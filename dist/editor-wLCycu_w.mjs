import { l as p, i as Je, a as os, U as Q$, e as Xa, b as ci, c as zr, d as Ro, K as Ph, E as X$, f as Ks, C as mi, g as Ja, h as R, j as ne, t as Se, B as Li, s as UB, k as Ee, m as Wg, n as BN, p as ir, o as He, q as Gu, w as J$, D as P, r as q, u as Zr, v as Xy, x as T_, y as me, z as e5, L as Ps, I as ut, A as HN, F as t5, G as i5, H as n5, J as s5, M as $B, N as vD, O as Ws, P as ur, Q as Os, R as Ur, S as o5, T as zt, V as ct, W as A, X as _x, Y as $n, Z as KB, _ as r5, $ as gr, a0 as L, a1 as rd, a2 as Ma, a3 as Fs, a4 as XR, a5, a6 as l5, a7 as Tt, a8 as d5, a9 as cf, aa as Yt, ab as nb, ac as VN, ad as Rn, ae as rs, af as c5, ag as JR, ah as h5, ai as u5, aj as zN, ak as oS, al as Jy, am as Of, an as ns, ao as ja, ap as kc, aq as e0, ar as ri, as as UN, at as vd, au as Hd, av as z, aw as $N, ax as Qt, ay as jB, az as eA, aA as tA, aB as bd, aC as So, aD as ge, aE as xc, aF as rS, aG as Yi, aH as g5, aI as qB, aJ as fr, aK as f5, aL as GB, aM as p5, aN as Bg, aO as Jb, aP as Vd, aQ as ZB, aR as Ic, aS as Ec, aT as ad, aU as N_, aV as qa, aW as YB, aX as Ff, aY as Cd, aZ as m5, a_ as Ba, a$ as Xd, b0 as KN, b1 as Tc, b2 as _5, b3 as Zm, b4 as cr, b5 as $r, b6 as v5, b7 as M_, b8 as QB, b9 as XB, ba as b5, bb as C5, bc as iA, bd as w5, be as S5, bf as JB, bg as eH, bh as y5, bi as L5, bj as jN, bk as tn, bl as nA, bm as Sw, bn as tH, bo as D5, bp as eC, bq as Ih, br as bD, bs as sA, bt as k5, bu as x5, bv as _r, bw as I5, bx as iH, by as E5, bz as T5, bA as Ym, bB as N5, bC as M5, bD as qN, bE as Yr, bF as t0, bG as R5, bH as fc, bI as A5, bJ as i0, bK as nH, bL as P5, bM as sH, bN as aS, bO as an, bP as O5, bQ as F5, bR as oH, bS as rH, bT as vx, bU as W5, bV as aH, bW as R_, bX as _s, bY as n0, bZ as Wf, b_ as B5, b$ as lH, c0 as cl, c1 as at, c2 as H5, c3 as V5, c4 as vu, c5 as CD, c6 as tC, c7 as dH, c8 as oA, c9 as z5, ca as rA, cb as cH, cc as aA, cd as U5, ce as hH, cf as uH, cg as $5, ch as lA, ci as gH, cj as K5, ck as j5, cl as q5, cm as G5, cn as Zu, co as Z5, cp as dA, cq as GN, cr as Y5, cs as Q5, ct as X5, cu as J5, cv as cA, cw as ZN, cx as fH, cy as pH, cz as eK, cA as tK, cB as iK, cC as nK, cD as sK, cE as oK, cF as rK, cG as aK, cH as lK, cI as dK, cJ as cK, cK as hK, cL as uK, cM as gK, cN as fK, cO as pK, cP as mK, cQ as _K, cR as vK, cS as bK, cT as CK, cU as wK, cV as SK, cW as yK, cX as LK, cY as DK, cZ as kK, c_ as xK, c$ as IK, d0 as EK, d1 as TK, d2 as NK, d3 as MK, d4 as RK, d5 as AK, d6 as PK, d7 as OK, d8 as FK, d9 as WK, da as BK, db as HK, dc as VK, dd as Lp, de as mH, df as zK, dg as _i, dh as YN, di as UK, dj as Me, dk as zi, dl as bx, dm as _H, dn as yw, dp as nu, dq as nr, dr as QN, ds as $K, dt as KK, du as hA, dv as jK, dw as vH, dx as lS, dy as Nc, dz as uA, dA as qK, dB as GK, dC as ZK, dD as XN, dE as YK, dF as gA, dG as Cx, dH as fA, dI as pc, dJ as wx, dK as QK, dL as XK, dM as JK, dN as bH, dO as CH, dP as ej, dQ as tj, dR as ij, dS as nj } from "./editorWorker-DuJkDQ_D.mjs";
const Tn = {
  tabSize: 4,
  indentSize: 4,
  insertSpaces: !0,
  detectIndentation: !0,
  trimAutoWhitespace: !0,
  largeFileOptimizations: !0,
  bracketPairColorizationOptions: {
    enabled: !0,
    independentColorPoolPerBracketType: !1
  }
}, Ca = 8;
class wH {
  /**
   * @internal
   */
  constructor(e) {
    this._values = e;
  }
  hasChanged(e) {
    return this._values[e];
  }
}
class SH {
  constructor() {
    this.stableMinimapLayoutInput = null, this.stableFitMaxMinimapScale = 0, this.stableFitRemainingWidth = 0;
  }
}
class Xt {
  constructor(e, t, i, n) {
    this.id = e, this.name = t, this.defaultValue = i, this.schema = n;
  }
  applyUpdate(e, t) {
    return s0(e, t);
  }
  compute(e, t, i) {
    return i;
  }
}
class Qm {
  constructor(e, t) {
    this.newValue = e, this.didChange = t;
  }
}
function s0(r, e) {
  if (typeof r != "object" || typeof e != "object" || !r || !e)
    return new Qm(e, r !== e);
  if (Array.isArray(r) || Array.isArray(e)) {
    const i = Array.isArray(r) && Array.isArray(e) && ci(r, e);
    return new Qm(e, !i);
  }
  let t = !1;
  for (const i in e)
    if (e.hasOwnProperty(i)) {
      const n = s0(r[i], e[i]);
      n.didChange && (r[i] = n.newValue, t = !0);
    }
  return new Qm(r, t);
}
class sb {
  constructor(e) {
    this.schema = void 0, this.id = e, this.name = "_never_", this.defaultValue = void 0;
  }
  applyUpdate(e, t) {
    return s0(e, t);
  }
  validate(e) {
    return this.defaultValue;
  }
}
class Dp {
  constructor(e, t, i, n) {
    this.id = e, this.name = t, this.defaultValue = i, this.schema = n;
  }
  applyUpdate(e, t) {
    return s0(e, t);
  }
  validate(e) {
    return typeof e > "u" ? this.defaultValue : e;
  }
  compute(e, t, i) {
    return i;
  }
}
function fe(r, e) {
  return typeof r > "u" ? e : r === "false" ? !1 : !!r;
}
class lt extends Dp {
  constructor(e, t, i, n = void 0) {
    typeof n < "u" && (n.type = "boolean", n.default = i), super(e, t, i, n);
  }
  validate(e) {
    return fe(e, this.defaultValue);
  }
}
function Eh(r, e, t, i) {
  if (typeof r > "u")
    return e;
  let n = parseInt(r, 10);
  return isNaN(n) ? e : (n = Math.max(t, n), n = Math.min(i, n), n | 0);
}
class Et extends Dp {
  static clampedInt(e, t, i, n) {
    return Eh(e, t, i, n);
  }
  constructor(e, t, i, n, s, o = void 0) {
    typeof o < "u" && (o.type = "integer", o.default = i, o.minimum = n, o.maximum = s), super(e, t, i, o), this.minimum = n, this.maximum = s;
  }
  validate(e) {
    return Et.clampedInt(e, this.defaultValue, this.minimum, this.maximum);
  }
}
function sj(r, e, t, i) {
  if (typeof r > "u")
    return e;
  const n = co.float(r, e);
  return co.clamp(n, t, i);
}
class co extends Dp {
  static clamp(e, t, i) {
    return e < t ? t : e > i ? i : e;
  }
  static float(e, t) {
    if (typeof e == "number")
      return e;
    if (typeof e > "u")
      return t;
    const i = parseFloat(e);
    return isNaN(i) ? t : i;
  }
  constructor(e, t, i, n, s) {
    typeof s < "u" && (s.type = "number", s.default = i), super(e, t, i, s), this.validationFn = n;
  }
  validate(e) {
    return this.validationFn(co.float(e, this.defaultValue));
  }
}
class Qn extends Dp {
  static string(e, t) {
    return typeof e != "string" ? t : e;
  }
  constructor(e, t, i, n = void 0) {
    typeof n < "u" && (n.type = "string", n.default = i), super(e, t, i, n);
  }
  validate(e) {
    return Qn.string(e, this.defaultValue);
  }
}
function gi(r, e, t, i) {
  return typeof r != "string" ? e : i && r in i ? i[r] : t.indexOf(r) === -1 ? e : r;
}
class oi extends Dp {
  constructor(e, t, i, n, s = void 0) {
    typeof s < "u" && (s.type = "string", s.enum = n, s.default = i), super(e, t, i, s), this._allowedValues = n;
  }
  validate(e) {
    return gi(e, this.defaultValue, this._allowedValues);
  }
}
class iC extends Xt {
  constructor(e, t, i, n, s, o, a = void 0) {
    typeof a < "u" && (a.type = "string", a.enum = s, a.default = n), super(e, t, i, a), this._allowedValues = s, this._convert = o;
  }
  validate(e) {
    return typeof e != "string" ? this.defaultValue : this._allowedValues.indexOf(e) === -1 ? this.defaultValue : this._convert(e);
  }
}
function oj(r) {
  switch (r) {
    case "none":
      return 0;
    case "keep":
      return 1;
    case "brackets":
      return 2;
    case "advanced":
      return 3;
    case "full":
      return 4;
  }
}
class rj extends Xt {
  constructor() {
    super(2, "accessibilitySupport", 0, {
      type: "string",
      enum: ["auto", "on", "off"],
      enumDescriptions: [
        p("accessibilitySupport.auto", "Use platform APIs to detect when a Screen Reader is attached."),
        p("accessibilitySupport.on", "Optimize for usage with a Screen Reader."),
        p("accessibilitySupport.off", "Assume a screen reader is not attached.")
      ],
      default: "auto",
      tags: ["accessibility"],
      description: p("accessibilitySupport", "Controls if the UI should run in a mode where it is optimized for screen readers.")
    });
  }
  validate(e) {
    switch (e) {
      case "auto":
        return 0;
      case "off":
        return 1;
      case "on":
        return 2;
    }
    return this.defaultValue;
  }
  compute(e, t, i) {
    return i === 0 ? e.accessibilitySupport : i;
  }
}
class aj extends Xt {
  constructor() {
    const e = {
      insertSpace: !0,
      ignoreEmptyLines: !0
    };
    super(23, "comments", e, {
      "editor.comments.insertSpace": {
        type: "boolean",
        default: e.insertSpace,
        description: p("comments.insertSpace", "Controls whether a space character is inserted when commenting.")
      },
      "editor.comments.ignoreEmptyLines": {
        type: "boolean",
        default: e.ignoreEmptyLines,
        description: p("comments.ignoreEmptyLines", "Controls if empty lines should be ignored with toggle, add or remove actions for line comments.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      insertSpace: fe(t.insertSpace, this.defaultValue.insertSpace),
      ignoreEmptyLines: fe(t.ignoreEmptyLines, this.defaultValue.ignoreEmptyLines)
    };
  }
}
function lj(r) {
  switch (r) {
    case "blink":
      return 1;
    case "smooth":
      return 2;
    case "phase":
      return 3;
    case "expand":
      return 4;
    case "solid":
      return 5;
  }
}
var gn;
(function(r) {
  r[r.Line = 1] = "Line", r[r.Block = 2] = "Block", r[r.Underline = 3] = "Underline", r[r.LineThin = 4] = "LineThin", r[r.BlockOutline = 5] = "BlockOutline", r[r.UnderlineThin = 6] = "UnderlineThin";
})(gn || (gn = {}));
function dj(r) {
  switch (r) {
    case "line":
      return gn.Line;
    case "block":
      return gn.Block;
    case "underline":
      return gn.Underline;
    case "line-thin":
      return gn.LineThin;
    case "block-outline":
      return gn.BlockOutline;
    case "underline-thin":
      return gn.UnderlineThin;
  }
}
class cj extends sb {
  constructor() {
    super(
      142
      /* EditorOption.editorClassName */
    );
  }
  compute(e, t, i) {
    const n = ["monaco-editor"];
    return t.get(
      39
      /* EditorOption.extraEditorClassName */
    ) && n.push(t.get(
      39
      /* EditorOption.extraEditorClassName */
    )), e.extraEditorClassName && n.push(e.extraEditorClassName), t.get(
      74
      /* EditorOption.mouseStyle */
    ) === "default" ? n.push("mouse-default") : t.get(
      74
      /* EditorOption.mouseStyle */
    ) === "copy" && n.push("mouse-copy"), t.get(
      111
      /* EditorOption.showUnused */
    ) && n.push("showUnused"), t.get(
      140
      /* EditorOption.showDeprecated */
    ) && n.push("showDeprecated"), n.join(" ");
  }
}
class hj extends lt {
  constructor() {
    super(37, "emptySelectionClipboard", !0, { description: p("emptySelectionClipboard", "Controls whether copying without a selection copies the current line.") });
  }
  compute(e, t, i) {
    return i && e.emptySelectionClipboard;
  }
}
class uj extends Xt {
  constructor() {
    const e = {
      cursorMoveOnType: !0,
      seedSearchStringFromSelection: "always",
      autoFindInSelection: "never",
      globalFindClipboard: !1,
      addExtraSpaceOnTop: !0,
      loop: !0
    };
    super(41, "find", e, {
      "editor.find.cursorMoveOnType": {
        type: "boolean",
        default: e.cursorMoveOnType,
        description: p("find.cursorMoveOnType", "Controls whether the cursor should jump to find matches while typing.")
      },
      "editor.find.seedSearchStringFromSelection": {
        type: "string",
        enum: ["never", "always", "selection"],
        default: e.seedSearchStringFromSelection,
        enumDescriptions: [
          p("editor.find.seedSearchStringFromSelection.never", "Never seed search string from the editor selection."),
          p("editor.find.seedSearchStringFromSelection.always", "Always seed search string from the editor selection, including word at cursor position."),
          p("editor.find.seedSearchStringFromSelection.selection", "Only seed search string from the editor selection.")
        ],
        description: p("find.seedSearchStringFromSelection", "Controls whether the search string in the Find Widget is seeded from the editor selection.")
      },
      "editor.find.autoFindInSelection": {
        type: "string",
        enum: ["never", "always", "multiline"],
        default: e.autoFindInSelection,
        enumDescriptions: [
          p("editor.find.autoFindInSelection.never", "Never turn on Find in Selection automatically (default)."),
          p("editor.find.autoFindInSelection.always", "Always turn on Find in Selection automatically."),
          p("editor.find.autoFindInSelection.multiline", "Turn on Find in Selection automatically when multiple lines of content are selected.")
        ],
        description: p("find.autoFindInSelection", "Controls the condition for turning on Find in Selection automatically.")
      },
      "editor.find.globalFindClipboard": {
        type: "boolean",
        default: e.globalFindClipboard,
        description: p("find.globalFindClipboard", "Controls whether the Find Widget should read or modify the shared find clipboard on macOS."),
        included: Je
      },
      "editor.find.addExtraSpaceOnTop": {
        type: "boolean",
        default: e.addExtraSpaceOnTop,
        description: p("find.addExtraSpaceOnTop", "Controls whether the Find Widget should add extra lines on top of the editor. When true, you can scroll beyond the first line when the Find Widget is visible.")
      },
      "editor.find.loop": {
        type: "boolean",
        default: e.loop,
        description: p("find.loop", "Controls whether the search automatically restarts from the beginning (or the end) when no further matches can be found.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      cursorMoveOnType: fe(t.cursorMoveOnType, this.defaultValue.cursorMoveOnType),
      seedSearchStringFromSelection: typeof e.seedSearchStringFromSelection == "boolean" ? e.seedSearchStringFromSelection ? "always" : "never" : gi(t.seedSearchStringFromSelection, this.defaultValue.seedSearchStringFromSelection, ["never", "always", "selection"]),
      autoFindInSelection: typeof e.autoFindInSelection == "boolean" ? e.autoFindInSelection ? "always" : "never" : gi(t.autoFindInSelection, this.defaultValue.autoFindInSelection, ["never", "always", "multiline"]),
      globalFindClipboard: fe(t.globalFindClipboard, this.defaultValue.globalFindClipboard),
      addExtraSpaceOnTop: fe(t.addExtraSpaceOnTop, this.defaultValue.addExtraSpaceOnTop),
      loop: fe(t.loop, this.defaultValue.loop)
    };
  }
}
class ro extends Xt {
  constructor() {
    super(51, "fontLigatures", ro.OFF, {
      anyOf: [
        {
          type: "boolean",
          description: p("fontLigatures", "Enables/Disables font ligatures ('calt' and 'liga' font features). Change this to a string for fine-grained control of the 'font-feature-settings' CSS property.")
        },
        {
          type: "string",
          description: p("fontFeatureSettings", "Explicit 'font-feature-settings' CSS property. A boolean can be passed instead if one only needs to turn on/off ligatures.")
        }
      ],
      description: p("fontLigaturesGeneral", "Configures font ligatures or font features. Can be either a boolean to enable/disable ligatures or a string for the value of the CSS 'font-feature-settings' property."),
      default: !1
    });
  }
  validate(e) {
    return typeof e > "u" ? this.defaultValue : typeof e == "string" ? e === "false" || e.length === 0 ? ro.OFF : e === "true" ? ro.ON : e : e ? ro.ON : ro.OFF;
  }
}
ro.OFF = '"liga" off, "calt" off';
ro.ON = '"liga" on, "calt" on';
class Or extends Xt {
  constructor() {
    super(54, "fontVariations", Or.OFF, {
      anyOf: [
        {
          type: "boolean",
          description: p("fontVariations", "Enables/Disables the translation from font-weight to font-variation-settings. Change this to a string for fine-grained control of the 'font-variation-settings' CSS property.")
        },
        {
          type: "string",
          description: p("fontVariationSettings", "Explicit 'font-variation-settings' CSS property. A boolean can be passed instead if one only needs to translate font-weight to font-variation-settings.")
        }
      ],
      description: p("fontVariationsGeneral", "Configures font variations. Can be either a boolean to enable/disable the translation from font-weight to font-variation-settings or a string for the value of the CSS 'font-variation-settings' property."),
      default: !1
    });
  }
  validate(e) {
    return typeof e > "u" ? this.defaultValue : typeof e == "string" ? e === "false" ? Or.OFF : e === "true" ? Or.TRANSLATE : e : e ? Or.TRANSLATE : Or.OFF;
  }
  compute(e, t, i) {
    return e.fontInfo.fontVariationSettings;
  }
}
Or.OFF = "normal";
Or.TRANSLATE = "translate";
class gj extends sb {
  constructor() {
    super(
      50
      /* EditorOption.fontInfo */
    );
  }
  compute(e, t, i) {
    return e.fontInfo;
  }
}
class fj extends Dp {
  constructor() {
    super(52, "fontSize", Ss.fontSize, {
      type: "number",
      minimum: 6,
      maximum: 100,
      default: Ss.fontSize,
      description: p("fontSize", "Controls the font size in pixels.")
    });
  }
  validate(e) {
    const t = co.float(e, this.defaultValue);
    return t === 0 ? Ss.fontSize : co.clamp(t, 6, 100);
  }
  compute(e, t, i) {
    return e.fontInfo.fontSize;
  }
}
class Ra extends Xt {
  constructor() {
    super(53, "fontWeight", Ss.fontWeight, {
      anyOf: [
        {
          type: "number",
          minimum: Ra.MINIMUM_VALUE,
          maximum: Ra.MAXIMUM_VALUE,
          errorMessage: p("fontWeightErrorMessage", 'Only "normal" and "bold" keywords or numbers between 1 and 1000 are allowed.')
        },
        {
          type: "string",
          pattern: "^(normal|bold|1000|[1-9][0-9]{0,2})$"
        },
        {
          enum: Ra.SUGGESTION_VALUES
        }
      ],
      default: Ss.fontWeight,
      description: p("fontWeight", 'Controls the font weight. Accepts "normal" and "bold" keywords or numbers between 1 and 1000.')
    });
  }
  validate(e) {
    return e === "normal" || e === "bold" ? e : String(Et.clampedInt(e, Ss.fontWeight, Ra.MINIMUM_VALUE, Ra.MAXIMUM_VALUE));
  }
}
Ra.SUGGESTION_VALUES = ["normal", "bold", "100", "200", "300", "400", "500", "600", "700", "800", "900"];
Ra.MINIMUM_VALUE = 1;
Ra.MAXIMUM_VALUE = 1e3;
class pj extends Xt {
  constructor() {
    const e = {
      multiple: "peek",
      multipleDefinitions: "peek",
      multipleTypeDefinitions: "peek",
      multipleDeclarations: "peek",
      multipleImplementations: "peek",
      multipleReferences: "peek",
      alternativeDefinitionCommand: "editor.action.goToReferences",
      alternativeTypeDefinitionCommand: "editor.action.goToReferences",
      alternativeDeclarationCommand: "editor.action.goToReferences",
      alternativeImplementationCommand: "",
      alternativeReferenceCommand: ""
    }, t = {
      type: "string",
      enum: ["peek", "gotoAndPeek", "goto"],
      default: e.multiple,
      enumDescriptions: [
        p("editor.gotoLocation.multiple.peek", "Show Peek view of the results (default)"),
        p("editor.gotoLocation.multiple.gotoAndPeek", "Go to the primary result and show a Peek view"),
        p("editor.gotoLocation.multiple.goto", "Go to the primary result and enable Peek-less navigation to others")
      ]
    }, i = ["", "editor.action.referenceSearch.trigger", "editor.action.goToReferences", "editor.action.peekImplementation", "editor.action.goToImplementation", "editor.action.peekTypeDefinition", "editor.action.goToTypeDefinition", "editor.action.peekDeclaration", "editor.action.revealDeclaration", "editor.action.peekDefinition", "editor.action.revealDefinitionAside", "editor.action.revealDefinition"];
    super(58, "gotoLocation", e, {
      "editor.gotoLocation.multiple": {
        deprecationMessage: p("editor.gotoLocation.multiple.deprecated", "This setting is deprecated, please use separate settings like 'editor.editor.gotoLocation.multipleDefinitions' or 'editor.editor.gotoLocation.multipleImplementations' instead.")
      },
      "editor.gotoLocation.multipleDefinitions": {
        description: p("editor.editor.gotoLocation.multipleDefinitions", "Controls the behavior the 'Go to Definition'-command when multiple target locations exist."),
        ...t
      },
      "editor.gotoLocation.multipleTypeDefinitions": {
        description: p("editor.editor.gotoLocation.multipleTypeDefinitions", "Controls the behavior the 'Go to Type Definition'-command when multiple target locations exist."),
        ...t
      },
      "editor.gotoLocation.multipleDeclarations": {
        description: p("editor.editor.gotoLocation.multipleDeclarations", "Controls the behavior the 'Go to Declaration'-command when multiple target locations exist."),
        ...t
      },
      "editor.gotoLocation.multipleImplementations": {
        description: p("editor.editor.gotoLocation.multipleImplemenattions", "Controls the behavior the 'Go to Implementations'-command when multiple target locations exist."),
        ...t
      },
      "editor.gotoLocation.multipleReferences": {
        description: p("editor.editor.gotoLocation.multipleReferences", "Controls the behavior the 'Go to References'-command when multiple target locations exist."),
        ...t
      },
      "editor.gotoLocation.alternativeDefinitionCommand": {
        type: "string",
        default: e.alternativeDefinitionCommand,
        enum: i,
        description: p("alternativeDefinitionCommand", "Alternative command id that is being executed when the result of 'Go to Definition' is the current location.")
      },
      "editor.gotoLocation.alternativeTypeDefinitionCommand": {
        type: "string",
        default: e.alternativeTypeDefinitionCommand,
        enum: i,
        description: p("alternativeTypeDefinitionCommand", "Alternative command id that is being executed when the result of 'Go to Type Definition' is the current location.")
      },
      "editor.gotoLocation.alternativeDeclarationCommand": {
        type: "string",
        default: e.alternativeDeclarationCommand,
        enum: i,
        description: p("alternativeDeclarationCommand", "Alternative command id that is being executed when the result of 'Go to Declaration' is the current location.")
      },
      "editor.gotoLocation.alternativeImplementationCommand": {
        type: "string",
        default: e.alternativeImplementationCommand,
        enum: i,
        description: p("alternativeImplementationCommand", "Alternative command id that is being executed when the result of 'Go to Implementation' is the current location.")
      },
      "editor.gotoLocation.alternativeReferenceCommand": {
        type: "string",
        default: e.alternativeReferenceCommand,
        enum: i,
        description: p("alternativeReferenceCommand", "Alternative command id that is being executed when the result of 'Go to Reference' is the current location.")
      }
    });
  }
  validate(e) {
    var t, i, n, s, o;
    if (!e || typeof e != "object")
      return this.defaultValue;
    const a = e;
    return {
      multiple: gi(a.multiple, this.defaultValue.multiple, ["peek", "gotoAndPeek", "goto"]),
      multipleDefinitions: (t = a.multipleDefinitions) !== null && t !== void 0 ? t : gi(a.multipleDefinitions, "peek", ["peek", "gotoAndPeek", "goto"]),
      multipleTypeDefinitions: (i = a.multipleTypeDefinitions) !== null && i !== void 0 ? i : gi(a.multipleTypeDefinitions, "peek", ["peek", "gotoAndPeek", "goto"]),
      multipleDeclarations: (n = a.multipleDeclarations) !== null && n !== void 0 ? n : gi(a.multipleDeclarations, "peek", ["peek", "gotoAndPeek", "goto"]),
      multipleImplementations: (s = a.multipleImplementations) !== null && s !== void 0 ? s : gi(a.multipleImplementations, "peek", ["peek", "gotoAndPeek", "goto"]),
      multipleReferences: (o = a.multipleReferences) !== null && o !== void 0 ? o : gi(a.multipleReferences, "peek", ["peek", "gotoAndPeek", "goto"]),
      alternativeDefinitionCommand: Qn.string(a.alternativeDefinitionCommand, this.defaultValue.alternativeDefinitionCommand),
      alternativeTypeDefinitionCommand: Qn.string(a.alternativeTypeDefinitionCommand, this.defaultValue.alternativeTypeDefinitionCommand),
      alternativeDeclarationCommand: Qn.string(a.alternativeDeclarationCommand, this.defaultValue.alternativeDeclarationCommand),
      alternativeImplementationCommand: Qn.string(a.alternativeImplementationCommand, this.defaultValue.alternativeImplementationCommand),
      alternativeReferenceCommand: Qn.string(a.alternativeReferenceCommand, this.defaultValue.alternativeReferenceCommand)
    };
  }
}
class mj extends Xt {
  constructor() {
    const e = {
      enabled: !0,
      delay: 300,
      hidingDelay: 300,
      sticky: !0,
      above: !0
    };
    super(60, "hover", e, {
      "editor.hover.enabled": {
        type: "boolean",
        default: e.enabled,
        description: p("hover.enabled", "Controls whether the hover is shown.")
      },
      "editor.hover.delay": {
        type: "number",
        default: e.delay,
        minimum: 0,
        maximum: 1e4,
        description: p("hover.delay", "Controls the delay in milliseconds after which the hover is shown.")
      },
      "editor.hover.sticky": {
        type: "boolean",
        default: e.sticky,
        description: p("hover.sticky", "Controls whether the hover should remain visible when mouse is moved over it.")
      },
      "editor.hover.hidingDelay": {
        type: "integer",
        minimum: 0,
        default: e.hidingDelay,
        description: p("hover.hidingDelay", "Controls the delay in milliseconds after which the hover is hidden. Requires `editor.hover.sticky` to be enabled.")
      },
      "editor.hover.above": {
        type: "boolean",
        default: e.above,
        description: p("hover.above", "Prefer showing hovers above the line, if there's space.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      enabled: fe(t.enabled, this.defaultValue.enabled),
      delay: Et.clampedInt(t.delay, this.defaultValue.delay, 0, 1e4),
      sticky: fe(t.sticky, this.defaultValue.sticky),
      hidingDelay: Et.clampedInt(t.hidingDelay, this.defaultValue.hidingDelay, 0, 6e5),
      above: fe(t.above, this.defaultValue.above)
    };
  }
}
class hf extends sb {
  constructor() {
    super(
      145
      /* EditorOption.layoutInfo */
    );
  }
  compute(e, t, i) {
    return hf.computeLayout(t, {
      memory: e.memory,
      outerWidth: e.outerWidth,
      outerHeight: e.outerHeight,
      isDominatedByLongLines: e.isDominatedByLongLines,
      lineHeight: e.fontInfo.lineHeight,
      viewLineCount: e.viewLineCount,
      lineNumbersDigitCount: e.lineNumbersDigitCount,
      typicalHalfwidthCharacterWidth: e.fontInfo.typicalHalfwidthCharacterWidth,
      maxDigitWidth: e.fontInfo.maxDigitWidth,
      pixelRatio: e.pixelRatio,
      glyphMarginDecorationLaneCount: e.glyphMarginDecorationLaneCount
    });
  }
  static computeContainedMinimapLineCount(e) {
    const t = e.height / e.lineHeight, i = Math.floor(e.paddingTop / e.lineHeight);
    let n = Math.floor(e.paddingBottom / e.lineHeight);
    e.scrollBeyondLastLine && (n = Math.max(n, t - 1));
    const s = (i + e.viewLineCount + n) / (e.pixelRatio * e.height), o = Math.floor(e.viewLineCount / s);
    return { typicalViewportLineCount: t, extraLinesBeforeFirstLine: i, extraLinesBeyondLastLine: n, desiredRatio: s, minimapLineCount: o };
  }
  static _computeMinimapLayout(e, t) {
    const i = e.outerWidth, n = e.outerHeight, s = e.pixelRatio;
    if (!e.minimap.enabled)
      return {
        renderMinimap: 0,
        minimapLeft: 0,
        minimapWidth: 0,
        minimapHeightIsEditorHeight: !1,
        minimapIsSampling: !1,
        minimapScale: 1,
        minimapLineHeight: 1,
        minimapCanvasInnerWidth: 0,
        minimapCanvasInnerHeight: Math.floor(s * n),
        minimapCanvasOuterWidth: 0,
        minimapCanvasOuterHeight: n
      };
    const o = t.stableMinimapLayoutInput, a = o && e.outerHeight === o.outerHeight && e.lineHeight === o.lineHeight && e.typicalHalfwidthCharacterWidth === o.typicalHalfwidthCharacterWidth && e.pixelRatio === o.pixelRatio && e.scrollBeyondLastLine === o.scrollBeyondLastLine && e.paddingTop === o.paddingTop && e.paddingBottom === o.paddingBottom && e.minimap.enabled === o.minimap.enabled && e.minimap.side === o.minimap.side && e.minimap.size === o.minimap.size && e.minimap.showSlider === o.minimap.showSlider && e.minimap.renderCharacters === o.minimap.renderCharacters && e.minimap.maxColumn === o.minimap.maxColumn && e.minimap.scale === o.minimap.scale && e.verticalScrollbarWidth === o.verticalScrollbarWidth && e.isViewportWrapping === o.isViewportWrapping, l = e.lineHeight, d = e.typicalHalfwidthCharacterWidth, c = e.scrollBeyondLastLine, h = e.minimap.renderCharacters;
    let u = s >= 2 ? Math.round(e.minimap.scale * 2) : e.minimap.scale;
    const g = e.minimap.maxColumn, f = e.minimap.size, m = e.minimap.side, _ = e.verticalScrollbarWidth, v = e.viewLineCount, b = e.remainingWidth, C = e.isViewportWrapping, w = h ? 2 : 3;
    let S = Math.floor(s * n);
    const y = S / s;
    let k = !1, E = !1, N = w * u, F = u / s, V = 1;
    if (f === "fill" || f === "fit") {
      const { typicalViewportLineCount: ze, extraLinesBeforeFirstLine: pe, extraLinesBeyondLastLine: $e, desiredRatio: Be, minimapLineCount: Te } = hf.computeContainedMinimapLineCount({
        viewLineCount: v,
        scrollBeyondLastLine: c,
        paddingTop: e.paddingTop,
        paddingBottom: e.paddingBottom,
        height: n,
        lineHeight: l,
        pixelRatio: s
      });
      if (v / Te > 1)
        k = !0, E = !0, u = 1, N = 1, F = u / s;
      else {
        let Fi = !1, Is = u + 1;
        if (f === "fit") {
          const Qi = Math.ceil((pe + v + $e) * N);
          C && a && b <= t.stableFitRemainingWidth ? (Fi = !0, Is = t.stableFitMaxMinimapScale) : Fi = Qi > S;
        }
        if (f === "fill" || Fi) {
          k = !0;
          const Qi = u;
          N = Math.min(l * s, Math.max(1, Math.floor(1 / Be))), C && a && b <= t.stableFitRemainingWidth && (Is = t.stableFitMaxMinimapScale), u = Math.min(Is, Math.max(1, Math.floor(N / w))), u > Qi && (V = Math.min(2, u / Qi)), F = u / s / V, S = Math.ceil(Math.max(ze, pe + v + $e) * N), C ? (t.stableMinimapLayoutInput = e, t.stableFitRemainingWidth = b, t.stableFitMaxMinimapScale = u) : (t.stableMinimapLayoutInput = null, t.stableFitRemainingWidth = 0);
        }
      }
    }
    const Z = Math.floor(g * F), H = Math.min(Z, Math.max(0, Math.floor((b - _ - 2) * F / (d + F))) + Ca);
    let re = Math.floor(s * H);
    const ue = re / s;
    re = Math.floor(re * V);
    const Ve = h ? 1 : 2, Ye = m === "left" ? 0 : i - H - _;
    return {
      renderMinimap: Ve,
      minimapLeft: Ye,
      minimapWidth: H,
      minimapHeightIsEditorHeight: k,
      minimapIsSampling: E,
      minimapScale: u,
      minimapLineHeight: N,
      minimapCanvasInnerWidth: re,
      minimapCanvasInnerHeight: S,
      minimapCanvasOuterWidth: ue,
      minimapCanvasOuterHeight: y
    };
  }
  static computeLayout(e, t) {
    const i = t.outerWidth | 0, n = t.outerHeight | 0, s = t.lineHeight | 0, o = t.lineNumbersDigitCount | 0, a = t.typicalHalfwidthCharacterWidth, l = t.maxDigitWidth, d = t.pixelRatio, c = t.viewLineCount, h = e.get(
      137
      /* EditorOption.wordWrapOverride2 */
    ), u = h === "inherit" ? e.get(
      136
      /* EditorOption.wordWrapOverride1 */
    ) : h, g = u === "inherit" ? e.get(
      132
      /* EditorOption.wordWrap */
    ) : u, f = e.get(
      135
      /* EditorOption.wordWrapColumn */
    ), m = t.isDominatedByLongLines, _ = e.get(
      57
      /* EditorOption.glyphMargin */
    ), v = e.get(
      68
      /* EditorOption.lineNumbers */
    ).renderType !== 0, b = e.get(
      69
      /* EditorOption.lineNumbersMinChars */
    ), C = e.get(
      105
      /* EditorOption.scrollBeyondLastLine */
    ), w = e.get(
      84
      /* EditorOption.padding */
    ), S = e.get(
      73
      /* EditorOption.minimap */
    ), y = e.get(
      103
      /* EditorOption.scrollbar */
    ), k = y.verticalScrollbarSize, E = y.verticalHasArrows, N = y.arrowSize, F = y.horizontalScrollbarSize, V = e.get(
      43
      /* EditorOption.folding */
    ), Z = e.get(
      110
      /* EditorOption.showFoldingControls */
    ) !== "never";
    let H = e.get(
      66
      /* EditorOption.lineDecorationsWidth */
    );
    V && Z && (H += 16);
    let re = 0;
    if (v) {
      const Ki = Math.max(o, b);
      re = Math.round(Ki * l);
    }
    let ue = 0;
    _ && (ue = s * t.glyphMarginDecorationLaneCount);
    let Ve = 0, Ye = Ve + ue, ze = Ye + re, pe = ze + H;
    const $e = i - ue - re - H;
    let Be = !1, Te = !1, ce = -1;
    u === "inherit" && m ? (Be = !0, Te = !0) : g === "on" || g === "bounded" ? Te = !0 : g === "wordWrapColumn" && (ce = f);
    const Fi = hf._computeMinimapLayout({
      outerWidth: i,
      outerHeight: n,
      lineHeight: s,
      typicalHalfwidthCharacterWidth: a,
      pixelRatio: d,
      scrollBeyondLastLine: C,
      paddingTop: w.top,
      paddingBottom: w.bottom,
      minimap: S,
      verticalScrollbarWidth: k,
      viewLineCount: c,
      remainingWidth: $e,
      isViewportWrapping: Te
    }, t.memory || new SH());
    Fi.renderMinimap !== 0 && Fi.minimapLeft === 0 && (Ve += Fi.minimapWidth, Ye += Fi.minimapWidth, ze += Fi.minimapWidth, pe += Fi.minimapWidth);
    const Is = $e - Fi.minimapWidth, Qi = Math.max(1, Math.floor((Is - k - 2) / a)), Ct = E ? N : 0;
    return Te && (ce = Math.max(1, Qi), g === "bounded" && (ce = Math.min(ce, f))), {
      width: i,
      height: n,
      glyphMarginLeft: Ve,
      glyphMarginWidth: ue,
      glyphMarginDecorationLaneCount: t.glyphMarginDecorationLaneCount,
      lineNumbersLeft: Ye,
      lineNumbersWidth: re,
      decorationsLeft: ze,
      decorationsWidth: H,
      contentLeft: pe,
      contentWidth: Is,
      minimap: Fi,
      viewportColumn: Qi,
      isWordWrapMinified: Be,
      isViewportWrapping: Te,
      wrappingColumn: ce,
      verticalScrollbarWidth: k,
      horizontalScrollbarHeight: F,
      overviewRuler: {
        top: Ct,
        width: k,
        height: n - 2 * Ct,
        right: 0
      }
    };
  }
}
class _j extends Xt {
  constructor() {
    super(139, "wrappingStrategy", "simple", {
      "editor.wrappingStrategy": {
        enumDescriptions: [
          p("wrappingStrategy.simple", "Assumes that all characters are of the same width. This is a fast algorithm that works correctly for monospace fonts and certain scripts (like Latin characters) where glyphs are of equal width."),
          p("wrappingStrategy.advanced", "Delegates wrapping points computation to the browser. This is a slow algorithm, that might cause freezes for large files, but it works correctly in all cases.")
        ],
        type: "string",
        enum: ["simple", "advanced"],
        default: "simple",
        description: p("wrappingStrategy", "Controls the algorithm that computes wrapping points. Note that when in accessibility mode, advanced will be used for the best experience.")
      }
    });
  }
  validate(e) {
    return gi(e, "simple", ["simple", "advanced"]);
  }
  compute(e, t, i) {
    return t.get(
      2
      /* EditorOption.accessibilitySupport */
    ) === 2 ? "advanced" : i;
  }
}
var tr;
(function(r) {
  r.Off = "off", r.OnCode = "onCode", r.On = "on";
})(tr || (tr = {}));
class vj extends Xt {
  constructor() {
    const e = { enabled: tr.On };
    super(65, "lightbulb", e, {
      "editor.lightbulb.enabled": {
        type: "string",
        tags: ["experimental"],
        enum: [tr.Off, tr.OnCode, tr.On],
        default: e.enabled,
        enumDescriptions: [
          p("editor.lightbulb.enabled.off", "Disable the code action menu."),
          p("editor.lightbulb.enabled.onCode", "Show the code action menu when the cursor is on lines with code."),
          p("editor.lightbulb.enabled.on", "Show the code action menu when the cursor is on lines with code or on empty lines.")
        ],
        description: p("enabled", "Enables the Code Action lightbulb in the editor.")
      }
    });
  }
  validate(e) {
    return !e || typeof e != "object" ? this.defaultValue : {
      enabled: gi(e.enabled, this.defaultValue.enabled, [tr.Off, tr.OnCode, tr.On])
    };
  }
}
class bj extends Xt {
  constructor() {
    const e = { enabled: !0, maxLineCount: 5, defaultModel: "outlineModel", scrollWithEditor: !0 };
    super(115, "stickyScroll", e, {
      "editor.stickyScroll.enabled": {
        type: "boolean",
        default: e.enabled,
        description: p("editor.stickyScroll.enabled", "Shows the nested current scopes during the scroll at the top of the editor."),
        tags: ["experimental"]
      },
      "editor.stickyScroll.maxLineCount": {
        type: "number",
        default: e.maxLineCount,
        minimum: 1,
        maximum: 20,
        description: p("editor.stickyScroll.maxLineCount", "Defines the maximum number of sticky lines to show.")
      },
      "editor.stickyScroll.defaultModel": {
        type: "string",
        enum: ["outlineModel", "foldingProviderModel", "indentationModel"],
        default: e.defaultModel,
        description: p("editor.stickyScroll.defaultModel", "Defines the model to use for determining which lines to stick. If the outline model does not exist, it will fall back on the folding provider model which falls back on the indentation model. This order is respected in all three cases.")
      },
      "editor.stickyScroll.scrollWithEditor": {
        type: "boolean",
        default: e.scrollWithEditor,
        description: p("editor.stickyScroll.scrollWithEditor", "Enable scrolling of Sticky Scroll with the editor's horizontal scrollbar.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      enabled: fe(t.enabled, this.defaultValue.enabled),
      maxLineCount: Et.clampedInt(t.maxLineCount, this.defaultValue.maxLineCount, 1, 20),
      defaultModel: gi(t.defaultModel, this.defaultValue.defaultModel, ["outlineModel", "foldingProviderModel", "indentationModel"]),
      scrollWithEditor: fe(t.scrollWithEditor, this.defaultValue.scrollWithEditor)
    };
  }
}
class Cj extends Xt {
  constructor() {
    const e = { enabled: "on", fontSize: 0, fontFamily: "", padding: !1 };
    super(141, "inlayHints", e, {
      "editor.inlayHints.enabled": {
        type: "string",
        default: e.enabled,
        description: p("inlayHints.enable", "Enables the inlay hints in the editor."),
        enum: ["on", "onUnlessPressed", "offUnlessPressed", "off"],
        markdownEnumDescriptions: [
          p("editor.inlayHints.on", "Inlay hints are enabled"),
          p("editor.inlayHints.onUnlessPressed", "Inlay hints are showing by default and hide when holding {0}", Je ? "Ctrl+Option" : "Ctrl+Alt"),
          p("editor.inlayHints.offUnlessPressed", "Inlay hints are hidden by default and show when holding {0}", Je ? "Ctrl+Option" : "Ctrl+Alt"),
          p("editor.inlayHints.off", "Inlay hints are disabled")
        ]
      },
      "editor.inlayHints.fontSize": {
        type: "number",
        default: e.fontSize,
        markdownDescription: p("inlayHints.fontSize", "Controls font size of inlay hints in the editor. As default the {0} is used when the configured value is less than {1} or greater than the editor font size.", "`#editor.fontSize#`", "`5`")
      },
      "editor.inlayHints.fontFamily": {
        type: "string",
        default: e.fontFamily,
        markdownDescription: p("inlayHints.fontFamily", "Controls font family of inlay hints in the editor. When set to empty, the {0} is used.", "`#editor.fontFamily#`")
      },
      "editor.inlayHints.padding": {
        type: "boolean",
        default: e.padding,
        description: p("inlayHints.padding", "Enables the padding around the inlay hints in the editor.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return typeof t.enabled == "boolean" && (t.enabled = t.enabled ? "on" : "off"), {
      enabled: gi(t.enabled, this.defaultValue.enabled, ["on", "off", "offUnlessPressed", "onUnlessPressed"]),
      fontSize: Et.clampedInt(t.fontSize, this.defaultValue.fontSize, 0, 100),
      fontFamily: Qn.string(t.fontFamily, this.defaultValue.fontFamily),
      padding: fe(t.padding, this.defaultValue.padding)
    };
  }
}
class wj extends Xt {
  constructor() {
    super(66, "lineDecorationsWidth", 10);
  }
  validate(e) {
    return typeof e == "string" && /^\d+(\.\d+)?ch$/.test(e) ? -parseFloat(e.substring(0, e.length - 2)) : Et.clampedInt(e, this.defaultValue, 0, 1e3);
  }
  compute(e, t, i) {
    return i < 0 ? Et.clampedInt(-i * e.fontInfo.typicalHalfwidthCharacterWidth, this.defaultValue, 0, 1e3) : i;
  }
}
class Sj extends co {
  constructor() {
    super(67, "lineHeight", Ss.lineHeight, (e) => co.clamp(e, 0, 150), { markdownDescription: p("lineHeight", `Controls the line height. 
 - Use 0 to automatically compute the line height from the font size.
 - Values between 0 and 8 will be used as a multiplier with the font size.
 - Values greater than or equal to 8 will be used as effective values.`) });
  }
  compute(e, t, i) {
    return e.fontInfo.lineHeight;
  }
}
class yj extends Xt {
  constructor() {
    const e = {
      enabled: !0,
      size: "proportional",
      side: "right",
      showSlider: "mouseover",
      autohide: !1,
      renderCharacters: !0,
      maxColumn: 120,
      scale: 1,
      showRegionSectionHeaders: !0,
      showMarkSectionHeaders: !0,
      sectionHeaderFontSize: 9,
      sectionHeaderLetterSpacing: 1
    };
    super(73, "minimap", e, {
      "editor.minimap.enabled": {
        type: "boolean",
        default: e.enabled,
        description: p("minimap.enabled", "Controls whether the minimap is shown.")
      },
      "editor.minimap.autohide": {
        type: "boolean",
        default: e.autohide,
        description: p("minimap.autohide", "Controls whether the minimap is hidden automatically.")
      },
      "editor.minimap.size": {
        type: "string",
        enum: ["proportional", "fill", "fit"],
        enumDescriptions: [
          p("minimap.size.proportional", "The minimap has the same size as the editor contents (and might scroll)."),
          p("minimap.size.fill", "The minimap will stretch or shrink as necessary to fill the height of the editor (no scrolling)."),
          p("minimap.size.fit", "The minimap will shrink as necessary to never be larger than the editor (no scrolling).")
        ],
        default: e.size,
        description: p("minimap.size", "Controls the size of the minimap.")
      },
      "editor.minimap.side": {
        type: "string",
        enum: ["left", "right"],
        default: e.side,
        description: p("minimap.side", "Controls the side where to render the minimap.")
      },
      "editor.minimap.showSlider": {
        type: "string",
        enum: ["always", "mouseover"],
        default: e.showSlider,
        description: p("minimap.showSlider", "Controls when the minimap slider is shown.")
      },
      "editor.minimap.scale": {
        type: "number",
        default: e.scale,
        minimum: 1,
        maximum: 3,
        enum: [1, 2, 3],
        description: p("minimap.scale", "Scale of content drawn in the minimap: 1, 2 or 3.")
      },
      "editor.minimap.renderCharacters": {
        type: "boolean",
        default: e.renderCharacters,
        description: p("minimap.renderCharacters", "Render the actual characters on a line as opposed to color blocks.")
      },
      "editor.minimap.maxColumn": {
        type: "number",
        default: e.maxColumn,
        description: p("minimap.maxColumn", "Limit the width of the minimap to render at most a certain number of columns.")
      },
      "editor.minimap.showRegionSectionHeaders": {
        type: "boolean",
        default: e.showRegionSectionHeaders,
        description: p("minimap.showRegionSectionHeaders", "Controls whether named regions are shown as section headers in the minimap.")
      },
      "editor.minimap.showMarkSectionHeaders": {
        type: "boolean",
        default: e.showMarkSectionHeaders,
        description: p("minimap.showMarkSectionHeaders", "Controls whether MARK: comments are shown as section headers in the minimap.")
      },
      "editor.minimap.sectionHeaderFontSize": {
        type: "number",
        default: e.sectionHeaderFontSize,
        description: p("minimap.sectionHeaderFontSize", "Controls the font size of section headers in the minimap.")
      },
      "editor.minimap.sectionHeaderLetterSpacing": {
        type: "number",
        default: e.sectionHeaderLetterSpacing,
        description: p("minimap.sectionHeaderLetterSpacing", "Controls the amount of space (in pixels) between characters of section header. This helps the readability of the header in small font sizes.")
      }
    });
  }
  validate(e) {
    var t, i;
    if (!e || typeof e != "object")
      return this.defaultValue;
    const n = e;
    return {
      enabled: fe(n.enabled, this.defaultValue.enabled),
      autohide: fe(n.autohide, this.defaultValue.autohide),
      size: gi(n.size, this.defaultValue.size, ["proportional", "fill", "fit"]),
      side: gi(n.side, this.defaultValue.side, ["right", "left"]),
      showSlider: gi(n.showSlider, this.defaultValue.showSlider, ["always", "mouseover"]),
      renderCharacters: fe(n.renderCharacters, this.defaultValue.renderCharacters),
      scale: Et.clampedInt(n.scale, 1, 1, 3),
      maxColumn: Et.clampedInt(n.maxColumn, this.defaultValue.maxColumn, 1, 1e4),
      showRegionSectionHeaders: fe(n.showRegionSectionHeaders, this.defaultValue.showRegionSectionHeaders),
      showMarkSectionHeaders: fe(n.showMarkSectionHeaders, this.defaultValue.showMarkSectionHeaders),
      sectionHeaderFontSize: co.clamp((t = n.sectionHeaderFontSize) !== null && t !== void 0 ? t : this.defaultValue.sectionHeaderFontSize, 4, 32),
      sectionHeaderLetterSpacing: co.clamp((i = n.sectionHeaderLetterSpacing) !== null && i !== void 0 ? i : this.defaultValue.sectionHeaderLetterSpacing, 0, 5)
    };
  }
}
function Lj(r) {
  return r === "ctrlCmd" ? Je ? "metaKey" : "ctrlKey" : "altKey";
}
class Dj extends Xt {
  constructor() {
    super(84, "padding", { top: 0, bottom: 0 }, {
      "editor.padding.top": {
        type: "number",
        default: 0,
        minimum: 0,
        maximum: 1e3,
        description: p("padding.top", "Controls the amount of space between the top edge of the editor and the first line.")
      },
      "editor.padding.bottom": {
        type: "number",
        default: 0,
        minimum: 0,
        maximum: 1e3,
        description: p("padding.bottom", "Controls the amount of space between the bottom edge of the editor and the last line.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      top: Et.clampedInt(t.top, 0, 0, 1e3),
      bottom: Et.clampedInt(t.bottom, 0, 0, 1e3)
    };
  }
}
class kj extends Xt {
  constructor() {
    const e = {
      enabled: !0,
      cycle: !0
    };
    super(86, "parameterHints", e, {
      "editor.parameterHints.enabled": {
        type: "boolean",
        default: e.enabled,
        description: p("parameterHints.enabled", "Enables a pop-up that shows parameter documentation and type information as you type.")
      },
      "editor.parameterHints.cycle": {
        type: "boolean",
        default: e.cycle,
        description: p("parameterHints.cycle", "Controls whether the parameter hints menu cycles or closes when reaching the end of the list.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      enabled: fe(t.enabled, this.defaultValue.enabled),
      cycle: fe(t.cycle, this.defaultValue.cycle)
    };
  }
}
class xj extends sb {
  constructor() {
    super(
      143
      /* EditorOption.pixelRatio */
    );
  }
  compute(e, t, i) {
    return e.pixelRatio;
  }
}
class Ij extends Xt {
  constructor() {
    const e = {
      other: "on",
      comments: "off",
      strings: "off"
    }, t = [
      { type: "boolean" },
      {
        type: "string",
        enum: ["on", "inline", "off"],
        enumDescriptions: [p("on", "Quick suggestions show inside the suggest widget"), p("inline", "Quick suggestions show as ghost text"), p("off", "Quick suggestions are disabled")]
      }
    ];
    super(89, "quickSuggestions", e, {
      type: "object",
      additionalProperties: !1,
      properties: {
        strings: {
          anyOf: t,
          default: e.strings,
          description: p("quickSuggestions.strings", "Enable quick suggestions inside strings.")
        },
        comments: {
          anyOf: t,
          default: e.comments,
          description: p("quickSuggestions.comments", "Enable quick suggestions inside comments.")
        },
        other: {
          anyOf: t,
          default: e.other,
          description: p("quickSuggestions.other", "Enable quick suggestions outside of strings and comments.")
        }
      },
      default: e,
      markdownDescription: p("quickSuggestions", "Controls whether suggestions should automatically show up while typing. This can be controlled for typing in comments, strings, and other code. Quick suggestion can be configured to show as ghost text or with the suggest widget. Also be aware of the '{0}'-setting which controls if suggestions are triggered by special characters.", "#editor.suggestOnTriggerCharacters#")
    }), this.defaultValue = e;
  }
  validate(e) {
    if (typeof e == "boolean") {
      const d = e ? "on" : "off";
      return { comments: d, strings: d, other: d };
    }
    if (!e || typeof e != "object")
      return this.defaultValue;
    const { other: t, comments: i, strings: n } = e, s = ["on", "inline", "off"];
    let o, a, l;
    return typeof t == "boolean" ? o = t ? "on" : "off" : o = gi(t, this.defaultValue.other, s), typeof i == "boolean" ? a = i ? "on" : "off" : a = gi(i, this.defaultValue.comments, s), typeof n == "boolean" ? l = n ? "on" : "off" : l = gi(n, this.defaultValue.strings, s), {
      other: o,
      comments: a,
      strings: l
    };
  }
}
class Ej extends Xt {
  constructor() {
    super(68, "lineNumbers", { renderType: 1, renderFn: null }, {
      type: "string",
      enum: ["off", "on", "relative", "interval"],
      enumDescriptions: [
        p("lineNumbers.off", "Line numbers are not rendered."),
        p("lineNumbers.on", "Line numbers are rendered as absolute number."),
        p("lineNumbers.relative", "Line numbers are rendered as distance in lines to cursor position."),
        p("lineNumbers.interval", "Line numbers are rendered every 10 lines.")
      ],
      default: "on",
      description: p("lineNumbers", "Controls the display of line numbers.")
    });
  }
  validate(e) {
    let t = this.defaultValue.renderType, i = this.defaultValue.renderFn;
    return typeof e < "u" && (typeof e == "function" ? (t = 4, i = e) : e === "interval" ? t = 3 : e === "relative" ? t = 2 : e === "on" ? t = 1 : t = 0), {
      renderType: t,
      renderFn: i
    };
  }
}
function dS(r) {
  const e = r.get(
    98
    /* EditorOption.renderValidationDecorations */
  );
  return e === "editable" ? r.get(
    91
    /* EditorOption.readOnly */
  ) : e !== "on";
}
class Tj extends Xt {
  constructor() {
    const e = [], t = { type: "number", description: p("rulers.size", "Number of monospace characters at which this editor ruler will render.") };
    super(102, "rulers", e, {
      type: "array",
      items: {
        anyOf: [
          t,
          {
            type: [
              "object"
            ],
            properties: {
              column: t,
              color: {
                type: "string",
                description: p("rulers.color", "Color of this editor ruler."),
                format: "color-hex"
              }
            }
          }
        ]
      },
      default: e,
      description: p("rulers", "Render vertical rulers after a certain number of monospace characters. Use multiple values for multiple rulers. No rulers are drawn if array is empty.")
    });
  }
  validate(e) {
    if (Array.isArray(e)) {
      const t = [];
      for (const i of e)
        if (typeof i == "number")
          t.push({
            column: Et.clampedInt(i, 0, 0, 1e4),
            color: null
          });
        else if (i && typeof i == "object") {
          const n = i;
          t.push({
            column: Et.clampedInt(n.column, 0, 0, 1e4),
            color: n.color
          });
        }
      return t.sort((i, n) => i.column - n.column), t;
    }
    return this.defaultValue;
  }
}
class Nj extends Xt {
  constructor() {
    super(92, "readOnlyMessage", void 0);
  }
  validate(e) {
    return !e || typeof e != "object" ? this.defaultValue : e;
  }
}
function pA(r, e) {
  if (typeof r != "string")
    return e;
  switch (r) {
    case "hidden":
      return 2;
    case "visible":
      return 3;
    default:
      return 1;
  }
}
let Mj = class extends Xt {
  constructor() {
    const e = {
      vertical: 1,
      horizontal: 1,
      arrowSize: 11,
      useShadows: !0,
      verticalHasArrows: !1,
      horizontalHasArrows: !1,
      horizontalScrollbarSize: 12,
      horizontalSliderSize: 12,
      verticalScrollbarSize: 14,
      verticalSliderSize: 14,
      handleMouseWheel: !0,
      alwaysConsumeMouseWheel: !0,
      scrollByPage: !1,
      ignoreHorizontalScrollbarInContentHeight: !1
    };
    super(103, "scrollbar", e, {
      "editor.scrollbar.vertical": {
        type: "string",
        enum: ["auto", "visible", "hidden"],
        enumDescriptions: [
          p("scrollbar.vertical.auto", "The vertical scrollbar will be visible only when necessary."),
          p("scrollbar.vertical.visible", "The vertical scrollbar will always be visible."),
          p("scrollbar.vertical.fit", "The vertical scrollbar will always be hidden.")
        ],
        default: "auto",
        description: p("scrollbar.vertical", "Controls the visibility of the vertical scrollbar.")
      },
      "editor.scrollbar.horizontal": {
        type: "string",
        enum: ["auto", "visible", "hidden"],
        enumDescriptions: [
          p("scrollbar.horizontal.auto", "The horizontal scrollbar will be visible only when necessary."),
          p("scrollbar.horizontal.visible", "The horizontal scrollbar will always be visible."),
          p("scrollbar.horizontal.fit", "The horizontal scrollbar will always be hidden.")
        ],
        default: "auto",
        description: p("scrollbar.horizontal", "Controls the visibility of the horizontal scrollbar.")
      },
      "editor.scrollbar.verticalScrollbarSize": {
        type: "number",
        default: e.verticalScrollbarSize,
        description: p("scrollbar.verticalScrollbarSize", "The width of the vertical scrollbar.")
      },
      "editor.scrollbar.horizontalScrollbarSize": {
        type: "number",
        default: e.horizontalScrollbarSize,
        description: p("scrollbar.horizontalScrollbarSize", "The height of the horizontal scrollbar.")
      },
      "editor.scrollbar.scrollByPage": {
        type: "boolean",
        default: e.scrollByPage,
        description: p("scrollbar.scrollByPage", "Controls whether clicks scroll by page or jump to click position.")
      },
      "editor.scrollbar.ignoreHorizontalScrollbarInContentHeight": {
        type: "boolean",
        default: e.ignoreHorizontalScrollbarInContentHeight,
        description: p("scrollbar.ignoreHorizontalScrollbarInContentHeight", "When set, the horizontal scrollbar will not increase the size of the editor's content.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e, i = Et.clampedInt(t.horizontalScrollbarSize, this.defaultValue.horizontalScrollbarSize, 0, 1e3), n = Et.clampedInt(t.verticalScrollbarSize, this.defaultValue.verticalScrollbarSize, 0, 1e3);
    return {
      arrowSize: Et.clampedInt(t.arrowSize, this.defaultValue.arrowSize, 0, 1e3),
      vertical: pA(t.vertical, this.defaultValue.vertical),
      horizontal: pA(t.horizontal, this.defaultValue.horizontal),
      useShadows: fe(t.useShadows, this.defaultValue.useShadows),
      verticalHasArrows: fe(t.verticalHasArrows, this.defaultValue.verticalHasArrows),
      horizontalHasArrows: fe(t.horizontalHasArrows, this.defaultValue.horizontalHasArrows),
      handleMouseWheel: fe(t.handleMouseWheel, this.defaultValue.handleMouseWheel),
      alwaysConsumeMouseWheel: fe(t.alwaysConsumeMouseWheel, this.defaultValue.alwaysConsumeMouseWheel),
      horizontalScrollbarSize: i,
      horizontalSliderSize: Et.clampedInt(t.horizontalSliderSize, i, 0, 1e3),
      verticalScrollbarSize: n,
      verticalSliderSize: Et.clampedInt(t.verticalSliderSize, n, 0, 1e3),
      scrollByPage: fe(t.scrollByPage, this.defaultValue.scrollByPage),
      ignoreHorizontalScrollbarInContentHeight: fe(t.ignoreHorizontalScrollbarInContentHeight, this.defaultValue.ignoreHorizontalScrollbarInContentHeight)
    };
  }
};
const Js = "inUntrustedWorkspace", bs = {
  allowedCharacters: "editor.unicodeHighlight.allowedCharacters",
  invisibleCharacters: "editor.unicodeHighlight.invisibleCharacters",
  nonBasicASCII: "editor.unicodeHighlight.nonBasicASCII",
  ambiguousCharacters: "editor.unicodeHighlight.ambiguousCharacters",
  includeComments: "editor.unicodeHighlight.includeComments",
  includeStrings: "editor.unicodeHighlight.includeStrings",
  allowedLocales: "editor.unicodeHighlight.allowedLocales"
};
class Rj extends Xt {
  constructor() {
    const e = {
      nonBasicASCII: Js,
      invisibleCharacters: !0,
      ambiguousCharacters: !0,
      includeComments: Js,
      includeStrings: !0,
      allowedCharacters: {},
      allowedLocales: { _os: !0, _vscode: !0 }
    };
    super(125, "unicodeHighlight", e, {
      [bs.nonBasicASCII]: {
        restricted: !0,
        type: ["boolean", "string"],
        enum: [!0, !1, Js],
        default: e.nonBasicASCII,
        description: p("unicodeHighlight.nonBasicASCII", "Controls whether all non-basic ASCII characters are highlighted. Only characters between U+0020 and U+007E, tab, line-feed and carriage-return are considered basic ASCII.")
      },
      [bs.invisibleCharacters]: {
        restricted: !0,
        type: "boolean",
        default: e.invisibleCharacters,
        description: p("unicodeHighlight.invisibleCharacters", "Controls whether characters that just reserve space or have no width at all are highlighted.")
      },
      [bs.ambiguousCharacters]: {
        restricted: !0,
        type: "boolean",
        default: e.ambiguousCharacters,
        description: p("unicodeHighlight.ambiguousCharacters", "Controls whether characters are highlighted that can be confused with basic ASCII characters, except those that are common in the current user locale.")
      },
      [bs.includeComments]: {
        restricted: !0,
        type: ["boolean", "string"],
        enum: [!0, !1, Js],
        default: e.includeComments,
        description: p("unicodeHighlight.includeComments", "Controls whether characters in comments should also be subject to Unicode highlighting.")
      },
      [bs.includeStrings]: {
        restricted: !0,
        type: ["boolean", "string"],
        enum: [!0, !1, Js],
        default: e.includeStrings,
        description: p("unicodeHighlight.includeStrings", "Controls whether characters in strings should also be subject to Unicode highlighting.")
      },
      [bs.allowedCharacters]: {
        restricted: !0,
        type: "object",
        default: e.allowedCharacters,
        description: p("unicodeHighlight.allowedCharacters", "Defines allowed characters that are not being highlighted."),
        additionalProperties: {
          type: "boolean"
        }
      },
      [bs.allowedLocales]: {
        restricted: !0,
        type: "object",
        additionalProperties: {
          type: "boolean"
        },
        default: e.allowedLocales,
        description: p("unicodeHighlight.allowedLocales", "Unicode characters that are common in allowed locales are not being highlighted.")
      }
    });
  }
  applyUpdate(e, t) {
    let i = !1;
    t.allowedCharacters && e && (Xa(e.allowedCharacters, t.allowedCharacters) || (e = { ...e, allowedCharacters: t.allowedCharacters }, i = !0)), t.allowedLocales && e && (Xa(e.allowedLocales, t.allowedLocales) || (e = { ...e, allowedLocales: t.allowedLocales }, i = !0));
    const n = super.applyUpdate(e, t);
    return i ? new Qm(n.newValue, !0) : n;
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      nonBasicASCII: uf(t.nonBasicASCII, Js, [!0, !1, Js]),
      invisibleCharacters: fe(t.invisibleCharacters, this.defaultValue.invisibleCharacters),
      ambiguousCharacters: fe(t.ambiguousCharacters, this.defaultValue.ambiguousCharacters),
      includeComments: uf(t.includeComments, Js, [!0, !1, Js]),
      includeStrings: uf(t.includeStrings, Js, [!0, !1, Js]),
      allowedCharacters: this.validateBooleanMap(e.allowedCharacters, this.defaultValue.allowedCharacters),
      allowedLocales: this.validateBooleanMap(e.allowedLocales, this.defaultValue.allowedLocales)
    };
  }
  validateBooleanMap(e, t) {
    if (typeof e != "object" || !e)
      return t;
    const i = {};
    for (const [n, s] of Object.entries(e))
      s === !0 && (i[n] = !0);
    return i;
  }
}
class Aj extends Xt {
  constructor() {
    const e = {
      enabled: !0,
      mode: "subwordSmart",
      showToolbar: "onHover",
      suppressSuggestions: !1,
      keepOnBlur: !1,
      fontFamily: "default"
    };
    super(62, "inlineSuggest", e, {
      "editor.inlineSuggest.enabled": {
        type: "boolean",
        default: e.enabled,
        description: p("inlineSuggest.enabled", "Controls whether to automatically show inline suggestions in the editor.")
      },
      "editor.inlineSuggest.showToolbar": {
        type: "string",
        default: e.showToolbar,
        enum: ["always", "onHover", "never"],
        enumDescriptions: [
          p("inlineSuggest.showToolbar.always", "Show the inline suggestion toolbar whenever an inline suggestion is shown."),
          p("inlineSuggest.showToolbar.onHover", "Show the inline suggestion toolbar when hovering over an inline suggestion."),
          p("inlineSuggest.showToolbar.never", "Never show the inline suggestion toolbar.")
        ],
        description: p("inlineSuggest.showToolbar", "Controls when to show the inline suggestion toolbar.")
      },
      "editor.inlineSuggest.suppressSuggestions": {
        type: "boolean",
        default: e.suppressSuggestions,
        description: p("inlineSuggest.suppressSuggestions", "Controls how inline suggestions interact with the suggest widget. If enabled, the suggest widget is not shown automatically when inline suggestions are available.")
      },
      "editor.inlineSuggest.fontFamily": {
        type: "string",
        default: e.fontFamily,
        description: p("inlineSuggest.fontFamily", "Controls the font family of the inline suggestions.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      enabled: fe(t.enabled, this.defaultValue.enabled),
      mode: gi(t.mode, this.defaultValue.mode, ["prefix", "subword", "subwordSmart"]),
      showToolbar: gi(t.showToolbar, this.defaultValue.showToolbar, ["always", "onHover", "never"]),
      suppressSuggestions: fe(t.suppressSuggestions, this.defaultValue.suppressSuggestions),
      keepOnBlur: fe(t.keepOnBlur, this.defaultValue.keepOnBlur),
      fontFamily: Qn.string(t.fontFamily, this.defaultValue.fontFamily)
    };
  }
}
class Pj extends Xt {
  constructor() {
    const e = {
      enabled: !1,
      showToolbar: "onHover",
      fontFamily: "default",
      keepOnBlur: !1,
      backgroundColoring: !1
    };
    super(63, "experimentalInlineEdit", e, {
      "editor.experimentalInlineEdit.enabled": {
        type: "boolean",
        default: e.enabled,
        description: p("inlineEdit.enabled", "Controls whether to show inline edits in the editor.")
      },
      "editor.experimentalInlineEdit.showToolbar": {
        type: "string",
        default: e.showToolbar,
        enum: ["always", "onHover", "never"],
        enumDescriptions: [
          p("inlineEdit.showToolbar.always", "Show the inline edit toolbar whenever an inline suggestion is shown."),
          p("inlineEdit.showToolbar.onHover", "Show the inline edit toolbar when hovering over an inline suggestion."),
          p("inlineEdit.showToolbar.never", "Never show the inline edit toolbar.")
        ],
        description: p("inlineEdit.showToolbar", "Controls when to show the inline edit toolbar.")
      },
      "editor.experimentalInlineEdit.fontFamily": {
        type: "string",
        default: e.fontFamily,
        description: p("inlineEdit.fontFamily", "Controls the font family of the inline edit.")
      },
      "editor.experimentalInlineEdit.backgroundColoring": {
        type: "boolean",
        default: e.backgroundColoring,
        description: p("inlineEdit.backgroundColoring", "Controls whether to color the background of inline edits.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      enabled: fe(t.enabled, this.defaultValue.enabled),
      showToolbar: gi(t.showToolbar, this.defaultValue.showToolbar, ["always", "onHover", "never"]),
      fontFamily: Qn.string(t.fontFamily, this.defaultValue.fontFamily),
      keepOnBlur: fe(t.keepOnBlur, this.defaultValue.keepOnBlur),
      backgroundColoring: fe(t.backgroundColoring, this.defaultValue.backgroundColoring)
    };
  }
}
class Oj extends Xt {
  constructor() {
    const e = {
      enabled: Tn.bracketPairColorizationOptions.enabled,
      independentColorPoolPerBracketType: Tn.bracketPairColorizationOptions.independentColorPoolPerBracketType
    };
    super(15, "bracketPairColorization", e, {
      "editor.bracketPairColorization.enabled": {
        type: "boolean",
        default: e.enabled,
        markdownDescription: p("bracketPairColorization.enabled", "Controls whether bracket pair colorization is enabled or not. Use {0} to override the bracket highlight colors.", "`#workbench.colorCustomizations#`")
      },
      "editor.bracketPairColorization.independentColorPoolPerBracketType": {
        type: "boolean",
        default: e.independentColorPoolPerBracketType,
        description: p("bracketPairColorization.independentColorPoolPerBracketType", "Controls whether each bracket type has its own independent color pool.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      enabled: fe(t.enabled, this.defaultValue.enabled),
      independentColorPoolPerBracketType: fe(t.independentColorPoolPerBracketType, this.defaultValue.independentColorPoolPerBracketType)
    };
  }
}
class Fj extends Xt {
  constructor() {
    const e = {
      bracketPairs: !1,
      bracketPairsHorizontal: "active",
      highlightActiveBracketPair: !0,
      indentation: !0,
      highlightActiveIndentation: !0
    };
    super(16, "guides", e, {
      "editor.guides.bracketPairs": {
        type: ["boolean", "string"],
        enum: [!0, "active", !1],
        enumDescriptions: [
          p("editor.guides.bracketPairs.true", "Enables bracket pair guides."),
          p("editor.guides.bracketPairs.active", "Enables bracket pair guides only for the active bracket pair."),
          p("editor.guides.bracketPairs.false", "Disables bracket pair guides.")
        ],
        default: e.bracketPairs,
        description: p("editor.guides.bracketPairs", "Controls whether bracket pair guides are enabled or not.")
      },
      "editor.guides.bracketPairsHorizontal": {
        type: ["boolean", "string"],
        enum: [!0, "active", !1],
        enumDescriptions: [
          p("editor.guides.bracketPairsHorizontal.true", "Enables horizontal guides as addition to vertical bracket pair guides."),
          p("editor.guides.bracketPairsHorizontal.active", "Enables horizontal guides only for the active bracket pair."),
          p("editor.guides.bracketPairsHorizontal.false", "Disables horizontal bracket pair guides.")
        ],
        default: e.bracketPairsHorizontal,
        description: p("editor.guides.bracketPairsHorizontal", "Controls whether horizontal bracket pair guides are enabled or not.")
      },
      "editor.guides.highlightActiveBracketPair": {
        type: "boolean",
        default: e.highlightActiveBracketPair,
        description: p("editor.guides.highlightActiveBracketPair", "Controls whether the editor should highlight the active bracket pair.")
      },
      "editor.guides.indentation": {
        type: "boolean",
        default: e.indentation,
        description: p("editor.guides.indentation", "Controls whether the editor should render indent guides.")
      },
      "editor.guides.highlightActiveIndentation": {
        type: ["boolean", "string"],
        enum: [!0, "always", !1],
        enumDescriptions: [
          p("editor.guides.highlightActiveIndentation.true", "Highlights the active indent guide."),
          p("editor.guides.highlightActiveIndentation.always", "Highlights the active indent guide even if bracket guides are highlighted."),
          p("editor.guides.highlightActiveIndentation.false", "Do not highlight the active indent guide.")
        ],
        default: e.highlightActiveIndentation,
        description: p("editor.guides.highlightActiveIndentation", "Controls whether the editor should highlight the active indent guide.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      bracketPairs: uf(t.bracketPairs, this.defaultValue.bracketPairs, [!0, !1, "active"]),
      bracketPairsHorizontal: uf(t.bracketPairsHorizontal, this.defaultValue.bracketPairsHorizontal, [!0, !1, "active"]),
      highlightActiveBracketPair: fe(t.highlightActiveBracketPair, this.defaultValue.highlightActiveBracketPair),
      indentation: fe(t.indentation, this.defaultValue.indentation),
      highlightActiveIndentation: uf(t.highlightActiveIndentation, this.defaultValue.highlightActiveIndentation, [!0, !1, "always"])
    };
  }
}
function uf(r, e, t) {
  const i = t.indexOf(r);
  return i === -1 ? e : t[i];
}
class Wj extends Xt {
  constructor() {
    const e = {
      insertMode: "insert",
      filterGraceful: !0,
      snippetsPreventQuickSuggestions: !1,
      localityBonus: !1,
      shareSuggestSelections: !1,
      selectionMode: "always",
      showIcons: !0,
      showStatusBar: !1,
      preview: !1,
      previewMode: "subwordSmart",
      showInlineDetails: !0,
      showMethods: !0,
      showFunctions: !0,
      showConstructors: !0,
      showDeprecated: !0,
      matchOnWordStartOnly: !0,
      showFields: !0,
      showVariables: !0,
      showClasses: !0,
      showStructs: !0,
      showInterfaces: !0,
      showModules: !0,
      showProperties: !0,
      showEvents: !0,
      showOperators: !0,
      showUnits: !0,
      showValues: !0,
      showConstants: !0,
      showEnums: !0,
      showEnumMembers: !0,
      showKeywords: !0,
      showWords: !0,
      showColors: !0,
      showFiles: !0,
      showReferences: !0,
      showFolders: !0,
      showTypeParameters: !0,
      showSnippets: !0,
      showUsers: !0,
      showIssues: !0
    };
    super(118, "suggest", e, {
      "editor.suggest.insertMode": {
        type: "string",
        enum: ["insert", "replace"],
        enumDescriptions: [
          p("suggest.insertMode.insert", "Insert suggestion without overwriting text right of the cursor."),
          p("suggest.insertMode.replace", "Insert suggestion and overwrite text right of the cursor.")
        ],
        default: e.insertMode,
        description: p("suggest.insertMode", "Controls whether words are overwritten when accepting completions. Note that this depends on extensions opting into this feature.")
      },
      "editor.suggest.filterGraceful": {
        type: "boolean",
        default: e.filterGraceful,
        description: p("suggest.filterGraceful", "Controls whether filtering and sorting suggestions accounts for small typos.")
      },
      "editor.suggest.localityBonus": {
        type: "boolean",
        default: e.localityBonus,
        description: p("suggest.localityBonus", "Controls whether sorting favors words that appear close to the cursor.")
      },
      "editor.suggest.shareSuggestSelections": {
        type: "boolean",
        default: e.shareSuggestSelections,
        markdownDescription: p("suggest.shareSuggestSelections", "Controls whether remembered suggestion selections are shared between multiple workspaces and windows (needs `#editor.suggestSelection#`).")
      },
      "editor.suggest.selectionMode": {
        type: "string",
        enum: ["always", "never", "whenTriggerCharacter", "whenQuickSuggestion"],
        enumDescriptions: [
          p("suggest.insertMode.always", "Always select a suggestion when automatically triggering IntelliSense."),
          p("suggest.insertMode.never", "Never select a suggestion when automatically triggering IntelliSense."),
          p("suggest.insertMode.whenTriggerCharacter", "Select a suggestion only when triggering IntelliSense from a trigger character."),
          p("suggest.insertMode.whenQuickSuggestion", "Select a suggestion only when triggering IntelliSense as you type.")
        ],
        default: e.selectionMode,
        markdownDescription: p("suggest.selectionMode", "Controls whether a suggestion is selected when the widget shows. Note that this only applies to automatically triggered suggestions (`#editor.quickSuggestions#` and `#editor.suggestOnTriggerCharacters#`) and that a suggestion is always selected when explicitly invoked, e.g via `Ctrl+Space`.")
      },
      "editor.suggest.snippetsPreventQuickSuggestions": {
        type: "boolean",
        default: e.snippetsPreventQuickSuggestions,
        description: p("suggest.snippetsPreventQuickSuggestions", "Controls whether an active snippet prevents quick suggestions.")
      },
      "editor.suggest.showIcons": {
        type: "boolean",
        default: e.showIcons,
        description: p("suggest.showIcons", "Controls whether to show or hide icons in suggestions.")
      },
      "editor.suggest.showStatusBar": {
        type: "boolean",
        default: e.showStatusBar,
        description: p("suggest.showStatusBar", "Controls the visibility of the status bar at the bottom of the suggest widget.")
      },
      "editor.suggest.preview": {
        type: "boolean",
        default: e.preview,
        description: p("suggest.preview", "Controls whether to preview the suggestion outcome in the editor.")
      },
      "editor.suggest.showInlineDetails": {
        type: "boolean",
        default: e.showInlineDetails,
        description: p("suggest.showInlineDetails", "Controls whether suggest details show inline with the label or only in the details widget.")
      },
      "editor.suggest.maxVisibleSuggestions": {
        type: "number",
        deprecationMessage: p("suggest.maxVisibleSuggestions.dep", "This setting is deprecated. The suggest widget can now be resized.")
      },
      "editor.suggest.filteredTypes": {
        type: "object",
        deprecationMessage: p("deprecated", "This setting is deprecated, please use separate settings like 'editor.suggest.showKeywords' or 'editor.suggest.showSnippets' instead.")
      },
      "editor.suggest.showMethods": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showMethods", "When enabled IntelliSense shows `method`-suggestions.")
      },
      "editor.suggest.showFunctions": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showFunctions", "When enabled IntelliSense shows `function`-suggestions.")
      },
      "editor.suggest.showConstructors": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showConstructors", "When enabled IntelliSense shows `constructor`-suggestions.")
      },
      "editor.suggest.showDeprecated": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showDeprecated", "When enabled IntelliSense shows `deprecated`-suggestions.")
      },
      "editor.suggest.matchOnWordStartOnly": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.matchOnWordStartOnly", "When enabled IntelliSense filtering requires that the first character matches on a word start. For example, `c` on `Console` or `WebContext` but _not_ on `description`. When disabled IntelliSense will show more results but still sorts them by match quality.")
      },
      "editor.suggest.showFields": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showFields", "When enabled IntelliSense shows `field`-suggestions.")
      },
      "editor.suggest.showVariables": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showVariables", "When enabled IntelliSense shows `variable`-suggestions.")
      },
      "editor.suggest.showClasses": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showClasss", "When enabled IntelliSense shows `class`-suggestions.")
      },
      "editor.suggest.showStructs": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showStructs", "When enabled IntelliSense shows `struct`-suggestions.")
      },
      "editor.suggest.showInterfaces": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showInterfaces", "When enabled IntelliSense shows `interface`-suggestions.")
      },
      "editor.suggest.showModules": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showModules", "When enabled IntelliSense shows `module`-suggestions.")
      },
      "editor.suggest.showProperties": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showPropertys", "When enabled IntelliSense shows `property`-suggestions.")
      },
      "editor.suggest.showEvents": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showEvents", "When enabled IntelliSense shows `event`-suggestions.")
      },
      "editor.suggest.showOperators": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showOperators", "When enabled IntelliSense shows `operator`-suggestions.")
      },
      "editor.suggest.showUnits": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showUnits", "When enabled IntelliSense shows `unit`-suggestions.")
      },
      "editor.suggest.showValues": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showValues", "When enabled IntelliSense shows `value`-suggestions.")
      },
      "editor.suggest.showConstants": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showConstants", "When enabled IntelliSense shows `constant`-suggestions.")
      },
      "editor.suggest.showEnums": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showEnums", "When enabled IntelliSense shows `enum`-suggestions.")
      },
      "editor.suggest.showEnumMembers": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showEnumMembers", "When enabled IntelliSense shows `enumMember`-suggestions.")
      },
      "editor.suggest.showKeywords": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showKeywords", "When enabled IntelliSense shows `keyword`-suggestions.")
      },
      "editor.suggest.showWords": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showTexts", "When enabled IntelliSense shows `text`-suggestions.")
      },
      "editor.suggest.showColors": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showColors", "When enabled IntelliSense shows `color`-suggestions.")
      },
      "editor.suggest.showFiles": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showFiles", "When enabled IntelliSense shows `file`-suggestions.")
      },
      "editor.suggest.showReferences": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showReferences", "When enabled IntelliSense shows `reference`-suggestions.")
      },
      "editor.suggest.showCustomcolors": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showCustomcolors", "When enabled IntelliSense shows `customcolor`-suggestions.")
      },
      "editor.suggest.showFolders": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showFolders", "When enabled IntelliSense shows `folder`-suggestions.")
      },
      "editor.suggest.showTypeParameters": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showTypeParameters", "When enabled IntelliSense shows `typeParameter`-suggestions.")
      },
      "editor.suggest.showSnippets": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showSnippets", "When enabled IntelliSense shows `snippet`-suggestions.")
      },
      "editor.suggest.showUsers": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showUsers", "When enabled IntelliSense shows `user`-suggestions.")
      },
      "editor.suggest.showIssues": {
        type: "boolean",
        default: !0,
        markdownDescription: p("editor.suggest.showIssues", "When enabled IntelliSense shows `issues`-suggestions.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      insertMode: gi(t.insertMode, this.defaultValue.insertMode, ["insert", "replace"]),
      filterGraceful: fe(t.filterGraceful, this.defaultValue.filterGraceful),
      snippetsPreventQuickSuggestions: fe(t.snippetsPreventQuickSuggestions, this.defaultValue.filterGraceful),
      localityBonus: fe(t.localityBonus, this.defaultValue.localityBonus),
      shareSuggestSelections: fe(t.shareSuggestSelections, this.defaultValue.shareSuggestSelections),
      selectionMode: gi(t.selectionMode, this.defaultValue.selectionMode, ["always", "never", "whenQuickSuggestion", "whenTriggerCharacter"]),
      showIcons: fe(t.showIcons, this.defaultValue.showIcons),
      showStatusBar: fe(t.showStatusBar, this.defaultValue.showStatusBar),
      preview: fe(t.preview, this.defaultValue.preview),
      previewMode: gi(t.previewMode, this.defaultValue.previewMode, ["prefix", "subword", "subwordSmart"]),
      showInlineDetails: fe(t.showInlineDetails, this.defaultValue.showInlineDetails),
      showMethods: fe(t.showMethods, this.defaultValue.showMethods),
      showFunctions: fe(t.showFunctions, this.defaultValue.showFunctions),
      showConstructors: fe(t.showConstructors, this.defaultValue.showConstructors),
      showDeprecated: fe(t.showDeprecated, this.defaultValue.showDeprecated),
      matchOnWordStartOnly: fe(t.matchOnWordStartOnly, this.defaultValue.matchOnWordStartOnly),
      showFields: fe(t.showFields, this.defaultValue.showFields),
      showVariables: fe(t.showVariables, this.defaultValue.showVariables),
      showClasses: fe(t.showClasses, this.defaultValue.showClasses),
      showStructs: fe(t.showStructs, this.defaultValue.showStructs),
      showInterfaces: fe(t.showInterfaces, this.defaultValue.showInterfaces),
      showModules: fe(t.showModules, this.defaultValue.showModules),
      showProperties: fe(t.showProperties, this.defaultValue.showProperties),
      showEvents: fe(t.showEvents, this.defaultValue.showEvents),
      showOperators: fe(t.showOperators, this.defaultValue.showOperators),
      showUnits: fe(t.showUnits, this.defaultValue.showUnits),
      showValues: fe(t.showValues, this.defaultValue.showValues),
      showConstants: fe(t.showConstants, this.defaultValue.showConstants),
      showEnums: fe(t.showEnums, this.defaultValue.showEnums),
      showEnumMembers: fe(t.showEnumMembers, this.defaultValue.showEnumMembers),
      showKeywords: fe(t.showKeywords, this.defaultValue.showKeywords),
      showWords: fe(t.showWords, this.defaultValue.showWords),
      showColors: fe(t.showColors, this.defaultValue.showColors),
      showFiles: fe(t.showFiles, this.defaultValue.showFiles),
      showReferences: fe(t.showReferences, this.defaultValue.showReferences),
      showFolders: fe(t.showFolders, this.defaultValue.showFolders),
      showTypeParameters: fe(t.showTypeParameters, this.defaultValue.showTypeParameters),
      showSnippets: fe(t.showSnippets, this.defaultValue.showSnippets),
      showUsers: fe(t.showUsers, this.defaultValue.showUsers),
      showIssues: fe(t.showIssues, this.defaultValue.showIssues)
    };
  }
}
class Bj extends Xt {
  constructor() {
    super(113, "smartSelect", {
      selectLeadingAndTrailingWhitespace: !0,
      selectSubwords: !0
    }, {
      "editor.smartSelect.selectLeadingAndTrailingWhitespace": {
        description: p("selectLeadingAndTrailingWhitespace", "Whether leading and trailing whitespace should always be selected."),
        default: !0,
        type: "boolean"
      },
      "editor.smartSelect.selectSubwords": {
        description: p("selectSubwords", "Whether subwords (like 'foo' in 'fooBar' or 'foo_bar') should be selected."),
        default: !0,
        type: "boolean"
      }
    });
  }
  validate(e) {
    return !e || typeof e != "object" ? this.defaultValue : {
      selectLeadingAndTrailingWhitespace: fe(e.selectLeadingAndTrailingWhitespace, this.defaultValue.selectLeadingAndTrailingWhitespace),
      selectSubwords: fe(e.selectSubwords, this.defaultValue.selectSubwords)
    };
  }
}
class Hj extends Xt {
  constructor() {
    const e = [];
    super(130, "wordSegmenterLocales", e, {
      anyOf: [
        {
          description: p("wordSegmenterLocales", "Locales to be used for word segmentation when doing word related navigations or operations. Specify the BCP 47 language tag of the word you wish to recognize (e.g., ja, zh-CN, zh-Hant-TW, etc.)."),
          type: "string"
        },
        {
          description: p("wordSegmenterLocales", "Locales to be used for word segmentation when doing word related navigations or operations. Specify the BCP 47 language tag of the word you wish to recognize (e.g., ja, zh-CN, zh-Hant-TW, etc.)."),
          type: "array",
          items: {
            type: "string"
          }
        }
      ]
    });
  }
  validate(e) {
    if (typeof e == "string" && (e = [e]), Array.isArray(e)) {
      const t = [];
      for (const i of e)
        if (typeof i == "string")
          try {
            Intl.Segmenter.supportedLocalesOf(i).length > 0 && t.push(i);
          } catch {
          }
      return t;
    }
    return this.defaultValue;
  }
}
class Vj extends Xt {
  constructor() {
    super(138, "wrappingIndent", 1, {
      "editor.wrappingIndent": {
        type: "string",
        enum: ["none", "same", "indent", "deepIndent"],
        enumDescriptions: [
          p("wrappingIndent.none", "No indentation. Wrapped lines begin at column 1."),
          p("wrappingIndent.same", "Wrapped lines get the same indentation as the parent."),
          p("wrappingIndent.indent", "Wrapped lines get +1 indentation toward the parent."),
          p("wrappingIndent.deepIndent", "Wrapped lines get +2 indentation toward the parent.")
        ],
        description: p("wrappingIndent", "Controls the indentation of wrapped lines."),
        default: "same"
      }
    });
  }
  validate(e) {
    switch (e) {
      case "none":
        return 0;
      case "same":
        return 1;
      case "indent":
        return 2;
      case "deepIndent":
        return 3;
    }
    return 1;
  }
  compute(e, t, i) {
    return t.get(
      2
      /* EditorOption.accessibilitySupport */
    ) === 2 ? 0 : i;
  }
}
class zj extends sb {
  constructor() {
    super(
      146
      /* EditorOption.wrappingInfo */
    );
  }
  compute(e, t, i) {
    const n = t.get(
      145
      /* EditorOption.layoutInfo */
    );
    return {
      isDominatedByLongLines: e.isDominatedByLongLines,
      isWordWrapMinified: n.isWordWrapMinified,
      isViewportWrapping: n.isViewportWrapping,
      wrappingColumn: n.wrappingColumn
    };
  }
}
class Uj extends Xt {
  constructor() {
    const e = { enabled: !0, showDropSelector: "afterDrop" };
    super(36, "dropIntoEditor", e, {
      "editor.dropIntoEditor.enabled": {
        type: "boolean",
        default: e.enabled,
        markdownDescription: p("dropIntoEditor.enabled", "Controls whether you can drag and drop a file into a text editor by holding down the `Shift` key (instead of opening the file in an editor).")
      },
      "editor.dropIntoEditor.showDropSelector": {
        type: "string",
        markdownDescription: p("dropIntoEditor.showDropSelector", "Controls if a widget is shown when dropping files into the editor. This widget lets you control how the file is dropped."),
        enum: [
          "afterDrop",
          "never"
        ],
        enumDescriptions: [
          p("dropIntoEditor.showDropSelector.afterDrop", "Show the drop selector widget after a file is dropped into the editor."),
          p("dropIntoEditor.showDropSelector.never", "Never show the drop selector widget. Instead the default drop provider is always used.")
        ],
        default: "afterDrop"
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      enabled: fe(t.enabled, this.defaultValue.enabled),
      showDropSelector: gi(t.showDropSelector, this.defaultValue.showDropSelector, ["afterDrop", "never"])
    };
  }
}
class $j extends Xt {
  constructor() {
    const e = { enabled: !0, showPasteSelector: "afterPaste" };
    super(85, "pasteAs", e, {
      "editor.pasteAs.enabled": {
        type: "boolean",
        default: e.enabled,
        markdownDescription: p("pasteAs.enabled", "Controls whether you can paste content in different ways.")
      },
      "editor.pasteAs.showPasteSelector": {
        type: "string",
        markdownDescription: p("pasteAs.showPasteSelector", "Controls if a widget is shown when pasting content in to the editor. This widget lets you control how the file is pasted."),
        enum: [
          "afterPaste",
          "never"
        ],
        enumDescriptions: [
          p("pasteAs.showPasteSelector.afterPaste", "Show the paste selector widget after content is pasted into the editor."),
          p("pasteAs.showPasteSelector.never", "Never show the paste selector widget. Instead the default pasting behavior is always used.")
        ],
        default: "afterPaste"
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      enabled: fe(t.enabled, this.defaultValue.enabled),
      showPasteSelector: gi(t.showPasteSelector, this.defaultValue.showPasteSelector, ["afterPaste", "never"])
    };
  }
}
const Kj = "Consolas, 'Courier New', monospace", jj = "Menlo, Monaco, 'Courier New', monospace", qj = "'Droid Sans Mono', 'monospace', monospace", Ss = {
  fontFamily: Je ? jj : os ? qj : Kj,
  fontWeight: "normal",
  fontSize: Je ? 12 : 14,
  lineHeight: 0,
  letterSpacing: 0
}, Hg = [];
function J(r) {
  return Hg[r.id] = r, r;
}
const oa = {
  acceptSuggestionOnCommitCharacter: J(new lt(0, "acceptSuggestionOnCommitCharacter", !0, { markdownDescription: p("acceptSuggestionOnCommitCharacter", "Controls whether suggestions should be accepted on commit characters. For example, in JavaScript, the semi-colon (`;`) can be a commit character that accepts a suggestion and types that character.") })),
  acceptSuggestionOnEnter: J(new oi(1, "acceptSuggestionOnEnter", "on", ["on", "smart", "off"], {
    markdownEnumDescriptions: [
      "",
      p("acceptSuggestionOnEnterSmart", "Only accept a suggestion with `Enter` when it makes a textual change."),
      ""
    ],
    markdownDescription: p("acceptSuggestionOnEnter", "Controls whether suggestions should be accepted on `Enter`, in addition to `Tab`. Helps to avoid ambiguity between inserting new lines or accepting suggestions.")
  })),
  accessibilitySupport: J(new rj()),
  accessibilityPageSize: J(new Et(3, "accessibilityPageSize", 10, 1, 1073741824, {
    description: p("accessibilityPageSize", "Controls the number of lines in the editor that can be read out by a screen reader at once. When we detect a screen reader we automatically set the default to be 500. Warning: this has a performance implication for numbers larger than the default."),
    tags: ["accessibility"]
  })),
  ariaLabel: J(new Qn(4, "ariaLabel", p("editorViewAccessibleLabel", "Editor content"))),
  ariaRequired: J(new lt(5, "ariaRequired", !1, void 0)),
  screenReaderAnnounceInlineSuggestion: J(new lt(8, "screenReaderAnnounceInlineSuggestion", !0, {
    description: p("screenReaderAnnounceInlineSuggestion", "Control whether inline suggestions are announced by a screen reader."),
    tags: ["accessibility"]
  })),
  autoClosingBrackets: J(new oi(6, "autoClosingBrackets", "languageDefined", ["always", "languageDefined", "beforeWhitespace", "never"], {
    enumDescriptions: [
      "",
      p("editor.autoClosingBrackets.languageDefined", "Use language configurations to determine when to autoclose brackets."),
      p("editor.autoClosingBrackets.beforeWhitespace", "Autoclose brackets only when the cursor is to the left of whitespace."),
      ""
    ],
    description: p("autoClosingBrackets", "Controls whether the editor should automatically close brackets after the user adds an opening bracket.")
  })),
  autoClosingComments: J(new oi(7, "autoClosingComments", "languageDefined", ["always", "languageDefined", "beforeWhitespace", "never"], {
    enumDescriptions: [
      "",
      p("editor.autoClosingComments.languageDefined", "Use language configurations to determine when to autoclose comments."),
      p("editor.autoClosingComments.beforeWhitespace", "Autoclose comments only when the cursor is to the left of whitespace."),
      ""
    ],
    description: p("autoClosingComments", "Controls whether the editor should automatically close comments after the user adds an opening comment.")
  })),
  autoClosingDelete: J(new oi(9, "autoClosingDelete", "auto", ["always", "auto", "never"], {
    enumDescriptions: [
      "",
      p("editor.autoClosingDelete.auto", "Remove adjacent closing quotes or brackets only if they were automatically inserted."),
      ""
    ],
    description: p("autoClosingDelete", "Controls whether the editor should remove adjacent closing quotes or brackets when deleting.")
  })),
  autoClosingOvertype: J(new oi(10, "autoClosingOvertype", "auto", ["always", "auto", "never"], {
    enumDescriptions: [
      "",
      p("editor.autoClosingOvertype.auto", "Type over closing quotes or brackets only if they were automatically inserted."),
      ""
    ],
    description: p("autoClosingOvertype", "Controls whether the editor should type over closing quotes or brackets.")
  })),
  autoClosingQuotes: J(new oi(11, "autoClosingQuotes", "languageDefined", ["always", "languageDefined", "beforeWhitespace", "never"], {
    enumDescriptions: [
      "",
      p("editor.autoClosingQuotes.languageDefined", "Use language configurations to determine when to autoclose quotes."),
      p("editor.autoClosingQuotes.beforeWhitespace", "Autoclose quotes only when the cursor is to the left of whitespace."),
      ""
    ],
    description: p("autoClosingQuotes", "Controls whether the editor should automatically close quotes after the user adds an opening quote.")
  })),
  autoIndent: J(new iC(12, "autoIndent", 4, "full", ["none", "keep", "brackets", "advanced", "full"], oj, {
    enumDescriptions: [
      p("editor.autoIndent.none", "The editor will not insert indentation automatically."),
      p("editor.autoIndent.keep", "The editor will keep the current line's indentation."),
      p("editor.autoIndent.brackets", "The editor will keep the current line's indentation and honor language defined brackets."),
      p("editor.autoIndent.advanced", "The editor will keep the current line's indentation, honor language defined brackets and invoke special onEnterRules defined by languages."),
      p("editor.autoIndent.full", "The editor will keep the current line's indentation, honor language defined brackets, invoke special onEnterRules defined by languages, and honor indentationRules defined by languages.")
    ],
    description: p("autoIndent", "Controls whether the editor should automatically adjust the indentation when users type, paste, move or indent lines.")
  })),
  automaticLayout: J(new lt(13, "automaticLayout", !1)),
  autoSurround: J(new oi(14, "autoSurround", "languageDefined", ["languageDefined", "quotes", "brackets", "never"], {
    enumDescriptions: [
      p("editor.autoSurround.languageDefined", "Use language configurations to determine when to automatically surround selections."),
      p("editor.autoSurround.quotes", "Surround with quotes but not brackets."),
      p("editor.autoSurround.brackets", "Surround with brackets but not quotes."),
      ""
    ],
    description: p("autoSurround", "Controls whether the editor should automatically surround selections when typing quotes or brackets.")
  })),
  bracketPairColorization: J(new Oj()),
  bracketPairGuides: J(new Fj()),
  stickyTabStops: J(new lt(116, "stickyTabStops", !1, { description: p("stickyTabStops", "Emulate selection behavior of tab characters when using spaces for indentation. Selection will stick to tab stops.") })),
  codeLens: J(new lt(17, "codeLens", !0, { description: p("codeLens", "Controls whether the editor shows CodeLens.") })),
  codeLensFontFamily: J(new Qn(18, "codeLensFontFamily", "", { description: p("codeLensFontFamily", "Controls the font family for CodeLens.") })),
  codeLensFontSize: J(new Et(19, "codeLensFontSize", 0, 0, 100, {
    type: "number",
    default: 0,
    minimum: 0,
    maximum: 100,
    markdownDescription: p("codeLensFontSize", "Controls the font size in pixels for CodeLens. When set to 0, 90% of `#editor.fontSize#` is used.")
  })),
  colorDecorators: J(new lt(20, "colorDecorators", !0, { description: p("colorDecorators", "Controls whether the editor should render the inline color decorators and color picker.") })),
  colorDecoratorActivatedOn: J(new oi(148, "colorDecoratorsActivatedOn", "clickAndHover", ["clickAndHover", "hover", "click"], {
    enumDescriptions: [
      p("editor.colorDecoratorActivatedOn.clickAndHover", "Make the color picker appear both on click and hover of the color decorator"),
      p("editor.colorDecoratorActivatedOn.hover", "Make the color picker appear on hover of the color decorator"),
      p("editor.colorDecoratorActivatedOn.click", "Make the color picker appear on click of the color decorator")
    ],
    description: p("colorDecoratorActivatedOn", "Controls the condition to make a color picker appear from a color decorator")
  })),
  colorDecoratorsLimit: J(new Et(21, "colorDecoratorsLimit", 500, 1, 1e6, {
    markdownDescription: p("colorDecoratorsLimit", "Controls the max number of color decorators that can be rendered in an editor at once.")
  })),
  columnSelection: J(new lt(22, "columnSelection", !1, { description: p("columnSelection", "Enable that the selection with the mouse and keys is doing column selection.") })),
  comments: J(new aj()),
  contextmenu: J(new lt(24, "contextmenu", !0)),
  copyWithSyntaxHighlighting: J(new lt(25, "copyWithSyntaxHighlighting", !0, { description: p("copyWithSyntaxHighlighting", "Controls whether syntax highlighting should be copied into the clipboard.") })),
  cursorBlinking: J(new iC(26, "cursorBlinking", 1, "blink", ["blink", "smooth", "phase", "expand", "solid"], lj, { description: p("cursorBlinking", "Control the cursor animation style.") })),
  cursorSmoothCaretAnimation: J(new oi(27, "cursorSmoothCaretAnimation", "off", ["off", "explicit", "on"], {
    enumDescriptions: [
      p("cursorSmoothCaretAnimation.off", "Smooth caret animation is disabled."),
      p("cursorSmoothCaretAnimation.explicit", "Smooth caret animation is enabled only when the user moves the cursor with an explicit gesture."),
      p("cursorSmoothCaretAnimation.on", "Smooth caret animation is always enabled.")
    ],
    description: p("cursorSmoothCaretAnimation", "Controls whether the smooth caret animation should be enabled.")
  })),
  cursorStyle: J(new iC(28, "cursorStyle", gn.Line, "line", ["line", "block", "underline", "line-thin", "block-outline", "underline-thin"], dj, { description: p("cursorStyle", "Controls the cursor style.") })),
  cursorSurroundingLines: J(new Et(29, "cursorSurroundingLines", 0, 0, 1073741824, { description: p("cursorSurroundingLines", "Controls the minimal number of visible leading lines (minimum 0) and trailing lines (minimum 1) surrounding the cursor. Known as 'scrollOff' or 'scrollOffset' in some other editors.") })),
  cursorSurroundingLinesStyle: J(new oi(30, "cursorSurroundingLinesStyle", "default", ["default", "all"], {
    enumDescriptions: [
      p("cursorSurroundingLinesStyle.default", "`cursorSurroundingLines` is enforced only when triggered via the keyboard or API."),
      p("cursorSurroundingLinesStyle.all", "`cursorSurroundingLines` is enforced always.")
    ],
    markdownDescription: p("cursorSurroundingLinesStyle", "Controls when `#editor.cursorSurroundingLines#` should be enforced.")
  })),
  cursorWidth: J(new Et(31, "cursorWidth", 0, 0, 1073741824, { markdownDescription: p("cursorWidth", "Controls the width of the cursor when `#editor.cursorStyle#` is set to `line`.") })),
  disableLayerHinting: J(new lt(32, "disableLayerHinting", !1)),
  disableMonospaceOptimizations: J(new lt(33, "disableMonospaceOptimizations", !1)),
  domReadOnly: J(new lt(34, "domReadOnly", !1)),
  dragAndDrop: J(new lt(35, "dragAndDrop", !0, { description: p("dragAndDrop", "Controls whether the editor should allow moving selections via drag and drop.") })),
  emptySelectionClipboard: J(new hj()),
  dropIntoEditor: J(new Uj()),
  stickyScroll: J(new bj()),
  experimentalWhitespaceRendering: J(new oi(38, "experimentalWhitespaceRendering", "svg", ["svg", "font", "off"], {
    enumDescriptions: [
      p("experimentalWhitespaceRendering.svg", "Use a new rendering method with svgs."),
      p("experimentalWhitespaceRendering.font", "Use a new rendering method with font characters."),
      p("experimentalWhitespaceRendering.off", "Use the stable rendering method.")
    ],
    description: p("experimentalWhitespaceRendering", "Controls whether whitespace is rendered with a new, experimental method.")
  })),
  extraEditorClassName: J(new Qn(39, "extraEditorClassName", "")),
  fastScrollSensitivity: J(new co(40, "fastScrollSensitivity", 5, (r) => r <= 0 ? 5 : r, { markdownDescription: p("fastScrollSensitivity", "Scrolling speed multiplier when pressing `Alt`.") })),
  find: J(new uj()),
  fixedOverflowWidgets: J(new lt(42, "fixedOverflowWidgets", !1)),
  folding: J(new lt(43, "folding", !0, { description: p("folding", "Controls whether the editor has code folding enabled.") })),
  foldingStrategy: J(new oi(44, "foldingStrategy", "auto", ["auto", "indentation"], {
    enumDescriptions: [
      p("foldingStrategy.auto", "Use a language-specific folding strategy if available, else the indentation-based one."),
      p("foldingStrategy.indentation", "Use the indentation-based folding strategy.")
    ],
    description: p("foldingStrategy", "Controls the strategy for computing folding ranges.")
  })),
  foldingHighlight: J(new lt(45, "foldingHighlight", !0, { description: p("foldingHighlight", "Controls whether the editor should highlight folded ranges.") })),
  foldingImportsByDefault: J(new lt(46, "foldingImportsByDefault", !1, { description: p("foldingImportsByDefault", "Controls whether the editor automatically collapses import ranges.") })),
  foldingMaximumRegions: J(new Et(
    47,
    "foldingMaximumRegions",
    5e3,
    10,
    65e3,
    // limit must be less than foldingRanges MAX_FOLDING_REGIONS
    { description: p("foldingMaximumRegions", "The maximum number of foldable regions. Increasing this value may result in the editor becoming less responsive when the current source has a large number of foldable regions.") }
  )),
  unfoldOnClickAfterEndOfLine: J(new lt(48, "unfoldOnClickAfterEndOfLine", !1, { description: p("unfoldOnClickAfterEndOfLine", "Controls whether clicking on the empty content after a folded line will unfold the line.") })),
  fontFamily: J(new Qn(49, "fontFamily", Ss.fontFamily, { description: p("fontFamily", "Controls the font family.") })),
  fontInfo: J(new gj()),
  fontLigatures2: J(new ro()),
  fontSize: J(new fj()),
  fontWeight: J(new Ra()),
  fontVariations: J(new Or()),
  formatOnPaste: J(new lt(55, "formatOnPaste", !1, { description: p("formatOnPaste", "Controls whether the editor should automatically format the pasted content. A formatter must be available and the formatter should be able to format a range in a document.") })),
  formatOnType: J(new lt(56, "formatOnType", !1, { description: p("formatOnType", "Controls whether the editor should automatically format the line after typing.") })),
  glyphMargin: J(new lt(57, "glyphMargin", !0, { description: p("glyphMargin", "Controls whether the editor should render the vertical glyph margin. Glyph margin is mostly used for debugging.") })),
  gotoLocation: J(new pj()),
  hideCursorInOverviewRuler: J(new lt(59, "hideCursorInOverviewRuler", !1, { description: p("hideCursorInOverviewRuler", "Controls whether the cursor should be hidden in the overview ruler.") })),
  hover: J(new mj()),
  inDiffEditor: J(new lt(61, "inDiffEditor", !1)),
  letterSpacing: J(new co(64, "letterSpacing", Ss.letterSpacing, (r) => co.clamp(r, -5, 20), { description: p("letterSpacing", "Controls the letter spacing in pixels.") })),
  lightbulb: J(new vj()),
  lineDecorationsWidth: J(new wj()),
  lineHeight: J(new Sj()),
  lineNumbers: J(new Ej()),
  lineNumbersMinChars: J(new Et(69, "lineNumbersMinChars", 5, 1, 300)),
  linkedEditing: J(new lt(70, "linkedEditing", !1, { description: p("linkedEditing", "Controls whether the editor has linked editing enabled. Depending on the language, related symbols such as HTML tags, are updated while editing.") })),
  links: J(new lt(71, "links", !0, { description: p("links", "Controls whether the editor should detect links and make them clickable.") })),
  matchBrackets: J(new oi(72, "matchBrackets", "always", ["always", "near", "never"], { description: p("matchBrackets", "Highlight matching brackets.") })),
  minimap: J(new yj()),
  mouseStyle: J(new oi(74, "mouseStyle", "text", ["text", "default", "copy"])),
  mouseWheelScrollSensitivity: J(new co(75, "mouseWheelScrollSensitivity", 1, (r) => r === 0 ? 1 : r, { markdownDescription: p("mouseWheelScrollSensitivity", "A multiplier to be used on the `deltaX` and `deltaY` of mouse wheel scroll events.") })),
  mouseWheelZoom: J(new lt(76, "mouseWheelZoom", !1, {
    markdownDescription: Je ? p("mouseWheelZoom.mac", "Zoom the font of the editor when using mouse wheel and holding `Cmd`.") : p("mouseWheelZoom", "Zoom the font of the editor when using mouse wheel and holding `Ctrl`.")
  })),
  multiCursorMergeOverlapping: J(new lt(77, "multiCursorMergeOverlapping", !0, { description: p("multiCursorMergeOverlapping", "Merge multiple cursors when they are overlapping.") })),
  multiCursorModifier: J(new iC(78, "multiCursorModifier", "altKey", "alt", ["ctrlCmd", "alt"], Lj, {
    markdownEnumDescriptions: [
      p("multiCursorModifier.ctrlCmd", "Maps to `Control` on Windows and Linux and to `Command` on macOS."),
      p("multiCursorModifier.alt", "Maps to `Alt` on Windows and Linux and to `Option` on macOS.")
    ],
    markdownDescription: p({
      key: "multiCursorModifier",
      comment: [
        "- `ctrlCmd` refers to a value the setting can take and should not be localized.",
        "- `Control` and `Command` refer to the modifier keys Ctrl or Cmd on the keyboard and can be localized."
      ]
    }, "The modifier to be used to add multiple cursors with the mouse. The Go to Definition and Open Link mouse gestures will adapt such that they do not conflict with the [multicursor modifier](https://code.visualstudio.com/docs/editor/codebasics#_multicursor-modifier).")
  })),
  multiCursorPaste: J(new oi(79, "multiCursorPaste", "spread", ["spread", "full"], {
    markdownEnumDescriptions: [
      p("multiCursorPaste.spread", "Each cursor pastes a single line of the text."),
      p("multiCursorPaste.full", "Each cursor pastes the full text.")
    ],
    markdownDescription: p("multiCursorPaste", "Controls pasting when the line count of the pasted text matches the cursor count.")
  })),
  multiCursorLimit: J(new Et(80, "multiCursorLimit", 1e4, 1, 1e5, {
    markdownDescription: p("multiCursorLimit", "Controls the max number of cursors that can be in an active editor at once.")
  })),
  occurrencesHighlight: J(new oi(81, "occurrencesHighlight", "singleFile", ["off", "singleFile", "multiFile"], {
    markdownEnumDescriptions: [
      p("occurrencesHighlight.off", "Does not highlight occurrences."),
      p("occurrencesHighlight.singleFile", "Highlights occurrences only in the current file."),
      p("occurrencesHighlight.multiFile", "Experimental: Highlights occurrences across all valid open files.")
    ],
    markdownDescription: p("occurrencesHighlight", "Controls whether occurrences should be highlighted across open files.")
  })),
  overviewRulerBorder: J(new lt(82, "overviewRulerBorder", !0, { description: p("overviewRulerBorder", "Controls whether a border should be drawn around the overview ruler.") })),
  overviewRulerLanes: J(new Et(83, "overviewRulerLanes", 3, 0, 3)),
  padding: J(new Dj()),
  pasteAs: J(new $j()),
  parameterHints: J(new kj()),
  peekWidgetDefaultFocus: J(new oi(87, "peekWidgetDefaultFocus", "tree", ["tree", "editor"], {
    enumDescriptions: [
      p("peekWidgetDefaultFocus.tree", "Focus the tree when opening peek"),
      p("peekWidgetDefaultFocus.editor", "Focus the editor when opening peek")
    ],
    description: p("peekWidgetDefaultFocus", "Controls whether to focus the inline editor or the tree in the peek widget.")
  })),
  definitionLinkOpensInPeek: J(new lt(88, "definitionLinkOpensInPeek", !1, { description: p("definitionLinkOpensInPeek", "Controls whether the Go to Definition mouse gesture always opens the peek widget.") })),
  quickSuggestions: J(new Ij()),
  quickSuggestionsDelay: J(new Et(90, "quickSuggestionsDelay", 10, 0, 1073741824, { description: p("quickSuggestionsDelay", "Controls the delay in milliseconds after which quick suggestions will show up.") })),
  readOnly: J(new lt(91, "readOnly", !1)),
  readOnlyMessage: J(new Nj()),
  renameOnType: J(new lt(93, "renameOnType", !1, { description: p("renameOnType", "Controls whether the editor auto renames on type."), markdownDeprecationMessage: p("renameOnTypeDeprecate", "Deprecated, use `editor.linkedEditing` instead.") })),
  renderControlCharacters: J(new lt(94, "renderControlCharacters", !0, { description: p("renderControlCharacters", "Controls whether the editor should render control characters."), restricted: !0 })),
  renderFinalNewline: J(new oi(95, "renderFinalNewline", os ? "dimmed" : "on", ["off", "on", "dimmed"], { description: p("renderFinalNewline", "Render last line number when the file ends with a newline.") })),
  renderLineHighlight: J(new oi(96, "renderLineHighlight", "line", ["none", "gutter", "line", "all"], {
    enumDescriptions: [
      "",
      "",
      "",
      p("renderLineHighlight.all", "Highlights both the gutter and the current line.")
    ],
    description: p("renderLineHighlight", "Controls how the editor should render the current line highlight.")
  })),
  renderLineHighlightOnlyWhenFocus: J(new lt(97, "renderLineHighlightOnlyWhenFocus", !1, { description: p("renderLineHighlightOnlyWhenFocus", "Controls if the editor should render the current line highlight only when the editor is focused.") })),
  renderValidationDecorations: J(new oi(98, "renderValidationDecorations", "editable", ["editable", "on", "off"])),
  renderWhitespace: J(new oi(99, "renderWhitespace", "selection", ["none", "boundary", "selection", "trailing", "all"], {
    enumDescriptions: [
      "",
      p("renderWhitespace.boundary", "Render whitespace characters except for single spaces between words."),
      p("renderWhitespace.selection", "Render whitespace characters only on selected text."),
      p("renderWhitespace.trailing", "Render only trailing whitespace characters."),
      ""
    ],
    description: p("renderWhitespace", "Controls how the editor should render whitespace characters.")
  })),
  revealHorizontalRightPadding: J(new Et(100, "revealHorizontalRightPadding", 15, 0, 1e3)),
  roundedSelection: J(new lt(101, "roundedSelection", !0, { description: p("roundedSelection", "Controls whether selections should have rounded corners.") })),
  rulers: J(new Tj()),
  scrollbar: J(new Mj()),
  scrollBeyondLastColumn: J(new Et(104, "scrollBeyondLastColumn", 4, 0, 1073741824, { description: p("scrollBeyondLastColumn", "Controls the number of extra characters beyond which the editor will scroll horizontally.") })),
  scrollBeyondLastLine: J(new lt(105, "scrollBeyondLastLine", !0, { description: p("scrollBeyondLastLine", "Controls whether the editor will scroll beyond the last line.") })),
  scrollPredominantAxis: J(new lt(106, "scrollPredominantAxis", !0, { description: p("scrollPredominantAxis", "Scroll only along the predominant axis when scrolling both vertically and horizontally at the same time. Prevents horizontal drift when scrolling vertically on a trackpad.") })),
  selectionClipboard: J(new lt(107, "selectionClipboard", !0, {
    description: p("selectionClipboard", "Controls whether the Linux primary clipboard should be supported."),
    included: os
  })),
  selectionHighlight: J(new lt(108, "selectionHighlight", !0, { description: p("selectionHighlight", "Controls whether the editor should highlight matches similar to the selection.") })),
  selectOnLineNumbers: J(new lt(109, "selectOnLineNumbers", !0)),
  showFoldingControls: J(new oi(110, "showFoldingControls", "mouseover", ["always", "never", "mouseover"], {
    enumDescriptions: [
      p("showFoldingControls.always", "Always show the folding controls."),
      p("showFoldingControls.never", "Never show the folding controls and reduce the gutter size."),
      p("showFoldingControls.mouseover", "Only show the folding controls when the mouse is over the gutter.")
    ],
    description: p("showFoldingControls", "Controls when the folding controls on the gutter are shown.")
  })),
  showUnused: J(new lt(111, "showUnused", !0, { description: p("showUnused", "Controls fading out of unused code.") })),
  showDeprecated: J(new lt(140, "showDeprecated", !0, { description: p("showDeprecated", "Controls strikethrough deprecated variables.") })),
  inlayHints: J(new Cj()),
  snippetSuggestions: J(new oi(112, "snippetSuggestions", "inline", ["top", "bottom", "inline", "none"], {
    enumDescriptions: [
      p("snippetSuggestions.top", "Show snippet suggestions on top of other suggestions."),
      p("snippetSuggestions.bottom", "Show snippet suggestions below other suggestions."),
      p("snippetSuggestions.inline", "Show snippets suggestions with other suggestions."),
      p("snippetSuggestions.none", "Do not show snippet suggestions.")
    ],
    description: p("snippetSuggestions", "Controls whether snippets are shown with other suggestions and how they are sorted.")
  })),
  smartSelect: J(new Bj()),
  smoothScrolling: J(new lt(114, "smoothScrolling", !1, { description: p("smoothScrolling", "Controls whether the editor will scroll using an animation.") })),
  stopRenderingLineAfter: J(new Et(
    117,
    "stopRenderingLineAfter",
    1e4,
    -1,
    1073741824
    /* Constants.MAX_SAFE_SMALL_INTEGER */
  )),
  suggest: J(new Wj()),
  inlineSuggest: J(new Aj()),
  inlineEdit: J(new Pj()),
  inlineCompletionsAccessibilityVerbose: J(new lt(149, "inlineCompletionsAccessibilityVerbose", !1, { description: p("inlineCompletionsAccessibilityVerbose", "Controls whether the accessibility hint should be provided to screen reader users when an inline completion is shown.") })),
  suggestFontSize: J(new Et(119, "suggestFontSize", 0, 0, 1e3, { markdownDescription: p("suggestFontSize", "Font size for the suggest widget. When set to {0}, the value of {1} is used.", "`0`", "`#editor.fontSize#`") })),
  suggestLineHeight: J(new Et(120, "suggestLineHeight", 0, 0, 1e3, { markdownDescription: p("suggestLineHeight", "Line height for the suggest widget. When set to {0}, the value of {1} is used. The minimum value is 8.", "`0`", "`#editor.lineHeight#`") })),
  suggestOnTriggerCharacters: J(new lt(121, "suggestOnTriggerCharacters", !0, { description: p("suggestOnTriggerCharacters", "Controls whether suggestions should automatically show up when typing trigger characters.") })),
  suggestSelection: J(new oi(122, "suggestSelection", "first", ["first", "recentlyUsed", "recentlyUsedByPrefix"], {
    markdownEnumDescriptions: [
      p("suggestSelection.first", "Always select the first suggestion."),
      p("suggestSelection.recentlyUsed", "Select recent suggestions unless further typing selects one, e.g. `console.| -> console.log` because `log` has been completed recently."),
      p("suggestSelection.recentlyUsedByPrefix", "Select suggestions based on previous prefixes that have completed those suggestions, e.g. `co -> console` and `con -> const`.")
    ],
    description: p("suggestSelection", "Controls how suggestions are pre-selected when showing the suggest list.")
  })),
  tabCompletion: J(new oi(123, "tabCompletion", "off", ["on", "off", "onlySnippets"], {
    enumDescriptions: [
      p("tabCompletion.on", "Tab complete will insert the best matching suggestion when pressing tab."),
      p("tabCompletion.off", "Disable tab completions."),
      p("tabCompletion.onlySnippets", "Tab complete snippets when their prefix match. Works best when 'quickSuggestions' aren't enabled.")
    ],
    description: p("tabCompletion", "Enables tab completions.")
  })),
  tabIndex: J(new Et(
    124,
    "tabIndex",
    0,
    -1,
    1073741824
    /* Constants.MAX_SAFE_SMALL_INTEGER */
  )),
  unicodeHighlight: J(new Rj()),
  unusualLineTerminators: J(new oi(126, "unusualLineTerminators", "prompt", ["auto", "off", "prompt"], {
    enumDescriptions: [
      p("unusualLineTerminators.auto", "Unusual line terminators are automatically removed."),
      p("unusualLineTerminators.off", "Unusual line terminators are ignored."),
      p("unusualLineTerminators.prompt", "Unusual line terminators prompt to be removed.")
    ],
    description: p("unusualLineTerminators", "Remove unusual line terminators that might cause problems.")
  })),
  useShadowDOM: J(new lt(127, "useShadowDOM", !0)),
  useTabStops: J(new lt(128, "useTabStops", !0, { description: p("useTabStops", "Spaces and tabs are inserted and deleted in alignment with tab stops.") })),
  wordBreak: J(new oi(129, "wordBreak", "normal", ["normal", "keepAll"], {
    markdownEnumDescriptions: [
      p("wordBreak.normal", "Use the default line break rule."),
      p("wordBreak.keepAll", "Word breaks should not be used for Chinese/Japanese/Korean (CJK) text. Non-CJK text behavior is the same as for normal.")
    ],
    description: p("wordBreak", "Controls the word break rules used for Chinese/Japanese/Korean (CJK) text.")
  })),
  wordSegmenterLocales: J(new Hj()),
  wordSeparators: J(new Qn(131, "wordSeparators", Q$, { description: p("wordSeparators", "Characters that will be used as word separators when doing word related navigations or operations.") })),
  wordWrap: J(new oi(132, "wordWrap", "off", ["off", "on", "wordWrapColumn", "bounded"], {
    markdownEnumDescriptions: [
      p("wordWrap.off", "Lines will never wrap."),
      p("wordWrap.on", "Lines will wrap at the viewport width."),
      p({
        key: "wordWrap.wordWrapColumn",
        comment: [
          "- `editor.wordWrapColumn` refers to a different setting and should not be localized."
        ]
      }, "Lines will wrap at `#editor.wordWrapColumn#`."),
      p({
        key: "wordWrap.bounded",
        comment: [
          "- viewport means the edge of the visible window size.",
          "- `editor.wordWrapColumn` refers to a different setting and should not be localized."
        ]
      }, "Lines will wrap at the minimum of viewport and `#editor.wordWrapColumn#`.")
    ],
    description: p({
      key: "wordWrap",
      comment: [
        "- 'off', 'on', 'wordWrapColumn' and 'bounded' refer to values the setting can take and should not be localized.",
        "- `editor.wordWrapColumn` refers to a different setting and should not be localized."
      ]
    }, "Controls how lines should wrap.")
  })),
  wordWrapBreakAfterCharacters: J(new Qn(
    133,
    "wordWrapBreakAfterCharacters",
    // allow-any-unicode-next-line
    " 	})]?|/&.,;"
  )),
  wordWrapBreakBeforeCharacters: J(new Qn(
    134,
    "wordWrapBreakBeforeCharacters",
    // allow-any-unicode-next-line
    "([{+"
  )),
  wordWrapColumn: J(new Et(135, "wordWrapColumn", 80, 1, 1073741824, {
    markdownDescription: p({
      key: "wordWrapColumn",
      comment: [
        "- `editor.wordWrap` refers to a different setting and should not be localized.",
        "- 'wordWrapColumn' and 'bounded' refer to values the different setting can take and should not be localized."
      ]
    }, "Controls the wrapping column of the editor when `#editor.wordWrap#` is `wordWrapColumn` or `bounded`.")
  })),
  wordWrapOverride1: J(new oi(136, "wordWrapOverride1", "inherit", ["off", "on", "inherit"])),
  wordWrapOverride2: J(new oi(137, "wordWrapOverride2", "inherit", ["off", "on", "inherit"])),
  // Leave these at the end (because they have dependencies!)
  editorClassName: J(new cj()),
  defaultColorDecorators: J(new lt(147, "defaultColorDecorators", !1, { markdownDescription: p("defaultColorDecorators", "Controls whether inline color decorations should be shown using the default document color provider") })),
  pixelRatio: J(new xj()),
  tabFocusMode: J(new lt(144, "tabFocusMode", !1, { markdownDescription: p("tabFocusMode", "Controls whether the editor receives tabs or defers them to the workbench for navigation.") })),
  layoutInfo: J(new hf()),
  wrappingInfo: J(new zj()),
  wrappingIndent: J(new Vj()),
  wrappingStrategy: J(new _j())
};
function Gj(r, e) {
  const t = r;
  typeof t.vscodeWindowId != "number" && Object.defineProperty(t, "vscodeWindowId", {
    get: () => e
  });
}
const Dt = window;
class Sx {
  constructor() {
    this.mapWindowIdToZoomFactor = /* @__PURE__ */ new Map();
  }
  getZoomFactor(e) {
    var t;
    return (t = this.mapWindowIdToZoomFactor.get(this.getWindowId(e))) !== null && t !== void 0 ? t : 1;
  }
  getWindowId(e) {
    return e.vscodeWindowId;
  }
}
Sx.INSTANCE = new Sx();
function yH(r, e, t) {
  typeof e == "string" && (e = r.matchMedia(e)), e.addEventListener("change", t);
}
function Zj(r) {
  return Sx.INSTANCE.getZoomFactor(r);
}
const kp = navigator.userAgent, Oo = kp.indexOf("Firefox") >= 0, su = kp.indexOf("AppleWebKit") >= 0, ob = kp.indexOf("Chrome") >= 0, ld = !ob && kp.indexOf("Safari") >= 0, LH = !ob && !ld && su;
kp.indexOf("Electron/") >= 0;
const mA = kp.indexOf("Android") >= 0;
let Lw = !1;
if (typeof Dt.matchMedia == "function") {
  const r = Dt.matchMedia("(display-mode: standalone) or (display-mode: window-controls-overlay)"), e = Dt.matchMedia("(display-mode: fullscreen)");
  Lw = r.matches, yH(Dt, r, ({ matches: t }) => {
    Lw && e.matches || (Lw = t);
  });
}
function Yj() {
  return Lw;
}
const JN = {
  clipboard: {
    writeText: zr || document.queryCommandSupported && document.queryCommandSupported("copy") || !!(navigator && navigator.clipboard && navigator.clipboard.writeText),
    readText: zr || !!(navigator && navigator.clipboard && navigator.clipboard.readText)
  },
  keyboard: zr || Yj() ? 0 : navigator.keyboard || ld ? 1 : 2,
  // 'ontouchstart' in window always evaluates to true with typescript's modern typings. This causes `window` to be
  // `never` later in `window.navigator`. That's why we need the explicit `window as Window` cast
  touch: "ontouchstart" in Dt || navigator.maxTouchPoints > 0,
  pointerEvents: Dt.PointerEvent && ("ontouchstart" in Dt || navigator.maxTouchPoints > 0)
};
function yx(r, e) {
  if (typeof r == "number") {
    if (r === 0)
      return null;
    const t = (r & 65535) >>> 0, i = (r & 4294901760) >>> 16;
    return i !== 0 ? new wD([
      nC(t, e),
      nC(i, e)
    ]) : new wD([nC(t, e)]);
  } else {
    const t = [];
    for (let i = 0; i < r.length; i++)
      t.push(nC(r[i], e));
    return new wD(t);
  }
}
function nC(r, e) {
  const t = !!(r & 2048), i = !!(r & 256), n = e === 2 ? i : t, s = !!(r & 1024), o = !!(r & 512), a = e === 2 ? t : i, l = r & 255;
  return new dd(n, s, o, a, l);
}
class dd {
  constructor(e, t, i, n, s) {
    this.ctrlKey = e, this.shiftKey = t, this.altKey = i, this.metaKey = n, this.keyCode = s;
  }
  equals(e) {
    return e instanceof dd && this.ctrlKey === e.ctrlKey && this.shiftKey === e.shiftKey && this.altKey === e.altKey && this.metaKey === e.metaKey && this.keyCode === e.keyCode;
  }
  isModifierKey() {
    return this.keyCode === 0 || this.keyCode === 5 || this.keyCode === 57 || this.keyCode === 6 || this.keyCode === 4;
  }
  /**
   * Does this keybinding refer to the key code of a modifier and it also has the modifier flag?
   */
  isDuplicateModifierCase() {
    return this.ctrlKey && this.keyCode === 5 || this.shiftKey && this.keyCode === 4 || this.altKey && this.keyCode === 6 || this.metaKey && this.keyCode === 57;
  }
}
class wD {
  constructor(e) {
    if (e.length === 0)
      throw Ro("chords");
    this.chords = e;
  }
}
class Qj {
  constructor(e, t, i, n, s, o) {
    this.ctrlKey = e, this.shiftKey = t, this.altKey = i, this.metaKey = n, this.keyLabel = s, this.keyAriaLabel = o;
  }
}
class Xj {
}
function Jj(r) {
  if (r.charCode) {
    const t = String.fromCharCode(r.charCode).toUpperCase();
    return Ph.fromString(t);
  }
  const e = r.keyCode;
  if (e === 3)
    return 7;
  if (Oo)
    switch (e) {
      case 59:
        return 85;
      case 60:
        if (os)
          return 97;
        break;
      case 61:
        return 86;
      case 107:
        return 109;
      case 109:
        return 111;
      case 173:
        return 88;
      case 224:
        if (Je)
          return 57;
        break;
    }
  else if (su) {
    if (Je && e === 93)
      return 57;
    if (!Je && e === 92)
      return 57;
  }
  return X$[e] || 0;
}
const e8 = Je ? 256 : 2048, t8 = 512, i8 = 1024, n8 = Je ? 2048 : 256;
class Mt {
  constructor(e) {
    var t;
    this._standardKeyboardEventBrand = !0;
    const i = e;
    this.browserEvent = i, this.target = i.target, this.ctrlKey = i.ctrlKey, this.shiftKey = i.shiftKey, this.altKey = i.altKey, this.metaKey = i.metaKey, this.altGraphKey = (t = i.getModifierState) === null || t === void 0 ? void 0 : t.call(i, "AltGraph"), this.keyCode = Jj(i), this.code = i.code, this.ctrlKey = this.ctrlKey || this.keyCode === 5, this.altKey = this.altKey || this.keyCode === 6, this.shiftKey = this.shiftKey || this.keyCode === 4, this.metaKey = this.metaKey || this.keyCode === 57, this._asKeybinding = this._computeKeybinding(), this._asKeyCodeChord = this._computeKeyCodeChord();
  }
  preventDefault() {
    this.browserEvent && this.browserEvent.preventDefault && this.browserEvent.preventDefault();
  }
  stopPropagation() {
    this.browserEvent && this.browserEvent.stopPropagation && this.browserEvent.stopPropagation();
  }
  toKeyCodeChord() {
    return this._asKeyCodeChord;
  }
  equals(e) {
    return this._asKeybinding === e;
  }
  _computeKeybinding() {
    let e = 0;
    this.keyCode !== 5 && this.keyCode !== 4 && this.keyCode !== 6 && this.keyCode !== 57 && (e = this.keyCode);
    let t = 0;
    return this.ctrlKey && (t |= e8), this.altKey && (t |= t8), this.shiftKey && (t |= i8), this.metaKey && (t |= n8), t |= e, t;
  }
  _computeKeyCodeChord() {
    let e = 0;
    return this.keyCode !== 5 && this.keyCode !== 4 && this.keyCode !== 6 && this.keyCode !== 57 && (e = this.keyCode), new dd(this.ctrlKey, this.shiftKey, this.altKey, this.metaKey, e);
  }
}
const _A = /* @__PURE__ */ new WeakMap();
function s8(r) {
  if (!r.parent || r.parent === r)
    return null;
  try {
    const e = r.location, t = r.parent.location;
    if (e.origin !== "null" && t.origin !== "null" && e.origin !== t.origin)
      return null;
  } catch {
    return null;
  }
  return r.parent;
}
class o8 {
  /**
   * Returns a chain of embedded windows with the same origin (which can be accessed programmatically).
   * Having a chain of length 1 might mean that the current execution environment is running outside of an iframe or inside an iframe embedded in a window with a different origin.
   */
  static getSameOriginWindowChain(e) {
    let t = _A.get(e);
    if (!t) {
      t = [], _A.set(e, t);
      let i = e, n;
      do
        n = s8(i), n ? t.push({
          window: new WeakRef(i),
          iframeElement: i.frameElement || null
        }) : t.push({
          window: new WeakRef(i),
          iframeElement: null
        }), i = n;
      while (i);
    }
    return t.slice(0);
  }
  /**
   * Returns the position of `childWindow` relative to `ancestorWindow`
   */
  static getPositionOfChildWindowRelativeToAncestorWindow(e, t) {
    var i, n;
    if (!t || e === t)
      return {
        top: 0,
        left: 0
      };
    let s = 0, o = 0;
    const a = this.getSameOriginWindowChain(e);
    for (const l of a) {
      const d = l.window.deref();
      if (s += (i = d == null ? void 0 : d.scrollY) !== null && i !== void 0 ? i : 0, o += (n = d == null ? void 0 : d.scrollX) !== null && n !== void 0 ? n : 0, d === t || !l.iframeElement)
        break;
      const c = l.iframeElement.getBoundingClientRect();
      s += c.top, o += c.left;
    }
    return {
      top: s,
      left: o
    };
  }
}
class rr {
  constructor(e, t) {
    this.timestamp = Date.now(), this.browserEvent = t, this.leftButton = t.button === 0, this.middleButton = t.button === 1, this.rightButton = t.button === 2, this.buttons = t.buttons, this.target = t.target, this.detail = t.detail || 1, t.type === "dblclick" && (this.detail = 2), this.ctrlKey = t.ctrlKey, this.shiftKey = t.shiftKey, this.altKey = t.altKey, this.metaKey = t.metaKey, typeof t.pageX == "number" ? (this.posx = t.pageX, this.posy = t.pageY) : (this.posx = t.clientX + this.target.ownerDocument.body.scrollLeft + this.target.ownerDocument.documentElement.scrollLeft, this.posy = t.clientY + this.target.ownerDocument.body.scrollTop + this.target.ownerDocument.documentElement.scrollTop);
    const i = o8.getPositionOfChildWindowRelativeToAncestorWindow(e, t.view);
    this.posx -= i.left, this.posy -= i.top;
  }
  preventDefault() {
    this.browserEvent.preventDefault();
  }
  stopPropagation() {
    this.browserEvent.stopPropagation();
  }
}
class bu {
  constructor(e, t = 0, i = 0) {
    var n;
    this.browserEvent = e || null, this.target = e ? e.target || e.targetNode || e.srcElement : null, this.deltaY = i, this.deltaX = t;
    let s = !1;
    if (ob) {
      const o = navigator.userAgent.match(/Chrome\/(\d+)/);
      s = (o ? parseInt(o[1]) : 123) <= 122;
    }
    if (e) {
      const o = e, a = e, l = ((n = e.view) === null || n === void 0 ? void 0 : n.devicePixelRatio) || 1;
      if (typeof o.wheelDeltaY < "u")
        s ? this.deltaY = o.wheelDeltaY / (120 * l) : this.deltaY = o.wheelDeltaY / 120;
      else if (typeof a.VERTICAL_AXIS < "u" && a.axis === a.VERTICAL_AXIS)
        this.deltaY = -a.detail / 3;
      else if (e.type === "wheel") {
        const d = e;
        d.deltaMode === d.DOM_DELTA_LINE ? Oo && !Je ? this.deltaY = -e.deltaY / 3 : this.deltaY = -e.deltaY : this.deltaY = -e.deltaY / 40;
      }
      if (typeof o.wheelDeltaX < "u")
        ld && Ks ? this.deltaX = -(o.wheelDeltaX / 120) : s ? this.deltaX = o.wheelDeltaX / (120 * l) : this.deltaX = o.wheelDeltaX / 120;
      else if (typeof a.HORIZONTAL_AXIS < "u" && a.axis === a.HORIZONTAL_AXIS)
        this.deltaX = -e.detail / 3;
      else if (e.type === "wheel") {
        const d = e;
        d.deltaMode === d.DOM_DELTA_LINE ? Oo && !Je ? this.deltaX = -e.deltaX / 3 : this.deltaX = -e.deltaX : this.deltaX = -e.deltaX / 40;
      }
      this.deltaY === 0 && this.deltaX === 0 && e.wheelDelta && (s ? this.deltaY = e.wheelDelta / (120 * l) : this.deltaY = e.wheelDelta / 120);
    }
  }
  preventDefault() {
    var e;
    (e = this.browserEvent) === null || e === void 0 || e.preventDefault();
  }
  stopPropagation() {
    var e;
    (e = this.browserEvent) === null || e === void 0 || e.stopPropagation();
  }
}
const DH = Symbol("MicrotaskDelay");
function Lx(r) {
  return !!r && typeof r.then == "function";
}
function Zi(r) {
  const e = new mi(), t = r(e.token), i = new Promise((n, s) => {
    const o = e.token.onCancellationRequested(() => {
      o.dispose(), s(new Ja());
    });
    Promise.resolve(t).then((a) => {
      o.dispose(), e.dispose(), n(a);
    }, (a) => {
      o.dispose(), e.dispose(), s(a);
    });
  });
  return new class {
    cancel() {
      e.cancel(), e.dispose();
    }
    then(n, s) {
      return i.then(n, s);
    }
    catch(n) {
      return this.then(void 0, n);
    }
    finally(n) {
      return i.finally(n);
    }
  }();
}
function rb(r, e, t) {
  return new Promise((i, n) => {
    const s = e.onCancellationRequested(() => {
      s.dispose(), i(t);
    });
    r.then(i, n).finally(() => s.dispose());
  });
}
class r8 {
  constructor() {
    this.isDisposed = !1, this.activePromise = null, this.queuedPromise = null, this.queuedPromiseFactory = null;
  }
  queue(e) {
    if (this.isDisposed)
      return Promise.reject(new Error("Throttler is disposed"));
    if (this.activePromise) {
      if (this.queuedPromiseFactory = e, !this.queuedPromise) {
        const t = () => {
          if (this.queuedPromise = null, this.isDisposed)
            return;
          const i = this.queue(this.queuedPromiseFactory);
          return this.queuedPromiseFactory = null, i;
        };
        this.queuedPromise = new Promise((i) => {
          this.activePromise.then(t, t).then(i);
        });
      }
      return new Promise((t, i) => {
        this.queuedPromise.then(t, i);
      });
    }
    return this.activePromise = e(), new Promise((t, i) => {
      this.activePromise.then((n) => {
        this.activePromise = null, t(n);
      }, (n) => {
        this.activePromise = null, i(n);
      });
    });
  }
  dispose() {
    this.isDisposed = !0;
  }
}
const a8 = (r, e) => {
  let t = !0;
  const i = setTimeout(() => {
    t = !1, e();
  }, r);
  return {
    isTriggered: () => t,
    dispose: () => {
      clearTimeout(i), t = !1;
    }
  };
}, l8 = (r) => {
  let e = !0;
  return queueMicrotask(() => {
    e && (e = !1, r());
  }), {
    isTriggered: () => e,
    dispose: () => {
      e = !1;
    }
  };
};
class pr {
  constructor(e) {
    this.defaultDelay = e, this.deferred = null, this.completionPromise = null, this.doResolve = null, this.doReject = null, this.task = null;
  }
  trigger(e, t = this.defaultDelay) {
    this.task = e, this.cancelTimeout(), this.completionPromise || (this.completionPromise = new Promise((n, s) => {
      this.doResolve = n, this.doReject = s;
    }).then(() => {
      if (this.completionPromise = null, this.doResolve = null, this.task) {
        const n = this.task;
        return this.task = null, n();
      }
    }));
    const i = () => {
      var n;
      this.deferred = null, (n = this.doResolve) === null || n === void 0 || n.call(this, null);
    };
    return this.deferred = t === DH ? l8(i) : a8(t, i), this.completionPromise;
  }
  isTriggered() {
    var e;
    return !!(!((e = this.deferred) === null || e === void 0) && e.isTriggered());
  }
  cancel() {
    var e;
    this.cancelTimeout(), this.completionPromise && ((e = this.doReject) === null || e === void 0 || e.call(this, new Ja()), this.completionPromise = null);
  }
  cancelTimeout() {
    var e;
    (e = this.deferred) === null || e === void 0 || e.dispose(), this.deferred = null;
  }
  dispose() {
    this.cancel();
  }
}
class kH {
  constructor(e) {
    this.delayer = new pr(e), this.throttler = new r8();
  }
  trigger(e, t) {
    return this.delayer.trigger(() => this.throttler.queue(e), t);
  }
  cancel() {
    this.delayer.cancel();
  }
  dispose() {
    this.delayer.dispose(), this.throttler.dispose();
  }
}
function cd(r, e) {
  return e ? new Promise((t, i) => {
    const n = setTimeout(() => {
      s.dispose(), t();
    }, r), s = e.onCancellationRequested(() => {
      clearTimeout(n), s.dispose(), i(new Ja());
    });
  }) : Zi((t) => cd(r, t));
}
function Mc(r, e = 0, t) {
  const i = setTimeout(() => {
    r(), t && n.dispose();
  }, e), n = Se(() => {
    clearTimeout(i), t == null || t.deleteAndLeak(n);
  });
  return t == null || t.add(n), n;
}
function e1(r, e = (i) => !!i, t = null) {
  let i = 0;
  const n = r.length, s = () => {
    if (i >= n)
      return Promise.resolve(t);
    const o = r[i++];
    return Promise.resolve(o()).then((l) => e(l) ? Promise.resolve(l) : s());
  };
  return s();
}
class vr {
  constructor(e, t) {
    this._isDisposed = !1, this._token = -1, typeof e == "function" && typeof t == "number" && this.setIfNotSet(e, t);
  }
  dispose() {
    this.cancel(), this._isDisposed = !0;
  }
  cancel() {
    this._token !== -1 && (clearTimeout(this._token), this._token = -1);
  }
  cancelAndSet(e, t) {
    if (this._isDisposed)
      throw new Li("Calling 'cancelAndSet' on a disposed TimeoutTimer");
    this.cancel(), this._token = setTimeout(() => {
      this._token = -1, e();
    }, t);
  }
  setIfNotSet(e, t) {
    if (this._isDisposed)
      throw new Li("Calling 'setIfNotSet' on a disposed TimeoutTimer");
    this._token === -1 && (this._token = setTimeout(() => {
      this._token = -1, e();
    }, t));
  }
}
class t1 {
  constructor() {
    this.disposable = void 0, this.isDisposed = !1;
  }
  cancel() {
    var e;
    (e = this.disposable) === null || e === void 0 || e.dispose(), this.disposable = void 0;
  }
  cancelAndSet(e, t, i = globalThis) {
    if (this.isDisposed)
      throw new Li("Calling 'cancelAndSet' on a disposed IntervalTimer");
    this.cancel();
    const n = i.setInterval(() => {
      e();
    }, t);
    this.disposable = Se(() => {
      i.clearInterval(n), this.disposable = void 0;
    });
  }
  dispose() {
    this.cancel(), this.isDisposed = !0;
  }
}
class xt {
  constructor(e, t) {
    this.timeoutToken = -1, this.runner = e, this.timeout = t, this.timeoutHandler = this.onTimeout.bind(this);
  }
  /**
   * Dispose RunOnceScheduler
   */
  dispose() {
    this.cancel(), this.runner = null;
  }
  /**
   * Cancel current scheduled runner (if any).
   */
  cancel() {
    this.isScheduled() && (clearTimeout(this.timeoutToken), this.timeoutToken = -1);
  }
  /**
   * Cancel previous runner (if any) & schedule a new runner.
   */
  schedule(e = this.timeout) {
    this.cancel(), this.timeoutToken = setTimeout(this.timeoutHandler, e);
  }
  get delay() {
    return this.timeout;
  }
  set delay(e) {
    this.timeout = e;
  }
  /**
   * Returns true if scheduled.
   */
  isScheduled() {
    return this.timeoutToken !== -1;
  }
  onTimeout() {
    this.timeoutToken = -1, this.runner && this.doRun();
  }
  doRun() {
    var e;
    (e = this.runner) === null || e === void 0 || e.call(this);
  }
}
let xH, Xm;
(function() {
  typeof globalThis.requestIdleCallback != "function" || typeof globalThis.cancelIdleCallback != "function" ? Xm = (r, e) => {
    UB(() => {
      if (t)
        return;
      const i = Date.now() + 15;
      e(Object.freeze({
        didTimeout: !0,
        timeRemaining() {
          return Math.max(0, i - Date.now());
        }
      }));
    });
    let t = !1;
    return {
      dispose() {
        t || (t = !0);
      }
    };
  } : Xm = (r, e, t) => {
    const i = r.requestIdleCallback(e, typeof t == "number" ? { timeout: t } : void 0);
    let n = !1;
    return {
      dispose() {
        n || (n = !0, r.cancelIdleCallback(i));
      }
    };
  }, xH = (r) => Xm(globalThis, r);
})();
class IH {
  constructor(e, t) {
    this._didRun = !1, this._executor = () => {
      try {
        this._value = t();
      } catch (i) {
        this._error = i;
      } finally {
        this._didRun = !0;
      }
    }, this._handle = Xm(e, () => this._executor());
  }
  dispose() {
    this._handle.dispose();
  }
  get value() {
    if (this._didRun || (this._handle.dispose(), this._executor()), this._error)
      throw this._error;
    return this._value;
  }
  get isInitialized() {
    return this._didRun;
  }
}
class d8 extends IH {
  constructor(e) {
    super(globalThis, e);
  }
}
class ab {
  get isRejected() {
    var e;
    return ((e = this.outcome) === null || e === void 0 ? void 0 : e.outcome) === 1;
  }
  get isSettled() {
    return !!this.outcome;
  }
  constructor() {
    this.p = new Promise((e, t) => {
      this.completeCallback = e, this.errorCallback = t;
    });
  }
  complete(e) {
    return new Promise((t) => {
      this.completeCallback(e), this.outcome = { outcome: 0, value: e }, t();
    });
  }
  error(e) {
    return new Promise((t) => {
      this.errorCallback(e), this.outcome = { outcome: 1, value: e }, t();
    });
  }
  cancel() {
    return this.error(new Ja());
  }
}
var Dx;
(function(r) {
  async function e(i) {
    let n;
    const s = await Promise.all(i.map((o) => o.then((a) => a, (a) => {
      n || (n = a);
    })));
    if (typeof n < "u")
      throw n;
    return s;
  }
  r.settled = e;
  function t(i) {
    return new Promise(async (n, s) => {
      try {
        await i(n, s);
      } catch (o) {
        s(o);
      }
    });
  }
  r.withAsyncBody = t;
})(Dx || (Dx = {}));
class Ni {
  static fromArray(e) {
    return new Ni((t) => {
      t.emitMany(e);
    });
  }
  static fromPromise(e) {
    return new Ni(async (t) => {
      t.emitMany(await e);
    });
  }
  static fromPromises(e) {
    return new Ni(async (t) => {
      await Promise.all(e.map(async (i) => t.emitOne(await i)));
    });
  }
  static merge(e) {
    return new Ni(async (t) => {
      await Promise.all(e.map(async (i) => {
        for await (const n of i)
          t.emitOne(n);
      }));
    });
  }
  constructor(e, t) {
    this._state = 0, this._results = [], this._error = null, this._onReturn = t, this._onStateChanged = new R(), queueMicrotask(async () => {
      const i = {
        emitOne: (n) => this.emitOne(n),
        emitMany: (n) => this.emitMany(n),
        reject: (n) => this.reject(n)
      };
      try {
        await Promise.resolve(e(i)), this.resolve();
      } catch (n) {
        this.reject(n);
      } finally {
        i.emitOne = void 0, i.emitMany = void 0, i.reject = void 0;
      }
    });
  }
  [Symbol.asyncIterator]() {
    let e = 0;
    return {
      next: async () => {
        do {
          if (this._state === 2)
            throw this._error;
          if (e < this._results.length)
            return { done: !1, value: this._results[e++] };
          if (this._state === 1)
            return { done: !0, value: void 0 };
          await ne.toPromise(this._onStateChanged.event);
        } while (!0);
      },
      return: async () => {
        var t;
        return (t = this._onReturn) === null || t === void 0 || t.call(this), { done: !0, value: void 0 };
      }
    };
  }
  static map(e, t) {
    return new Ni(async (i) => {
      for await (const n of e)
        i.emitOne(t(n));
    });
  }
  map(e) {
    return Ni.map(this, e);
  }
  static filter(e, t) {
    return new Ni(async (i) => {
      for await (const n of e)
        t(n) && i.emitOne(n);
    });
  }
  filter(e) {
    return Ni.filter(this, e);
  }
  static coalesce(e) {
    return Ni.filter(e, (t) => !!t);
  }
  coalesce() {
    return Ni.coalesce(this);
  }
  static async toPromise(e) {
    const t = [];
    for await (const i of e)
      t.push(i);
    return t;
  }
  toPromise() {
    return Ni.toPromise(this);
  }
  /**
   * The value will be appended at the end.
   *
   * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.
   */
  emitOne(e) {
    this._state === 0 && (this._results.push(e), this._onStateChanged.fire());
  }
  /**
   * The values will be appended at the end.
   *
   * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.
   */
  emitMany(e) {
    this._state === 0 && (this._results = this._results.concat(e), this._onStateChanged.fire());
  }
  /**
   * Calling `resolve()` will mark the result array as complete.
   *
   * **NOTE** `resolve()` must be called, otherwise all consumers of this iterable will hang indefinitely, similar to a non-resolved promise.
   * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.
   */
  resolve() {
    this._state === 0 && (this._state = 1, this._onStateChanged.fire());
  }
  /**
   * Writing an error will permanently invalidate this iterable.
   * The current users will receive an error thrown, as will all future users.
   *
   * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.
   */
  reject(e) {
    this._state === 0 && (this._state = 2, this._error = e, this._onStateChanged.fire());
  }
}
Ni.EMPTY = Ni.fromArray([]);
class c8 extends Ni {
  constructor(e, t) {
    super(t), this._source = e;
  }
  cancel() {
    this._source.cancel();
  }
}
function h8(r) {
  const e = new mi(), t = r(e.token);
  return new c8(e, async (i) => {
    const n = e.token.onCancellationRequested(() => {
      n.dispose(), e.dispose(), i.reject(new Ja());
    });
    try {
      for await (const s of t) {
        if (e.token.isCancellationRequested)
          return;
        i.emitOne(s);
      }
      n.dispose(), e.dispose();
    } catch (s) {
      n.dispose(), e.dispose(), i.reject(s);
    }
  });
}
/*! @license DOMPurify 3.0.5 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.0.5/LICENSE */
const {
  entries: EH,
  setPrototypeOf: vA,
  isFrozen: u8,
  getPrototypeOf: g8,
  getOwnPropertyDescriptor: f8
} = Object;
let {
  freeze: zs,
  seal: Qr,
  create: p8
} = Object, {
  apply: kx,
  construct: xx
} = typeof Reflect < "u" && Reflect;
kx || (kx = function(e, t, i) {
  return e.apply(t, i);
});
zs || (zs = function(e) {
  return e;
});
Qr || (Qr = function(e) {
  return e;
});
xx || (xx = function(e, t) {
  return new e(...t);
});
const m8 = mr(Array.prototype.forEach), bA = mr(Array.prototype.pop), Yp = mr(Array.prototype.push), Dw = mr(String.prototype.toLowerCase), SD = mr(String.prototype.toString), _8 = mr(String.prototype.match), Sr = mr(String.prototype.replace), v8 = mr(String.prototype.indexOf), b8 = mr(String.prototype.trim), yo = mr(RegExp.prototype.test), Qp = C8(TypeError);
function mr(r) {
  return function(e) {
    for (var t = arguments.length, i = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++)
      i[n - 1] = arguments[n];
    return kx(r, e, i);
  };
}
function C8(r) {
  return function() {
    for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
      t[i] = arguments[i];
    return xx(r, t);
  };
}
function yt(r, e, t) {
  var i;
  t = (i = t) !== null && i !== void 0 ? i : Dw, vA && vA(r, null);
  let n = e.length;
  for (; n--; ) {
    let s = e[n];
    if (typeof s == "string") {
      const o = t(s);
      o !== s && (u8(e) || (e[n] = o), s = o);
    }
    r[s] = !0;
  }
  return r;
}
function fg(r) {
  const e = p8(null);
  for (const [t, i] of EH(r))
    e[t] = i;
  return e;
}
function sC(r, e) {
  for (; r !== null; ) {
    const i = f8(r, e);
    if (i) {
      if (i.get)
        return mr(i.get);
      if (typeof i.value == "function")
        return mr(i.value);
    }
    r = g8(r);
  }
  function t(i) {
    return console.warn("fallback value for", i), null;
  }
  return t;
}
const CA = zs(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), yD = zs(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), LD = zs(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), w8 = zs(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), DD = zs(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]), S8 = zs(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), wA = zs(["#text"]), SA = zs(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "xmlns", "slot"]), kD = zs(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), yA = zs(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), oC = zs(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), y8 = Qr(/\{\{[\w\W]*|[\w\W]*\}\}/gm), L8 = Qr(/<%[\w\W]*|[\w\W]*%>/gm), D8 = Qr(/\${[\w\W]*}/gm), k8 = Qr(/^data-[\-\w.\u00B7-\uFFFF]/), x8 = Qr(/^aria-[\-\w]+$/), TH = Qr(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
  // eslint-disable-line no-useless-escape
), I8 = Qr(/^(?:\w+script|data):/i), E8 = Qr(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
  // eslint-disable-line no-control-regex
), NH = Qr(/^html$/i);
var LA = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  MUSTACHE_EXPR: y8,
  ERB_EXPR: L8,
  TMPLIT_EXPR: D8,
  DATA_ATTR: k8,
  ARIA_ATTR: x8,
  IS_ALLOWED_URI: TH,
  IS_SCRIPT_OR_DATA: I8,
  ATTR_WHITESPACE: E8,
  DOCTYPE_NAME: NH
});
const T8 = () => typeof window > "u" ? null : window, N8 = function(e, t) {
  if (typeof e != "object" || typeof e.createPolicy != "function")
    return null;
  let i = null;
  const n = "data-tt-policy-suffix";
  t && t.hasAttribute(n) && (i = t.getAttribute(n));
  const s = "dompurify" + (i ? "#" + i : "");
  try {
    return e.createPolicy(s, {
      createHTML(o) {
        return o;
      },
      createScriptURL(o) {
        return o;
      }
    });
  } catch {
    return console.warn("TrustedTypes policy " + s + " could not be created."), null;
  }
};
function MH() {
  let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : T8();
  const e = (Xe) => MH(Xe);
  if (e.version = "3.0.5", e.removed = [], !r || !r.document || r.document.nodeType !== 9)
    return e.isSupported = !1, e;
  const t = r.document, i = t.currentScript;
  let {
    document: n
  } = r;
  const {
    DocumentFragment: s,
    HTMLTemplateElement: o,
    Node: a,
    Element: l,
    NodeFilter: d,
    NamedNodeMap: c = r.NamedNodeMap || r.MozNamedAttrMap,
    HTMLFormElement: h,
    DOMParser: u,
    trustedTypes: g
  } = r, f = l.prototype, m = sC(f, "cloneNode"), _ = sC(f, "nextSibling"), v = sC(f, "childNodes"), b = sC(f, "parentNode");
  if (typeof o == "function") {
    const Xe = n.createElement("template");
    Xe.content && Xe.content.ownerDocument && (n = Xe.content.ownerDocument);
  }
  let C, w = "";
  const {
    implementation: S,
    createNodeIterator: y,
    createDocumentFragment: k,
    getElementsByTagName: E
  } = n, {
    importNode: N
  } = t;
  let F = {};
  e.isSupported = typeof EH == "function" && typeof b == "function" && S && S.createHTMLDocument !== void 0;
  const {
    MUSTACHE_EXPR: V,
    ERB_EXPR: Z,
    TMPLIT_EXPR: H,
    DATA_ATTR: re,
    ARIA_ATTR: ue,
    IS_SCRIPT_OR_DATA: Ve,
    ATTR_WHITESPACE: Ye
  } = LA;
  let {
    IS_ALLOWED_URI: ze
  } = LA, pe = null;
  const $e = yt({}, [...CA, ...yD, ...LD, ...DD, ...wA]);
  let Be = null;
  const Te = yt({}, [...SA, ...kD, ...yA, ...oC]);
  let ce = Object.seal(Object.create(null, {
    tagNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    attributeNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: !1
    }
  })), Fi = null, Is = null, Qi = !0, Ct = !0, Ki = !1, Gn = !0, dn = !1, Ue = !1, jo = !1, qo = !1, Qs = !1, pl = !1, Xi = !1, Cr = !0, Yb = !1;
  const pD = "user-content-";
  let te = !0, j = !1, $ = {}, T = null;
  const M = yt({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
  let B = null;
  const O = yt({}, ["audio", "video", "img", "source", "image", "track"]);
  let ee = null;
  const de = yt({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), ye = "http://www.w3.org/1998/Math/MathML", Ie = "http://www.w3.org/2000/svg", Ze = "http://www.w3.org/1999/xhtml";
  let Ke = Ze, Ft = !1, It = null;
  const Oe = yt({}, [ye, Ie, Ze], SD);
  let vi;
  const bi = ["application/xhtml+xml", "text/html"], Go = "text/html";
  let St, Wi = null;
  const uh = n.createElement("form"), gh = function(K) {
    return K instanceof RegExp || K instanceof Function;
  }, wr = function(K) {
    if (!(Wi && Wi === K)) {
      if ((!K || typeof K != "object") && (K = {}), K = fg(K), vi = // eslint-disable-next-line unicorn/prefer-includes
      bi.indexOf(K.PARSER_MEDIA_TYPE) === -1 ? vi = Go : vi = K.PARSER_MEDIA_TYPE, St = vi === "application/xhtml+xml" ? SD : Dw, pe = "ALLOWED_TAGS" in K ? yt({}, K.ALLOWED_TAGS, St) : $e, Be = "ALLOWED_ATTR" in K ? yt({}, K.ALLOWED_ATTR, St) : Te, It = "ALLOWED_NAMESPACES" in K ? yt({}, K.ALLOWED_NAMESPACES, SD) : Oe, ee = "ADD_URI_SAFE_ATTR" in K ? yt(
        fg(de),
        // eslint-disable-line indent
        K.ADD_URI_SAFE_ATTR,
        // eslint-disable-line indent
        St
        // eslint-disable-line indent
      ) : de, B = "ADD_DATA_URI_TAGS" in K ? yt(
        fg(O),
        // eslint-disable-line indent
        K.ADD_DATA_URI_TAGS,
        // eslint-disable-line indent
        St
        // eslint-disable-line indent
      ) : O, T = "FORBID_CONTENTS" in K ? yt({}, K.FORBID_CONTENTS, St) : M, Fi = "FORBID_TAGS" in K ? yt({}, K.FORBID_TAGS, St) : {}, Is = "FORBID_ATTR" in K ? yt({}, K.FORBID_ATTR, St) : {}, $ = "USE_PROFILES" in K ? K.USE_PROFILES : !1, Qi = K.ALLOW_ARIA_ATTR !== !1, Ct = K.ALLOW_DATA_ATTR !== !1, Ki = K.ALLOW_UNKNOWN_PROTOCOLS || !1, Gn = K.ALLOW_SELF_CLOSE_IN_ATTR !== !1, dn = K.SAFE_FOR_TEMPLATES || !1, Ue = K.WHOLE_DOCUMENT || !1, Qs = K.RETURN_DOM || !1, pl = K.RETURN_DOM_FRAGMENT || !1, Xi = K.RETURN_TRUSTED_TYPE || !1, qo = K.FORCE_BODY || !1, Cr = K.SANITIZE_DOM !== !1, Yb = K.SANITIZE_NAMED_PROPS || !1, te = K.KEEP_CONTENT !== !1, j = K.IN_PLACE || !1, ze = K.ALLOWED_URI_REGEXP || TH, Ke = K.NAMESPACE || Ze, ce = K.CUSTOM_ELEMENT_HANDLING || {}, K.CUSTOM_ELEMENT_HANDLING && gh(K.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (ce.tagNameCheck = K.CUSTOM_ELEMENT_HANDLING.tagNameCheck), K.CUSTOM_ELEMENT_HANDLING && gh(K.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (ce.attributeNameCheck = K.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), K.CUSTOM_ELEMENT_HANDLING && typeof K.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (ce.allowCustomizedBuiltInElements = K.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), dn && (Ct = !1), pl && (Qs = !0), $ && (pe = yt({}, [...wA]), Be = [], $.html === !0 && (yt(pe, CA), yt(Be, SA)), $.svg === !0 && (yt(pe, yD), yt(Be, kD), yt(Be, oC)), $.svgFilters === !0 && (yt(pe, LD), yt(Be, kD), yt(Be, oC)), $.mathMl === !0 && (yt(pe, DD), yt(Be, yA), yt(Be, oC))), K.ADD_TAGS && (pe === $e && (pe = fg(pe)), yt(pe, K.ADD_TAGS, St)), K.ADD_ATTR && (Be === Te && (Be = fg(Be)), yt(Be, K.ADD_ATTR, St)), K.ADD_URI_SAFE_ATTR && yt(ee, K.ADD_URI_SAFE_ATTR, St), K.FORBID_CONTENTS && (T === M && (T = fg(T)), yt(T, K.FORBID_CONTENTS, St)), te && (pe["#text"] = !0), Ue && yt(pe, ["html", "head", "body"]), pe.table && (yt(pe, ["tbody"]), delete Fi.tbody), K.TRUSTED_TYPES_POLICY) {
        if (typeof K.TRUSTED_TYPES_POLICY.createHTML != "function")
          throw Qp('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
        if (typeof K.TRUSTED_TYPES_POLICY.createScriptURL != "function")
          throw Qp('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
        C = K.TRUSTED_TYPES_POLICY, w = C.createHTML("");
      } else
        C === void 0 && (C = N8(g, i)), C !== null && typeof w == "string" && (w = C.createHTML(""));
      zs && zs(K), Wi = K;
    }
  }, Ed = yt({}, ["mi", "mo", "mn", "ms", "mtext"]), fh = yt({}, ["foreignobject", "desc", "title", "annotation-xml"]), ph = yt({}, ["title", "style", "font", "a", "script"]), gg = yt({}, yD);
  yt(gg, LD), yt(gg, w8);
  const mh = yt({}, DD);
  yt(mh, S8);
  const mD = function(K) {
    let _e = b(K);
    (!_e || !_e.tagName) && (_e = {
      namespaceURI: Ke,
      tagName: "template"
    });
    const Ae = Dw(K.tagName), Ci = Dw(_e.tagName);
    return It[K.namespaceURI] ? K.namespaceURI === Ie ? _e.namespaceURI === Ze ? Ae === "svg" : _e.namespaceURI === ye ? Ae === "svg" && (Ci === "annotation-xml" || Ed[Ci]) : !!gg[Ae] : K.namespaceURI === ye ? _e.namespaceURI === Ze ? Ae === "math" : _e.namespaceURI === Ie ? Ae === "math" && fh[Ci] : !!mh[Ae] : K.namespaceURI === Ze ? _e.namespaceURI === Ie && !fh[Ci] || _e.namespaceURI === ye && !Ed[Ci] ? !1 : !mh[Ae] && (ph[Ae] || !gg[Ae]) : !!(vi === "application/xhtml+xml" && It[K.namespaceURI]) : !1;
  }, ha = function(K) {
    Yp(e.removed, {
      element: K
    });
    try {
      K.parentNode.removeChild(K);
    } catch {
      K.remove();
    }
  }, Gp = function(K, _e) {
    try {
      Yp(e.removed, {
        attribute: _e.getAttributeNode(K),
        from: _e
      });
    } catch {
      Yp(e.removed, {
        attribute: null,
        from: _e
      });
    }
    if (_e.removeAttribute(K), K === "is" && !Be[K])
      if (Qs || pl)
        try {
          ha(_e);
        } catch {
        }
      else
        try {
          _e.setAttribute(K, "");
        } catch {
        }
  }, Zp = function(K) {
    let _e, Ae;
    if (qo)
      K = "<remove></remove>" + K;
    else {
      const Zo = _8(K, /^[\r\n\t ]+/);
      Ae = Zo && Zo[0];
    }
    vi === "application/xhtml+xml" && Ke === Ze && (K = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + K + "</body></html>");
    const Ci = C ? C.createHTML(K) : K;
    if (Ke === Ze)
      try {
        _e = new u().parseFromString(Ci, vi);
      } catch {
      }
    if (!_e || !_e.documentElement) {
      _e = S.createDocument(Ke, "template", null);
      try {
        _e.documentElement.innerHTML = Ft ? w : Ci;
      } catch {
      }
    }
    const Fn = _e.body || _e.documentElement;
    return K && Ae && Fn.insertBefore(n.createTextNode(Ae), Fn.childNodes[0] || null), Ke === Ze ? E.call(_e, Ue ? "html" : "body")[0] : Ue ? _e.documentElement : Fn;
  }, Qb = function(K) {
    return y.call(
      K.ownerDocument || K,
      K,
      // eslint-disable-next-line no-bitwise
      d.SHOW_ELEMENT | d.SHOW_COMMENT | d.SHOW_TEXT,
      null,
      !1
    );
  }, Z$ = function(K) {
    return K instanceof h && (typeof K.nodeName != "string" || typeof K.textContent != "string" || typeof K.removeChild != "function" || !(K.attributes instanceof c) || typeof K.removeAttribute != "function" || typeof K.setAttribute != "function" || typeof K.namespaceURI != "string" || typeof K.insertBefore != "function" || typeof K.hasChildNodes != "function");
  }, Xb = function(K) {
    return typeof a == "object" ? K instanceof a : K && typeof K == "object" && typeof K.nodeType == "number" && typeof K.nodeName == "string";
  }, ml = function(K, _e, Ae) {
    F[K] && m8(F[K], (Ci) => {
      Ci.call(e, _e, Ae, Wi);
    });
  }, qR = function(K) {
    let _e;
    if (ml("beforeSanitizeElements", K, null), Z$(K))
      return ha(K), !0;
    const Ae = St(K.nodeName);
    if (ml("uponSanitizeElement", K, {
      tagName: Ae,
      allowedTags: pe
    }), K.hasChildNodes() && !Xb(K.firstElementChild) && (!Xb(K.content) || !Xb(K.content.firstElementChild)) && yo(/<[/\w]/g, K.innerHTML) && yo(/<[/\w]/g, K.textContent))
      return ha(K), !0;
    if (!pe[Ae] || Fi[Ae]) {
      if (!Fi[Ae] && ZR(Ae) && (ce.tagNameCheck instanceof RegExp && yo(ce.tagNameCheck, Ae) || ce.tagNameCheck instanceof Function && ce.tagNameCheck(Ae)))
        return !1;
      if (te && !T[Ae]) {
        const Ci = b(K) || K.parentNode, Fn = v(K) || K.childNodes;
        if (Fn && Ci) {
          const Zo = Fn.length;
          for (let ji = Zo - 1; ji >= 0; --ji)
            Ci.insertBefore(m(Fn[ji], !0), _(K));
        }
      }
      return ha(K), !0;
    }
    return K instanceof l && !mD(K) || (Ae === "noscript" || Ae === "noembed" || Ae === "noframes") && yo(/<\/no(script|embed|frames)/i, K.innerHTML) ? (ha(K), !0) : (dn && K.nodeType === 3 && (_e = K.textContent, _e = Sr(_e, V, " "), _e = Sr(_e, Z, " "), _e = Sr(_e, H, " "), K.textContent !== _e && (Yp(e.removed, {
      element: K.cloneNode()
    }), K.textContent = _e)), ml("afterSanitizeElements", K, null), !1);
  }, GR = function(K, _e, Ae) {
    if (Cr && (_e === "id" || _e === "name") && (Ae in n || Ae in uh))
      return !1;
    if (!(Ct && !Is[_e] && yo(re, _e))) {
      if (!(Qi && yo(ue, _e))) {
        if (!Be[_e] || Is[_e]) {
          if (
            // First condition does a very basic check if a) it's basically a valid custom element tagname AND
            // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
            !(ZR(K) && (ce.tagNameCheck instanceof RegExp && yo(ce.tagNameCheck, K) || ce.tagNameCheck instanceof Function && ce.tagNameCheck(K)) && (ce.attributeNameCheck instanceof RegExp && yo(ce.attributeNameCheck, _e) || ce.attributeNameCheck instanceof Function && ce.attributeNameCheck(_e)) || // Alternative, second condition checks if it's an `is`-attribute, AND
            // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            _e === "is" && ce.allowCustomizedBuiltInElements && (ce.tagNameCheck instanceof RegExp && yo(ce.tagNameCheck, Ae) || ce.tagNameCheck instanceof Function && ce.tagNameCheck(Ae)))
          ) return !1;
        } else if (!ee[_e]) {
          if (!yo(ze, Sr(Ae, Ye, ""))) {
            if (!((_e === "src" || _e === "xlink:href" || _e === "href") && K !== "script" && v8(Ae, "data:") === 0 && B[K])) {
              if (!(Ki && !yo(Ve, Sr(Ae, Ye, "")))) {
                if (Ae)
                  return !1;
              }
            }
          }
        }
      }
    }
    return !0;
  }, ZR = function(K) {
    return K.indexOf("-") > 0;
  }, YR = function(K) {
    let _e, Ae, Ci, Fn;
    ml("beforeSanitizeAttributes", K, null);
    const {
      attributes: Zo
    } = K;
    if (!Zo)
      return;
    const ji = {
      attrName: "",
      attrValue: "",
      keepAttr: !0,
      allowedAttributes: Be
    };
    for (Fn = Zo.length; Fn--; ) {
      _e = Zo[Fn];
      const {
        name: ua,
        namespaceURI: _D
      } = _e;
      if (Ae = ua === "value" ? _e.value : b8(_e.value), Ci = St(ua), ji.attrName = Ci, ji.attrValue = Ae, ji.keepAttr = !0, ji.forceKeepAttr = void 0, ml("uponSanitizeAttribute", K, ji), Ae = ji.attrValue, ji.forceKeepAttr || (Gp(ua, K), !ji.keepAttr))
        continue;
      if (!Gn && yo(/\/>/i, Ae)) {
        Gp(ua, K);
        continue;
      }
      dn && (Ae = Sr(Ae, V, " "), Ae = Sr(Ae, Z, " "), Ae = Sr(Ae, H, " "));
      const QR = St(K.nodeName);
      if (GR(QR, Ci, Ae)) {
        if (Yb && (Ci === "id" || Ci === "name") && (Gp(ua, K), Ae = pD + Ae), C && typeof g == "object" && typeof g.getAttributeType == "function" && !_D)
          switch (g.getAttributeType(QR, Ci)) {
            case "TrustedHTML": {
              Ae = C.createHTML(Ae);
              break;
            }
            case "TrustedScriptURL": {
              Ae = C.createScriptURL(Ae);
              break;
            }
          }
        try {
          _D ? K.setAttributeNS(_D, ua, Ae) : K.setAttribute(ua, Ae), bA(e.removed);
        } catch {
        }
      }
    }
    ml("afterSanitizeAttributes", K, null);
  }, Y$ = function Xe(K) {
    let _e;
    const Ae = Qb(K);
    for (ml("beforeSanitizeShadowDOM", K, null); _e = Ae.nextNode(); )
      ml("uponSanitizeShadowNode", _e, null), !qR(_e) && (_e.content instanceof s && Xe(_e.content), YR(_e));
    ml("afterSanitizeShadowDOM", K, null);
  };
  return e.sanitize = function(Xe) {
    let K = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _e, Ae, Ci, Fn;
    if (Ft = !Xe, Ft && (Xe = "<!-->"), typeof Xe != "string" && !Xb(Xe))
      if (typeof Xe.toString == "function") {
        if (Xe = Xe.toString(), typeof Xe != "string")
          throw Qp("dirty is not a string, aborting");
      } else
        throw Qp("toString is not a function");
    if (!e.isSupported)
      return Xe;
    if (jo || wr(K), e.removed = [], typeof Xe == "string" && (j = !1), j) {
      if (Xe.nodeName) {
        const ua = St(Xe.nodeName);
        if (!pe[ua] || Fi[ua])
          throw Qp("root node is forbidden and cannot be sanitized in-place");
      }
    } else if (Xe instanceof a)
      _e = Zp("<!---->"), Ae = _e.ownerDocument.importNode(Xe, !0), Ae.nodeType === 1 && Ae.nodeName === "BODY" || Ae.nodeName === "HTML" ? _e = Ae : _e.appendChild(Ae);
    else {
      if (!Qs && !dn && !Ue && // eslint-disable-next-line unicorn/prefer-includes
      Xe.indexOf("<") === -1)
        return C && Xi ? C.createHTML(Xe) : Xe;
      if (_e = Zp(Xe), !_e)
        return Qs ? null : Xi ? w : "";
    }
    _e && qo && ha(_e.firstChild);
    const Zo = Qb(j ? Xe : _e);
    for (; Ci = Zo.nextNode(); )
      qR(Ci) || (Ci.content instanceof s && Y$(Ci.content), YR(Ci));
    if (j)
      return Xe;
    if (Qs) {
      if (pl)
        for (Fn = k.call(_e.ownerDocument); _e.firstChild; )
          Fn.appendChild(_e.firstChild);
      else
        Fn = _e;
      return (Be.shadowroot || Be.shadowrootmode) && (Fn = N.call(t, Fn, !0)), Fn;
    }
    let ji = Ue ? _e.outerHTML : _e.innerHTML;
    return Ue && pe["!doctype"] && _e.ownerDocument && _e.ownerDocument.doctype && _e.ownerDocument.doctype.name && yo(NH, _e.ownerDocument.doctype.name) && (ji = "<!DOCTYPE " + _e.ownerDocument.doctype.name + `>
` + ji), dn && (ji = Sr(ji, V, " "), ji = Sr(ji, Z, " "), ji = Sr(ji, H, " ")), C && Xi ? C.createHTML(ji) : ji;
  }, e.setConfig = function(Xe) {
    wr(Xe), jo = !0;
  }, e.clearConfig = function() {
    Wi = null, jo = !1;
  }, e.isValidAttribute = function(Xe, K, _e) {
    Wi || wr({});
    const Ae = St(Xe), Ci = St(K);
    return GR(Ae, Ci, _e);
  }, e.addHook = function(Xe, K) {
    typeof K == "function" && (F[Xe] = F[Xe] || [], Yp(F[Xe], K));
  }, e.removeHook = function(Xe) {
    if (F[Xe])
      return bA(F[Xe]);
  }, e.removeHooks = function(Xe) {
    F[Xe] && (F[Xe] = []);
  }, e.removeAllHooks = function() {
    F = {};
  }, e;
}
var hl = MH();
hl.version;
hl.isSupported;
const RH = hl.sanitize;
hl.setConfig;
hl.clearConfig;
hl.isValidAttribute;
const AH = hl.addHook, PH = hl.removeHook;
hl.removeHooks;
hl.removeAllHooks;
var Ne;
(function(r) {
  r.inMemory = "inmemory", r.vscode = "vscode", r.internal = "private", r.walkThrough = "walkThrough", r.walkThroughSnippet = "walkThroughSnippet", r.http = "http", r.https = "https", r.file = "file", r.mailto = "mailto", r.untitled = "untitled", r.data = "data", r.command = "command", r.vscodeRemote = "vscode-remote", r.vscodeRemoteResource = "vscode-remote-resource", r.vscodeManagedRemoteResource = "vscode-managed-remote-resource", r.vscodeUserData = "vscode-userdata", r.vscodeCustomEditor = "vscode-custom-editor", r.vscodeNotebookCell = "vscode-notebook-cell", r.vscodeNotebookCellMetadata = "vscode-notebook-cell-metadata", r.vscodeNotebookCellOutput = "vscode-notebook-cell-output", r.vscodeInteractiveInput = "vscode-interactive-input", r.vscodeSettings = "vscode-settings", r.vscodeWorkspaceTrust = "vscode-workspace-trust", r.vscodeTerminal = "vscode-terminal", r.vscodeChatCodeBlock = "vscode-chat-code-block", r.vscodeCopilotBackingChatCodeBlock = "vscode-copilot-chat-code-block", r.vscodeChatCodeCompareBlock = "vscode-chat-code-compare-block", r.vscodeChatSesssion = "vscode-chat-editor", r.webviewPanel = "webview-panel", r.vscodeWebview = "vscode-webview", r.extension = "extension", r.vscodeFileResource = "vscode-file", r.tmp = "tmp", r.vsls = "vsls", r.vscodeSourceControl = "vscode-scm", r.commentsInput = "comment", r.codeSetting = "code-setting";
})(Ne || (Ne = {}));
function i1(r, e) {
  return Ee.isUri(r) ? Wg(r.scheme, e) : BN(r, e + ":");
}
function Ix(r, ...e) {
  return e.some((t) => i1(r, t));
}
const M8 = "tkn";
class R8 {
  constructor() {
    this._hosts = /* @__PURE__ */ Object.create(null), this._ports = /* @__PURE__ */ Object.create(null), this._connectionTokens = /* @__PURE__ */ Object.create(null), this._preferredWebSchema = "http", this._delegate = null, this._serverRootPath = "/";
  }
  setPreferredWebSchema(e) {
    this._preferredWebSchema = e;
  }
  get _remoteResourcesPath() {
    return ir.join(this._serverRootPath, Ne.vscodeRemoteResource);
  }
  rewrite(e) {
    if (this._delegate)
      try {
        return this._delegate(e);
      } catch (a) {
        return He(a), e;
      }
    const t = e.authority;
    let i = this._hosts[t];
    i && i.indexOf(":") !== -1 && i.indexOf("[") === -1 && (i = `[${i}]`);
    const n = this._ports[t], s = this._connectionTokens[t];
    let o = `path=${encodeURIComponent(e.path)}`;
    return typeof s == "string" && (o += `&${M8}=${encodeURIComponent(s)}`), Ee.from({
      scheme: Gu ? this._preferredWebSchema : Ne.vscodeRemoteResource,
      authority: `${i}:${n}`,
      path: this._remoteResourcesPath,
      query: o
    });
  }
}
const OH = new R8(), A8 = "vscode-app";
class A_ {
  /**
   * Returns a URI to use in contexts where the browser is responsible
   * for loading (e.g. fetch()) or when used within the DOM.
   *
   * **Note:** use `dom.ts#asCSSUrl` whenever the URL is to be used in CSS context.
   */
  uriToBrowserUri(e) {
    return e.scheme === Ne.vscodeRemote ? OH.rewrite(e) : (
      // ...only ever for `file` resources
      e.scheme === Ne.file && // ...and we run in native environments
      (zr || // ...or web worker extensions on desktop
      J$ === `${Ne.vscodeFileResource}://${A_.FALLBACK_AUTHORITY}`) ? e.with({
        scheme: Ne.vscodeFileResource,
        // We need to provide an authority here so that it can serve
        // as origin for network and loading matters in chromium.
        // If the URI is not coming with an authority already, we
        // add our own
        authority: e.authority || A_.FALLBACK_AUTHORITY,
        query: null,
        fragment: null
      }) : e
    );
  }
}
A_.FALLBACK_AUTHORITY = A8;
const FH = new A_();
var DA;
(function(r) {
  const e = /* @__PURE__ */ new Map([
    ["1", { "Cross-Origin-Opener-Policy": "same-origin" }],
    ["2", { "Cross-Origin-Embedder-Policy": "require-corp" }],
    ["3", { "Cross-Origin-Opener-Policy": "same-origin", "Cross-Origin-Embedder-Policy": "require-corp" }]
  ]);
  r.CoopAndCoep = Object.freeze(e.get("3"));
  const t = "vscode-coi";
  function i(s) {
    let o;
    typeof s == "string" ? o = new URL(s).searchParams : s instanceof URL ? o = s.searchParams : Ee.isUri(s) && (o = new URL(s.toString(!0)).searchParams);
    const a = o == null ? void 0 : o.get(t);
    if (a)
      return e.get(a);
  }
  r.getHeadersFromQuery = i;
  function n(s, o, a) {
    if (!globalThis.crossOriginIsolated)
      return;
    const l = o && a ? "3" : a ? "2" : "1";
    s instanceof URLSearchParams ? s.set(t, l) : s[t] = l;
  }
  r.addSearchParam = n;
})(DA || (DA = {}));
const { registerWindow: pCe, getWindow: we, getDocument: mCe, getWindows: WH, getWindowsCount: P8, getWindowId: cS, getWindowById: kA, hasWindow: _Ce, onDidRegisterWindow: o0, onWillUnregisterWindow: O8, onDidUnregisterWindow: F8 } = function() {
  const r = /* @__PURE__ */ new Map();
  Gj(Dt, 1);
  const e = { window: Dt, disposables: new q() };
  r.set(Dt.vscodeWindowId, e);
  const t = new R(), i = new R(), n = new R();
  function s(o, a) {
    const l = typeof o == "number" ? r.get(o) : void 0;
    return l ?? (a ? e : void 0);
  }
  return {
    onDidRegisterWindow: t.event,
    onWillUnregisterWindow: n.event,
    onDidUnregisterWindow: i.event,
    registerWindow(o) {
      if (r.has(o.vscodeWindowId))
        return P.None;
      const a = new q(), l = {
        window: o,
        disposables: a.add(new q())
      };
      return r.set(o.vscodeWindowId, l), a.add(Se(() => {
        r.delete(o.vscodeWindowId), i.fire(o);
      })), a.add(W(o, Q.BEFORE_UNLOAD, () => {
        n.fire(o);
      })), t.fire(l), a;
    },
    getWindows() {
      return r.values();
    },
    getWindowsCount() {
      return r.size;
    },
    getWindowId(o) {
      return o.vscodeWindowId;
    },
    hasWindow(o) {
      return r.has(o);
    },
    getWindowById: s,
    getWindow(o) {
      var a;
      const l = o;
      if (!((a = l == null ? void 0 : l.ownerDocument) === null || a === void 0) && a.defaultView)
        return l.ownerDocument.defaultView.window;
      const d = o;
      return d != null && d.view ? d.view.window : Dt;
    },
    getDocument(o) {
      return we(o).document;
    }
  };
}();
function pn(r) {
  for (; r.firstChild; )
    r.firstChild.remove();
}
class W8 {
  constructor(e, t, i, n) {
    this._node = e, this._type = t, this._handler = i, this._options = n || !1, this._node.addEventListener(this._type, this._handler, this._options);
  }
  dispose() {
    this._handler && (this._node.removeEventListener(this._type, this._handler, this._options), this._node = null, this._handler = null);
  }
}
function W(r, e, t, i) {
  return new W8(r, e, t, i);
}
function BH(r, e) {
  return function(t) {
    return e(new rr(r, t));
  };
}
function B8(r) {
  return function(e) {
    return r(new Mt(e));
  };
}
const pi = function(e, t, i, n) {
  let s = i;
  return t === "click" || t === "mousedown" || t === "contextmenu" ? s = BH(we(e), i) : (t === "keydown" || t === "keypress" || t === "keyup") && (s = B8(i)), W(e, t, s, n);
}, H8 = function(e, t, i) {
  const n = BH(we(e), t);
  return V8(e, n, i);
};
function V8(r, e, t) {
  return W(r, Zr && JN.pointerEvents ? Q.POINTER_DOWN : Q.MOUSE_DOWN, e, t);
}
function ym(r, e, t) {
  return Xm(r, e, t);
}
class xD extends IH {
  constructor(e, t) {
    super(e, t);
  }
}
let hS, Us;
class n1 extends t1 {
  /**
   *
   * @param node The optional node from which the target window is determined
   */
  constructor(e) {
    super(), this.defaultTarget = e && we(e);
  }
  cancelAndSet(e, t, i) {
    return super.cancelAndSet(e, t, i ?? this.defaultTarget);
  }
}
class ID {
  constructor(e, t = 0) {
    this._runner = e, this.priority = t, this._canceled = !1;
  }
  dispose() {
    this._canceled = !0;
  }
  execute() {
    if (!this._canceled)
      try {
        this._runner();
      } catch (e) {
        He(e);
      }
  }
  // Sort by priority (largest to lowest)
  static sort(e, t) {
    return t.priority - e.priority;
  }
}
(function() {
  const r = /* @__PURE__ */ new Map(), e = /* @__PURE__ */ new Map(), t = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), n = (s) => {
    var o;
    t.set(s, !1);
    const a = (o = r.get(s)) !== null && o !== void 0 ? o : [];
    for (e.set(s, a), r.set(s, []), i.set(s, !0); a.length > 0; )
      a.sort(ID.sort), a.shift().execute();
    i.set(s, !1);
  };
  Us = (s, o, a = 0) => {
    const l = cS(s), d = new ID(o, a);
    let c = r.get(l);
    return c || (c = [], r.set(l, c)), c.push(d), t.get(l) || (t.set(l, !0), s.requestAnimationFrame(() => n(l))), d;
  }, hS = (s, o, a) => {
    const l = cS(s);
    if (i.get(l)) {
      const d = new ID(o, a);
      let c = e.get(l);
      return c || (c = [], e.set(l, c)), c.push(d), d;
    } else
      return Us(s, o, a);
  };
})();
function r0(r) {
  return we(r).getComputedStyle(r, null);
}
function Rc(r, e) {
  const t = we(r), i = t.document;
  if (r !== i.body)
    return new pt(r.clientWidth, r.clientHeight);
  if (Zr && (t != null && t.visualViewport))
    return new pt(t.visualViewport.width, t.visualViewport.height);
  if (t != null && t.innerWidth && t.innerHeight)
    return new pt(t.innerWidth, t.innerHeight);
  if (i.body && i.body.clientWidth && i.body.clientHeight)
    return new pt(i.body.clientWidth, i.body.clientHeight);
  if (i.documentElement && i.documentElement.clientWidth && i.documentElement.clientHeight)
    return new pt(i.documentElement.clientWidth, i.documentElement.clientHeight);
  throw new Error("Unable to figure out browser width and height");
}
class Si {
  // Adapted from WinJS
  // Converts a CSS positioning string for the specified element to pixels.
  static convertToPixels(e, t) {
    return parseFloat(t) || 0;
  }
  static getDimension(e, t, i) {
    const n = r0(e), s = n ? n.getPropertyValue(t) : "0";
    return Si.convertToPixels(e, s);
  }
  static getBorderLeftWidth(e) {
    return Si.getDimension(e, "border-left-width", "borderLeftWidth");
  }
  static getBorderRightWidth(e) {
    return Si.getDimension(e, "border-right-width", "borderRightWidth");
  }
  static getBorderTopWidth(e) {
    return Si.getDimension(e, "border-top-width", "borderTopWidth");
  }
  static getBorderBottomWidth(e) {
    return Si.getDimension(e, "border-bottom-width", "borderBottomWidth");
  }
  static getPaddingLeft(e) {
    return Si.getDimension(e, "padding-left", "paddingLeft");
  }
  static getPaddingRight(e) {
    return Si.getDimension(e, "padding-right", "paddingRight");
  }
  static getPaddingTop(e) {
    return Si.getDimension(e, "padding-top", "paddingTop");
  }
  static getPaddingBottom(e) {
    return Si.getDimension(e, "padding-bottom", "paddingBottom");
  }
  static getMarginLeft(e) {
    return Si.getDimension(e, "margin-left", "marginLeft");
  }
  static getMarginTop(e) {
    return Si.getDimension(e, "margin-top", "marginTop");
  }
  static getMarginRight(e) {
    return Si.getDimension(e, "margin-right", "marginRight");
  }
  static getMarginBottom(e) {
    return Si.getDimension(e, "margin-bottom", "marginBottom");
  }
}
class pt {
  constructor(e, t) {
    this.width = e, this.height = t;
  }
  with(e = this.width, t = this.height) {
    return e !== this.width || t !== this.height ? new pt(e, t) : this;
  }
  static is(e) {
    return typeof e == "object" && typeof e.height == "number" && typeof e.width == "number";
  }
  static lift(e) {
    return e instanceof pt ? e : new pt(e.width, e.height);
  }
  static equals(e, t) {
    return e === t ? !0 : !e || !t ? !1 : e.width === t.width && e.height === t.height;
  }
}
pt.None = new pt(0, 0);
function HH(r) {
  let e = r.offsetParent, t = r.offsetTop, i = r.offsetLeft;
  for (; (r = r.parentNode) !== null && r !== r.ownerDocument.body && r !== r.ownerDocument.documentElement; ) {
    t -= r.scrollTop;
    const n = zH(r) ? null : r0(r);
    n && (i -= n.direction !== "rtl" ? r.scrollLeft : -r.scrollLeft), r === e && (i += Si.getBorderLeftWidth(r), t += Si.getBorderTopWidth(r), t += r.offsetTop, i += r.offsetLeft, e = r.offsetParent);
  }
  return {
    left: i,
    top: t
  };
}
function z8(r, e, t) {
  typeof e == "number" && (r.style.width = `${e}px`), typeof t == "number" && (r.style.height = `${t}px`);
}
function Ei(r) {
  const e = r.getBoundingClientRect(), t = we(r);
  return {
    left: e.left + t.scrollX,
    top: e.top + t.scrollY,
    width: e.width,
    height: e.height
  };
}
function VH(r) {
  let e = r, t = 1;
  do {
    const i = r0(e).zoom;
    i != null && i !== "1" && (t *= i), e = e.parentElement;
  } while (e !== null && e !== e.ownerDocument.documentElement);
  return t;
}
function Ms(r) {
  const e = Si.getMarginLeft(r) + Si.getMarginRight(r);
  return r.offsetWidth + e;
}
function ED(r) {
  const e = Si.getBorderLeftWidth(r) + Si.getBorderRightWidth(r), t = Si.getPaddingLeft(r) + Si.getPaddingRight(r);
  return r.offsetWidth - e - t;
}
function U8(r) {
  const e = Si.getBorderTopWidth(r) + Si.getBorderBottomWidth(r), t = Si.getPaddingTop(r) + Si.getPaddingBottom(r);
  return r.offsetHeight - e - t;
}
function Bl(r) {
  const e = Si.getMarginTop(r) + Si.getMarginBottom(r);
  return r.offsetHeight + e;
}
function qi(r, e) {
  return !!(e != null && e.contains(r));
}
function $8(r, e, t) {
  for (; r && r.nodeType === r.ELEMENT_NODE; ) {
    if (r.classList.contains(e))
      return r;
    if (t) {
      if (typeof t == "string") {
        if (r.classList.contains(t))
          return null;
      } else if (r === t)
        return null;
    }
    r = r.parentNode;
  }
  return null;
}
function TD(r, e, t) {
  return !!$8(r, e, t);
}
function zH(r) {
  return r && !!r.host && !!r.mode;
}
function uS(r) {
  return !!Cu(r);
}
function Cu(r) {
  for (var e; r.parentNode; ) {
    if (r === ((e = r.ownerDocument) === null || e === void 0 ? void 0 : e.body))
      return null;
    r = r.parentNode;
  }
  return zH(r) ? r : null;
}
function Ln() {
  let r = xp().activeElement;
  for (; r != null && r.shadowRoot; )
    r = r.shadowRoot.activeElement;
  return r;
}
function a0(r) {
  return Ln() === r;
}
function UH(r) {
  return qi(Ln(), r);
}
function xp() {
  var r;
  return P8() <= 1 ? Dt.document : (r = Array.from(WH()).map(({ window: t }) => t.document).find((t) => t.hasFocus())) !== null && r !== void 0 ? r : Dt.document;
}
function kw() {
  var r, e;
  return (e = (r = xp().defaultView) === null || r === void 0 ? void 0 : r.window) !== null && e !== void 0 ? e : Dt;
}
const s1 = /* @__PURE__ */ new Map();
function $H() {
  return new K8();
}
class K8 {
  constructor() {
    this._currentCssStyle = "", this._styleSheet = void 0;
  }
  setStyle(e) {
    e !== this._currentCssStyle && (this._currentCssStyle = e, this._styleSheet ? this._styleSheet.innerText = e : this._styleSheet = fo(Dt.document.head, (t) => t.innerText = e));
  }
  dispose() {
    this._styleSheet && (this._styleSheet.remove(), this._styleSheet = void 0);
  }
}
function fo(r = Dt.document.head, e, t) {
  const i = document.createElement("style");
  if (i.type = "text/css", i.media = "screen", e == null || e(i), r.appendChild(i), t && t.add(Se(() => r.removeChild(i))), r === Dt.document.head) {
    const n = /* @__PURE__ */ new Set();
    s1.set(i, n);
    for (const { window: s, disposables: o } of WH()) {
      if (s === Dt)
        continue;
      const a = o.add(j8(i, n, s));
      t == null || t.add(a);
    }
  }
  return i;
}
function j8(r, e, t) {
  var i, n;
  const s = new q(), o = r.cloneNode(!0);
  t.document.head.appendChild(o), s.add(Se(() => t.document.head.removeChild(o)));
  for (const a of jH(r))
    (i = o.sheet) === null || i === void 0 || i.insertRule(a.cssText, (n = o.sheet) === null || n === void 0 ? void 0 : n.cssRules.length);
  return s.add(q8.observe(r, s, { childList: !0 })(() => {
    o.textContent = r.textContent;
  })), e.add(o), s.add(Se(() => e.delete(o))), s;
}
const q8 = new class {
  constructor() {
    this.mutationObservers = /* @__PURE__ */ new Map();
  }
  observe(r, e, t) {
    let i = this.mutationObservers.get(r);
    i || (i = /* @__PURE__ */ new Map(), this.mutationObservers.set(r, i));
    const n = Xy(t);
    let s = i.get(n);
    if (s)
      s.users += 1;
    else {
      const o = new R(), a = new MutationObserver((d) => o.fire(d));
      a.observe(r, t);
      const l = s = {
        users: 1,
        observer: a,
        onDidMutate: o.event
      };
      e.add(Se(() => {
        l.users -= 1, l.users === 0 && (o.dispose(), a.disconnect(), i == null || i.delete(n), (i == null ? void 0 : i.size) === 0 && this.mutationObservers.delete(r));
      })), i.set(n, s);
    }
    return s.onDidMutate;
  }
}();
let ND = null;
function KH() {
  return ND || (ND = fo()), ND;
}
function jH(r) {
  var e, t;
  return !((e = r == null ? void 0 : r.sheet) === null || e === void 0) && e.rules ? r.sheet.rules : !((t = r == null ? void 0 : r.sheet) === null || t === void 0) && t.cssRules ? r.sheet.cssRules : [];
}
function gS(r, e, t = KH()) {
  var i, n;
  if (!(!t || !e)) {
    (i = t.sheet) === null || i === void 0 || i.insertRule(`${r} {${e}}`, 0);
    for (const s of (n = s1.get(t)) !== null && n !== void 0 ? n : [])
      gS(r, e, s);
  }
}
function Ex(r, e = KH()) {
  var t, i;
  if (!e)
    return;
  const n = jH(e), s = [];
  for (let o = 0; o < n.length; o++) {
    const a = n[o];
    G8(a) && a.selectorText.indexOf(r) !== -1 && s.push(o);
  }
  for (let o = s.length - 1; o >= 0; o--)
    (t = e.sheet) === null || t === void 0 || t.deleteRule(s[o]);
  for (const o of (i = s1.get(e)) !== null && i !== void 0 ? i : [])
    Ex(r, o);
}
function G8(r) {
  return typeof r.selectorText == "string";
}
function ln(r) {
  return r instanceof HTMLElement || r instanceof we(r).HTMLElement;
}
function xA(r) {
  return r instanceof HTMLAnchorElement || r instanceof we(r).HTMLAnchorElement;
}
function o1(r) {
  return r instanceof MouseEvent || r instanceof we(r).MouseEvent;
}
function $d(r) {
  return r instanceof KeyboardEvent || r instanceof we(r).KeyboardEvent;
}
const Q = {
  // Mouse
  CLICK: "click",
  AUXCLICK: "auxclick",
  DBLCLICK: "dblclick",
  MOUSE_UP: "mouseup",
  MOUSE_DOWN: "mousedown",
  MOUSE_OVER: "mouseover",
  MOUSE_MOVE: "mousemove",
  MOUSE_OUT: "mouseout",
  MOUSE_ENTER: "mouseenter",
  MOUSE_LEAVE: "mouseleave",
  MOUSE_WHEEL: "wheel",
  POINTER_UP: "pointerup",
  POINTER_DOWN: "pointerdown",
  POINTER_MOVE: "pointermove",
  POINTER_LEAVE: "pointerleave",
  CONTEXT_MENU: "contextmenu",
  WHEEL: "wheel",
  // Keyboard
  KEY_DOWN: "keydown",
  KEY_PRESS: "keypress",
  KEY_UP: "keyup",
  // HTML Document
  LOAD: "load",
  BEFORE_UNLOAD: "beforeunload",
  UNLOAD: "unload",
  PAGE_SHOW: "pageshow",
  PAGE_HIDE: "pagehide",
  PASTE: "paste",
  ABORT: "abort",
  ERROR: "error",
  RESIZE: "resize",
  SCROLL: "scroll",
  FULLSCREEN_CHANGE: "fullscreenchange",
  WK_FULLSCREEN_CHANGE: "webkitfullscreenchange",
  // Form
  SELECT: "select",
  CHANGE: "change",
  SUBMIT: "submit",
  RESET: "reset",
  FOCUS: "focus",
  FOCUS_IN: "focusin",
  FOCUS_OUT: "focusout",
  BLUR: "blur",
  INPUT: "input",
  // Local Storage
  STORAGE: "storage",
  // Drag
  DRAG_START: "dragstart",
  DRAG: "drag",
  DRAG_ENTER: "dragenter",
  DRAG_LEAVE: "dragleave",
  DRAG_OVER: "dragover",
  DROP: "drop",
  DRAG_END: "dragend",
  // Animation
  ANIMATION_START: su ? "webkitAnimationStart" : "animationstart",
  ANIMATION_END: su ? "webkitAnimationEnd" : "animationend",
  ANIMATION_ITERATION: su ? "webkitAnimationIteration" : "animationiteration"
};
function Z8(r) {
  const e = r;
  return !!(e && typeof e.preventDefault == "function" && typeof e.stopPropagation == "function");
}
const nt = {
  stop: (r, e) => (r.preventDefault(), e && r.stopPropagation(), r)
};
function Y8(r) {
  const e = [];
  for (let t = 0; r && r.nodeType === r.ELEMENT_NODE; t++)
    e[t] = r.scrollTop, r = r.parentNode;
  return e;
}
function Q8(r, e) {
  for (let t = 0; r && r.nodeType === r.ELEMENT_NODE; t++)
    r.scrollTop !== e[t] && (r.scrollTop = e[t]), r = r.parentNode;
}
class fS extends P {
  static hasFocusWithin(e) {
    if (ln(e)) {
      const t = Cu(e), i = t ? t.activeElement : e.ownerDocument.activeElement;
      return qi(i, e);
    } else {
      const t = e;
      return qi(t.document.activeElement, t.document);
    }
  }
  constructor(e) {
    super(), this._onDidFocus = this._register(new R()), this.onDidFocus = this._onDidFocus.event, this._onDidBlur = this._register(new R()), this.onDidBlur = this._onDidBlur.event;
    let t = fS.hasFocusWithin(e), i = !1;
    const n = () => {
      i = !1, t || (t = !0, this._onDidFocus.fire());
    }, s = () => {
      t && (i = !0, (ln(e) ? we(e) : e).setTimeout(() => {
        i && (i = !1, t = !1, this._onDidBlur.fire());
      }, 0));
    };
    this._refreshStateHandler = () => {
      fS.hasFocusWithin(e) !== t && (t ? s() : n());
    }, this._register(W(e, Q.FOCUS, n, !0)), this._register(W(e, Q.BLUR, s, !0)), ln(e) && (this._register(W(e, Q.FOCUS_IN, () => this._refreshStateHandler())), this._register(W(e, Q.FOCUS_OUT, () => this._refreshStateHandler())));
  }
}
function Xr(r) {
  return new fS(r);
}
function X8(r, e) {
  return r.after(e), e;
}
function G(r, ...e) {
  if (r.append(...e), e.length === 1 && typeof e[0] != "string")
    return e[0];
}
function r1(r, e) {
  return r.insertBefore(e, r.firstChild), e;
}
function mn(r, ...e) {
  r.innerText = "", G(r, ...e);
}
const J8 = /([\w\-]+)?(#([\w\-]+))?((\.([\w\-]+))*)/;
var P_;
(function(r) {
  r.HTML = "http://www.w3.org/1999/xhtml", r.SVG = "http://www.w3.org/2000/svg";
})(P_ || (P_ = {}));
function qH(r, e, t, ...i) {
  const n = J8.exec(e);
  if (!n)
    throw new Error("Bad use of emmet");
  const s = n[1] || "div";
  let o;
  return r !== P_.HTML ? o = document.createElementNS(r, s) : o = document.createElement(s), n[3] && (o.id = n[3]), n[4] && (o.className = n[4].replace(/\./g, " ").trim()), t && Object.entries(t).forEach(([a, l]) => {
    typeof l > "u" || (/^on\w+$/.test(a) ? o[a] = l : a === "selected" ? l && o.setAttribute(a, "true") : o.setAttribute(a, l));
  }), o.append(...i), o;
}
function X(r, e, ...t) {
  return qH(P_.HTML, r, e, ...t);
}
X.SVG = function(r, e, ...t) {
  return qH(P_.SVG, r, e, ...t);
};
function e6(r, ...e) {
  r ? As(...e) : Xn(...e);
}
function As(...r) {
  for (const e of r)
    e.style.display = "", e.removeAttribute("aria-hidden");
}
function Xn(...r) {
  for (const e of r)
    e.style.display = "none", e.setAttribute("aria-hidden", "true");
}
function IA(r, e) {
  const t = r.devicePixelRatio * e;
  return Math.max(1, Math.floor(t)) / r.devicePixelRatio;
}
function GH(r) {
  Dt.open(r, "_blank", "noopener");
}
function t6(r, e) {
  const t = () => {
    e(), i = Us(r, t);
  };
  let i = Us(r, t);
  return Se(() => i.dispose());
}
OH.setPreferredWebSchema(/^https:/.test(Dt.location.href) ? "https" : "http");
function hd(r) {
  return r ? `url('${FH.uriToBrowserUri(r).toString(!0).replace(/'/g, "%27")}')` : "url('')";
}
function MD(r) {
  return `'${r.replace(/'/g, "%27")}'`;
}
function ed(r, e) {
  if (r !== void 0) {
    const t = r.match(/^\s*var\((.+)\)$/);
    if (t) {
      const i = t[1].split(",", 2);
      return i.length === 2 && (e = ed(i[1].trim(), e)), `var(${i[0]}, ${e})`;
    }
    return r;
  }
  return e;
}
function i6(r, e = !1) {
  const t = document.createElement("a");
  return AH("afterSanitizeAttributes", (i) => {
    for (const n of ["href", "src"])
      if (i.hasAttribute(n)) {
        const s = i.getAttribute(n);
        if (n === "href" && s.startsWith("#"))
          continue;
        if (t.href = s, !r.includes(t.protocol.replace(/:$/, ""))) {
          if (e && n === "src" && t.href.startsWith("data:"))
            continue;
          i.removeAttribute(n);
        }
      }
  }), Se(() => {
    PH("afterSanitizeAttributes");
  });
}
const n6 = Object.freeze([
  "a",
  "abbr",
  "b",
  "bdo",
  "blockquote",
  "br",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "dd",
  "del",
  "details",
  "dfn",
  "div",
  "dl",
  "dt",
  "em",
  "figcaption",
  "figure",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "hr",
  "i",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "li",
  "mark",
  "ol",
  "p",
  "pre",
  "q",
  "rp",
  "rt",
  "ruby",
  "samp",
  "small",
  "small",
  "source",
  "span",
  "strike",
  "strong",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "time",
  "tr",
  "tt",
  "u",
  "ul",
  "var",
  "video",
  "wbr"
]);
class Hl extends R {
  constructor() {
    super(), this._subscriptions = new q(), this._keyStatus = {
      altKey: !1,
      shiftKey: !1,
      ctrlKey: !1,
      metaKey: !1
    }, this._subscriptions.add(ne.runAndSubscribe(o0, ({ window: e, disposables: t }) => this.registerListeners(e, t), { window: Dt, disposables: this._subscriptions }));
  }
  registerListeners(e, t) {
    t.add(W(e, "keydown", (i) => {
      if (i.defaultPrevented)
        return;
      const n = new Mt(i);
      if (!(n.keyCode === 6 && i.repeat)) {
        if (i.altKey && !this._keyStatus.altKey)
          this._keyStatus.lastKeyPressed = "alt";
        else if (i.ctrlKey && !this._keyStatus.ctrlKey)
          this._keyStatus.lastKeyPressed = "ctrl";
        else if (i.metaKey && !this._keyStatus.metaKey)
          this._keyStatus.lastKeyPressed = "meta";
        else if (i.shiftKey && !this._keyStatus.shiftKey)
          this._keyStatus.lastKeyPressed = "shift";
        else if (n.keyCode !== 6)
          this._keyStatus.lastKeyPressed = void 0;
        else
          return;
        this._keyStatus.altKey = i.altKey, this._keyStatus.ctrlKey = i.ctrlKey, this._keyStatus.metaKey = i.metaKey, this._keyStatus.shiftKey = i.shiftKey, this._keyStatus.lastKeyPressed && (this._keyStatus.event = i, this.fire(this._keyStatus));
      }
    }, !0)), t.add(W(e, "keyup", (i) => {
      i.defaultPrevented || (!i.altKey && this._keyStatus.altKey ? this._keyStatus.lastKeyReleased = "alt" : !i.ctrlKey && this._keyStatus.ctrlKey ? this._keyStatus.lastKeyReleased = "ctrl" : !i.metaKey && this._keyStatus.metaKey ? this._keyStatus.lastKeyReleased = "meta" : !i.shiftKey && this._keyStatus.shiftKey ? this._keyStatus.lastKeyReleased = "shift" : this._keyStatus.lastKeyReleased = void 0, this._keyStatus.lastKeyPressed !== this._keyStatus.lastKeyReleased && (this._keyStatus.lastKeyPressed = void 0), this._keyStatus.altKey = i.altKey, this._keyStatus.ctrlKey = i.ctrlKey, this._keyStatus.metaKey = i.metaKey, this._keyStatus.shiftKey = i.shiftKey, this._keyStatus.lastKeyReleased && (this._keyStatus.event = i, this.fire(this._keyStatus)));
    }, !0)), t.add(W(e.document.body, "mousedown", () => {
      this._keyStatus.lastKeyPressed = void 0;
    }, !0)), t.add(W(e.document.body, "mouseup", () => {
      this._keyStatus.lastKeyPressed = void 0;
    }, !0)), t.add(W(e.document.body, "mousemove", (i) => {
      i.buttons && (this._keyStatus.lastKeyPressed = void 0);
    }, !0)), t.add(W(e, "blur", () => {
      this.resetKeyStatus();
    }));
  }
  get keyStatus() {
    return this._keyStatus;
  }
  /**
   * Allows to explicitly reset the key status based on more knowledge (#109062)
   */
  resetKeyStatus() {
    this.doResetKeyStatus(), this.fire(this._keyStatus);
  }
  doResetKeyStatus() {
    this._keyStatus = {
      altKey: !1,
      shiftKey: !1,
      ctrlKey: !1,
      metaKey: !1
    };
  }
  static getInstance() {
    return Hl.instance || (Hl.instance = new Hl()), Hl.instance;
  }
  dispose() {
    super.dispose(), this._subscriptions.dispose();
  }
}
class s6 extends P {
  constructor(e, t) {
    super(), this.element = e, this.callbacks = t, this.counter = 0, this.dragStartTime = 0, this.registerListeners();
  }
  registerListeners() {
    this.callbacks.onDragStart && this._register(W(this.element, Q.DRAG_START, (e) => {
      var t, i;
      (i = (t = this.callbacks).onDragStart) === null || i === void 0 || i.call(t, e);
    })), this.callbacks.onDrag && this._register(W(this.element, Q.DRAG, (e) => {
      var t, i;
      (i = (t = this.callbacks).onDrag) === null || i === void 0 || i.call(t, e);
    })), this._register(W(this.element, Q.DRAG_ENTER, (e) => {
      var t, i;
      this.counter++, this.dragStartTime = e.timeStamp, (i = (t = this.callbacks).onDragEnter) === null || i === void 0 || i.call(t, e);
    })), this._register(W(this.element, Q.DRAG_OVER, (e) => {
      var t, i;
      e.preventDefault(), (i = (t = this.callbacks).onDragOver) === null || i === void 0 || i.call(t, e, e.timeStamp - this.dragStartTime);
    })), this._register(W(this.element, Q.DRAG_LEAVE, (e) => {
      var t, i;
      this.counter--, this.counter === 0 && (this.dragStartTime = 0, (i = (t = this.callbacks).onDragLeave) === null || i === void 0 || i.call(t, e));
    })), this._register(W(this.element, Q.DRAG_END, (e) => {
      var t, i;
      this.counter = 0, this.dragStartTime = 0, (i = (t = this.callbacks).onDragEnd) === null || i === void 0 || i.call(t, e);
    })), this._register(W(this.element, Q.DROP, (e) => {
      var t, i;
      this.counter = 0, this.dragStartTime = 0, (i = (t = this.callbacks).onDrop) === null || i === void 0 || i.call(t, e);
    }));
  }
}
const o6 = /(?<tag>[\w\-]+)?(?:#(?<id>[\w\-]+))?(?<class>(?:\.(?:[\w\-]+))*)(?:@(?<name>(?:[\w\_])+))?/;
function ft(r, ...e) {
  let t, i;
  Array.isArray(e[0]) ? (t = {}, i = e[0]) : (t = e[0] || {}, i = e[1]);
  const n = o6.exec(r);
  if (!n || !n.groups)
    throw new Error("Bad use of h");
  const s = n.groups.tag || "div", o = document.createElement(s);
  n.groups.id && (o.id = n.groups.id);
  const a = [];
  if (n.groups.class)
    for (const d of n.groups.class.split("."))
      d !== "" && a.push(d);
  if (t.className !== void 0)
    for (const d of t.className.split("."))
      d !== "" && a.push(d);
  a.length > 0 && (o.className = a.join(" "));
  const l = {};
  if (n.groups.name && (l[n.groups.name] = o), i)
    for (const d of i)
      ln(d) ? o.appendChild(d) : typeof d == "string" ? o.append(d) : "root" in d && (Object.assign(l, d), o.appendChild(d.root));
  for (const [d, c] of Object.entries(t))
    if (d !== "className")
      if (d === "style")
        for (const [h, u] of Object.entries(c))
          o.style.setProperty(EA(h), typeof u == "number" ? u + "px" : "" + u);
      else d === "tabIndex" ? o.tabIndex = c : o.setAttribute(EA(d), c.toString());
  return l.root = o, l;
}
function EA(r) {
  return r.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
}
class r6 extends P {
  constructor(e) {
    super(), this._onDidChange = this._register(new R()), this.onDidChange = this._onDidChange.event, this._listener = () => this._handleChange(e, !0), this._mediaQueryList = null, this._handleChange(e, !1);
  }
  _handleChange(e, t) {
    var i;
    (i = this._mediaQueryList) === null || i === void 0 || i.removeEventListener("change", this._listener), this._mediaQueryList = e.matchMedia(`(resolution: ${e.devicePixelRatio}dppx)`), this._mediaQueryList.addEventListener("change", this._listener), t && this._onDidChange.fire();
  }
}
class a6 extends P {
  get value() {
    return this._value;
  }
  constructor(e) {
    super(), this._onDidChange = this._register(new R()), this.onDidChange = this._onDidChange.event, this._value = this._getPixelRatio(e);
    const t = this._register(new r6(e));
    this._register(t.onDidChange(() => {
      this._value = this._getPixelRatio(e), this._onDidChange.fire(this._value);
    }));
  }
  _getPixelRatio(e) {
    const t = document.createElement("canvas").getContext("2d"), i = e.devicePixelRatio || 1, n = t.webkitBackingStorePixelRatio || t.mozBackingStorePixelRatio || t.msBackingStorePixelRatio || t.oBackingStorePixelRatio || t.backingStorePixelRatio || 1;
    return i / n;
  }
}
class l6 {
  constructor() {
    this.mapWindowIdToPixelRatioMonitor = /* @__PURE__ */ new Map();
  }
  _getOrCreatePixelRatioMonitor(e) {
    const t = cS(e);
    let i = this.mapWindowIdToPixelRatioMonitor.get(t);
    return i || (i = T_(new a6(e)), this.mapWindowIdToPixelRatioMonitor.set(t, i), T_(ne.once(F8)(({ vscodeWindowId: n }) => {
      n === t && (i == null || i.dispose(), this.mapWindowIdToPixelRatioMonitor.delete(t));
    }))), i;
  }
  getInstance(e) {
    return this._getOrCreatePixelRatioMonitor(e);
  }
}
const O_ = new l6();
class ZH {
  constructor(e) {
    this.domNode = e, this._maxWidth = "", this._width = "", this._height = "", this._top = "", this._left = "", this._bottom = "", this._right = "", this._paddingLeft = "", this._fontFamily = "", this._fontWeight = "", this._fontSize = "", this._fontStyle = "", this._fontFeatureSettings = "", this._fontVariationSettings = "", this._textDecoration = "", this._lineHeight = "", this._letterSpacing = "", this._className = "", this._display = "", this._position = "", this._visibility = "", this._color = "", this._backgroundColor = "", this._layerHint = !1, this._contain = "none", this._boxShadow = "";
  }
  setMaxWidth(e) {
    const t = yr(e);
    this._maxWidth !== t && (this._maxWidth = t, this.domNode.style.maxWidth = this._maxWidth);
  }
  setWidth(e) {
    const t = yr(e);
    this._width !== t && (this._width = t, this.domNode.style.width = this._width);
  }
  setHeight(e) {
    const t = yr(e);
    this._height !== t && (this._height = t, this.domNode.style.height = this._height);
  }
  setTop(e) {
    const t = yr(e);
    this._top !== t && (this._top = t, this.domNode.style.top = this._top);
  }
  setLeft(e) {
    const t = yr(e);
    this._left !== t && (this._left = t, this.domNode.style.left = this._left);
  }
  setBottom(e) {
    const t = yr(e);
    this._bottom !== t && (this._bottom = t, this.domNode.style.bottom = this._bottom);
  }
  setRight(e) {
    const t = yr(e);
    this._right !== t && (this._right = t, this.domNode.style.right = this._right);
  }
  setPaddingLeft(e) {
    const t = yr(e);
    this._paddingLeft !== t && (this._paddingLeft = t, this.domNode.style.paddingLeft = this._paddingLeft);
  }
  setFontFamily(e) {
    this._fontFamily !== e && (this._fontFamily = e, this.domNode.style.fontFamily = this._fontFamily);
  }
  setFontWeight(e) {
    this._fontWeight !== e && (this._fontWeight = e, this.domNode.style.fontWeight = this._fontWeight);
  }
  setFontSize(e) {
    const t = yr(e);
    this._fontSize !== t && (this._fontSize = t, this.domNode.style.fontSize = this._fontSize);
  }
  setFontStyle(e) {
    this._fontStyle !== e && (this._fontStyle = e, this.domNode.style.fontStyle = this._fontStyle);
  }
  setFontFeatureSettings(e) {
    this._fontFeatureSettings !== e && (this._fontFeatureSettings = e, this.domNode.style.fontFeatureSettings = this._fontFeatureSettings);
  }
  setFontVariationSettings(e) {
    this._fontVariationSettings !== e && (this._fontVariationSettings = e, this.domNode.style.fontVariationSettings = this._fontVariationSettings);
  }
  setTextDecoration(e) {
    this._textDecoration !== e && (this._textDecoration = e, this.domNode.style.textDecoration = this._textDecoration);
  }
  setLineHeight(e) {
    const t = yr(e);
    this._lineHeight !== t && (this._lineHeight = t, this.domNode.style.lineHeight = this._lineHeight);
  }
  setLetterSpacing(e) {
    const t = yr(e);
    this._letterSpacing !== t && (this._letterSpacing = t, this.domNode.style.letterSpacing = this._letterSpacing);
  }
  setClassName(e) {
    this._className !== e && (this._className = e, this.domNode.className = this._className);
  }
  toggleClassName(e, t) {
    this.domNode.classList.toggle(e, t), this._className = this.domNode.className;
  }
  setDisplay(e) {
    this._display !== e && (this._display = e, this.domNode.style.display = this._display);
  }
  setPosition(e) {
    this._position !== e && (this._position = e, this.domNode.style.position = this._position);
  }
  setVisibility(e) {
    this._visibility !== e && (this._visibility = e, this.domNode.style.visibility = this._visibility);
  }
  setColor(e) {
    this._color !== e && (this._color = e, this.domNode.style.color = this._color);
  }
  setBackgroundColor(e) {
    this._backgroundColor !== e && (this._backgroundColor = e, this.domNode.style.backgroundColor = this._backgroundColor);
  }
  setLayerHinting(e) {
    this._layerHint !== e && (this._layerHint = e, this.domNode.style.transform = this._layerHint ? "translate3d(0px, 0px, 0px)" : "");
  }
  setBoxShadow(e) {
    this._boxShadow !== e && (this._boxShadow = e, this.domNode.style.boxShadow = e);
  }
  setContain(e) {
    this._contain !== e && (this._contain = e, this.domNode.style.contain = this._contain);
  }
  setAttribute(e, t) {
    this.domNode.setAttribute(e, t);
  }
  removeAttribute(e) {
    this.domNode.removeAttribute(e);
  }
  appendChild(e) {
    this.domNode.appendChild(e.domNode);
  }
  removeChild(e) {
    this.domNode.removeChild(e.domNode);
  }
}
function yr(r) {
  return typeof r == "number" ? `${r}px` : r;
}
function bt(r) {
  return new ZH(r);
}
function _n(r, e) {
  r instanceof ZH ? (r.setFontFamily(e.getMassagedFontFamily()), r.setFontWeight(e.fontWeight), r.setFontSize(e.fontSize), r.setFontFeatureSettings(e.fontFeatureSettings), r.setFontVariationSettings(e.fontVariationSettings), r.setLineHeight(e.lineHeight), r.setLetterSpacing(e.letterSpacing)) : (r.style.fontFamily = e.getMassagedFontFamily(), r.style.fontWeight = e.fontWeight, r.style.fontSize = e.fontSize + "px", r.style.fontFeatureSettings = e.fontFeatureSettings, r.style.fontVariationSettings = e.fontVariationSettings, r.style.lineHeight = e.lineHeight + "px", r.style.letterSpacing = e.letterSpacing + "px");
}
class d6 {
  constructor(e, t) {
    this.chr = e, this.type = t, this.width = 0;
  }
  fulfill(e) {
    this.width = e;
  }
}
class a1 {
  constructor(e, t) {
    this._bareFontInfo = e, this._requests = t, this._container = null, this._testElements = null;
  }
  read(e) {
    this._createDomElements(), e.document.body.appendChild(this._container), this._readFromDomElements(), e.document.body.removeChild(this._container), this._container = null, this._testElements = null;
  }
  _createDomElements() {
    const e = document.createElement("div");
    e.style.position = "absolute", e.style.top = "-50000px", e.style.width = "50000px";
    const t = document.createElement("div");
    _n(t, this._bareFontInfo), e.appendChild(t);
    const i = document.createElement("div");
    _n(i, this._bareFontInfo), i.style.fontWeight = "bold", e.appendChild(i);
    const n = document.createElement("div");
    _n(n, this._bareFontInfo), n.style.fontStyle = "italic", e.appendChild(n);
    const s = [];
    for (const o of this._requests) {
      let a;
      o.type === 0 && (a = t), o.type === 2 && (a = i), o.type === 1 && (a = n), a.appendChild(document.createElement("br"));
      const l = document.createElement("span");
      a1._render(l, o), a.appendChild(l), s.push(l);
    }
    this._container = e, this._testElements = s;
  }
  static _render(e, t) {
    if (t.chr === " ") {
      let i = "";
      for (let n = 0; n < 8; n++)
        i += i;
      e.innerText = i;
    } else {
      let i = t.chr;
      for (let n = 0; n < 8; n++)
        i += i;
      e.textContent = i;
    }
  }
  _readFromDomElements() {
    for (let e = 0, t = this._requests.length; e < t; e++) {
      const i = this._requests[e], n = this._testElements[e];
      i.fulfill(n.offsetWidth / 256);
    }
  }
}
function c6(r, e, t) {
  new a1(e, t).read(r);
}
const xo = new class {
  constructor() {
    this._zoomLevel = 0, this._onDidChangeZoomLevel = new R(), this.onDidChangeZoomLevel = this._onDidChangeZoomLevel.event;
  }
  getZoomLevel() {
    return this._zoomLevel;
  }
  setZoomLevel(r) {
    r = Math.min(Math.max(-5, r), 20), this._zoomLevel !== r && (this._zoomLevel = r, this._onDidChangeZoomLevel.fire(this._zoomLevel));
  }
}(), h6 = Je ? 1.5 : 1.35, RD = 8;
class ou {
  /**
   * @internal
   */
  static createFromValidatedSettings(e, t, i) {
    const n = e.get(
      49
      /* EditorOption.fontFamily */
    ), s = e.get(
      53
      /* EditorOption.fontWeight */
    ), o = e.get(
      52
      /* EditorOption.fontSize */
    ), a = e.get(
      51
      /* EditorOption.fontLigatures */
    ), l = e.get(
      54
      /* EditorOption.fontVariations */
    ), d = e.get(
      67
      /* EditorOption.lineHeight */
    ), c = e.get(
      64
      /* EditorOption.letterSpacing */
    );
    return ou._create(n, s, o, a, l, d, c, t, i);
  }
  /**
   * @internal
   */
  static _create(e, t, i, n, s, o, a, l, d) {
    o === 0 ? o = h6 * i : o < RD && (o = o * i), o = Math.round(o), o < RD && (o = RD);
    const c = 1 + (d ? 0 : xo.getZoomLevel() * 0.1);
    return i *= c, o *= c, s === Or.TRANSLATE && (t === "normal" || t === "bold" ? s = Or.OFF : (s = `'wght' ${parseInt(t, 10)}`, t = "normal")), new ou({
      pixelRatio: l,
      fontFamily: e,
      fontWeight: t,
      fontSize: i,
      fontFeatureSettings: n,
      fontVariationSettings: s,
      lineHeight: o,
      letterSpacing: a
    });
  }
  /**
   * @internal
   */
  constructor(e) {
    this._bareFontInfoBrand = void 0, this.pixelRatio = e.pixelRatio, this.fontFamily = String(e.fontFamily), this.fontWeight = String(e.fontWeight), this.fontSize = e.fontSize, this.fontFeatureSettings = e.fontFeatureSettings, this.fontVariationSettings = e.fontVariationSettings, this.lineHeight = e.lineHeight | 0, this.letterSpacing = e.letterSpacing;
  }
  /**
   * @internal
   */
  getId() {
    return `${this.pixelRatio}-${this.fontFamily}-${this.fontWeight}-${this.fontSize}-${this.fontFeatureSettings}-${this.fontVariationSettings}-${this.lineHeight}-${this.letterSpacing}`;
  }
  /**
   * @internal
   */
  getMassagedFontFamily() {
    const e = Ss.fontFamily, t = ou._wrapInQuotes(this.fontFamily);
    return e && this.fontFamily !== e ? `${t}, ${e}` : t;
  }
  static _wrapInQuotes(e) {
    return /[,"']/.test(e) ? e : /[+ ]/.test(e) ? `"${e}"` : e;
  }
}
const u6 = 2;
class Tx extends ou {
  /**
   * @internal
   */
  constructor(e, t) {
    super(e), this._editorStylingBrand = void 0, this.version = u6, this.isTrusted = t, this.isMonospace = e.isMonospace, this.typicalHalfwidthCharacterWidth = e.typicalHalfwidthCharacterWidth, this.typicalFullwidthCharacterWidth = e.typicalFullwidthCharacterWidth, this.canUseHalfwidthRightwardsArrow = e.canUseHalfwidthRightwardsArrow, this.spaceWidth = e.spaceWidth, this.middotWidth = e.middotWidth, this.wsmiddotWidth = e.wsmiddotWidth, this.maxDigitWidth = e.maxDigitWidth;
  }
  /**
   * @internal
   */
  equals(e) {
    return this.fontFamily === e.fontFamily && this.fontWeight === e.fontWeight && this.fontSize === e.fontSize && this.fontFeatureSettings === e.fontFeatureSettings && this.fontVariationSettings === e.fontVariationSettings && this.lineHeight === e.lineHeight && this.letterSpacing === e.letterSpacing && this.typicalHalfwidthCharacterWidth === e.typicalHalfwidthCharacterWidth && this.typicalFullwidthCharacterWidth === e.typicalFullwidthCharacterWidth && this.canUseHalfwidthRightwardsArrow === e.canUseHalfwidthRightwardsArrow && this.spaceWidth === e.spaceWidth && this.middotWidth === e.middotWidth && this.wsmiddotWidth === e.wsmiddotWidth && this.maxDigitWidth === e.maxDigitWidth;
  }
}
class g6 extends P {
  constructor() {
    super(...arguments), this._cache = /* @__PURE__ */ new Map(), this._evictUntrustedReadingsTimeout = -1, this._onDidChange = this._register(new R()), this.onDidChange = this._onDidChange.event;
  }
  dispose() {
    this._evictUntrustedReadingsTimeout !== -1 && (clearTimeout(this._evictUntrustedReadingsTimeout), this._evictUntrustedReadingsTimeout = -1), super.dispose();
  }
  /**
   * Clear all cached font information and trigger a change event.
   */
  clearAllFontInfos() {
    this._cache.clear(), this._onDidChange.fire();
  }
  _ensureCache(e) {
    const t = cS(e);
    let i = this._cache.get(t);
    return i || (i = new f6(), this._cache.set(t, i)), i;
  }
  _writeToCache(e, t, i) {
    this._ensureCache(e).put(t, i), !i.isTrusted && this._evictUntrustedReadingsTimeout === -1 && (this._evictUntrustedReadingsTimeout = e.setTimeout(() => {
      this._evictUntrustedReadingsTimeout = -1, this._evictUntrustedReadings(e);
    }, 5e3));
  }
  _evictUntrustedReadings(e) {
    const t = this._ensureCache(e), i = t.getValues();
    let n = !1;
    for (const s of i)
      s.isTrusted || (n = !0, t.remove(s));
    n && this._onDidChange.fire();
  }
  /**
   * Read font information.
   */
  readFontInfo(e, t) {
    const i = this._ensureCache(e);
    if (!i.has(t)) {
      let n = this._actualReadFontInfo(e, t);
      (n.typicalHalfwidthCharacterWidth <= 2 || n.typicalFullwidthCharacterWidth <= 2 || n.spaceWidth <= 2 || n.maxDigitWidth <= 2) && (n = new Tx({
        pixelRatio: O_.getInstance(e).value,
        fontFamily: n.fontFamily,
        fontWeight: n.fontWeight,
        fontSize: n.fontSize,
        fontFeatureSettings: n.fontFeatureSettings,
        fontVariationSettings: n.fontVariationSettings,
        lineHeight: n.lineHeight,
        letterSpacing: n.letterSpacing,
        isMonospace: n.isMonospace,
        typicalHalfwidthCharacterWidth: Math.max(n.typicalHalfwidthCharacterWidth, 5),
        typicalFullwidthCharacterWidth: Math.max(n.typicalFullwidthCharacterWidth, 5),
        canUseHalfwidthRightwardsArrow: n.canUseHalfwidthRightwardsArrow,
        spaceWidth: Math.max(n.spaceWidth, 5),
        middotWidth: Math.max(n.middotWidth, 5),
        wsmiddotWidth: Math.max(n.wsmiddotWidth, 5),
        maxDigitWidth: Math.max(n.maxDigitWidth, 5)
      }, !1)), this._writeToCache(e, t, n);
    }
    return i.get(t);
  }
  _createRequest(e, t, i, n) {
    const s = new d6(e, t);
    return i.push(s), n == null || n.push(s), s;
  }
  _actualReadFontInfo(e, t) {
    const i = [], n = [], s = this._createRequest("n", 0, i, n), o = this._createRequest("", 0, i, null), a = this._createRequest(" ", 0, i, n), l = this._createRequest("0", 0, i, n), d = this._createRequest("1", 0, i, n), c = this._createRequest("2", 0, i, n), h = this._createRequest("3", 0, i, n), u = this._createRequest("4", 0, i, n), g = this._createRequest("5", 0, i, n), f = this._createRequest("6", 0, i, n), m = this._createRequest("7", 0, i, n), _ = this._createRequest("8", 0, i, n), v = this._createRequest("9", 0, i, n), b = this._createRequest("", 0, i, n), C = this._createRequest("", 0, i, null), w = this._createRequest("", 0, i, n), S = this._createRequest("", 0, i, null), y = "|/-_ilm%";
    for (let V = 0, Z = y.length; V < Z; V++)
      this._createRequest(y.charAt(V), 0, i, n), this._createRequest(y.charAt(V), 1, i, n), this._createRequest(y.charAt(V), 2, i, n);
    c6(e, t, i);
    const k = Math.max(l.width, d.width, c.width, h.width, u.width, g.width, f.width, m.width, _.width, v.width);
    let E = t.fontFeatureSettings === ro.OFF;
    const N = n[0].width;
    for (let V = 1, Z = n.length; E && V < Z; V++) {
      const H = N - n[V].width;
      if (H < -1e-3 || H > 1e-3) {
        E = !1;
        break;
      }
    }
    let F = !0;
    return E && C.width !== N && (F = !1), C.width > b.width && (F = !1), new Tx({
      pixelRatio: O_.getInstance(e).value,
      fontFamily: t.fontFamily,
      fontWeight: t.fontWeight,
      fontSize: t.fontSize,
      fontFeatureSettings: t.fontFeatureSettings,
      fontVariationSettings: t.fontVariationSettings,
      lineHeight: t.lineHeight,
      letterSpacing: t.letterSpacing,
      isMonospace: E,
      typicalHalfwidthCharacterWidth: s.width,
      typicalFullwidthCharacterWidth: o.width,
      canUseHalfwidthRightwardsArrow: F,
      spaceWidth: a.width,
      middotWidth: w.width,
      wsmiddotWidth: S.width,
      maxDigitWidth: k
    }, !0);
  }
}
class f6 {
  constructor() {
    this._keys = /* @__PURE__ */ Object.create(null), this._values = /* @__PURE__ */ Object.create(null);
  }
  has(e) {
    const t = e.getId();
    return !!this._values[t];
  }
  get(e) {
    const t = e.getId();
    return this._values[t];
  }
  put(e, t) {
    const i = e.getId();
    this._keys[i] = e, this._values[i] = t;
  }
  remove(e) {
    const t = e.getId();
    delete this._keys[t], delete this._values[t];
  }
  getValues() {
    return Object.keys(this._keys).map((e) => this._values[e]);
  }
}
const Nx = new g6();
var Br;
(function(r) {
  r.serviceIds = /* @__PURE__ */ new Map(), r.DI_TARGET = "$di$target", r.DI_DEPENDENCIES = "$di$dependencies";
  function e(t) {
    return t[r.DI_DEPENDENCIES] || [];
  }
  r.getServiceDependencies = e;
})(Br || (Br = {}));
const be = et("instantiationService");
function p6(r, e, t) {
  e[Br.DI_TARGET] === e ? e[Br.DI_DEPENDENCIES].push({ id: r, index: t }) : (e[Br.DI_DEPENDENCIES] = [{ id: r, index: t }], e[Br.DI_TARGET] = e);
}
function et(r) {
  if (Br.serviceIds.has(r))
    return Br.serviceIds.get(r);
  const e = function(t, i, n) {
    if (arguments.length !== 3)
      throw new Error("@IServiceName-decorator can only be used to decorate a parameter");
    p6(e, t, n);
  };
  return e.toString = () => r, Br.serviceIds.set(r, e), e;
}
const ht = et("codeEditorService"), ii = et("modelService"), xs = et("textModelService");
class Bs extends P {
  constructor(e, t = "", i = "", n = !0, s) {
    super(), this._onDidChange = this._register(new R()), this.onDidChange = this._onDidChange.event, this._enabled = !0, this._id = e, this._label = t, this._cssClass = i, this._enabled = n, this._actionCallback = s;
  }
  get id() {
    return this._id;
  }
  get label() {
    return this._label;
  }
  set label(e) {
    this._setLabel(e);
  }
  _setLabel(e) {
    this._label !== e && (this._label = e, this._onDidChange.fire({ label: e }));
  }
  get tooltip() {
    return this._tooltip || "";
  }
  set tooltip(e) {
    this._setTooltip(e);
  }
  _setTooltip(e) {
    this._tooltip !== e && (this._tooltip = e, this._onDidChange.fire({ tooltip: e }));
  }
  get class() {
    return this._cssClass;
  }
  set class(e) {
    this._setClass(e);
  }
  _setClass(e) {
    this._cssClass !== e && (this._cssClass = e, this._onDidChange.fire({ class: e }));
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(e) {
    this._setEnabled(e);
  }
  _setEnabled(e) {
    this._enabled !== e && (this._enabled = e, this._onDidChange.fire({ enabled: e }));
  }
  get checked() {
    return this._checked;
  }
  set checked(e) {
    this._setChecked(e);
  }
  _setChecked(e) {
    this._checked !== e && (this._checked = e, this._onDidChange.fire({ checked: e }));
  }
  async run(e, t) {
    this._actionCallback && await this._actionCallback(e);
  }
}
class wu extends P {
  constructor() {
    super(...arguments), this._onWillRun = this._register(new R()), this.onWillRun = this._onWillRun.event, this._onDidRun = this._register(new R()), this.onDidRun = this._onDidRun.event;
  }
  async run(e, t) {
    if (!e.enabled)
      return;
    this._onWillRun.fire({ action: e });
    let i;
    try {
      await this.runAction(e, t);
    } catch (n) {
      i = n;
    }
    this._onDidRun.fire({ action: e, error: i });
  }
  async runAction(e, t) {
    await e.run(t);
  }
}
class Oi {
  constructor() {
    this.id = Oi.ID, this.label = "", this.tooltip = "", this.class = "separator", this.enabled = !1, this.checked = !1;
  }
  /**
   * Joins all non-empty lists of actions with separators.
   */
  static join(...e) {
    let t = [];
    for (const i of e)
      i.length && (t.length ? t = [...t, new Oi(), ...i] : t = i);
    return t;
  }
  async run() {
  }
}
Oi.ID = "vs.actions.separator";
class Bf {
  get actions() {
    return this._actions;
  }
  constructor(e, t, i, n) {
    this.tooltip = "", this.enabled = !0, this.checked = void 0, this.id = e, this.label = t, this.class = n, this._actions = i;
  }
  async run() {
  }
}
class l0 extends Bs {
  constructor() {
    super(l0.ID, p("submenu.empty", "(empty)"), void 0, !1);
  }
}
l0.ID = "vs.actions.empty";
function ru(r) {
  var e, t;
  return {
    id: r.id,
    label: r.label,
    tooltip: (e = r.tooltip) !== null && e !== void 0 ? e : r.label,
    class: r.class,
    enabled: (t = r.enabled) !== null && t !== void 0 ? t : !0,
    checked: r.checked,
    run: async (...i) => r.run(...i)
  };
}
var Mx;
(function(r) {
  function e(t) {
    return t && typeof t == "object" && typeof t.id == "string";
  }
  r.isThemeColor = e;
})(Mx || (Mx = {}));
var Le;
(function(r) {
  r.iconNameSegment = "[A-Za-z0-9]+", r.iconNameExpression = "[A-Za-z0-9-]+", r.iconModifierExpression = "~[A-Za-z]+", r.iconNameCharacter = "[A-Za-z0-9~-]";
  const e = new RegExp(`^(${r.iconNameExpression})(${r.iconModifierExpression})?$`);
  function t(u) {
    const g = e.exec(u.id);
    if (!g)
      return t(me.error);
    const [, f, m] = g, _ = ["codicon", "codicon-" + f];
    return m && _.push("codicon-modifier-" + m.substring(1)), _;
  }
  r.asClassNameArray = t;
  function i(u) {
    return t(u).join(" ");
  }
  r.asClassName = i;
  function n(u) {
    return "." + t(u).join(".");
  }
  r.asCSSSelector = n;
  function s(u) {
    return u && typeof u == "object" && typeof u.id == "string" && (typeof u.color > "u" || Mx.isThemeColor(u.color));
  }
  r.isThemeIcon = s;
  const o = new RegExp(`^\\$\\((${r.iconNameExpression}(?:${r.iconModifierExpression})?)\\)$`);
  function a(u) {
    const g = o.exec(u);
    if (!g)
      return;
    const [, f] = g;
    return { id: f };
  }
  r.fromString = a;
  function l(u) {
    return { id: u };
  }
  r.fromId = l;
  function d(u, g) {
    let f = u.id;
    const m = f.lastIndexOf("~");
    return m !== -1 && (f = f.substring(0, m)), g && (f = `${f}~${g}`), { id: f };
  }
  r.modify = d;
  function c(u) {
    const g = u.id.lastIndexOf("~");
    if (g !== -1)
      return u.id.substring(g + 1);
  }
  r.getModifier = c;
  function h(u, g) {
    var f, m;
    return u.id === g.id && ((f = u.color) === null || f === void 0 ? void 0 : f.id) === ((m = g.color) === null || m === void 0 ? void 0 : m.id);
  }
  r.isEqual = h;
})(Le || (Le = {}));
const $t = et("commandService"), st = new class {
  constructor() {
    this._commands = /* @__PURE__ */ new Map(), this._onDidRegisterCommand = new R(), this.onDidRegisterCommand = this._onDidRegisterCommand.event;
  }
  registerCommand(r, e) {
    if (!r)
      throw new Error("invalid command");
    if (typeof r == "string") {
      if (!e)
        throw new Error("invalid command");
      return this.registerCommand({ id: r, handler: e });
    }
    if (r.metadata && Array.isArray(r.metadata.args)) {
      const o = [];
      for (const l of r.metadata.args)
        o.push(l.constraint);
      const a = r.handler;
      r.handler = function(l, ...d) {
        return e5(d, o), a(l, ...d);
      };
    }
    const { id: t } = r;
    let i = this._commands.get(t);
    i || (i = new Ps(), this._commands.set(t, i));
    const n = i.unshift(r), s = Se(() => {
      n();
      const o = this._commands.get(t);
      o != null && o.isEmpty() && this._commands.delete(t);
    });
    return this._onDidRegisterCommand.fire(t), s;
  }
  registerCommandAlias(r, e) {
    return st.registerCommand(r, (t, ...i) => t.get($t).executeCommand(e, ...i));
  }
  getCommand(r) {
    const e = this._commands.get(r);
    if (!(!e || e.isEmpty()))
      return ut.first(e);
  }
  getCommands() {
    const r = /* @__PURE__ */ new Map();
    for (const e of this._commands.keys()) {
      const t = this.getCommand(e);
      t && r.set(e, t);
    }
    return r;
  }
}();
st.registerCommand("noop", () => {
});
function AD(...r) {
  switch (r.length) {
    case 1:
      return p("contextkey.scanner.hint.didYouMean1", "Did you mean {0}?", r[0]);
    case 2:
      return p("contextkey.scanner.hint.didYouMean2", "Did you mean {0} or {1}?", r[0], r[1]);
    case 3:
      return p("contextkey.scanner.hint.didYouMean3", "Did you mean {0}, {1} or {2}?", r[0], r[1], r[2]);
    default:
      return;
  }
}
const m6 = p("contextkey.scanner.hint.didYouForgetToOpenOrCloseQuote", "Did you forget to open or close the quote?"), _6 = p("contextkey.scanner.hint.didYouForgetToEscapeSlash", "Did you forget to escape the '/' (slash) character? Put two backslashes before it to escape, e.g., '\\\\/'.");
let Oh = class Rx {
  constructor() {
    this._input = "", this._start = 0, this._current = 0, this._tokens = [], this._errors = [], this.stringRe = /[a-zA-Z0-9_<>\-\./\\:\*\?\+\[\]\^,#@;"%\$\p{L}-]+/uy;
  }
  static getLexeme(e) {
    switch (e.type) {
      case 0:
        return "(";
      case 1:
        return ")";
      case 2:
        return "!";
      case 3:
        return e.isTripleEq ? "===" : "==";
      case 4:
        return e.isTripleEq ? "!==" : "!=";
      case 5:
        return "<";
      case 6:
        return "<=";
      case 7:
        return ">=";
      case 8:
        return ">=";
      case 9:
        return "=~";
      case 10:
        return e.lexeme;
      case 11:
        return "true";
      case 12:
        return "false";
      case 13:
        return "in";
      case 14:
        return "not";
      case 15:
        return "&&";
      case 16:
        return "||";
      case 17:
        return e.lexeme;
      case 18:
        return e.lexeme;
      case 19:
        return e.lexeme;
      case 20:
        return "EOF";
      default:
        throw HN(`unhandled token type: ${JSON.stringify(e)}; have you forgotten to add a case?`);
    }
  }
  reset(e) {
    return this._input = e, this._start = 0, this._current = 0, this._tokens = [], this._errors = [], this;
  }
  scan() {
    for (; !this._isAtEnd(); )
      switch (this._start = this._current, this._advance()) {
        case 40:
          this._addToken(
            0
            /* TokenType.LParen */
          );
          break;
        case 41:
          this._addToken(
            1
            /* TokenType.RParen */
          );
          break;
        case 33:
          if (this._match(
            61
            /* CharCode.Equals */
          )) {
            const t = this._match(
              61
              /* CharCode.Equals */
            );
            this._tokens.push({ type: 4, offset: this._start, isTripleEq: t });
          } else
            this._addToken(
              2
              /* TokenType.Neg */
            );
          break;
        case 39:
          this._quotedString();
          break;
        case 47:
          this._regex();
          break;
        case 61:
          if (this._match(
            61
            /* CharCode.Equals */
          )) {
            const t = this._match(
              61
              /* CharCode.Equals */
            );
            this._tokens.push({ type: 3, offset: this._start, isTripleEq: t });
          } else this._match(
            126
            /* CharCode.Tilde */
          ) ? this._addToken(
            9
            /* TokenType.RegexOp */
          ) : this._error(AD("==", "=~"));
          break;
        case 60:
          this._addToken(
            this._match(
              61
              /* CharCode.Equals */
            ) ? 6 : 5
            /* TokenType.Lt */
          );
          break;
        case 62:
          this._addToken(
            this._match(
              61
              /* CharCode.Equals */
            ) ? 8 : 7
            /* TokenType.Gt */
          );
          break;
        case 38:
          this._match(
            38
            /* CharCode.Ampersand */
          ) ? this._addToken(
            15
            /* TokenType.And */
          ) : this._error(AD("&&"));
          break;
        case 124:
          this._match(
            124
            /* CharCode.Pipe */
          ) ? this._addToken(
            16
            /* TokenType.Or */
          ) : this._error(AD("||"));
          break;
        case 32:
        case 13:
        case 9:
        case 10:
        case 160:
          break;
        default:
          this._string();
      }
    return this._start = this._current, this._addToken(
      20
      /* TokenType.EOF */
    ), Array.from(this._tokens);
  }
  _match(e) {
    return this._isAtEnd() || this._input.charCodeAt(this._current) !== e ? !1 : (this._current++, !0);
  }
  _advance() {
    return this._input.charCodeAt(this._current++);
  }
  _peek() {
    return this._isAtEnd() ? 0 : this._input.charCodeAt(this._current);
  }
  _addToken(e) {
    this._tokens.push({ type: e, offset: this._start });
  }
  _error(e) {
    const t = this._start, i = this._input.substring(this._start, this._current), n = { type: 19, offset: this._start, lexeme: i };
    this._errors.push({ offset: t, lexeme: i, additionalInfo: e }), this._tokens.push(n);
  }
  _string() {
    this.stringRe.lastIndex = this._start;
    const e = this.stringRe.exec(this._input);
    if (e) {
      this._current = this._start + e[0].length;
      const t = this._input.substring(this._start, this._current), i = Rx._keywords.get(t);
      i ? this._addToken(i) : this._tokens.push({ type: 17, lexeme: t, offset: this._start });
    }
  }
  // captures the lexeme without the leading and trailing '
  _quotedString() {
    for (; this._peek() !== 39 && !this._isAtEnd(); )
      this._advance();
    if (this._isAtEnd()) {
      this._error(m6);
      return;
    }
    this._advance(), this._tokens.push({ type: 18, lexeme: this._input.substring(this._start + 1, this._current - 1), offset: this._start + 1 });
  }
  /*
   * Lexing a regex expression: /.../[igsmyu]*
   * Based on https://github.com/microsoft/TypeScript/blob/9247ef115e617805983740ba795d7a8164babf89/src/compiler/scanner.ts#L2129-L2181
   *
   * Note that we want slashes within a regex to be escaped, e.g., /file:\\/\\/\\// should match `file:///`
   */
  _regex() {
    let e = this._current, t = !1, i = !1;
    for (; ; ) {
      if (e >= this._input.length) {
        this._current = e, this._error(_6);
        return;
      }
      const s = this._input.charCodeAt(e);
      if (t)
        t = !1;
      else if (s === 47 && !i) {
        e++;
        break;
      } else s === 91 ? i = !0 : s === 92 ? t = !0 : s === 93 && (i = !1);
      e++;
    }
    for (; e < this._input.length && Rx._regexFlags.has(this._input.charCodeAt(e)); )
      e++;
    this._current = e;
    const n = this._input.substring(this._start, this._current);
    this._tokens.push({ type: 10, lexeme: n, offset: this._start });
  }
  _isAtEnd() {
    return this._current >= this._input.length;
  }
};
Oh._regexFlags = new Set(["i", "g", "s", "m", "y", "u"].map((r) => r.charCodeAt(0)));
Oh._keywords = /* @__PURE__ */ new Map([
  [
    "not",
    14
    /* TokenType.Not */
  ],
  [
    "in",
    13
    /* TokenType.In */
  ],
  [
    "false",
    12
    /* TokenType.False */
  ],
  [
    "true",
    11
    /* TokenType.True */
  ]
]);
const An = /* @__PURE__ */ new Map();
An.set("false", !1);
An.set("true", !0);
An.set("isMac", Je);
An.set("isLinux", os);
An.set("isWindows", Ks);
An.set("isWeb", Gu);
An.set("isMacNative", Je && !Gu);
An.set("isEdge", t5);
An.set("isFirefox", i5);
An.set("isChrome", n5);
An.set("isSafari", s5);
const v6 = Object.prototype.hasOwnProperty, b6 = {
  regexParsingWithErrorRecovery: !0
}, C6 = p("contextkey.parser.error.emptyString", "Empty context key expression"), w6 = p("contextkey.parser.error.emptyString.hint", "Did you forget to write an expression? You can also put 'false' or 'true' to always evaluate to false or true, respectively."), S6 = p("contextkey.parser.error.noInAfterNot", "'in' after 'not'."), TA = p("contextkey.parser.error.closingParenthesis", "closing parenthesis ')'"), y6 = p("contextkey.parser.error.unexpectedToken", "Unexpected token"), L6 = p("contextkey.parser.error.unexpectedToken.hint", "Did you forget to put && or || before the token?"), D6 = p("contextkey.parser.error.unexpectedEOF", "Unexpected end of expression"), k6 = p("contextkey.parser.error.unexpectedEOF.hint", "Did you forget to put a context key?");
let YH = class Lm {
  constructor(e = b6) {
    this._config = e, this._scanner = new Oh(), this._tokens = [], this._current = 0, this._parsingErrors = [], this._flagsGYRe = /g|y/g;
  }
  /**
   * Parse a context key expression.
   *
   * @param input the expression to parse
   * @returns the parsed expression or `undefined` if there's an error - call `lexingErrors` and `parsingErrors` to see the errors
   */
  parse(e) {
    if (e === "") {
      this._parsingErrors.push({ message: C6, offset: 0, lexeme: "", additionalInfo: w6 });
      return;
    }
    this._tokens = this._scanner.reset(e).scan(), this._current = 0, this._parsingErrors = [];
    try {
      const t = this._expr();
      if (!this._isAtEnd()) {
        const i = this._peek(), n = i.type === 17 ? L6 : void 0;
        throw this._parsingErrors.push({ message: y6, offset: i.offset, lexeme: Oh.getLexeme(i), additionalInfo: n }), Lm._parseError;
      }
      return t;
    } catch (t) {
      if (t !== Lm._parseError)
        throw t;
      return;
    }
  }
  _expr() {
    return this._or();
  }
  _or() {
    const e = [this._and()];
    for (; this._matchOne(
      16
      /* TokenType.Or */
    ); ) {
      const t = this._and();
      e.push(t);
    }
    return e.length === 1 ? e[0] : U.or(...e);
  }
  _and() {
    const e = [this._term()];
    for (; this._matchOne(
      15
      /* TokenType.And */
    ); ) {
      const t = this._term();
      e.push(t);
    }
    return e.length === 1 ? e[0] : U.and(...e);
  }
  _term() {
    if (this._matchOne(
      2
      /* TokenType.Neg */
    )) {
      const e = this._peek();
      switch (e.type) {
        case 11:
          return this._advance(), as.INSTANCE;
        case 12:
          return this._advance(), ys.INSTANCE;
        case 0: {
          this._advance();
          const t = this._expr();
          return this._consume(1, TA), t == null ? void 0 : t.negate();
        }
        case 17:
          return this._advance(), Qu.create(e.lexeme);
        default:
          throw this._errExpectedButGot("KEY | true | false | '(' expression ')'", e);
      }
    }
    return this._primary();
  }
  _primary() {
    const e = this._peek();
    switch (e.type) {
      case 11:
        return this._advance(), U.true();
      case 12:
        return this._advance(), U.false();
      case 0: {
        this._advance();
        const t = this._expr();
        return this._consume(1, TA), t;
      }
      case 17: {
        const t = e.lexeme;
        if (this._advance(), this._matchOne(
          9
          /* TokenType.RegexOp */
        )) {
          const n = this._peek();
          if (!this._config.regexParsingWithErrorRecovery) {
            if (this._advance(), n.type !== 10)
              throw this._errExpectedButGot("REGEX", n);
            const s = n.lexeme, o = s.lastIndexOf("/"), a = o === s.length - 1 ? void 0 : this._removeFlagsGY(s.substring(o + 1));
            let l;
            try {
              l = new RegExp(s.substring(1, o), a);
            } catch {
              throw this._errExpectedButGot("REGEX", n);
            }
            return F_.create(t, l);
          }
          switch (n.type) {
            case 10:
            case 19: {
              const s = [n.lexeme];
              this._advance();
              let o = this._peek(), a = 0;
              for (let u = 0; u < n.lexeme.length; u++)
                n.lexeme.charCodeAt(u) === 40 ? a++ : n.lexeme.charCodeAt(u) === 41 && a--;
              for (; !this._isAtEnd() && o.type !== 15 && o.type !== 16; ) {
                switch (o.type) {
                  case 0:
                    a++;
                    break;
                  case 1:
                    a--;
                    break;
                  case 10:
                  case 18:
                    for (let u = 0; u < o.lexeme.length; u++)
                      o.lexeme.charCodeAt(u) === 40 ? a++ : n.lexeme.charCodeAt(u) === 41 && a--;
                }
                if (a < 0)
                  break;
                s.push(Oh.getLexeme(o)), this._advance(), o = this._peek();
              }
              const l = s.join(""), d = l.lastIndexOf("/"), c = d === l.length - 1 ? void 0 : this._removeFlagsGY(l.substring(d + 1));
              let h;
              try {
                h = new RegExp(l.substring(1, d), c);
              } catch {
                throw this._errExpectedButGot("REGEX", n);
              }
              return U.regex(t, h);
            }
            case 18: {
              const s = n.lexeme;
              this._advance();
              let o = null;
              if (!$B(s)) {
                const a = s.indexOf("/"), l = s.lastIndexOf("/");
                if (a !== l && a >= 0) {
                  const d = s.slice(a + 1, l), c = s[l + 1] === "i" ? "i" : "";
                  try {
                    o = new RegExp(d, c);
                  } catch {
                    throw this._errExpectedButGot("REGEX", n);
                  }
                }
              }
              if (o === null)
                throw this._errExpectedButGot("REGEX", n);
              return F_.create(t, o);
            }
            default:
              throw this._errExpectedButGot("REGEX", this._peek());
          }
        }
        if (this._matchOne(
          14
          /* TokenType.Not */
        )) {
          this._consume(13, S6);
          const n = this._value();
          return U.notIn(t, n);
        }
        switch (this._peek().type) {
          case 3: {
            this._advance();
            const n = this._value();
            if (this._previous().type === 18)
              return U.equals(t, n);
            switch (n) {
              case "true":
                return U.has(t);
              case "false":
                return U.not(t);
              default:
                return U.equals(t, n);
            }
          }
          case 4: {
            this._advance();
            const n = this._value();
            if (this._previous().type === 18)
              return U.notEquals(t, n);
            switch (n) {
              case "true":
                return U.not(t);
              case "false":
                return U.has(t);
              default:
                return U.notEquals(t, n);
            }
          }
          case 5:
            return this._advance(), p0.create(t, this._value());
          case 6:
            return this._advance(), m0.create(t, this._value());
          case 7:
            return this._advance(), g0.create(t, this._value());
          case 8:
            return this._advance(), f0.create(t, this._value());
          case 13:
            return this._advance(), U.in(t, this._value());
          default:
            return U.has(t);
        }
      }
      case 20:
        throw this._parsingErrors.push({ message: D6, offset: e.offset, lexeme: "", additionalInfo: k6 }), Lm._parseError;
      default:
        throw this._errExpectedButGot(`true | false | KEY 
	| KEY '=~' REGEX 
	| KEY ('==' | '!=' | '<' | '<=' | '>' | '>=' | 'in' | 'not' 'in') value`, this._peek());
    }
  }
  _value() {
    const e = this._peek();
    switch (e.type) {
      case 17:
      case 18:
        return this._advance(), e.lexeme;
      case 11:
        return this._advance(), "true";
      case 12:
        return this._advance(), "false";
      case 13:
        return this._advance(), "in";
      default:
        return "";
    }
  }
  _removeFlagsGY(e) {
    return e.replaceAll(this._flagsGYRe, "");
  }
  // careful: this can throw if current token is the initial one (ie index = 0)
  _previous() {
    return this._tokens[this._current - 1];
  }
  _matchOne(e) {
    return this._check(e) ? (this._advance(), !0) : !1;
  }
  _advance() {
    return this._isAtEnd() || this._current++, this._previous();
  }
  _consume(e, t) {
    if (this._check(e))
      return this._advance();
    throw this._errExpectedButGot(t, this._peek());
  }
  _errExpectedButGot(e, t, i) {
    const n = p("contextkey.parser.error.expectedButGot", `Expected: {0}
Received: '{1}'.`, e, Oh.getLexeme(t)), s = t.offset, o = Oh.getLexeme(t);
    return this._parsingErrors.push({ message: n, offset: s, lexeme: o, additionalInfo: i }), Lm._parseError;
  }
  _check(e) {
    return this._peek().type === e;
  }
  _peek() {
    return this._tokens[this._current];
  }
  _isAtEnd() {
    return this._peek().type === 20;
  }
};
YH._parseError = new Error();
class U {
  static false() {
    return as.INSTANCE;
  }
  static true() {
    return ys.INSTANCE;
  }
  static has(e) {
    return Yu.create(e);
  }
  static equals(e, t) {
    return Ip.create(e, t);
  }
  static notEquals(e, t) {
    return h0.create(e, t);
  }
  static regex(e, t) {
    return F_.create(e, t);
  }
  static in(e, t) {
    return d0.create(e, t);
  }
  static notIn(e, t) {
    return c0.create(e, t);
  }
  static not(e) {
    return Qu.create(e);
  }
  static and(...e) {
    return jh.create(e, null, !0);
  }
  static or(...e) {
    return Rl.create(e, null, !0);
  }
  static deserialize(e) {
    return e == null ? void 0 : this._parser.parse(e);
  }
}
U._parser = new YH({ regexParsingWithErrorRecovery: !1 });
function x6(r, e) {
  const t = r ? r.substituteConstants() : void 0, i = e ? e.substituteConstants() : void 0;
  return !t && !i ? !0 : !t || !i ? !1 : t.equals(i);
}
function Jm(r, e) {
  return r.cmp(e);
}
class as {
  constructor() {
    this.type = 0;
  }
  cmp(e) {
    return this.type - e.type;
  }
  equals(e) {
    return e.type === this.type;
  }
  substituteConstants() {
    return this;
  }
  evaluate(e) {
    return !1;
  }
  serialize() {
    return "false";
  }
  keys() {
    return [];
  }
  negate() {
    return ys.INSTANCE;
  }
}
as.INSTANCE = new as();
class ys {
  constructor() {
    this.type = 1;
  }
  cmp(e) {
    return this.type - e.type;
  }
  equals(e) {
    return e.type === this.type;
  }
  substituteConstants() {
    return this;
  }
  evaluate(e) {
    return !0;
  }
  serialize() {
    return "true";
  }
  keys() {
    return [];
  }
  negate() {
    return as.INSTANCE;
  }
}
ys.INSTANCE = new ys();
class Yu {
  static create(e, t = null) {
    const i = An.get(e);
    return typeof i == "boolean" ? i ? ys.INSTANCE : as.INSTANCE : new Yu(e, t);
  }
  constructor(e, t) {
    this.key = e, this.negated = t, this.type = 2;
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : XH(this.key, e.key);
  }
  equals(e) {
    return e.type === this.type ? this.key === e.key : !1;
  }
  substituteConstants() {
    const e = An.get(this.key);
    return typeof e == "boolean" ? e ? ys.INSTANCE : as.INSTANCE : this;
  }
  evaluate(e) {
    return !!e.getValue(this.key);
  }
  serialize() {
    return this.key;
  }
  keys() {
    return [this.key];
  }
  negate() {
    return this.negated || (this.negated = Qu.create(this.key, this)), this.negated;
  }
}
class Ip {
  static create(e, t, i = null) {
    if (typeof t == "boolean")
      return t ? Yu.create(e, i) : Qu.create(e, i);
    const n = An.get(e);
    return typeof n == "boolean" ? t === (n ? "true" : "false") ? ys.INSTANCE : as.INSTANCE : new Ip(e, t, i);
  }
  constructor(e, t, i) {
    this.key = e, this.value = t, this.negated = i, this.type = 4;
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : Xu(this.key, this.value, e.key, e.value);
  }
  equals(e) {
    return e.type === this.type ? this.key === e.key && this.value === e.value : !1;
  }
  substituteConstants() {
    const e = An.get(this.key);
    if (typeof e == "boolean") {
      const t = e ? "true" : "false";
      return this.value === t ? ys.INSTANCE : as.INSTANCE;
    }
    return this;
  }
  evaluate(e) {
    return e.getValue(this.key) == this.value;
  }
  serialize() {
    return `${this.key} == '${this.value}'`;
  }
  keys() {
    return [this.key];
  }
  negate() {
    return this.negated || (this.negated = h0.create(this.key, this.value, this)), this.negated;
  }
}
class d0 {
  static create(e, t) {
    return new d0(e, t);
  }
  constructor(e, t) {
    this.key = e, this.valueKey = t, this.type = 10, this.negated = null;
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : Xu(this.key, this.valueKey, e.key, e.valueKey);
  }
  equals(e) {
    return e.type === this.type ? this.key === e.key && this.valueKey === e.valueKey : !1;
  }
  substituteConstants() {
    return this;
  }
  evaluate(e) {
    const t = e.getValue(this.valueKey), i = e.getValue(this.key);
    return Array.isArray(t) ? t.includes(i) : typeof i == "string" && typeof t == "object" && t !== null ? v6.call(t, i) : !1;
  }
  serialize() {
    return `${this.key} in '${this.valueKey}'`;
  }
  keys() {
    return [this.key, this.valueKey];
  }
  negate() {
    return this.negated || (this.negated = c0.create(this.key, this.valueKey)), this.negated;
  }
}
class c0 {
  static create(e, t) {
    return new c0(e, t);
  }
  constructor(e, t) {
    this.key = e, this.valueKey = t, this.type = 11, this._negated = d0.create(e, t);
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : this._negated.cmp(e._negated);
  }
  equals(e) {
    return e.type === this.type ? this._negated.equals(e._negated) : !1;
  }
  substituteConstants() {
    return this;
  }
  evaluate(e) {
    return !this._negated.evaluate(e);
  }
  serialize() {
    return `${this.key} not in '${this.valueKey}'`;
  }
  keys() {
    return this._negated.keys();
  }
  negate() {
    return this._negated;
  }
}
class h0 {
  static create(e, t, i = null) {
    if (typeof t == "boolean")
      return t ? Qu.create(e, i) : Yu.create(e, i);
    const n = An.get(e);
    return typeof n == "boolean" ? t === (n ? "true" : "false") ? as.INSTANCE : ys.INSTANCE : new h0(e, t, i);
  }
  constructor(e, t, i) {
    this.key = e, this.value = t, this.negated = i, this.type = 5;
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : Xu(this.key, this.value, e.key, e.value);
  }
  equals(e) {
    return e.type === this.type ? this.key === e.key && this.value === e.value : !1;
  }
  substituteConstants() {
    const e = An.get(this.key);
    if (typeof e == "boolean") {
      const t = e ? "true" : "false";
      return this.value === t ? as.INSTANCE : ys.INSTANCE;
    }
    return this;
  }
  evaluate(e) {
    return e.getValue(this.key) != this.value;
  }
  serialize() {
    return `${this.key} != '${this.value}'`;
  }
  keys() {
    return [this.key];
  }
  negate() {
    return this.negated || (this.negated = Ip.create(this.key, this.value, this)), this.negated;
  }
}
class Qu {
  static create(e, t = null) {
    const i = An.get(e);
    return typeof i == "boolean" ? i ? as.INSTANCE : ys.INSTANCE : new Qu(e, t);
  }
  constructor(e, t) {
    this.key = e, this.negated = t, this.type = 3;
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : XH(this.key, e.key);
  }
  equals(e) {
    return e.type === this.type ? this.key === e.key : !1;
  }
  substituteConstants() {
    const e = An.get(this.key);
    return typeof e == "boolean" ? e ? as.INSTANCE : ys.INSTANCE : this;
  }
  evaluate(e) {
    return !e.getValue(this.key);
  }
  serialize() {
    return `!${this.key}`;
  }
  keys() {
    return [this.key];
  }
  negate() {
    return this.negated || (this.negated = Yu.create(this.key, this)), this.negated;
  }
}
function u0(r, e) {
  if (typeof r == "string") {
    const t = parseFloat(r);
    isNaN(t) || (r = t);
  }
  return typeof r == "string" || typeof r == "number" ? e(r) : as.INSTANCE;
}
class g0 {
  static create(e, t, i = null) {
    return u0(t, (n) => new g0(e, n, i));
  }
  constructor(e, t, i) {
    this.key = e, this.value = t, this.negated = i, this.type = 12;
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : Xu(this.key, this.value, e.key, e.value);
  }
  equals(e) {
    return e.type === this.type ? this.key === e.key && this.value === e.value : !1;
  }
  substituteConstants() {
    return this;
  }
  evaluate(e) {
    return typeof this.value == "string" ? !1 : parseFloat(e.getValue(this.key)) > this.value;
  }
  serialize() {
    return `${this.key} > ${this.value}`;
  }
  keys() {
    return [this.key];
  }
  negate() {
    return this.negated || (this.negated = m0.create(this.key, this.value, this)), this.negated;
  }
}
class f0 {
  static create(e, t, i = null) {
    return u0(t, (n) => new f0(e, n, i));
  }
  constructor(e, t, i) {
    this.key = e, this.value = t, this.negated = i, this.type = 13;
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : Xu(this.key, this.value, e.key, e.value);
  }
  equals(e) {
    return e.type === this.type ? this.key === e.key && this.value === e.value : !1;
  }
  substituteConstants() {
    return this;
  }
  evaluate(e) {
    return typeof this.value == "string" ? !1 : parseFloat(e.getValue(this.key)) >= this.value;
  }
  serialize() {
    return `${this.key} >= ${this.value}`;
  }
  keys() {
    return [this.key];
  }
  negate() {
    return this.negated || (this.negated = p0.create(this.key, this.value, this)), this.negated;
  }
}
class p0 {
  static create(e, t, i = null) {
    return u0(t, (n) => new p0(e, n, i));
  }
  constructor(e, t, i) {
    this.key = e, this.value = t, this.negated = i, this.type = 14;
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : Xu(this.key, this.value, e.key, e.value);
  }
  equals(e) {
    return e.type === this.type ? this.key === e.key && this.value === e.value : !1;
  }
  substituteConstants() {
    return this;
  }
  evaluate(e) {
    return typeof this.value == "string" ? !1 : parseFloat(e.getValue(this.key)) < this.value;
  }
  serialize() {
    return `${this.key} < ${this.value}`;
  }
  keys() {
    return [this.key];
  }
  negate() {
    return this.negated || (this.negated = f0.create(this.key, this.value, this)), this.negated;
  }
}
class m0 {
  static create(e, t, i = null) {
    return u0(t, (n) => new m0(e, n, i));
  }
  constructor(e, t, i) {
    this.key = e, this.value = t, this.negated = i, this.type = 15;
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : Xu(this.key, this.value, e.key, e.value);
  }
  equals(e) {
    return e.type === this.type ? this.key === e.key && this.value === e.value : !1;
  }
  substituteConstants() {
    return this;
  }
  evaluate(e) {
    return typeof this.value == "string" ? !1 : parseFloat(e.getValue(this.key)) <= this.value;
  }
  serialize() {
    return `${this.key} <= ${this.value}`;
  }
  keys() {
    return [this.key];
  }
  negate() {
    return this.negated || (this.negated = g0.create(this.key, this.value, this)), this.negated;
  }
}
class F_ {
  static create(e, t) {
    return new F_(e, t);
  }
  constructor(e, t) {
    this.key = e, this.regexp = t, this.type = 7, this.negated = null;
  }
  cmp(e) {
    if (e.type !== this.type)
      return this.type - e.type;
    if (this.key < e.key)
      return -1;
    if (this.key > e.key)
      return 1;
    const t = this.regexp ? this.regexp.source : "", i = e.regexp ? e.regexp.source : "";
    return t < i ? -1 : t > i ? 1 : 0;
  }
  equals(e) {
    if (e.type === this.type) {
      const t = this.regexp ? this.regexp.source : "", i = e.regexp ? e.regexp.source : "";
      return this.key === e.key && t === i;
    }
    return !1;
  }
  substituteConstants() {
    return this;
  }
  evaluate(e) {
    const t = e.getValue(this.key);
    return this.regexp ? this.regexp.test(t) : !1;
  }
  serialize() {
    const e = this.regexp ? `/${this.regexp.source}/${this.regexp.flags}` : "/invalid/";
    return `${this.key} =~ ${e}`;
  }
  keys() {
    return [this.key];
  }
  negate() {
    return this.negated || (this.negated = l1.create(this)), this.negated;
  }
}
class l1 {
  static create(e) {
    return new l1(e);
  }
  constructor(e) {
    this._actual = e, this.type = 8;
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : this._actual.cmp(e._actual);
  }
  equals(e) {
    return e.type === this.type ? this._actual.equals(e._actual) : !1;
  }
  substituteConstants() {
    return this;
  }
  evaluate(e) {
    return !this._actual.evaluate(e);
  }
  serialize() {
    return `!(${this._actual.serialize()})`;
  }
  keys() {
    return this._actual.keys();
  }
  negate() {
    return this._actual;
  }
}
function QH(r) {
  let e = null;
  for (let t = 0, i = r.length; t < i; t++) {
    const n = r[t].substituteConstants();
    if (r[t] !== n && e === null) {
      e = [];
      for (let s = 0; s < t; s++)
        e[s] = r[s];
    }
    e !== null && (e[t] = n);
  }
  return e === null ? r : e;
}
class jh {
  static create(e, t, i) {
    return jh._normalizeArr(e, t, i);
  }
  constructor(e, t) {
    this.expr = e, this.negated = t, this.type = 6;
  }
  cmp(e) {
    if (e.type !== this.type)
      return this.type - e.type;
    if (this.expr.length < e.expr.length)
      return -1;
    if (this.expr.length > e.expr.length)
      return 1;
    for (let t = 0, i = this.expr.length; t < i; t++) {
      const n = Jm(this.expr[t], e.expr[t]);
      if (n !== 0)
        return n;
    }
    return 0;
  }
  equals(e) {
    if (e.type === this.type) {
      if (this.expr.length !== e.expr.length)
        return !1;
      for (let t = 0, i = this.expr.length; t < i; t++)
        if (!this.expr[t].equals(e.expr[t]))
          return !1;
      return !0;
    }
    return !1;
  }
  substituteConstants() {
    const e = QH(this.expr);
    return e === this.expr ? this : jh.create(e, this.negated, !1);
  }
  evaluate(e) {
    for (let t = 0, i = this.expr.length; t < i; t++)
      if (!this.expr[t].evaluate(e))
        return !1;
    return !0;
  }
  static _normalizeArr(e, t, i) {
    const n = [];
    let s = !1;
    for (const o of e)
      if (o) {
        if (o.type === 1) {
          s = !0;
          continue;
        }
        if (o.type === 0)
          return as.INSTANCE;
        if (o.type === 6) {
          n.push(...o.expr);
          continue;
        }
        n.push(o);
      }
    if (n.length === 0 && s)
      return ys.INSTANCE;
    if (n.length !== 0) {
      if (n.length === 1)
        return n[0];
      n.sort(Jm);
      for (let o = 1; o < n.length; o++)
        n[o - 1].equals(n[o]) && (n.splice(o, 1), o--);
      if (n.length === 1)
        return n[0];
      for (; n.length > 1; ) {
        const o = n[n.length - 1];
        if (o.type !== 9)
          break;
        n.pop();
        const a = n.pop(), l = n.length === 0, d = Rl.create(o.expr.map((c) => jh.create([c, a], null, i)), null, l);
        d && (n.push(d), n.sort(Jm));
      }
      if (n.length === 1)
        return n[0];
      if (i) {
        for (let o = 0; o < n.length; o++)
          for (let a = o + 1; a < n.length; a++)
            if (n[o].negate().equals(n[a]))
              return as.INSTANCE;
        if (n.length === 1)
          return n[0];
      }
      return new jh(n, t);
    }
  }
  serialize() {
    return this.expr.map((e) => e.serialize()).join(" && ");
  }
  keys() {
    const e = [];
    for (const t of this.expr)
      e.push(...t.keys());
    return e;
  }
  negate() {
    if (!this.negated) {
      const e = [];
      for (const t of this.expr)
        e.push(t.negate());
      this.negated = Rl.create(e, this, !0);
    }
    return this.negated;
  }
}
class Rl {
  static create(e, t, i) {
    return Rl._normalizeArr(e, t, i);
  }
  constructor(e, t) {
    this.expr = e, this.negated = t, this.type = 9;
  }
  cmp(e) {
    if (e.type !== this.type)
      return this.type - e.type;
    if (this.expr.length < e.expr.length)
      return -1;
    if (this.expr.length > e.expr.length)
      return 1;
    for (let t = 0, i = this.expr.length; t < i; t++) {
      const n = Jm(this.expr[t], e.expr[t]);
      if (n !== 0)
        return n;
    }
    return 0;
  }
  equals(e) {
    if (e.type === this.type) {
      if (this.expr.length !== e.expr.length)
        return !1;
      for (let t = 0, i = this.expr.length; t < i; t++)
        if (!this.expr[t].equals(e.expr[t]))
          return !1;
      return !0;
    }
    return !1;
  }
  substituteConstants() {
    const e = QH(this.expr);
    return e === this.expr ? this : Rl.create(e, this.negated, !1);
  }
  evaluate(e) {
    for (let t = 0, i = this.expr.length; t < i; t++)
      if (this.expr[t].evaluate(e))
        return !0;
    return !1;
  }
  static _normalizeArr(e, t, i) {
    let n = [], s = !1;
    if (e) {
      for (let o = 0, a = e.length; o < a; o++) {
        const l = e[o];
        if (l) {
          if (l.type === 0) {
            s = !0;
            continue;
          }
          if (l.type === 1)
            return ys.INSTANCE;
          if (l.type === 9) {
            n = n.concat(l.expr);
            continue;
          }
          n.push(l);
        }
      }
      if (n.length === 0 && s)
        return as.INSTANCE;
      n.sort(Jm);
    }
    if (n.length !== 0) {
      if (n.length === 1)
        return n[0];
      for (let o = 1; o < n.length; o++)
        n[o - 1].equals(n[o]) && (n.splice(o, 1), o--);
      if (n.length === 1)
        return n[0];
      if (i) {
        for (let o = 0; o < n.length; o++)
          for (let a = o + 1; a < n.length; a++)
            if (n[o].negate().equals(n[a]))
              return ys.INSTANCE;
        if (n.length === 1)
          return n[0];
      }
      return new Rl(n, t);
    }
  }
  serialize() {
    return this.expr.map((e) => e.serialize()).join(" || ");
  }
  keys() {
    const e = [];
    for (const t of this.expr)
      e.push(...t.keys());
    return e;
  }
  negate() {
    if (!this.negated) {
      const e = [];
      for (const t of this.expr)
        e.push(t.negate());
      for (; e.length > 1; ) {
        const t = e.shift(), i = e.shift(), n = [];
        for (const s of MA(t))
          for (const o of MA(i))
            n.push(jh.create([s, o], null, !1));
        e.unshift(Rl.create(n, null, !1));
      }
      this.negated = Rl.create(e, this, !0);
    }
    return this.negated;
  }
}
class oe extends Yu {
  static all() {
    return oe._info.values();
  }
  constructor(e, t, i) {
    super(e, null), this._defaultValue = t, typeof i == "object" ? oe._info.push({ ...i, key: e }) : i !== !0 && oe._info.push({ key: e, description: i, type: t != null ? typeof t : void 0 });
  }
  bindTo(e) {
    return e.createKey(this.key, this._defaultValue);
  }
  getValue(e) {
    return e.getContextKeyValue(this.key);
  }
  toNegated() {
    return this.negate();
  }
  isEqualTo(e) {
    return Ip.create(this.key, e);
  }
}
oe._info = [];
const De = et("contextKeyService");
function XH(r, e) {
  return r < e ? -1 : r > e ? 1 : 0;
}
function Xu(r, e, t, i) {
  return r < t ? -1 : r > t ? 1 : e < i ? -1 : e > i ? 1 : 0;
}
function Ax(r, e) {
  if (r.type === 0 || e.type === 1)
    return !0;
  if (r.type === 9)
    return e.type === 9 ? NA(r.expr, e.expr) : !1;
  if (e.type === 9) {
    for (const t of e.expr)
      if (Ax(r, t))
        return !0;
    return !1;
  }
  if (r.type === 6) {
    if (e.type === 6)
      return NA(e.expr, r.expr);
    for (const t of r.expr)
      if (Ax(t, e))
        return !0;
    return !1;
  }
  return r.equals(e);
}
function NA(r, e) {
  let t = 0, i = 0;
  for (; t < r.length && i < e.length; ) {
    const n = r[t].cmp(e[i]);
    if (n < 0)
      return !1;
    n === 0 && t++, i++;
  }
  return t === r.length;
}
function MA(r) {
  return r.type === 9 ? r.expr : [r];
}
class I6 {
  constructor() {
    this.data = /* @__PURE__ */ new Map();
  }
  add(e, t) {
    vD(Ws(e)), vD(ur(t)), vD(!this.data.has(e), "There is already an extension with this id"), this.data.set(e, t);
  }
  as(e) {
    return this.data.get(e) || null;
  }
}
const si = new I6();
class d1 {
  constructor() {
    this._coreKeybindings = new Ps(), this._extensionKeybindings = [], this._cachedMergedKeybindings = null;
  }
  /**
   * Take current platform into account and reduce to primary & secondary.
   */
  static bindToCurrentPlatform(e) {
    if (Os === 1) {
      if (e && e.win)
        return e.win;
    } else if (Os === 2) {
      if (e && e.mac)
        return e.mac;
    } else if (e && e.linux)
      return e.linux;
    return e;
  }
  registerKeybindingRule(e) {
    const t = d1.bindToCurrentPlatform(e), i = new q();
    if (t && t.primary) {
      const n = yx(t.primary, Os);
      n && i.add(this._registerDefaultKeybinding(n, e.id, e.args, e.weight, 0, e.when));
    }
    if (t && Array.isArray(t.secondary))
      for (let n = 0, s = t.secondary.length; n < s; n++) {
        const o = t.secondary[n], a = yx(o, Os);
        a && i.add(this._registerDefaultKeybinding(a, e.id, e.args, e.weight, -n - 1, e.when));
      }
    return i;
  }
  registerCommandAndKeybindingRule(e) {
    return Ur(this.registerKeybindingRule(e), st.registerCommand(e));
  }
  _registerDefaultKeybinding(e, t, i, n, s, o) {
    const a = this._coreKeybindings.push({
      keybinding: e,
      command: t,
      commandArgs: i,
      when: o,
      weight1: n,
      weight2: s,
      extensionId: null,
      isBuiltinExtension: !1
    });
    return this._cachedMergedKeybindings = null, Se(() => {
      a(), this._cachedMergedKeybindings = null;
    });
  }
  getDefaultKeybindings() {
    return this._cachedMergedKeybindings || (this._cachedMergedKeybindings = Array.from(this._coreKeybindings).concat(this._extensionKeybindings), this._cachedMergedKeybindings.sort(T6)), this._cachedMergedKeybindings.slice(0);
  }
}
const ls = new d1(), E6 = {
  EditorModes: "platform.keybindingsRegistry"
};
si.add(E6.EditorModes, ls);
function T6(r, e) {
  if (r.weight1 !== e.weight1)
    return r.weight1 - e.weight1;
  if (r.command && e.command) {
    if (r.command < e.command)
      return -1;
    if (r.command > e.command)
      return 1;
  }
  return r.weight2 - e.weight2;
}
var N6 = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, RA = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, xw;
function Vg(r) {
  return r.command !== void 0;
}
function M6(r) {
  return r.submenu !== void 0;
}
class D {
  /**
   * Create a new `MenuId` with the unique identifier. Will throw if a menu
   * with the identifier already exists, use `MenuId.for(ident)` or a unique
   * identifier
   */
  constructor(e) {
    if (D._instances.has(e))
      throw new TypeError(`MenuId with identifier '${e}' already exists. Use MenuId.for(ident) or a unique identifier`);
    D._instances.set(e, this), this.id = e;
  }
}
D._instances = /* @__PURE__ */ new Map();
D.CommandPalette = new D("CommandPalette");
D.DebugBreakpointsContext = new D("DebugBreakpointsContext");
D.DebugCallStackContext = new D("DebugCallStackContext");
D.DebugConsoleContext = new D("DebugConsoleContext");
D.DebugVariablesContext = new D("DebugVariablesContext");
D.NotebookVariablesContext = new D("NotebookVariablesContext");
D.DebugHoverContext = new D("DebugHoverContext");
D.DebugWatchContext = new D("DebugWatchContext");
D.DebugToolBar = new D("DebugToolBar");
D.DebugToolBarStop = new D("DebugToolBarStop");
D.EditorContext = new D("EditorContext");
D.SimpleEditorContext = new D("SimpleEditorContext");
D.EditorContent = new D("EditorContent");
D.EditorLineNumberContext = new D("EditorLineNumberContext");
D.EditorContextCopy = new D("EditorContextCopy");
D.EditorContextPeek = new D("EditorContextPeek");
D.EditorContextShare = new D("EditorContextShare");
D.EditorTitle = new D("EditorTitle");
D.EditorTitleRun = new D("EditorTitleRun");
D.EditorTitleContext = new D("EditorTitleContext");
D.EditorTitleContextShare = new D("EditorTitleContextShare");
D.EmptyEditorGroup = new D("EmptyEditorGroup");
D.EmptyEditorGroupContext = new D("EmptyEditorGroupContext");
D.EditorTabsBarContext = new D("EditorTabsBarContext");
D.EditorTabsBarShowTabsSubmenu = new D("EditorTabsBarShowTabsSubmenu");
D.EditorTabsBarShowTabsZenModeSubmenu = new D("EditorTabsBarShowTabsZenModeSubmenu");
D.EditorActionsPositionSubmenu = new D("EditorActionsPositionSubmenu");
D.ExplorerContext = new D("ExplorerContext");
D.ExplorerContextShare = new D("ExplorerContextShare");
D.ExtensionContext = new D("ExtensionContext");
D.GlobalActivity = new D("GlobalActivity");
D.CommandCenter = new D("CommandCenter");
D.CommandCenterCenter = new D("CommandCenterCenter");
D.LayoutControlMenuSubmenu = new D("LayoutControlMenuSubmenu");
D.LayoutControlMenu = new D("LayoutControlMenu");
D.MenubarMainMenu = new D("MenubarMainMenu");
D.MenubarAppearanceMenu = new D("MenubarAppearanceMenu");
D.MenubarDebugMenu = new D("MenubarDebugMenu");
D.MenubarEditMenu = new D("MenubarEditMenu");
D.MenubarCopy = new D("MenubarCopy");
D.MenubarFileMenu = new D("MenubarFileMenu");
D.MenubarGoMenu = new D("MenubarGoMenu");
D.MenubarHelpMenu = new D("MenubarHelpMenu");
D.MenubarLayoutMenu = new D("MenubarLayoutMenu");
D.MenubarNewBreakpointMenu = new D("MenubarNewBreakpointMenu");
D.PanelAlignmentMenu = new D("PanelAlignmentMenu");
D.PanelPositionMenu = new D("PanelPositionMenu");
D.ActivityBarPositionMenu = new D("ActivityBarPositionMenu");
D.MenubarPreferencesMenu = new D("MenubarPreferencesMenu");
D.MenubarRecentMenu = new D("MenubarRecentMenu");
D.MenubarSelectionMenu = new D("MenubarSelectionMenu");
D.MenubarShare = new D("MenubarShare");
D.MenubarSwitchEditorMenu = new D("MenubarSwitchEditorMenu");
D.MenubarSwitchGroupMenu = new D("MenubarSwitchGroupMenu");
D.MenubarTerminalMenu = new D("MenubarTerminalMenu");
D.MenubarViewMenu = new D("MenubarViewMenu");
D.MenubarHomeMenu = new D("MenubarHomeMenu");
D.OpenEditorsContext = new D("OpenEditorsContext");
D.OpenEditorsContextShare = new D("OpenEditorsContextShare");
D.ProblemsPanelContext = new D("ProblemsPanelContext");
D.SCMInputBox = new D("SCMInputBox");
D.SCMChangesSeparator = new D("SCMChangesSeparator");
D.SCMIncomingChanges = new D("SCMIncomingChanges");
D.SCMIncomingChangesContext = new D("SCMIncomingChangesContext");
D.SCMIncomingChangesSetting = new D("SCMIncomingChangesSetting");
D.SCMOutgoingChanges = new D("SCMOutgoingChanges");
D.SCMOutgoingChangesContext = new D("SCMOutgoingChangesContext");
D.SCMOutgoingChangesSetting = new D("SCMOutgoingChangesSetting");
D.SCMIncomingChangesAllChangesContext = new D("SCMIncomingChangesAllChangesContext");
D.SCMIncomingChangesHistoryItemContext = new D("SCMIncomingChangesHistoryItemContext");
D.SCMOutgoingChangesAllChangesContext = new D("SCMOutgoingChangesAllChangesContext");
D.SCMOutgoingChangesHistoryItemContext = new D("SCMOutgoingChangesHistoryItemContext");
D.SCMChangeContext = new D("SCMChangeContext");
D.SCMResourceContext = new D("SCMResourceContext");
D.SCMResourceContextShare = new D("SCMResourceContextShare");
D.SCMResourceFolderContext = new D("SCMResourceFolderContext");
D.SCMResourceGroupContext = new D("SCMResourceGroupContext");
D.SCMSourceControl = new D("SCMSourceControl");
D.SCMSourceControlInline = new D("SCMSourceControlInline");
D.SCMSourceControlTitle = new D("SCMSourceControlTitle");
D.SCMTitle = new D("SCMTitle");
D.SearchContext = new D("SearchContext");
D.SearchActionMenu = new D("SearchActionContext");
D.StatusBarWindowIndicatorMenu = new D("StatusBarWindowIndicatorMenu");
D.StatusBarRemoteIndicatorMenu = new D("StatusBarRemoteIndicatorMenu");
D.StickyScrollContext = new D("StickyScrollContext");
D.TestItem = new D("TestItem");
D.TestItemGutter = new D("TestItemGutter");
D.TestMessageContext = new D("TestMessageContext");
D.TestMessageContent = new D("TestMessageContent");
D.TestPeekElement = new D("TestPeekElement");
D.TestPeekTitle = new D("TestPeekTitle");
D.TouchBarContext = new D("TouchBarContext");
D.TitleBarContext = new D("TitleBarContext");
D.TitleBarTitleContext = new D("TitleBarTitleContext");
D.TunnelContext = new D("TunnelContext");
D.TunnelPrivacy = new D("TunnelPrivacy");
D.TunnelProtocol = new D("TunnelProtocol");
D.TunnelPortInline = new D("TunnelInline");
D.TunnelTitle = new D("TunnelTitle");
D.TunnelLocalAddressInline = new D("TunnelLocalAddressInline");
D.TunnelOriginInline = new D("TunnelOriginInline");
D.ViewItemContext = new D("ViewItemContext");
D.ViewContainerTitle = new D("ViewContainerTitle");
D.ViewContainerTitleContext = new D("ViewContainerTitleContext");
D.ViewTitle = new D("ViewTitle");
D.ViewTitleContext = new D("ViewTitleContext");
D.CommentEditorActions = new D("CommentEditorActions");
D.CommentThreadTitle = new D("CommentThreadTitle");
D.CommentThreadActions = new D("CommentThreadActions");
D.CommentThreadAdditionalActions = new D("CommentThreadAdditionalActions");
D.CommentThreadTitleContext = new D("CommentThreadTitleContext");
D.CommentThreadCommentContext = new D("CommentThreadCommentContext");
D.CommentTitle = new D("CommentTitle");
D.CommentActions = new D("CommentActions");
D.CommentsViewThreadActions = new D("CommentsViewThreadActions");
D.InteractiveToolbar = new D("InteractiveToolbar");
D.InteractiveCellTitle = new D("InteractiveCellTitle");
D.InteractiveCellDelete = new D("InteractiveCellDelete");
D.InteractiveCellExecute = new D("InteractiveCellExecute");
D.InteractiveInputExecute = new D("InteractiveInputExecute");
D.IssueReporter = new D("IssueReporter");
D.NotebookToolbar = new D("NotebookToolbar");
D.NotebookStickyScrollContext = new D("NotebookStickyScrollContext");
D.NotebookCellTitle = new D("NotebookCellTitle");
D.NotebookCellDelete = new D("NotebookCellDelete");
D.NotebookCellInsert = new D("NotebookCellInsert");
D.NotebookCellBetween = new D("NotebookCellBetween");
D.NotebookCellListTop = new D("NotebookCellTop");
D.NotebookCellExecute = new D("NotebookCellExecute");
D.NotebookCellExecuteGoTo = new D("NotebookCellExecuteGoTo");
D.NotebookCellExecutePrimary = new D("NotebookCellExecutePrimary");
D.NotebookDiffCellInputTitle = new D("NotebookDiffCellInputTitle");
D.NotebookDiffCellMetadataTitle = new D("NotebookDiffCellMetadataTitle");
D.NotebookDiffCellOutputsTitle = new D("NotebookDiffCellOutputsTitle");
D.NotebookOutputToolbar = new D("NotebookOutputToolbar");
D.NotebookOutlineFilter = new D("NotebookOutlineFilter");
D.NotebookOutlineActionMenu = new D("NotebookOutlineActionMenu");
D.NotebookEditorLayoutConfigure = new D("NotebookEditorLayoutConfigure");
D.NotebookKernelSource = new D("NotebookKernelSource");
D.BulkEditTitle = new D("BulkEditTitle");
D.BulkEditContext = new D("BulkEditContext");
D.TimelineItemContext = new D("TimelineItemContext");
D.TimelineTitle = new D("TimelineTitle");
D.TimelineTitleContext = new D("TimelineTitleContext");
D.TimelineFilterSubMenu = new D("TimelineFilterSubMenu");
D.AccountsContext = new D("AccountsContext");
D.SidebarTitle = new D("SidebarTitle");
D.PanelTitle = new D("PanelTitle");
D.AuxiliaryBarTitle = new D("AuxiliaryBarTitle");
D.AuxiliaryBarHeader = new D("AuxiliaryBarHeader");
D.TerminalInstanceContext = new D("TerminalInstanceContext");
D.TerminalEditorInstanceContext = new D("TerminalEditorInstanceContext");
D.TerminalNewDropdownContext = new D("TerminalNewDropdownContext");
D.TerminalTabContext = new D("TerminalTabContext");
D.TerminalTabEmptyAreaContext = new D("TerminalTabEmptyAreaContext");
D.TerminalStickyScrollContext = new D("TerminalStickyScrollContext");
D.WebviewContext = new D("WebviewContext");
D.InlineCompletionsActions = new D("InlineCompletionsActions");
D.InlineEditActions = new D("InlineEditActions");
D.NewFile = new D("NewFile");
D.MergeInput1Toolbar = new D("MergeToolbar1Toolbar");
D.MergeInput2Toolbar = new D("MergeToolbar2Toolbar");
D.MergeBaseToolbar = new D("MergeBaseToolbar");
D.MergeInputResultToolbar = new D("MergeToolbarResultToolbar");
D.InlineSuggestionToolbar = new D("InlineSuggestionToolbar");
D.InlineEditToolbar = new D("InlineEditToolbar");
D.ChatContext = new D("ChatContext");
D.ChatCodeBlock = new D("ChatCodeblock");
D.ChatCompareBlock = new D("ChatCompareBlock");
D.ChatMessageTitle = new D("ChatMessageTitle");
D.ChatExecute = new D("ChatExecute");
D.ChatExecuteSecondary = new D("ChatExecuteSecondary");
D.ChatInputSide = new D("ChatInputSide");
D.AccessibleView = new D("AccessibleView");
D.MultiDiffEditorFileToolbar = new D("MultiDiffEditorFileToolbar");
D.DiffEditorHunkToolbar = new D("DiffEditorHunkToolbar");
D.DiffEditorSelectionToolbar = new D("DiffEditorSelectionToolbar");
const vo = et("menuService");
class Al {
  static for(e) {
    let t = this._all.get(e);
    return t || (t = new Al(e), this._all.set(e, t)), t;
  }
  static merge(e) {
    const t = /* @__PURE__ */ new Set();
    for (const i of e)
      i instanceof Al && t.add(i.id);
    return t;
  }
  constructor(e) {
    this.id = e, this.has = (t) => t === e;
  }
}
Al._all = /* @__PURE__ */ new Map();
const on = new class {
  constructor() {
    this._commands = /* @__PURE__ */ new Map(), this._menuItems = /* @__PURE__ */ new Map(), this._onDidChangeMenu = new o5({
      merge: Al.merge
    }), this.onDidChangeMenu = this._onDidChangeMenu.event;
  }
  addCommand(r) {
    return this._commands.set(r.id, r), this._onDidChangeMenu.fire(Al.for(D.CommandPalette)), Se(() => {
      this._commands.delete(r.id) && this._onDidChangeMenu.fire(Al.for(D.CommandPalette));
    });
  }
  getCommand(r) {
    return this._commands.get(r);
  }
  getCommands() {
    const r = /* @__PURE__ */ new Map();
    return this._commands.forEach((e, t) => r.set(t, e)), r;
  }
  appendMenuItem(r, e) {
    let t = this._menuItems.get(r);
    t || (t = new Ps(), this._menuItems.set(r, t));
    const i = t.push(e);
    return this._onDidChangeMenu.fire(Al.for(r)), Se(() => {
      i(), this._onDidChangeMenu.fire(Al.for(r));
    });
  }
  appendMenuItems(r) {
    const e = new q();
    for (const { id: t, item: i } of r)
      e.add(this.appendMenuItem(t, i));
    return e;
  }
  getMenuItems(r) {
    let e;
    return this._menuItems.has(r) ? e = [...this._menuItems.get(r)] : e = [], r === D.CommandPalette && this._appendImplicitItems(e), e;
  }
  _appendImplicitItems(r) {
    const e = /* @__PURE__ */ new Set();
    for (const t of r)
      Vg(t) && (e.add(t.command.id), t.alt && e.add(t.alt.id));
    this._commands.forEach((t, i) => {
      e.has(i) || r.push({ command: t });
    });
  }
}();
class gf extends Bf {
  constructor(e, t, i) {
    super(`submenuitem.${e.submenu.id}`, typeof e.title == "string" ? e.title : e.title.value, i, "submenu"), this.item = e, this.hideActions = t;
  }
}
let Hs = xw = class {
  static label(e, t) {
    return t != null && t.renderShortTitle && e.shortTitle ? typeof e.shortTitle == "string" ? e.shortTitle : e.shortTitle.value : typeof e.title == "string" ? e.title : e.title.value;
  }
  constructor(e, t, i, n, s, o, a) {
    var l, d;
    this.hideActions = n, this.menuKeybinding = s, this._commandService = a, this.id = e.id, this.label = xw.label(e, i), this.tooltip = (d = typeof e.tooltip == "string" ? e.tooltip : (l = e.tooltip) === null || l === void 0 ? void 0 : l.value) !== null && d !== void 0 ? d : "", this.enabled = !e.precondition || o.contextMatchesRules(e.precondition), this.checked = void 0;
    let c;
    if (e.toggled) {
      const h = e.toggled.condition ? e.toggled : { condition: e.toggled };
      this.checked = o.contextMatchesRules(h.condition), this.checked && h.tooltip && (this.tooltip = typeof h.tooltip == "string" ? h.tooltip : h.tooltip.value), this.checked && Le.isThemeIcon(h.icon) && (c = h.icon), this.checked && h.title && (this.label = typeof h.title == "string" ? h.title : h.title.value);
    }
    c || (c = Le.isThemeIcon(e.icon) ? e.icon : void 0), this.item = e, this.alt = t ? new xw(t, void 0, i, n, void 0, o, a) : void 0, this._options = i, this.class = c && Le.asClassName(c);
  }
  run(...e) {
    var t, i;
    let n = [];
    return !((t = this._options) === null || t === void 0) && t.arg && (n = [...n, this._options.arg]), !((i = this._options) === null || i === void 0) && i.shouldForwardArgs && (n = [...n, ...e]), this._commandService.executeCommand(this.id, ...n);
  }
};
Hs = xw = N6([
  RA(5, De),
  RA(6, $t)
], Hs);
class cs {
  constructor(e) {
    this.desc = e;
  }
}
function Rt(r) {
  const e = [], t = new r(), { f1: i, menu: n, keybinding: s, ...o } = t.desc;
  if (st.getCommand(o.id))
    throw new Error(`Cannot register two commands with the same id: ${o.id}`);
  if (e.push(st.registerCommand({
    id: o.id,
    handler: (a, ...l) => t.run(a, ...l),
    metadata: o.metadata
  })), Array.isArray(n))
    for (const a of n)
      e.push(on.appendMenuItem(a.id, { command: { ...o, precondition: a.precondition === null ? void 0 : o.precondition }, ...a }));
  else n && e.push(on.appendMenuItem(n.id, { command: { ...o, precondition: n.precondition === null ? void 0 : o.precondition }, ...n }));
  if (i && (e.push(on.appendMenuItem(D.CommandPalette, { command: o, when: o.precondition })), e.push(on.addCommand(o))), Array.isArray(s))
    for (const a of s)
      e.push(ls.registerKeybindingRule({
        ...a,
        id: o.id,
        when: o.precondition ? U.and(o.precondition, a.when) : a.when
      }));
  else s && e.push(ls.registerKeybindingRule({
    ...s,
    id: o.id,
    when: o.precondition ? U.and(o.precondition, s.when) : s.when
  }));
  return {
    dispose() {
      zt(e);
    }
  };
}
const kn = et("telemetryService"), Pn = et("logService");
var Sn;
(function(r) {
  r[r.Off = 0] = "Off", r[r.Trace = 1] = "Trace", r[r.Debug = 2] = "Debug", r[r.Info = 3] = "Info", r[r.Warning = 4] = "Warning", r[r.Error = 5] = "Error";
})(Sn || (Sn = {}));
const JH = Sn.Info;
class eV extends P {
  constructor() {
    super(...arguments), this.level = JH, this._onDidChangeLogLevel = this._register(new R()), this.onDidChangeLogLevel = this._onDidChangeLogLevel.event;
  }
  setLevel(e) {
    this.level !== e && (this.level = e, this._onDidChangeLogLevel.fire(this.level));
  }
  getLevel() {
    return this.level;
  }
  checkLogLevel(e) {
    return this.level !== Sn.Off && this.level <= e;
  }
}
class R6 extends eV {
  constructor(e = JH, t = !0) {
    super(), this.useColors = t, this.setLevel(e);
  }
  trace(e, ...t) {
    this.checkLogLevel(Sn.Trace) && (this.useColors ? console.log("%cTRACE", "color: #888", e, ...t) : console.log(e, ...t));
  }
  debug(e, ...t) {
    this.checkLogLevel(Sn.Debug) && (this.useColors ? console.log("%cDEBUG", "background: #eee; color: #888", e, ...t) : console.log(e, ...t));
  }
  info(e, ...t) {
    this.checkLogLevel(Sn.Info) && (this.useColors ? console.log("%c INFO", "color: #33f", e, ...t) : console.log(e, ...t));
  }
  warn(e, ...t) {
    this.checkLogLevel(Sn.Warning) && (this.useColors ? console.log("%c WARN", "color: #993", e, ...t) : console.log(e, ...t));
  }
  error(e, ...t) {
    this.checkLogLevel(Sn.Error) && (this.useColors ? console.log("%c  ERR", "color: #f33", e, ...t) : console.error(e, ...t));
  }
}
class A6 extends eV {
  constructor(e) {
    super(), this.loggers = e, e.length && this.setLevel(e[0].getLevel());
  }
  setLevel(e) {
    for (const t of this.loggers)
      t.setLevel(e);
    super.setLevel(e);
  }
  trace(e, ...t) {
    for (const i of this.loggers)
      i.trace(e, ...t);
  }
  debug(e, ...t) {
    for (const i of this.loggers)
      i.debug(e, ...t);
  }
  info(e, ...t) {
    for (const i of this.loggers)
      i.info(e, ...t);
  }
  warn(e, ...t) {
    for (const i of this.loggers)
      i.warn(e, ...t);
  }
  error(e, ...t) {
    for (const i of this.loggers)
      i.error(e, ...t);
  }
  dispose() {
    for (const e of this.loggers)
      e.dispose();
    super.dispose();
  }
}
function P6(r) {
  switch (r) {
    case Sn.Trace:
      return "trace";
    case Sn.Debug:
      return "debug";
    case Sn.Info:
      return "info";
    case Sn.Warning:
      return "warn";
    case Sn.Error:
      return "error";
    case Sn.Off:
      return "off";
  }
}
new oe("logLevel", P6(Sn.Info));
class _0 {
  constructor(e) {
    this.id = e.id, this.precondition = e.precondition, this._kbOpts = e.kbOpts, this._menuOpts = e.menuOpts, this.metadata = e.metadata;
  }
  register() {
    if (Array.isArray(this._menuOpts) ? this._menuOpts.forEach(this._registerMenuItem, this) : this._menuOpts && this._registerMenuItem(this._menuOpts), this._kbOpts) {
      const e = Array.isArray(this._kbOpts) ? this._kbOpts : [this._kbOpts];
      for (const t of e) {
        let i = t.kbExpr;
        this.precondition && (i ? i = U.and(i, this.precondition) : i = this.precondition);
        const n = {
          id: this.id,
          weight: t.weight,
          args: t.args,
          when: i,
          primary: t.primary,
          secondary: t.secondary,
          win: t.win,
          linux: t.linux,
          mac: t.mac
        };
        ls.registerKeybindingRule(n);
      }
    }
    st.registerCommand({
      id: this.id,
      handler: (e, t) => this.runCommand(e, t),
      metadata: this.metadata
    });
  }
  _registerMenuItem(e) {
    on.appendMenuItem(e.menuId, {
      group: e.group,
      command: {
        id: this.id,
        title: e.title,
        icon: e.icon,
        precondition: this.precondition
      },
      when: e.when,
      order: e.order
    });
  }
}
class Ep extends _0 {
  constructor() {
    super(...arguments), this._implementations = [];
  }
  /**
   * A higher priority gets to be looked at first
   */
  addImplementation(e, t, i, n) {
    return this._implementations.push({ priority: e, name: t, implementation: i, when: n }), this._implementations.sort((s, o) => o.priority - s.priority), {
      dispose: () => {
        for (let s = 0; s < this._implementations.length; s++)
          if (this._implementations[s].implementation === i) {
            this._implementations.splice(s, 1);
            return;
          }
      }
    };
  }
  runCommand(e, t) {
    const i = e.get(Pn), n = e.get(De);
    i.trace(`Executing Command '${this.id}' which has ${this._implementations.length} bound.`);
    for (const s of this._implementations) {
      if (s.when) {
        const a = n.getContext(Ln());
        if (!s.when.evaluate(a))
          continue;
      }
      const o = s.implementation(e, t);
      if (o)
        return i.trace(`Command '${this.id}' was handled by '${s.name}'.`), typeof o == "boolean" ? void 0 : o;
    }
    i.trace(`The Command '${this.id}' was not handled by any implementation.`);
  }
}
class tV extends _0 {
  constructor(e, t) {
    super(t), this.command = e;
  }
  runCommand(e, t) {
    return this.command.runCommand(e, t);
  }
}
class Ui extends _0 {
  /**
   * Create a command class that is bound to a certain editor contribution.
   */
  static bindToContribution(e) {
    return class extends Ui {
      constructor(i) {
        super(i), this._callback = i.handler;
      }
      runEditorCommand(i, n, s) {
        const o = e(n);
        o && this._callback(o, s);
      }
    };
  }
  static runEditorCommand(e, t, i, n) {
    const s = e.get(ht), o = s.getFocusedCodeEditor() || s.getActiveCodeEditor();
    if (o)
      return o.invokeWithinContext((a) => {
        if (a.get(De).contextMatchesRules(i ?? void 0))
          return n(a, o, t);
      });
  }
  runCommand(e, t) {
    return Ui.runEditorCommand(e, t, this.precondition, (i, n, s) => this.runEditorCommand(i, n, s));
  }
}
class ae extends Ui {
  static convertOptions(e) {
    let t;
    Array.isArray(e.menuOpts) ? t = e.menuOpts : e.menuOpts ? t = [e.menuOpts] : t = [];
    function i(n) {
      return n.menuId || (n.menuId = D.EditorContext), n.title || (n.title = e.label), n.when = U.and(e.precondition, n.when), n;
    }
    return Array.isArray(e.contextMenuOpts) ? t.push(...e.contextMenuOpts.map(i)) : e.contextMenuOpts && t.push(i(e.contextMenuOpts)), e.menuOpts = t, e;
  }
  constructor(e) {
    super(ae.convertOptions(e)), this.label = e.label, this.alias = e.alias;
  }
  runEditorCommand(e, t, i) {
    return this.reportTelemetry(e, t), this.run(e, t, i || {});
  }
  reportTelemetry(e, t) {
    e.get(kn).publicLog2("editorActionInvoked", { name: this.label, id: this.id });
  }
}
class iV extends ae {
  constructor() {
    super(...arguments), this._implementations = [];
  }
  /**
   * A higher priority gets to be looked at first
   */
  addImplementation(e, t) {
    return this._implementations.push([e, t]), this._implementations.sort((i, n) => n[0] - i[0]), {
      dispose: () => {
        for (let i = 0; i < this._implementations.length; i++)
          if (this._implementations[i][1] === t) {
            this._implementations.splice(i, 1);
            return;
          }
      }
    };
  }
  run(e, t, i) {
    for (const n of this._implementations) {
      const s = n[1](e, t, i);
      if (s)
        return typeof s == "boolean" ? void 0 : s;
    }
  }
}
class ra extends cs {
  run(e, ...t) {
    const i = e.get(ht), n = i.getFocusedCodeEditor() || i.getActiveCodeEditor();
    if (n)
      return n.invokeWithinContext((s) => {
        var o, a;
        const l = s.get(De), d = s.get(Pn);
        if (!l.contextMatchesRules((o = this.desc.precondition) !== null && o !== void 0 ? o : void 0)) {
          d.debug("[EditorAction2] NOT running command because its precondition is FALSE", this.desc.id, (a = this.desc.precondition) === null || a === void 0 ? void 0 : a.serialize());
          return;
        }
        return this.runEditorCommand(s, n, ...t);
      });
  }
}
function ul(r, e) {
  st.registerCommand(r, function(t, ...i) {
    const n = t.get(be), [s, o] = i;
    ct(Ee.isUri(s)), ct(A.isIPosition(o));
    const a = t.get(ii).getModel(s);
    if (a) {
      const l = A.lift(o);
      return n.invokeFunction(e, a, l, ...i.slice(2));
    }
    return t.get(xs).createModelReference(s).then((l) => new Promise((d, c) => {
      try {
        const h = n.invokeFunction(e, l.object.textEditorModel, A.lift(o), i.slice(2));
        d(h);
      } catch (h) {
        c(h);
      }
    }).finally(() => {
      l.dispose();
    }));
  });
}
function se(r) {
  return Io.INSTANCE.registerEditorCommand(r), r;
}
function Y(r) {
  const e = new r();
  return Io.INSTANCE.registerEditorAction(e), e;
}
function nV(r) {
  return Io.INSTANCE.registerEditorAction(r), r;
}
function O6(r) {
  Io.INSTANCE.registerEditorAction(r);
}
function gt(r, e, t) {
  Io.INSTANCE.registerEditorContribution(r, e, t);
}
var ff;
(function(r) {
  function e(o) {
    return Io.INSTANCE.getEditorCommand(o);
  }
  r.getEditorCommand = e;
  function t() {
    return Io.INSTANCE.getEditorActions();
  }
  r.getEditorActions = t;
  function i() {
    return Io.INSTANCE.getEditorContributions();
  }
  r.getEditorContributions = i;
  function n(o) {
    return Io.INSTANCE.getEditorContributions().filter((a) => o.indexOf(a.id) >= 0);
  }
  r.getSomeEditorContributions = n;
  function s() {
    return Io.INSTANCE.getDiffEditorContributions();
  }
  r.getDiffEditorContributions = s;
})(ff || (ff = {}));
const F6 = {
  EditorCommonContributions: "editor.contributions"
};
class Io {
  constructor() {
    this.editorContributions = [], this.diffEditorContributions = [], this.editorActions = [], this.editorCommands = /* @__PURE__ */ Object.create(null);
  }
  registerEditorContribution(e, t, i) {
    this.editorContributions.push({ id: e, ctor: t, instantiation: i });
  }
  getEditorContributions() {
    return this.editorContributions.slice(0);
  }
  getDiffEditorContributions() {
    return this.diffEditorContributions.slice(0);
  }
  registerEditorAction(e) {
    e.register(), this.editorActions.push(e);
  }
  getEditorActions() {
    return this.editorActions;
  }
  registerEditorCommand(e) {
    e.register(), this.editorCommands[e.id] = e;
  }
  getEditorCommand(e) {
    return this.editorCommands[e] || null;
  }
}
Io.INSTANCE = new Io();
si.add(F6.EditorCommonContributions, Io.INSTANCE);
function lb(r) {
  return r.register(), r;
}
const sV = lb(new Ep({
  id: "undo",
  precondition: void 0,
  kbOpts: {
    weight: 0,
    primary: 2104
    /* KeyCode.KeyZ */
  },
  menuOpts: [{
    menuId: D.MenubarEditMenu,
    group: "1_do",
    title: p({ key: "miUndo", comment: ["&& denotes a mnemonic"] }, "&&Undo"),
    order: 1
  }, {
    menuId: D.CommandPalette,
    group: "",
    title: p("undo", "Undo"),
    order: 1
  }]
}));
lb(new tV(sV, { id: "default:undo", precondition: void 0 }));
const oV = lb(new Ep({
  id: "redo",
  precondition: void 0,
  kbOpts: {
    weight: 0,
    primary: 2103,
    secondary: [
      3128
      /* KeyCode.KeyZ */
    ],
    mac: {
      primary: 3128
      /* KeyCode.KeyZ */
    }
  },
  menuOpts: [{
    menuId: D.MenubarEditMenu,
    group: "1_do",
    title: p({ key: "miRedo", comment: ["&& denotes a mnemonic"] }, "&&Redo"),
    order: 2
  }, {
    menuId: D.CommandPalette,
    group: "",
    title: p("redo", "Redo"),
    order: 1
  }]
}));
lb(new tV(oV, { id: "default:redo", precondition: void 0 }));
const W6 = lb(new Ep({
  id: "editor.action.selectAll",
  precondition: void 0,
  kbOpts: {
    weight: 0,
    kbExpr: null,
    primary: 2079
    /* KeyCode.KeyA */
  },
  menuOpts: [{
    menuId: D.MenubarSelectionMenu,
    group: "1_basic",
    title: p({ key: "miSelectAll", comment: ["&& denotes a mnemonic"] }, "&&Select All"),
    order: 1
  }, {
    menuId: D.CommandPalette,
    group: "",
    title: p("selectAll", "Select All"),
    order: 1
  }]
}));
function wd(r, e) {
  var t;
  const i = globalThis.MonacoEnvironment;
  if (i != null && i.createTrustedTypesPolicy)
    try {
      return i.createTrustedTypesPolicy(r, e);
    } catch (n) {
      He(n);
      return;
    }
  try {
    return (t = Dt.trustedTypes) === null || t === void 0 ? void 0 : t.createPolicy(r, e);
  } catch (n) {
    He(n);
    return;
  }
}
const AA = wd("defaultWorkerFactory", { createScriptURL: (r) => r });
function B6(r) {
  const e = globalThis.MonacoEnvironment;
  if (e) {
    if (typeof e.getWorker == "function")
      return e.getWorker("workerMain.js", r);
    if (typeof e.getWorkerUrl == "function") {
      const t = e.getWorkerUrl("workerMain.js", r);
      return new Worker(AA ? AA.createScriptURL(t) : t, { name: r });
    }
  }
  throw new Error("You must define a function MonacoEnvironment.getWorkerUrl or MonacoEnvironment.getWorker");
}
function H6(r) {
  return typeof r.then == "function";
}
class V6 extends P {
  constructor(e, t, i, n, s) {
    super(), this.id = t, this.label = i;
    const o = B6(i);
    H6(o) ? this.worker = o : this.worker = Promise.resolve(o), this.postMessage(e, []), this.worker.then((a) => {
      a.onmessage = function(l) {
        n(l.data);
      }, a.onmessageerror = s, typeof a.addEventListener == "function" && a.addEventListener("error", s);
    }), this._register(Se(() => {
      var a;
      (a = this.worker) === null || a === void 0 || a.then((l) => {
        l.onmessage = null, l.onmessageerror = null, l.removeEventListener("error", s), l.terminate();
      }), this.worker = null;
    }));
  }
  getId() {
    return this.id;
  }
  postMessage(e, t) {
    var i;
    (i = this.worker) === null || i === void 0 || i.then((n) => {
      try {
        n.postMessage(e, t);
      } catch (s) {
        He(s), He(new Error(`FAILED to post message to '${this.label}'-worker`, { cause: s }));
      }
    });
  }
}
class v0 {
  constructor(e) {
    this._label = e, this._webWorkerFailedBeforeError = !1;
  }
  create(e, t, i) {
    const n = ++v0.LAST_WORKER_ID;
    if (this._webWorkerFailedBeforeError)
      throw this._webWorkerFailedBeforeError;
    return new V6(e, n, this._label || "anonymous" + n, t, (s) => {
      _x(s), this._webWorkerFailedBeforeError = s, i(s);
    });
  }
}
v0.LAST_WORKER_ID = 0;
var Mi;
(function(r) {
  r[r.None = 0] = "None", r[r.Indent = 1] = "Indent", r[r.IndentOutdent = 2] = "IndentOutdent", r[r.Outdent = 3] = "Outdent";
})(Mi || (Mi = {}));
class PD {
  constructor(e) {
    if (this._neutralCharacter = null, this._neutralCharacterSearched = !1, this.open = e.open, this.close = e.close, this._inString = !0, this._inComment = !0, this._inRegEx = !0, Array.isArray(e.notIn))
      for (let t = 0, i = e.notIn.length; t < i; t++)
        switch (e.notIn[t]) {
          case "string":
            this._inString = !1;
            break;
          case "comment":
            this._inComment = !1;
            break;
          case "regex":
            this._inRegEx = !1;
            break;
        }
  }
  isOK(e) {
    switch (e) {
      case 0:
        return !0;
      case 1:
        return this._inComment;
      case 2:
        return this._inString;
      case 3:
        return this._inRegEx;
    }
  }
  shouldAutoClose(e, t) {
    if (e.getTokenCount() === 0)
      return !0;
    const i = e.findTokenIndexAtOffset(t - 2), n = e.getStandardTokenType(i);
    return this.isOK(n);
  }
  _findNeutralCharacterInRange(e, t) {
    for (let i = e; i <= t; i++) {
      const n = String.fromCharCode(i);
      if (!this.open.includes(n) && !this.close.includes(n))
        return n;
    }
    return null;
  }
  /**
   * Find a character in the range [0-9a-zA-Z] that does not appear in the open or close
   */
  findNeutralCharacter() {
    return this._neutralCharacterSearched || (this._neutralCharacterSearched = !0, this._neutralCharacter || (this._neutralCharacter = this._findNeutralCharacterInRange(
      48,
      57
      /* CharCode.Digit9 */
    )), this._neutralCharacter || (this._neutralCharacter = this._findNeutralCharacterInRange(
      97,
      122
      /* CharCode.z */
    )), this._neutralCharacter || (this._neutralCharacter = this._findNeutralCharacterInRange(
      65,
      90
      /* CharCode.Z */
    ))), this._neutralCharacter;
  }
}
class z6 {
  constructor(e) {
    this.autoClosingPairsOpenByStart = /* @__PURE__ */ new Map(), this.autoClosingPairsOpenByEnd = /* @__PURE__ */ new Map(), this.autoClosingPairsCloseByStart = /* @__PURE__ */ new Map(), this.autoClosingPairsCloseByEnd = /* @__PURE__ */ new Map(), this.autoClosingPairsCloseSingleChar = /* @__PURE__ */ new Map();
    for (const t of e)
      Xp(this.autoClosingPairsOpenByStart, t.open.charAt(0), t), Xp(this.autoClosingPairsOpenByEnd, t.open.charAt(t.open.length - 1), t), Xp(this.autoClosingPairsCloseByStart, t.close.charAt(0), t), Xp(this.autoClosingPairsCloseByEnd, t.close.charAt(t.close.length - 1), t), t.close.length === 1 && t.open.length === 1 && Xp(this.autoClosingPairsCloseSingleChar, t.close, t);
  }
}
function Xp(r, e, t) {
  r.has(e) ? r.get(e).push(t) : r.set(e, [t]);
}
class Hf {
  constructor(e) {
    if (e.autoClosingPairs ? this._autoClosingPairs = e.autoClosingPairs.map((t) => new PD(t)) : e.brackets ? this._autoClosingPairs = e.brackets.map((t) => new PD({ open: t[0], close: t[1] })) : this._autoClosingPairs = [], e.__electricCharacterSupport && e.__electricCharacterSupport.docComment) {
      const t = e.__electricCharacterSupport.docComment;
      this._autoClosingPairs.push(new PD({ open: t.open, close: t.close || "" }));
    }
    this._autoCloseBeforeForQuotes = typeof e.autoCloseBefore == "string" ? e.autoCloseBefore : Hf.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_QUOTES, this._autoCloseBeforeForBrackets = typeof e.autoCloseBefore == "string" ? e.autoCloseBefore : Hf.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_BRACKETS, this._surroundingPairs = e.surroundingPairs || this._autoClosingPairs;
  }
  getAutoClosingPairs() {
    return this._autoClosingPairs;
  }
  getAutoCloseBeforeSet(e) {
    return e ? this._autoCloseBeforeForQuotes : this._autoCloseBeforeForBrackets;
  }
  getSurroundingPairs() {
    return this._surroundingPairs;
  }
}
Hf.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_QUOTES = `;:.,=}])> 
	`;
Hf.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_BRACKETS = `'"\`;:.,=}])> 
	`;
function qh(r, e) {
  const t = r.getCount(), i = r.findTokenIndexAtOffset(e), n = r.getLanguageId(i);
  let s = i;
  for (; s + 1 < t && r.getLanguageId(s + 1) === n; )
    s++;
  let o = i;
  for (; o > 0 && r.getLanguageId(o - 1) === n; )
    o--;
  return new U6(r, n, o, s + 1, r.getStartOffset(o), r.getEndOffset(s));
}
class U6 {
  constructor(e, t, i, n, s, o) {
    this._scopedLineTokensBrand = void 0, this._actual = e, this.languageId = t, this._firstTokenIndex = i, this._lastTokenIndex = n, this.firstCharOffset = s, this._lastCharOffset = o, this.languageIdCodec = e.languageIdCodec;
  }
  getLineContent() {
    return this._actual.getLineContent().substring(this.firstCharOffset, this._lastCharOffset);
  }
  getLineLength() {
    return this._lastCharOffset - this.firstCharOffset;
  }
  getActualLineContentBefore(e) {
    return this._actual.getLineContent().substring(0, this.firstCharOffset + e);
  }
  getTokenCount() {
    return this._lastTokenIndex - this._firstTokenIndex;
  }
  findTokenIndexAtOffset(e) {
    return this._actual.findTokenIndexAtOffset(e + this.firstCharOffset) - this._firstTokenIndex;
  }
  getStandardTokenType(e) {
    return this._actual.getStandardTokenType(e + this._firstTokenIndex);
  }
  toIViewLineTokens() {
    return this._actual.sliceAndInflate(this.firstCharOffset, this._lastCharOffset, 0);
  }
}
function wa(r) {
  return (r & 3) !== 0;
}
const PA = typeof Buffer < "u";
let OD;
class b0 {
  /**
   * When running in a nodejs context, if `actual` is not a nodejs Buffer, the backing store for
   * the returned `VSBuffer` instance might use a nodejs Buffer allocated from node's Buffer pool,
   * which is not transferrable.
   */
  static wrap(e) {
    return PA && !Buffer.isBuffer(e) && (e = Buffer.from(e.buffer, e.byteOffset, e.byteLength)), new b0(e);
  }
  constructor(e) {
    this.buffer = e, this.byteLength = this.buffer.byteLength;
  }
  toString() {
    return PA ? this.buffer.toString() : (OD || (OD = new TextDecoder()), OD.decode(this.buffer));
  }
}
function $6(r, e) {
  return r[e + 0] << 0 >>> 0 | r[e + 1] << 8 >>> 0;
}
function K6(r, e, t) {
  r[t + 0] = e & 255, e = e >>> 8, r[t + 1] = e & 255;
}
function Ir(r, e) {
  return r[e] * 2 ** 24 + r[e + 1] * 2 ** 16 + r[e + 2] * 2 ** 8 + r[e + 3];
}
function Er(r, e, t) {
  r[t + 3] = e, e = e >>> 8, r[t + 2] = e, e = e >>> 8, r[t + 1] = e, e = e >>> 8, r[t] = e;
}
function OA(r, e) {
  return r[e];
}
function FA(r, e, t) {
  r[t] = e;
}
let FD;
function rV() {
  return FD || (FD = new TextDecoder("UTF-16LE")), FD;
}
let WD;
function j6() {
  return WD || (WD = new TextDecoder("UTF-16BE")), WD;
}
let BD;
function aV() {
  return BD || (BD = KB() ? rV() : j6()), BD;
}
function q6(r, e, t) {
  const i = new Uint16Array(r.buffer, e, t);
  return t > 0 && (i[0] === 65279 || i[0] === 65534) ? G6(r, e, t) : rV().decode(i);
}
function G6(r, e, t) {
  const i = [];
  let n = 0;
  for (let s = 0; s < t; s++) {
    const o = $6(r, e);
    e += 2, i[n++] = String.fromCharCode(o);
  }
  return i.join("");
}
class Tp {
  constructor(e) {
    this._capacity = e | 0, this._buffer = new Uint16Array(this._capacity), this._completedStrings = null, this._bufferLength = 0;
  }
  reset() {
    this._completedStrings = null, this._bufferLength = 0;
  }
  build() {
    return this._completedStrings !== null ? (this._flushBuffer(), this._completedStrings.join("")) : this._buildBuffer();
  }
  _buildBuffer() {
    if (this._bufferLength === 0)
      return "";
    const e = new Uint16Array(this._buffer.buffer, 0, this._bufferLength);
    return aV().decode(e);
  }
  _flushBuffer() {
    const e = this._buildBuffer();
    this._bufferLength = 0, this._completedStrings === null ? this._completedStrings = [e] : this._completedStrings[this._completedStrings.length] = e;
  }
  /**
   * Append a char code (<2^16)
   */
  appendCharCode(e) {
    const t = this._capacity - this._bufferLength;
    t <= 1 && (t === 0 || $n(e)) && this._flushBuffer(), this._buffer[this._bufferLength++] = e;
  }
  /**
   * Append an ASCII char code (<2^8)
   */
  appendASCIICharCode(e) {
    this._bufferLength === this._capacity && this._flushBuffer(), this._buffer[this._bufferLength++] = e;
  }
  appendString(e) {
    const t = e.length;
    if (this._bufferLength + t >= this._capacity) {
      this._flushBuffer(), this._completedStrings[this._completedStrings.length] = e;
      return;
    }
    for (let i = 0; i < t; i++)
      this._buffer[this._bufferLength++] = e.charCodeAt(i);
  }
}
class pS {
  constructor(e, t, i, n, s, o) {
    this._richEditBracketBrand = void 0, this.languageId = e, this.index = t, this.open = i, this.close = n, this.forwardRegex = s, this.reversedRegex = o, this._openSet = pS._toSet(this.open), this._closeSet = pS._toSet(this.close);
  }
  /**
   * Check if the provided `text` is an open bracket in this group.
   */
  isOpen(e) {
    return this._openSet.has(e);
  }
  /**
   * Check if the provided `text` is a close bracket in this group.
   */
  isClose(e) {
    return this._closeSet.has(e);
  }
  static _toSet(e) {
    const t = /* @__PURE__ */ new Set();
    for (const i of e)
      t.add(i);
    return t;
  }
}
function Z6(r) {
  const e = r.length;
  r = r.map((o) => [o[0].toLowerCase(), o[1].toLowerCase()]);
  const t = [];
  for (let o = 0; o < e; o++)
    t[o] = o;
  const i = (o, a) => {
    const [l, d] = o, [c, h] = a;
    return l === c || l === h || d === c || d === h;
  }, n = (o, a) => {
    const l = Math.min(o, a), d = Math.max(o, a);
    for (let c = 0; c < e; c++)
      t[c] === d && (t[c] = l);
  };
  for (let o = 0; o < e; o++) {
    const a = r[o];
    for (let l = o + 1; l < e; l++) {
      const d = r[l];
      i(a, d) && n(t[o], t[l]);
    }
  }
  const s = [];
  for (let o = 0; o < e; o++) {
    const a = [], l = [];
    for (let d = 0; d < e; d++)
      if (t[d] === o) {
        const [c, h] = r[d];
        a.push(c), l.push(h);
      }
    a.length > 0 && s.push({
      open: a,
      close: l
    });
  }
  return s;
}
class Y6 {
  constructor(e, t) {
    this._richEditBracketsBrand = void 0;
    const i = Z6(t);
    this.brackets = i.map((n, s) => new pS(e, s, n.open, n.close, Q6(n.open, n.close, i, s), X6(n.open, n.close, i, s))), this.forwardRegex = J6(this.brackets), this.reversedRegex = eq(this.brackets), this.textIsBracket = {}, this.textIsOpenBracket = {}, this.maxBracketLength = 0;
    for (const n of this.brackets) {
      for (const s of n.open)
        this.textIsBracket[s] = n, this.textIsOpenBracket[s] = !0, this.maxBracketLength = Math.max(this.maxBracketLength, s.length);
      for (const s of n.close)
        this.textIsBracket[s] = n, this.textIsOpenBracket[s] = !1, this.maxBracketLength = Math.max(this.maxBracketLength, s.length);
    }
  }
}
function lV(r, e, t, i) {
  for (let n = 0, s = e.length; n < s; n++) {
    if (n === t)
      continue;
    const o = e[n];
    for (const a of o.open)
      a.indexOf(r) >= 0 && i.push(a);
    for (const a of o.close)
      a.indexOf(r) >= 0 && i.push(a);
  }
}
function dV(r, e) {
  return r.length - e.length;
}
function C0(r) {
  if (r.length <= 1)
    return r;
  const e = [], t = /* @__PURE__ */ new Set();
  for (const i of r)
    t.has(i) || (e.push(i), t.add(i));
  return e;
}
function Q6(r, e, t, i) {
  let n = [];
  n = n.concat(r), n = n.concat(e);
  for (let s = 0, o = n.length; s < o; s++)
    lV(n[s], t, i, n);
  return n = C0(n), n.sort(dV), n.reverse(), db(n);
}
function X6(r, e, t, i) {
  let n = [];
  n = n.concat(r), n = n.concat(e);
  for (let s = 0, o = n.length; s < o; s++)
    lV(n[s], t, i, n);
  return n = C0(n), n.sort(dV), n.reverse(), db(n.map(c1));
}
function J6(r) {
  let e = [];
  for (const t of r) {
    for (const i of t.open)
      e.push(i);
    for (const i of t.close)
      e.push(i);
  }
  return e = C0(e), db(e);
}
function eq(r) {
  let e = [];
  for (const t of r) {
    for (const i of t.open)
      e.push(i);
    for (const i of t.close)
      e.push(i);
  }
  return e = C0(e), db(e.map(c1));
}
function tq(r) {
  const e = /^[\w ]+$/.test(r);
  return r = gr(r), e ? `\\b${r}\\b` : r;
}
function db(r, e) {
  const t = `(${r.map(tq).join(")|(")})`;
  return r5(t, !0, e);
}
const c1 = /* @__PURE__ */ function() {
  function r(i) {
    const n = new Uint16Array(i.length);
    let s = 0;
    for (let o = i.length - 1; o >= 0; o--)
      n[s++] = i.charCodeAt(o);
    return aV().decode(n);
  }
  let e = null, t = null;
  return function(n) {
    return e !== n && (e = n, t = r(e)), t;
  };
}();
class Qo {
  static _findPrevBracketInText(e, t, i, n) {
    const s = i.match(e);
    if (!s)
      return null;
    const o = i.length - (s.index || 0), a = s[0].length, l = n + o;
    return new L(t, l - a + 1, t, l + 1);
  }
  static findPrevBracketInRange(e, t, i, n, s) {
    const a = c1(i).substring(i.length - s, i.length - n);
    return this._findPrevBracketInText(e, t, a, n);
  }
  static findNextBracketInText(e, t, i, n) {
    const s = i.match(e);
    if (!s)
      return null;
    const o = s.index || 0, a = s[0].length;
    if (a === 0)
      return null;
    const l = n + o;
    return new L(t, l + 1, t, l + 1 + a);
  }
  static findNextBracketInRange(e, t, i, n, s) {
    const o = i.substring(n, s);
    return this.findNextBracketInText(e, t, o, n);
  }
}
class iq {
  constructor(e) {
    this._richEditBrackets = e;
  }
  getElectricCharacters() {
    const e = [];
    if (this._richEditBrackets)
      for (const t of this._richEditBrackets.brackets)
        for (const i of t.close) {
          const n = i.charAt(i.length - 1);
          e.push(n);
        }
    return rd(e);
  }
  onElectricCharacter(e, t, i) {
    if (!this._richEditBrackets || this._richEditBrackets.brackets.length === 0)
      return null;
    const n = t.findTokenIndexAtOffset(i - 1);
    if (wa(t.getStandardTokenType(n)))
      return null;
    const s = this._richEditBrackets.reversedRegex, o = t.getLineContent().substring(0, i - 1) + e, a = Qo.findPrevBracketInRange(s, 1, o, 0, o.length);
    if (!a)
      return null;
    const l = o.substring(a.startColumn - 1, a.endColumn - 1).toLowerCase();
    if (this._richEditBrackets.textIsOpenBracket[l])
      return null;
    const c = t.getActualLineContentBefore(a.startColumn - 1);
    return /^\s*$/.test(c) ? {
      matchOpenBracket: l
    } : null;
  }
}
function rC(r) {
  return r.global && (r.lastIndex = 0), !0;
}
class nq {
  constructor(e) {
    this._indentationRules = e;
  }
  shouldIncrease(e) {
    return !!(this._indentationRules && this._indentationRules.increaseIndentPattern && rC(this._indentationRules.increaseIndentPattern) && this._indentationRules.increaseIndentPattern.test(e));
  }
  shouldDecrease(e) {
    return !!(this._indentationRules && this._indentationRules.decreaseIndentPattern && rC(this._indentationRules.decreaseIndentPattern) && this._indentationRules.decreaseIndentPattern.test(e));
  }
  shouldIndentNextLine(e) {
    return !!(this._indentationRules && this._indentationRules.indentNextLinePattern && rC(this._indentationRules.indentNextLinePattern) && this._indentationRules.indentNextLinePattern.test(e));
  }
  shouldIgnore(e) {
    return !!(this._indentationRules && this._indentationRules.unIndentedLinePattern && rC(this._indentationRules.unIndentedLinePattern) && this._indentationRules.unIndentedLinePattern.test(e));
  }
  getIndentMetadata(e) {
    let t = 0;
    return this.shouldIncrease(e) && (t += 1), this.shouldDecrease(e) && (t += 2), this.shouldIndentNextLine(e) && (t += 4), this.shouldIgnore(e) && (t += 8), t;
  }
}
class zg {
  constructor(e) {
    e = e || {}, e.brackets = e.brackets || [
      ["(", ")"],
      ["{", "}"],
      ["[", "]"]
    ], this._brackets = [], e.brackets.forEach((t) => {
      const i = zg._createOpenBracketRegExp(t[0]), n = zg._createCloseBracketRegExp(t[1]);
      i && n && this._brackets.push({
        open: t[0],
        openRegExp: i,
        close: t[1],
        closeRegExp: n
      });
    }), this._regExpRules = e.onEnterRules || [];
  }
  onEnter(e, t, i, n) {
    if (e >= 3)
      for (let s = 0, o = this._regExpRules.length; s < o; s++) {
        const a = this._regExpRules[s];
        if ([{
          reg: a.beforeText,
          text: i
        }, {
          reg: a.afterText,
          text: n
        }, {
          reg: a.previousLineText,
          text: t
        }].every((d) => d.reg ? (d.reg.lastIndex = 0, d.reg.test(d.text)) : !0))
          return a.action;
      }
    if (e >= 2 && i.length > 0 && n.length > 0)
      for (let s = 0, o = this._brackets.length; s < o; s++) {
        const a = this._brackets[s];
        if (a.openRegExp.test(i) && a.closeRegExp.test(n))
          return { indentAction: Mi.IndentOutdent };
      }
    if (e >= 2 && i.length > 0) {
      for (let s = 0, o = this._brackets.length; s < o; s++)
        if (this._brackets[s].openRegExp.test(i))
          return { indentAction: Mi.Indent };
    }
    return null;
  }
  static _createOpenBracketRegExp(e) {
    let t = gr(e);
    return /\B/.test(t.charAt(0)) || (t = "\\b" + t), t += "\\s*$", zg._safeRegExp(t);
  }
  static _createCloseBracketRegExp(e) {
    let t = gr(e);
    return /\B/.test(t.charAt(t.length - 1)) || (t = t + "\\b"), t = "^\\s*" + t, zg._safeRegExp(t);
  }
  static _safeRegExp(e) {
    try {
      return new RegExp(e);
    } catch (t) {
      return He(t), null;
    }
  }
}
const Ge = et("configurationService");
function Px(r, e) {
  const t = /* @__PURE__ */ Object.create(null);
  for (const i in r)
    cV(t, i, r[i], e);
  return t;
}
function cV(r, e, t, i) {
  const n = e.split("."), s = n.pop();
  let o = r;
  for (let a = 0; a < n.length; a++) {
    const l = n[a];
    let d = o[l];
    switch (typeof d) {
      case "undefined":
        d = o[l] = /* @__PURE__ */ Object.create(null);
        break;
      case "object":
        if (d === null) {
          i(`Ignoring ${e} as ${n.slice(0, a + 1).join(".")} is null`);
          return;
        }
        break;
      default:
        i(`Ignoring ${e} as ${n.slice(0, a + 1).join(".")} is ${JSON.stringify(d)}`);
        return;
    }
    o = d;
  }
  if (typeof o == "object" && o !== null)
    try {
      o[s] = t;
    } catch {
      i(`Ignoring ${e} as ${n.join(".")} is ${JSON.stringify(o)}`);
    }
  else
    i(`Ignoring ${e} as ${n.join(".")} is ${JSON.stringify(o)}`);
}
function sq(r, e) {
  const t = e.split(".");
  hV(r, t);
}
function hV(r, e) {
  const t = e.shift();
  if (e.length === 0) {
    delete r[t];
    return;
  }
  if (Object.keys(r).indexOf(t) !== -1) {
    const i = r[t];
    typeof i == "object" && !Array.isArray(i) && (hV(i, e), Object.keys(i).length === 0 && delete r[t]);
  }
}
function WA(r, e, t) {
  function i(o, a) {
    let l = o;
    for (const d of a) {
      if (typeof l != "object" || l === null)
        return;
      l = l[d];
    }
    return l;
  }
  const n = e.split("."), s = i(r, n);
  return typeof s > "u" ? t : s;
}
function oq(r) {
  return r.replace(/[\[\]]/g, "");
}
const Jt = et("languageService");
class Ia {
  constructor(e, t = [], i = !1) {
    this.ctor = e, this.staticArguments = t, this.supportsDelayedInstantiation = i;
  }
}
const uV = [];
function ot(r, e, t) {
  e instanceof Ia || (e = new Ia(e, [], !!t)), uV.push([r, e]);
}
function BA() {
  return uV;
}
const fi = Object.freeze({
  text: "text/plain",
  binary: "application/octet-stream",
  unknown: "application/unknown",
  markdown: "text/markdown",
  latex: "text/latex",
  uriList: "text/uri-list"
}), w0 = {
  JSONContribution: "base.contributions.json"
};
function rq(r) {
  return r.length > 0 && r.charAt(r.length - 1) === "#" ? r.substring(0, r.length - 1) : r;
}
class aq {
  constructor() {
    this._onDidChangeSchema = new R(), this.schemasById = {};
  }
  registerSchema(e, t) {
    this.schemasById[rq(e)] = t, this._onDidChangeSchema.fire(e);
  }
  notifySchemaChanged(e) {
    this._onDidChangeSchema.fire(e);
  }
}
const lq = new aq();
si.add(w0.JSONContribution, lq);
const aa = {
  Configuration: "base.contributions.configuration"
}, Jp = "vscode://schemas/settings/resourceLanguage", HA = si.as(w0.JSONContribution);
class dq {
  constructor() {
    this.overrideIdentifiers = /* @__PURE__ */ new Set(), this._onDidSchemaChange = new R(), this._onDidUpdateConfiguration = new R(), this.configurationDefaultsOverrides = /* @__PURE__ */ new Map(), this.defaultLanguageConfigurationOverridesNode = {
      id: "defaultOverrides",
      title: p("defaultLanguageConfigurationOverrides.title", "Default Language Configuration Overrides"),
      properties: {}
    }, this.configurationContributors = [this.defaultLanguageConfigurationOverridesNode], this.resourceLanguageSettingsSchema = {
      properties: {},
      patternProperties: {},
      additionalProperties: !0,
      allowTrailingCommas: !0,
      allowComments: !0
    }, this.configurationProperties = {}, this.policyConfigurations = /* @__PURE__ */ new Map(), this.excludedConfigurationProperties = {}, HA.registerSchema(Jp, this.resourceLanguageSettingsSchema), this.registerOverridePropertyPatternKey();
  }
  registerConfiguration(e, t = !0) {
    this.registerConfigurations([e], t);
  }
  registerConfigurations(e, t = !0) {
    const i = /* @__PURE__ */ new Set();
    this.doRegisterConfigurations(e, t, i), HA.registerSchema(Jp, this.resourceLanguageSettingsSchema), this._onDidSchemaChange.fire(), this._onDidUpdateConfiguration.fire({ properties: i });
  }
  registerDefaultConfigurations(e) {
    const t = /* @__PURE__ */ new Set();
    this.doRegisterDefaultConfigurations(e, t), this._onDidSchemaChange.fire(), this._onDidUpdateConfiguration.fire({ properties: t, defaultsOverrides: !0 });
  }
  doRegisterDefaultConfigurations(e, t) {
    var i;
    const n = [];
    for (const { overrides: s, source: o } of e)
      for (const a in s)
        if (t.add(a), Ac.test(a)) {
          const l = this.configurationDefaultsOverrides.get(a), d = (i = l == null ? void 0 : l.valuesSources) !== null && i !== void 0 ? i : /* @__PURE__ */ new Map();
          if (o)
            for (const g of Object.keys(s[a]))
              d.set(g, o);
          const c = { ...(l == null ? void 0 : l.value) || {}, ...s[a] };
          this.configurationDefaultsOverrides.set(a, { source: o, value: c, valuesSources: d });
          const h = oq(a), u = {
            type: "object",
            default: c,
            description: p("defaultLanguageConfiguration.description", "Configure settings to be overridden for the {0} language.", h),
            $ref: Jp,
            defaultDefaultValue: c,
            source: Ws(o) ? void 0 : o,
            defaultValueSource: o
          };
          n.push(...mS(a)), this.configurationProperties[a] = u, this.defaultLanguageConfigurationOverridesNode.properties[a] = u;
        } else {
          this.configurationDefaultsOverrides.set(a, { value: s[a], source: o });
          const l = this.configurationProperties[a];
          l && (this.updatePropertyDefaultValue(a, l), this.updateSchema(a, l));
        }
    this.doRegisterOverrideIdentifiers(n);
  }
  registerOverrideIdentifiers(e) {
    this.doRegisterOverrideIdentifiers(e), this._onDidSchemaChange.fire();
  }
  doRegisterOverrideIdentifiers(e) {
    for (const t of e)
      this.overrideIdentifiers.add(t);
    this.updateOverridePropertyPatternKey();
  }
  doRegisterConfigurations(e, t, i) {
    e.forEach((n) => {
      this.validateAndRegisterProperties(n, t, n.extensionInfo, n.restrictedProperties, void 0, i), this.configurationContributors.push(n), this.registerJSONConfiguration(n);
    });
  }
  validateAndRegisterProperties(e, t = !0, i, n, s = 3, o) {
    var a;
    s = Ma(e.scope) ? s : e.scope;
    const l = e.properties;
    if (l)
      for (const c in l) {
        const h = l[c];
        if (t && uq(c, h)) {
          delete l[c];
          continue;
        }
        if (h.source = i, h.defaultDefaultValue = l[c].default, this.updatePropertyDefaultValue(c, h), Ac.test(c) ? h.scope = void 0 : (h.scope = Ma(h.scope) ? s : h.scope, h.restricted = Ma(h.restricted) ? !!(n != null && n.includes(c)) : h.restricted), l[c].hasOwnProperty("included") && !l[c].included) {
          this.excludedConfigurationProperties[c] = l[c], delete l[c];
          continue;
        } else
          this.configurationProperties[c] = l[c], !((a = l[c].policy) === null || a === void 0) && a.name && this.policyConfigurations.set(l[c].policy.name, c);
        !l[c].deprecationMessage && l[c].markdownDeprecationMessage && (l[c].deprecationMessage = l[c].markdownDeprecationMessage), o.add(c);
      }
    const d = e.allOf;
    if (d)
      for (const c of d)
        this.validateAndRegisterProperties(c, t, i, n, s, o);
  }
  getConfigurationProperties() {
    return this.configurationProperties;
  }
  getPolicyConfigurations() {
    return this.policyConfigurations;
  }
  registerJSONConfiguration(e) {
    const t = (i) => {
      const n = i.properties;
      if (n)
        for (const o in n)
          this.updateSchema(o, n[o]);
      const s = i.allOf;
      s == null || s.forEach(t);
    };
    t(e);
  }
  updateSchema(e, t) {
    switch (t.scope) {
      case 1:
        break;
      case 2:
        break;
      case 6:
        break;
      case 3:
        break;
      case 4:
        break;
      case 5:
        this.resourceLanguageSettingsSchema.properties[e] = t;
        break;
    }
  }
  updateOverridePropertyPatternKey() {
    for (const e of this.overrideIdentifiers.values()) {
      const t = `[${e}]`, i = {
        type: "object",
        description: p("overrideSettings.defaultDescription", "Configure editor settings to be overridden for a language."),
        errorMessage: p("overrideSettings.errorMessage", "This setting does not support per-language configuration."),
        $ref: Jp
      };
      this.updatePropertyDefaultValue(t, i);
    }
  }
  registerOverridePropertyPatternKey() {
    p("overrideSettings.defaultDescription", "Configure editor settings to be overridden for a language."), p("overrideSettings.errorMessage", "This setting does not support per-language configuration."), this._onDidSchemaChange.fire();
  }
  updatePropertyDefaultValue(e, t) {
    const i = this.configurationDefaultsOverrides.get(e);
    let n = i == null ? void 0 : i.value, s = i == null ? void 0 : i.source;
    Fs(n) && (n = t.defaultDefaultValue, s = void 0), Fs(n) && (n = hq(t.type)), t.default = n, t.defaultValueSource = s;
  }
}
const gV = "\\[([^\\]]+)\\]", VA = new RegExp(gV, "g"), cq = `^(${gV})+$`, Ac = new RegExp(cq);
function mS(r) {
  const e = [];
  if (Ac.test(r)) {
    let t = VA.exec(r);
    for (; t != null && t.length; ) {
      const i = t[1].trim();
      i && e.push(i), t = VA.exec(r);
    }
  }
  return rd(e);
}
function hq(r) {
  switch (Array.isArray(r) ? r[0] : r) {
    case "boolean":
      return !1;
    case "integer":
    case "number":
      return 0;
    case "string":
      return "";
    case "array":
      return [];
    case "object":
      return {};
    default:
      return null;
  }
}
const Iw = new dq();
si.add(aa.Configuration, Iw);
function uq(r, e) {
  var t, i, n, s;
  return r.trim() ? Ac.test(r) ? p("config.property.languageDefault", "Cannot register '{0}'. This matches property pattern '\\\\[.*\\\\]$' for describing language specific editor settings. Use 'configurationDefaults' contribution.", r) : Iw.getConfigurationProperties()[r] !== void 0 ? p("config.property.duplicate", "Cannot register '{0}'. This property is already registered.", r) : !((t = e.policy) === null || t === void 0) && t.name && Iw.getPolicyConfigurations().get((i = e.policy) === null || i === void 0 ? void 0 : i.name) !== void 0 ? p("config.policy.duplicate", "Cannot register '{0}'. The associated policy {1} is already registered with {2}.", r, (n = e.policy) === null || n === void 0 ? void 0 : n.name, Iw.getPolicyConfigurations().get((s = e.policy) === null || s === void 0 ? void 0 : s.name)) : null : p("config.property.empty", "Cannot register an empty property");
}
const gq = {
  ModesRegistry: "editor.modesRegistry"
};
class fq {
  constructor() {
    this._onDidChangeLanguages = new R(), this.onDidChangeLanguages = this._onDidChangeLanguages.event, this._languages = [];
  }
  registerLanguage(e) {
    return this._languages.push(e), this._onDidChangeLanguages.fire(void 0), {
      dispose: () => {
        for (let t = 0, i = this._languages.length; t < i; t++)
          if (this._languages[t] === e) {
            this._languages.splice(t, 1);
            return;
          }
      }
    };
  }
  getLanguages() {
    return this._languages;
  }
}
const Vf = new fq();
si.add(gq.ModesRegistry, Vf);
const go = "plaintext", pq = ".txt";
Vf.registerLanguage({
  id: go,
  extensions: [pq],
  aliases: [p("plainText.alias", "Plain Text"), "text"],
  mimetypes: [fi.text]
});
si.as(aa.Configuration).registerDefaultConfigurations([{
  overrides: {
    "[plaintext]": {
      "editor.unicodeHighlight.ambiguousCharacters": !1,
      "editor.unicodeHighlight.invisibleCharacters": !1
    }
  }
}]);
class mq {
  constructor(e, t) {
    this.languageId = e;
    const i = t.brackets ? zA(t.brackets) : [], n = new XR((a) => {
      const l = /* @__PURE__ */ new Set();
      return {
        info: new _q(this, a, l),
        closing: l
      };
    }), s = new XR((a) => {
      const l = /* @__PURE__ */ new Set(), d = /* @__PURE__ */ new Set();
      return {
        info: new vq(this, a, l, d),
        opening: l,
        openingColorized: d
      };
    });
    for (const [a, l] of i) {
      const d = n.get(a), c = s.get(l);
      d.closing.add(c.info), c.opening.add(d.info);
    }
    const o = t.colorizedBracketPairs ? zA(t.colorizedBracketPairs) : i.filter((a) => !(a[0] === "<" && a[1] === ">"));
    for (const [a, l] of o) {
      const d = n.get(a), c = s.get(l);
      d.closing.add(c.info), c.openingColorized.add(d.info), c.opening.add(d.info);
    }
    this._openingBrackets = new Map([...n.cachedValues].map(([a, l]) => [a, l.info])), this._closingBrackets = new Map([...s.cachedValues].map(([a, l]) => [a, l.info]));
  }
  /**
   * No two brackets have the same bracket text.
  */
  get openingBrackets() {
    return [...this._openingBrackets.values()];
  }
  /**
   * No two brackets have the same bracket text.
  */
  get closingBrackets() {
    return [...this._closingBrackets.values()];
  }
  getOpeningBracketInfo(e) {
    return this._openingBrackets.get(e);
  }
  getClosingBracketInfo(e) {
    return this._closingBrackets.get(e);
  }
  getBracketInfo(e) {
    return this.getOpeningBracketInfo(e) || this.getClosingBracketInfo(e);
  }
  getBracketRegExp(e) {
    const t = Array.from([...this._openingBrackets.keys(), ...this._closingBrackets.keys()]);
    return db(t, e);
  }
}
function zA(r) {
  return r.filter(([e, t]) => e !== "" && t !== "");
}
class fV {
  constructor(e, t) {
    this.config = e, this.bracketText = t;
  }
  get languageId() {
    return this.config.languageId;
  }
}
class _q extends fV {
  constructor(e, t, i) {
    super(e, t), this.openedBrackets = i, this.isOpeningBracket = !0;
  }
}
class vq extends fV {
  constructor(e, t, i, n) {
    super(e, t), this.openingBrackets = i, this.openingColorizedBrackets = n, this.isOpeningBracket = !1;
  }
  /**
   * Checks if this bracket closes the given other bracket.
   * If the bracket infos come from different configurations, this method will return false.
  */
  closes(e) {
    return e.config !== this.config ? !1 : this.openingBrackets.has(e);
  }
  closesColorized(e) {
    return e.config !== this.config ? !1 : this.openingColorizedBrackets.has(e);
  }
  getOpeningBrackets() {
    return [...this.openingBrackets];
  }
}
var bq = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, UA = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
class HD {
  constructor(e) {
    this.languageId = e;
  }
  affects(e) {
    return this.languageId ? this.languageId === e : !0;
  }
}
const Ot = et("languageConfigurationService");
let Ox = class extends P {
  constructor(e, t) {
    super(), this.configurationService = e, this.languageService = t, this._registry = this._register(new yq()), this.onDidChangeEmitter = this._register(new R()), this.onDidChange = this.onDidChangeEmitter.event, this.configurations = /* @__PURE__ */ new Map();
    const i = new Set(Object.values(Fx));
    this._register(this.configurationService.onDidChangeConfiguration((n) => {
      const s = n.change.keys.some((a) => i.has(a)), o = n.change.overrides.filter(([a, l]) => l.some((d) => i.has(d))).map(([a]) => a);
      if (s)
        this.configurations.clear(), this.onDidChangeEmitter.fire(new HD(void 0));
      else
        for (const a of o)
          this.languageService.isRegisteredLanguageId(a) && (this.configurations.delete(a), this.onDidChangeEmitter.fire(new HD(a)));
    })), this._register(this._registry.onDidChange((n) => {
      this.configurations.delete(n.languageId), this.onDidChangeEmitter.fire(new HD(n.languageId));
    }));
  }
  register(e, t, i) {
    return this._registry.register(e, t, i);
  }
  getLanguageConfiguration(e) {
    let t = this.configurations.get(e);
    return t || (t = Cq(e, this._registry, this.configurationService, this.languageService), this.configurations.set(e, t)), t;
  }
};
Ox = bq([
  UA(0, Ge),
  UA(1, Jt)
], Ox);
function Cq(r, e, t, i) {
  let n = e.getLanguageConfiguration(r);
  if (!n) {
    if (!i.isRegisteredLanguageId(r))
      return new pf(r, {});
    n = new pf(r, {});
  }
  const s = wq(n.languageId, t), o = mV([n.underlyingConfig, s]);
  return new pf(n.languageId, o);
}
const Fx = {
  brackets: "editor.language.brackets",
  colorizedBracketPairs: "editor.language.colorizedBracketPairs"
};
function wq(r, e) {
  const t = e.getValue(Fx.brackets, {
    overrideIdentifier: r
  }), i = e.getValue(Fx.colorizedBracketPairs, {
    overrideIdentifier: r
  });
  return {
    brackets: $A(t),
    colorizedBracketPairs: $A(i)
  };
}
function $A(r) {
  if (Array.isArray(r))
    return r.map((e) => {
      if (!(!Array.isArray(e) || e.length !== 2))
        return [e[0], e[1]];
    }).filter((e) => !!e);
}
function pV(r, e, t) {
  const i = r.getLineContent(e);
  let n = Tt(i);
  return n.length > t - 1 && (n = n.substring(0, t - 1)), n;
}
class Sq {
  constructor(e) {
    this.languageId = e, this._resolved = null, this._entries = [], this._order = 0, this._resolved = null;
  }
  register(e, t) {
    const i = new KA(e, t, ++this._order);
    return this._entries.push(i), this._resolved = null, Se(() => {
      for (let n = 0; n < this._entries.length; n++)
        if (this._entries[n] === i) {
          this._entries.splice(n, 1), this._resolved = null;
          break;
        }
    });
  }
  getResolvedConfiguration() {
    if (!this._resolved) {
      const e = this._resolve();
      e && (this._resolved = new pf(this.languageId, e));
    }
    return this._resolved;
  }
  _resolve() {
    return this._entries.length === 0 ? null : (this._entries.sort(KA.cmp), mV(this._entries.map((e) => e.configuration)));
  }
}
function mV(r) {
  let e = {
    comments: void 0,
    brackets: void 0,
    wordPattern: void 0,
    indentationRules: void 0,
    onEnterRules: void 0,
    autoClosingPairs: void 0,
    surroundingPairs: void 0,
    autoCloseBefore: void 0,
    folding: void 0,
    colorizedBracketPairs: void 0,
    __electricCharacterSupport: void 0
  };
  for (const t of r)
    e = {
      comments: t.comments || e.comments,
      brackets: t.brackets || e.brackets,
      wordPattern: t.wordPattern || e.wordPattern,
      indentationRules: t.indentationRules || e.indentationRules,
      onEnterRules: t.onEnterRules || e.onEnterRules,
      autoClosingPairs: t.autoClosingPairs || e.autoClosingPairs,
      surroundingPairs: t.surroundingPairs || e.surroundingPairs,
      autoCloseBefore: t.autoCloseBefore || e.autoCloseBefore,
      folding: t.folding || e.folding,
      colorizedBracketPairs: t.colorizedBracketPairs || e.colorizedBracketPairs,
      __electricCharacterSupport: t.__electricCharacterSupport || e.__electricCharacterSupport
    };
  return e;
}
class KA {
  constructor(e, t, i) {
    this.configuration = e, this.priority = t, this.order = i;
  }
  static cmp(e, t) {
    return e.priority === t.priority ? e.order - t.order : e.priority - t.priority;
  }
}
class jA {
  constructor(e) {
    this.languageId = e;
  }
}
class yq extends P {
  constructor() {
    super(), this._entries = /* @__PURE__ */ new Map(), this._onDidChange = this._register(new R()), this.onDidChange = this._onDidChange.event, this._register(this.register(go, {
      brackets: [
        ["(", ")"],
        ["[", "]"],
        ["{", "}"]
      ],
      surroundingPairs: [
        { open: "{", close: "}" },
        { open: "[", close: "]" },
        { open: "(", close: ")" },
        { open: "<", close: ">" },
        { open: '"', close: '"' },
        { open: "'", close: "'" },
        { open: "`", close: "`" }
      ],
      colorizedBracketPairs: [],
      folding: {
        offSide: !0
      }
    }, 0));
  }
  /**
   * @param priority Use a higher number for higher priority
   */
  register(e, t, i = 0) {
    let n = this._entries.get(e);
    n || (n = new Sq(e), this._entries.set(e, n));
    const s = n.register(t, i);
    return this._onDidChange.fire(new jA(e)), Se(() => {
      s.dispose(), this._onDidChange.fire(new jA(e));
    });
  }
  getLanguageConfiguration(e) {
    const t = this._entries.get(e);
    return (t == null ? void 0 : t.getResolvedConfiguration()) || null;
  }
}
class pf {
  constructor(e, t) {
    this.languageId = e, this.underlyingConfig = t, this._brackets = null, this._electricCharacter = null, this._onEnterSupport = this.underlyingConfig.brackets || this.underlyingConfig.indentationRules || this.underlyingConfig.onEnterRules ? new zg(this.underlyingConfig) : null, this.comments = pf._handleComments(this.underlyingConfig), this.characterPair = new Hf(this.underlyingConfig), this.wordDefinition = this.underlyingConfig.wordPattern || a5, this.indentationRules = this.underlyingConfig.indentationRules, this.underlyingConfig.indentationRules ? this.indentRulesSupport = new nq(this.underlyingConfig.indentationRules) : this.indentRulesSupport = null, this.foldingRules = this.underlyingConfig.folding || {}, this.bracketsNew = new mq(e, this.underlyingConfig);
  }
  getWordDefinition() {
    return l5(this.wordDefinition);
  }
  get brackets() {
    return !this._brackets && this.underlyingConfig.brackets && (this._brackets = new Y6(this.languageId, this.underlyingConfig.brackets)), this._brackets;
  }
  get electricCharacter() {
    return this._electricCharacter || (this._electricCharacter = new iq(this.brackets)), this._electricCharacter;
  }
  onEnter(e, t, i, n) {
    return this._onEnterSupport ? this._onEnterSupport.onEnter(e, t, i, n) : null;
  }
  getAutoClosingPairs() {
    return new z6(this.characterPair.getAutoClosingPairs());
  }
  getAutoCloseBeforeSet(e) {
    return this.characterPair.getAutoCloseBeforeSet(e);
  }
  getSurroundingPairs() {
    return this.characterPair.getSurroundingPairs();
  }
  static _handleComments(e) {
    const t = e.comments;
    if (!t)
      return null;
    const i = {};
    if (t.lineComment && (i.lineCommentToken = t.lineComment), t.blockComment) {
      const [n, s] = t.blockComment;
      i.blockCommentStartToken = n, i.blockCommentEndToken = s;
    }
    return i;
  }
}
ot(
  Ot,
  Ox,
  1
  /* InstantiationType.Delayed */
);
const h1 = et("textResourceConfigurationService"), _V = et("textResourcePropertiesService"), he = et("ILanguageFeaturesService");
var Lq = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, em = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
const qA = 60 * 1e3, GA = 5 * 60 * 1e3;
function Fh(r, e) {
  const t = r.getModel(e);
  return !(!t || t.isTooLargeForSyncing());
}
let Wx = class extends P {
  constructor(e, t, i, n, s) {
    super(), this._modelService = e, this._workerManager = this._register(new kq(this._modelService, n)), this._logService = i, this._register(s.linkProvider.register({ language: "*", hasAccessToAllModels: !0 }, {
      provideLinks: (o, a) => Fh(this._modelService, o.uri) ? this._workerManager.withWorker().then((l) => l.computeLinks(o.uri)).then((l) => l && { links: l }) : Promise.resolve({ links: [] })
    })), this._register(s.completionProvider.register("*", new Dq(this._workerManager, t, this._modelService, n)));
  }
  dispose() {
    super.dispose();
  }
  canComputeUnicodeHighlights(e) {
    return Fh(this._modelService, e);
  }
  computedUnicodeHighlights(e, t, i) {
    return this._workerManager.withWorker().then((n) => n.computedUnicodeHighlights(e, t, i));
  }
  async computeDiff(e, t, i, n) {
    const s = await this._workerManager.withWorker().then((l) => l.computeDiff(e, t, i, n));
    if (!s)
      return null;
    return {
      identical: s.identical,
      quitEarly: s.quitEarly,
      changes: a(s.changes),
      moves: s.moves.map((l) => new d5(new cf(new Yt(l[0], l[1]), new Yt(l[2], l[3])), a(l[4])))
    };
    function a(l) {
      return l.map((d) => {
        var c;
        return new nb(new Yt(d[0], d[1]), new Yt(d[2], d[3]), (c = d[4]) === null || c === void 0 ? void 0 : c.map((h) => new VN(new L(h[0], h[1], h[2], h[3]), new L(h[4], h[5], h[6], h[7]))));
      });
    }
  }
  computeMoreMinimalEdits(e, t, i = !1) {
    if (Rn(t)) {
      if (!Fh(this._modelService, e))
        return Promise.resolve(t);
      const n = rs.create(), s = this._workerManager.withWorker().then((o) => o.computeMoreMinimalEdits(e, t, i));
      return s.finally(() => this._logService.trace("FORMAT#computeMoreMinimalEdits", e.toString(!0), n.elapsed())), Promise.race([s, cd(1e3).then(() => t)]);
    } else
      return Promise.resolve(void 0);
  }
  canNavigateValueSet(e) {
    return Fh(this._modelService, e);
  }
  navigateValueSet(e, t, i) {
    return this._workerManager.withWorker().then((n) => n.navigateValueSet(e, t, i));
  }
  canComputeWordRanges(e) {
    return Fh(this._modelService, e);
  }
  computeWordRanges(e, t) {
    return this._workerManager.withWorker().then((i) => i.computeWordRanges(e, t));
  }
  findSectionHeaders(e, t) {
    return this._workerManager.withWorker().then((i) => i.findSectionHeaders(e, t));
  }
};
Wx = Lq([
  em(0, ii),
  em(1, h1),
  em(2, Pn),
  em(3, Ot),
  em(4, he)
], Wx);
class Dq {
  constructor(e, t, i, n) {
    this.languageConfigurationService = n, this._debugDisplayName = "wordbasedCompletions", this._workerManager = e, this._configurationService = t, this._modelService = i;
  }
  async provideCompletionItems(e, t) {
    const i = this._configurationService.getValue(e.uri, t, "editor");
    if (i.wordBasedSuggestions === "off")
      return;
    const n = [];
    if (i.wordBasedSuggestions === "currentDocument")
      Fh(this._modelService, e.uri) && n.push(e.uri);
    else
      for (const h of this._modelService.getModels())
        Fh(this._modelService, h.uri) && (h === e ? n.unshift(h.uri) : (i.wordBasedSuggestions === "allDocuments" || h.getLanguageId() === e.getLanguageId()) && n.push(h.uri));
    if (n.length === 0)
      return;
    const s = this.languageConfigurationService.getLanguageConfiguration(e.getLanguageId()).getWordDefinition(), o = e.getWordAtPosition(t), a = o ? new L(t.lineNumber, o.startColumn, t.lineNumber, o.endColumn) : L.fromPositions(t), l = a.setEndPosition(t.lineNumber, t.column), c = await (await this._workerManager.withWorker()).textualSuggest(n, o == null ? void 0 : o.word, s);
    if (c)
      return {
        duration: c.duration,
        suggestions: c.words.map((h) => ({
          kind: 18,
          label: h,
          insertText: h,
          range: { insert: l, replace: a }
        }))
      };
  }
}
class kq extends P {
  constructor(e, t) {
    super(), this.languageConfigurationService = t, this._modelService = e, this._editorWorkerClient = null, this._lastWorkerUsedTime = (/* @__PURE__ */ new Date()).getTime(), this._register(new n1()).cancelAndSet(() => this._checkStopIdleWorker(), Math.round(GA / 2), Dt), this._register(this._modelService.onModelRemoved((n) => this._checkStopEmptyWorker()));
  }
  dispose() {
    this._editorWorkerClient && (this._editorWorkerClient.dispose(), this._editorWorkerClient = null), super.dispose();
  }
  /**
   * Check if the model service has no more models and stop the worker if that is the case.
   */
  _checkStopEmptyWorker() {
    if (!this._editorWorkerClient)
      return;
    this._modelService.getModels().length === 0 && (this._editorWorkerClient.dispose(), this._editorWorkerClient = null);
  }
  /**
   * Check if the worker has been idle for a while and then stop it.
   */
  _checkStopIdleWorker() {
    if (!this._editorWorkerClient)
      return;
    (/* @__PURE__ */ new Date()).getTime() - this._lastWorkerUsedTime > GA && (this._editorWorkerClient.dispose(), this._editorWorkerClient = null);
  }
  withWorker() {
    return this._lastWorkerUsedTime = (/* @__PURE__ */ new Date()).getTime(), this._editorWorkerClient || (this._editorWorkerClient = new u1(this._modelService, !1, "editorWorkerService", this.languageConfigurationService)), Promise.resolve(this._editorWorkerClient);
  }
}
class xq extends P {
  constructor(e, t, i) {
    if (super(), this._syncedModels = /* @__PURE__ */ Object.create(null), this._syncedModelsLastUsedTime = /* @__PURE__ */ Object.create(null), this._proxy = e, this._modelService = t, !i) {
      const n = new t1();
      n.cancelAndSet(() => this._checkStopModelSync(), Math.round(qA / 2)), this._register(n);
    }
  }
  dispose() {
    for (const e in this._syncedModels)
      zt(this._syncedModels[e]);
    this._syncedModels = /* @__PURE__ */ Object.create(null), this._syncedModelsLastUsedTime = /* @__PURE__ */ Object.create(null), super.dispose();
  }
  ensureSyncedResources(e, t) {
    for (const i of e) {
      const n = i.toString();
      this._syncedModels[n] || this._beginModelSync(i, t), this._syncedModels[n] && (this._syncedModelsLastUsedTime[n] = (/* @__PURE__ */ new Date()).getTime());
    }
  }
  _checkStopModelSync() {
    const e = (/* @__PURE__ */ new Date()).getTime(), t = [];
    for (const i in this._syncedModelsLastUsedTime)
      e - this._syncedModelsLastUsedTime[i] > qA && t.push(i);
    for (const i of t)
      this._stopModelSync(i);
  }
  _beginModelSync(e, t) {
    const i = this._modelService.getModel(e);
    if (!i || !t && i.isTooLargeForSyncing())
      return;
    const n = e.toString();
    this._proxy.acceptNewModel({
      url: i.uri.toString(),
      lines: i.getLinesContent(),
      EOL: i.getEOL(),
      versionId: i.getVersionId()
    });
    const s = new q();
    s.add(i.onDidChangeContent((o) => {
      this._proxy.acceptModelChanged(n.toString(), o);
    })), s.add(i.onWillDispose(() => {
      this._stopModelSync(n);
    })), s.add(Se(() => {
      this._proxy.acceptRemovedModel(n);
    })), this._syncedModels[n] = s;
  }
  _stopModelSync(e) {
    const t = this._syncedModels[e];
    delete this._syncedModels[e], delete this._syncedModelsLastUsedTime[e], zt(t);
  }
}
class ZA {
  constructor(e) {
    this._instance = e, this._proxyObj = Promise.resolve(this._instance);
  }
  dispose() {
    this._instance.dispose();
  }
  getProxyObject() {
    return this._proxyObj;
  }
}
class VD {
  constructor(e) {
    this._workerClient = e;
  }
  // foreign host request
  fhr(e, t) {
    return this._workerClient.fhr(e, t);
  }
}
class u1 extends P {
  constructor(e, t, i, n) {
    super(), this.languageConfigurationService = n, this._disposed = !1, this._modelService = e, this._keepIdleModels = t, this._workerFactory = new v0(i), this._worker = null, this._modelManager = null;
  }
  // foreign host request
  fhr(e, t) {
    throw new Error("Not implemented!");
  }
  _getOrCreateWorker() {
    if (!this._worker)
      try {
        this._worker = this._register(new c5(this._workerFactory, "vs/editor/common/services/editorSimpleWorker", new VD(this)));
      } catch (e) {
        _x(e), this._worker = new ZA(new JR(new VD(this), null));
      }
    return this._worker;
  }
  _getProxy() {
    return this._getOrCreateWorker().getProxyObject().then(void 0, (e) => (_x(e), this._worker = new ZA(new JR(new VD(this), null)), this._getOrCreateWorker().getProxyObject()));
  }
  _getOrCreateModelManager(e) {
    return this._modelManager || (this._modelManager = this._register(new xq(e, this._modelService, this._keepIdleModels))), this._modelManager;
  }
  async _withSyncedResources(e, t = !1) {
    return this._disposed ? Promise.reject(h5()) : this._getProxy().then((i) => (this._getOrCreateModelManager(i).ensureSyncedResources(e, t), i));
  }
  computedUnicodeHighlights(e, t, i) {
    return this._withSyncedResources([e]).then((n) => n.computeUnicodeHighlights(e.toString(), t, i));
  }
  computeDiff(e, t, i, n) {
    return this._withSyncedResources(
      [e, t],
      /* forceLargeModels */
      !0
    ).then((s) => s.computeDiff(e.toString(), t.toString(), i, n));
  }
  computeMoreMinimalEdits(e, t, i) {
    return this._withSyncedResources([e]).then((n) => n.computeMoreMinimalEdits(e.toString(), t, i));
  }
  computeLinks(e) {
    return this._withSyncedResources([e]).then((t) => t.computeLinks(e.toString()));
  }
  computeDefaultDocumentColors(e) {
    return this._withSyncedResources([e]).then((t) => t.computeDefaultDocumentColors(e.toString()));
  }
  async textualSuggest(e, t, i) {
    const n = await this._withSyncedResources(e), s = i.source, o = i.flags;
    return n.textualSuggest(e.map((a) => a.toString()), t, s, o);
  }
  computeWordRanges(e, t) {
    return this._withSyncedResources([e]).then((i) => {
      const n = this._modelService.getModel(e);
      if (!n)
        return Promise.resolve(null);
      const s = this.languageConfigurationService.getLanguageConfiguration(n.getLanguageId()).getWordDefinition(), o = s.source, a = s.flags;
      return i.computeWordRanges(e.toString(), t, o, a);
    });
  }
  navigateValueSet(e, t, i) {
    return this._withSyncedResources([e]).then((n) => {
      const s = this._modelService.getModel(e);
      if (!s)
        return null;
      const o = this.languageConfigurationService.getLanguageConfiguration(s.getLanguageId()).getWordDefinition(), a = o.source, l = o.flags;
      return n.navigateValueSet(e.toString(), t, i, a, l);
    });
  }
  findSectionHeaders(e, t) {
    return this._withSyncedResources([e]).then((i) => i.findSectionHeaders(e.toString(), t));
  }
  dispose() {
    super.dispose(), this._disposed = !0;
  }
}
function Iq(r, e, t) {
  return new Eq(r, e, t);
}
class Eq extends u1 {
  constructor(e, t, i) {
    super(e, i.keepIdleModels || !1, i.label, t), this._foreignModuleId = i.moduleId, this._foreignModuleCreateData = i.createData || null, this._foreignModuleHost = i.host || null, this._foreignProxy = null;
  }
  // foreign host request
  fhr(e, t) {
    if (!this._foreignModuleHost || typeof this._foreignModuleHost[e] != "function")
      return Promise.reject(new Error("Missing method " + e + " or missing main thread foreign host."));
    try {
      return Promise.resolve(this._foreignModuleHost[e].apply(this._foreignModuleHost, t));
    } catch (i) {
      return Promise.reject(i);
    }
  }
  _getForeignProxy() {
    return this._foreignProxy || (this._foreignProxy = this._getProxy().then((e) => {
      const t = this._foreignModuleHost ? u5(this._foreignModuleHost) : [];
      return e.loadForeignModule(this._foreignModuleId, this._foreignModuleCreateData, t).then((i) => {
        this._foreignModuleCreateData = null;
        const n = (a, l) => e.fmr(a, l), s = (a, l) => function() {
          const d = Array.prototype.slice.call(arguments, 0);
          return l(a, d);
        }, o = {};
        for (const a of i)
          o[a] = s(a, n);
        return o;
      });
    })), this._foreignProxy;
  }
  getProxy() {
    return this._getForeignProxy();
  }
  withSyncedResources(e) {
    return this._withSyncedResources(e).then((t) => this.getProxy());
  }
}
const cb = {
  ICodeEditor: "vs.editor.ICodeEditor",
  IDiffEditor: "vs.editor.IDiffEditor"
}, zf = new class {
  clone() {
    return this;
  }
  equals(r) {
    return this === r;
  }
}();
function g1(r, e) {
  return new zN([new oS(0, "", r)], e);
}
function S0(r, e) {
  const t = new Uint32Array(2);
  return t[0] = 0, t[1] = (r << 0 | 0 | 0 | 32768 | 2 << 24) >>> 0, new Jy(t, e === null ? zf : e);
}
class yn {
  static getLanguageId(e) {
    return (e & 255) >>> 0;
  }
  static getTokenType(e) {
    return (e & 768) >>> 8;
  }
  static containsBalancedBrackets(e) {
    return (e & 1024) !== 0;
  }
  static getFontStyle(e) {
    return (e & 30720) >>> 11;
  }
  static getForeground(e) {
    return (e & 16744448) >>> 15;
  }
  static getBackground(e) {
    return (e & 4278190080) >>> 24;
  }
  static getClassNameFromMetadata(e) {
    let i = "mtk" + this.getForeground(e);
    const n = this.getFontStyle(e);
    return n & 1 && (i += " mtki"), n & 2 && (i += " mtkb"), n & 4 && (i += " mtku"), n & 8 && (i += " mtks"), i;
  }
  static getInlineStyleFromMetadata(e, t) {
    const i = this.getForeground(e), n = this.getFontStyle(e);
    let s = `color: ${t[i]};`;
    n & 1 && (s += "font-style: italic;"), n & 2 && (s += "font-weight: bold;");
    let o = "";
    return n & 4 && (o += " underline"), n & 8 && (o += " line-through"), o && (s += `text-decoration:${o};`), s;
  }
  static getPresentationFromMetadata(e) {
    const t = this.getForeground(e), i = this.getFontStyle(e);
    return {
      foreground: t,
      italic: !!(i & 1),
      bold: !!(i & 2),
      underline: !!(i & 4),
      strikethrough: !!(i & 8)
    };
  }
}
class Ri {
  static createEmpty(e, t) {
    const i = Ri.defaultTokenMetadata, n = new Uint32Array(2);
    return n[0] = e.length, n[1] = i, new Ri(n, e, t);
  }
  static createFromTextAndMetadata(e, t) {
    let i = 0, n = "";
    const s = new Array();
    for (const { text: o, metadata: a } of e)
      s.push(i + o.length, a), i += o.length, n += o;
    return new Ri(new Uint32Array(s), n, t);
  }
  constructor(e, t, i) {
    this._lineTokensBrand = void 0, this._tokens = e, this._tokensCount = this._tokens.length >>> 1, this._text = t, this.languageIdCodec = i;
  }
  equals(e) {
    return e instanceof Ri ? this.slicedEquals(e, 0, this._tokensCount) : !1;
  }
  slicedEquals(e, t, i) {
    if (this._text !== e._text || this._tokensCount !== e._tokensCount)
      return !1;
    const n = t << 1, s = n + (i << 1);
    for (let o = n; o < s; o++)
      if (this._tokens[o] !== e._tokens[o])
        return !1;
    return !0;
  }
  getLineContent() {
    return this._text;
  }
  getCount() {
    return this._tokensCount;
  }
  getStartOffset(e) {
    return e > 0 ? this._tokens[e - 1 << 1] : 0;
  }
  getMetadata(e) {
    return this._tokens[(e << 1) + 1];
  }
  getLanguageId(e) {
    const t = this._tokens[(e << 1) + 1], i = yn.getLanguageId(t);
    return this.languageIdCodec.decodeLanguageId(i);
  }
  getStandardTokenType(e) {
    const t = this._tokens[(e << 1) + 1];
    return yn.getTokenType(t);
  }
  getForeground(e) {
    const t = this._tokens[(e << 1) + 1];
    return yn.getForeground(t);
  }
  getClassName(e) {
    const t = this._tokens[(e << 1) + 1];
    return yn.getClassNameFromMetadata(t);
  }
  getInlineStyle(e, t) {
    const i = this._tokens[(e << 1) + 1];
    return yn.getInlineStyleFromMetadata(i, t);
  }
  getPresentation(e) {
    const t = this._tokens[(e << 1) + 1];
    return yn.getPresentationFromMetadata(t);
  }
  getEndOffset(e) {
    return this._tokens[e << 1];
  }
  /**
   * Find the token containing offset `offset`.
   * @param offset The search offset
   * @return The index of the token containing the offset.
   */
  findTokenIndexAtOffset(e) {
    return Ri.findIndexInTokensArray(this._tokens, e);
  }
  inflate() {
    return this;
  }
  sliceAndInflate(e, t, i) {
    return new f1(this, e, t, i);
  }
  static convertToEndOffset(e, t) {
    const n = (e.length >>> 1) - 1;
    for (let s = 0; s < n; s++)
      e[s << 1] = e[s + 1 << 1];
    e[n << 1] = t;
  }
  static findIndexInTokensArray(e, t) {
    if (e.length <= 2)
      return 0;
    let i = 0, n = (e.length >>> 1) - 1;
    for (; i < n; ) {
      const s = i + Math.floor((n - i) / 2), o = e[s << 1];
      if (o === t)
        return s + 1;
      o < t ? i = s + 1 : o > t && (n = s);
    }
    return i;
  }
  /**
   * @pure
   * @param insertTokens Must be sorted by offset.
  */
  withInserted(e) {
    if (e.length === 0)
      return this;
    let t = 0, i = 0, n = "";
    const s = new Array();
    let o = 0;
    for (; ; ) {
      const a = t < this._tokensCount ? this._tokens[t << 1] : -1, l = i < e.length ? e[i] : null;
      if (a !== -1 && (l === null || a <= l.offset)) {
        n += this._text.substring(o, a);
        const d = this._tokens[(t << 1) + 1];
        s.push(n.length, d), t++, o = a;
      } else if (l) {
        if (l.offset > o) {
          n += this._text.substring(o, l.offset);
          const d = this._tokens[(t << 1) + 1];
          s.push(n.length, d), o = l.offset;
        }
        n += l.text, s.push(n.length, l.tokenMetadata), i++;
      } else
        break;
    }
    return new Ri(new Uint32Array(s), n, this.languageIdCodec);
  }
  getTokenText(e) {
    const t = this.getStartOffset(e), i = this.getEndOffset(e);
    return this._text.substring(t, i);
  }
  forEach(e) {
    const t = this.getCount();
    for (let i = 0; i < t; i++)
      e(i);
  }
}
Ri.defaultTokenMetadata = (32768 | 2 << 24) >>> 0;
class f1 {
  constructor(e, t, i, n) {
    this._source = e, this._startOffset = t, this._endOffset = i, this._deltaOffset = n, this._firstTokenIndex = e.findTokenIndexAtOffset(t), this.languageIdCodec = e.languageIdCodec, this._tokensCount = 0;
    for (let s = this._firstTokenIndex, o = e.getCount(); s < o && !(e.getStartOffset(s) >= i); s++)
      this._tokensCount++;
  }
  getMetadata(e) {
    return this._source.getMetadata(this._firstTokenIndex + e);
  }
  getLanguageId(e) {
    return this._source.getLanguageId(this._firstTokenIndex + e);
  }
  getLineContent() {
    return this._source.getLineContent().substring(this._startOffset, this._endOffset);
  }
  equals(e) {
    return e instanceof f1 ? this._startOffset === e._startOffset && this._endOffset === e._endOffset && this._deltaOffset === e._deltaOffset && this._source.slicedEquals(e._source, this._firstTokenIndex, this._tokensCount) : !1;
  }
  getCount() {
    return this._tokensCount;
  }
  getStandardTokenType(e) {
    return this._source.getStandardTokenType(this._firstTokenIndex + e);
  }
  getForeground(e) {
    return this._source.getForeground(this._firstTokenIndex + e);
  }
  getEndOffset(e) {
    const t = this._source.getEndOffset(this._firstTokenIndex + e);
    return Math.min(this._endOffset, t) - this._startOffset + this._deltaOffset;
  }
  getClassName(e) {
    return this._source.getClassName(this._firstTokenIndex + e);
  }
  getInlineStyle(e, t) {
    return this._source.getInlineStyle(this._firstTokenIndex + e, t);
  }
  getPresentation(e) {
    return this._source.getPresentation(this._firstTokenIndex + e);
  }
  findTokenIndexAtOffset(e) {
    return this._source.findTokenIndexAtOffset(e + this._startOffset - this._deltaOffset) - this._firstTokenIndex;
  }
  getTokenText(e) {
    const t = this._firstTokenIndex + e, i = this._source.getStartOffset(t), n = this._source.getEndOffset(t);
    let s = this._source.getTokenText(t);
    return i < this._startOffset && (s = s.substring(this._startOffset - i)), n > this._endOffset && (s = s.substring(0, s.length - (n - this._endOffset))), s;
  }
  forEach(e) {
    for (let t = 0; t < this.getCount(); t++)
      e(t);
  }
}
function Tq(r, e) {
  const t = e.lineNumber;
  if (!r.tokenization.isCheapToTokenize(t))
    return;
  r.tokenization.forceTokenization(t);
  const i = r.tokenization.getLineTokens(t), n = i.findTokenIndexAtOffset(e.column - 1);
  return i.getStandardTokenType(n);
}
class ts {
  constructor(e, t, i, n) {
    this.startColumn = e, this.endColumn = t, this.className = i, this.type = n, this._lineDecorationBrand = void 0;
  }
  static _equals(e, t) {
    return e.startColumn === t.startColumn && e.endColumn === t.endColumn && e.className === t.className && e.type === t.type;
  }
  static equalsArr(e, t) {
    const i = e.length, n = t.length;
    if (i !== n)
      return !1;
    for (let s = 0; s < i; s++)
      if (!ts._equals(e[s], t[s]))
        return !1;
    return !0;
  }
  static extractWrapped(e, t, i) {
    if (e.length === 0)
      return e;
    const n = t + 1, s = i + 1, o = i - t, a = [];
    let l = 0;
    for (const d of e)
      d.endColumn <= n || d.startColumn >= s || (a[l++] = new ts(Math.max(1, d.startColumn - n + 1), Math.min(o + 1, d.endColumn - n + 1), d.className, d.type));
    return a;
  }
  static filter(e, t, i, n) {
    if (e.length === 0)
      return [];
    const s = [];
    let o = 0;
    for (let a = 0, l = e.length; a < l; a++) {
      const d = e[a], c = d.range;
      if (c.endLineNumber < t || c.startLineNumber > t || c.isEmpty() && (d.type === 0 || d.type === 3))
        continue;
      const h = c.startLineNumber === t ? c.startColumn : i, u = c.endLineNumber === t ? c.endColumn : n;
      s[o++] = new ts(h, u, d.inlineClassName, d.type);
    }
    return s;
  }
  static _typeCompare(e, t) {
    const i = [2, 0, 1, 3];
    return i[e] - i[t];
  }
  static compare(e, t) {
    if (e.startColumn !== t.startColumn)
      return e.startColumn - t.startColumn;
    if (e.endColumn !== t.endColumn)
      return e.endColumn - t.endColumn;
    const i = ts._typeCompare(e.type, t.type);
    return i !== 0 ? i : e.className !== t.className ? e.className < t.className ? -1 : 1 : 0;
  }
}
class YA {
  constructor(e, t, i, n) {
    this.startOffset = e, this.endOffset = t, this.className = i, this.metadata = n;
  }
}
class _S {
  constructor() {
    this.stopOffsets = [], this.classNames = [], this.metadata = [], this.count = 0;
  }
  static _metadata(e) {
    let t = 0;
    for (let i = 0, n = e.length; i < n; i++)
      t |= e[i];
    return t;
  }
  consumeLowerThan(e, t, i) {
    for (; this.count > 0 && this.stopOffsets[0] < e; ) {
      let n = 0;
      for (; n + 1 < this.count && this.stopOffsets[n] === this.stopOffsets[n + 1]; )
        n++;
      i.push(new YA(t, this.stopOffsets[n], this.classNames.join(" "), _S._metadata(this.metadata))), t = this.stopOffsets[n] + 1, this.stopOffsets.splice(0, n + 1), this.classNames.splice(0, n + 1), this.metadata.splice(0, n + 1), this.count -= n + 1;
    }
    return this.count > 0 && t < e && (i.push(new YA(t, e - 1, this.classNames.join(" "), _S._metadata(this.metadata))), t = e), t;
  }
  insert(e, t, i) {
    if (this.count === 0 || this.stopOffsets[this.count - 1] <= e)
      this.stopOffsets.push(e), this.classNames.push(t), this.metadata.push(i);
    else
      for (let n = 0; n < this.count; n++)
        if (this.stopOffsets[n] >= e) {
          this.stopOffsets.splice(n, 0, e), this.classNames.splice(n, 0, t), this.metadata.splice(n, 0, i);
          break;
        }
    this.count++;
  }
}
class Nq {
  /**
   * Normalize line decorations. Overlapping decorations will generate multiple segments
   */
  static normalize(e, t) {
    if (t.length === 0)
      return [];
    const i = [], n = new _S();
    let s = 0;
    for (let o = 0, a = t.length; o < a; o++) {
      const l = t[o];
      let d = l.startColumn, c = l.endColumn;
      const h = l.className, u = l.type === 1 ? 2 : l.type === 2 ? 4 : 0;
      if (d > 1) {
        const m = e.charCodeAt(d - 2);
        $n(m) && d--;
      }
      if (c > 1) {
        const m = e.charCodeAt(c - 2);
        $n(m) && c--;
      }
      const g = d - 1, f = c - 2;
      s = n.consumeLowerThan(g, s, i), n.count === 0 && (s = g), n.insert(f, h, u);
    }
    return n.consumeLowerThan(1073741824, s, i), i;
  }
}
class nn {
  constructor(e, t, i, n) {
    this.endIndex = e, this.type = t, this.metadata = i, this.containsRTL = n, this._linePartBrand = void 0;
  }
  isWhitespace() {
    return !!(this.metadata & 1);
  }
  isPseudoAfter() {
    return !!(this.metadata & 4);
  }
}
class vV {
  constructor(e, t) {
    this.startOffset = e, this.endOffset = t;
  }
  equals(e) {
    return this.startOffset === e.startOffset && this.endOffset === e.endOffset;
  }
}
class th {
  constructor(e, t, i, n, s, o, a, l, d, c, h, u, g, f, m, _, v, b, C) {
    this.useMonospaceOptimizations = e, this.canUseHalfwidthRightwardsArrow = t, this.lineContent = i, this.continuesWithWrappedLine = n, this.isBasicASCII = s, this.containsRTL = o, this.fauxIndentLength = a, this.lineTokens = l, this.lineDecorations = d.sort(ts.compare), this.tabSize = c, this.startVisibleColumn = h, this.spaceWidth = u, this.stopRenderingLineAfter = m, this.renderWhitespace = _ === "all" ? 4 : _ === "boundary" ? 1 : _ === "selection" ? 2 : _ === "trailing" ? 3 : 0, this.renderControlCharacters = v, this.fontLigatures = b, this.selectionsOnLine = C && C.sort((y, k) => y.startOffset < k.startOffset ? -1 : 1);
    const w = Math.abs(f - u), S = Math.abs(g - u);
    w < S ? (this.renderSpaceWidth = f, this.renderSpaceCharCode = 11825) : (this.renderSpaceWidth = g, this.renderSpaceCharCode = 183);
  }
  sameSelection(e) {
    if (this.selectionsOnLine === null)
      return e === null;
    if (e === null || e.length !== this.selectionsOnLine.length)
      return !1;
    for (let t = 0; t < this.selectionsOnLine.length; t++)
      if (!this.selectionsOnLine[t].equals(e[t]))
        return !1;
    return !0;
  }
  equals(e) {
    return this.useMonospaceOptimizations === e.useMonospaceOptimizations && this.canUseHalfwidthRightwardsArrow === e.canUseHalfwidthRightwardsArrow && this.lineContent === e.lineContent && this.continuesWithWrappedLine === e.continuesWithWrappedLine && this.isBasicASCII === e.isBasicASCII && this.containsRTL === e.containsRTL && this.fauxIndentLength === e.fauxIndentLength && this.tabSize === e.tabSize && this.startVisibleColumn === e.startVisibleColumn && this.spaceWidth === e.spaceWidth && this.renderSpaceWidth === e.renderSpaceWidth && this.renderSpaceCharCode === e.renderSpaceCharCode && this.stopRenderingLineAfter === e.stopRenderingLineAfter && this.renderWhitespace === e.renderWhitespace && this.renderControlCharacters === e.renderControlCharacters && this.fontLigatures === e.fontLigatures && ts.equalsArr(this.lineDecorations, e.lineDecorations) && this.lineTokens.equals(e.lineTokens) && this.sameSelection(e.selectionsOnLine);
  }
}
class bV {
  constructor(e, t) {
    this.partIndex = e, this.charIndex = t;
  }
}
class Ea {
  static getPartIndex(e) {
    return (e & 4294901760) >>> 16;
  }
  static getCharIndex(e) {
    return (e & 65535) >>> 0;
  }
  constructor(e, t) {
    this.length = e, this._data = new Uint32Array(this.length), this._horizontalOffset = new Uint32Array(this.length);
  }
  setColumnInfo(e, t, i, n) {
    const s = (t << 16 | i << 0) >>> 0;
    this._data[e - 1] = s, this._horizontalOffset[e - 1] = n;
  }
  getHorizontalOffset(e) {
    return this._horizontalOffset.length === 0 ? 0 : this._horizontalOffset[e - 1];
  }
  charOffsetToPartData(e) {
    return this.length === 0 ? 0 : e < 0 ? this._data[0] : e >= this.length ? this._data[this.length - 1] : this._data[e];
  }
  getDomPosition(e) {
    const t = this.charOffsetToPartData(e - 1), i = Ea.getPartIndex(t), n = Ea.getCharIndex(t);
    return new bV(i, n);
  }
  getColumn(e, t) {
    return this.partDataToCharOffset(e.partIndex, t, e.charIndex) + 1;
  }
  partDataToCharOffset(e, t, i) {
    if (this.length === 0)
      return 0;
    const n = (e << 16 | i << 0) >>> 0;
    let s = 0, o = this.length - 1;
    for (; s + 1 < o; ) {
      const m = s + o >>> 1, _ = this._data[m];
      if (_ === n)
        return m;
      _ > n ? o = m : s = m;
    }
    if (s === o)
      return s;
    const a = this._data[s], l = this._data[o];
    if (a === n)
      return s;
    if (l === n)
      return o;
    const d = Ea.getPartIndex(a), c = Ea.getCharIndex(a), h = Ea.getPartIndex(l);
    let u;
    d !== h ? u = t : u = Ea.getCharIndex(l);
    const g = i - c, f = u - i;
    return g <= f ? s : o;
  }
}
class Bx {
  constructor(e, t, i) {
    this._renderLineOutputBrand = void 0, this.characterMapping = e, this.containsRTL = t, this.containsForeignElements = i;
  }
}
function hb(r, e) {
  if (r.lineContent.length === 0) {
    if (r.lineDecorations.length > 0) {
      e.appendString("<span>");
      let t = 0, i = 0, n = 0;
      for (const o of r.lineDecorations)
        (o.type === 1 || o.type === 2) && (e.appendString('<span class="'), e.appendString(o.className), e.appendString('"></span>'), o.type === 1 && (n |= 1, t++), o.type === 2 && (n |= 2, i++));
      e.appendString("</span>");
      const s = new Ea(1, t + i);
      return s.setColumnInfo(1, t, 0, 0), new Bx(s, !1, n);
    }
    return e.appendString("<span><span></span></span>"), new Bx(
      new Ea(0, 0),
      !1,
      0
      /* ForeignElementType.None */
    );
  }
  return Hq(Aq(r), e);
}
class Mq {
  constructor(e, t, i, n) {
    this.characterMapping = e, this.html = t, this.containsRTL = i, this.containsForeignElements = n;
  }
}
function y0(r) {
  const e = new Tp(1e4), t = hb(r, e);
  return new Mq(t.characterMapping, e.build(), t.containsRTL, t.containsForeignElements);
}
class Rq {
  constructor(e, t, i, n, s, o, a, l, d, c, h, u, g, f, m, _) {
    this.fontIsMonospace = e, this.canUseHalfwidthRightwardsArrow = t, this.lineContent = i, this.len = n, this.isOverflowing = s, this.overflowingCharCount = o, this.parts = a, this.containsForeignElements = l, this.fauxIndentLength = d, this.tabSize = c, this.startVisibleColumn = h, this.containsRTL = u, this.spaceWidth = g, this.renderSpaceCharCode = f, this.renderWhitespace = m, this.renderControlCharacters = _;
  }
}
function Aq(r) {
  const e = r.lineContent;
  let t, i, n;
  r.stopRenderingLineAfter !== -1 && r.stopRenderingLineAfter < e.length ? (t = !0, i = e.length - r.stopRenderingLineAfter, n = r.stopRenderingLineAfter) : (t = !1, i = 0, n = e.length);
  let s = Pq(e, r.containsRTL, r.lineTokens, r.fauxIndentLength, n);
  r.renderControlCharacters && !r.isBasicASCII && (s = Fq(e, s)), (r.renderWhitespace === 4 || r.renderWhitespace === 1 || r.renderWhitespace === 2 && r.selectionsOnLine || r.renderWhitespace === 3 && !r.continuesWithWrappedLine) && (s = Wq(r, e, n, s));
  let o = 0;
  if (r.lineDecorations.length > 0) {
    for (let a = 0, l = r.lineDecorations.length; a < l; a++) {
      const d = r.lineDecorations[a];
      d.type === 3 || d.type === 1 ? o |= 1 : d.type === 2 && (o |= 2);
    }
    s = Bq(e, n, s, r.lineDecorations);
  }
  return r.containsRTL || (s = Oq(e, s, !r.isBasicASCII || r.fontLigatures)), new Rq(r.useMonospaceOptimizations, r.canUseHalfwidthRightwardsArrow, e, n, t, i, s, o, r.fauxIndentLength, r.tabSize, r.startVisibleColumn, r.containsRTL, r.spaceWidth, r.renderSpaceCharCode, r.renderWhitespace, r.renderControlCharacters);
}
function Pq(r, e, t, i, n) {
  const s = [];
  let o = 0;
  i > 0 && (s[o++] = new nn(i, "", 0, !1));
  let a = i;
  for (let l = 0, d = t.getCount(); l < d; l++) {
    const c = t.getEndOffset(l);
    if (c <= i)
      continue;
    const h = t.getClassName(l);
    if (c >= n) {
      const g = e ? Of(r.substring(a, n)) : !1;
      s[o++] = new nn(n, h, 0, g);
      break;
    }
    const u = e ? Of(r.substring(a, c)) : !1;
    s[o++] = new nn(c, h, 0, u), a = c;
  }
  return s;
}
function Oq(r, e, t) {
  let i = 0;
  const n = [];
  let s = 0;
  if (t)
    for (let o = 0, a = e.length; o < a; o++) {
      const l = e[o], d = l.endIndex;
      if (i + 50 < d) {
        const c = l.type, h = l.metadata, u = l.containsRTL;
        let g = -1, f = i;
        for (let m = i; m < d; m++)
          r.charCodeAt(m) === 32 && (g = m), g !== -1 && m - f >= 50 && (n[s++] = new nn(g + 1, c, h, u), f = g + 1, g = -1);
        f !== d && (n[s++] = new nn(d, c, h, u));
      } else
        n[s++] = l;
      i = d;
    }
  else
    for (let o = 0, a = e.length; o < a; o++) {
      const l = e[o], d = l.endIndex, c = d - i;
      if (c > 50) {
        const h = l.type, u = l.metadata, g = l.containsRTL, f = Math.ceil(
          c / 50
          /* Constants.LongToken */
        );
        for (let m = 1; m < f; m++) {
          const _ = i + m * 50;
          n[s++] = new nn(_, h, u, g);
        }
        n[s++] = new nn(d, h, u, g);
      } else
        n[s++] = l;
      i = d;
    }
  return n;
}
function CV(r) {
  return r < 32 ? r !== 9 : r === 127 || r >= 8234 && r <= 8238 || r >= 8294 && r <= 8297 || r >= 8206 && r <= 8207 || r === 1564;
}
function Fq(r, e) {
  const t = [];
  let i = new nn(0, "", 0, !1), n = 0;
  for (const s of e) {
    const o = s.endIndex;
    for (; n < o; n++) {
      const a = r.charCodeAt(n);
      CV(a) && (n > i.endIndex && (i = new nn(n, s.type, s.metadata, s.containsRTL), t.push(i)), i = new nn(n + 1, "mtkcontrol", s.metadata, !1), t.push(i));
    }
    n > i.endIndex && (i = new nn(o, s.type, s.metadata, s.containsRTL), t.push(i));
  }
  return t;
}
function Wq(r, e, t, i) {
  const n = r.continuesWithWrappedLine, s = r.fauxIndentLength, o = r.tabSize, a = r.startVisibleColumn, l = r.useMonospaceOptimizations, d = r.selectionsOnLine, c = r.renderWhitespace === 1, h = r.renderWhitespace === 3, u = r.renderSpaceWidth !== r.spaceWidth, g = [];
  let f = 0, m = 0, _ = i[m].type, v = i[m].containsRTL, b = i[m].endIndex;
  const C = i.length;
  let w = !1, S = ns(e), y;
  S === -1 ? (w = !0, S = t, y = t) : y = ja(e);
  let k = !1, E = 0, N = d && d[E], F = a % o;
  for (let Z = s; Z < t; Z++) {
    const H = e.charCodeAt(Z);
    N && Z >= N.endOffset && (E++, N = d && d[E]);
    let re;
    if (Z < S || Z > y)
      re = !0;
    else if (H === 9)
      re = !0;
    else if (H === 32)
      if (c)
        if (k)
          re = !0;
        else {
          const ue = Z + 1 < t ? e.charCodeAt(Z + 1) : 0;
          re = ue === 32 || ue === 9;
        }
      else
        re = !0;
    else
      re = !1;
    if (re && d && (re = !!N && N.startOffset <= Z && N.endOffset > Z), re && h && (re = w || Z > y), re && v && Z >= S && Z <= y && (re = !1), k) {
      if (!re || !l && F >= o) {
        if (u) {
          const ue = f > 0 ? g[f - 1].endIndex : s;
          for (let Ve = ue + 1; Ve <= Z; Ve++)
            g[f++] = new nn(Ve, "mtkw", 1, !1);
        } else
          g[f++] = new nn(Z, "mtkw", 1, !1);
        F = F % o;
      }
    } else
      (Z === b || re && Z > s) && (g[f++] = new nn(Z, _, 0, v), F = F % o);
    for (H === 9 ? F = o : kc(H) ? F += 2 : F++, k = re; Z === b && (m++, m < C); )
      _ = i[m].type, v = i[m].containsRTL, b = i[m].endIndex;
  }
  let V = !1;
  if (k)
    if (n && c) {
      const Z = t > 0 ? e.charCodeAt(t - 1) : 0, H = t > 1 ? e.charCodeAt(t - 2) : 0;
      Z === 32 && H !== 32 && H !== 9 || (V = !0);
    } else
      V = !0;
  if (V)
    if (u) {
      const Z = f > 0 ? g[f - 1].endIndex : s;
      for (let H = Z + 1; H <= t; H++)
        g[f++] = new nn(H, "mtkw", 1, !1);
    } else
      g[f++] = new nn(t, "mtkw", 1, !1);
  else
    g[f++] = new nn(t, _, 0, v);
  return g;
}
function Bq(r, e, t, i) {
  i.sort(ts.compare);
  const n = Nq.normalize(r, i), s = n.length;
  let o = 0;
  const a = [];
  let l = 0, d = 0;
  for (let h = 0, u = t.length; h < u; h++) {
    const g = t[h], f = g.endIndex, m = g.type, _ = g.metadata, v = g.containsRTL;
    for (; o < s && n[o].startOffset < f; ) {
      const b = n[o];
      if (b.startOffset > d && (d = b.startOffset, a[l++] = new nn(d, m, _, v)), b.endOffset + 1 <= f)
        d = b.endOffset + 1, a[l++] = new nn(d, m + " " + b.className, _ | b.metadata, v), o++;
      else {
        d = f, a[l++] = new nn(d, m + " " + b.className, _ | b.metadata, v);
        break;
      }
    }
    f > d && (d = f, a[l++] = new nn(d, m, _, v));
  }
  const c = t[t.length - 1].endIndex;
  if (o < s && n[o].startOffset === c)
    for (; o < s && n[o].startOffset === c; ) {
      const h = n[o];
      a[l++] = new nn(d, h.className, h.metadata, !1), o++;
    }
  return a;
}
function Hq(r, e) {
  const t = r.fontIsMonospace, i = r.canUseHalfwidthRightwardsArrow, n = r.containsForeignElements, s = r.lineContent, o = r.len, a = r.isOverflowing, l = r.overflowingCharCount, d = r.parts, c = r.fauxIndentLength, h = r.tabSize, u = r.startVisibleColumn, g = r.containsRTL, f = r.spaceWidth, m = r.renderSpaceCharCode, _ = r.renderWhitespace, v = r.renderControlCharacters, b = new Ea(o + 1, d.length);
  let C = !1, w = 0, S = u, y = 0, k = 0, E = 0;
  g ? e.appendString('<span dir="ltr">') : e.appendString("<span>");
  for (let N = 0, F = d.length; N < F; N++) {
    const V = d[N], Z = V.endIndex, H = V.type, re = V.containsRTL, ue = _ !== 0 && V.isWhitespace(), Ve = ue && !t && (H === "mtkw" || !n), Ye = w === Z && V.isPseudoAfter();
    if (y = 0, e.appendString("<span "), re && e.appendString('style="unicode-bidi:isolate" '), e.appendString('class="'), e.appendString(Ve ? "mtkz" : H), e.appendASCIICharCode(
      34
      /* CharCode.DoubleQuote */
    ), ue) {
      let ze = 0;
      {
        let pe = w, $e = S;
        for (; pe < Z; pe++) {
          const Te = (s.charCodeAt(pe) === 9 ? h - $e % h : 1) | 0;
          ze += Te, pe >= c && ($e += Te);
        }
      }
      for (Ve && (e.appendString(' style="width:'), e.appendString(String(f * ze)), e.appendString('px"')), e.appendASCIICharCode(
        62
        /* CharCode.GreaterThan */
      ); w < Z; w++) {
        b.setColumnInfo(w + 1, N - E, y, k), E = 0;
        const pe = s.charCodeAt(w);
        let $e, Be;
        if (pe === 9) {
          $e = h - S % h | 0, Be = $e, !i || Be > 1 ? e.appendCharCode(8594) : e.appendCharCode(65515);
          for (let Te = 2; Te <= Be; Te++)
            e.appendCharCode(160);
        } else
          $e = 2, Be = 1, e.appendCharCode(m), e.appendCharCode(8204);
        y += $e, k += Be, w >= c && (S += Be);
      }
    } else
      for (e.appendASCIICharCode(
        62
        /* CharCode.GreaterThan */
      ); w < Z; w++) {
        b.setColumnInfo(w + 1, N - E, y, k), E = 0;
        const ze = s.charCodeAt(w);
        let pe = 1, $e = 1;
        switch (ze) {
          case 9:
            pe = h - S % h, $e = pe;
            for (let Be = 1; Be <= pe; Be++)
              e.appendCharCode(160);
            break;
          case 32:
            e.appendCharCode(160);
            break;
          case 60:
            e.appendString("&lt;");
            break;
          case 62:
            e.appendString("&gt;");
            break;
          case 38:
            e.appendString("&amp;");
            break;
          case 0:
            v ? e.appendCharCode(9216) : e.appendString("&#00;");
            break;
          case 65279:
          case 8232:
          case 8233:
          case 133:
            e.appendCharCode(65533);
            break;
          default:
            kc(ze) && $e++, v && ze < 32 ? e.appendCharCode(9216 + ze) : v && ze === 127 ? e.appendCharCode(9249) : v && CV(ze) ? (e.appendString("[U+"), e.appendString(Vq(ze)), e.appendString("]"), pe = 8, $e = pe) : e.appendCharCode(ze);
        }
        y += pe, k += $e, w >= c && (S += $e);
      }
    Ye ? E++ : E = 0, w >= o && !C && V.isPseudoAfter() && (C = !0, b.setColumnInfo(w + 1, N, y, k)), e.appendString("</span>");
  }
  return C || b.setColumnInfo(o + 1, d.length - 1, y, k), a && (e.appendString('<span class="mtkoverflow">'), e.appendString(p("showMore", "Show more ({0})", zq(l))), e.appendString("</span>")), e.appendString("</span>"), new Bx(b, g, n);
}
function Vq(r) {
  return r.toString(16).toUpperCase().padStart(4, "0");
}
function zq(r) {
  return r < 1024 ? p("overflow.chars", "{0} chars", r) : r < 1024 * 1024 ? `${(r / 1024).toFixed(1)} KB` : `${(r / 1024 / 1024).toFixed(1)} MB`;
}
class QA {
  constructor(e, t, i, n) {
    this._viewportBrand = void 0, this.top = e | 0, this.left = t | 0, this.width = i | 0, this.height = n | 0;
  }
}
class Uq {
  constructor(e, t) {
    this.tabSize = e, this.data = t;
  }
}
class p1 {
  constructor(e, t, i, n, s, o, a) {
    this._viewLineDataBrand = void 0, this.content = e, this.continuesWithWrappedLine = t, this.minColumn = i, this.maxColumn = n, this.startVisibleColumn = s, this.tokens = o, this.inlineDecorations = a;
  }
}
class po {
  constructor(e, t, i, n, s, o, a, l, d, c) {
    this.minColumn = e, this.maxColumn = t, this.content = i, this.continuesWithWrappedLine = n, this.isBasicASCII = po.isBasicASCII(i, o), this.containsRTL = po.containsRTL(i, this.isBasicASCII, s), this.tokens = a, this.inlineDecorations = l, this.tabSize = d, this.startVisibleColumn = c;
  }
  static isBasicASCII(e, t) {
    return t ? e0(e) : !0;
  }
  static containsRTL(e, t, i) {
    return !t && i ? Of(e) : !1;
  }
}
class e_ {
  constructor(e, t, i) {
    this.range = e, this.inlineClassName = t, this.type = i;
  }
}
class $q {
  constructor(e, t, i, n) {
    this.startOffset = e, this.endOffset = t, this.inlineClassName = i, this.inlineClassNameAffectsLetterSpacing = n;
  }
  toInlineDecoration(e) {
    return new e_(
      new L(e, this.startOffset + 1, e, this.endOffset + 1),
      this.inlineClassName,
      this.inlineClassNameAffectsLetterSpacing ? 3 : 0
      /* InlineDecorationType.Regular */
    );
  }
}
class wV {
  constructor(e, t) {
    this._viewModelDecorationBrand = void 0, this.range = e, this.options = t;
  }
}
class W_ {
  constructor(e, t, i) {
    this.color = e, this.zIndex = t, this.data = i;
  }
  static compareByRenderingProps(e, t) {
    return e.zIndex === t.zIndex ? e.color < t.color ? -1 : e.color > t.color ? 1 : 0 : e.zIndex - t.zIndex;
  }
  static equals(e, t) {
    return e.color === t.color && e.zIndex === t.zIndex && ci(e.data, t.data);
  }
  static equalsArr(e, t) {
    return ci(e, t, W_.equals);
  }
}
function Kq(r) {
  return Array.isArray(r);
}
function jq(r) {
  return !Kq(r);
}
function SV(r) {
  return typeof r == "string";
}
function XA(r) {
  return !SV(r);
}
function Wh(r) {
  return !r;
}
function td(r, e) {
  return r.ignoreCase && e ? e.toLowerCase() : e;
}
function JA(r) {
  return r.replace(/[&<>'"_]/g, "-");
}
function qq(r, e) {
  console.log(`${r.languageId}: ${e}`);
}
function jt(r, e) {
  return new Error(`${r.languageId}: ${e}`);
}
function Kd(r, e, t, i, n) {
  const s = /\$((\$)|(#)|(\d\d?)|[sS](\d\d?)|@(\w+))/g;
  let o = null;
  return e.replace(s, function(a, l, d, c, h, u, g, f, m) {
    return Wh(d) ? Wh(c) ? !Wh(h) && h < i.length ? td(r, i[h]) : !Wh(g) && r && typeof r[g] == "string" ? r[g] : (o === null && (o = n.split("."), o.unshift(n)), !Wh(u) && u < o.length ? td(r, o[u]) : "") : td(r, t) : "$";
  });
}
function Gq(r, e, t) {
  const i = /\$[sS](\d\d?)/g;
  let n = null;
  return e.replace(i, function(s, o) {
    return n === null && (n = t.split("."), n.unshift(t)), !Wh(o) && o < n.length ? td(r, n[o]) : "";
  });
}
function aC(r, e) {
  let t = e;
  for (; t && t.length > 0; ) {
    const i = r.tokenizer[t];
    if (i)
      return i;
    const n = t.lastIndexOf(".");
    n < 0 ? t = null : t = t.substr(0, n);
  }
  return null;
}
function Zq(r, e) {
  let t = e;
  for (; t && t.length > 0; ) {
    if (r.stateNames[t])
      return !0;
    const n = t.lastIndexOf(".");
    n < 0 ? t = null : t = t.substr(0, n);
  }
  return !1;
}
var Yq = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Qq = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, Hx;
const yV = 5;
class B_ {
  static create(e, t) {
    return this._INSTANCE.create(e, t);
  }
  constructor(e) {
    this._maxCacheDepth = e, this._entries = /* @__PURE__ */ Object.create(null);
  }
  create(e, t) {
    if (e !== null && e.depth >= this._maxCacheDepth)
      return new mf(e, t);
    let i = mf.getStackElementId(e);
    i.length > 0 && (i += "|"), i += t;
    let n = this._entries[i];
    return n || (n = new mf(e, t), this._entries[i] = n, n);
  }
}
B_._INSTANCE = new B_(yV);
class mf {
  constructor(e, t) {
    this.parent = e, this.state = t, this.depth = (this.parent ? this.parent.depth : 0) + 1;
  }
  static getStackElementId(e) {
    let t = "";
    for (; e !== null; )
      t.length > 0 && (t += "|"), t += e.state, e = e.parent;
    return t;
  }
  static _equals(e, t) {
    for (; e !== null && t !== null; ) {
      if (e === t)
        return !0;
      if (e.state !== t.state)
        return !1;
      e = e.parent, t = t.parent;
    }
    return e === null && t === null;
  }
  equals(e) {
    return mf._equals(this, e);
  }
  push(e) {
    return B_.create(this, e);
  }
  pop() {
    return this.parent;
  }
  popall() {
    let e = this;
    for (; e.parent; )
      e = e.parent;
    return e;
  }
  switchTo(e) {
    return B_.create(this.parent, e);
  }
}
class Ug {
  constructor(e, t) {
    this.languageId = e, this.state = t;
  }
  equals(e) {
    return this.languageId === e.languageId && this.state.equals(e.state);
  }
  clone() {
    return this.state.clone() === this.state ? this : new Ug(this.languageId, this.state);
  }
}
class jd {
  static create(e, t) {
    return this._INSTANCE.create(e, t);
  }
  constructor(e) {
    this._maxCacheDepth = e, this._entries = /* @__PURE__ */ Object.create(null);
  }
  create(e, t) {
    if (t !== null)
      return new t_(e, t);
    if (e !== null && e.depth >= this._maxCacheDepth)
      return new t_(e, t);
    const i = mf.getStackElementId(e);
    let n = this._entries[i];
    return n || (n = new t_(e, null), this._entries[i] = n, n);
  }
}
jd._INSTANCE = new jd(yV);
class t_ {
  constructor(e, t) {
    this.stack = e, this.embeddedLanguageData = t;
  }
  clone() {
    return (this.embeddedLanguageData ? this.embeddedLanguageData.clone() : null) === this.embeddedLanguageData ? this : jd.create(this.stack, this.embeddedLanguageData);
  }
  equals(e) {
    return !(e instanceof t_) || !this.stack.equals(e.stack) ? !1 : this.embeddedLanguageData === null && e.embeddedLanguageData === null ? !0 : this.embeddedLanguageData === null || e.embeddedLanguageData === null ? !1 : this.embeddedLanguageData.equals(e.embeddedLanguageData);
  }
}
class Xq {
  constructor() {
    this._tokens = [], this._languageId = null, this._lastTokenType = null, this._lastTokenLanguage = null;
  }
  enterLanguage(e) {
    this._languageId = e;
  }
  emit(e, t) {
    this._lastTokenType === t && this._lastTokenLanguage === this._languageId || (this._lastTokenType = t, this._lastTokenLanguage = this._languageId, this._tokens.push(new oS(e, t, this._languageId)));
  }
  nestedLanguageTokenize(e, t, i, n) {
    const s = i.languageId, o = i.state, a = ri.get(s);
    if (!a)
      return this.enterLanguage(s), this.emit(n, ""), o;
    const l = a.tokenize(e, t, o);
    if (n !== 0)
      for (const d of l.tokens)
        this._tokens.push(new oS(d.offset + n, d.type, d.language));
    else
      this._tokens = this._tokens.concat(l.tokens);
    return this._lastTokenType = null, this._lastTokenLanguage = null, this._languageId = null, l.endState;
  }
  finalize(e) {
    return new zN(this._tokens, e);
  }
}
class vS {
  constructor(e, t) {
    this._languageService = e, this._theme = t, this._prependTokens = null, this._tokens = [], this._currentLanguageId = 0, this._lastTokenMetadata = 0;
  }
  enterLanguage(e) {
    this._currentLanguageId = this._languageService.languageIdCodec.encodeLanguageId(e);
  }
  emit(e, t) {
    const i = this._theme.match(this._currentLanguageId, t) | 1024;
    this._lastTokenMetadata !== i && (this._lastTokenMetadata = i, this._tokens.push(e), this._tokens.push(i));
  }
  static _merge(e, t, i) {
    const n = e !== null ? e.length : 0, s = t.length, o = i !== null ? i.length : 0;
    if (n === 0 && s === 0 && o === 0)
      return new Uint32Array(0);
    if (n === 0 && s === 0)
      return i;
    if (s === 0 && o === 0)
      return e;
    const a = new Uint32Array(n + s + o);
    e !== null && a.set(e);
    for (let l = 0; l < s; l++)
      a[n + l] = t[l];
    return i !== null && a.set(i, n + s), a;
  }
  nestedLanguageTokenize(e, t, i, n) {
    const s = i.languageId, o = i.state, a = ri.get(s);
    if (!a)
      return this.enterLanguage(s), this.emit(n, ""), o;
    const l = a.tokenizeEncoded(e, t, o);
    if (n !== 0)
      for (let d = 0, c = l.tokens.length; d < c; d += 2)
        l.tokens[d] += n;
    return this._prependTokens = vS._merge(this._prependTokens, this._tokens, l.tokens), this._tokens = [], this._currentLanguageId = 0, this._lastTokenMetadata = 0, l.endState;
  }
  finalize(e) {
    return new Jy(vS._merge(this._prependTokens, this._tokens, null), e);
  }
}
let H_ = Hx = class extends P {
  constructor(e, t, i, n, s) {
    super(), this._configurationService = s, this._languageService = e, this._standaloneThemeService = t, this._languageId = i, this._lexer = n, this._embeddedLanguages = /* @__PURE__ */ Object.create(null), this.embeddedLoaded = Promise.resolve(void 0);
    let o = !1;
    this._register(ri.onDidChange((a) => {
      if (o)
        return;
      let l = !1;
      for (let d = 0, c = a.changedLanguages.length; d < c; d++) {
        const h = a.changedLanguages[d];
        if (this._embeddedLanguages[h]) {
          l = !0;
          break;
        }
      }
      l && (o = !0, ri.handleChange([this._languageId]), o = !1);
    })), this._maxTokenizationLineLength = this._configurationService.getValue("editor.maxTokenizationLineLength", {
      overrideIdentifier: this._languageId
    }), this._register(this._configurationService.onDidChangeConfiguration((a) => {
      a.affectsConfiguration("editor.maxTokenizationLineLength") && (this._maxTokenizationLineLength = this._configurationService.getValue("editor.maxTokenizationLineLength", {
        overrideIdentifier: this._languageId
      }));
    }));
  }
  getLoadStatus() {
    const e = [];
    for (const t in this._embeddedLanguages) {
      const i = ri.get(t);
      if (i) {
        if (i instanceof Hx) {
          const n = i.getLoadStatus();
          n.loaded === !1 && e.push(n.promise);
        }
        continue;
      }
      ri.isResolved(t) || e.push(ri.getOrCreate(t));
    }
    return e.length === 0 ? {
      loaded: !0
    } : {
      loaded: !1,
      promise: Promise.all(e).then((t) => {
      })
    };
  }
  getInitialState() {
    const e = B_.create(null, this._lexer.start);
    return jd.create(e, null);
  }
  tokenize(e, t, i) {
    if (e.length >= this._maxTokenizationLineLength)
      return g1(this._languageId, i);
    const n = new Xq(), s = this._tokenize(e, t, i, n);
    return n.finalize(s);
  }
  tokenizeEncoded(e, t, i) {
    if (e.length >= this._maxTokenizationLineLength)
      return S0(this._languageService.languageIdCodec.encodeLanguageId(this._languageId), i);
    const n = new vS(this._languageService, this._standaloneThemeService.getColorTheme().tokenTheme), s = this._tokenize(e, t, i, n);
    return n.finalize(s);
  }
  _tokenize(e, t, i, n) {
    return i.embeddedLanguageData ? this._nestedTokenize(e, t, i, 0, n) : this._myTokenize(e, t, i, 0, n);
  }
  _findLeavingNestedLanguageOffset(e, t) {
    let i = this._lexer.tokenizer[t.stack.state];
    if (!i && (i = aC(this._lexer, t.stack.state), !i))
      throw jt(this._lexer, "tokenizer state is not defined: " + t.stack.state);
    let n = -1, s = !1;
    for (const o of i) {
      if (!XA(o.action) || o.action.nextEmbedded !== "@pop")
        continue;
      s = !0;
      let a = o.resolveRegex(t.stack.state);
      const l = a.source;
      if (l.substr(0, 4) === "^(?:" && l.substr(l.length - 1, 1) === ")") {
        const c = (a.ignoreCase ? "i" : "") + (a.unicode ? "u" : "");
        a = new RegExp(l.substr(4, l.length - 5), c);
      }
      const d = e.search(a);
      d === -1 || d !== 0 && o.matchOnlyAtLineStart || (n === -1 || d < n) && (n = d);
    }
    if (!s)
      throw jt(this._lexer, 'no rule containing nextEmbedded: "@pop" in tokenizer embedded state: ' + t.stack.state);
    return n;
  }
  _nestedTokenize(e, t, i, n, s) {
    const o = this._findLeavingNestedLanguageOffset(e, i);
    if (o === -1) {
      const d = s.nestedLanguageTokenize(e, t, i.embeddedLanguageData, n);
      return jd.create(i.stack, new Ug(i.embeddedLanguageData.languageId, d));
    }
    const a = e.substring(0, o);
    a.length > 0 && s.nestedLanguageTokenize(a, !1, i.embeddedLanguageData, n);
    const l = e.substring(o);
    return this._myTokenize(l, t, i, n + o, s);
  }
  _safeRuleName(e) {
    return e ? e.name : "(unknown)";
  }
  _myTokenize(e, t, i, n, s) {
    s.enterLanguage(this._languageId);
    const o = e.length, a = t && this._lexer.includeLF ? e + `
` : e, l = a.length;
    let d = i.embeddedLanguageData, c = i.stack, h = 0, u = null, g = !0;
    for (; g || h < l; ) {
      const f = h, m = c.depth, _ = u ? u.groups.length : 0, v = c.state;
      let b = null, C = null, w = null, S = null, y = null;
      if (u) {
        b = u.matches;
        const N = u.groups.shift();
        C = N.matched, w = N.action, S = u.rule, u.groups.length === 0 && (u = null);
      } else {
        if (!g && h >= l)
          break;
        g = !1;
        let N = this._lexer.tokenizer[v];
        if (!N && (N = aC(this._lexer, v), !N))
          throw jt(this._lexer, "tokenizer state is not defined: " + v);
        const F = a.substr(h);
        for (const V of N)
          if ((h === 0 || !V.matchOnlyAtLineStart) && (b = F.match(V.resolveRegex(v)), b)) {
            C = b[0], w = V.action;
            break;
          }
      }
      if (b || (b = [""], C = ""), w || (h < l && (b = [a.charAt(h)], C = b[0]), w = this._lexer.defaultToken), C === null)
        break;
      for (h += C.length; jq(w) && XA(w) && w.test; )
        w = w.test(C, b, v, h === l);
      let k = null;
      if (typeof w == "string" || Array.isArray(w))
        k = w;
      else if (w.group)
        k = w.group;
      else if (w.token !== null && w.token !== void 0) {
        if (w.tokenSubst ? k = Kd(this._lexer, w.token, C, b, v) : k = w.token, w.nextEmbedded)
          if (w.nextEmbedded === "@pop") {
            if (!d)
              throw jt(this._lexer, "cannot pop embedded language if not inside one");
            d = null;
          } else {
            if (d)
              throw jt(this._lexer, "cannot enter embedded language from within an embedded language");
            y = Kd(this._lexer, w.nextEmbedded, C, b, v);
          }
        if (w.goBack && (h = Math.max(0, h - w.goBack)), w.switchTo && typeof w.switchTo == "string") {
          let N = Kd(this._lexer, w.switchTo, C, b, v);
          if (N[0] === "@" && (N = N.substr(1)), aC(this._lexer, N))
            c = c.switchTo(N);
          else
            throw jt(this._lexer, "trying to switch to a state '" + N + "' that is undefined in rule: " + this._safeRuleName(S));
        } else {
          if (w.transform && typeof w.transform == "function")
            throw jt(this._lexer, "action.transform not supported");
          if (w.next)
            if (w.next === "@push") {
              if (c.depth >= this._lexer.maxStack)
                throw jt(this._lexer, "maximum tokenizer stack size reached: [" + c.state + "," + c.parent.state + ",...]");
              c = c.push(v);
            } else if (w.next === "@pop") {
              if (c.depth <= 1)
                throw jt(this._lexer, "trying to pop an empty stack in rule: " + this._safeRuleName(S));
              c = c.pop();
            } else if (w.next === "@popall")
              c = c.popall();
            else {
              let N = Kd(this._lexer, w.next, C, b, v);
              if (N[0] === "@" && (N = N.substr(1)), aC(this._lexer, N))
                c = c.push(N);
              else
                throw jt(this._lexer, "trying to set a next state '" + N + "' that is undefined in rule: " + this._safeRuleName(S));
            }
        }
        w.log && typeof w.log == "string" && qq(this._lexer, this._lexer.languageId + ": " + Kd(this._lexer, w.log, C, b, v));
      }
      if (k === null)
        throw jt(this._lexer, "lexer rule has no well-defined action in rule: " + this._safeRuleName(S));
      const E = (N) => {
        const F = this._languageService.getLanguageIdByLanguageName(N) || this._languageService.getLanguageIdByMimeType(N) || N, V = this._getNestedEmbeddedLanguageData(F);
        if (h < l) {
          const Z = e.substr(h);
          return this._nestedTokenize(Z, t, jd.create(c, V), n + h, s);
        } else
          return jd.create(c, V);
      };
      if (Array.isArray(k)) {
        if (u && u.groups.length > 0)
          throw jt(this._lexer, "groups cannot be nested: " + this._safeRuleName(S));
        if (b.length !== k.length + 1)
          throw jt(this._lexer, "matched number of groups does not match the number of actions in rule: " + this._safeRuleName(S));
        let N = 0;
        for (let F = 1; F < b.length; F++)
          N += b[F].length;
        if (N !== C.length)
          throw jt(this._lexer, "with groups, all characters should be matched in consecutive groups in rule: " + this._safeRuleName(S));
        u = {
          rule: S,
          matches: b,
          groups: []
        };
        for (let F = 0; F < k.length; F++)
          u.groups[F] = {
            action: k[F],
            matched: b[F + 1]
          };
        h -= C.length;
        continue;
      } else {
        if (k === "@rematch" && (h -= C.length, C = "", b = null, k = "", y !== null))
          return E(y);
        if (C.length === 0) {
          if (l === 0 || m !== c.depth || v !== c.state || (u ? u.groups.length : 0) !== _)
            continue;
          throw jt(this._lexer, "no progress in tokenizer in rule: " + this._safeRuleName(S));
        }
        let N = null;
        if (SV(k) && k.indexOf("@brackets") === 0) {
          const F = k.substr(9), V = Jq(this._lexer, C);
          if (!V)
            throw jt(this._lexer, "@brackets token returned but no bracket defined as: " + C);
          N = JA(V.token + F);
        } else {
          const F = k === "" ? "" : k + this._lexer.tokenPostfix;
          N = JA(F);
        }
        f < o && s.emit(f + n, N);
      }
      if (y !== null)
        return E(y);
    }
    return jd.create(c, d);
  }
  _getNestedEmbeddedLanguageData(e) {
    if (!this._languageService.isRegisteredLanguageId(e))
      return new Ug(e, zf);
    e !== this._languageId && (this._languageService.requestBasicLanguageFeatures(e), ri.getOrCreate(e), this._embeddedLanguages[e] = !0);
    const t = ri.get(e);
    return t ? new Ug(e, t.getInitialState()) : new Ug(e, zf);
  }
};
H_ = Hx = Yq([
  Qq(4, Ge)
], H_);
function Jq(r, e) {
  if (!e)
    return null;
  e = td(r, e);
  const t = r.brackets;
  for (const i of t) {
    if (i.open === e)
      return {
        token: i.token,
        bracketType: 1
        /* monarchCommon.MonarchBracket.Open */
      };
    if (i.close === e)
      return {
        token: i.token,
        bracketType: -1
        /* monarchCommon.MonarchBracket.Close */
      };
  }
  return null;
}
const zD = wd("standaloneColorizer", { createHTML: (r) => r });
class m1 {
  static colorizeElement(e, t, i, n) {
    n = n || {};
    const s = n.theme || "vs", o = n.mimeType || i.getAttribute("lang") || i.getAttribute("data-lang");
    if (!o)
      return console.error("Mode not detected"), Promise.resolve();
    const a = t.getLanguageIdByMimeType(o) || o;
    e.setTheme(s);
    const l = i.firstChild ? i.firstChild.nodeValue : "";
    i.className += " " + s;
    const d = (c) => {
      var h;
      const u = (h = zD == null ? void 0 : zD.createHTML(c)) !== null && h !== void 0 ? h : c;
      i.innerHTML = u;
    };
    return this.colorize(t, l || "", a, n).then(d, (c) => console.error(c));
  }
  static async colorize(e, t, i, n) {
    const s = e.languageIdCodec;
    let o = 4;
    n && typeof n.tabSize == "number" && (o = n.tabSize), UN(t) && (t = t.substr(1));
    const a = vd(t);
    if (!e.isRegisteredLanguageId(i))
      return eP(a, o, s);
    const l = await ri.getOrCreate(i);
    return l ? eG(a, o, l, s) : eP(a, o, s);
  }
  static colorizeLine(e, t, i, n, s = 4) {
    const o = po.isBasicASCII(e, t), a = po.containsRTL(e, o, i);
    return y0(new th(!1, !0, e, !1, o, a, 0, n, [], s, 0, 0, 0, 0, -1, "none", !1, !1, null)).html;
  }
  static colorizeModelLine(e, t, i = 4) {
    const n = e.getLineContent(t);
    e.tokenization.forceTokenization(t);
    const o = e.tokenization.getLineTokens(t).inflate();
    return this.colorizeLine(n, e.mightContainNonBasicASCII(), e.mightContainRTL(), o, i);
  }
}
function eG(r, e, t, i) {
  return new Promise((n, s) => {
    const o = () => {
      const a = tG(r, e, t, i);
      if (t instanceof H_) {
        const l = t.getLoadStatus();
        if (l.loaded === !1) {
          l.promise.then(o, s);
          return;
        }
      }
      n(a);
    };
    o();
  });
}
function eP(r, e, t) {
  let i = [];
  const s = new Uint32Array(2);
  s[0] = 0, s[1] = 33587200;
  for (let o = 0, a = r.length; o < a; o++) {
    const l = r[o];
    s[0] = l.length;
    const d = new Ri(s, l, t), c = po.isBasicASCII(
      l,
      /* check for basic ASCII */
      !0
    ), h = po.containsRTL(
      l,
      c,
      /* check for RTL */
      !0
    ), u = y0(new th(!1, !0, l, !1, c, h, 0, d, [], e, 0, 0, 0, 0, -1, "none", !1, !1, null));
    i = i.concat(u.html), i.push("<br/>");
  }
  return i.join("");
}
function tG(r, e, t, i) {
  let n = [], s = t.getInitialState();
  for (let o = 0, a = r.length; o < a; o++) {
    const l = r[o], d = t.tokenizeEncoded(l, !0, s);
    Ri.convertToEndOffset(d.tokens, l.length);
    const c = new Ri(d.tokens, l, i), h = po.isBasicASCII(
      l,
      /* check for basic ASCII */
      !0
    ), u = po.containsRTL(
      l,
      h,
      /* check for RTL */
      !0
    ), g = y0(new th(!1, !0, l, !1, h, u, 0, c.inflate(), [], e, 0, 0, 0, 0, -1, "none", !1, !1, null));
    n = n.concat(g.html), n.push("<br/>"), s = d.endState;
  }
  return n.join("");
}
const tP = 2e4;
let Bh, Ew, Vx, Tw, zx;
function iG(r) {
  Bh = document.createElement("div"), Bh.className = "monaco-aria-container";
  const e = () => {
    const i = document.createElement("div");
    return i.className = "monaco-alert", i.setAttribute("role", "alert"), i.setAttribute("aria-atomic", "true"), Bh.appendChild(i), i;
  };
  Ew = e(), Vx = e();
  const t = () => {
    const i = document.createElement("div");
    return i.className = "monaco-status", i.setAttribute("aria-live", "polite"), i.setAttribute("aria-atomic", "true"), Bh.appendChild(i), i;
  };
  Tw = t(), zx = t(), r.appendChild(Bh);
}
function Ls(r) {
  Bh && (Ew.textContent !== r ? (pn(Vx), bS(Ew, r)) : (pn(Ew), bS(Vx, r)));
}
function el(r) {
  Bh && (Tw.textContent !== r ? (pn(zx), bS(Tw, r)) : (pn(Tw), bS(zx, r)));
}
function bS(r, e) {
  pn(r), e.length > tP && (e = e.substr(0, tP)), r.textContent = e, r.style.visibility = "hidden", r.style.visibility = "visible";
}
const _1 = et("markerDecorationsService");
var nG = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, sG = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
let V_ = class {
  constructor(e, t) {
  }
  dispose() {
  }
};
V_.ID = "editor.contrib.markerDecorations";
V_ = nG([
  sG(1, _1)
], V_);
gt(
  V_.ID,
  V_,
  0
  /* EditorContributionInstantiation.Eager */
);
class LV extends P {
  constructor(e, t) {
    super(), this._onDidChange = this._register(new R()), this.onDidChange = this._onDidChange.event, this._referenceDomElement = e, this._width = -1, this._height = -1, this._resizeObserver = null, this.measureReferenceDomElement(!1, t);
  }
  dispose() {
    this.stopObserving(), super.dispose();
  }
  getWidth() {
    return this._width;
  }
  getHeight() {
    return this._height;
  }
  startObserving() {
    if (!this._resizeObserver && this._referenceDomElement) {
      let e = null;
      const t = () => {
        e ? this.observe({ width: e.width, height: e.height }) : this.observe();
      };
      let i = !1, n = !1;
      const s = () => {
        if (i && !n)
          try {
            i = !1, n = !0, t();
          } finally {
            Us(we(this._referenceDomElement), () => {
              n = !1, s();
            });
          }
      };
      this._resizeObserver = new ResizeObserver((o) => {
        o && o[0] && o[0].contentRect ? e = { width: o[0].contentRect.width, height: o[0].contentRect.height } : e = null, i = !0, s();
      }), this._resizeObserver.observe(this._referenceDomElement);
    }
  }
  stopObserving() {
    this._resizeObserver && (this._resizeObserver.disconnect(), this._resizeObserver = null);
  }
  observe(e) {
    this.measureReferenceDomElement(!0, e);
  }
  measureReferenceDomElement(e, t) {
    let i = 0, n = 0;
    t ? (i = t.width, n = t.height) : this._referenceDomElement && (i = this._referenceDomElement.clientWidth, n = this._referenceDomElement.clientHeight), i = Math.max(5, i), n = Math.max(5, n), (this._width !== i || this._height !== n) && (this._width = i, this._height = n, e && this._onDidChange.fire());
  }
}
class mc {
  constructor(e, t) {
    this.key = e, this.migrate = t;
  }
  apply(e) {
    const t = mc._read(e, this.key), i = (s) => mc._read(e, s), n = (s, o) => mc._write(e, s, o);
    this.migrate(t, i, n);
  }
  static _read(e, t) {
    if (typeof e > "u")
      return;
    const i = t.indexOf(".");
    if (i >= 0) {
      const n = t.substring(0, i);
      return this._read(e[n], t.substring(i + 1));
    }
    return e[t];
  }
  static _write(e, t, i) {
    const n = t.indexOf(".");
    if (n >= 0) {
      const s = t.substring(0, n);
      e[s] = e[s] || {}, this._write(e[s], t.substring(n + 1), i);
      return;
    }
    e[t] = i;
  }
}
mc.items = [];
function la(r, e) {
  mc.items.push(new mc(r, e));
}
function js(r, e) {
  la(r, (t, i, n) => {
    if (typeof t < "u") {
      for (const [s, o] of e)
        if (t === s) {
          n(r, o);
          return;
        }
    }
  });
}
function oG(r) {
  mc.items.forEach((e) => e.apply(r));
}
js("wordWrap", [[!0, "on"], [!1, "off"]]);
js("lineNumbers", [[!0, "on"], [!1, "off"]]);
js("cursorBlinking", [["visible", "solid"]]);
js("renderWhitespace", [[!0, "boundary"], [!1, "none"]]);
js("renderLineHighlight", [[!0, "line"], [!1, "none"]]);
js("acceptSuggestionOnEnter", [[!0, "on"], [!1, "off"]]);
js("tabCompletion", [[!1, "off"], [!0, "onlySnippets"]]);
js("hover", [[!0, { enabled: !0 }], [!1, { enabled: !1 }]]);
js("parameterHints", [[!0, { enabled: !0 }], [!1, { enabled: !1 }]]);
js("autoIndent", [[!1, "advanced"], [!0, "full"]]);
js("matchBrackets", [[!0, "always"], [!1, "never"]]);
js("renderFinalNewline", [[!0, "on"], [!1, "off"]]);
js("cursorSmoothCaretAnimation", [[!0, "on"], [!1, "off"]]);
js("occurrencesHighlight", [[!0, "singleFile"], [!1, "off"]]);
js("wordBasedSuggestions", [[!0, "matchingDocuments"], [!1, "off"]]);
la("autoClosingBrackets", (r, e, t) => {
  r === !1 && (t("autoClosingBrackets", "never"), typeof e("autoClosingQuotes") > "u" && t("autoClosingQuotes", "never"), typeof e("autoSurround") > "u" && t("autoSurround", "never"));
});
la("renderIndentGuides", (r, e, t) => {
  typeof r < "u" && (t("renderIndentGuides", void 0), typeof e("guides.indentation") > "u" && t("guides.indentation", !!r));
});
la("highlightActiveIndentGuide", (r, e, t) => {
  typeof r < "u" && (t("highlightActiveIndentGuide", void 0), typeof e("guides.highlightActiveIndentation") > "u" && t("guides.highlightActiveIndentation", !!r));
});
const rG = {
  method: "showMethods",
  function: "showFunctions",
  constructor: "showConstructors",
  deprecated: "showDeprecated",
  field: "showFields",
  variable: "showVariables",
  class: "showClasses",
  struct: "showStructs",
  interface: "showInterfaces",
  module: "showModules",
  property: "showProperties",
  event: "showEvents",
  operator: "showOperators",
  unit: "showUnits",
  value: "showValues",
  constant: "showConstants",
  enum: "showEnums",
  enumMember: "showEnumMembers",
  keyword: "showKeywords",
  text: "showWords",
  color: "showColors",
  file: "showFiles",
  reference: "showReferences",
  folder: "showFolders",
  typeParameter: "showTypeParameters",
  snippet: "showSnippets"
};
la("suggest.filteredTypes", (r, e, t) => {
  if (r && typeof r == "object") {
    for (const i of Object.entries(rG))
      r[i[0]] === !1 && typeof e(`suggest.${i[1]}`) > "u" && t(`suggest.${i[1]}`, !1);
    t("suggest.filteredTypes", void 0);
  }
});
la("quickSuggestions", (r, e, t) => {
  if (typeof r == "boolean") {
    const i = r ? "on" : "off";
    t("quickSuggestions", { comments: i, strings: i, other: i });
  }
});
la("experimental.stickyScroll.enabled", (r, e, t) => {
  typeof r == "boolean" && (t("experimental.stickyScroll.enabled", void 0), typeof e("stickyScroll.enabled") > "u" && t("stickyScroll.enabled", r));
});
la("experimental.stickyScroll.maxLineCount", (r, e, t) => {
  typeof r == "number" && (t("experimental.stickyScroll.maxLineCount", void 0), typeof e("stickyScroll.maxLineCount") > "u" && t("stickyScroll.maxLineCount", r));
});
la("codeActionsOnSave", (r, e, t) => {
  if (r && typeof r == "object") {
    let i = !1;
    const n = {};
    for (const s of Object.entries(r))
      typeof s[1] == "boolean" ? (i = !0, n[s[0]] = s[1] ? "explicit" : "never") : n[s[0]] = s[1];
    i && t("codeActionsOnSave", n);
  }
});
la("codeActionWidget.includeNearbyQuickfixes", (r, e, t) => {
  typeof r == "boolean" && (t("codeActionWidget.includeNearbyQuickfixes", void 0), typeof e("codeActionWidget.includeNearbyQuickFixes") > "u" && t("codeActionWidget.includeNearbyQuickFixes", r));
});
la("lightbulb.enabled", (r, e, t) => {
  typeof r == "boolean" && t("lightbulb.enabled", r ? void 0 : "off");
});
class aG {
  constructor() {
    this._tabFocus = !1, this._onDidChangeTabFocus = new R(), this.onDidChangeTabFocus = this._onDidChangeTabFocus.event;
  }
  getTabFocusMode() {
    return this._tabFocus;
  }
  setTabFocusMode(e) {
    this._tabFocus = e, this._onDidChangeTabFocus.fire(this._tabFocus);
  }
}
const Uf = new aG(), qs = et("accessibilityService"), ub = new oe("accessibilityModeEnabled", !1);
var lG = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, dG = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
let Ux = class extends P {
  constructor(e, t, i, n, s) {
    super(), this._accessibilityService = s, this._onDidChange = this._register(new R()), this.onDidChange = this._onDidChange.event, this._onDidChangeFast = this._register(new R()), this.onDidChangeFast = this._onDidChangeFast.event, this._isDominatedByLongLines = !1, this._viewLineCount = 1, this._lineNumbersDigitCount = 1, this._reservedHeight = 0, this._glyphMarginDecorationLaneCount = 1, this._computeOptionsMemory = new SH(), this.isSimpleWidget = e, this.contextMenuId = t, this._containerObserver = this._register(new LV(n, i.dimension)), this._targetWindowId = we(n).vscodeWindowId, this._rawOptions = iP(i), this._validatedOptions = qd.validateOptions(this._rawOptions), this.options = this._computeOptions(), this.options.get(
      13
      /* EditorOption.automaticLayout */
    ) && this._containerObserver.startObserving(), this._register(xo.onDidChangeZoomLevel(() => this._recomputeOptions())), this._register(Uf.onDidChangeTabFocus(() => this._recomputeOptions())), this._register(this._containerObserver.onDidChange(() => this._recomputeOptions())), this._register(Nx.onDidChange(() => this._recomputeOptions())), this._register(O_.getInstance(we(n)).onDidChange(() => this._recomputeOptions())), this._register(this._accessibilityService.onDidChangeScreenReaderOptimized(() => this._recomputeOptions()));
  }
  _recomputeOptions() {
    const e = this._computeOptions(), t = qd.checkEquals(this.options, e);
    t !== null && (this.options = e, this._onDidChangeFast.fire(t), this._onDidChange.fire(t));
  }
  _computeOptions() {
    const e = this._readEnvConfiguration(), t = ou.createFromValidatedSettings(this._validatedOptions, e.pixelRatio, this.isSimpleWidget), i = this._readFontInfo(t), n = {
      memory: this._computeOptionsMemory,
      outerWidth: e.outerWidth,
      outerHeight: e.outerHeight - this._reservedHeight,
      fontInfo: i,
      extraEditorClassName: e.extraEditorClassName,
      isDominatedByLongLines: this._isDominatedByLongLines,
      viewLineCount: this._viewLineCount,
      lineNumbersDigitCount: this._lineNumbersDigitCount,
      emptySelectionClipboard: e.emptySelectionClipboard,
      pixelRatio: e.pixelRatio,
      tabFocusMode: Uf.getTabFocusMode(),
      accessibilitySupport: e.accessibilitySupport,
      glyphMarginDecorationLaneCount: this._glyphMarginDecorationLaneCount
    };
    return qd.computeOptions(this._validatedOptions, n);
  }
  _readEnvConfiguration() {
    return {
      extraEditorClassName: hG(),
      outerWidth: this._containerObserver.getWidth(),
      outerHeight: this._containerObserver.getHeight(),
      emptySelectionClipboard: su || Oo,
      pixelRatio: O_.getInstance(kA(this._targetWindowId, !0).window).value,
      accessibilitySupport: this._accessibilityService.isScreenReaderOptimized() ? 2 : this._accessibilityService.getAccessibilitySupport()
    };
  }
  _readFontInfo(e) {
    return Nx.readFontInfo(kA(this._targetWindowId, !0).window, e);
  }
  getRawOptions() {
    return this._rawOptions;
  }
  updateOptions(e) {
    const t = iP(e);
    qd.applyUpdate(this._rawOptions, t) && (this._validatedOptions = qd.validateOptions(this._rawOptions), this._recomputeOptions());
  }
  observeContainer(e) {
    this._containerObserver.observe(e);
  }
  setIsDominatedByLongLines(e) {
    this._isDominatedByLongLines !== e && (this._isDominatedByLongLines = e, this._recomputeOptions());
  }
  setModelLineCount(e) {
    const t = cG(e);
    this._lineNumbersDigitCount !== t && (this._lineNumbersDigitCount = t, this._recomputeOptions());
  }
  setViewLineCount(e) {
    this._viewLineCount !== e && (this._viewLineCount = e, this._recomputeOptions());
  }
  setReservedHeight(e) {
    this._reservedHeight !== e && (this._reservedHeight = e, this._recomputeOptions());
  }
  setGlyphMarginDecorationLaneCount(e) {
    this._glyphMarginDecorationLaneCount !== e && (this._glyphMarginDecorationLaneCount = e, this._recomputeOptions());
  }
};
Ux = lG([
  dG(4, qs)
], Ux);
function cG(r) {
  let e = 0;
  for (; r; )
    r = Math.floor(r / 10), e++;
  return e || 1;
}
function hG() {
  let r = "";
  return !ld && !LH && (r += "no-user-select "), ld && (r += "no-minimap-shadow ", r += "enable-user-select "), Je && (r += "mac "), r;
}
class uG {
  constructor() {
    this._values = [];
  }
  _read(e) {
    return this._values[e];
  }
  get(e) {
    return this._values[e];
  }
  _write(e, t) {
    this._values[e] = t;
  }
}
class gG {
  constructor() {
    this._values = [];
  }
  _read(e) {
    if (e >= this._values.length)
      throw new Error("Cannot read uninitialized value");
    return this._values[e];
  }
  get(e) {
    return this._read(e);
  }
  _write(e, t) {
    this._values[e] = t;
  }
}
class qd {
  static validateOptions(e) {
    const t = new uG();
    for (const i of Hg) {
      const n = i.name === "_never_" ? void 0 : e[i.name];
      t._write(i.id, i.validate(n));
    }
    return t;
  }
  static computeOptions(e, t) {
    const i = new gG();
    for (const n of Hg)
      i._write(n.id, n.compute(t, i, e._read(n.id)));
    return i;
  }
  static _deepEquals(e, t) {
    if (typeof e != "object" || typeof t != "object" || !e || !t)
      return e === t;
    if (Array.isArray(e) || Array.isArray(t))
      return Array.isArray(e) && Array.isArray(t) ? ci(e, t) : !1;
    if (Object.keys(e).length !== Object.keys(t).length)
      return !1;
    for (const i in e)
      if (!qd._deepEquals(e[i], t[i]))
        return !1;
    return !0;
  }
  static checkEquals(e, t) {
    const i = [];
    let n = !1;
    for (const s of Hg) {
      const o = !qd._deepEquals(e._read(s.id), t._read(s.id));
      i[s.id] = o, o && (n = !0);
    }
    return n ? new wH(i) : null;
  }
  /**
   * Returns true if something changed.
   * Modifies `options`.
  */
  static applyUpdate(e, t) {
    let i = !1;
    for (const n of Hg)
      if (t.hasOwnProperty(n.name)) {
        const s = n.applyUpdate(e[n.name], t[n.name]);
        e[n.name] = s.newValue, i = i || s.didChange;
      }
    return i;
  }
}
function iP(r) {
  const e = Hd(r);
  return oG(e), e;
}
var Jd;
(function(r) {
  const e = { total: 0, min: Number.MAX_VALUE, max: 0 }, t = { ...e }, i = { ...e }, n = { ...e };
  let s = 0;
  const o = {
    keydown: 0,
    input: 0,
    render: 0
  };
  function a() {
    v(), performance.mark("inputlatency/start"), performance.mark("keydown/start"), o.keydown = 1, queueMicrotask(l);
  }
  r.onKeyDown = a;
  function l() {
    o.keydown === 1 && (performance.mark("keydown/end"), o.keydown = 2);
  }
  function d() {
    performance.mark("input/start"), o.input = 1, _();
  }
  r.onBeforeInput = d;
  function c() {
    o.input === 0 && d(), queueMicrotask(h);
  }
  r.onInput = c;
  function h() {
    o.input === 1 && (performance.mark("input/end"), o.input = 2);
  }
  function u() {
    v();
  }
  r.onKeyUp = u;
  function g() {
    v();
  }
  r.onSelectionChange = g;
  function f() {
    o.keydown === 2 && o.input === 2 && o.render === 0 && (performance.mark("render/start"), o.render = 1, queueMicrotask(m), _());
  }
  r.onRenderStart = f;
  function m() {
    o.render === 1 && (performance.mark("render/end"), o.render = 2);
  }
  function _() {
    setTimeout(v);
  }
  function v() {
    o.keydown === 2 && o.input === 2 && o.render === 2 && (performance.mark("inputlatency/end"), performance.measure("keydown", "keydown/start", "keydown/end"), performance.measure("input", "input/start", "input/end"), performance.measure("render", "render/start", "render/end"), performance.measure("inputlatency", "inputlatency/start", "inputlatency/end"), b("keydown", e), b("input", t), b("render", i), b("inputlatency", n), s++, C());
  }
  function b(k, E) {
    const N = performance.getEntriesByName(k)[0].duration;
    E.total += N, E.min = Math.min(E.min, N), E.max = Math.max(E.max, N);
  }
  function C() {
    performance.clearMarks("keydown/start"), performance.clearMarks("keydown/end"), performance.clearMarks("input/start"), performance.clearMarks("input/end"), performance.clearMarks("render/start"), performance.clearMarks("render/end"), performance.clearMarks("inputlatency/start"), performance.clearMarks("inputlatency/end"), performance.clearMeasures("keydown"), performance.clearMeasures("input"), performance.clearMeasures("render"), performance.clearMeasures("inputlatency"), o.keydown = 0, o.input = 0, o.render = 0;
  }
  function w() {
    if (s === 0)
      return;
    const k = {
      keydown: S(e),
      input: S(t),
      render: S(i),
      total: S(n),
      sampleCount: s
    };
    return y(e), y(t), y(i), y(n), s = 0, k;
  }
  r.getAndClearMeasurements = w;
  function S(k) {
    return {
      average: k.total / s,
      max: k.max,
      min: k.min
    };
  }
  function y(k) {
    k.total = 0, k.min = Number.MAX_VALUE, k.max = 0;
  }
})(Jd || (Jd = {}));
class Np {
  constructor() {
    this._hooks = new q(), this._pointerMoveCallback = null, this._onStopCallback = null;
  }
  dispose() {
    this.stopMonitoring(!1), this._hooks.dispose();
  }
  stopMonitoring(e, t) {
    if (!this.isMonitoring())
      return;
    this._hooks.clear(), this._pointerMoveCallback = null;
    const i = this._onStopCallback;
    this._onStopCallback = null, e && i && i(t);
  }
  isMonitoring() {
    return !!this._pointerMoveCallback;
  }
  startMonitoring(e, t, i, n, s) {
    this.isMonitoring() && this.stopMonitoring(!1), this._pointerMoveCallback = n, this._onStopCallback = s;
    let o = e;
    try {
      e.setPointerCapture(t), this._hooks.add(Se(() => {
        try {
          e.releasePointerCapture(t);
        } catch {
        }
      }));
    } catch {
      o = we(e);
    }
    this._hooks.add(W(o, Q.POINTER_MOVE, (a) => {
      if (a.buttons !== i) {
        this.stopMonitoring(!0);
        return;
      }
      a.preventDefault(), this._pointerMoveCallback(a);
    })), this._hooks.add(W(o, Q.POINTER_UP, (a) => this.stopMonitoring(!0)));
  }
}
function v1(r) {
  return `--vscode-${r.replace(/\./g, "-")}`;
}
function le(r) {
  return `var(${v1(r)})`;
}
function fG(r, e) {
  return `var(${v1(r)}, ${e})`;
}
const DV = {
  ColorContribution: "base.contributions.colors"
};
class pG {
  constructor() {
    this._onDidChangeSchema = new R(), this.onDidChangeSchema = this._onDidChangeSchema.event, this.colorSchema = { type: "object", properties: {} }, this.colorReferenceSchema = { type: "string", enum: [], enumDescriptions: [] }, this.colorsById = {};
  }
  registerColor(e, t, i, n = !1, s) {
    const o = { id: e, description: i, defaults: t, needsTransparency: n, deprecationMessage: s };
    this.colorsById[e] = o;
    const a = { type: "string", description: i, format: "color-hex", defaultSnippets: [{ body: "${1:#ff0000}" }] };
    return s && (a.deprecationMessage = s), n && (a.pattern = "^#(?:(?<rgba>[0-9a-fA-f]{3}[0-9a-eA-E])|(?:[0-9a-fA-F]{6}(?:(?![fF]{2})(?:[0-9a-fA-F]{2}))))?$", a.patternErrorMessage = "This color must be transparent or it will obscure content"), this.colorSchema.properties[e] = a, this.colorReferenceSchema.enum.push(e), this.colorReferenceSchema.enumDescriptions.push(i), this._onDidChangeSchema.fire(), e;
  }
  getColors() {
    return Object.keys(this.colorsById).map((e) => this.colorsById[e]);
  }
  resolveDefaultColor(e, t) {
    const i = this.colorsById[e];
    if (i && i.defaults) {
      const n = i.defaults[t.type];
      return Lr(n, t);
    }
  }
  getColorSchema() {
    return this.colorSchema;
  }
  toString() {
    const e = (t, i) => {
      const n = t.indexOf(".") === -1 ? 0 : 1, s = i.indexOf(".") === -1 ? 0 : 1;
      return n !== s ? n - s : t.localeCompare(i);
    };
    return Object.keys(this.colorsById).sort(e).map((t) => `- \`${t}\`: ${this.colorsById[t].description}`).join(`
`);
  }
}
const L0 = new pG();
si.add(DV.ColorContribution, L0);
function I(r, e, t, i, n) {
  return L0.registerColor(r, e, t, i, n);
}
function mG(r, e) {
  var t, i, n, s;
  switch (r.op) {
    case 0:
      return (t = Lr(r.value, e)) === null || t === void 0 ? void 0 : t.darken(r.factor);
    case 1:
      return (i = Lr(r.value, e)) === null || i === void 0 ? void 0 : i.lighten(r.factor);
    case 2:
      return (n = Lr(r.value, e)) === null || n === void 0 ? void 0 : n.transparent(r.factor);
    case 3: {
      const o = Lr(r.background, e);
      return o ? (s = Lr(r.value, e)) === null || s === void 0 ? void 0 : s.makeOpaque(o) : Lr(r.value, e);
    }
    case 4:
      for (const o of r.values) {
        const a = Lr(o, e);
        if (a)
          return a;
      }
      return;
    case 6:
      return Lr(e.defines(r.if) ? r.then : r.else, e);
    case 5: {
      const o = Lr(r.value, e);
      if (!o)
        return;
      const a = Lr(r.background, e);
      return a ? o.isDarkerThan(a) ? z.getLighterColor(o, a, r.factor).transparent(r.transparency) : z.getDarkerColor(o, a, r.factor).transparent(r.transparency) : o.transparent(r.factor * r.transparency);
    }
    default:
      throw $N();
  }
}
function Ju(r, e) {
  return { op: 0, value: r, factor: e };
}
function Kr(r, e) {
  return { op: 1, value: r, factor: e };
}
function ve(r, e) {
  return { op: 2, value: r, factor: e };
}
function z_(...r) {
  return { op: 4, values: r };
}
function _G(r, e, t) {
  return { op: 6, if: r, then: e, else: t };
}
function nP(r, e, t, i) {
  return { op: 5, value: r, background: e, factor: t, transparency: i };
}
function Lr(r, e) {
  if (r !== null) {
    if (typeof r == "string")
      return r[0] === "#" ? z.fromHex(r) : e.getColor(r);
    if (r instanceof z)
      return r;
    if (typeof r == "object")
      return mG(r, e);
  }
}
const kV = "vscode://schemas/workbench-colors", xV = si.as(w0.JSONContribution);
xV.registerSchema(kV, L0.getColorSchema());
const sP = new xt(() => xV.notifySchemaChanged(kV), 200);
L0.onDidChangeSchema(() => {
  sP.isScheduled() || sP.schedule();
});
const ie = I("foreground", { dark: "#CCCCCC", light: "#616161", hcDark: "#FFFFFF", hcLight: "#292929" }, p("foreground", "Overall foreground color. This color is only used if not overridden by a component."));
I("disabledForeground", { dark: "#CCCCCC80", light: "#61616180", hcDark: "#A5A5A5", hcLight: "#7F7F7F" }, p("disabledForeground", "Overall foreground for disabled elements. This color is only used if not overridden by a component."));
I("errorForeground", { dark: "#F48771", light: "#A1260D", hcDark: "#F48771", hcLight: "#B5200D" }, p("errorForeground", "Overall foreground color for error messages. This color is only used if not overridden by a component."));
I("descriptionForeground", { light: "#717171", dark: ve(ie, 0.7), hcDark: ve(ie, 0.7), hcLight: ve(ie, 0.7) }, p("descriptionForeground", "Foreground color for description text providing additional information, for example for a label."));
const Ha = I("icon.foreground", { dark: "#C5C5C5", light: "#424242", hcDark: "#FFFFFF", hcLight: "#292929" }, p("iconForeground", "The default color for icons in the workbench.")), To = I("focusBorder", { dark: "#007FD4", light: "#0090F1", hcDark: "#F38518", hcLight: "#006BBD" }, p("focusBorder", "Overall border color for focused elements. This color is only used if not overridden by a component.")), it = I("contrastBorder", { light: null, dark: null, hcDark: "#6FC3DF", hcLight: "#0F4A85" }, p("contrastBorder", "An extra border around elements to separate them from others for greater contrast.")), Gt = I("contrastActiveBorder", { light: null, dark: null, hcDark: To, hcLight: To }, p("activeContrastBorder", "An extra border around active elements to separate them from others for greater contrast."));
I("selection.background", { light: null, dark: null, hcDark: null, hcLight: null }, p("selectionBackground", "The background color of text selections in the workbench (e.g. for input fields or text areas). Note that this does not apply to selections within the editor."));
const vG = I("textLink.foreground", { light: "#006AB1", dark: "#3794FF", hcDark: "#21A6FF", hcLight: "#0F4A85" }, p("textLinkForeground", "Foreground color for links in text."));
I("textLink.activeForeground", { light: "#006AB1", dark: "#3794FF", hcDark: "#21A6FF", hcLight: "#0F4A85" }, p("textLinkActiveForeground", "Foreground color for links in text when clicked on and on mouse hover."));
I("textSeparator.foreground", { light: "#0000002e", dark: "#ffffff2e", hcDark: z.black, hcLight: "#292929" }, p("textSeparatorForeground", "Color for text separators."));
I("textPreformat.foreground", { light: "#A31515", dark: "#D7BA7D", hcDark: "#000000", hcLight: "#FFFFFF" }, p("textPreformatForeground", "Foreground color for preformatted text segments."));
I("textPreformat.background", { light: "#0000001A", dark: "#FFFFFF1A", hcDark: "#FFFFFF", hcLight: "#09345f" }, p("textPreformatBackground", "Background color for preformatted text segments."));
I("textBlockQuote.background", { light: "#f2f2f2", dark: "#222222", hcDark: null, hcLight: "#F2F2F2" }, p("textBlockQuoteBackground", "Background color for block quotes in text."));
I("textBlockQuote.border", { light: "#007acc80", dark: "#007acc80", hcDark: z.white, hcLight: "#292929" }, p("textBlockQuoteBorder", "Border color for block quotes in text."));
I("textCodeBlock.background", { light: "#dcdcdc66", dark: "#0a0a0a66", hcDark: z.black, hcLight: "#F2F2F2" }, p("textCodeBlockBackground", "Background color for code blocks in text."));
I("sash.hoverBorder", { dark: To, light: To, hcDark: To, hcLight: To }, p("sashActiveBorder", "Border color of active sashes."));
const Nw = I("badge.background", { dark: "#4D4D4D", light: "#C4C4C4", hcDark: z.black, hcLight: "#0F4A85" }, p("badgeBackground", "Badge background color. Badges are small information labels, e.g. for search results count.")), bG = I("badge.foreground", { dark: z.white, light: "#333", hcDark: z.white, hcLight: z.white }, p("badgeForeground", "Badge foreground color. Badges are small information labels, e.g. for search results count.")), Dm = I("scrollbar.shadow", { dark: "#000000", light: "#DDDDDD", hcDark: null, hcLight: null }, p("scrollbarShadow", "Scrollbar shadow to indicate that the view is scrolled.")), km = I("scrollbarSlider.background", { dark: z.fromHex("#797979").transparent(0.4), light: z.fromHex("#646464").transparent(0.4), hcDark: ve(it, 0.6), hcLight: ve(it, 0.4) }, p("scrollbarSliderBackground", "Scrollbar slider background color.")), xm = I("scrollbarSlider.hoverBackground", { dark: z.fromHex("#646464").transparent(0.7), light: z.fromHex("#646464").transparent(0.7), hcDark: ve(it, 0.8), hcLight: ve(it, 0.8) }, p("scrollbarSliderHoverBackground", "Scrollbar slider background color when hovering.")), Im = I("scrollbarSlider.activeBackground", { dark: z.fromHex("#BFBFBF").transparent(0.4), light: z.fromHex("#000000").transparent(0.6), hcDark: it, hcLight: it }, p("scrollbarSliderActiveBackground", "Scrollbar slider background color when clicked on.")), CG = I("progressBar.background", { dark: z.fromHex("#0E70C0"), light: z.fromHex("#0E70C0"), hcDark: it, hcLight: it }, p("progressBarBackground", "Background color of the progress bar that can show for long running operations.")), Gi = I("editor.background", { light: "#ffffff", dark: "#1E1E1E", hcDark: z.black, hcLight: z.white }, p("editorBackground", "Editor background color.")), No = I("editor.foreground", { light: "#333333", dark: "#BBBBBB", hcDark: z.white, hcLight: ie }, p("editorForeground", "Editor default foreground color."));
I("editorStickyScroll.background", { light: Gi, dark: Gi, hcDark: Gi, hcLight: Gi }, p("editorStickyScrollBackground", "Background color of sticky scroll in the editor"));
I("editorStickyScrollHover.background", { dark: "#2A2D2E", light: "#F0F0F0", hcDark: null, hcLight: z.fromHex("#0F4A85").transparent(0.1) }, p("editorStickyScrollHoverBackground", "Background color of sticky scroll on hover in the editor"));
I("editorStickyScroll.border", { dark: null, light: null, hcDark: it, hcLight: it }, p("editorStickyScrollBorder", "Border color of sticky scroll in the editor"));
I("editorStickyScroll.shadow", { dark: Dm, light: Dm, hcDark: Dm, hcLight: Dm }, p("editorStickyScrollShadow", " Shadow color of sticky scroll in the editor"));
const Di = I("editorWidget.background", { dark: "#252526", light: "#F3F3F3", hcDark: "#0C141F", hcLight: z.white }, p("editorWidgetBackground", "Background color of editor widgets, such as find/replace.")), Vl = I("editorWidget.foreground", { dark: ie, light: ie, hcDark: ie, hcLight: ie }, p("editorWidgetForeground", "Foreground color of editor widgets, such as find/replace.")), zl = I("editorWidget.border", { dark: "#454545", light: "#C8C8C8", hcDark: it, hcLight: it }, p("editorWidgetBorder", "Border color of editor widgets. The color is only used if the widget chooses to have a border and if the color is not overridden by a widget."));
I("editorWidget.resizeBorder", { light: null, dark: null, hcDark: null, hcLight: null }, p("editorWidgetResizeBorder", "Border color of the resize bar of editor widgets. The color is only used if the widget chooses to have a resize border and if the color is not overridden by a widget."));
I("editorError.background", { dark: null, light: null, hcDark: null, hcLight: null }, p("editorError.background", "Background color of error text in the editor. The color must not be opaque so as not to hide underlying decorations."), !0);
const Va = I("editorError.foreground", { dark: "#F14C4C", light: "#E51400", hcDark: "#F48771", hcLight: "#B5200D" }, p("editorError.foreground", "Foreground color of error squigglies in the editor.")), wG = I("editorError.border", { dark: null, light: null, hcDark: z.fromHex("#E47777").transparent(0.8), hcLight: "#B5200D" }, p("errorBorder", "If set, color of double underlines for errors in the editor.")), lC = I("editorWarning.background", { dark: null, light: null, hcDark: null, hcLight: null }, p("editorWarning.background", "Background color of warning text in the editor. The color must not be opaque so as not to hide underlying decorations."), !0), Kn = I("editorWarning.foreground", { dark: "#CCA700", light: "#BF8803", hcDark: "#FFD370", hcLight: "#895503" }, p("editorWarning.foreground", "Foreground color of warning squigglies in the editor.")), U_ = I("editorWarning.border", { dark: null, light: null, hcDark: z.fromHex("#FFCC00").transparent(0.8), hcLight: z.fromHex("#FFCC00").transparent(0.8) }, p("warningBorder", "If set, color of double underlines for warnings in the editor."));
I("editorInfo.background", { dark: null, light: null, hcDark: null, hcLight: null }, p("editorInfo.background", "Background color of info text in the editor. The color must not be opaque so as not to hide underlying decorations."), !0);
const ws = I("editorInfo.foreground", { dark: "#3794FF", light: "#1a85ff", hcDark: "#3794FF", hcLight: "#1a85ff" }, p("editorInfo.foreground", "Foreground color of info squigglies in the editor.")), $_ = I("editorInfo.border", { dark: null, light: null, hcDark: z.fromHex("#3794FF").transparent(0.8), hcLight: "#292929" }, p("infoBorder", "If set, color of double underlines for infos in the editor.")), SG = I("editorHint.foreground", { dark: z.fromHex("#eeeeee").transparent(0.7), light: "#6c6c6c", hcDark: null, hcLight: null }, p("editorHint.foreground", "Foreground color of hint squigglies in the editor."));
I("editorHint.border", { dark: null, light: null, hcDark: z.fromHex("#eeeeee").transparent(0.8), hcLight: "#292929" }, p("hintBorder", "If set, color of double underlines for hints in the editor."));
const yG = I("editorLink.activeForeground", { dark: "#4E94CE", light: z.blue, hcDark: z.cyan, hcLight: "#292929" }, p("activeLinkForeground", "Color of active links.")), ec = I("editor.selectionBackground", { light: "#ADD6FF", dark: "#264F78", hcDark: "#f3f518", hcLight: "#0F4A85" }, p("editorSelectionBackground", "Color of the editor selection.")), LG = I("editor.selectionForeground", { light: null, dark: null, hcDark: "#000000", hcLight: z.white }, p("editorSelectionForeground", "Color of the selected text for high contrast.")), IV = I("editor.inactiveSelectionBackground", { light: ve(ec, 0.5), dark: ve(ec, 0.5), hcDark: ve(ec, 0.7), hcLight: ve(ec, 0.5) }, p("editorInactiveSelection", "Color of the selection in an inactive editor. The color must not be opaque so as not to hide underlying decorations."), !0), b1 = I("editor.selectionHighlightBackground", { light: nP(ec, Gi, 0.3, 0.6), dark: nP(ec, Gi, 0.3, 0.6), hcDark: null, hcLight: null }, p("editorSelectionHighlight", "Color for regions with the same content as the selection. The color must not be opaque so as not to hide underlying decorations."), !0);
I("editor.selectionHighlightBorder", { light: null, dark: null, hcDark: Gt, hcLight: Gt }, p("editorSelectionHighlightBorder", "Border color for regions with the same content as the selection."));
I("editor.findMatchBackground", { light: "#A8AC94", dark: "#515C6A", hcDark: null, hcLight: null }, p("editorFindMatch", "Color of the current search match."));
const DG = I("editor.findMatchForeground", { light: null, dark: null, hcDark: null, hcLight: null }, p("editorFindMatchForeground", "Text color of the current search match.")), Ul = I("editor.findMatchHighlightBackground", { light: "#EA5C0055", dark: "#EA5C0055", hcDark: null, hcLight: null }, p("findMatchHighlight", "Color of the other search matches. The color must not be opaque so as not to hide underlying decorations."), !0), kG = I("editor.findMatchHighlightForeground", { light: null, dark: null, hcDark: null, hcLight: null }, p("findMatchHighlightForeground", "Foreground color of the other search matches."), !0);
I("editor.findRangeHighlightBackground", { dark: "#3a3d4166", light: "#b4b4b44d", hcDark: null, hcLight: null }, p("findRangeHighlight", "Color of the range limiting the search. The color must not be opaque so as not to hide underlying decorations."), !0);
I("editor.findMatchBorder", { light: null, dark: null, hcDark: Gt, hcLight: Gt }, p("editorFindMatchBorder", "Border color of the current search match."));
const tc = I("editor.findMatchHighlightBorder", { light: null, dark: null, hcDark: Gt, hcLight: Gt }, p("findMatchHighlightBorder", "Border color of the other search matches.")), xG = I("editor.findRangeHighlightBorder", { dark: null, light: null, hcDark: ve(Gt, 0.4), hcLight: ve(Gt, 0.4) }, p("findRangeHighlightBorder", "Border color of the range limiting the search. The color must not be opaque so as not to hide underlying decorations."), !0);
I("editor.hoverHighlightBackground", { light: "#ADD6FF26", dark: "#264f7840", hcDark: "#ADD6FF26", hcLight: null }, p("hoverHighlight", "Highlight below the word for which a hover is shown. The color must not be opaque so as not to hide underlying decorations."), !0);
const CS = I("editorHoverWidget.background", { light: Di, dark: Di, hcDark: Di, hcLight: Di }, p("hoverBackground", "Background color of the editor hover."));
I("editorHoverWidget.foreground", { light: Vl, dark: Vl, hcDark: Vl, hcLight: Vl }, p("hoverForeground", "Foreground color of the editor hover."));
const EV = I("editorHoverWidget.border", { light: zl, dark: zl, hcDark: zl, hcLight: zl }, p("hoverBorder", "Border color of the editor hover."));
I("editorHoverWidget.statusBarBackground", { dark: Kr(CS, 0.2), light: Ju(CS, 0.05), hcDark: Di, hcLight: Di }, p("statusBarBackground", "Background color of the editor hover status bar."));
const $l = I("editorInlayHint.foreground", { dark: "#969696", light: "#969696", hcDark: z.white, hcLight: z.black }, p("editorInlayHintForeground", "Foreground color of inline hints")), Kl = I("editorInlayHint.background", { dark: ve(Nw, 0.1), light: ve(Nw, 0.1), hcDark: ve(z.white, 0.1), hcLight: ve(Nw, 0.1) }, p("editorInlayHintBackground", "Background color of inline hints")), IG = I("editorInlayHint.typeForeground", { dark: $l, light: $l, hcDark: $l, hcLight: $l }, p("editorInlayHintForegroundTypes", "Foreground color of inline hints for types")), EG = I("editorInlayHint.typeBackground", { dark: Kl, light: Kl, hcDark: Kl, hcLight: Kl }, p("editorInlayHintBackgroundTypes", "Background color of inline hints for types")), TG = I("editorInlayHint.parameterForeground", { dark: $l, light: $l, hcDark: $l, hcLight: $l }, p("editorInlayHintForegroundParameter", "Foreground color of inline hints for parameters")), NG = I("editorInlayHint.parameterBackground", { dark: Kl, light: Kl, hcDark: Kl, hcLight: Kl }, p("editorInlayHintBackgroundParameter", "Background color of inline hints for parameters")), dC = I("editorLightBulb.foreground", { dark: "#FFCC00", light: "#DDB100", hcDark: "#FFCC00", hcLight: "#007ACC" }, p("editorLightBulbForeground", "The color used for the lightbulb actions icon."));
I("editorLightBulbAutoFix.foreground", { dark: "#75BEFF", light: "#007ACC", hcDark: "#75BEFF", hcLight: "#007ACC" }, p("editorLightBulbAutoFixForeground", "The color used for the lightbulb auto fix actions icon."));
I("editorLightBulbAi.foreground", { dark: dC, light: dC, hcDark: dC, hcLight: dC }, p("editorLightBulbAiForeground", "The color used for the lightbulb AI icon."));
I("editor.snippetTabstopHighlightBackground", { dark: new z(new Qt(124, 124, 124, 0.3)), light: new z(new Qt(10, 50, 100, 0.2)), hcDark: new z(new Qt(124, 124, 124, 0.3)), hcLight: new z(new Qt(10, 50, 100, 0.2)) }, p("snippetTabstopHighlightBackground", "Highlight background color of a snippet tabstop."));
I("editor.snippetTabstopHighlightBorder", { dark: null, light: null, hcDark: null, hcLight: null }, p("snippetTabstopHighlightBorder", "Highlight border color of a snippet tabstop."));
I("editor.snippetFinalTabstopHighlightBackground", { dark: null, light: null, hcDark: null, hcLight: null }, p("snippetFinalTabstopHighlightBackground", "Highlight background color of the final tabstop of a snippet."));
I("editor.snippetFinalTabstopHighlightBorder", { dark: "#525252", light: new z(new Qt(10, 50, 100, 0.5)), hcDark: "#525252", hcLight: "#292929" }, p("snippetFinalTabstopHighlightBorder", "Highlight border color of the final tabstop of a snippet."));
const $x = new z(new Qt(155, 185, 85, 0.2)), Kx = new z(new Qt(255, 0, 0, 0.2)), MG = I("diffEditor.insertedTextBackground", { dark: "#9ccc2c33", light: "#9ccc2c40", hcDark: null, hcLight: null }, p("diffEditorInserted", "Background color for text that got inserted. The color must not be opaque so as not to hide underlying decorations."), !0), RG = I("diffEditor.removedTextBackground", { dark: "#ff000033", light: "#ff000033", hcDark: null, hcLight: null }, p("diffEditorRemoved", "Background color for text that got removed. The color must not be opaque so as not to hide underlying decorations."), !0);
I("diffEditor.insertedLineBackground", { dark: $x, light: $x, hcDark: null, hcLight: null }, p("diffEditorInsertedLines", "Background color for lines that got inserted. The color must not be opaque so as not to hide underlying decorations."), !0);
I("diffEditor.removedLineBackground", { dark: Kx, light: Kx, hcDark: null, hcLight: null }, p("diffEditorRemovedLines", "Background color for lines that got removed. The color must not be opaque so as not to hide underlying decorations."), !0);
I("diffEditorGutter.insertedLineBackground", { dark: null, light: null, hcDark: null, hcLight: null }, p("diffEditorInsertedLineGutter", "Background color for the margin where lines got inserted."));
I("diffEditorGutter.removedLineBackground", { dark: null, light: null, hcDark: null, hcLight: null }, p("diffEditorRemovedLineGutter", "Background color for the margin where lines got removed."));
const AG = I("diffEditorOverview.insertedForeground", { dark: null, light: null, hcDark: null, hcLight: null }, p("diffEditorOverviewInserted", "Diff overview ruler foreground for inserted content.")), PG = I("diffEditorOverview.removedForeground", { dark: null, light: null, hcDark: null, hcLight: null }, p("diffEditorOverviewRemoved", "Diff overview ruler foreground for removed content."));
I("diffEditor.insertedTextBorder", { dark: null, light: null, hcDark: "#33ff2eff", hcLight: "#374E06" }, p("diffEditorInsertedOutline", "Outline color for the text that got inserted."));
I("diffEditor.removedTextBorder", { dark: null, light: null, hcDark: "#FF008F", hcLight: "#AD0707" }, p("diffEditorRemovedOutline", "Outline color for text that got removed."));
I("diffEditor.border", { dark: null, light: null, hcDark: it, hcLight: it }, p("diffEditorBorder", "Border color between the two text editors."));
I("diffEditor.diagonalFill", { dark: "#cccccc33", light: "#22222233", hcDark: null, hcLight: null }, p("diffDiagonalFill", "Color of the diff editor's diagonal fill. The diagonal fill is used in side-by-side diff views."));
I("diffEditor.unchangedRegionBackground", { dark: "sideBar.background", light: "sideBar.background", hcDark: "sideBar.background", hcLight: "sideBar.background" }, p("diffEditor.unchangedRegionBackground", "The background color of unchanged blocks in the diff editor."));
I("diffEditor.unchangedRegionForeground", { dark: "foreground", light: "foreground", hcDark: "foreground", hcLight: "foreground" }, p("diffEditor.unchangedRegionForeground", "The foreground color of unchanged blocks in the diff editor."));
I("diffEditor.unchangedCodeBackground", { dark: "#74747429", light: "#b8b8b829", hcDark: null, hcLight: null }, p("diffEditor.unchangedCodeBackground", "The background color of unchanged code in the diff editor."));
const jl = I("widget.shadow", { dark: ve(z.black, 0.36), light: ve(z.black, 0.16), hcDark: null, hcLight: null }, p("widgetShadow", "Shadow color of widgets such as find/replace inside the editor.")), TV = I("widget.border", { dark: null, light: null, hcDark: it, hcLight: it }, p("widgetBorder", "Border color of widgets such as find/replace inside the editor.")), oP = I("toolbar.hoverBackground", { dark: "#5a5d5e50", light: "#b8b8b850", hcDark: null, hcLight: null }, p("toolbarHoverBackground", "Toolbar background when hovering over actions using the mouse"));
I("toolbar.hoverOutline", { dark: null, light: null, hcDark: Gt, hcLight: Gt }, p("toolbarHoverOutline", "Toolbar outline when hovering over actions using the mouse"));
I("toolbar.activeBackground", { dark: Kr(oP, 0.1), light: Ju(oP, 0.1), hcDark: null, hcLight: null }, p("toolbarActiveBackground", "Toolbar background when holding the mouse over actions"));
const OG = I("breadcrumb.foreground", { light: ve(ie, 0.8), dark: ve(ie, 0.8), hcDark: ve(ie, 0.8), hcLight: ve(ie, 0.8) }, p("breadcrumbsFocusForeground", "Color of focused breadcrumb items.")), FG = I("breadcrumb.background", { light: Gi, dark: Gi, hcDark: Gi, hcLight: Gi }, p("breadcrumbsBackground", "Background color of breadcrumb items.")), rP = I("breadcrumb.focusForeground", { light: Ju(ie, 0.2), dark: Kr(ie, 0.1), hcDark: Kr(ie, 0.1), hcLight: Kr(ie, 0.1) }, p("breadcrumbsFocusForeground", "Color of focused breadcrumb items.")), WG = I("breadcrumb.activeSelectionForeground", { light: Ju(ie, 0.2), dark: Kr(ie, 0.1), hcDark: Kr(ie, 0.1), hcLight: Kr(ie, 0.1) }, p("breadcrumbsSelectedForeground", "Color of selected breadcrumb items."));
I("breadcrumbPicker.background", { light: Di, dark: Di, hcDark: Di, hcLight: Di }, p("breadcrumbsSelectedBackground", "Background color of breadcrumb item picker."));
const NV = 0.5, aP = z.fromHex("#40C8AE").transparent(NV), lP = z.fromHex("#40A6FF").transparent(NV), dP = z.fromHex("#606060").transparent(0.4), ar = 0.4, $f = 1, $g = I("merge.currentHeaderBackground", { dark: aP, light: aP, hcDark: null, hcLight: null }, p("mergeCurrentHeaderBackground", "Current header background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations."), !0);
I("merge.currentContentBackground", { dark: ve($g, ar), light: ve($g, ar), hcDark: ve($g, ar), hcLight: ve($g, ar) }, p("mergeCurrentContentBackground", "Current content background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations."), !0);
const Kg = I("merge.incomingHeaderBackground", { dark: lP, light: lP, hcDark: null, hcLight: null }, p("mergeIncomingHeaderBackground", "Incoming header background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations."), !0);
I("merge.incomingContentBackground", { dark: ve(Kg, ar), light: ve(Kg, ar), hcDark: ve(Kg, ar), hcLight: ve(Kg, ar) }, p("mergeIncomingContentBackground", "Incoming content background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations."), !0);
const jg = I("merge.commonHeaderBackground", { dark: dP, light: dP, hcDark: null, hcLight: null }, p("mergeCommonHeaderBackground", "Common ancestor header background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations."), !0);
I("merge.commonContentBackground", { dark: ve(jg, ar), light: ve(jg, ar), hcDark: ve(jg, ar), hcLight: ve(jg, ar) }, p("mergeCommonContentBackground", "Common ancestor content background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations."), !0);
const Kf = I("merge.border", { dark: null, light: null, hcDark: "#C3DF6F", hcLight: "#007ACC" }, p("mergeBorder", "Border color on headers and the splitter in inline merge-conflicts."));
I("editorOverviewRuler.currentContentForeground", { dark: ve($g, $f), light: ve($g, $f), hcDark: Kf, hcLight: Kf }, p("overviewRulerCurrentContentForeground", "Current overview ruler foreground for inline merge-conflicts."));
I("editorOverviewRuler.incomingContentForeground", { dark: ve(Kg, $f), light: ve(Kg, $f), hcDark: Kf, hcLight: Kf }, p("overviewRulerIncomingContentForeground", "Incoming overview ruler foreground for inline merge-conflicts."));
I("editorOverviewRuler.commonContentForeground", { dark: ve(jg, $f), light: ve(jg, $f), hcDark: Kf, hcLight: Kf }, p("overviewRulerCommonContentForeground", "Common ancestor overview ruler foreground for inline merge-conflicts."));
const C1 = I("editorOverviewRuler.findMatchForeground", { dark: "#d186167e", light: "#d186167e", hcDark: "#AB5A00", hcLight: "" }, p("overviewRulerFindMatchForeground", "Overview ruler marker color for find matches. The color must not be opaque so as not to hide underlying decorations."), !0), Em = I("editorOverviewRuler.selectionHighlightForeground", { dark: "#A0A0A0CC", light: "#A0A0A0CC", hcDark: "#A0A0A0CC", hcLight: "#A0A0A0CC" }, p("overviewRulerSelectionHighlightForeground", "Overview ruler marker color for selection highlights. The color must not be opaque so as not to hide underlying decorations."), !0), BG = I("problemsErrorIcon.foreground", { dark: Va, light: Va, hcDark: Va, hcLight: Va }, p("problemsErrorIconForeground", "The color used for the problems error icon.")), HG = I("problemsWarningIcon.foreground", { dark: Kn, light: Kn, hcDark: Kn, hcLight: Kn }, p("problemsWarningIconForeground", "The color used for the problems warning icon.")), VG = I("problemsInfoIcon.foreground", { dark: ws, light: ws, hcDark: ws, hcLight: ws }, p("problemsInfoIconForeground", "The color used for the problems info icon.")), qg = I("minimap.findMatchHighlight", { light: "#d18616", dark: "#d18616", hcDark: "#AB5A00", hcLight: "#0F4A85" }, p("minimapFindMatchHighlight", "Minimap marker color for find matches."), !0), D0 = I("minimap.selectionOccurrenceHighlight", { light: "#c9c9c9", dark: "#676767", hcDark: "#ffffff", hcLight: "#0F4A85" }, p("minimapSelectionOccurrenceHighlight", "Minimap marker color for repeating editor selections."), !0), cP = I("minimap.selectionHighlight", { light: "#ADD6FF", dark: "#264F78", hcDark: "#ffffff", hcLight: "#0F4A85" }, p("minimapSelectionHighlight", "Minimap marker color for the editor selection."), !0), zG = I("minimap.infoHighlight", { dark: ws, light: ws, hcDark: $_, hcLight: $_ }, p("minimapInfo", "Minimap marker color for infos.")), UG = I("minimap.warningHighlight", { dark: Kn, light: Kn, hcDark: U_, hcLight: U_ }, p("overviewRuleWarning", "Minimap marker color for warnings.")), $G = I("minimap.errorHighlight", { dark: new z(new Qt(255, 18, 18, 0.7)), light: new z(new Qt(255, 18, 18, 0.7)), hcDark: new z(new Qt(255, 50, 50, 1)), hcLight: "#B5200D" }, p("minimapError", "Minimap marker color for errors.")), KG = I("minimap.background", { dark: null, light: null, hcDark: null, hcLight: null }, p("minimapBackground", "Minimap background color.")), jG = I("minimap.foregroundOpacity", { dark: z.fromHex("#000f"), light: z.fromHex("#000f"), hcDark: z.fromHex("#000f"), hcLight: z.fromHex("#000f") }, p("minimapForegroundOpacity", 'Opacity of foreground elements rendered in the minimap. For example, "#000000c0" will render the elements with 75% opacity.'));
I("minimapSlider.background", { light: ve(km, 0.5), dark: ve(km, 0.5), hcDark: ve(km, 0.5), hcLight: ve(km, 0.5) }, p("minimapSliderBackground", "Minimap slider background color."));
I("minimapSlider.hoverBackground", { light: ve(xm, 0.5), dark: ve(xm, 0.5), hcDark: ve(xm, 0.5), hcLight: ve(xm, 0.5) }, p("minimapSliderHoverBackground", "Minimap slider background color when hovering."));
I("minimapSlider.activeBackground", { light: ve(Im, 0.5), dark: ve(Im, 0.5), hcDark: ve(Im, 0.5), hcLight: ve(Im, 0.5) }, p("minimapSliderActiveBackground", "Minimap slider background color when clicked on."));
I("charts.foreground", { dark: ie, light: ie, hcDark: ie, hcLight: ie }, p("chartsForeground", "The foreground color used in charts."));
I("charts.lines", { dark: ve(ie, 0.5), light: ve(ie, 0.5), hcDark: ve(ie, 0.5), hcLight: ve(ie, 0.5) }, p("chartsLines", "The color used for horizontal lines in charts."));
I("charts.red", { dark: Va, light: Va, hcDark: Va, hcLight: Va }, p("chartsRed", "The red color used in chart visualizations."));
I("charts.blue", { dark: ws, light: ws, hcDark: ws, hcLight: ws }, p("chartsBlue", "The blue color used in chart visualizations."));
I("charts.yellow", { dark: Kn, light: Kn, hcDark: Kn, hcLight: Kn }, p("chartsYellow", "The yellow color used in chart visualizations."));
I("charts.orange", { dark: qg, light: qg, hcDark: qg, hcLight: qg }, p("chartsOrange", "The orange color used in chart visualizations."));
I("charts.green", { dark: "#89D185", light: "#388A34", hcDark: "#89D185", hcLight: "#374e06" }, p("chartsGreen", "The green color used in chart visualizations."));
I("charts.purple", { dark: "#B180D7", light: "#652D90", hcDark: "#B180D7", hcLight: "#652D90" }, p("chartsPurple", "The purple color used in chart visualizations."));
const jx = I("input.background", { dark: "#3C3C3C", light: z.white, hcDark: z.black, hcLight: z.white }, p("inputBoxBackground", "Input box background.")), MV = I("input.foreground", { dark: ie, light: ie, hcDark: ie, hcLight: ie }, p("inputBoxForeground", "Input box foreground.")), RV = I("input.border", { dark: null, light: null, hcDark: it, hcLight: it }, p("inputBoxBorder", "Input box border.")), w1 = I("inputOption.activeBorder", { dark: "#007ACC", light: "#007ACC", hcDark: it, hcLight: it }, p("inputBoxActiveOptionBorder", "Border color of activated options in input fields."));
I("inputOption.hoverBackground", { dark: "#5a5d5e80", light: "#b8b8b850", hcDark: null, hcLight: null }, p("inputOption.hoverBackground", "Background color of activated options in input fields."));
const Gh = I("inputOption.activeBackground", { dark: ve(To, 0.4), light: ve(To, 0.2), hcDark: z.transparent, hcLight: z.transparent }, p("inputOption.activeBackground", "Background hover color of options in input fields.")), S1 = I("inputOption.activeForeground", { dark: z.white, light: z.black, hcDark: ie, hcLight: ie }, p("inputOption.activeForeground", "Foreground color of activated options in input fields."));
I("input.placeholderForeground", { light: ve(ie, 0.5), dark: ve(ie, 0.5), hcDark: ve(ie, 0.7), hcLight: ve(ie, 0.7) }, p("inputPlaceholderForeground", "Input box foreground color for placeholder text."));
const qG = I("inputValidation.infoBackground", { dark: "#063B49", light: "#D6ECF2", hcDark: z.black, hcLight: z.white }, p("inputValidationInfoBackground", "Input validation background color for information severity.")), GG = I("inputValidation.infoForeground", { dark: null, light: null, hcDark: null, hcLight: ie }, p("inputValidationInfoForeground", "Input validation foreground color for information severity.")), ZG = I("inputValidation.infoBorder", { dark: "#007acc", light: "#007acc", hcDark: it, hcLight: it }, p("inputValidationInfoBorder", "Input validation border color for information severity.")), YG = I("inputValidation.warningBackground", { dark: "#352A05", light: "#F6F5D2", hcDark: z.black, hcLight: z.white }, p("inputValidationWarningBackground", "Input validation background color for warning severity.")), QG = I("inputValidation.warningForeground", { dark: null, light: null, hcDark: null, hcLight: ie }, p("inputValidationWarningForeground", "Input validation foreground color for warning severity.")), XG = I("inputValidation.warningBorder", { dark: "#B89500", light: "#B89500", hcDark: it, hcLight: it }, p("inputValidationWarningBorder", "Input validation border color for warning severity.")), JG = I("inputValidation.errorBackground", { dark: "#5A1D1D", light: "#F2DEDE", hcDark: z.black, hcLight: z.white }, p("inputValidationErrorBackground", "Input validation background color for error severity.")), e9 = I("inputValidation.errorForeground", { dark: null, light: null, hcDark: null, hcLight: ie }, p("inputValidationErrorForeground", "Input validation foreground color for error severity.")), t9 = I("inputValidation.errorBorder", { dark: "#BE1100", light: "#BE1100", hcDark: it, hcLight: it }, p("inputValidationErrorBorder", "Input validation border color for error severity.")), za = I("dropdown.background", { dark: "#3C3C3C", light: z.white, hcDark: z.black, hcLight: z.white }, p("dropdownBackground", "Dropdown background.")), i9 = I("dropdown.listBackground", { dark: null, light: null, hcDark: z.black, hcLight: z.white }, p("dropdownListBackground", "Dropdown list background.")), ql = I("dropdown.foreground", { dark: "#F0F0F0", light: ie, hcDark: z.white, hcLight: ie }, p("dropdownForeground", "Dropdown foreground.")), Gg = I("dropdown.border", { dark: za, light: "#CECECE", hcDark: it, hcLight: it }, p("dropdownBorder", "Dropdown border.")), Tm = I("button.foreground", { dark: z.white, light: z.white, hcDark: z.white, hcLight: z.white }, p("buttonForeground", "Button foreground color.")), n9 = I("button.separator", { dark: ve(Tm, 0.4), light: ve(Tm, 0.4), hcDark: ve(Tm, 0.4), hcLight: ve(Tm, 0.4) }, p("buttonSeparator", "Button separator color.")), Nm = I("button.background", { dark: "#0E639C", light: "#007ACC", hcDark: null, hcLight: "#0F4A85" }, p("buttonBackground", "Button background color.")), s9 = I("button.hoverBackground", { dark: Kr(Nm, 0.2), light: Ju(Nm, 0.2), hcDark: Nm, hcLight: Nm }, p("buttonHoverBackground", "Button background color when hovering.")), o9 = I("button.border", { dark: it, light: it, hcDark: it, hcLight: it }, p("buttonBorder", "Button border color.")), r9 = I("button.secondaryForeground", { dark: z.white, light: z.white, hcDark: z.white, hcLight: ie }, p("buttonSecondaryForeground", "Secondary button foreground color.")), qx = I("button.secondaryBackground", { dark: "#3A3D41", light: "#5F6A79", hcDark: null, hcLight: z.white }, p("buttonSecondaryBackground", "Secondary button background color.")), a9 = I("button.secondaryHoverBackground", { dark: Kr(qx, 0.2), light: Ju(qx, 0.2), hcDark: null, hcLight: null }, p("buttonSecondaryHoverBackground", "Secondary button background color when hovering.")), l9 = I("checkbox.background", { dark: za, light: za, hcDark: za, hcLight: za }, p("checkbox.background", "Background color of checkbox widget."));
I("checkbox.selectBackground", { dark: Di, light: Di, hcDark: Di, hcLight: Di }, p("checkbox.select.background", "Background color of checkbox widget when the element it's in is selected."));
const d9 = I("checkbox.foreground", { dark: ql, light: ql, hcDark: ql, hcLight: ql }, p("checkbox.foreground", "Foreground color of checkbox widget.")), c9 = I("checkbox.border", { dark: Gg, light: Gg, hcDark: Gg, hcLight: Gg }, p("checkbox.border", "Border color of checkbox widget."));
I("checkbox.selectBorder", { dark: Ha, light: Ha, hcDark: Ha, hcLight: Ha }, p("checkbox.select.border", "Border color of checkbox widget when the element it's in is selected."));
const h9 = I("keybindingLabel.background", { dark: new z(new Qt(128, 128, 128, 0.17)), light: new z(new Qt(221, 221, 221, 0.4)), hcDark: z.transparent, hcLight: z.transparent }, p("keybindingLabelBackground", "Keybinding label background color. The keybinding label is used to represent a keyboard shortcut.")), u9 = I("keybindingLabel.foreground", { dark: z.fromHex("#CCCCCC"), light: z.fromHex("#555555"), hcDark: z.white, hcLight: ie }, p("keybindingLabelForeground", "Keybinding label foreground color. The keybinding label is used to represent a keyboard shortcut.")), g9 = I("keybindingLabel.border", { dark: new z(new Qt(51, 51, 51, 0.6)), light: new z(new Qt(204, 204, 204, 0.4)), hcDark: new z(new Qt(111, 195, 223)), hcLight: it }, p("keybindingLabelBorder", "Keybinding label border color. The keybinding label is used to represent a keyboard shortcut.")), f9 = I("keybindingLabel.bottomBorder", { dark: new z(new Qt(68, 68, 68, 0.6)), light: new z(new Qt(187, 187, 187, 0.4)), hcDark: new z(new Qt(111, 195, 223)), hcLight: ie }, p("keybindingLabelBottomBorder", "Keybinding label border bottom color. The keybinding label is used to represent a keyboard shortcut.")), p9 = I("list.focusBackground", { dark: null, light: null, hcDark: null, hcLight: null }, p("listFocusBackground", "List/Tree background color for the focused item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not.")), m9 = I("list.focusForeground", { dark: null, light: null, hcDark: null, hcLight: null }, p("listFocusForeground", "List/Tree foreground color for the focused item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not.")), _9 = I("list.focusOutline", { dark: To, light: To, hcDark: Gt, hcLight: Gt }, p("listFocusOutline", "List/Tree outline color for the focused item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not.")), v9 = I("list.focusAndSelectionOutline", { dark: null, light: null, hcDark: null, hcLight: null }, p("listFocusAndSelectionOutline", "List/Tree outline color for the focused item when the list/tree is active and selected. An active list/tree has keyboard focus, an inactive does not.")), Gl = I("list.activeSelectionBackground", { dark: "#04395E", light: "#0060C0", hcDark: null, hcLight: z.fromHex("#0F4A85").transparent(0.1) }, p("listActiveSelectionBackground", "List/Tree background color for the selected item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not.")), Ua = I("list.activeSelectionForeground", { dark: z.white, light: z.white, hcDark: null, hcLight: null }, p("listActiveSelectionForeground", "List/Tree foreground color for the selected item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not.")), Mm = I("list.activeSelectionIconForeground", { dark: null, light: null, hcDark: null, hcLight: null }, p("listActiveSelectionIconForeground", "List/Tree icon foreground color for the selected item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not.")), b9 = I("list.inactiveSelectionBackground", { dark: "#37373D", light: "#E4E6F1", hcDark: null, hcLight: z.fromHex("#0F4A85").transparent(0.1) }, p("listInactiveSelectionBackground", "List/Tree background color for the selected item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not.")), C9 = I("list.inactiveSelectionForeground", { dark: null, light: null, hcDark: null, hcLight: null }, p("listInactiveSelectionForeground", "List/Tree foreground color for the selected item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not.")), w9 = I("list.inactiveSelectionIconForeground", { dark: null, light: null, hcDark: null, hcLight: null }, p("listInactiveSelectionIconForeground", "List/Tree icon foreground color for the selected item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not.")), S9 = I("list.inactiveFocusBackground", { dark: null, light: null, hcDark: null, hcLight: null }, p("listInactiveFocusBackground", "List/Tree background color for the focused item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not.")), y9 = I("list.inactiveFocusOutline", { dark: null, light: null, hcDark: null, hcLight: null }, p("listInactiveFocusOutline", "List/Tree outline color for the focused item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not.")), AV = I("list.hoverBackground", { dark: "#2A2D2E", light: "#F0F0F0", hcDark: z.white.transparent(0.1), hcLight: z.fromHex("#0F4A85").transparent(0.1) }, p("listHoverBackground", "List/Tree background when hovering over items using the mouse.")), PV = I("list.hoverForeground", { dark: null, light: null, hcDark: null, hcLight: null }, p("listHoverForeground", "List/Tree foreground when hovering over items using the mouse.")), L9 = I("list.dropBackground", { dark: "#062F4A", light: "#D6EBFF", hcDark: null, hcLight: null }, p("listDropBackground", "List/Tree drag and drop background when moving items over other items when using the mouse.")), D9 = I("list.dropBetweenBackground", { dark: Ha, light: Ha, hcDark: null, hcLight: null }, p("listDropBetweenBackground", "List/Tree drag and drop border color when moving items between items when using the mouse.")), lr = I("list.highlightForeground", { dark: "#2AAAFF", light: "#0066BF", hcDark: To, hcLight: To }, p("highlight", "List/Tree foreground color of the match highlights when searching inside the list/tree.")), cC = I("list.focusHighlightForeground", { dark: lr, light: _G(Gl, lr, "#BBE7FF"), hcDark: lr, hcLight: lr }, p("listFocusHighlightForeground", "List/Tree foreground color of the match highlights on actively focused items when searching inside the list/tree."));
I("list.invalidItemForeground", { dark: "#B89500", light: "#B89500", hcDark: "#B89500", hcLight: "#B5200D" }, p("invalidItemForeground", "List/Tree foreground color for invalid items, for example an unresolved root in explorer."));
I("list.errorForeground", { dark: "#F88070", light: "#B01011", hcDark: null, hcLight: null }, p("listErrorForeground", "Foreground color of list items containing errors."));
I("list.warningForeground", { dark: "#CCA700", light: "#855F00", hcDark: null, hcLight: null }, p("listWarningForeground", "Foreground color of list items containing warnings."));
const k9 = I("listFilterWidget.background", { light: Ju(Di, 0), dark: Kr(Di, 0), hcDark: Di, hcLight: Di }, p("listFilterWidgetBackground", "Background color of the type filter widget in lists and trees.")), x9 = I("listFilterWidget.outline", { dark: z.transparent, light: z.transparent, hcDark: "#f38518", hcLight: "#007ACC" }, p("listFilterWidgetOutline", "Outline color of the type filter widget in lists and trees.")), I9 = I("listFilterWidget.noMatchesOutline", { dark: "#BE1100", light: "#BE1100", hcDark: it, hcLight: it }, p("listFilterWidgetNoMatchesOutline", "Outline color of the type filter widget in lists and trees, when there are no matches.")), E9 = I("listFilterWidget.shadow", { dark: jl, light: jl, hcDark: jl, hcLight: jl }, p("listFilterWidgetShadow", "Shadow color of the type filter widget in lists and trees."));
I("list.filterMatchBackground", { dark: Ul, light: Ul, hcDark: null, hcLight: null }, p("listFilterMatchHighlight", "Background color of the filtered match."));
I("list.filterMatchBorder", { dark: tc, light: tc, hcDark: it, hcLight: Gt }, p("listFilterMatchHighlightBorder", "Border color of the filtered match."));
I("list.deemphasizedForeground", { dark: "#8C8C8C", light: "#8E8E90", hcDark: "#A7A8A9", hcLight: "#666666" }, p("listDeemphasizedForeground", "List/Tree foreground color for items that are deemphasized."));
const Rm = I("tree.indentGuidesStroke", { dark: "#585858", light: "#a9a9a9", hcDark: "#a9a9a9", hcLight: "#a5a5a5" }, p("treeIndentGuidesStroke", "Tree stroke color for the indentation guides.")), T9 = I("tree.inactiveIndentGuidesStroke", { dark: ve(Rm, 0.4), light: ve(Rm, 0.4), hcDark: ve(Rm, 0.4), hcLight: ve(Rm, 0.4) }, p("treeInactiveIndentGuidesStroke", "Tree stroke color for the indentation guides that are not active.")), N9 = I("tree.tableColumnsBorder", { dark: "#CCCCCC20", light: "#61616120", hcDark: null, hcLight: null }, p("tableColumnsBorder", "Table border color between columns.")), M9 = I("tree.tableOddRowsBackground", { dark: ve(ie, 0.04), light: ve(ie, 0.04), hcDark: null, hcLight: null }, p("tableOddRowsBackgroundColor", "Background color for odd table rows.")), R9 = I("menu.border", { dark: null, light: null, hcDark: it, hcLight: it }, p("menuBorder", "Border color of menus.")), A9 = I("menu.foreground", { dark: ql, light: ql, hcDark: ql, hcLight: ql }, p("menuForeground", "Foreground color of menu items.")), P9 = I("menu.background", { dark: za, light: za, hcDark: za, hcLight: za }, p("menuBackground", "Background color of menu items.")), O9 = I("menu.selectionForeground", { dark: Ua, light: Ua, hcDark: Ua, hcLight: Ua }, p("menuSelectionForeground", "Foreground color of the selected menu item in menus.")), F9 = I("menu.selectionBackground", { dark: Gl, light: Gl, hcDark: Gl, hcLight: Gl }, p("menuSelectionBackground", "Background color of the selected menu item in menus.")), W9 = I("menu.selectionBorder", { dark: null, light: null, hcDark: Gt, hcLight: Gt }, p("menuSelectionBorder", "Border color of the selected menu item in menus.")), B9 = I("menu.separatorBackground", { dark: "#606060", light: "#D4D4D4", hcDark: it, hcLight: it }, p("menuSeparatorBackground", "Color of a separator menu item in menus.")), hP = I("quickInput.background", { dark: Di, light: Di, hcDark: Di, hcLight: Di }, p("pickerBackground", "Quick picker background color. The quick picker widget is the container for pickers like the command palette.")), H9 = I("quickInput.foreground", { dark: Vl, light: Vl, hcDark: Vl, hcLight: Vl }, p("pickerForeground", "Quick picker foreground color. The quick picker widget is the container for pickers like the command palette.")), V9 = I("quickInputTitle.background", { dark: new z(new Qt(255, 255, 255, 0.105)), light: new z(new Qt(0, 0, 0, 0.06)), hcDark: "#000000", hcLight: z.white }, p("pickerTitleBackground", "Quick picker title background color. The quick picker widget is the container for pickers like the command palette.")), OV = I("pickerGroup.foreground", { dark: "#3794FF", light: "#0066BF", hcDark: z.white, hcLight: "#0F4A85" }, p("pickerGroupForeground", "Quick picker color for grouping labels.")), z9 = I("pickerGroup.border", { dark: "#3F3F46", light: "#CCCEDB", hcDark: z.white, hcLight: "#0F4A85" }, p("pickerGroupBorder", "Quick picker color for grouping borders.")), uP = I("quickInput.list.focusBackground", { dark: null, light: null, hcDark: null, hcLight: null }, "", void 0, p("quickInput.list.focusBackground deprecation", "Please use quickInputList.focusBackground instead")), ic = I("quickInputList.focusForeground", { dark: Ua, light: Ua, hcDark: Ua, hcLight: Ua }, p("quickInput.listFocusForeground", "Quick picker foreground color for the focused item.")), Zg = I("quickInputList.focusIconForeground", { dark: Mm, light: Mm, hcDark: Mm, hcLight: Mm }, p("quickInput.listFocusIconForeground", "Quick picker icon foreground color for the focused item.")), nc = I("quickInputList.focusBackground", { dark: z_(uP, Gl), light: z_(uP, Gl), hcDark: null, hcLight: null }, p("quickInput.listFocusBackground", "Quick picker background color for the focused item."));
I("search.resultsInfoForeground", { light: ie, dark: ve(ie, 0.65), hcDark: ie, hcLight: ie }, p("search.resultsInfoForeground", "Color of the text in the search viewlet's completion message."));
I("searchEditor.findMatchBackground", { light: ve(Ul, 0.66), dark: ve(Ul, 0.66), hcDark: Ul, hcLight: Ul }, p("searchEditor.queryMatch", "Color of the Search Editor query matches."));
I("searchEditor.findMatchBorder", { light: ve(tc, 0.66), dark: ve(tc, 0.66), hcDark: tc, hcLight: tc }, p("searchEditor.editorFindMatchBorder", "Border color of the Search Editor query matches."));
class k0 {
  constructor(e, t) {
    this.x = e, this.y = t, this._pageCoordinatesBrand = void 0;
  }
  toClientCoordinates(e) {
    return new FV(this.x - e.scrollX, this.y - e.scrollY);
  }
}
class FV {
  constructor(e, t) {
    this.clientX = e, this.clientY = t, this._clientCoordinatesBrand = void 0;
  }
  toPageCoordinates(e) {
    return new k0(this.clientX + e.scrollX, this.clientY + e.scrollY);
  }
}
class U9 {
  constructor(e, t, i, n) {
    this.x = e, this.y = t, this.width = i, this.height = n, this._editorPagePositionBrand = void 0;
  }
}
class $9 {
  constructor(e, t) {
    this.x = e, this.y = t, this._positionRelativeToEditorBrand = void 0;
  }
}
function y1(r) {
  const e = Ei(r);
  return new U9(e.left, e.top, e.width, e.height);
}
function L1(r, e, t) {
  const i = e.width / r.offsetWidth, n = e.height / r.offsetHeight, s = (t.x - e.x) / i, o = (t.y - e.y) / n;
  return new $9(s, o);
}
class Pc extends rr {
  constructor(e, t, i) {
    super(we(i), e), this._editorMouseEventBrand = void 0, this.isFromPointerCapture = t, this.pos = new k0(this.posx, this.posy), this.editorPos = y1(i), this.relativePos = L1(i, this.editorPos, this.pos);
  }
}
class K9 {
  constructor(e) {
    this._editorViewDomNode = e;
  }
  _create(e) {
    return new Pc(e, !1, this._editorViewDomNode);
  }
  onContextMenu(e, t) {
    return W(e, "contextmenu", (i) => {
      t(this._create(i));
    });
  }
  onMouseUp(e, t) {
    return W(e, "mouseup", (i) => {
      t(this._create(i));
    });
  }
  onMouseDown(e, t) {
    return W(e, Q.MOUSE_DOWN, (i) => {
      t(this._create(i));
    });
  }
  onPointerDown(e, t) {
    return W(e, Q.POINTER_DOWN, (i) => {
      t(this._create(i), i.pointerId);
    });
  }
  onMouseLeave(e, t) {
    return W(e, Q.MOUSE_LEAVE, (i) => {
      t(this._create(i));
    });
  }
  onMouseMove(e, t) {
    return W(e, "mousemove", (i) => t(this._create(i)));
  }
}
class j9 {
  constructor(e) {
    this._editorViewDomNode = e;
  }
  _create(e) {
    return new Pc(e, !1, this._editorViewDomNode);
  }
  onPointerUp(e, t) {
    return W(e, "pointerup", (i) => {
      t(this._create(i));
    });
  }
  onPointerDown(e, t) {
    return W(e, Q.POINTER_DOWN, (i) => {
      t(this._create(i), i.pointerId);
    });
  }
  onPointerLeave(e, t) {
    return W(e, Q.POINTER_LEAVE, (i) => {
      t(this._create(i));
    });
  }
  onPointerMove(e, t) {
    return W(e, "pointermove", (i) => t(this._create(i)));
  }
}
class q9 extends P {
  constructor(e) {
    super(), this._editorViewDomNode = e, this._globalPointerMoveMonitor = this._register(new Np()), this._keydownListener = null;
  }
  startMonitoring(e, t, i, n, s) {
    this._keydownListener = pi(e.ownerDocument, "keydown", (o) => {
      o.toKeyCodeChord().isModifierKey() || this._globalPointerMoveMonitor.stopMonitoring(!0, o.browserEvent);
    }, !0), this._globalPointerMoveMonitor.startMonitoring(e, t, i, (o) => {
      n(new Pc(o, !0, this._editorViewDomNode));
    }, (o) => {
      this._keydownListener.dispose(), s(o);
    });
  }
  stopMonitoring() {
    this._globalPointerMoveMonitor.stopMonitoring(!0);
  }
}
class gb {
  constructor(e) {
    this._editor = e, this._instanceId = ++gb._idPool, this._counter = 0, this._rules = /* @__PURE__ */ new Map(), this._garbageCollectionScheduler = new xt(() => this.garbageCollect(), 1e3);
  }
  createClassNameRef(e) {
    const t = this.getOrCreateRule(e);
    return t.increaseRefCount(), {
      className: t.className,
      dispose: () => {
        t.decreaseRefCount(), this._garbageCollectionScheduler.schedule();
      }
    };
  }
  getOrCreateRule(e) {
    const t = this.computeUniqueKey(e);
    let i = this._rules.get(t);
    if (!i) {
      const n = this._counter++;
      i = new G9(t, `dyn-rule-${this._instanceId}-${n}`, uS(this._editor.getContainerDomNode()) ? this._editor.getContainerDomNode() : void 0, e), this._rules.set(t, i);
    }
    return i;
  }
  computeUniqueKey(e) {
    return JSON.stringify(e);
  }
  garbageCollect() {
    for (const e of this._rules.values())
      e.hasReferences() || (this._rules.delete(e.key), e.dispose());
  }
}
gb._idPool = 0;
class G9 {
  constructor(e, t, i, n) {
    this.key = e, this.className = t, this.properties = n, this._referenceCount = 0, this._styleElementDisposables = new q(), this._styleElement = fo(i, void 0, this._styleElementDisposables), this._styleElement.textContent = this.getCssText(this.className, this.properties);
  }
  getCssText(e, t) {
    let i = `.${e} {`;
    for (const n in t) {
      const s = t[n];
      let o;
      typeof s == "object" ? o = le(s.id) : o = s;
      const a = Z9(n);
      i += `
	${a}: ${o};`;
    }
    return i += `
}`, i;
  }
  dispose() {
    this._styleElementDisposables.dispose(), this._styleElement = void 0;
  }
  increaseRefCount() {
    this._referenceCount++;
  }
  decreaseRefCount() {
    this._referenceCount--;
  }
  hasReferences() {
    return this._referenceCount > 0;
  }
}
function Z9(r) {
  return r.replace(/(^[A-Z])/, ([e]) => e.toLowerCase()).replace(/([A-Z])/g, ([e]) => `-${e.toLowerCase()}`);
}
class fb extends P {
  constructor() {
    super(), this._shouldRender = !0;
  }
  shouldRender() {
    return this._shouldRender;
  }
  forceShouldRender() {
    this._shouldRender = !0;
  }
  setShouldRender() {
    this._shouldRender = !0;
  }
  onDidRender() {
    this._shouldRender = !1;
  }
  // --- begin event handlers
  onCompositionStart(e) {
    return !1;
  }
  onCompositionEnd(e) {
    return !1;
  }
  onConfigurationChanged(e) {
    return !1;
  }
  onCursorStateChanged(e) {
    return !1;
  }
  onDecorationsChanged(e) {
    return !1;
  }
  onFlushed(e) {
    return !1;
  }
  onFocusChanged(e) {
    return !1;
  }
  onLanguageConfigurationChanged(e) {
    return !1;
  }
  onLineMappingChanged(e) {
    return !1;
  }
  onLinesChanged(e) {
    return !1;
  }
  onLinesDeleted(e) {
    return !1;
  }
  onLinesInserted(e) {
    return !1;
  }
  onRevealRangeRequest(e) {
    return !1;
  }
  onScrollChanged(e) {
    return !1;
  }
  onThemeChanged(e) {
    return !1;
  }
  onTokensChanged(e) {
    return !1;
  }
  onTokensColorsChanged(e) {
    return !1;
  }
  onZonesChanged(e) {
    return !1;
  }
  // --- end event handlers
  handleEvents(e) {
    let t = !1;
    for (let i = 0, n = e.length; i < n; i++) {
      const s = e[i];
      switch (s.type) {
        case 0:
          this.onCompositionStart(s) && (t = !0);
          break;
        case 1:
          this.onCompositionEnd(s) && (t = !0);
          break;
        case 2:
          this.onConfigurationChanged(s) && (t = !0);
          break;
        case 3:
          this.onCursorStateChanged(s) && (t = !0);
          break;
        case 4:
          this.onDecorationsChanged(s) && (t = !0);
          break;
        case 5:
          this.onFlushed(s) && (t = !0);
          break;
        case 6:
          this.onFocusChanged(s) && (t = !0);
          break;
        case 7:
          this.onLanguageConfigurationChanged(s) && (t = !0);
          break;
        case 8:
          this.onLineMappingChanged(s) && (t = !0);
          break;
        case 9:
          this.onLinesChanged(s) && (t = !0);
          break;
        case 10:
          this.onLinesDeleted(s) && (t = !0);
          break;
        case 11:
          this.onLinesInserted(s) && (t = !0);
          break;
        case 12:
          this.onRevealRangeRequest(s) && (t = !0);
          break;
        case 13:
          this.onScrollChanged(s) && (t = !0);
          break;
        case 15:
          this.onTokensChanged(s) && (t = !0);
          break;
        case 14:
          this.onThemeChanged(s) && (t = !0);
          break;
        case 16:
          this.onTokensColorsChanged(s) && (t = !0);
          break;
        case 17:
          this.onZonesChanged(s) && (t = !0);
          break;
        default:
          console.info("View received unknown event: "), console.info(s);
      }
    }
    t && (this._shouldRender = !0);
  }
}
class Gs extends fb {
  constructor(e) {
    super(), this._context = e, this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this), super.dispose();
  }
}
class Jr {
  static write(e, t) {
    e.setAttribute("data-mprt", String(t));
  }
  static read(e) {
    const t = e.getAttribute("data-mprt");
    return t === null ? 0 : parseInt(t, 10);
  }
  static collect(e, t) {
    const i = [];
    let n = 0;
    for (; e && e !== e.ownerDocument.body && e !== t; )
      e.nodeType === e.ELEMENT_NODE && (i[n++] = this.read(e)), e = e.parentElement;
    const s = new Uint8Array(n);
    for (let o = 0; o < n; o++)
      s[o] = i[n - o - 1];
    return s;
  }
}
class Y9 {
  constructor(e, t) {
    this._restrictedRenderingContextBrand = void 0, this._viewLayout = e, this.viewportData = t, this.scrollWidth = this._viewLayout.getScrollWidth(), this.scrollHeight = this._viewLayout.getScrollHeight(), this.visibleRange = this.viewportData.visibleRange, this.bigNumbersDelta = this.viewportData.bigNumbersDelta;
    const i = this._viewLayout.getCurrentViewport();
    this.scrollTop = i.top, this.scrollLeft = i.left, this.viewportWidth = i.width, this.viewportHeight = i.height;
  }
  getScrolledTopFromAbsoluteTop(e) {
    return e - this.scrollTop;
  }
  getVerticalOffsetForLineNumber(e, t) {
    return this._viewLayout.getVerticalOffsetForLineNumber(e, t);
  }
  getVerticalOffsetAfterLineNumber(e, t) {
    return this._viewLayout.getVerticalOffsetAfterLineNumber(e, t);
  }
  getDecorationsInViewport() {
    return this.viewportData.getDecorationsInViewport();
  }
}
class Q9 extends Y9 {
  constructor(e, t, i) {
    super(e, t), this._renderingContextBrand = void 0, this._viewLines = i;
  }
  linesVisibleRangesForRange(e, t) {
    return this._viewLines.linesVisibleRangesForRange(e, t);
  }
  visibleRangeForPosition(e) {
    return this._viewLines.visibleRangeForPosition(e);
  }
}
class X9 {
  constructor(e, t, i, n) {
    this.outsideRenderedLine = e, this.lineNumber = t, this.ranges = i, this.continuesOnNextLine = n;
  }
}
class x0 {
  static from(e) {
    const t = new Array(e.length);
    for (let i = 0, n = e.length; i < n; i++) {
      const s = e[i];
      t[i] = new x0(s.left, s.width);
    }
    return t;
  }
  constructor(e, t) {
    this._horizontalRangeBrand = void 0, this.left = Math.round(e), this.width = Math.round(t);
  }
  toString() {
    return `[${this.left},${this.width}]`;
  }
}
class au {
  constructor(e, t) {
    this._floatHorizontalRangeBrand = void 0, this.left = e, this.width = t;
  }
  toString() {
    return `[${this.left},${this.width}]`;
  }
  static compare(e, t) {
    return e.left - t.left;
  }
}
class J9 {
  constructor(e, t) {
    this.outsideRenderedLine = e, this.originalLeft = t, this.left = Math.round(this.originalLeft);
  }
}
class gP {
  constructor(e, t) {
    this.outsideRenderedLine = e, this.ranges = t;
  }
}
class Mw {
  static _createRange() {
    return this._handyReadyRange || (this._handyReadyRange = document.createRange()), this._handyReadyRange;
  }
  static _detachRange(e, t) {
    e.selectNodeContents(t);
  }
  static _readClientRects(e, t, i, n, s) {
    const o = this._createRange();
    try {
      return o.setStart(e, t), o.setEnd(i, n), o.getClientRects();
    } catch {
      return null;
    } finally {
      this._detachRange(o, s);
    }
  }
  static _mergeAdjacentRanges(e) {
    if (e.length === 1)
      return e;
    e.sort(au.compare);
    const t = [];
    let i = 0, n = e[0];
    for (let s = 1, o = e.length; s < o; s++) {
      const a = e[s];
      n.left + n.width + 0.9 >= a.left ? n.width = Math.max(n.width, a.left + a.width - n.left) : (t[i++] = n, n = a);
    }
    return t[i++] = n, t;
  }
  static _createHorizontalRangesFromClientRects(e, t, i) {
    if (!e || e.length === 0)
      return null;
    const n = [];
    for (let s = 0, o = e.length; s < o; s++) {
      const a = e[s];
      n[s] = new au(Math.max(0, (a.left - t) / i), a.width / i);
    }
    return this._mergeAdjacentRanges(n);
  }
  static readHorizontalRanges(e, t, i, n, s, o) {
    const l = e.children.length - 1;
    if (0 > l)
      return null;
    if (t = Math.min(l, Math.max(0, t)), n = Math.min(l, Math.max(0, n)), t === n && i === s && i === 0 && !e.children[t].firstChild) {
      const u = e.children[t].getClientRects();
      return o.markDidDomLayout(), this._createHorizontalRangesFromClientRects(u, o.clientRectDeltaLeft, o.clientRectScale);
    }
    t !== n && n > 0 && s === 0 && (n--, s = 1073741824);
    let d = e.children[t].firstChild, c = e.children[n].firstChild;
    if ((!d || !c) && (!d && i === 0 && t > 0 && (d = e.children[t - 1].firstChild, i = 1073741824), !c && s === 0 && n > 0 && (c = e.children[n - 1].firstChild, s = 1073741824)), !d || !c)
      return null;
    i = Math.min(d.textContent.length, Math.max(0, i)), s = Math.min(c.textContent.length, Math.max(0, s));
    const h = this._readClientRects(d, i, c, s, o.endNode);
    return o.markDidDomLayout(), this._createHorizontalRangesFromClientRects(h, o.clientRectDeltaLeft, o.clientRectScale);
  }
}
var Mo;
(function(r) {
  r.DARK = "dark", r.LIGHT = "light", r.HIGH_CONTRAST_DARK = "hcDark", r.HIGH_CONTRAST_LIGHT = "hcLight";
})(Mo || (Mo = {}));
function jr(r) {
  return r === Mo.HIGH_CONTRAST_DARK || r === Mo.HIGH_CONTRAST_LIGHT;
}
function jf(r) {
  return r === Mo.DARK || r === Mo.HIGH_CONTRAST_DARK;
}
const e7 = /* @__PURE__ */ function() {
  return zr ? !0 : !(os || Oo || ld);
}();
let _f = !0;
class fP {
  constructor(e, t) {
    this.themeType = t;
    const i = e.options, n = i.get(
      50
      /* EditorOption.fontInfo */
    );
    i.get(
      38
      /* EditorOption.experimentalWhitespaceRendering */
    ) === "off" ? this.renderWhitespace = i.get(
      99
      /* EditorOption.renderWhitespace */
    ) : this.renderWhitespace = "none", this.renderControlCharacters = i.get(
      94
      /* EditorOption.renderControlCharacters */
    ), this.spaceWidth = n.spaceWidth, this.middotWidth = n.middotWidth, this.wsmiddotWidth = n.wsmiddotWidth, this.useMonospaceOptimizations = n.isMonospace && !i.get(
      33
      /* EditorOption.disableMonospaceOptimizations */
    ), this.canUseHalfwidthRightwardsArrow = n.canUseHalfwidthRightwardsArrow, this.lineHeight = i.get(
      67
      /* EditorOption.lineHeight */
    ), this.stopRenderingLineAfter = i.get(
      117
      /* EditorOption.stopRenderingLineAfter */
    ), this.fontLigatures = i.get(
      51
      /* EditorOption.fontLigatures */
    );
  }
  equals(e) {
    return this.themeType === e.themeType && this.renderWhitespace === e.renderWhitespace && this.renderControlCharacters === e.renderControlCharacters && this.spaceWidth === e.spaceWidth && this.middotWidth === e.middotWidth && this.wsmiddotWidth === e.wsmiddotWidth && this.useMonospaceOptimizations === e.useMonospaceOptimizations && this.canUseHalfwidthRightwardsArrow === e.canUseHalfwidthRightwardsArrow && this.lineHeight === e.lineHeight && this.stopRenderingLineAfter === e.stopRenderingLineAfter && this.fontLigatures === e.fontLigatures;
  }
}
class Aa {
  constructor(e) {
    this._options = e, this._isMaybeInvalid = !0, this._renderedViewLine = null;
  }
  // --- begin IVisibleLineData
  getDomNode() {
    return this._renderedViewLine && this._renderedViewLine.domNode ? this._renderedViewLine.domNode.domNode : null;
  }
  setDomNode(e) {
    if (this._renderedViewLine)
      this._renderedViewLine.domNode = bt(e);
    else
      throw new Error("I have no rendered view line to set the dom node to...");
  }
  onContentChanged() {
    this._isMaybeInvalid = !0;
  }
  onTokensChanged() {
    this._isMaybeInvalid = !0;
  }
  onDecorationsChanged() {
    this._isMaybeInvalid = !0;
  }
  onOptionsChanged(e) {
    this._isMaybeInvalid = !0, this._options = e;
  }
  onSelectionChanged() {
    return jr(this._options.themeType) || this._options.renderWhitespace === "selection" ? (this._isMaybeInvalid = !0, !0) : !1;
  }
  renderLine(e, t, i, n, s) {
    if (this._isMaybeInvalid === !1)
      return !1;
    this._isMaybeInvalid = !1;
    const o = n.getViewLineRenderingData(e), a = this._options, l = ts.filter(o.inlineDecorations, e, o.minColumn, o.maxColumn);
    let d = null;
    if (jr(a.themeType) || this._options.renderWhitespace === "selection") {
      const g = n.selections;
      for (const f of g) {
        if (f.endLineNumber < e || f.startLineNumber > e)
          continue;
        const m = f.startLineNumber === e ? f.startColumn : o.minColumn, _ = f.endLineNumber === e ? f.endColumn : o.maxColumn;
        m < _ && (jr(a.themeType) && l.push(new ts(
          m,
          _,
          "inline-selected-text",
          0
          /* InlineDecorationType.Regular */
        )), this._options.renderWhitespace === "selection" && (d || (d = []), d.push(new vV(m - 1, _ - 1))));
      }
    }
    const c = new th(a.useMonospaceOptimizations, a.canUseHalfwidthRightwardsArrow, o.content, o.continuesWithWrappedLine, o.isBasicASCII, o.containsRTL, o.minColumn - 1, o.tokens, l, o.tabSize, o.startVisibleColumn, a.spaceWidth, a.middotWidth, a.wsmiddotWidth, a.stopRenderingLineAfter, a.renderWhitespace, a.renderControlCharacters, a.fontLigatures !== ro.OFF, d);
    if (this._renderedViewLine && this._renderedViewLine.input.equals(c))
      return !1;
    s.appendString('<div style="top:'), s.appendString(String(t)), s.appendString("px;height:"), s.appendString(String(i)), s.appendString('px;" class="'), s.appendString(Aa.CLASS_NAME), s.appendString('">');
    const h = hb(c, s);
    s.appendString("</div>");
    let u = null;
    return _f && e7 && o.isBasicASCII && a.useMonospaceOptimizations && h.containsForeignElements === 0 && (u = new hC(this._renderedViewLine ? this._renderedViewLine.domNode : null, c, h.characterMapping)), u || (u = BV(this._renderedViewLine ? this._renderedViewLine.domNode : null, c, h.characterMapping, h.containsRTL, h.containsForeignElements)), this._renderedViewLine = u, !0;
  }
  layoutLine(e, t, i) {
    this._renderedViewLine && this._renderedViewLine.domNode && (this._renderedViewLine.domNode.setTop(t), this._renderedViewLine.domNode.setHeight(i));
  }
  // --- end IVisibleLineData
  getWidth(e) {
    return this._renderedViewLine ? this._renderedViewLine.getWidth(e) : 0;
  }
  getWidthIsFast() {
    return this._renderedViewLine ? this._renderedViewLine.getWidthIsFast() : !0;
  }
  needsMonospaceFontCheck() {
    return this._renderedViewLine ? this._renderedViewLine instanceof hC : !1;
  }
  monospaceAssumptionsAreValid() {
    return this._renderedViewLine && this._renderedViewLine instanceof hC ? this._renderedViewLine.monospaceAssumptionsAreValid() : _f;
  }
  onMonospaceAssumptionsInvalidated() {
    this._renderedViewLine && this._renderedViewLine instanceof hC && (this._renderedViewLine = this._renderedViewLine.toSlowRenderedLine());
  }
  getVisibleRangesForRange(e, t, i, n) {
    if (!this._renderedViewLine)
      return null;
    t = Math.min(this._renderedViewLine.input.lineContent.length + 1, Math.max(1, t)), i = Math.min(this._renderedViewLine.input.lineContent.length + 1, Math.max(1, i));
    const s = this._renderedViewLine.input.stopRenderingLineAfter;
    if (s !== -1 && t > s + 1 && i > s + 1)
      return new gP(!0, [new au(this.getWidth(n), 0)]);
    s !== -1 && t > s + 1 && (t = s + 1), s !== -1 && i > s + 1 && (i = s + 1);
    const o = this._renderedViewLine.getVisibleRangesForRange(e, t, i, n);
    return o && o.length > 0 ? new gP(!1, o) : null;
  }
  getColumnOfNodeOffset(e, t) {
    return this._renderedViewLine ? this._renderedViewLine.getColumnOfNodeOffset(e, t) : 1;
  }
}
Aa.CLASS_NAME = "view-line";
class hC {
  constructor(e, t, i) {
    this._cachedWidth = -1, this.domNode = e, this.input = t;
    const n = Math.floor(
      t.lineContent.length / 300
      /* Constants.MaxMonospaceDistance */
    );
    if (n > 0) {
      this._keyColumnPixelOffsetCache = new Float32Array(n);
      for (let s = 0; s < n; s++)
        this._keyColumnPixelOffsetCache[s] = -1;
    } else
      this._keyColumnPixelOffsetCache = null;
    this._characterMapping = i, this._charWidth = t.spaceWidth;
  }
  getWidth(e) {
    if (!this.domNode || this.input.lineContent.length < 300) {
      const t = this._characterMapping.getHorizontalOffset(this._characterMapping.length);
      return Math.round(this._charWidth * t);
    }
    return this._cachedWidth === -1 && (this._cachedWidth = this._getReadingTarget(this.domNode).offsetWidth, e == null || e.markDidDomLayout()), this._cachedWidth;
  }
  getWidthIsFast() {
    return this.input.lineContent.length < 300 || this._cachedWidth !== -1;
  }
  monospaceAssumptionsAreValid() {
    if (!this.domNode)
      return _f;
    if (this.input.lineContent.length < 300) {
      const e = this.getWidth(null), t = this.domNode.domNode.firstChild.offsetWidth;
      Math.abs(e - t) >= 2 && (console.warn("monospace assumptions have been violated, therefore disabling monospace optimizations!"), _f = !1);
    }
    return _f;
  }
  toSlowRenderedLine() {
    return BV(
      this.domNode,
      this.input,
      this._characterMapping,
      !1,
      0
      /* ForeignElementType.None */
    );
  }
  getVisibleRangesForRange(e, t, i, n) {
    const s = this._getColumnPixelOffset(e, t, n), o = this._getColumnPixelOffset(e, i, n);
    return [new au(s, o - s)];
  }
  _getColumnPixelOffset(e, t, i) {
    if (t <= 300) {
      const d = this._characterMapping.getHorizontalOffset(t);
      return this._charWidth * d;
    }
    const n = Math.floor(
      (t - 1) / 300
      /* Constants.MaxMonospaceDistance */
    ) - 1, s = (n + 1) * 300 + 1;
    let o = -1;
    if (this._keyColumnPixelOffsetCache && (o = this._keyColumnPixelOffsetCache[n], o === -1 && (o = this._actualReadPixelOffset(e, s, i), this._keyColumnPixelOffsetCache[n] = o)), o === -1) {
      const d = this._characterMapping.getHorizontalOffset(t);
      return this._charWidth * d;
    }
    const a = this._characterMapping.getHorizontalOffset(s), l = this._characterMapping.getHorizontalOffset(t);
    return o + this._charWidth * (l - a);
  }
  _getReadingTarget(e) {
    return e.domNode.firstChild;
  }
  _actualReadPixelOffset(e, t, i) {
    if (!this.domNode)
      return -1;
    const n = this._characterMapping.getDomPosition(t), s = Mw.readHorizontalRanges(this._getReadingTarget(this.domNode), n.partIndex, n.charIndex, n.partIndex, n.charIndex, i);
    return !s || s.length === 0 ? -1 : s[0].left;
  }
  getColumnOfNodeOffset(e, t) {
    return D1(this._characterMapping, e, t);
  }
}
class WV {
  constructor(e, t, i, n, s) {
    if (this.domNode = e, this.input = t, this._characterMapping = i, this._isWhitespaceOnly = /^\s*$/.test(t.lineContent), this._containsForeignElements = s, this._cachedWidth = -1, this._pixelOffsetCache = null, !n || this._characterMapping.length === 0) {
      this._pixelOffsetCache = new Float32Array(Math.max(2, this._characterMapping.length + 1));
      for (let o = 0, a = this._characterMapping.length; o <= a; o++)
        this._pixelOffsetCache[o] = -1;
    }
  }
  // --- Reading from the DOM methods
  _getReadingTarget(e) {
    return e.domNode.firstChild;
  }
  /**
   * Width of the line in pixels
   */
  getWidth(e) {
    return this.domNode ? (this._cachedWidth === -1 && (this._cachedWidth = this._getReadingTarget(this.domNode).offsetWidth, e == null || e.markDidDomLayout()), this._cachedWidth) : 0;
  }
  getWidthIsFast() {
    return this._cachedWidth !== -1;
  }
  /**
   * Visible ranges for a model range
   */
  getVisibleRangesForRange(e, t, i, n) {
    if (!this.domNode)
      return null;
    if (this._pixelOffsetCache !== null) {
      const s = this._readPixelOffset(this.domNode, e, t, n);
      if (s === -1)
        return null;
      const o = this._readPixelOffset(this.domNode, e, i, n);
      return o === -1 ? null : [new au(s, o - s)];
    }
    return this._readVisibleRangesForRange(this.domNode, e, t, i, n);
  }
  _readVisibleRangesForRange(e, t, i, n, s) {
    if (i === n) {
      const o = this._readPixelOffset(e, t, i, s);
      return o === -1 ? null : [new au(o, 0)];
    } else
      return this._readRawVisibleRangesForRange(e, i, n, s);
  }
  _readPixelOffset(e, t, i, n) {
    if (this._characterMapping.length === 0) {
      if (this._containsForeignElements === 0 || this._containsForeignElements === 2)
        return 0;
      if (this._containsForeignElements === 1)
        return this.getWidth(n);
      const s = this._getReadingTarget(e);
      return s.firstChild ? (n.markDidDomLayout(), s.firstChild.offsetWidth) : 0;
    }
    if (this._pixelOffsetCache !== null) {
      const s = this._pixelOffsetCache[i];
      if (s !== -1)
        return s;
      const o = this._actualReadPixelOffset(e, t, i, n);
      return this._pixelOffsetCache[i] = o, o;
    }
    return this._actualReadPixelOffset(e, t, i, n);
  }
  _actualReadPixelOffset(e, t, i, n) {
    if (this._characterMapping.length === 0) {
      const l = Mw.readHorizontalRanges(this._getReadingTarget(e), 0, 0, 0, 0, n);
      return !l || l.length === 0 ? -1 : l[0].left;
    }
    if (i === this._characterMapping.length && this._isWhitespaceOnly && this._containsForeignElements === 0)
      return this.getWidth(n);
    const s = this._characterMapping.getDomPosition(i), o = Mw.readHorizontalRanges(this._getReadingTarget(e), s.partIndex, s.charIndex, s.partIndex, s.charIndex, n);
    if (!o || o.length === 0)
      return -1;
    const a = o[0].left;
    if (this.input.isBasicASCII) {
      const l = this._characterMapping.getHorizontalOffset(i), d = Math.round(this.input.spaceWidth * l);
      if (Math.abs(d - a) <= 1)
        return d;
    }
    return a;
  }
  _readRawVisibleRangesForRange(e, t, i, n) {
    if (t === 1 && i === this._characterMapping.length)
      return [new au(0, this.getWidth(n))];
    const s = this._characterMapping.getDomPosition(t), o = this._characterMapping.getDomPosition(i);
    return Mw.readHorizontalRanges(this._getReadingTarget(e), s.partIndex, s.charIndex, o.partIndex, o.charIndex, n);
  }
  /**
   * Returns the column for the text found at a specific offset inside a rendered dom node
   */
  getColumnOfNodeOffset(e, t) {
    return D1(this._characterMapping, e, t);
  }
}
class t7 extends WV {
  _readVisibleRangesForRange(e, t, i, n, s) {
    const o = super._readVisibleRangesForRange(e, t, i, n, s);
    if (!o || o.length === 0 || i === n || i === 1 && n === this._characterMapping.length)
      return o;
    if (!this.input.containsRTL) {
      const a = this._readPixelOffset(e, t, n, s);
      if (a !== -1) {
        const l = o[o.length - 1];
        l.left < a && (l.width = a - l.left);
      }
    }
    return o;
  }
}
const BV = /* @__PURE__ */ function() {
  return su ? i7 : n7;
}();
function i7(r, e, t, i, n) {
  return new t7(r, e, t, i, n);
}
function n7(r, e, t, i, n) {
  return new WV(r, e, t, i, n);
}
function D1(r, e, t) {
  const i = e.textContent.length;
  let n = -1;
  for (; e; )
    e = e.previousSibling, n++;
  return r.getColumn(new bV(n, t), i);
}
class Hi {
  static _nextVisibleColumn(e, t, i) {
    return e === 9 ? Hi.nextRenderTabStop(t, i) : kc(e) || jB(e) ? t + 2 : t + 1;
  }
  /**
   * Returns a visible column from a column.
   * @see {@link CursorColumns}
   */
  static visibleColumnFromColumn(e, t, i) {
    const n = Math.min(t - 1, e.length), s = e.substring(0, n), o = new eA(s);
    let a = 0;
    for (; !o.eol(); ) {
      const l = tA(s, n, o.offset);
      o.nextGraphemeLength(), a = this._nextVisibleColumn(l, a, i);
    }
    return a;
  }
  /**
   * Returns a column from a visible column.
   * @see {@link CursorColumns}
   */
  static columnFromVisibleColumn(e, t, i) {
    if (t <= 0)
      return 1;
    const n = e.length, s = new eA(e);
    let o = 0, a = 1;
    for (; !s.eol(); ) {
      const l = tA(e, n, s.offset);
      s.nextGraphemeLength();
      const d = this._nextVisibleColumn(l, o, i), c = s.offset + 1;
      if (d >= t) {
        const h = t - o;
        return d - t < h ? c : a;
      }
      o = d, a = c;
    }
    return n + 1;
  }
  /**
   * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)
   * @see {@link CursorColumns}
   */
  static nextRenderTabStop(e, t) {
    return e + t - e % t;
  }
  /**
   * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)
   * @see {@link CursorColumns}
   */
  static nextIndentTabStop(e, t) {
    return e + t - e % t;
  }
  /**
   * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)
   * @see {@link CursorColumns}
   */
  static prevRenderTabStop(e, t) {
    return Math.max(0, e - 1 - (e - 1) % t);
  }
  /**
   * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)
   * @see {@link CursorColumns}
   */
  static prevIndentTabStop(e, t) {
    return Math.max(0, e - 1 - (e - 1) % t);
  }
}
class K_ {
  /**
   * Get the visible column at the position. If we get to a non-whitespace character first
   * or past the end of string then return -1.
   *
   * **Note** `position` and the return value are 0-based.
   */
  static whitespaceVisibleColumn(e, t, i) {
    const n = e.length;
    let s = 0, o = -1, a = -1;
    for (let l = 0; l < n; l++) {
      if (l === t)
        return [o, a, s];
      switch (s % i === 0 && (o = l, a = s), e.charCodeAt(l)) {
        case 32:
          s += 1;
          break;
        case 9:
          s = Hi.nextRenderTabStop(s, i);
          break;
        default:
          return [-1, -1, -1];
      }
    }
    return t === n ? [o, a, s] : [-1, -1, -1];
  }
  /**
   * Return the position that should result from a move left, right or to the
   * nearest tab, if atomic tabs are enabled. Left and right are used for the
   * arrow key movements, nearest is used for mouse selection. It returns
   * -1 if atomic tabs are not relevant and you should fall back to normal
   * behaviour.
   *
   * **Note**: `position` and the return value are 0-based.
   */
  static atomicPosition(e, t, i, n) {
    const s = e.length, [o, a, l] = K_.whitespaceVisibleColumn(e, t, i);
    if (l === -1)
      return -1;
    let d;
    switch (n) {
      case 0:
        d = !0;
        break;
      case 1:
        d = !1;
        break;
      case 2:
        if (l % i === 0)
          return t;
        d = l % i <= i / 2;
        break;
    }
    if (d) {
      if (o === -1)
        return -1;
      let u = a;
      for (let g = o; g < s; ++g) {
        if (u === a + i)
          return o;
        switch (e.charCodeAt(g)) {
          case 32:
            u += 1;
            break;
          case 9:
            u = Hi.nextRenderTabStop(u, i);
            break;
          default:
            return -1;
        }
      }
      return u === a + i ? o : -1;
    }
    const c = Hi.nextRenderTabStop(l, i);
    let h = l;
    for (let u = t; u < s; u++) {
      if (h === c)
        return u;
      switch (e.charCodeAt(u)) {
        case 32:
          h += 1;
          break;
        case 9:
          h = Hi.nextRenderTabStop(h, i);
          break;
        default:
          return -1;
      }
    }
    return h === c ? s : -1;
  }
}
class Ad {
  constructor(e = null) {
    this.hitTarget = e, this.type = 0;
  }
}
class HV {
  get hitTarget() {
    return this.spanNode;
  }
  constructor(e, t, i) {
    this.position = e, this.spanNode = t, this.injectedText = i, this.type = 1;
  }
}
var Hh;
(function(r) {
  function e(t, i, n) {
    const s = t.getPositionFromDOMInfo(i, n);
    return s ? new HV(s, i, null) : new Ad(i);
  }
  r.createFromDOMInfo = e;
})(Hh || (Hh = {}));
class s7 {
  constructor(e, t) {
    this.lastViewCursorsRenderData = e, this.lastTextareaPosition = t;
  }
}
class zn {
  static _deduceRage(e, t = null) {
    return !t && e ? new L(e.lineNumber, e.column, e.lineNumber, e.column) : t ?? null;
  }
  static createUnknown(e, t, i) {
    return { type: 0, element: e, mouseColumn: t, position: i, range: this._deduceRage(i) };
  }
  static createTextarea(e, t) {
    return { type: 1, element: e, mouseColumn: t, position: null, range: null };
  }
  static createMargin(e, t, i, n, s, o) {
    return { type: e, element: t, mouseColumn: i, position: n, range: s, detail: o };
  }
  static createViewZone(e, t, i, n, s) {
    return { type: e, element: t, mouseColumn: i, position: n, range: this._deduceRage(n), detail: s };
  }
  static createContentText(e, t, i, n, s) {
    return { type: 6, element: e, mouseColumn: t, position: i, range: this._deduceRage(i, n), detail: s };
  }
  static createContentEmpty(e, t, i, n) {
    return { type: 7, element: e, mouseColumn: t, position: i, range: this._deduceRage(i), detail: n };
  }
  static createContentWidget(e, t, i) {
    return { type: 9, element: e, mouseColumn: t, position: null, range: null, detail: i };
  }
  static createScrollbar(e, t, i) {
    return { type: 11, element: e, mouseColumn: t, position: i, range: this._deduceRage(i) };
  }
  static createOverlayWidget(e, t, i) {
    return { type: 12, element: e, mouseColumn: t, position: null, range: null, detail: i };
  }
  static createOutsideEditor(e, t, i, n) {
    return { type: 13, element: null, mouseColumn: e, position: t, range: this._deduceRage(t), outsidePosition: i, outsideDistance: n };
  }
  static _typeToString(e) {
    return e === 1 ? "TEXTAREA" : e === 2 ? "GUTTER_GLYPH_MARGIN" : e === 3 ? "GUTTER_LINE_NUMBERS" : e === 4 ? "GUTTER_LINE_DECORATIONS" : e === 5 ? "GUTTER_VIEW_ZONE" : e === 6 ? "CONTENT_TEXT" : e === 7 ? "CONTENT_EMPTY" : e === 8 ? "CONTENT_VIEW_ZONE" : e === 9 ? "CONTENT_WIDGET" : e === 10 ? "OVERVIEW_RULER" : e === 11 ? "SCROLLBAR" : e === 12 ? "OVERLAY_WIDGET" : "UNKNOWN";
  }
  static toString(e) {
    return this._typeToString(e.type) + ": " + e.position + " - " + e.range + " - " + JSON.stringify(e.detail);
  }
}
class Zn {
  static isTextArea(e) {
    return e.length === 2 && e[0] === 3 && e[1] === 7;
  }
  static isChildOfViewLines(e) {
    return e.length >= 4 && e[0] === 3 && e[3] === 8;
  }
  static isStrictChildOfViewLines(e) {
    return e.length > 4 && e[0] === 3 && e[3] === 8;
  }
  static isChildOfScrollableElement(e) {
    return e.length >= 2 && e[0] === 3 && e[1] === 6;
  }
  static isChildOfMinimap(e) {
    return e.length >= 2 && e[0] === 3 && e[1] === 9;
  }
  static isChildOfContentWidgets(e) {
    return e.length >= 4 && e[0] === 3 && e[3] === 1;
  }
  static isChildOfOverflowGuard(e) {
    return e.length >= 1 && e[0] === 3;
  }
  static isChildOfOverflowingContentWidgets(e) {
    return e.length >= 1 && e[0] === 2;
  }
  static isChildOfOverlayWidgets(e) {
    return e.length >= 2 && e[0] === 3 && e[1] === 4;
  }
  static isChildOfOverflowingOverlayWidgets(e) {
    return e.length >= 1 && e[0] === 5;
  }
}
class qf {
  constructor(e, t, i) {
    this.viewModel = e.viewModel;
    const n = e.configuration.options;
    this.layoutInfo = n.get(
      145
      /* EditorOption.layoutInfo */
    ), this.viewDomNode = t.viewDomNode, this.lineHeight = n.get(
      67
      /* EditorOption.lineHeight */
    ), this.stickyTabStops = n.get(
      116
      /* EditorOption.stickyTabStops */
    ), this.typicalHalfwidthCharacterWidth = n.get(
      50
      /* EditorOption.fontInfo */
    ).typicalHalfwidthCharacterWidth, this.lastRenderData = i, this._context = e, this._viewHelper = t;
  }
  getZoneAtCoord(e) {
    return qf.getZoneAtCoord(this._context, e);
  }
  static getZoneAtCoord(e, t) {
    const i = e.viewLayout.getWhitespaceAtVerticalOffset(t);
    if (i) {
      const n = i.verticalOffset + i.height / 2, s = e.viewModel.getLineCount();
      let o = null, a, l = null;
      return i.afterLineNumber !== s && (l = new A(i.afterLineNumber + 1, 1)), i.afterLineNumber > 0 && (o = new A(i.afterLineNumber, e.viewModel.getLineMaxColumn(i.afterLineNumber))), l === null ? a = o : o === null ? a = l : t < n ? a = o : a = l, {
        viewZoneId: i.id,
        afterLineNumber: i.afterLineNumber,
        positionBefore: o,
        positionAfter: l,
        position: a
      };
    }
    return null;
  }
  getFullLineRangeAtCoord(e) {
    if (this._context.viewLayout.isAfterLines(e)) {
      const n = this._context.viewModel.getLineCount(), s = this._context.viewModel.getLineMaxColumn(n);
      return {
        range: new L(n, s, n, s),
        isAfterLines: !0
      };
    }
    const t = this._context.viewLayout.getLineNumberAtVerticalOffset(e), i = this._context.viewModel.getLineMaxColumn(t);
    return {
      range: new L(t, 1, t, i),
      isAfterLines: !1
    };
  }
  getLineNumberAtVerticalOffset(e) {
    return this._context.viewLayout.getLineNumberAtVerticalOffset(e);
  }
  isAfterLines(e) {
    return this._context.viewLayout.isAfterLines(e);
  }
  isInTopPadding(e) {
    return this._context.viewLayout.isInTopPadding(e);
  }
  isInBottomPadding(e) {
    return this._context.viewLayout.isInBottomPadding(e);
  }
  getVerticalOffsetForLineNumber(e) {
    return this._context.viewLayout.getVerticalOffsetForLineNumber(e);
  }
  findAttribute(e, t) {
    return qf._findAttribute(e, t, this._viewHelper.viewDomNode);
  }
  static _findAttribute(e, t, i) {
    for (; e && e !== e.ownerDocument.body; ) {
      if (e.hasAttribute && e.hasAttribute(t))
        return e.getAttribute(t);
      if (e === i)
        return null;
      e = e.parentNode;
    }
    return null;
  }
  getLineWidth(e) {
    return this._viewHelper.getLineWidth(e);
  }
  visibleRangeForPosition(e, t) {
    return this._viewHelper.visibleRangeForPosition(e, t);
  }
  getPositionFromDOMInfo(e, t) {
    return this._viewHelper.getPositionFromDOMInfo(e, t);
  }
  getCurrentScrollTop() {
    return this._context.viewLayout.getCurrentScrollTop();
  }
  getCurrentScrollLeft() {
    return this._context.viewLayout.getCurrentScrollLeft();
  }
}
class o7 {
  constructor(e, t, i, n) {
    this.editorPos = t, this.pos = i, this.relativePos = n, this.mouseVerticalOffset = Math.max(0, e.getCurrentScrollTop() + this.relativePos.y), this.mouseContentHorizontalOffset = e.getCurrentScrollLeft() + this.relativePos.x - e.layoutInfo.contentLeft, this.isInMarginArea = this.relativePos.x < e.layoutInfo.contentLeft && this.relativePos.x >= e.layoutInfo.glyphMarginLeft, this.isInContentArea = !this.isInMarginArea, this.mouseColumn = Math.max(0, Hn._getMouseColumn(this.mouseContentHorizontalOffset, e.typicalHalfwidthCharacterWidth));
  }
}
class r7 extends o7 {
  get target() {
    return this._useHitTestTarget ? this.hitTestResult.value.hitTarget : this._eventTarget;
  }
  get targetPath() {
    return this._targetPathCacheElement !== this.target && (this._targetPathCacheElement = this.target, this._targetPathCacheValue = Jr.collect(this.target, this._ctx.viewDomNode)), this._targetPathCacheValue;
  }
  constructor(e, t, i, n, s) {
    super(e, t, i, n), this.hitTestResult = new bd(() => Hn.doHitTest(this._ctx, this)), this._targetPathCacheElement = null, this._targetPathCacheValue = new Uint8Array(0), this._ctx = e, this._eventTarget = s;
    const o = !!this._eventTarget;
    this._useHitTestTarget = !o;
  }
  toString() {
    return `pos(${this.pos.x},${this.pos.y}), editorPos(${this.editorPos.x},${this.editorPos.y}), relativePos(${this.relativePos.x},${this.relativePos.y}), mouseVerticalOffset: ${this.mouseVerticalOffset}, mouseContentHorizontalOffset: ${this.mouseContentHorizontalOffset}
	target: ${this.target ? this.target.outerHTML : null}`;
  }
  get wouldBenefitFromHitTestTargetSwitch() {
    return !this._useHitTestTarget && this.hitTestResult.value.hitTarget !== null && this.target !== this.hitTestResult.value.hitTarget;
  }
  switchToHitTestTarget() {
    this._useHitTestTarget = !0;
  }
  _getMouseColumn(e = null) {
    return e && e.column < this._ctx.viewModel.getLineMaxColumn(e.lineNumber) ? Hi.visibleColumnFromColumn(this._ctx.viewModel.getLineContent(e.lineNumber), e.column, this._ctx.viewModel.model.getOptions().tabSize) + 1 : this.mouseColumn;
  }
  fulfillUnknown(e = null) {
    return zn.createUnknown(this.target, this._getMouseColumn(e), e);
  }
  fulfillTextarea() {
    return zn.createTextarea(this.target, this._getMouseColumn());
  }
  fulfillMargin(e, t, i, n) {
    return zn.createMargin(e, this.target, this._getMouseColumn(t), t, i, n);
  }
  fulfillViewZone(e, t, i) {
    return zn.createViewZone(e, this.target, this._getMouseColumn(t), t, i);
  }
  fulfillContentText(e, t, i) {
    return zn.createContentText(this.target, this._getMouseColumn(e), e, t, i);
  }
  fulfillContentEmpty(e, t) {
    return zn.createContentEmpty(this.target, this._getMouseColumn(e), e, t);
  }
  fulfillContentWidget(e) {
    return zn.createContentWidget(this.target, this._getMouseColumn(), e);
  }
  fulfillScrollbar(e) {
    return zn.createScrollbar(this.target, this._getMouseColumn(e), e);
  }
  fulfillOverlayWidget(e) {
    return zn.createOverlayWidget(this.target, this._getMouseColumn(), e);
  }
}
const pP = { isAfterLines: !0 };
function UD(r) {
  return {
    isAfterLines: !1,
    horizontalDistanceToText: r
  };
}
class Hn {
  constructor(e, t) {
    this._context = e, this._viewHelper = t;
  }
  mouseTargetIsWidget(e) {
    const t = e.target, i = Jr.collect(t, this._viewHelper.viewDomNode);
    return !!(Zn.isChildOfContentWidgets(i) || Zn.isChildOfOverflowingContentWidgets(i) || Zn.isChildOfOverlayWidgets(i) || Zn.isChildOfOverflowingOverlayWidgets(i));
  }
  createMouseTarget(e, t, i, n, s) {
    const o = new qf(this._context, this._viewHelper, e), a = new r7(o, t, i, n, s);
    try {
      const l = Hn._createMouseTarget(o, a);
      if (l.type === 6 && o.stickyTabStops && l.position !== null) {
        const d = Hn._snapToSoftTabBoundary(l.position, o.viewModel), c = L.fromPositions(d, d).plusRange(l.range);
        return a.fulfillContentText(d, c, l.detail);
      }
      return l;
    } catch {
      return a.fulfillUnknown();
    }
  }
  static _createMouseTarget(e, t) {
    if (t.target === null)
      return t.fulfillUnknown();
    const i = t;
    let n = null;
    return !Zn.isChildOfOverflowGuard(t.targetPath) && !Zn.isChildOfOverflowingContentWidgets(t.targetPath) && !Zn.isChildOfOverflowingOverlayWidgets(t.targetPath) && (n = n || t.fulfillUnknown()), n = n || Hn._hitTestContentWidget(e, i), n = n || Hn._hitTestOverlayWidget(e, i), n = n || Hn._hitTestMinimap(e, i), n = n || Hn._hitTestScrollbarSlider(e, i), n = n || Hn._hitTestViewZone(e, i), n = n || Hn._hitTestMargin(e, i), n = n || Hn._hitTestViewCursor(e, i), n = n || Hn._hitTestTextArea(e, i), n = n || Hn._hitTestViewLines(e, i), n = n || Hn._hitTestScrollbar(e, i), n || t.fulfillUnknown();
  }
  static _hitTestContentWidget(e, t) {
    if (Zn.isChildOfContentWidgets(t.targetPath) || Zn.isChildOfOverflowingContentWidgets(t.targetPath)) {
      const i = e.findAttribute(t.target, "widgetId");
      return i ? t.fulfillContentWidget(i) : t.fulfillUnknown();
    }
    return null;
  }
  static _hitTestOverlayWidget(e, t) {
    if (Zn.isChildOfOverlayWidgets(t.targetPath) || Zn.isChildOfOverflowingOverlayWidgets(t.targetPath)) {
      const i = e.findAttribute(t.target, "widgetId");
      return i ? t.fulfillOverlayWidget(i) : t.fulfillUnknown();
    }
    return null;
  }
  static _hitTestViewCursor(e, t) {
    if (t.target) {
      const i = e.lastRenderData.lastViewCursorsRenderData;
      for (const n of i)
        if (t.target === n.domNode)
          return t.fulfillContentText(n.position, null, { mightBeForeignElement: !1, injectedText: null });
    }
    if (t.isInContentArea) {
      const i = e.lastRenderData.lastViewCursorsRenderData, n = t.mouseContentHorizontalOffset, s = t.mouseVerticalOffset;
      for (const o of i) {
        if (n < o.contentLeft || n > o.contentLeft + o.width)
          continue;
        const a = e.getVerticalOffsetForLineNumber(o.position.lineNumber);
        if (a <= s && s <= a + o.height)
          return t.fulfillContentText(o.position, null, { mightBeForeignElement: !1, injectedText: null });
      }
    }
    return null;
  }
  static _hitTestViewZone(e, t) {
    const i = e.getZoneAtCoord(t.mouseVerticalOffset);
    if (i) {
      const n = t.isInContentArea ? 8 : 5;
      return t.fulfillViewZone(n, i.position, i);
    }
    return null;
  }
  static _hitTestTextArea(e, t) {
    return Zn.isTextArea(t.targetPath) ? e.lastRenderData.lastTextareaPosition ? t.fulfillContentText(e.lastRenderData.lastTextareaPosition, null, { mightBeForeignElement: !1, injectedText: null }) : t.fulfillTextarea() : null;
  }
  static _hitTestMargin(e, t) {
    if (t.isInMarginArea) {
      const i = e.getFullLineRangeAtCoord(t.mouseVerticalOffset), n = i.range.getStartPosition();
      let s = Math.abs(t.relativePos.x);
      const o = {
        isAfterLines: i.isAfterLines,
        glyphMarginLeft: e.layoutInfo.glyphMarginLeft,
        glyphMarginWidth: e.layoutInfo.glyphMarginWidth,
        lineNumbersWidth: e.layoutInfo.lineNumbersWidth,
        offsetX: s
      };
      if (s -= e.layoutInfo.glyphMarginLeft, s <= e.layoutInfo.glyphMarginWidth) {
        const a = e.viewModel.coordinatesConverter.convertViewPositionToModelPosition(i.range.getStartPosition()), l = e.viewModel.glyphLanes.getLanesAtLine(a.lineNumber);
        return o.glyphMarginLane = l[Math.floor(s / e.lineHeight)], t.fulfillMargin(2, n, i.range, o);
      }
      return s -= e.layoutInfo.glyphMarginWidth, s <= e.layoutInfo.lineNumbersWidth ? t.fulfillMargin(3, n, i.range, o) : (s -= e.layoutInfo.lineNumbersWidth, t.fulfillMargin(4, n, i.range, o));
    }
    return null;
  }
  static _hitTestViewLines(e, t) {
    if (!Zn.isChildOfViewLines(t.targetPath))
      return null;
    if (e.isInTopPadding(t.mouseVerticalOffset))
      return t.fulfillContentEmpty(new A(1, 1), pP);
    if (e.isAfterLines(t.mouseVerticalOffset) || e.isInBottomPadding(t.mouseVerticalOffset)) {
      const n = e.viewModel.getLineCount(), s = e.viewModel.getLineMaxColumn(n);
      return t.fulfillContentEmpty(new A(n, s), pP);
    }
    if (Zn.isStrictChildOfViewLines(t.targetPath)) {
      const n = e.getLineNumberAtVerticalOffset(t.mouseVerticalOffset);
      if (e.viewModel.getLineLength(n) === 0) {
        const o = e.getLineWidth(n), a = UD(t.mouseContentHorizontalOffset - o);
        return t.fulfillContentEmpty(new A(n, 1), a);
      }
      const s = e.getLineWidth(n);
      if (t.mouseContentHorizontalOffset >= s) {
        const o = UD(t.mouseContentHorizontalOffset - s), a = new A(n, e.viewModel.getLineMaxColumn(n));
        return t.fulfillContentEmpty(a, o);
      }
    }
    const i = t.hitTestResult.value;
    return i.type === 1 ? Hn.createMouseTargetFromHitTestPosition(e, t, i.spanNode, i.position, i.injectedText) : t.wouldBenefitFromHitTestTargetSwitch ? (t.switchToHitTestTarget(), this._createMouseTarget(e, t)) : t.fulfillUnknown();
  }
  static _hitTestMinimap(e, t) {
    if (Zn.isChildOfMinimap(t.targetPath)) {
      const i = e.getLineNumberAtVerticalOffset(t.mouseVerticalOffset), n = e.viewModel.getLineMaxColumn(i);
      return t.fulfillScrollbar(new A(i, n));
    }
    return null;
  }
  static _hitTestScrollbarSlider(e, t) {
    if (Zn.isChildOfScrollableElement(t.targetPath) && t.target && t.target.nodeType === 1) {
      const i = t.target.className;
      if (i && /\b(slider|scrollbar)\b/.test(i)) {
        const n = e.getLineNumberAtVerticalOffset(t.mouseVerticalOffset), s = e.viewModel.getLineMaxColumn(n);
        return t.fulfillScrollbar(new A(n, s));
      }
    }
    return null;
  }
  static _hitTestScrollbar(e, t) {
    if (Zn.isChildOfScrollableElement(t.targetPath)) {
      const i = e.getLineNumberAtVerticalOffset(t.mouseVerticalOffset), n = e.viewModel.getLineMaxColumn(i);
      return t.fulfillScrollbar(new A(i, n));
    }
    return null;
  }
  getMouseColumn(e) {
    const t = this._context.configuration.options, i = t.get(
      145
      /* EditorOption.layoutInfo */
    ), n = this._context.viewLayout.getCurrentScrollLeft() + e.x - i.contentLeft;
    return Hn._getMouseColumn(n, t.get(
      50
      /* EditorOption.fontInfo */
    ).typicalHalfwidthCharacterWidth);
  }
  static _getMouseColumn(e, t) {
    return e < 0 ? 1 : Math.round(e / t) + 1;
  }
  static createMouseTargetFromHitTestPosition(e, t, i, n, s) {
    const o = n.lineNumber, a = n.column, l = e.getLineWidth(o);
    if (t.mouseContentHorizontalOffset > l) {
      const v = UD(t.mouseContentHorizontalOffset - l);
      return t.fulfillContentEmpty(n, v);
    }
    const d = e.visibleRangeForPosition(o, a);
    if (!d)
      return t.fulfillUnknown(n);
    const c = d.left;
    if (Math.abs(t.mouseContentHorizontalOffset - c) < 1)
      return t.fulfillContentText(n, null, { mightBeForeignElement: !!s, injectedText: s });
    const h = [];
    if (h.push({ offset: d.left, column: a }), a > 1) {
      const v = e.visibleRangeForPosition(o, a - 1);
      v && h.push({ offset: v.left, column: a - 1 });
    }
    const u = e.viewModel.getLineMaxColumn(o);
    if (a < u) {
      const v = e.visibleRangeForPosition(o, a + 1);
      v && h.push({ offset: v.left, column: a + 1 });
    }
    h.sort((v, b) => v.offset - b.offset);
    const g = t.pos.toClientCoordinates(we(e.viewDomNode)), f = i.getBoundingClientRect(), m = f.left <= g.clientX && g.clientX <= f.right;
    let _ = null;
    for (let v = 1; v < h.length; v++) {
      const b = h[v - 1], C = h[v];
      if (b.offset <= t.mouseContentHorizontalOffset && t.mouseContentHorizontalOffset <= C.offset) {
        _ = new L(o, b.column, o, C.column);
        const w = Math.abs(b.offset - t.mouseContentHorizontalOffset), S = Math.abs(C.offset - t.mouseContentHorizontalOffset);
        n = w < S ? new A(o, b.column) : new A(o, C.column);
        break;
      }
    }
    return t.fulfillContentText(n, _, { mightBeForeignElement: !m || !!s, injectedText: s });
  }
  /**
   * Most probably WebKit browsers and Edge
   */
  static _doHitTestWithCaretRangeFromPoint(e, t) {
    const i = e.getLineNumberAtVerticalOffset(t.mouseVerticalOffset), n = e.getVerticalOffsetForLineNumber(i), s = n + e.lineHeight;
    if (!(i === e.viewModel.getLineCount() && t.mouseVerticalOffset > s)) {
      const a = Math.floor((n + s) / 2);
      let l = t.pos.y + (a - t.mouseVerticalOffset);
      l <= t.editorPos.y && (l = t.editorPos.y + 1), l >= t.editorPos.y + t.editorPos.height && (l = t.editorPos.y + t.editorPos.height - 1);
      const d = new k0(t.pos.x, l), c = this._actualDoHitTestWithCaretRangeFromPoint(e, d.toClientCoordinates(we(e.viewDomNode)));
      if (c.type === 1)
        return c;
    }
    return this._actualDoHitTestWithCaretRangeFromPoint(e, t.pos.toClientCoordinates(we(e.viewDomNode)));
  }
  static _actualDoHitTestWithCaretRangeFromPoint(e, t) {
    const i = Cu(e.viewDomNode);
    let n;
    if (i ? typeof i.caretRangeFromPoint > "u" ? n = a7(i, t.clientX, t.clientY) : n = i.caretRangeFromPoint(t.clientX, t.clientY) : n = e.viewDomNode.ownerDocument.caretRangeFromPoint(t.clientX, t.clientY), !n || !n.startContainer)
      return new Ad();
    const s = n.startContainer;
    if (s.nodeType === s.TEXT_NODE) {
      const o = s.parentNode, a = o ? o.parentNode : null, l = a ? a.parentNode : null;
      return (l && l.nodeType === l.ELEMENT_NODE ? l.className : null) === Aa.CLASS_NAME ? Hh.createFromDOMInfo(e, o, n.startOffset) : new Ad(s.parentNode);
    } else if (s.nodeType === s.ELEMENT_NODE) {
      const o = s.parentNode, a = o ? o.parentNode : null;
      return (a && a.nodeType === a.ELEMENT_NODE ? a.className : null) === Aa.CLASS_NAME ? Hh.createFromDOMInfo(e, s, s.textContent.length) : new Ad(s);
    }
    return new Ad();
  }
  /**
   * Most probably Gecko
   */
  static _doHitTestWithCaretPositionFromPoint(e, t) {
    const i = e.viewDomNode.ownerDocument.caretPositionFromPoint(t.clientX, t.clientY);
    if (i.offsetNode.nodeType === i.offsetNode.TEXT_NODE) {
      const n = i.offsetNode.parentNode, s = n ? n.parentNode : null, o = s ? s.parentNode : null;
      return (o && o.nodeType === o.ELEMENT_NODE ? o.className : null) === Aa.CLASS_NAME ? Hh.createFromDOMInfo(e, i.offsetNode.parentNode, i.offset) : new Ad(i.offsetNode.parentNode);
    }
    if (i.offsetNode.nodeType === i.offsetNode.ELEMENT_NODE) {
      const n = i.offsetNode.parentNode, s = n && n.nodeType === n.ELEMENT_NODE ? n.className : null, o = n ? n.parentNode : null, a = o && o.nodeType === o.ELEMENT_NODE ? o.className : null;
      if (s === Aa.CLASS_NAME) {
        const l = i.offsetNode.childNodes[Math.min(i.offset, i.offsetNode.childNodes.length - 1)];
        if (l)
          return Hh.createFromDOMInfo(e, l, 0);
      } else if (a === Aa.CLASS_NAME)
        return Hh.createFromDOMInfo(e, i.offsetNode, 0);
    }
    return new Ad(i.offsetNode);
  }
  static _snapToSoftTabBoundary(e, t) {
    const i = t.getLineContent(e.lineNumber), { tabSize: n } = t.model.getOptions(), s = K_.atomicPosition(
      i,
      e.column - 1,
      n,
      2
      /* Direction.Nearest */
    );
    return s !== -1 ? new A(e.lineNumber, s + 1) : e;
  }
  static doHitTest(e, t) {
    let i = new Ad();
    if (typeof e.viewDomNode.ownerDocument.caretRangeFromPoint == "function" ? i = this._doHitTestWithCaretRangeFromPoint(e, t) : e.viewDomNode.ownerDocument.caretPositionFromPoint && (i = this._doHitTestWithCaretPositionFromPoint(e, t.pos.toClientCoordinates(we(e.viewDomNode)))), i.type === 1) {
      const n = e.viewModel.getInjectedTextAt(i.position), s = e.viewModel.normalizePosition(
        i.position,
        2
        /* PositionAffinity.None */
      );
      (n || !s.equals(i.position)) && (i = new HV(s, i.spanNode, n));
    }
    return i;
  }
}
function a7(r, e, t) {
  const i = document.createRange();
  let n = r.elementFromPoint(e, t);
  if (n !== null) {
    for (; n && n.firstChild && n.firstChild.nodeType !== n.firstChild.TEXT_NODE && n.lastChild && n.lastChild.firstChild; )
      n = n.lastChild;
    const s = n.getBoundingClientRect(), o = we(n), a = o.getComputedStyle(n, null).getPropertyValue("font-style"), l = o.getComputedStyle(n, null).getPropertyValue("font-variant"), d = o.getComputedStyle(n, null).getPropertyValue("font-weight"), c = o.getComputedStyle(n, null).getPropertyValue("font-size"), h = o.getComputedStyle(n, null).getPropertyValue("line-height"), u = o.getComputedStyle(n, null).getPropertyValue("font-family"), g = `${a} ${l} ${d} ${c}/${h} ${u}`, f = n.innerText;
    let m = s.left, _ = 0, v;
    if (e > s.left + s.width)
      _ = f.length;
    else {
      const b = Zh.getInstance();
      for (let C = 0; C < f.length + 1; C++) {
        if (v = b.getCharWidth(f.charAt(C), g) / 2, m += v, e < m) {
          _ = C;
          break;
        }
        m += v;
      }
    }
    i.setStart(n.firstChild, _), i.setEnd(n.firstChild, _);
  }
  return i;
}
class Zh {
  static getInstance() {
    return Zh._INSTANCE || (Zh._INSTANCE = new Zh()), Zh._INSTANCE;
  }
  constructor() {
    this._cache = {}, this._canvas = document.createElement("canvas");
  }
  getCharWidth(e, t) {
    const i = e + t;
    if (this._cache[i])
      return this._cache[i];
    const n = this._canvas.getContext("2d");
    n.font = t;
    const o = n.measureText(e).width;
    return this._cache[i] = o, o;
  }
}
Zh._INSTANCE = null;
function ki(r, e, t) {
  let i = null, n = null;
  if (typeof t.value == "function" ? (i = "value", n = t.value, n.length !== 0 && console.warn("Memoize should only be used in functions with zero parameters")) : typeof t.get == "function" && (i = "get", n = t.get), !n)
    throw new Error("not supported");
  const s = `$memoize$${e}`;
  t[i] = function(...o) {
    return this.hasOwnProperty(s) || Object.defineProperty(this, s, {
      configurable: !1,
      enumerable: !1,
      writable: !1,
      value: n.apply(this, o)
    }), this[s];
  };
}
var l7 = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Pt;
(function(r) {
  r.Tap = "-monaco-gesturetap", r.Change = "-monaco-gesturechange", r.Start = "-monaco-gesturestart", r.End = "-monaco-gesturesend", r.Contextmenu = "-monaco-gesturecontextmenu";
})(Pt || (Pt = {}));
class At extends P {
  constructor() {
    super(), this.dispatched = !1, this.targets = new Ps(), this.ignoreTargets = new Ps(), this.activeTouches = {}, this.handle = null, this._lastSetTapCountTime = 0, this._register(ne.runAndSubscribe(o0, ({ window: e, disposables: t }) => {
      t.add(W(e.document, "touchstart", (i) => this.onTouchStart(i), { passive: !1 })), t.add(W(e.document, "touchend", (i) => this.onTouchEnd(e, i))), t.add(W(e.document, "touchmove", (i) => this.onTouchMove(i), { passive: !1 }));
    }, { window: Dt, disposables: this._store }));
  }
  static addTarget(e) {
    if (!At.isTouchDevice())
      return P.None;
    At.INSTANCE || (At.INSTANCE = T_(new At()));
    const t = At.INSTANCE.targets.push(e);
    return Se(t);
  }
  static ignoreTarget(e) {
    if (!At.isTouchDevice())
      return P.None;
    At.INSTANCE || (At.INSTANCE = T_(new At()));
    const t = At.INSTANCE.ignoreTargets.push(e);
    return Se(t);
  }
  static isTouchDevice() {
    return "ontouchstart" in Dt || navigator.maxTouchPoints > 0;
  }
  dispose() {
    this.handle && (this.handle.dispose(), this.handle = null), super.dispose();
  }
  onTouchStart(e) {
    const t = Date.now();
    this.handle && (this.handle.dispose(), this.handle = null);
    for (let i = 0, n = e.targetTouches.length; i < n; i++) {
      const s = e.targetTouches.item(i);
      this.activeTouches[s.identifier] = {
        id: s.identifier,
        initialTarget: s.target,
        initialTimeStamp: t,
        initialPageX: s.pageX,
        initialPageY: s.pageY,
        rollingTimestamps: [t],
        rollingPageX: [s.pageX],
        rollingPageY: [s.pageY]
      };
      const o = this.newGestureEvent(Pt.Start, s.target);
      o.pageX = s.pageX, o.pageY = s.pageY, this.dispatchEvent(o);
    }
    this.dispatched && (e.preventDefault(), e.stopPropagation(), this.dispatched = !1);
  }
  onTouchEnd(e, t) {
    const i = Date.now(), n = Object.keys(this.activeTouches).length;
    for (let s = 0, o = t.changedTouches.length; s < o; s++) {
      const a = t.changedTouches.item(s);
      if (!this.activeTouches.hasOwnProperty(String(a.identifier))) {
        console.warn("move of an UNKNOWN touch", a);
        continue;
      }
      const l = this.activeTouches[a.identifier], d = Date.now() - l.initialTimeStamp;
      if (d < At.HOLD_DELAY && Math.abs(l.initialPageX - So(l.rollingPageX)) < 30 && Math.abs(l.initialPageY - So(l.rollingPageY)) < 30) {
        const c = this.newGestureEvent(Pt.Tap, l.initialTarget);
        c.pageX = So(l.rollingPageX), c.pageY = So(l.rollingPageY), this.dispatchEvent(c);
      } else if (d >= At.HOLD_DELAY && Math.abs(l.initialPageX - So(l.rollingPageX)) < 30 && Math.abs(l.initialPageY - So(l.rollingPageY)) < 30) {
        const c = this.newGestureEvent(Pt.Contextmenu, l.initialTarget);
        c.pageX = So(l.rollingPageX), c.pageY = So(l.rollingPageY), this.dispatchEvent(c);
      } else if (n === 1) {
        const c = So(l.rollingPageX), h = So(l.rollingPageY), u = So(l.rollingTimestamps) - l.rollingTimestamps[0], g = c - l.rollingPageX[0], f = h - l.rollingPageY[0], m = [...this.targets].filter((_) => l.initialTarget instanceof Node && _.contains(l.initialTarget));
        this.inertia(
          e,
          m,
          i,
          // time now
          Math.abs(g) / u,
          // speed
          g > 0 ? 1 : -1,
          // x direction
          c,
          // x now
          Math.abs(f) / u,
          // y speed
          f > 0 ? 1 : -1,
          // y direction
          h
          // y now
        );
      }
      this.dispatchEvent(this.newGestureEvent(Pt.End, l.initialTarget)), delete this.activeTouches[a.identifier];
    }
    this.dispatched && (t.preventDefault(), t.stopPropagation(), this.dispatched = !1);
  }
  newGestureEvent(e, t) {
    const i = document.createEvent("CustomEvent");
    return i.initEvent(e, !1, !0), i.initialTarget = t, i.tapCount = 0, i;
  }
  dispatchEvent(e) {
    if (e.type === Pt.Tap) {
      const t = (/* @__PURE__ */ new Date()).getTime();
      let i = 0;
      t - this._lastSetTapCountTime > At.CLEAR_TAP_COUNT_TIME ? i = 1 : i = 2, this._lastSetTapCountTime = t, e.tapCount = i;
    } else (e.type === Pt.Change || e.type === Pt.Contextmenu) && (this._lastSetTapCountTime = 0);
    if (e.initialTarget instanceof Node) {
      for (const i of this.ignoreTargets)
        if (i.contains(e.initialTarget))
          return;
      const t = [];
      for (const i of this.targets)
        if (i.contains(e.initialTarget)) {
          let n = 0, s = e.initialTarget;
          for (; s && s !== i; )
            n++, s = s.parentElement;
          t.push([n, i]);
        }
      t.sort((i, n) => i[0] - n[0]);
      for (const [i, n] of t)
        n.dispatchEvent(e), this.dispatched = !0;
    }
  }
  inertia(e, t, i, n, s, o, a, l, d) {
    this.handle = Us(e, () => {
      const c = Date.now(), h = c - i;
      let u = 0, g = 0, f = !0;
      n += At.SCROLL_FRICTION * h, a += At.SCROLL_FRICTION * h, n > 0 && (f = !1, u = s * n * h), a > 0 && (f = !1, g = l * a * h);
      const m = this.newGestureEvent(Pt.Change);
      m.translationX = u, m.translationY = g, t.forEach((_) => _.dispatchEvent(m)), f || this.inertia(e, t, c, n, s, o + u, a, l, d + g);
    });
  }
  onTouchMove(e) {
    const t = Date.now();
    for (let i = 0, n = e.changedTouches.length; i < n; i++) {
      const s = e.changedTouches.item(i);
      if (!this.activeTouches.hasOwnProperty(String(s.identifier))) {
        console.warn("end of an UNKNOWN touch", s);
        continue;
      }
      const o = this.activeTouches[s.identifier], a = this.newGestureEvent(Pt.Change, o.initialTarget);
      a.translationX = s.pageX - So(o.rollingPageX), a.translationY = s.pageY - So(o.rollingPageY), a.pageX = s.pageX, a.pageY = s.pageY, this.dispatchEvent(a), o.rollingPageX.length > 3 && (o.rollingPageX.shift(), o.rollingPageY.shift(), o.rollingTimestamps.shift()), o.rollingPageX.push(s.pageX), o.rollingPageY.push(s.pageY), o.rollingTimestamps.push(t);
    }
    this.dispatched && (e.preventDefault(), e.stopPropagation(), this.dispatched = !1);
  }
}
At.SCROLL_FRICTION = -5e-3;
At.HOLD_DELAY = 700;
At.CLEAR_TAP_COUNT_TIME = 400;
l7([
  ki
], At, "isTouchDevice", null);
let bo = class extends P {
  onclick(e, t) {
    this._register(W(e, Q.CLICK, (i) => t(new rr(we(e), i))));
  }
  onmousedown(e, t) {
    this._register(W(e, Q.MOUSE_DOWN, (i) => t(new rr(we(e), i))));
  }
  onmouseover(e, t) {
    this._register(W(e, Q.MOUSE_OVER, (i) => t(new rr(we(e), i))));
  }
  onmouseleave(e, t) {
    this._register(W(e, Q.MOUSE_LEAVE, (i) => t(new rr(we(e), i))));
  }
  onkeydown(e, t) {
    this._register(W(e, Q.KEY_DOWN, (i) => t(new Mt(i))));
  }
  onkeyup(e, t) {
    this._register(W(e, Q.KEY_UP, (i) => t(new Mt(i))));
  }
  oninput(e, t) {
    this._register(W(e, Q.INPUT, t));
  }
  onblur(e, t) {
    this._register(W(e, Q.BLUR, t));
  }
  onfocus(e, t) {
    this._register(W(e, Q.FOCUS, t));
  }
  ignoreGesture(e) {
    return At.ignoreTarget(e);
  }
};
const Gf = 11;
class d7 extends bo {
  constructor(e) {
    super(), this._onActivate = e.onActivate, this.bgDomNode = document.createElement("div"), this.bgDomNode.className = "arrow-background", this.bgDomNode.style.position = "absolute", this.bgDomNode.style.width = e.bgWidth + "px", this.bgDomNode.style.height = e.bgHeight + "px", typeof e.top < "u" && (this.bgDomNode.style.top = "0px"), typeof e.left < "u" && (this.bgDomNode.style.left = "0px"), typeof e.bottom < "u" && (this.bgDomNode.style.bottom = "0px"), typeof e.right < "u" && (this.bgDomNode.style.right = "0px"), this.domNode = document.createElement("div"), this.domNode.className = e.className, this.domNode.classList.add(...Le.asClassNameArray(e.icon)), this.domNode.style.position = "absolute", this.domNode.style.width = Gf + "px", this.domNode.style.height = Gf + "px", typeof e.top < "u" && (this.domNode.style.top = e.top + "px"), typeof e.left < "u" && (this.domNode.style.left = e.left + "px"), typeof e.bottom < "u" && (this.domNode.style.bottom = e.bottom + "px"), typeof e.right < "u" && (this.domNode.style.right = e.right + "px"), this._pointerMoveMonitor = this._register(new Np()), this._register(pi(this.bgDomNode, Q.POINTER_DOWN, (t) => this._arrowPointerDown(t))), this._register(pi(this.domNode, Q.POINTER_DOWN, (t) => this._arrowPointerDown(t))), this._pointerdownRepeatTimer = this._register(new n1()), this._pointerdownScheduleRepeatTimer = this._register(new vr());
  }
  _arrowPointerDown(e) {
    if (!e.target || !(e.target instanceof Element))
      return;
    const t = () => {
      this._pointerdownRepeatTimer.cancelAndSet(() => this._onActivate(), 1e3 / 24, we(e));
    };
    this._onActivate(), this._pointerdownRepeatTimer.cancel(), this._pointerdownScheduleRepeatTimer.cancelAndSet(t, 200), this._pointerMoveMonitor.startMonitoring(e.target, e.pointerId, e.buttons, (i) => {
    }, () => {
      this._pointerdownRepeatTimer.cancel(), this._pointerdownScheduleRepeatTimer.cancel();
    }), e.preventDefault();
  }
}
class c7 extends P {
  constructor(e, t, i) {
    super(), this._visibility = e, this._visibleClassName = t, this._invisibleClassName = i, this._domNode = null, this._isVisible = !1, this._isNeeded = !1, this._rawShouldBeVisible = !1, this._shouldBeVisible = !1, this._revealTimer = this._register(new vr());
  }
  setVisibility(e) {
    this._visibility !== e && (this._visibility = e, this._updateShouldBeVisible());
  }
  // ----------------- Hide / Reveal
  setShouldBeVisible(e) {
    this._rawShouldBeVisible = e, this._updateShouldBeVisible();
  }
  _applyVisibilitySetting() {
    return this._visibility === 2 ? !1 : this._visibility === 3 ? !0 : this._rawShouldBeVisible;
  }
  _updateShouldBeVisible() {
    const e = this._applyVisibilitySetting();
    this._shouldBeVisible !== e && (this._shouldBeVisible = e, this.ensureVisibility());
  }
  setIsNeeded(e) {
    this._isNeeded !== e && (this._isNeeded = e, this.ensureVisibility());
  }
  setDomNode(e) {
    this._domNode = e, this._domNode.setClassName(this._invisibleClassName), this.setShouldBeVisible(!1);
  }
  ensureVisibility() {
    if (!this._isNeeded) {
      this._hide(!1);
      return;
    }
    this._shouldBeVisible ? this._reveal() : this._hide(!0);
  }
  _reveal() {
    this._isVisible || (this._isVisible = !0, this._revealTimer.setIfNotSet(() => {
      var e;
      (e = this._domNode) === null || e === void 0 || e.setClassName(this._visibleClassName);
    }, 0));
  }
  _hide(e) {
    var t;
    this._revealTimer.cancel(), this._isVisible && (this._isVisible = !1, (t = this._domNode) === null || t === void 0 || t.setClassName(this._invisibleClassName + (e ? " fade" : "")));
  }
}
const h7 = 140;
class VV extends bo {
  constructor(e) {
    super(), this._lazyRender = e.lazyRender, this._host = e.host, this._scrollable = e.scrollable, this._scrollByPage = e.scrollByPage, this._scrollbarState = e.scrollbarState, this._visibilityController = this._register(new c7(e.visibility, "visible scrollbar " + e.extraScrollbarClassName, "invisible scrollbar " + e.extraScrollbarClassName)), this._visibilityController.setIsNeeded(this._scrollbarState.isNeeded()), this._pointerMoveMonitor = this._register(new Np()), this._shouldRender = !0, this.domNode = bt(document.createElement("div")), this.domNode.setAttribute("role", "presentation"), this.domNode.setAttribute("aria-hidden", "true"), this._visibilityController.setDomNode(this.domNode), this.domNode.setPosition("absolute"), this._register(W(this.domNode.domNode, Q.POINTER_DOWN, (t) => this._domNodePointerDown(t)));
  }
  // ----------------- creation
  /**
   * Creates the dom node for an arrow & adds it to the container
   */
  _createArrow(e) {
    const t = this._register(new d7(e));
    this.domNode.domNode.appendChild(t.bgDomNode), this.domNode.domNode.appendChild(t.domNode);
  }
  /**
   * Creates the slider dom node, adds it to the container & hooks up the events
   */
  _createSlider(e, t, i, n) {
    this.slider = bt(document.createElement("div")), this.slider.setClassName("slider"), this.slider.setPosition("absolute"), this.slider.setTop(e), this.slider.setLeft(t), typeof i == "number" && this.slider.setWidth(i), typeof n == "number" && this.slider.setHeight(n), this.slider.setLayerHinting(!0), this.slider.setContain("strict"), this.domNode.domNode.appendChild(this.slider.domNode), this._register(W(this.slider.domNode, Q.POINTER_DOWN, (s) => {
      s.button === 0 && (s.preventDefault(), this._sliderPointerDown(s));
    })), this.onclick(this.slider.domNode, (s) => {
      s.leftButton && s.stopPropagation();
    });
  }
  // ----------------- Update state
  _onElementSize(e) {
    return this._scrollbarState.setVisibleSize(e) && (this._visibilityController.setIsNeeded(this._scrollbarState.isNeeded()), this._shouldRender = !0, this._lazyRender || this.render()), this._shouldRender;
  }
  _onElementScrollSize(e) {
    return this._scrollbarState.setScrollSize(e) && (this._visibilityController.setIsNeeded(this._scrollbarState.isNeeded()), this._shouldRender = !0, this._lazyRender || this.render()), this._shouldRender;
  }
  _onElementScrollPosition(e) {
    return this._scrollbarState.setScrollPosition(e) && (this._visibilityController.setIsNeeded(this._scrollbarState.isNeeded()), this._shouldRender = !0, this._lazyRender || this.render()), this._shouldRender;
  }
  // ----------------- rendering
  beginReveal() {
    this._visibilityController.setShouldBeVisible(!0);
  }
  beginHide() {
    this._visibilityController.setShouldBeVisible(!1);
  }
  render() {
    this._shouldRender && (this._shouldRender = !1, this._renderDomNode(this._scrollbarState.getRectangleLargeSize(), this._scrollbarState.getRectangleSmallSize()), this._updateSlider(this._scrollbarState.getSliderSize(), this._scrollbarState.getArrowSize() + this._scrollbarState.getSliderPosition()));
  }
  // ----------------- DOM events
  _domNodePointerDown(e) {
    e.target === this.domNode.domNode && this._onPointerDown(e);
  }
  delegatePointerDown(e) {
    const t = this.domNode.domNode.getClientRects()[0].top, i = t + this._scrollbarState.getSliderPosition(), n = t + this._scrollbarState.getSliderPosition() + this._scrollbarState.getSliderSize(), s = this._sliderPointerPosition(e);
    i <= s && s <= n ? e.button === 0 && (e.preventDefault(), this._sliderPointerDown(e)) : this._onPointerDown(e);
  }
  _onPointerDown(e) {
    let t, i;
    if (e.target === this.domNode.domNode && typeof e.offsetX == "number" && typeof e.offsetY == "number")
      t = e.offsetX, i = e.offsetY;
    else {
      const s = Ei(this.domNode.domNode);
      t = e.pageX - s.left, i = e.pageY - s.top;
    }
    const n = this._pointerDownRelativePosition(t, i);
    this._setDesiredScrollPositionNow(this._scrollByPage ? this._scrollbarState.getDesiredScrollPositionFromOffsetPaged(n) : this._scrollbarState.getDesiredScrollPositionFromOffset(n)), e.button === 0 && (e.preventDefault(), this._sliderPointerDown(e));
  }
  _sliderPointerDown(e) {
    if (!e.target || !(e.target instanceof Element))
      return;
    const t = this._sliderPointerPosition(e), i = this._sliderOrthogonalPointerPosition(e), n = this._scrollbarState.clone();
    this.slider.toggleClassName("active", !0), this._pointerMoveMonitor.startMonitoring(e.target, e.pointerId, e.buttons, (s) => {
      const o = this._sliderOrthogonalPointerPosition(s), a = Math.abs(o - i);
      if (Ks && a > h7) {
        this._setDesiredScrollPositionNow(n.getScrollPosition());
        return;
      }
      const d = this._sliderPointerPosition(s) - t;
      this._setDesiredScrollPositionNow(n.getDesiredScrollPositionFromDelta(d));
    }, () => {
      this.slider.toggleClassName("active", !1), this._host.onDragEnd();
    }), this._host.onDragStart();
  }
  _setDesiredScrollPositionNow(e) {
    const t = {};
    this.writeScrollPosition(t, e), this._scrollable.setScrollPositionNow(t);
  }
  updateScrollbarSize(e) {
    this._updateScrollbarSize(e), this._scrollbarState.setScrollbarSize(e), this._shouldRender = !0, this._lazyRender || this.render();
  }
  isNeeded() {
    return this._scrollbarState.isNeeded();
  }
}
const u7 = 20;
class Zf {
  constructor(e, t, i, n, s, o) {
    this._scrollbarSize = Math.round(t), this._oppositeScrollbarSize = Math.round(i), this._arrowSize = Math.round(e), this._visibleSize = n, this._scrollSize = s, this._scrollPosition = o, this._computedAvailableSize = 0, this._computedIsNeeded = !1, this._computedSliderSize = 0, this._computedSliderRatio = 0, this._computedSliderPosition = 0, this._refreshComputedValues();
  }
  clone() {
    return new Zf(this._arrowSize, this._scrollbarSize, this._oppositeScrollbarSize, this._visibleSize, this._scrollSize, this._scrollPosition);
  }
  setVisibleSize(e) {
    const t = Math.round(e);
    return this._visibleSize !== t ? (this._visibleSize = t, this._refreshComputedValues(), !0) : !1;
  }
  setScrollSize(e) {
    const t = Math.round(e);
    return this._scrollSize !== t ? (this._scrollSize = t, this._refreshComputedValues(), !0) : !1;
  }
  setScrollPosition(e) {
    const t = Math.round(e);
    return this._scrollPosition !== t ? (this._scrollPosition = t, this._refreshComputedValues(), !0) : !1;
  }
  setScrollbarSize(e) {
    this._scrollbarSize = Math.round(e);
  }
  setOppositeScrollbarSize(e) {
    this._oppositeScrollbarSize = Math.round(e);
  }
  static _computeValues(e, t, i, n, s) {
    const o = Math.max(0, i - e), a = Math.max(0, o - 2 * t), l = n > 0 && n > i;
    if (!l)
      return {
        computedAvailableSize: Math.round(o),
        computedIsNeeded: l,
        computedSliderSize: Math.round(a),
        computedSliderRatio: 0,
        computedSliderPosition: 0
      };
    const d = Math.round(Math.max(u7, Math.floor(i * a / n))), c = (a - d) / (n - i), h = s * c;
    return {
      computedAvailableSize: Math.round(o),
      computedIsNeeded: l,
      computedSliderSize: Math.round(d),
      computedSliderRatio: c,
      computedSliderPosition: Math.round(h)
    };
  }
  _refreshComputedValues() {
    const e = Zf._computeValues(this._oppositeScrollbarSize, this._arrowSize, this._visibleSize, this._scrollSize, this._scrollPosition);
    this._computedAvailableSize = e.computedAvailableSize, this._computedIsNeeded = e.computedIsNeeded, this._computedSliderSize = e.computedSliderSize, this._computedSliderRatio = e.computedSliderRatio, this._computedSliderPosition = e.computedSliderPosition;
  }
  getArrowSize() {
    return this._arrowSize;
  }
  getScrollPosition() {
    return this._scrollPosition;
  }
  getRectangleLargeSize() {
    return this._computedAvailableSize;
  }
  getRectangleSmallSize() {
    return this._scrollbarSize;
  }
  isNeeded() {
    return this._computedIsNeeded;
  }
  getSliderSize() {
    return this._computedSliderSize;
  }
  getSliderPosition() {
    return this._computedSliderPosition;
  }
  /**
   * Compute a desired `scrollPosition` such that `offset` ends up in the center of the slider.
   * `offset` is based on the same coordinate system as the `sliderPosition`.
   */
  getDesiredScrollPositionFromOffset(e) {
    if (!this._computedIsNeeded)
      return 0;
    const t = e - this._arrowSize - this._computedSliderSize / 2;
    return Math.round(t / this._computedSliderRatio);
  }
  /**
   * Compute a desired `scrollPosition` from if offset is before or after the slider position.
   * If offset is before slider, treat as a page up (or left).  If after, page down (or right).
   * `offset` and `_computedSliderPosition` are based on the same coordinate system.
   * `_visibleSize` corresponds to a "page" of lines in the returned coordinate system.
   */
  getDesiredScrollPositionFromOffsetPaged(e) {
    if (!this._computedIsNeeded)
      return 0;
    const t = e - this._arrowSize;
    let i = this._scrollPosition;
    return t < this._computedSliderPosition ? i -= this._visibleSize : i += this._visibleSize, i;
  }
  /**
   * Compute a desired `scrollPosition` such that the slider moves by `delta`.
   */
  getDesiredScrollPositionFromDelta(e) {
    if (!this._computedIsNeeded)
      return 0;
    const t = this._computedSliderPosition + e;
    return Math.round(t / this._computedSliderRatio);
  }
}
class g7 extends VV {
  constructor(e, t, i) {
    const n = e.getScrollDimensions(), s = e.getCurrentScrollPosition();
    if (super({
      lazyRender: t.lazyRender,
      host: i,
      scrollbarState: new Zf(t.horizontalHasArrows ? t.arrowSize : 0, t.horizontal === 2 ? 0 : t.horizontalScrollbarSize, t.vertical === 2 ? 0 : t.verticalScrollbarSize, n.width, n.scrollWidth, s.scrollLeft),
      visibility: t.horizontal,
      extraScrollbarClassName: "horizontal",
      scrollable: e,
      scrollByPage: t.scrollByPage
    }), t.horizontalHasArrows) {
      const o = (t.arrowSize - Gf) / 2, a = (t.horizontalScrollbarSize - Gf) / 2;
      this._createArrow({
        className: "scra",
        icon: me.scrollbarButtonLeft,
        top: a,
        left: o,
        bottom: void 0,
        right: void 0,
        bgWidth: t.arrowSize,
        bgHeight: t.horizontalScrollbarSize,
        onActivate: () => this._host.onMouseWheel(new bu(null, 1, 0))
      }), this._createArrow({
        className: "scra",
        icon: me.scrollbarButtonRight,
        top: a,
        left: void 0,
        bottom: void 0,
        right: o,
        bgWidth: t.arrowSize,
        bgHeight: t.horizontalScrollbarSize,
        onActivate: () => this._host.onMouseWheel(new bu(null, -1, 0))
      });
    }
    this._createSlider(Math.floor((t.horizontalScrollbarSize - t.horizontalSliderSize) / 2), 0, void 0, t.horizontalSliderSize);
  }
  _updateSlider(e, t) {
    this.slider.setWidth(e), this.slider.setLeft(t);
  }
  _renderDomNode(e, t) {
    this.domNode.setWidth(e), this.domNode.setHeight(t), this.domNode.setLeft(0), this.domNode.setBottom(0);
  }
  onDidScroll(e) {
    return this._shouldRender = this._onElementScrollSize(e.scrollWidth) || this._shouldRender, this._shouldRender = this._onElementScrollPosition(e.scrollLeft) || this._shouldRender, this._shouldRender = this._onElementSize(e.width) || this._shouldRender, this._shouldRender;
  }
  _pointerDownRelativePosition(e, t) {
    return e;
  }
  _sliderPointerPosition(e) {
    return e.pageX;
  }
  _sliderOrthogonalPointerPosition(e) {
    return e.pageY;
  }
  _updateScrollbarSize(e) {
    this.slider.setHeight(e);
  }
  writeScrollPosition(e, t) {
    e.scrollLeft = t;
  }
  updateOptions(e) {
    this.updateScrollbarSize(e.horizontal === 2 ? 0 : e.horizontalScrollbarSize), this._scrollbarState.setOppositeScrollbarSize(e.vertical === 2 ? 0 : e.verticalScrollbarSize), this._visibilityController.setVisibility(e.horizontal), this._scrollByPage = e.scrollByPage;
  }
}
class f7 extends VV {
  constructor(e, t, i) {
    const n = e.getScrollDimensions(), s = e.getCurrentScrollPosition();
    if (super({
      lazyRender: t.lazyRender,
      host: i,
      scrollbarState: new Zf(
        t.verticalHasArrows ? t.arrowSize : 0,
        t.vertical === 2 ? 0 : t.verticalScrollbarSize,
        // give priority to vertical scroll bar over horizontal and let it scroll all the way to the bottom
        0,
        n.height,
        n.scrollHeight,
        s.scrollTop
      ),
      visibility: t.vertical,
      extraScrollbarClassName: "vertical",
      scrollable: e,
      scrollByPage: t.scrollByPage
    }), t.verticalHasArrows) {
      const o = (t.arrowSize - Gf) / 2, a = (t.verticalScrollbarSize - Gf) / 2;
      this._createArrow({
        className: "scra",
        icon: me.scrollbarButtonUp,
        top: o,
        left: a,
        bottom: void 0,
        right: void 0,
        bgWidth: t.verticalScrollbarSize,
        bgHeight: t.arrowSize,
        onActivate: () => this._host.onMouseWheel(new bu(null, 0, 1))
      }), this._createArrow({
        className: "scra",
        icon: me.scrollbarButtonDown,
        top: void 0,
        left: a,
        bottom: o,
        right: void 0,
        bgWidth: t.verticalScrollbarSize,
        bgHeight: t.arrowSize,
        onActivate: () => this._host.onMouseWheel(new bu(null, 0, -1))
      });
    }
    this._createSlider(0, Math.floor((t.verticalScrollbarSize - t.verticalSliderSize) / 2), t.verticalSliderSize, void 0);
  }
  _updateSlider(e, t) {
    this.slider.setHeight(e), this.slider.setTop(t);
  }
  _renderDomNode(e, t) {
    this.domNode.setWidth(t), this.domNode.setHeight(e), this.domNode.setRight(0), this.domNode.setTop(0);
  }
  onDidScroll(e) {
    return this._shouldRender = this._onElementScrollSize(e.scrollHeight) || this._shouldRender, this._shouldRender = this._onElementScrollPosition(e.scrollTop) || this._shouldRender, this._shouldRender = this._onElementSize(e.height) || this._shouldRender, this._shouldRender;
  }
  _pointerDownRelativePosition(e, t) {
    return t;
  }
  _sliderPointerPosition(e) {
    return e.pageY;
  }
  _sliderOrthogonalPointerPosition(e) {
    return e.pageX;
  }
  _updateScrollbarSize(e) {
    this.slider.setWidth(e);
  }
  writeScrollPosition(e, t) {
    e.scrollTop = t;
  }
  updateOptions(e) {
    this.updateScrollbarSize(e.vertical === 2 ? 0 : e.verticalScrollbarSize), this._scrollbarState.setOppositeScrollbarSize(0), this._visibilityController.setVisibility(e.vertical), this._scrollByPage = e.scrollByPage;
  }
}
class wS {
  constructor(e, t, i, n, s, o, a) {
    this._forceIntegerValues = e, this._scrollStateBrand = void 0, this._forceIntegerValues && (t = t | 0, i = i | 0, n = n | 0, s = s | 0, o = o | 0, a = a | 0), this.rawScrollLeft = n, this.rawScrollTop = a, t < 0 && (t = 0), n + t > i && (n = i - t), n < 0 && (n = 0), s < 0 && (s = 0), a + s > o && (a = o - s), a < 0 && (a = 0), this.width = t, this.scrollWidth = i, this.scrollLeft = n, this.height = s, this.scrollHeight = o, this.scrollTop = a;
  }
  equals(e) {
    return this.rawScrollLeft === e.rawScrollLeft && this.rawScrollTop === e.rawScrollTop && this.width === e.width && this.scrollWidth === e.scrollWidth && this.scrollLeft === e.scrollLeft && this.height === e.height && this.scrollHeight === e.scrollHeight && this.scrollTop === e.scrollTop;
  }
  withScrollDimensions(e, t) {
    return new wS(this._forceIntegerValues, typeof e.width < "u" ? e.width : this.width, typeof e.scrollWidth < "u" ? e.scrollWidth : this.scrollWidth, t ? this.rawScrollLeft : this.scrollLeft, typeof e.height < "u" ? e.height : this.height, typeof e.scrollHeight < "u" ? e.scrollHeight : this.scrollHeight, t ? this.rawScrollTop : this.scrollTop);
  }
  withScrollPosition(e) {
    return new wS(this._forceIntegerValues, this.width, this.scrollWidth, typeof e.scrollLeft < "u" ? e.scrollLeft : this.rawScrollLeft, this.height, this.scrollHeight, typeof e.scrollTop < "u" ? e.scrollTop : this.rawScrollTop);
  }
  createScrollEvent(e, t) {
    const i = this.width !== e.width, n = this.scrollWidth !== e.scrollWidth, s = this.scrollLeft !== e.scrollLeft, o = this.height !== e.height, a = this.scrollHeight !== e.scrollHeight, l = this.scrollTop !== e.scrollTop;
    return {
      inSmoothScrolling: t,
      oldWidth: e.width,
      oldScrollWidth: e.scrollWidth,
      oldScrollLeft: e.scrollLeft,
      width: this.width,
      scrollWidth: this.scrollWidth,
      scrollLeft: this.scrollLeft,
      oldHeight: e.height,
      oldScrollHeight: e.scrollHeight,
      oldScrollTop: e.scrollTop,
      height: this.height,
      scrollHeight: this.scrollHeight,
      scrollTop: this.scrollTop,
      widthChanged: i,
      scrollWidthChanged: n,
      scrollLeftChanged: s,
      heightChanged: o,
      scrollHeightChanged: a,
      scrollTopChanged: l
    };
  }
}
class Mp extends P {
  constructor(e) {
    super(), this._scrollableBrand = void 0, this._onScroll = this._register(new R()), this.onScroll = this._onScroll.event, this._smoothScrollDuration = e.smoothScrollDuration, this._scheduleAtNextAnimationFrame = e.scheduleAtNextAnimationFrame, this._state = new wS(e.forceIntegerValues, 0, 0, 0, 0, 0, 0), this._smoothScrolling = null;
  }
  dispose() {
    this._smoothScrolling && (this._smoothScrolling.dispose(), this._smoothScrolling = null), super.dispose();
  }
  setSmoothScrollDuration(e) {
    this._smoothScrollDuration = e;
  }
  validateScrollPosition(e) {
    return this._state.withScrollPosition(e);
  }
  getScrollDimensions() {
    return this._state;
  }
  setScrollDimensions(e, t) {
    var i;
    const n = this._state.withScrollDimensions(e, t);
    this._setState(n, !!this._smoothScrolling), (i = this._smoothScrolling) === null || i === void 0 || i.acceptScrollDimensions(this._state);
  }
  /**
   * Returns the final scroll position that the instance will have once the smooth scroll animation concludes.
   * If no scroll animation is occurring, it will return the current scroll position instead.
   */
  getFutureScrollPosition() {
    return this._smoothScrolling ? this._smoothScrolling.to : this._state;
  }
  /**
   * Returns the current scroll position.
   * Note: This result might be an intermediate scroll position, as there might be an ongoing smooth scroll animation.
   */
  getCurrentScrollPosition() {
    return this._state;
  }
  setScrollPositionNow(e) {
    const t = this._state.withScrollPosition(e);
    this._smoothScrolling && (this._smoothScrolling.dispose(), this._smoothScrolling = null), this._setState(t, !1);
  }
  setScrollPositionSmooth(e, t) {
    if (this._smoothScrollDuration === 0)
      return this.setScrollPositionNow(e);
    if (this._smoothScrolling) {
      e = {
        scrollLeft: typeof e.scrollLeft > "u" ? this._smoothScrolling.to.scrollLeft : e.scrollLeft,
        scrollTop: typeof e.scrollTop > "u" ? this._smoothScrolling.to.scrollTop : e.scrollTop
      };
      const i = this._state.withScrollPosition(e);
      if (this._smoothScrolling.to.scrollLeft === i.scrollLeft && this._smoothScrolling.to.scrollTop === i.scrollTop)
        return;
      let n;
      t ? n = new j_(this._smoothScrolling.from, i, this._smoothScrolling.startTime, this._smoothScrolling.duration) : n = this._smoothScrolling.combine(this._state, i, this._smoothScrollDuration), this._smoothScrolling.dispose(), this._smoothScrolling = n;
    } else {
      const i = this._state.withScrollPosition(e);
      this._smoothScrolling = j_.start(this._state, i, this._smoothScrollDuration);
    }
    this._smoothScrolling.animationFrameDisposable = this._scheduleAtNextAnimationFrame(() => {
      this._smoothScrolling && (this._smoothScrolling.animationFrameDisposable = null, this._performSmoothScrolling());
    });
  }
  hasPendingScrollAnimation() {
    return !!this._smoothScrolling;
  }
  _performSmoothScrolling() {
    if (!this._smoothScrolling)
      return;
    const e = this._smoothScrolling.tick(), t = this._state.withScrollPosition(e);
    if (this._setState(t, !0), !!this._smoothScrolling) {
      if (e.isDone) {
        this._smoothScrolling.dispose(), this._smoothScrolling = null;
        return;
      }
      this._smoothScrolling.animationFrameDisposable = this._scheduleAtNextAnimationFrame(() => {
        this._smoothScrolling && (this._smoothScrolling.animationFrameDisposable = null, this._performSmoothScrolling());
      });
    }
  }
  _setState(e, t) {
    const i = this._state;
    i.equals(e) || (this._state = e, this._onScroll.fire(this._state.createScrollEvent(i, t)));
  }
}
class mP {
  constructor(e, t, i) {
    this.scrollLeft = e, this.scrollTop = t, this.isDone = i;
  }
}
function $D(r, e) {
  const t = e - r;
  return function(i) {
    return r + t * _7(i);
  };
}
function p7(r, e, t) {
  return function(i) {
    return i < t ? r(i / t) : e((i - t) / (1 - t));
  };
}
class j_ {
  constructor(e, t, i, n) {
    this.from = e, this.to = t, this.duration = n, this.startTime = i, this.animationFrameDisposable = null, this._initAnimations();
  }
  _initAnimations() {
    this.scrollLeft = this._initAnimation(this.from.scrollLeft, this.to.scrollLeft, this.to.width), this.scrollTop = this._initAnimation(this.from.scrollTop, this.to.scrollTop, this.to.height);
  }
  _initAnimation(e, t, i) {
    if (Math.abs(e - t) > 2.5 * i) {
      let s, o;
      return e < t ? (s = e + 0.75 * i, o = t - 0.75 * i) : (s = e - 0.75 * i, o = t + 0.75 * i), p7($D(e, s), $D(o, t), 0.33);
    }
    return $D(e, t);
  }
  dispose() {
    this.animationFrameDisposable !== null && (this.animationFrameDisposable.dispose(), this.animationFrameDisposable = null);
  }
  acceptScrollDimensions(e) {
    this.to = e.withScrollPosition(this.to), this._initAnimations();
  }
  tick() {
    return this._tick(Date.now());
  }
  _tick(e) {
    const t = (e - this.startTime) / this.duration;
    if (t < 1) {
      const i = this.scrollLeft(t), n = this.scrollTop(t);
      return new mP(i, n, !1);
    }
    return new mP(this.to.scrollLeft, this.to.scrollTop, !0);
  }
  combine(e, t, i) {
    return j_.start(e, t, i);
  }
  static start(e, t, i) {
    i = i + 10;
    const n = Date.now() - 10;
    return new j_(e, t, n, i);
  }
}
function m7(r) {
  return Math.pow(r, 3);
}
function _7(r) {
  return 1 - m7(1 - r);
}
const v7 = 500, _P = 50;
class b7 {
  constructor(e, t, i) {
    this.timestamp = e, this.deltaX = t, this.deltaY = i, this.score = 0;
  }
}
class SS {
  constructor() {
    this._capacity = 5, this._memory = [], this._front = -1, this._rear = -1;
  }
  isPhysicalMouseWheel() {
    if (this._front === -1 && this._rear === -1)
      return !1;
    let e = 1, t = 0, i = 1, n = this._rear;
    do {
      const s = n === this._front ? e : Math.pow(2, -i);
      if (e -= s, t += this._memory[n].score * s, n === this._front)
        break;
      n = (this._capacity + n - 1) % this._capacity, i++;
    } while (!0);
    return t <= 0.5;
  }
  acceptStandardWheelEvent(e) {
    if (ob) {
      const t = we(e.browserEvent), i = Zj(t);
      this.accept(Date.now(), e.deltaX * i, e.deltaY * i);
    } else
      this.accept(Date.now(), e.deltaX, e.deltaY);
  }
  accept(e, t, i) {
    let n = null;
    const s = new b7(e, t, i);
    this._front === -1 && this._rear === -1 ? (this._memory[0] = s, this._front = 0, this._rear = 0) : (n = this._memory[this._rear], this._rear = (this._rear + 1) % this._capacity, this._rear === this._front && (this._front = (this._front + 1) % this._capacity), this._memory[this._rear] = s), s.score = this._computeScore(s, n);
  }
  /**
   * A score between 0 and 1 for `item`.
   *  - a score towards 0 indicates that the source appears to be a physical mouse wheel
   *  - a score towards 1 indicates that the source appears to be a touchpad or magic mouse, etc.
   */
  _computeScore(e, t) {
    if (Math.abs(e.deltaX) > 0 && Math.abs(e.deltaY) > 0)
      return 1;
    let i = 0.5;
    if ((!this._isAlmostInt(e.deltaX) || !this._isAlmostInt(e.deltaY)) && (i += 0.25), t) {
      const n = Math.abs(e.deltaX), s = Math.abs(e.deltaY), o = Math.abs(t.deltaX), a = Math.abs(t.deltaY), l = Math.max(Math.min(n, o), 1), d = Math.max(Math.min(s, a), 1), c = Math.max(n, o), h = Math.max(s, a);
      c % l === 0 && h % d === 0 && (i -= 0.5);
    }
    return Math.min(Math.max(i, 0), 1);
  }
  _isAlmostInt(e) {
    return Math.abs(Math.round(e) - e) < 0.01;
  }
}
SS.INSTANCE = new SS();
class k1 extends bo {
  get options() {
    return this._options;
  }
  constructor(e, t, i) {
    super(), this._onScroll = this._register(new R()), this.onScroll = this._onScroll.event, this._onWillScroll = this._register(new R()), e.style.overflow = "hidden", this._options = C7(t), this._scrollable = i, this._register(this._scrollable.onScroll((s) => {
      this._onWillScroll.fire(s), this._onDidScroll(s), this._onScroll.fire(s);
    }));
    const n = {
      onMouseWheel: (s) => this._onMouseWheel(s),
      onDragStart: () => this._onDragStart(),
      onDragEnd: () => this._onDragEnd()
    };
    this._verticalScrollbar = this._register(new f7(this._scrollable, this._options, n)), this._horizontalScrollbar = this._register(new g7(this._scrollable, this._options, n)), this._domNode = document.createElement("div"), this._domNode.className = "monaco-scrollable-element " + this._options.className, this._domNode.setAttribute("role", "presentation"), this._domNode.style.position = "relative", this._domNode.style.overflow = "hidden", this._domNode.appendChild(e), this._domNode.appendChild(this._horizontalScrollbar.domNode.domNode), this._domNode.appendChild(this._verticalScrollbar.domNode.domNode), this._options.useShadows ? (this._leftShadowDomNode = bt(document.createElement("div")), this._leftShadowDomNode.setClassName("shadow"), this._domNode.appendChild(this._leftShadowDomNode.domNode), this._topShadowDomNode = bt(document.createElement("div")), this._topShadowDomNode.setClassName("shadow"), this._domNode.appendChild(this._topShadowDomNode.domNode), this._topLeftShadowDomNode = bt(document.createElement("div")), this._topLeftShadowDomNode.setClassName("shadow"), this._domNode.appendChild(this._topLeftShadowDomNode.domNode)) : (this._leftShadowDomNode = null, this._topShadowDomNode = null, this._topLeftShadowDomNode = null), this._listenOnDomNode = this._options.listenOnDomNode || this._domNode, this._mouseWheelToDispose = [], this._setListeningToMouseWheel(this._options.handleMouseWheel), this.onmouseover(this._listenOnDomNode, (s) => this._onMouseOver(s)), this.onmouseleave(this._listenOnDomNode, (s) => this._onMouseLeave(s)), this._hideTimeout = this._register(new vr()), this._isDragging = !1, this._mouseIsOver = !1, this._shouldRender = !0, this._revealOnScroll = !0;
  }
  dispose() {
    this._mouseWheelToDispose = zt(this._mouseWheelToDispose), super.dispose();
  }
  /**
   * Get the generated 'scrollable' dom node
   */
  getDomNode() {
    return this._domNode;
  }
  getOverviewRulerLayoutInfo() {
    return {
      parent: this._domNode,
      insertBefore: this._verticalScrollbar.domNode.domNode
    };
  }
  /**
   * Delegate a pointer down event to the vertical scrollbar.
   * This is to help with clicking somewhere else and having the scrollbar react.
   */
  delegateVerticalScrollbarPointerDown(e) {
    this._verticalScrollbar.delegatePointerDown(e);
  }
  getScrollDimensions() {
    return this._scrollable.getScrollDimensions();
  }
  setScrollDimensions(e) {
    this._scrollable.setScrollDimensions(e, !1);
  }
  /**
   * Update the class name of the scrollable element.
   */
  updateClassName(e) {
    this._options.className = e, Je && (this._options.className += " mac"), this._domNode.className = "monaco-scrollable-element " + this._options.className;
  }
  /**
   * Update configuration options for the scrollbar.
   */
  updateOptions(e) {
    typeof e.handleMouseWheel < "u" && (this._options.handleMouseWheel = e.handleMouseWheel, this._setListeningToMouseWheel(this._options.handleMouseWheel)), typeof e.mouseWheelScrollSensitivity < "u" && (this._options.mouseWheelScrollSensitivity = e.mouseWheelScrollSensitivity), typeof e.fastScrollSensitivity < "u" && (this._options.fastScrollSensitivity = e.fastScrollSensitivity), typeof e.scrollPredominantAxis < "u" && (this._options.scrollPredominantAxis = e.scrollPredominantAxis), typeof e.horizontal < "u" && (this._options.horizontal = e.horizontal), typeof e.vertical < "u" && (this._options.vertical = e.vertical), typeof e.horizontalScrollbarSize < "u" && (this._options.horizontalScrollbarSize = e.horizontalScrollbarSize), typeof e.verticalScrollbarSize < "u" && (this._options.verticalScrollbarSize = e.verticalScrollbarSize), typeof e.scrollByPage < "u" && (this._options.scrollByPage = e.scrollByPage), this._horizontalScrollbar.updateOptions(this._options), this._verticalScrollbar.updateOptions(this._options), this._options.lazyRender || this._render();
  }
  delegateScrollFromMouseWheelEvent(e) {
    this._onMouseWheel(new bu(e));
  }
  // -------------------- mouse wheel scrolling --------------------
  _setListeningToMouseWheel(e) {
    if (this._mouseWheelToDispose.length > 0 !== e && (this._mouseWheelToDispose = zt(this._mouseWheelToDispose), e)) {
      const i = (n) => {
        this._onMouseWheel(new bu(n));
      };
      this._mouseWheelToDispose.push(W(this._listenOnDomNode, Q.MOUSE_WHEEL, i, { passive: !1 }));
    }
  }
  _onMouseWheel(e) {
    var t;
    if (!((t = e.browserEvent) === null || t === void 0) && t.defaultPrevented)
      return;
    const i = SS.INSTANCE;
    i.acceptStandardWheelEvent(e);
    let n = !1;
    if (e.deltaY || e.deltaX) {
      let o = e.deltaY * this._options.mouseWheelScrollSensitivity, a = e.deltaX * this._options.mouseWheelScrollSensitivity;
      this._options.scrollPredominantAxis && (this._options.scrollYToX && a + o === 0 ? a = o = 0 : Math.abs(o) >= Math.abs(a) ? a = 0 : o = 0), this._options.flipAxes && ([o, a] = [a, o]);
      const l = !Je && e.browserEvent && e.browserEvent.shiftKey;
      (this._options.scrollYToX || l) && !a && (a = o, o = 0), e.browserEvent && e.browserEvent.altKey && (a = a * this._options.fastScrollSensitivity, o = o * this._options.fastScrollSensitivity);
      const d = this._scrollable.getFutureScrollPosition();
      let c = {};
      if (o) {
        const h = _P * o, u = d.scrollTop - (h < 0 ? Math.floor(h) : Math.ceil(h));
        this._verticalScrollbar.writeScrollPosition(c, u);
      }
      if (a) {
        const h = _P * a, u = d.scrollLeft - (h < 0 ? Math.floor(h) : Math.ceil(h));
        this._horizontalScrollbar.writeScrollPosition(c, u);
      }
      c = this._scrollable.validateScrollPosition(c), (d.scrollLeft !== c.scrollLeft || d.scrollTop !== c.scrollTop) && (this._options.mouseWheelSmoothScroll && i.isPhysicalMouseWheel() ? this._scrollable.setScrollPositionSmooth(c) : this._scrollable.setScrollPositionNow(c), n = !0);
    }
    let s = n;
    !s && this._options.alwaysConsumeMouseWheel && (s = !0), !s && this._options.consumeMouseWheelIfScrollbarIsNeeded && (this._verticalScrollbar.isNeeded() || this._horizontalScrollbar.isNeeded()) && (s = !0), s && (e.preventDefault(), e.stopPropagation());
  }
  _onDidScroll(e) {
    this._shouldRender = this._horizontalScrollbar.onDidScroll(e) || this._shouldRender, this._shouldRender = this._verticalScrollbar.onDidScroll(e) || this._shouldRender, this._options.useShadows && (this._shouldRender = !0), this._revealOnScroll && this._reveal(), this._options.lazyRender || this._render();
  }
  /**
   * Render / mutate the DOM now.
   * Should be used together with the ctor option `lazyRender`.
   */
  renderNow() {
    if (!this._options.lazyRender)
      throw new Error("Please use `lazyRender` together with `renderNow`!");
    this._render();
  }
  _render() {
    if (this._shouldRender && (this._shouldRender = !1, this._horizontalScrollbar.render(), this._verticalScrollbar.render(), this._options.useShadows)) {
      const e = this._scrollable.getCurrentScrollPosition(), t = e.scrollTop > 0, i = e.scrollLeft > 0, n = i ? " left" : "", s = t ? " top" : "", o = i || t ? " top-left-corner" : "";
      this._leftShadowDomNode.setClassName(`shadow${n}`), this._topShadowDomNode.setClassName(`shadow${s}`), this._topLeftShadowDomNode.setClassName(`shadow${o}${s}${n}`);
    }
  }
  // -------------------- fade in / fade out --------------------
  _onDragStart() {
    this._isDragging = !0, this._reveal();
  }
  _onDragEnd() {
    this._isDragging = !1, this._hide();
  }
  _onMouseLeave(e) {
    this._mouseIsOver = !1, this._hide();
  }
  _onMouseOver(e) {
    this._mouseIsOver = !0, this._reveal();
  }
  _reveal() {
    this._verticalScrollbar.beginReveal(), this._horizontalScrollbar.beginReveal(), this._scheduleHide();
  }
  _hide() {
    !this._mouseIsOver && !this._isDragging && (this._verticalScrollbar.beginHide(), this._horizontalScrollbar.beginHide());
  }
  _scheduleHide() {
    !this._mouseIsOver && !this._isDragging && this._hideTimeout.cancelAndSet(() => this._hide(), v7);
  }
}
class zV extends k1 {
  constructor(e, t) {
    t = t || {}, t.mouseWheelSmoothScroll = !1;
    const i = new Mp({
      forceIntegerValues: !0,
      smoothScrollDuration: 0,
      scheduleAtNextAnimationFrame: (n) => Us(we(e), n)
    });
    super(e, t, i), this._register(i);
  }
  setScrollPosition(e) {
    this._scrollable.setScrollPositionNow(e);
  }
}
class I0 extends k1 {
  constructor(e, t, i) {
    super(e, t, i);
  }
  setScrollPosition(e) {
    e.reuseAnimation ? this._scrollable.setScrollPositionSmooth(e, e.reuseAnimation) : this._scrollable.setScrollPositionNow(e);
  }
  getScrollPosition() {
    return this._scrollable.getCurrentScrollPosition();
  }
}
class pb extends k1 {
  constructor(e, t) {
    t = t || {}, t.mouseWheelSmoothScroll = !1;
    const i = new Mp({
      forceIntegerValues: !1,
      // See https://github.com/microsoft/vscode/issues/139877
      smoothScrollDuration: 0,
      scheduleAtNextAnimationFrame: (n) => Us(we(e), n)
    });
    super(e, t, i), this._register(i), this._element = e, this._register(this.onScroll((n) => {
      n.scrollTopChanged && (this._element.scrollTop = n.scrollTop), n.scrollLeftChanged && (this._element.scrollLeft = n.scrollLeft);
    })), this.scanDomNode();
  }
  setScrollPosition(e) {
    this._scrollable.setScrollPositionNow(e);
  }
  getScrollPosition() {
    return this._scrollable.getCurrentScrollPosition();
  }
  scanDomNode() {
    this.setScrollDimensions({
      width: this._element.clientWidth,
      scrollWidth: this._element.scrollWidth,
      height: this._element.clientHeight,
      scrollHeight: this._element.scrollHeight
    }), this.setScrollPosition({
      scrollLeft: this._element.scrollLeft,
      scrollTop: this._element.scrollTop
    });
  }
}
function C7(r) {
  const e = {
    lazyRender: typeof r.lazyRender < "u" ? r.lazyRender : !1,
    className: typeof r.className < "u" ? r.className : "",
    useShadows: typeof r.useShadows < "u" ? r.useShadows : !0,
    handleMouseWheel: typeof r.handleMouseWheel < "u" ? r.handleMouseWheel : !0,
    flipAxes: typeof r.flipAxes < "u" ? r.flipAxes : !1,
    consumeMouseWheelIfScrollbarIsNeeded: typeof r.consumeMouseWheelIfScrollbarIsNeeded < "u" ? r.consumeMouseWheelIfScrollbarIsNeeded : !1,
    alwaysConsumeMouseWheel: typeof r.alwaysConsumeMouseWheel < "u" ? r.alwaysConsumeMouseWheel : !1,
    scrollYToX: typeof r.scrollYToX < "u" ? r.scrollYToX : !1,
    mouseWheelScrollSensitivity: typeof r.mouseWheelScrollSensitivity < "u" ? r.mouseWheelScrollSensitivity : 1,
    fastScrollSensitivity: typeof r.fastScrollSensitivity < "u" ? r.fastScrollSensitivity : 5,
    scrollPredominantAxis: typeof r.scrollPredominantAxis < "u" ? r.scrollPredominantAxis : !0,
    mouseWheelSmoothScroll: typeof r.mouseWheelSmoothScroll < "u" ? r.mouseWheelSmoothScroll : !0,
    arrowSize: typeof r.arrowSize < "u" ? r.arrowSize : 11,
    listenOnDomNode: typeof r.listenOnDomNode < "u" ? r.listenOnDomNode : null,
    horizontal: typeof r.horizontal < "u" ? r.horizontal : 1,
    horizontalScrollbarSize: typeof r.horizontalScrollbarSize < "u" ? r.horizontalScrollbarSize : 10,
    horizontalSliderSize: typeof r.horizontalSliderSize < "u" ? r.horizontalSliderSize : 0,
    horizontalHasArrows: typeof r.horizontalHasArrows < "u" ? r.horizontalHasArrows : !1,
    vertical: typeof r.vertical < "u" ? r.vertical : 1,
    verticalScrollbarSize: typeof r.verticalScrollbarSize < "u" ? r.verticalScrollbarSize : 10,
    verticalHasArrows: typeof r.verticalHasArrows < "u" ? r.verticalHasArrows : !1,
    verticalSliderSize: typeof r.verticalSliderSize < "u" ? r.verticalSliderSize : 0,
    scrollByPage: typeof r.scrollByPage < "u" ? r.scrollByPage : !1
  };
  return e.horizontalSliderSize = typeof r.horizontalSliderSize < "u" ? r.horizontalSliderSize : e.horizontalScrollbarSize, e.verticalSliderSize = typeof r.verticalSliderSize < "u" ? r.verticalSliderSize : e.verticalScrollbarSize, Je && (e.className += " mac"), e;
}
class x1 extends fb {
  constructor(e, t, i) {
    super(), this._mouseLeaveMonitor = null, this._context = e, this.viewController = t, this.viewHelper = i, this.mouseTargetFactory = new Hn(this._context, i), this._mouseDownOperation = this._register(new w7(this._context, this.viewController, this.viewHelper, this.mouseTargetFactory, (o, a) => this._createMouseTarget(o, a), (o) => this._getMouseColumn(o))), this.lastMouseLeaveTime = -1, this._height = this._context.configuration.options.get(
      145
      /* EditorOption.layoutInfo */
    ).height;
    const n = new K9(this.viewHelper.viewDomNode);
    this._register(n.onContextMenu(this.viewHelper.viewDomNode, (o) => this._onContextMenu(o, !0))), this._register(n.onMouseMove(this.viewHelper.viewDomNode, (o) => {
      this._onMouseMove(o), this._mouseLeaveMonitor || (this._mouseLeaveMonitor = W(this.viewHelper.viewDomNode.ownerDocument, "mousemove", (a) => {
        this.viewHelper.viewDomNode.contains(a.target) || this._onMouseLeave(new Pc(a, !1, this.viewHelper.viewDomNode));
      }));
    })), this._register(n.onMouseUp(this.viewHelper.viewDomNode, (o) => this._onMouseUp(o))), this._register(n.onMouseLeave(this.viewHelper.viewDomNode, (o) => this._onMouseLeave(o)));
    let s = 0;
    this._register(n.onPointerDown(this.viewHelper.viewDomNode, (o, a) => {
      s = a;
    })), this._register(W(this.viewHelper.viewDomNode, Q.POINTER_UP, (o) => {
      this._mouseDownOperation.onPointerUp();
    })), this._register(n.onMouseDown(this.viewHelper.viewDomNode, (o) => this._onMouseDown(o, s))), this._setupMouseWheelZoomListener(), this._context.addEventHandler(this);
  }
  _setupMouseWheelZoomListener() {
    const e = SS.INSTANCE;
    let t = 0, i = xo.getZoomLevel(), n = !1, s = 0;
    const o = (l) => {
      if (this.viewController.emitMouseWheel(l), !this._context.configuration.options.get(
        76
        /* EditorOption.mouseWheelZoom */
      ))
        return;
      const d = new bu(l);
      if (e.acceptStandardWheelEvent(d), e.isPhysicalMouseWheel()) {
        if (a(l)) {
          const c = xo.getZoomLevel(), h = d.deltaY > 0 ? 1 : -1;
          xo.setZoomLevel(c + h), d.preventDefault(), d.stopPropagation();
        }
      } else
        Date.now() - t > 50 && (i = xo.getZoomLevel(), n = a(l), s = 0), t = Date.now(), s += d.deltaY, n && (xo.setZoomLevel(i + s / 5), d.preventDefault(), d.stopPropagation());
    };
    this._register(W(this.viewHelper.viewDomNode, Q.MOUSE_WHEEL, o, { capture: !0, passive: !1 }));
    function a(l) {
      return Je ? (l.metaKey || l.ctrlKey) && !l.shiftKey && !l.altKey : l.ctrlKey && !l.metaKey && !l.shiftKey && !l.altKey;
    }
  }
  dispose() {
    this._context.removeEventHandler(this), this._mouseLeaveMonitor && (this._mouseLeaveMonitor.dispose(), this._mouseLeaveMonitor = null), super.dispose();
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    if (e.hasChanged(
      145
      /* EditorOption.layoutInfo */
    )) {
      const t = this._context.configuration.options.get(
        145
        /* EditorOption.layoutInfo */
      ).height;
      this._height !== t && (this._height = t, this._mouseDownOperation.onHeightChanged());
    }
    return !1;
  }
  onCursorStateChanged(e) {
    return this._mouseDownOperation.onCursorStateChanged(e), !1;
  }
  onFocusChanged(e) {
    return !1;
  }
  // --- end event handlers
  getTargetAtClientPoint(e, t) {
    const n = new FV(e, t).toPageCoordinates(we(this.viewHelper.viewDomNode)), s = y1(this.viewHelper.viewDomNode);
    if (n.y < s.y || n.y > s.y + s.height || n.x < s.x || n.x > s.x + s.width)
      return null;
    const o = L1(this.viewHelper.viewDomNode, s, n);
    return this.mouseTargetFactory.createMouseTarget(this.viewHelper.getLastRenderData(), s, n, o, null);
  }
  _createMouseTarget(e, t) {
    let i = e.target;
    if (!this.viewHelper.viewDomNode.contains(i)) {
      const n = Cu(this.viewHelper.viewDomNode);
      n && (i = n.elementsFromPoint(e.posx, e.posy).find((s) => this.viewHelper.viewDomNode.contains(s)));
    }
    return this.mouseTargetFactory.createMouseTarget(this.viewHelper.getLastRenderData(), e.editorPos, e.pos, e.relativePos, t ? i : null);
  }
  _getMouseColumn(e) {
    return this.mouseTargetFactory.getMouseColumn(e.relativePos);
  }
  _onContextMenu(e, t) {
    this.viewController.emitContextMenu({
      event: e,
      target: this._createMouseTarget(e, t)
    });
  }
  _onMouseMove(e) {
    this.mouseTargetFactory.mouseTargetIsWidget(e) || e.preventDefault(), !(this._mouseDownOperation.isActive() || e.timestamp < this.lastMouseLeaveTime) && this.viewController.emitMouseMove({
      event: e,
      target: this._createMouseTarget(e, !0)
    });
  }
  _onMouseLeave(e) {
    this._mouseLeaveMonitor && (this._mouseLeaveMonitor.dispose(), this._mouseLeaveMonitor = null), this.lastMouseLeaveTime = (/* @__PURE__ */ new Date()).getTime(), this.viewController.emitMouseLeave({
      event: e,
      target: null
    });
  }
  _onMouseUp(e) {
    this.viewController.emitMouseUp({
      event: e,
      target: this._createMouseTarget(e, !0)
    });
  }
  _onMouseDown(e, t) {
    const i = this._createMouseTarget(e, !0), n = i.type === 6 || i.type === 7, s = i.type === 2 || i.type === 3 || i.type === 4, o = i.type === 3, a = this._context.configuration.options.get(
      109
      /* EditorOption.selectOnLineNumbers */
    ), l = i.type === 8 || i.type === 5, d = i.type === 9;
    let c = e.leftButton || e.middleButton;
    Je && e.leftButton && e.ctrlKey && (c = !1);
    const h = () => {
      e.preventDefault(), this.viewHelper.focusTextArea();
    };
    if (c && (n || o && a))
      h(), this._mouseDownOperation.start(i.type, e, t);
    else if (s)
      e.preventDefault();
    else if (l) {
      const u = i.detail;
      c && this.viewHelper.shouldSuppressMouseDownOnViewZone(u.viewZoneId) && (h(), this._mouseDownOperation.start(i.type, e, t), e.preventDefault());
    } else d && this.viewHelper.shouldSuppressMouseDownOnWidget(i.detail) && (h(), e.preventDefault());
    this.viewController.emitMouseDown({
      event: e,
      target: i
    });
  }
}
class w7 extends P {
  constructor(e, t, i, n, s, o) {
    super(), this._context = e, this._viewController = t, this._viewHelper = i, this._mouseTargetFactory = n, this._createMouseTarget = s, this._getMouseColumn = o, this._mouseMoveMonitor = this._register(new q9(this._viewHelper.viewDomNode)), this._topBottomDragScrolling = this._register(new S7(this._context, this._viewHelper, this._mouseTargetFactory, (a, l, d) => this._dispatchMouse(a, l, d))), this._mouseState = new E0(), this._currentSelection = new ge(1, 1, 1, 1), this._isActive = !1, this._lastMouseEvent = null;
  }
  dispose() {
    super.dispose();
  }
  isActive() {
    return this._isActive;
  }
  _onMouseDownThenMove(e) {
    this._lastMouseEvent = e, this._mouseState.setModifiers(e);
    const t = this._findMousePosition(e, !1);
    t && (this._mouseState.isDragAndDrop ? this._viewController.emitMouseDrag({
      event: e,
      target: t
    }) : t.type === 13 && (t.outsidePosition === "above" || t.outsidePosition === "below") ? this._topBottomDragScrolling.start(t, e) : (this._topBottomDragScrolling.stop(), this._dispatchMouse(
      t,
      !0,
      1
      /* NavigationCommandRevealType.Minimal */
    )));
  }
  start(e, t, i) {
    this._lastMouseEvent = t, this._mouseState.setStartedOnLineNumbers(
      e === 3
      /* MouseTargetType.GUTTER_LINE_NUMBERS */
    ), this._mouseState.setStartButtons(t), this._mouseState.setModifiers(t);
    const n = this._findMousePosition(t, !0);
    if (!n || !n.position)
      return;
    this._mouseState.trySetCount(t.detail, n.position), t.detail = this._mouseState.count;
    const s = this._context.configuration.options;
    if (!s.get(
      91
      /* EditorOption.readOnly */
    ) && s.get(
      35
      /* EditorOption.dragAndDrop */
    ) && !s.get(
      22
      /* EditorOption.columnSelection */
    ) && !this._mouseState.altKey && t.detail < 2 && !this._isActive && !this._currentSelection.isEmpty() && n.type === 6 && n.position && this._currentSelection.containsPosition(n.position)) {
      this._mouseState.isDragAndDrop = !0, this._isActive = !0, this._mouseMoveMonitor.startMonitoring(this._viewHelper.viewLinesDomNode, i, t.buttons, (o) => this._onMouseDownThenMove(o), (o) => {
        const a = this._findMousePosition(this._lastMouseEvent, !1);
        $d(o) ? this._viewController.emitMouseDropCanceled() : this._viewController.emitMouseDrop({
          event: this._lastMouseEvent,
          target: a ? this._createMouseTarget(this._lastMouseEvent, !0) : null
          // Ignoring because position is unknown, e.g., Content View Zone
        }), this._stop();
      });
      return;
    }
    this._mouseState.isDragAndDrop = !1, this._dispatchMouse(
      n,
      t.shiftKey,
      1
      /* NavigationCommandRevealType.Minimal */
    ), this._isActive || (this._isActive = !0, this._mouseMoveMonitor.startMonitoring(this._viewHelper.viewLinesDomNode, i, t.buttons, (o) => this._onMouseDownThenMove(o), () => this._stop()));
  }
  _stop() {
    this._isActive = !1, this._topBottomDragScrolling.stop();
  }
  onHeightChanged() {
    this._mouseMoveMonitor.stopMonitoring();
  }
  onPointerUp() {
    this._mouseMoveMonitor.stopMonitoring();
  }
  onCursorStateChanged(e) {
    this._currentSelection = e.selections[0];
  }
  _getPositionOutsideEditor(e) {
    const t = e.editorPos, i = this._context.viewModel, n = this._context.viewLayout, s = this._getMouseColumn(e);
    if (e.posy < t.y) {
      const a = t.y - e.posy, l = Math.max(n.getCurrentScrollTop() - a, 0), d = qf.getZoneAtCoord(this._context, l);
      if (d) {
        const h = this._helpPositionJumpOverViewZone(d);
        if (h)
          return zn.createOutsideEditor(s, h, "above", a);
      }
      const c = n.getLineNumberAtVerticalOffset(l);
      return zn.createOutsideEditor(s, new A(c, 1), "above", a);
    }
    if (e.posy > t.y + t.height) {
      const a = e.posy - t.y - t.height, l = n.getCurrentScrollTop() + e.relativePos.y, d = qf.getZoneAtCoord(this._context, l);
      if (d) {
        const h = this._helpPositionJumpOverViewZone(d);
        if (h)
          return zn.createOutsideEditor(s, h, "below", a);
      }
      const c = n.getLineNumberAtVerticalOffset(l);
      return zn.createOutsideEditor(s, new A(c, i.getLineMaxColumn(c)), "below", a);
    }
    const o = n.getLineNumberAtVerticalOffset(n.getCurrentScrollTop() + e.relativePos.y);
    if (e.posx < t.x) {
      const a = t.x - e.posx;
      return zn.createOutsideEditor(s, new A(o, 1), "left", a);
    }
    if (e.posx > t.x + t.width) {
      const a = e.posx - t.x - t.width;
      return zn.createOutsideEditor(s, new A(o, i.getLineMaxColumn(o)), "right", a);
    }
    return null;
  }
  _findMousePosition(e, t) {
    const i = this._getPositionOutsideEditor(e);
    if (i)
      return i;
    const n = this._createMouseTarget(e, t);
    if (!n.position)
      return null;
    if (n.type === 8 || n.type === 5) {
      const o = this._helpPositionJumpOverViewZone(n.detail);
      if (o)
        return zn.createViewZone(n.type, n.element, n.mouseColumn, o, n.detail);
    }
    return n;
  }
  _helpPositionJumpOverViewZone(e) {
    const t = new A(this._currentSelection.selectionStartLineNumber, this._currentSelection.selectionStartColumn), i = e.positionBefore, n = e.positionAfter;
    return i && n ? i.isBefore(t) ? i : n : null;
  }
  _dispatchMouse(e, t, i) {
    e.position && this._viewController.dispatchMouse({
      position: e.position,
      mouseColumn: e.mouseColumn,
      startedOnLineNumbers: this._mouseState.startedOnLineNumbers,
      revealType: i,
      inSelectionMode: t,
      mouseDownCount: this._mouseState.count,
      altKey: this._mouseState.altKey,
      ctrlKey: this._mouseState.ctrlKey,
      metaKey: this._mouseState.metaKey,
      shiftKey: this._mouseState.shiftKey,
      leftButton: this._mouseState.leftButton,
      middleButton: this._mouseState.middleButton,
      onInjectedText: e.type === 6 && e.detail.injectedText !== null
    });
  }
}
class S7 extends P {
  constructor(e, t, i, n) {
    super(), this._context = e, this._viewHelper = t, this._mouseTargetFactory = i, this._dispatchMouse = n, this._operation = null;
  }
  dispose() {
    super.dispose(), this.stop();
  }
  start(e, t) {
    this._operation ? this._operation.setPosition(e, t) : this._operation = new y7(this._context, this._viewHelper, this._mouseTargetFactory, this._dispatchMouse, e, t);
  }
  stop() {
    this._operation && (this._operation.dispose(), this._operation = null);
  }
}
class y7 extends P {
  constructor(e, t, i, n, s, o) {
    super(), this._context = e, this._viewHelper = t, this._mouseTargetFactory = i, this._dispatchMouse = n, this._position = s, this._mouseEvent = o, this._lastTime = Date.now(), this._animationFrameDisposable = Us(we(o.browserEvent), () => this._execute());
  }
  dispose() {
    this._animationFrameDisposable.dispose(), super.dispose();
  }
  setPosition(e, t) {
    this._position = e, this._mouseEvent = t;
  }
  /**
   * update internal state and return elapsed ms since last time
   */
  _tick() {
    const e = Date.now(), t = e - this._lastTime;
    return this._lastTime = e, t;
  }
  /**
   * get the number of lines per second to auto-scroll
   */
  _getScrollSpeed() {
    const e = this._context.configuration.options.get(
      67
      /* EditorOption.lineHeight */
    ), t = this._context.configuration.options.get(
      145
      /* EditorOption.layoutInfo */
    ).height / e, i = this._position.outsideDistance / e;
    return i <= 1.5 ? Math.max(30, t * (1 + i)) : i <= 3 ? Math.max(60, t * (2 + i)) : Math.max(200, t * (7 + i));
  }
  _execute() {
    const e = this._context.configuration.options.get(
      67
      /* EditorOption.lineHeight */
    ), t = this._getScrollSpeed(), i = this._tick(), n = t * (i / 1e3) * e, s = this._position.outsidePosition === "above" ? -n : n;
    this._context.viewModel.viewLayout.deltaScrollNow(0, s), this._viewHelper.renderNow();
    const o = this._context.viewLayout.getLinesViewportData(), a = this._position.outsidePosition === "above" ? o.startLineNumber : o.endLineNumber;
    let l;
    {
      const d = y1(this._viewHelper.viewDomNode), c = this._context.configuration.options.get(
        145
        /* EditorOption.layoutInfo */
      ).horizontalScrollbarHeight, h = new k0(this._mouseEvent.pos.x, d.y + d.height - c - 0.1), u = L1(this._viewHelper.viewDomNode, d, h);
      l = this._mouseTargetFactory.createMouseTarget(this._viewHelper.getLastRenderData(), d, h, u, null);
    }
    (!l.position || l.position.lineNumber !== a) && (this._position.outsidePosition === "above" ? l = zn.createOutsideEditor(this._position.mouseColumn, new A(a, 1), "above", this._position.outsideDistance) : l = zn.createOutsideEditor(this._position.mouseColumn, new A(a, this._context.viewModel.getLineMaxColumn(a)), "below", this._position.outsideDistance)), this._dispatchMouse(
      l,
      !0,
      2
      /* NavigationCommandRevealType.None */
    ), this._animationFrameDisposable = Us(we(l.element), () => this._execute());
  }
}
class E0 {
  get altKey() {
    return this._altKey;
  }
  get ctrlKey() {
    return this._ctrlKey;
  }
  get metaKey() {
    return this._metaKey;
  }
  get shiftKey() {
    return this._shiftKey;
  }
  get leftButton() {
    return this._leftButton;
  }
  get middleButton() {
    return this._middleButton;
  }
  get startedOnLineNumbers() {
    return this._startedOnLineNumbers;
  }
  constructor() {
    this._altKey = !1, this._ctrlKey = !1, this._metaKey = !1, this._shiftKey = !1, this._leftButton = !1, this._middleButton = !1, this._startedOnLineNumbers = !1, this._lastMouseDownPosition = null, this._lastMouseDownPositionEqualCount = 0, this._lastMouseDownCount = 0, this._lastSetMouseDownCountTime = 0, this.isDragAndDrop = !1;
  }
  get count() {
    return this._lastMouseDownCount;
  }
  setModifiers(e) {
    this._altKey = e.altKey, this._ctrlKey = e.ctrlKey, this._metaKey = e.metaKey, this._shiftKey = e.shiftKey;
  }
  setStartButtons(e) {
    this._leftButton = e.leftButton, this._middleButton = e.middleButton;
  }
  setStartedOnLineNumbers(e) {
    this._startedOnLineNumbers = e;
  }
  trySetCount(e, t) {
    const i = (/* @__PURE__ */ new Date()).getTime();
    i - this._lastSetMouseDownCountTime > E0.CLEAR_MOUSE_DOWN_COUNT_TIME && (e = 1), this._lastSetMouseDownCountTime = i, e > this._lastMouseDownCount + 1 && (e = this._lastMouseDownCount + 1), this._lastMouseDownPosition && this._lastMouseDownPosition.equals(t) ? this._lastMouseDownPositionEqualCount++ : this._lastMouseDownPositionEqualCount = 1, this._lastMouseDownPosition = t, this._lastMouseDownCount = Math.min(e, this._lastMouseDownPositionEqualCount);
  }
}
E0.CLEAR_MOUSE_DOWN_COUNT_TIME = 400;
class tt {
  get event() {
    return this.emitter.event;
  }
  constructor(e, t, i) {
    const n = (s) => this.emitter.fire(s);
    this.emitter = new R({
      onWillAddFirstListener: () => e.addEventListener(t, n, i),
      onDidRemoveLastListener: () => e.removeEventListener(t, n, i)
    });
  }
  dispose() {
    this.emitter.dispose();
  }
}
class hn {
  constructor(e, t, i, n, s) {
    this.value = e, this.selectionStart = t, this.selectionEnd = i, this.selection = n, this.newlineCountBeforeSelection = s;
  }
  toString() {
    return `[ <${this.value}>, selectionStart: ${this.selectionStart}, selectionEnd: ${this.selectionEnd}]`;
  }
  static readFromTextArea(e, t) {
    const i = e.getValue(), n = e.getSelectionStart(), s = e.getSelectionEnd();
    let o;
    if (t) {
      const a = i.substring(0, n), l = t.value.substring(0, t.selectionStart);
      a === l && (o = t.newlineCountBeforeSelection);
    }
    return new hn(i, n, s, null, o);
  }
  collapseSelection() {
    return this.selectionStart === this.value.length ? this : new hn(this.value, this.value.length, this.value.length, null, void 0);
  }
  writeToTextArea(e, t, i) {
    t.setValue(e, this.value), i && t.setSelectionRange(e, this.selectionStart, this.selectionEnd);
  }
  deduceEditorPosition(e) {
    var t, i, n, s, o, a, l, d;
    if (e <= this.selectionStart) {
      const u = this.value.substring(e, this.selectionStart);
      return this._finishDeduceEditorPosition((i = (t = this.selection) === null || t === void 0 ? void 0 : t.getStartPosition()) !== null && i !== void 0 ? i : null, u, -1);
    }
    if (e >= this.selectionEnd) {
      const u = this.value.substring(this.selectionEnd, e);
      return this._finishDeduceEditorPosition((s = (n = this.selection) === null || n === void 0 ? void 0 : n.getEndPosition()) !== null && s !== void 0 ? s : null, u, 1);
    }
    const c = this.value.substring(this.selectionStart, e);
    if (c.indexOf("") === -1)
      return this._finishDeduceEditorPosition((a = (o = this.selection) === null || o === void 0 ? void 0 : o.getStartPosition()) !== null && a !== void 0 ? a : null, c, 1);
    const h = this.value.substring(e, this.selectionEnd);
    return this._finishDeduceEditorPosition((d = (l = this.selection) === null || l === void 0 ? void 0 : l.getEndPosition()) !== null && d !== void 0 ? d : null, h, -1);
  }
  _finishDeduceEditorPosition(e, t, i) {
    let n = 0, s = -1;
    for (; (s = t.indexOf(`
`, s + 1)) !== -1; )
      n++;
    return [e, i * t.length, n];
  }
  static deduceInput(e, t, i) {
    if (!e)
      return {
        text: "",
        replacePrevCharCnt: 0,
        replaceNextCharCnt: 0,
        positionDelta: 0
      };
    const n = Math.min(xc(e.value, t.value), e.selectionStart, t.selectionStart), s = Math.min(rS(e.value, t.value), e.value.length - e.selectionEnd, t.value.length - t.selectionEnd);
    e.value.substring(n, e.value.length - s);
    const o = t.value.substring(n, t.value.length - s), a = e.selectionStart - n, l = e.selectionEnd - n, d = t.selectionStart - n, c = t.selectionEnd - n;
    if (d === c) {
      const u = e.selectionStart - n;
      return {
        text: o,
        replacePrevCharCnt: u,
        replaceNextCharCnt: 0,
        positionDelta: 0
      };
    }
    const h = l - a;
    return {
      text: o,
      replacePrevCharCnt: h,
      replaceNextCharCnt: 0,
      positionDelta: 0
    };
  }
  static deduceAndroidCompositionInput(e, t) {
    if (!e)
      return {
        text: "",
        replacePrevCharCnt: 0,
        replaceNextCharCnt: 0,
        positionDelta: 0
      };
    if (e.value === t.value)
      return {
        text: "",
        replacePrevCharCnt: 0,
        replaceNextCharCnt: 0,
        positionDelta: t.selectionEnd - e.selectionEnd
      };
    const i = Math.min(xc(e.value, t.value), e.selectionEnd), n = Math.min(rS(e.value, t.value), e.value.length - e.selectionEnd), s = e.value.substring(i, e.value.length - n), o = t.value.substring(i, t.value.length - n);
    e.selectionStart - i;
    const a = e.selectionEnd - i;
    t.selectionStart - i;
    const l = t.selectionEnd - i;
    return {
      text: o,
      replacePrevCharCnt: a,
      replaceNextCharCnt: s.length - a,
      positionDelta: l - o.length
    };
  }
}
hn.EMPTY = new hn("", 0, 0, null, void 0);
class Yg {
  static _getPageOfLine(e, t) {
    return Math.floor((e - 1) / t);
  }
  static _getRangeForPage(e, t) {
    const i = e * t, n = i + 1, s = i + t;
    return new L(n, 1, s + 1, 1);
  }
  static fromEditorSelection(e, t, i, n) {
    const o = Yg._getPageOfLine(t.startLineNumber, i), a = Yg._getRangeForPage(o, i), l = Yg._getPageOfLine(t.endLineNumber, i), d = Yg._getRangeForPage(l, i);
    let c = a.intersectRanges(new L(1, 1, t.startLineNumber, t.startColumn));
    if (n && e.getValueLengthInRange(
      c,
      1
      /* EndOfLinePreference.LF */
    ) > 500) {
      const v = e.modifyPosition(c.getEndPosition(), -500);
      c = L.fromPositions(v, c.getEndPosition());
    }
    const h = e.getValueInRange(
      c,
      1
      /* EndOfLinePreference.LF */
    ), u = e.getLineCount(), g = e.getLineMaxColumn(u);
    let f = d.intersectRanges(new L(t.endLineNumber, t.endColumn, u, g));
    if (n && e.getValueLengthInRange(
      f,
      1
      /* EndOfLinePreference.LF */
    ) > 500) {
      const v = e.modifyPosition(f.getStartPosition(), 500);
      f = L.fromPositions(f.getStartPosition(), v);
    }
    const m = e.getValueInRange(
      f,
      1
      /* EndOfLinePreference.LF */
    );
    let _;
    if (o === l || o + 1 === l)
      _ = e.getValueInRange(
        t,
        1
        /* EndOfLinePreference.LF */
      );
    else {
      const v = a.intersectRanges(t), b = d.intersectRanges(t);
      _ = e.getValueInRange(
        v,
        1
        /* EndOfLinePreference.LF */
      ) + "" + e.getValueInRange(
        b,
        1
        /* EndOfLinePreference.LF */
      );
    }
    return n && _.length > 2 * 500 && (_ = _.substring(0, 500) + "" + _.substring(_.length - 500, _.length)), new hn(h + _ + m, h.length, h.length + _.length, t, c.endLineNumber - c.startLineNumber);
  }
}
var L7 = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, vP = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, yS;
(function(r) {
  r.Tap = "-monaco-textarea-synthetic-tap";
})(yS || (yS = {}));
const Gx = {
  forceCopyWithSyntaxHighlighting: !1
};
class q_ {
  constructor() {
    this._lastState = null;
  }
  set(e, t) {
    this._lastState = { lastCopiedValue: e, data: t };
  }
  get(e) {
    return this._lastState && this._lastState.lastCopiedValue === e ? this._lastState.data : (this._lastState = null, null);
  }
}
q_.INSTANCE = new q_();
class D7 {
  constructor() {
    this._lastTypeTextLength = 0;
  }
  handleCompositionUpdate(e) {
    e = e || "";
    const t = {
      text: e,
      replacePrevCharCnt: this._lastTypeTextLength,
      replaceNextCharCnt: 0,
      positionDelta: 0
    };
    return this._lastTypeTextLength = e.length, t;
  }
}
let Zx = class extends P {
  get textAreaState() {
    return this._textAreaState;
  }
  constructor(e, t, i, n, s, o) {
    super(), this._host = e, this._textArea = t, this._OS = i, this._browser = n, this._accessibilityService = s, this._logService = o, this._onFocus = this._register(new R()), this.onFocus = this._onFocus.event, this._onBlur = this._register(new R()), this.onBlur = this._onBlur.event, this._onKeyDown = this._register(new R()), this.onKeyDown = this._onKeyDown.event, this._onKeyUp = this._register(new R()), this.onKeyUp = this._onKeyUp.event, this._onCut = this._register(new R()), this.onCut = this._onCut.event, this._onPaste = this._register(new R()), this.onPaste = this._onPaste.event, this._onType = this._register(new R()), this.onType = this._onType.event, this._onCompositionStart = this._register(new R()), this.onCompositionStart = this._onCompositionStart.event, this._onCompositionUpdate = this._register(new R()), this.onCompositionUpdate = this._onCompositionUpdate.event, this._onCompositionEnd = this._register(new R()), this.onCompositionEnd = this._onCompositionEnd.event, this._onSelectionChangeRequest = this._register(new R()), this.onSelectionChangeRequest = this._onSelectionChangeRequest.event, this._asyncFocusGainWriteScreenReaderContent = this._register(new Yi()), this._asyncTriggerCut = this._register(new xt(() => this._onCut.fire(), 0)), this._textAreaState = hn.EMPTY, this._selectionChangeListener = null, this._accessibilityService.isScreenReaderOptimized() && this.writeNativeTextAreaContent("ctor"), this._register(ne.runAndSubscribe(this._accessibilityService.onDidChangeScreenReaderOptimized, () => {
      this._accessibilityService.isScreenReaderOptimized() && !this._asyncFocusGainWriteScreenReaderContent.value ? this._asyncFocusGainWriteScreenReaderContent.value = this._register(new xt(() => this.writeNativeTextAreaContent("asyncFocusGain"), 0)) : this._asyncFocusGainWriteScreenReaderContent.clear();
    })), this._hasFocus = !1, this._currentComposition = null;
    let a = null;
    this._register(this._textArea.onKeyDown((l) => {
      const d = new Mt(l);
      (d.keyCode === 114 || this._currentComposition && d.keyCode === 1) && d.stopPropagation(), d.equals(
        9
        /* KeyCode.Escape */
      ) && d.preventDefault(), a = d, this._onKeyDown.fire(d);
    })), this._register(this._textArea.onKeyUp((l) => {
      const d = new Mt(l);
      this._onKeyUp.fire(d);
    })), this._register(this._textArea.onCompositionStart((l) => {
      const d = new D7();
      if (this._currentComposition) {
        this._currentComposition = d;
        return;
      }
      if (this._currentComposition = d, this._OS === 2 && a && a.equals(
        114
        /* KeyCode.KEY_IN_COMPOSITION */
      ) && this._textAreaState.selectionStart === this._textAreaState.selectionEnd && this._textAreaState.selectionStart > 0 && this._textAreaState.value.substr(this._textAreaState.selectionStart - 1, 1) === l.data && (a.code === "ArrowRight" || a.code === "ArrowLeft")) {
        d.handleCompositionUpdate("x"), this._onCompositionStart.fire({ data: l.data });
        return;
      }
      if (this._browser.isAndroid) {
        this._onCompositionStart.fire({ data: l.data });
        return;
      }
      this._onCompositionStart.fire({ data: l.data });
    })), this._register(this._textArea.onCompositionUpdate((l) => {
      const d = this._currentComposition;
      if (!d)
        return;
      if (this._browser.isAndroid) {
        const h = hn.readFromTextArea(this._textArea, this._textAreaState), u = hn.deduceAndroidCompositionInput(this._textAreaState, h);
        this._textAreaState = h, this._onType.fire(u), this._onCompositionUpdate.fire(l);
        return;
      }
      const c = d.handleCompositionUpdate(l.data);
      this._textAreaState = hn.readFromTextArea(this._textArea, this._textAreaState), this._onType.fire(c), this._onCompositionUpdate.fire(l);
    })), this._register(this._textArea.onCompositionEnd((l) => {
      const d = this._currentComposition;
      if (!d)
        return;
      if (this._currentComposition = null, this._browser.isAndroid) {
        const h = hn.readFromTextArea(this._textArea, this._textAreaState), u = hn.deduceAndroidCompositionInput(this._textAreaState, h);
        this._textAreaState = h, this._onType.fire(u), this._onCompositionEnd.fire();
        return;
      }
      const c = d.handleCompositionUpdate(l.data);
      this._textAreaState = hn.readFromTextArea(this._textArea, this._textAreaState), this._onType.fire(c), this._onCompositionEnd.fire();
    })), this._register(this._textArea.onInput((l) => {
      if (this._textArea.setIgnoreSelectionChangeTime("received input event"), this._currentComposition)
        return;
      const d = hn.readFromTextArea(this._textArea, this._textAreaState), c = hn.deduceInput(
        this._textAreaState,
        d,
        /*couldBeEmojiInput*/
        this._OS === 2
        /* OperatingSystem.Macintosh */
      );
      c.replacePrevCharCnt === 0 && c.text.length === 1 && ($n(c.text.charCodeAt(0)) || c.text.charCodeAt(0) === 127) || (this._textAreaState = d, (c.text !== "" || c.replacePrevCharCnt !== 0 || c.replaceNextCharCnt !== 0 || c.positionDelta !== 0) && this._onType.fire(c));
    })), this._register(this._textArea.onCut((l) => {
      this._textArea.setIgnoreSelectionChangeTime("received cut event"), this._ensureClipboardGetsEditorSelection(l), this._asyncTriggerCut.schedule();
    })), this._register(this._textArea.onCopy((l) => {
      this._ensureClipboardGetsEditorSelection(l);
    })), this._register(this._textArea.onPaste((l) => {
      if (this._textArea.setIgnoreSelectionChangeTime("received paste event"), l.preventDefault(), !l.clipboardData)
        return;
      let [d, c] = Yx.getTextData(l.clipboardData);
      d && (c = c || q_.INSTANCE.get(d), this._onPaste.fire({
        text: d,
        metadata: c
      }));
    })), this._register(this._textArea.onFocus(() => {
      const l = this._hasFocus;
      this._setHasFocus(!0), this._accessibilityService.isScreenReaderOptimized() && this._browser.isSafari && !l && this._hasFocus && (this._asyncFocusGainWriteScreenReaderContent.value || (this._asyncFocusGainWriteScreenReaderContent.value = new xt(() => this.writeNativeTextAreaContent("asyncFocusGain"), 0)), this._asyncFocusGainWriteScreenReaderContent.value.schedule());
    })), this._register(this._textArea.onBlur(() => {
      this._currentComposition && (this._currentComposition = null, this.writeNativeTextAreaContent("blurWithoutCompositionEnd"), this._onCompositionEnd.fire()), this._setHasFocus(!1);
    })), this._register(this._textArea.onSyntheticTap(() => {
      this._browser.isAndroid && this._currentComposition && (this._currentComposition = null, this.writeNativeTextAreaContent("tapWithoutCompositionEnd"), this._onCompositionEnd.fire());
    }));
  }
  _installSelectionChangeListener() {
    let e = 0;
    return W(this._textArea.ownerDocument, "selectionchange", (t) => {
      if (Jd.onSelectionChange(), !this._hasFocus || this._currentComposition || !this._browser.isChrome)
        return;
      const i = Date.now(), n = i - e;
      if (e = i, n < 5)
        return;
      const s = i - this._textArea.getIgnoreSelectionChangeTime();
      if (this._textArea.resetSelectionChangeTime(), s < 100 || !this._textAreaState.selection)
        return;
      const o = this._textArea.getValue();
      if (this._textAreaState.value !== o)
        return;
      const a = this._textArea.getSelectionStart(), l = this._textArea.getSelectionEnd();
      if (this._textAreaState.selectionStart === a && this._textAreaState.selectionEnd === l)
        return;
      const d = this._textAreaState.deduceEditorPosition(a), c = this._host.deduceModelPosition(d[0], d[1], d[2]), h = this._textAreaState.deduceEditorPosition(l), u = this._host.deduceModelPosition(h[0], h[1], h[2]), g = new ge(c.lineNumber, c.column, u.lineNumber, u.column);
      this._onSelectionChangeRequest.fire(g);
    });
  }
  dispose() {
    super.dispose(), this._selectionChangeListener && (this._selectionChangeListener.dispose(), this._selectionChangeListener = null);
  }
  focusTextArea() {
    this._setHasFocus(!0), this.refreshFocusState();
  }
  isFocused() {
    return this._hasFocus;
  }
  refreshFocusState() {
    this._setHasFocus(this._textArea.hasFocus());
  }
  _setHasFocus(e) {
    this._hasFocus !== e && (this._hasFocus = e, this._selectionChangeListener && (this._selectionChangeListener.dispose(), this._selectionChangeListener = null), this._hasFocus && (this._selectionChangeListener = this._installSelectionChangeListener()), this._hasFocus && this.writeNativeTextAreaContent("focusgain"), this._hasFocus ? this._onFocus.fire() : this._onBlur.fire());
  }
  _setAndWriteTextAreaState(e, t) {
    this._hasFocus || (t = t.collapseSelection()), t.writeToTextArea(e, this._textArea, this._hasFocus), this._textAreaState = t;
  }
  writeNativeTextAreaContent(e) {
    !this._accessibilityService.isScreenReaderOptimized() && e === "render" || this._currentComposition || (this._logService.trace(`writeTextAreaState(reason: ${e})`), this._setAndWriteTextAreaState(e, this._host.getScreenReaderContent()));
  }
  _ensureClipboardGetsEditorSelection(e) {
    const t = this._host.getDataToCopy(), i = {
      version: 1,
      isFromEmptySelection: t.isFromEmptySelection,
      multicursorText: t.multicursorText,
      mode: t.mode
    };
    q_.INSTANCE.set(
      // When writing "LINE\r\n" to the clipboard and then pasting,
      // Firefox pastes "LINE\n", so let's work around this quirk
      this._browser.isFirefox ? t.text.replace(/\r\n/g, `
`) : t.text,
      i
    ), e.preventDefault(), e.clipboardData && Yx.setTextData(e.clipboardData, t.text, t.html, i);
  }
};
Zx = L7([
  vP(4, qs),
  vP(5, Pn)
], Zx);
const Yx = {
  getTextData(r) {
    const e = r.getData(fi.text);
    let t = null;
    const i = r.getData("vscode-editor-data");
    if (typeof i == "string")
      try {
        t = JSON.parse(i), t.version !== 1 && (t = null);
      } catch {
      }
    return e.length === 0 && t === null && r.files.length > 0 ? [Array.prototype.slice.call(r.files, 0).map((s) => s.name).join(`
`), null] : [e, t];
  },
  setTextData(r, e, t, i) {
    r.setData(fi.text, e), typeof t == "string" && r.setData("text/html", t), r.setData("vscode-editor-data", JSON.stringify(i));
  }
};
class k7 extends P {
  get ownerDocument() {
    return this._actual.ownerDocument;
  }
  constructor(e) {
    super(), this._actual = e, this.onKeyDown = this._register(new tt(this._actual, "keydown")).event, this.onKeyUp = this._register(new tt(this._actual, "keyup")).event, this.onCompositionStart = this._register(new tt(this._actual, "compositionstart")).event, this.onCompositionUpdate = this._register(new tt(this._actual, "compositionupdate")).event, this.onCompositionEnd = this._register(new tt(this._actual, "compositionend")).event, this.onBeforeInput = this._register(new tt(this._actual, "beforeinput")).event, this.onInput = this._register(new tt(this._actual, "input")).event, this.onCut = this._register(new tt(this._actual, "cut")).event, this.onCopy = this._register(new tt(this._actual, "copy")).event, this.onPaste = this._register(new tt(this._actual, "paste")).event, this.onFocus = this._register(new tt(this._actual, "focus")).event, this.onBlur = this._register(new tt(this._actual, "blur")).event, this._onSyntheticTap = this._register(new R()), this.onSyntheticTap = this._onSyntheticTap.event, this._ignoreSelectionChangeTime = 0, this._register(this.onKeyDown(() => Jd.onKeyDown())), this._register(this.onBeforeInput(() => Jd.onBeforeInput())), this._register(this.onInput(() => Jd.onInput())), this._register(this.onKeyUp(() => Jd.onKeyUp())), this._register(W(this._actual, yS.Tap, () => this._onSyntheticTap.fire()));
  }
  hasFocus() {
    const e = Cu(this._actual);
    return e ? e.activeElement === this._actual : this._actual.isConnected ? Ln() === this._actual : !1;
  }
  setIgnoreSelectionChangeTime(e) {
    this._ignoreSelectionChangeTime = Date.now();
  }
  getIgnoreSelectionChangeTime() {
    return this._ignoreSelectionChangeTime;
  }
  resetSelectionChangeTime() {
    this._ignoreSelectionChangeTime = 0;
  }
  getValue() {
    return this._actual.value;
  }
  setValue(e, t) {
    const i = this._actual;
    i.value !== t && (this.setIgnoreSelectionChangeTime("setValue"), i.value = t);
  }
  getSelectionStart() {
    return this._actual.selectionDirection === "backward" ? this._actual.selectionEnd : this._actual.selectionStart;
  }
  getSelectionEnd() {
    return this._actual.selectionDirection === "backward" ? this._actual.selectionStart : this._actual.selectionEnd;
  }
  setSelectionRange(e, t, i) {
    const n = this._actual;
    let s = null;
    const o = Cu(n);
    o ? s = o.activeElement : s = Ln();
    const a = we(s), l = s === n, d = n.selectionStart, c = n.selectionEnd;
    if (l && d === t && c === i) {
      Oo && a.parent !== a && n.focus();
      return;
    }
    if (l) {
      this.setIgnoreSelectionChangeTime("setSelectionRange"), n.setSelectionRange(t, i), Oo && a.parent !== a && n.focus();
      return;
    }
    try {
      const h = Y8(n);
      this.setIgnoreSelectionChangeTime("setSelectionRange"), n.focus(), n.setSelectionRange(t, i), Q8(n, h);
    } catch {
    }
  }
}
class x7 extends x1 {
  constructor(e, t, i) {
    super(e, t, i), this._register(At.addTarget(this.viewHelper.linesContentDomNode)), this._register(W(this.viewHelper.linesContentDomNode, Pt.Tap, (s) => this.onTap(s))), this._register(W(this.viewHelper.linesContentDomNode, Pt.Change, (s) => this.onChange(s))), this._register(W(this.viewHelper.linesContentDomNode, Pt.Contextmenu, (s) => this._onContextMenu(new Pc(s, !1, this.viewHelper.viewDomNode), !1))), this._lastPointerType = "mouse", this._register(W(this.viewHelper.linesContentDomNode, "pointerdown", (s) => {
      const o = s.pointerType;
      if (o === "mouse") {
        this._lastPointerType = "mouse";
        return;
      } else o === "touch" ? this._lastPointerType = "touch" : this._lastPointerType = "pen";
    }));
    const n = new j9(this.viewHelper.viewDomNode);
    this._register(n.onPointerMove(this.viewHelper.viewDomNode, (s) => this._onMouseMove(s))), this._register(n.onPointerUp(this.viewHelper.viewDomNode, (s) => this._onMouseUp(s))), this._register(n.onPointerLeave(this.viewHelper.viewDomNode, (s) => this._onMouseLeave(s))), this._register(n.onPointerDown(this.viewHelper.viewDomNode, (s, o) => this._onMouseDown(s, o)));
  }
  onTap(e) {
    !e.initialTarget || !this.viewHelper.linesContentDomNode.contains(e.initialTarget) || (e.preventDefault(), this.viewHelper.focusTextArea(), this._dispatchGesture(
      e,
      /*inSelectionMode*/
      !1
    ));
  }
  onChange(e) {
    this._lastPointerType === "touch" && this._context.viewModel.viewLayout.deltaScrollNow(-e.translationX, -e.translationY), this._lastPointerType === "pen" && this._dispatchGesture(
      e,
      /*inSelectionMode*/
      !0
    );
  }
  _dispatchGesture(e, t) {
    const i = this._createMouseTarget(new Pc(e, !1, this.viewHelper.viewDomNode), !1);
    i.position && this.viewController.dispatchMouse({
      position: i.position,
      mouseColumn: i.position.column,
      startedOnLineNumbers: !1,
      revealType: 1,
      mouseDownCount: e.tapCount,
      inSelectionMode: t,
      altKey: !1,
      ctrlKey: !1,
      metaKey: !1,
      shiftKey: !1,
      leftButton: !1,
      middleButton: !1,
      onInjectedText: i.type === 6 && i.detail.injectedText !== null
    });
  }
  _onMouseDown(e, t) {
    e.browserEvent.pointerType !== "touch" && super._onMouseDown(e, t);
  }
}
class I7 extends x1 {
  constructor(e, t, i) {
    super(e, t, i), this._register(At.addTarget(this.viewHelper.linesContentDomNode)), this._register(W(this.viewHelper.linesContentDomNode, Pt.Tap, (n) => this.onTap(n))), this._register(W(this.viewHelper.linesContentDomNode, Pt.Change, (n) => this.onChange(n))), this._register(W(this.viewHelper.linesContentDomNode, Pt.Contextmenu, (n) => this._onContextMenu(new Pc(n, !1, this.viewHelper.viewDomNode), !1)));
  }
  onTap(e) {
    e.preventDefault(), this.viewHelper.focusTextArea();
    const t = this._createMouseTarget(new Pc(e, !1, this.viewHelper.viewDomNode), !1);
    if (t.position) {
      const i = document.createEvent("CustomEvent");
      i.initEvent(yS.Tap, !1, !0), this.viewHelper.dispatchTextAreaEvent(i), this.viewController.moveTo(
        t.position,
        1
        /* NavigationCommandRevealType.Minimal */
      );
    }
  }
  onChange(e) {
    this._context.viewModel.viewLayout.deltaScrollNow(-e.translationX, -e.translationY);
  }
}
class E7 extends P {
  constructor(e, t, i) {
    super(), (Zr || g5 && qB) && JN.pointerEvents ? this.handler = this._register(new x7(e, t, i)) : Dt.TouchEvent ? this.handler = this._register(new I7(e, t, i)) : this.handler = this._register(new x1(e, t, i));
  }
  getTargetAtClientPoint(e, t) {
    return this.handler.getTargetAtClientPoint(e, t);
  }
}
class eg extends fb {
}
const $i = et("themeService");
function ai(r) {
  return { id: r };
}
function Qx(r) {
  switch (r) {
    case Mo.DARK:
      return "vs-dark";
    case Mo.HIGH_CONTRAST_DARK:
      return "hc-black";
    case Mo.HIGH_CONTRAST_LIGHT:
      return "hc-light";
    default:
      return "vs";
  }
}
const UV = {
  ThemingContribution: "base.contributions.theming"
};
class T7 {
  constructor() {
    this.themingParticipants = [], this.themingParticipants = [], this.onThemingParticipantAddedEmitter = new R();
  }
  onColorThemeChange(e) {
    return this.themingParticipants.push(e), this.onThemingParticipantAddedEmitter.fire(e), Se(() => {
      const t = this.themingParticipants.indexOf(e);
      this.themingParticipants.splice(t, 1);
    });
  }
  getThemingParticipants() {
    return this.themingParticipants;
  }
}
const $V = new T7();
si.add(UV.ThemingContribution, $V);
function Ho(r) {
  return $V.onColorThemeChange(r);
}
class N7 extends P {
  constructor(e) {
    super(), this.themeService = e, this.theme = e.getColorTheme(), this._register(this.themeService.onDidColorThemeChange((t) => this.onThemeChange(t)));
  }
  onThemeChange(e) {
    this.theme = e, this.updateStyles();
  }
  updateStyles() {
  }
}
const KV = I("editor.lineHighlightBackground", { dark: null, light: null, hcDark: null, hcLight: null }, p("lineHighlight", "Background color for the highlight of line at the cursor position.")), bP = I("editor.lineHighlightBorder", { dark: "#282828", light: "#eeeeee", hcDark: "#f38518", hcLight: it }, p("lineHighlightBorderBox", "Background color for the border around the line at the cursor position."));
I("editor.rangeHighlightBackground", { dark: "#ffffff0b", light: "#fdff0033", hcDark: null, hcLight: null }, p("rangeHighlight", "Background color of highlighted ranges, like by quick open and find features. The color must not be opaque so as not to hide underlying decorations."), !0);
I("editor.rangeHighlightBorder", { dark: null, light: null, hcDark: Gt, hcLight: Gt }, p("rangeHighlightBorder", "Background color of the border around highlighted ranges."));
I("editor.symbolHighlightBackground", { dark: Ul, light: Ul, hcDark: null, hcLight: null }, p("symbolHighlight", "Background color of highlighted symbol, like for go to definition or go next/previous symbol. The color must not be opaque so as not to hide underlying decorations."), !0);
I("editor.symbolHighlightBorder", { dark: null, light: null, hcDark: Gt, hcLight: Gt }, p("symbolHighlightBorder", "Background color of the border around highlighted symbols."));
const $a = I("editorCursor.foreground", { dark: "#AEAFAD", light: z.black, hcDark: z.white, hcLight: "#0F4A85" }, p("caret", "Color of the editor cursor.")), Zl = I("editorCursor.background", null, p("editorCursorBackground", "The background color of the editor cursor. Allows customizing the color of a character overlapped by a block cursor.")), jV = I("editorMultiCursor.primary.foreground", { dark: $a, light: $a, hcDark: $a, hcLight: $a }, p("editorMultiCursorPrimaryForeground", "Color of the primary editor cursor when multiple cursors are present.")), M7 = I("editorMultiCursor.primary.background", { dark: Zl, light: Zl, hcDark: Zl, hcLight: Zl }, p("editorMultiCursorPrimaryBackground", "The background color of the primary editor cursor when multiple cursors are present. Allows customizing the color of a character overlapped by a block cursor.")), qV = I("editorMultiCursor.secondary.foreground", { dark: $a, light: $a, hcDark: $a, hcLight: $a }, p("editorMultiCursorSecondaryForeground", "Color of secondary editor cursors when multiple cursors are present.")), R7 = I("editorMultiCursor.secondary.background", { dark: Zl, light: Zl, hcDark: Zl, hcLight: Zl }, p("editorMultiCursorSecondaryBackground", "The background color of secondary editor cursors when multiple cursors are present. Allows customizing the color of a character overlapped by a block cursor.")), Yl = I("editorWhitespace.foreground", { dark: "#e3e4e229", light: "#33333333", hcDark: "#e3e4e229", hcLight: "#CCCCCC" }, p("editorWhitespaces", "Color of whitespace characters in the editor.")), A7 = I("editorLineNumber.foreground", { dark: "#858585", light: "#237893", hcDark: z.white, hcLight: "#292929" }, p("editorLineNumbers", "Color of editor line numbers.")), uC = I("editorIndentGuide.background", { dark: Yl, light: Yl, hcDark: Yl, hcLight: Yl }, p("editorIndentGuides", "Color of the editor indentation guides."), !1, p("deprecatedEditorIndentGuides", "'editorIndentGuide.background' is deprecated. Use 'editorIndentGuide.background1' instead.")), gC = I("editorIndentGuide.activeBackground", { dark: Yl, light: Yl, hcDark: Yl, hcLight: Yl }, p("editorActiveIndentGuide", "Color of the active editor indentation guides."), !1, p("deprecatedEditorActiveIndentGuide", "'editorIndentGuide.activeBackground' is deprecated. Use 'editorIndentGuide.activeBackground1' instead.")), mb = I("editorIndentGuide.background1", { dark: uC, light: uC, hcDark: uC, hcLight: uC }, p("editorIndentGuides1", "Color of the editor indentation guides (1).")), P7 = I("editorIndentGuide.background2", { dark: "#00000000", light: "#00000000", hcDark: "#00000000", hcLight: "#00000000" }, p("editorIndentGuides2", "Color of the editor indentation guides (2).")), O7 = I("editorIndentGuide.background3", { dark: "#00000000", light: "#00000000", hcDark: "#00000000", hcLight: "#00000000" }, p("editorIndentGuides3", "Color of the editor indentation guides (3).")), F7 = I("editorIndentGuide.background4", { dark: "#00000000", light: "#00000000", hcDark: "#00000000", hcLight: "#00000000" }, p("editorIndentGuides4", "Color of the editor indentation guides (4).")), W7 = I("editorIndentGuide.background5", { dark: "#00000000", light: "#00000000", hcDark: "#00000000", hcLight: "#00000000" }, p("editorIndentGuides5", "Color of the editor indentation guides (5).")), B7 = I("editorIndentGuide.background6", { dark: "#00000000", light: "#00000000", hcDark: "#00000000", hcLight: "#00000000" }, p("editorIndentGuides6", "Color of the editor indentation guides (6).")), _b = I("editorIndentGuide.activeBackground1", { dark: gC, light: gC, hcDark: gC, hcLight: gC }, p("editorActiveIndentGuide1", "Color of the active editor indentation guides (1).")), H7 = I("editorIndentGuide.activeBackground2", { dark: "#00000000", light: "#00000000", hcDark: "#00000000", hcLight: "#00000000" }, p("editorActiveIndentGuide2", "Color of the active editor indentation guides (2).")), V7 = I("editorIndentGuide.activeBackground3", { dark: "#00000000", light: "#00000000", hcDark: "#00000000", hcLight: "#00000000" }, p("editorActiveIndentGuide3", "Color of the active editor indentation guides (3).")), z7 = I("editorIndentGuide.activeBackground4", { dark: "#00000000", light: "#00000000", hcDark: "#00000000", hcLight: "#00000000" }, p("editorActiveIndentGuide4", "Color of the active editor indentation guides (4).")), U7 = I("editorIndentGuide.activeBackground5", { dark: "#00000000", light: "#00000000", hcDark: "#00000000", hcLight: "#00000000" }, p("editorActiveIndentGuide5", "Color of the active editor indentation guides (5).")), $7 = I("editorIndentGuide.activeBackground6", { dark: "#00000000", light: "#00000000", hcDark: "#00000000", hcLight: "#00000000" }, p("editorActiveIndentGuide6", "Color of the active editor indentation guides (6).")), fC = I("editorActiveLineNumber.foreground", { dark: "#c6c6c6", light: "#0B216F", hcDark: Gt, hcLight: Gt }, p("editorActiveLineNumber", "Color of editor active line number"), !1, p("deprecatedEditorActiveLineNumber", "Id is deprecated. Use 'editorLineNumber.activeForeground' instead."));
I("editorLineNumber.activeForeground", { dark: fC, light: fC, hcDark: fC, hcLight: fC }, p("editorActiveLineNumber", "Color of editor active line number"));
const K7 = I("editorLineNumber.dimmedForeground", { dark: null, light: null, hcDark: null, hcLight: null }, p("editorDimmedLineNumber", "Color of the final editor line when editor.renderFinalNewline is set to dimmed."));
I("editorRuler.foreground", { dark: "#5A5A5A", light: z.lightgrey, hcDark: z.white, hcLight: "#292929" }, p("editorRuler", "Color of the editor rulers."));
I("editorCodeLens.foreground", { dark: "#999999", light: "#919191", hcDark: "#999999", hcLight: "#292929" }, p("editorCodeLensForeground", "Foreground color of editor CodeLens"));
I("editorBracketMatch.background", { dark: "#0064001a", light: "#0064001a", hcDark: "#0064001a", hcLight: "#0000" }, p("editorBracketMatchBackground", "Background color behind matching brackets"));
I("editorBracketMatch.border", { dark: "#888", light: "#B9B9B9", hcDark: it, hcLight: it }, p("editorBracketMatchBorder", "Color for matching brackets boxes"));
const j7 = I("editorOverviewRuler.border", { dark: "#7f7f7f4d", light: "#7f7f7f4d", hcDark: "#7f7f7f4d", hcLight: "#666666" }, p("editorOverviewRulerBorder", "Color of the overview ruler border.")), q7 = I("editorOverviewRuler.background", null, p("editorOverviewRulerBackground", "Background color of the editor overview ruler."));
I("editorGutter.background", { dark: Gi, light: Gi, hcDark: Gi, hcLight: Gi }, p("editorGutter", "Background color of the editor gutter. The gutter contains the glyph margins and the line numbers."));
I("editorUnnecessaryCode.border", { dark: null, light: null, hcDark: z.fromHex("#fff").transparent(0.8), hcLight: it }, p("unnecessaryCodeBorder", "Border color of unnecessary (unused) source code in the editor."));
const G7 = I("editorUnnecessaryCode.opacity", { dark: z.fromHex("#000a"), light: z.fromHex("#0007"), hcDark: null, hcLight: null }, p("unnecessaryCodeOpacity", `Opacity of unnecessary (unused) source code in the editor. For example, "#000000c0" will render the code with 75% opacity. For high contrast themes, use the  'editorUnnecessaryCode.border' theme color to underline unnecessary code instead of fading it out.`));
I("editorGhostText.border", { dark: null, light: null, hcDark: z.fromHex("#fff").transparent(0.8), hcLight: z.fromHex("#292929").transparent(0.8) }, p("editorGhostTextBorder", "Border color of ghost text in the editor."));
I("editorGhostText.foreground", { dark: z.fromHex("#ffffff56"), light: z.fromHex("#0007"), hcDark: null, hcLight: null }, p("editorGhostTextForeground", "Foreground color of the ghost text in the editor."));
I("editorGhostText.background", { dark: null, light: null, hcDark: null, hcLight: null }, p("editorGhostTextBackground", "Background color of the ghost text in the editor."));
const pC = new z(new Qt(0, 122, 204, 0.6)), GV = I("editorOverviewRuler.rangeHighlightForeground", { dark: pC, light: pC, hcDark: pC, hcLight: pC }, p("overviewRulerRangeHighlight", "Overview ruler marker color for range highlights. The color must not be opaque so as not to hide underlying decorations."), !0), Z7 = I("editorOverviewRuler.errorForeground", { dark: new z(new Qt(255, 18, 18, 0.7)), light: new z(new Qt(255, 18, 18, 0.7)), hcDark: new z(new Qt(255, 50, 50, 1)), hcLight: "#B5200D" }, p("overviewRuleError", "Overview ruler marker color for errors.")), Y7 = I("editorOverviewRuler.warningForeground", { dark: Kn, light: Kn, hcDark: U_, hcLight: U_ }, p("overviewRuleWarning", "Overview ruler marker color for warnings.")), Q7 = I("editorOverviewRuler.infoForeground", { dark: ws, light: ws, hcDark: $_, hcLight: $_ }, p("overviewRuleInfo", "Overview ruler marker color for infos.")), ZV = I("editorBracketHighlight.foreground1", { dark: "#FFD700", light: "#0431FAFF", hcDark: "#FFD700", hcLight: "#0431FAFF" }, p("editorBracketHighlightForeground1", "Foreground color of brackets (1). Requires enabling bracket pair colorization.")), YV = I("editorBracketHighlight.foreground2", { dark: "#DA70D6", light: "#319331FF", hcDark: "#DA70D6", hcLight: "#319331FF" }, p("editorBracketHighlightForeground2", "Foreground color of brackets (2). Requires enabling bracket pair colorization.")), QV = I("editorBracketHighlight.foreground3", { dark: "#179FFF", light: "#7B3814FF", hcDark: "#87CEFA", hcLight: "#7B3814FF" }, p("editorBracketHighlightForeground3", "Foreground color of brackets (3). Requires enabling bracket pair colorization.")), XV = I("editorBracketHighlight.foreground4", { dark: "#00000000", light: "#00000000", hcDark: "#00000000", hcLight: "#00000000" }, p("editorBracketHighlightForeground4", "Foreground color of brackets (4). Requires enabling bracket pair colorization.")), JV = I("editorBracketHighlight.foreground5", { dark: "#00000000", light: "#00000000", hcDark: "#00000000", hcLight: "#00000000" }, p("editorBracketHighlightForeground5", "Foreground color of brackets (5). Requires enabling bracket pair colorization.")), e2 = I("editorBracketHighlight.foreground6", { dark: "#00000000", light: "#00000000", hcDark: "#00000000", hcLight: "#00000000" }, p("editorBracketHighlightForeground6", "Foreground color of brackets (6). Requires enabling bracket pair colorization.")), X7 = I("editorBracketHighlight.unexpectedBracket.foreground", { dark: new z(new Qt(255, 18, 18, 0.8)), light: new z(new Qt(255, 18, 18, 0.8)), hcDark: new z(new Qt(255, 50, 50, 1)), hcLight: "" }, p("editorBracketHighlightUnexpectedBracketForeground", "Foreground color of unexpected brackets.")), J7 = I("editorBracketPairGuide.background1", { dark: "#00000000", light: "#00000000", hcDark: "#00000000", hcLight: "#00000000" }, p("editorBracketPairGuide.background1", "Background color of inactive bracket pair guides (1). Requires enabling bracket pair guides.")), eZ = I("editorBracketPairGuide.background2", { dark: "#00000000", light: "#00000000", hcDark: "#00000000", hcLight: "#00000000" }, p("editorBracketPairGuide.background2", "Background color of inactive bracket pair guides (2). Requires enabling bracket pair guides.")), tZ = I("editorBracketPairGuide.background3", { dark: "#00000000", light: "#00000000", hcDark: "#00000000", hcLight: "#00000000" }, p("editorBracketPairGuide.background3", "Background color of inactive bracket pair guides (3). Requires enabling bracket pair guides.")), iZ = I("editorBracketPairGuide.background4", { dark: "#00000000", light: "#00000000", hcDark: "#00000000", hcLight: "#00000000" }, p("editorBracketPairGuide.background4", "Background color of inactive bracket pair guides (4). Requires enabling bracket pair guides.")), nZ = I("editorBracketPairGuide.background5", { dark: "#00000000", light: "#00000000", hcDark: "#00000000", hcLight: "#00000000" }, p("editorBracketPairGuide.background5", "Background color of inactive bracket pair guides (5). Requires enabling bracket pair guides.")), sZ = I("editorBracketPairGuide.background6", { dark: "#00000000", light: "#00000000", hcDark: "#00000000", hcLight: "#00000000" }, p("editorBracketPairGuide.background6", "Background color of inactive bracket pair guides (6). Requires enabling bracket pair guides.")), oZ = I("editorBracketPairGuide.activeBackground1", { dark: "#00000000", light: "#00000000", hcDark: "#00000000", hcLight: "#00000000" }, p("editorBracketPairGuide.activeBackground1", "Background color of active bracket pair guides (1). Requires enabling bracket pair guides.")), rZ = I("editorBracketPairGuide.activeBackground2", { dark: "#00000000", light: "#00000000", hcDark: "#00000000", hcLight: "#00000000" }, p("editorBracketPairGuide.activeBackground2", "Background color of active bracket pair guides (2). Requires enabling bracket pair guides.")), aZ = I("editorBracketPairGuide.activeBackground3", { dark: "#00000000", light: "#00000000", hcDark: "#00000000", hcLight: "#00000000" }, p("editorBracketPairGuide.activeBackground3", "Background color of active bracket pair guides (3). Requires enabling bracket pair guides.")), lZ = I("editorBracketPairGuide.activeBackground4", { dark: "#00000000", light: "#00000000", hcDark: "#00000000", hcLight: "#00000000" }, p("editorBracketPairGuide.activeBackground4", "Background color of active bracket pair guides (4). Requires enabling bracket pair guides.")), dZ = I("editorBracketPairGuide.activeBackground5", { dark: "#00000000", light: "#00000000", hcDark: "#00000000", hcLight: "#00000000" }, p("editorBracketPairGuide.activeBackground5", "Background color of active bracket pair guides (5). Requires enabling bracket pair guides.")), cZ = I("editorBracketPairGuide.activeBackground6", { dark: "#00000000", light: "#00000000", hcDark: "#00000000", hcLight: "#00000000" }, p("editorBracketPairGuide.activeBackground6", "Background color of active bracket pair guides (6). Requires enabling bracket pair guides."));
I("editorUnicodeHighlight.border", { dark: Kn, light: Kn, hcDark: Kn, hcLight: Kn }, p("editorUnicodeHighlight.border", "Border color used to highlight unicode characters."));
I("editorUnicodeHighlight.background", { dark: lC, light: lC, hcDark: lC, hcLight: lC }, p("editorUnicodeHighlight.background", "Background color used to highlight unicode characters."));
Ho((r, e) => {
  const t = r.getColor(Gi), i = r.getColor(KV), n = i && !i.isTransparent() ? i : t;
  n && e.addRule(`.monaco-editor .inputarea.ime-input { background-color: ${n}; }`);
});
class vb extends eg {
  constructor(e) {
    super(), this._context = e, this._readConfig(), this._lastCursorModelPosition = new A(1, 1), this._renderResult = null, this._activeLineNumber = 1, this._context.addEventHandler(this);
  }
  _readConfig() {
    const e = this._context.configuration.options;
    this._lineHeight = e.get(
      67
      /* EditorOption.lineHeight */
    );
    const t = e.get(
      68
      /* EditorOption.lineNumbers */
    );
    this._renderLineNumbers = t.renderType, this._renderCustomLineNumbers = t.renderFn, this._renderFinalNewline = e.get(
      95
      /* EditorOption.renderFinalNewline */
    );
    const i = e.get(
      145
      /* EditorOption.layoutInfo */
    );
    this._lineNumbersLeft = i.lineNumbersLeft, this._lineNumbersWidth = i.lineNumbersWidth;
  }
  dispose() {
    this._context.removeEventHandler(this), this._renderResult = null, super.dispose();
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    return this._readConfig(), !0;
  }
  onCursorStateChanged(e) {
    const t = e.selections[0].getPosition();
    this._lastCursorModelPosition = this._context.viewModel.coordinatesConverter.convertViewPositionToModelPosition(t);
    let i = !1;
    return this._activeLineNumber !== t.lineNumber && (this._activeLineNumber = t.lineNumber, i = !0), (this._renderLineNumbers === 2 || this._renderLineNumbers === 3) && (i = !0), i;
  }
  onFlushed(e) {
    return !0;
  }
  onLinesChanged(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged;
  }
  onZonesChanged(e) {
    return !0;
  }
  onDecorationsChanged(e) {
    return e.affectsLineNumber;
  }
  // --- end event handlers
  _getLineRenderLineNumber(e) {
    const t = this._context.viewModel.coordinatesConverter.convertViewPositionToModelPosition(new A(e, 1));
    if (t.column !== 1)
      return "";
    const i = t.lineNumber;
    if (this._renderCustomLineNumbers)
      return this._renderCustomLineNumbers(i);
    if (this._renderLineNumbers === 2) {
      const n = Math.abs(this._lastCursorModelPosition.lineNumber - i);
      return n === 0 ? '<span class="relative-current-line-number">' + i + "</span>" : String(n);
    }
    if (this._renderLineNumbers === 3) {
      if (this._lastCursorModelPosition.lineNumber === i || i % 10 === 0)
        return String(i);
      const n = this._context.viewModel.getLineCount();
      return i === n ? String(i) : "";
    }
    return String(i);
  }
  prepareRender(e) {
    if (this._renderLineNumbers === 0) {
      this._renderResult = null;
      return;
    }
    const t = os ? this._lineHeight % 2 === 0 ? " lh-even" : " lh-odd" : "", i = e.visibleRange.startLineNumber, n = e.visibleRange.endLineNumber, s = this._context.viewModel.getDecorationsInViewport(e.visibleRange).filter((d) => !!d.options.lineNumberClassName);
    s.sort((d, c) => L.compareRangesUsingEnds(d.range, c.range));
    let o = 0;
    const a = this._context.viewModel.getLineCount(), l = [];
    for (let d = i; d <= n; d++) {
      const c = d - i;
      let h = this._getLineRenderLineNumber(d), u = "";
      for (; o < s.length && s[o].range.endLineNumber < d; )
        o++;
      for (let g = o; g < s.length; g++) {
        const { range: f, options: m } = s[g];
        f.startLineNumber <= d && (u += " " + m.lineNumberClassName);
      }
      if (!h && !u) {
        l[c] = "";
        continue;
      }
      d === a && this._context.viewModel.getLineLength(d) === 0 && (this._renderFinalNewline === "off" && (h = ""), this._renderFinalNewline === "dimmed" && (u += " dimmed-line-number")), d === this._activeLineNumber && (u += " active-line-number"), l[c] = `<div class="${vb.CLASS_NAME}${t}${u}" style="left:${this._lineNumbersLeft}px;width:${this._lineNumbersWidth}px;">${h}</div>`;
    }
    this._renderResult = l;
  }
  render(e, t) {
    if (!this._renderResult)
      return "";
    const i = t - e;
    return i < 0 || i >= this._renderResult.length ? "" : this._renderResult[i];
  }
}
vb.CLASS_NAME = "line-numbers";
Ho((r, e) => {
  const t = r.getColor(A7), i = r.getColor(K7);
  i ? e.addRule(`.monaco-editor .line-numbers.dimmed-line-number { color: ${i}; }`) : t && e.addRule(`.monaco-editor .line-numbers.dimmed-line-number { color: ${t.transparent(0.4)}; }`);
});
class Su extends Gs {
  constructor(e) {
    super(e);
    const t = this._context.configuration.options, i = t.get(
      145
      /* EditorOption.layoutInfo */
    );
    this._canUseLayerHinting = !t.get(
      32
      /* EditorOption.disableLayerHinting */
    ), this._contentLeft = i.contentLeft, this._glyphMarginLeft = i.glyphMarginLeft, this._glyphMarginWidth = i.glyphMarginWidth, this._domNode = bt(document.createElement("div")), this._domNode.setClassName(Su.OUTER_CLASS_NAME), this._domNode.setPosition("absolute"), this._domNode.setAttribute("role", "presentation"), this._domNode.setAttribute("aria-hidden", "true"), this._glyphMarginBackgroundDomNode = bt(document.createElement("div")), this._glyphMarginBackgroundDomNode.setClassName(Su.CLASS_NAME), this._domNode.appendChild(this._glyphMarginBackgroundDomNode);
  }
  dispose() {
    super.dispose();
  }
  getDomNode() {
    return this._domNode;
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    const t = this._context.configuration.options, i = t.get(
      145
      /* EditorOption.layoutInfo */
    );
    return this._canUseLayerHinting = !t.get(
      32
      /* EditorOption.disableLayerHinting */
    ), this._contentLeft = i.contentLeft, this._glyphMarginLeft = i.glyphMarginLeft, this._glyphMarginWidth = i.glyphMarginWidth, !0;
  }
  onScrollChanged(e) {
    return super.onScrollChanged(e) || e.scrollTopChanged;
  }
  // --- end event handlers
  prepareRender(e) {
  }
  render(e) {
    this._domNode.setLayerHinting(this._canUseLayerHinting), this._domNode.setContain("strict");
    const t = e.scrollTop - e.bigNumbersDelta;
    this._domNode.setTop(-t);
    const i = Math.min(e.scrollHeight, 1e6);
    this._domNode.setHeight(i), this._domNode.setWidth(this._contentLeft), this._glyphMarginBackgroundDomNode.setLeft(this._glyphMarginLeft), this._glyphMarginBackgroundDomNode.setWidth(this._glyphMarginWidth), this._glyphMarginBackgroundDomNode.setHeight(i);
  }
}
Su.CLASS_NAME = "glyph-margin";
Su.OUTER_CLASS_NAME = "margin";
const vf = "monaco-mouse-cursor-text";
class hZ {
  constructor() {
    this._onDidChange = new R(), this.onDidChange = this._onDidChange.event, this._enabled = !0;
  }
  get enabled() {
    return this._enabled;
  }
  /**
   * Enable IME
   */
  enable() {
    this._enabled = !0, this._onDidChange.fire();
  }
  /**
   * Disable IME
   */
  disable() {
    this._enabled = !1, this._onDidChange.fire();
  }
}
const i_ = new hZ(), _t = et("keybindingService");
var uZ = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, CP = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
class gZ {
  constructor(e, t, i, n, s) {
    this._context = e, this.modelLineNumber = t, this.distanceToModelLineStart = i, this.widthOfHiddenLineTextBefore = n, this.distanceToModelLineEnd = s, this._visibleTextAreaBrand = void 0, this.startPosition = null, this.endPosition = null, this.visibleTextareaStart = null, this.visibleTextareaEnd = null, this._previousPresentation = null;
  }
  prepareRender(e) {
    const t = new A(this.modelLineNumber, this.distanceToModelLineStart + 1), i = new A(this.modelLineNumber, this._context.viewModel.model.getLineMaxColumn(this.modelLineNumber) - this.distanceToModelLineEnd);
    this.startPosition = this._context.viewModel.coordinatesConverter.convertModelPositionToViewPosition(t), this.endPosition = this._context.viewModel.coordinatesConverter.convertModelPositionToViewPosition(i), this.startPosition.lineNumber === this.endPosition.lineNumber ? (this.visibleTextareaStart = e.visibleRangeForPosition(this.startPosition), this.visibleTextareaEnd = e.visibleRangeForPosition(this.endPosition)) : (this.visibleTextareaStart = null, this.visibleTextareaEnd = null);
  }
  definePresentation(e) {
    return this._previousPresentation || (e ? this._previousPresentation = e : this._previousPresentation = {
      foreground: 1,
      italic: !1,
      bold: !1,
      underline: !1,
      strikethrough: !1
    }), this._previousPresentation;
  }
}
const KD = Oo;
let Xx = class extends Gs {
  constructor(e, t, i, n, s) {
    super(e), this._keybindingService = n, this._instantiationService = s, this._primaryCursorPosition = new A(1, 1), this._primaryCursorVisibleRange = null, this._viewController = t, this._visibleRangeProvider = i, this._scrollLeft = 0, this._scrollTop = 0;
    const o = this._context.configuration.options, a = o.get(
      145
      /* EditorOption.layoutInfo */
    );
    this._setAccessibilityOptions(o), this._contentLeft = a.contentLeft, this._contentWidth = a.contentWidth, this._contentHeight = a.height, this._fontInfo = o.get(
      50
      /* EditorOption.fontInfo */
    ), this._lineHeight = o.get(
      67
      /* EditorOption.lineHeight */
    ), this._emptySelectionClipboard = o.get(
      37
      /* EditorOption.emptySelectionClipboard */
    ), this._copyWithSyntaxHighlighting = o.get(
      25
      /* EditorOption.copyWithSyntaxHighlighting */
    ), this._visibleTextArea = null, this._selections = [new ge(1, 1, 1, 1)], this._modelSelections = [new ge(1, 1, 1, 1)], this._lastRenderPosition = null, this.textArea = bt(document.createElement("textarea")), Jr.write(
      this.textArea,
      7
      /* PartFingerprint.TextArea */
    ), this.textArea.setClassName(`inputarea ${vf}`), this.textArea.setAttribute("wrap", this._textAreaWrapping && !this._visibleTextArea ? "on" : "off");
    const { tabSize: l } = this._context.viewModel.model.getOptions();
    this.textArea.domNode.style.tabSize = `${l * this._fontInfo.spaceWidth}px`, this.textArea.setAttribute("autocorrect", "off"), this.textArea.setAttribute("autocapitalize", "off"), this.textArea.setAttribute("autocomplete", "off"), this.textArea.setAttribute("spellcheck", "false"), this.textArea.setAttribute("aria-label", this._getAriaLabel(o)), this.textArea.setAttribute("aria-required", o.get(
      5
      /* EditorOption.ariaRequired */
    ) ? "true" : "false"), this.textArea.setAttribute("tabindex", String(o.get(
      124
      /* EditorOption.tabIndex */
    ))), this.textArea.setAttribute("role", "textbox"), this.textArea.setAttribute("aria-roledescription", p("editor", "editor")), this.textArea.setAttribute("aria-multiline", "true"), this.textArea.setAttribute("aria-autocomplete", o.get(
      91
      /* EditorOption.readOnly */
    ) ? "none" : "both"), this._ensureReadOnlyAttribute(), this.textAreaCover = bt(document.createElement("div")), this.textAreaCover.setPosition("absolute");
    const d = {
      getLineCount: () => this._context.viewModel.getLineCount(),
      getLineMaxColumn: (u) => this._context.viewModel.getLineMaxColumn(u),
      getValueInRange: (u, g) => this._context.viewModel.getValueInRange(u, g),
      getValueLengthInRange: (u, g) => this._context.viewModel.getValueLengthInRange(u, g),
      modifyPosition: (u, g) => this._context.viewModel.modifyPosition(u, g)
    }, c = {
      getDataToCopy: () => {
        const u = this._context.viewModel.getPlainTextToCopy(this._modelSelections, this._emptySelectionClipboard, Ks), g = this._context.viewModel.model.getEOL(), f = this._emptySelectionClipboard && this._modelSelections.length === 1 && this._modelSelections[0].isEmpty(), m = Array.isArray(u) ? u : null, _ = Array.isArray(u) ? u.join(g) : u;
        let v, b = null;
        if (Gx.forceCopyWithSyntaxHighlighting || this._copyWithSyntaxHighlighting && _.length < 65536) {
          const C = this._context.viewModel.getRichTextToCopy(this._modelSelections, this._emptySelectionClipboard);
          C && (v = C.html, b = C.mode);
        }
        return {
          isFromEmptySelection: f,
          multicursorText: m,
          text: _,
          html: v,
          mode: b
        };
      },
      getScreenReaderContent: () => {
        if (this._accessibilitySupport === 1) {
          const u = this._selections[0];
          if (Je && u.isEmpty()) {
            const f = u.getStartPosition();
            let m = this._getWordBeforePosition(f);
            if (m.length === 0 && (m = this._getCharacterBeforePosition(f)), m.length > 0)
              return new hn(m, m.length, m.length, L.fromPositions(f), 0);
          }
          if (Je && !u.isEmpty() && d.getValueLengthInRange(
            u,
            0
            /* EndOfLinePreference.TextDefined */
          ) < 500) {
            const f = d.getValueInRange(
              u,
              0
              /* EndOfLinePreference.TextDefined */
            );
            return new hn(f, 0, f.length, u, 0);
          }
          if (ld && !u.isEmpty()) {
            const f = "vscode-placeholder";
            return new hn(f, 0, f.length, null, void 0);
          }
          return hn.EMPTY;
        }
        if (mA) {
          const u = this._selections[0];
          if (u.isEmpty()) {
            const g = u.getStartPosition(), [f, m] = this._getAndroidWordAtPosition(g);
            if (f.length > 0)
              return new hn(f, m, m, L.fromPositions(g), 0);
          }
          return hn.EMPTY;
        }
        return Yg.fromEditorSelection(
          d,
          this._selections[0],
          this._accessibilityPageSize,
          this._accessibilitySupport === 0
          /* AccessibilitySupport.Unknown */
        );
      },
      deduceModelPosition: (u, g, f) => this._context.viewModel.deduceModelPositionRelativeToViewPosition(u, g, f)
    }, h = this._register(new k7(this.textArea.domNode));
    this._textAreaInput = this._register(this._instantiationService.createInstance(Zx, c, h, Os, {
      isAndroid: mA,
      isChrome: ob,
      isFirefox: Oo,
      isSafari: ld
    })), this._register(this._textAreaInput.onKeyDown((u) => {
      this._viewController.emitKeyDown(u);
    })), this._register(this._textAreaInput.onKeyUp((u) => {
      this._viewController.emitKeyUp(u);
    })), this._register(this._textAreaInput.onPaste((u) => {
      let g = !1, f = null, m = null;
      u.metadata && (g = this._emptySelectionClipboard && !!u.metadata.isFromEmptySelection, f = typeof u.metadata.multicursorText < "u" ? u.metadata.multicursorText : null, m = u.metadata.mode), this._viewController.paste(u.text, g, f, m);
    })), this._register(this._textAreaInput.onCut(() => {
      this._viewController.cut();
    })), this._register(this._textAreaInput.onType((u) => {
      u.replacePrevCharCnt || u.replaceNextCharCnt || u.positionDelta ? this._viewController.compositionType(u.text, u.replacePrevCharCnt, u.replaceNextCharCnt, u.positionDelta) : this._viewController.type(u.text);
    })), this._register(this._textAreaInput.onSelectionChangeRequest((u) => {
      this._viewController.setSelection(u);
    })), this._register(this._textAreaInput.onCompositionStart((u) => {
      const g = this.textArea.domNode, f = this._modelSelections[0], { distanceToModelLineStart: m, widthOfHiddenTextBefore: _ } = (() => {
        const b = g.value.substring(0, Math.min(g.selectionStart, g.selectionEnd)), C = b.lastIndexOf(`
`), w = b.substring(C + 1), S = w.lastIndexOf("	"), y = w.length - S - 1, k = f.getStartPosition(), E = Math.min(k.column - 1, y), N = k.column - 1 - E, F = w.substring(0, w.length - E), { tabSize: V } = this._context.viewModel.model.getOptions(), Z = fZ(this.textArea.domNode.ownerDocument, F, this._fontInfo, V);
        return { distanceToModelLineStart: N, widthOfHiddenTextBefore: Z };
      })(), { distanceToModelLineEnd: v } = (() => {
        const b = g.value.substring(Math.max(g.selectionStart, g.selectionEnd)), C = b.indexOf(`
`), w = C === -1 ? b : b.substring(0, C), S = w.indexOf("	"), y = S === -1 ? w.length : w.length - S - 1, k = f.getEndPosition(), E = Math.min(this._context.viewModel.model.getLineMaxColumn(k.lineNumber) - k.column, y);
        return { distanceToModelLineEnd: this._context.viewModel.model.getLineMaxColumn(k.lineNumber) - k.column - E };
      })();
      this._context.viewModel.revealRange(
        "keyboard",
        !0,
        L.fromPositions(this._selections[0].getStartPosition()),
        0,
        1
        /* ScrollType.Immediate */
      ), this._visibleTextArea = new gZ(this._context, f.startLineNumber, m, _, v), this.textArea.setAttribute("wrap", this._textAreaWrapping && !this._visibleTextArea ? "on" : "off"), this._visibleTextArea.prepareRender(this._visibleRangeProvider), this._render(), this.textArea.setClassName(`inputarea ${vf} ime-input`), this._viewController.compositionStart(), this._context.viewModel.onCompositionStart();
    })), this._register(this._textAreaInput.onCompositionUpdate((u) => {
      this._visibleTextArea && (this._visibleTextArea.prepareRender(this._visibleRangeProvider), this._render());
    })), this._register(this._textAreaInput.onCompositionEnd(() => {
      this._visibleTextArea = null, this.textArea.setAttribute("wrap", this._textAreaWrapping && !this._visibleTextArea ? "on" : "off"), this._render(), this.textArea.setClassName(`inputarea ${vf}`), this._viewController.compositionEnd(), this._context.viewModel.onCompositionEnd();
    })), this._register(this._textAreaInput.onFocus(() => {
      this._context.viewModel.setHasFocus(!0);
    })), this._register(this._textAreaInput.onBlur(() => {
      this._context.viewModel.setHasFocus(!1);
    })), this._register(i_.onDidChange(() => {
      this._ensureReadOnlyAttribute();
    }));
  }
  writeScreenReaderContent(e) {
    this._textAreaInput.writeNativeTextAreaContent(e);
  }
  dispose() {
    super.dispose();
  }
  _getAndroidWordAtPosition(e) {
    const t = '`~!@#$%^&*()-=+[{]}\\|;:",.<>/?', i = this._context.viewModel.getLineContent(e.lineNumber), n = fr(t, []);
    let s = !0, o = e.column, a = !0, l = e.column, d = 0;
    for (; d < 50 && (s || a); ) {
      if (s && o <= 1 && (s = !1), s) {
        const c = i.charCodeAt(o - 2);
        n.get(c) !== 0 ? s = !1 : o--;
      }
      if (a && l > i.length && (a = !1), a) {
        const c = i.charCodeAt(l - 1);
        n.get(c) !== 0 ? a = !1 : l++;
      }
      d++;
    }
    return [i.substring(o - 1, l - 1), e.column - o];
  }
  _getWordBeforePosition(e) {
    const t = this._context.viewModel.getLineContent(e.lineNumber), i = fr(this._context.configuration.options.get(
      131
      /* EditorOption.wordSeparators */
    ), []);
    let n = e.column, s = 0;
    for (; n > 1; ) {
      const o = t.charCodeAt(n - 2);
      if (i.get(o) !== 0 || s > 50)
        return t.substring(n - 1, e.column - 1);
      s++, n--;
    }
    return t.substring(0, e.column - 1);
  }
  _getCharacterBeforePosition(e) {
    if (e.column > 1) {
      const i = this._context.viewModel.getLineContent(e.lineNumber).charAt(e.column - 2);
      if (!$n(i.charCodeAt(0)))
        return i;
    }
    return "";
  }
  _getAriaLabel(e) {
    var t, i, n;
    if (e.get(
      2
      /* EditorOption.accessibilitySupport */
    ) === 1) {
      const o = (t = this._keybindingService.lookupKeybinding("editor.action.toggleScreenReaderAccessibilityMode")) === null || t === void 0 ? void 0 : t.getAriaLabel(), a = (i = this._keybindingService.lookupKeybinding("workbench.action.showCommands")) === null || i === void 0 ? void 0 : i.getAriaLabel(), l = (n = this._keybindingService.lookupKeybinding("workbench.action.openGlobalKeybindings")) === null || n === void 0 ? void 0 : n.getAriaLabel(), d = p("accessibilityModeOff", "The editor is not accessible at this time.");
      return o ? p("accessibilityOffAriaLabel", "{0} To enable screen reader optimized mode, use {1}", d, o) : a ? p("accessibilityOffAriaLabelNoKb", "{0} To enable screen reader optimized mode, open the quick pick with {1} and run the command Toggle Screen Reader Accessibility Mode, which is currently not triggerable via keyboard.", d, a) : l ? p("accessibilityOffAriaLabelNoKbs", "{0} Please assign a keybinding for the command Toggle Screen Reader Accessibility Mode by accessing the keybindings editor with {1} and run it.", d, l) : d;
    }
    return e.get(
      4
      /* EditorOption.ariaLabel */
    );
  }
  _setAccessibilityOptions(e) {
    this._accessibilitySupport = e.get(
      2
      /* EditorOption.accessibilitySupport */
    );
    const t = e.get(
      3
      /* EditorOption.accessibilityPageSize */
    );
    this._accessibilitySupport === 2 && t === oa.accessibilityPageSize.defaultValue ? this._accessibilityPageSize = 500 : this._accessibilityPageSize = t;
    const n = e.get(
      145
      /* EditorOption.layoutInfo */
    ).wrappingColumn;
    if (n !== -1 && this._accessibilitySupport !== 1) {
      const s = e.get(
        50
        /* EditorOption.fontInfo */
      );
      this._textAreaWrapping = !0, this._textAreaWidth = Math.round(n * s.typicalHalfwidthCharacterWidth);
    } else
      this._textAreaWrapping = !1, this._textAreaWidth = KD ? 0 : 1;
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    const t = this._context.configuration.options, i = t.get(
      145
      /* EditorOption.layoutInfo */
    );
    this._setAccessibilityOptions(t), this._contentLeft = i.contentLeft, this._contentWidth = i.contentWidth, this._contentHeight = i.height, this._fontInfo = t.get(
      50
      /* EditorOption.fontInfo */
    ), this._lineHeight = t.get(
      67
      /* EditorOption.lineHeight */
    ), this._emptySelectionClipboard = t.get(
      37
      /* EditorOption.emptySelectionClipboard */
    ), this._copyWithSyntaxHighlighting = t.get(
      25
      /* EditorOption.copyWithSyntaxHighlighting */
    ), this.textArea.setAttribute("wrap", this._textAreaWrapping && !this._visibleTextArea ? "on" : "off");
    const { tabSize: n } = this._context.viewModel.model.getOptions();
    return this.textArea.domNode.style.tabSize = `${n * this._fontInfo.spaceWidth}px`, this.textArea.setAttribute("aria-label", this._getAriaLabel(t)), this.textArea.setAttribute("aria-required", t.get(
      5
      /* EditorOption.ariaRequired */
    ) ? "true" : "false"), this.textArea.setAttribute("tabindex", String(t.get(
      124
      /* EditorOption.tabIndex */
    ))), (e.hasChanged(
      34
      /* EditorOption.domReadOnly */
    ) || e.hasChanged(
      91
      /* EditorOption.readOnly */
    )) && this._ensureReadOnlyAttribute(), e.hasChanged(
      2
      /* EditorOption.accessibilitySupport */
    ) && this._textAreaInput.writeNativeTextAreaContent("strategy changed"), !0;
  }
  onCursorStateChanged(e) {
    return this._selections = e.selections.slice(0), this._modelSelections = e.modelSelections.slice(0), this._textAreaInput.writeNativeTextAreaContent("selection changed"), !0;
  }
  onDecorationsChanged(e) {
    return !0;
  }
  onFlushed(e) {
    return !0;
  }
  onLinesChanged(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return this._scrollLeft = e.scrollLeft, this._scrollTop = e.scrollTop, !0;
  }
  onZonesChanged(e) {
    return !0;
  }
  // --- end event handlers
  // --- begin view API
  isFocused() {
    return this._textAreaInput.isFocused();
  }
  focusTextArea() {
    this._textAreaInput.focusTextArea();
  }
  getLastRenderData() {
    return this._lastRenderPosition;
  }
  setAriaOptions(e) {
    e.activeDescendant ? (this.textArea.setAttribute("aria-haspopup", "true"), this.textArea.setAttribute("aria-autocomplete", "list"), this.textArea.setAttribute("aria-activedescendant", e.activeDescendant)) : (this.textArea.setAttribute("aria-haspopup", "false"), this.textArea.setAttribute("aria-autocomplete", "both"), this.textArea.removeAttribute("aria-activedescendant")), e.role && this.textArea.setAttribute("role", e.role);
  }
  // --- end view API
  _ensureReadOnlyAttribute() {
    const e = this._context.configuration.options;
    !i_.enabled || e.get(
      34
      /* EditorOption.domReadOnly */
    ) && e.get(
      91
      /* EditorOption.readOnly */
    ) ? this.textArea.setAttribute("readonly", "true") : this.textArea.removeAttribute("readonly");
  }
  prepareRender(e) {
    var t;
    this._primaryCursorPosition = new A(this._selections[0].positionLineNumber, this._selections[0].positionColumn), this._primaryCursorVisibleRange = e.visibleRangeForPosition(this._primaryCursorPosition), (t = this._visibleTextArea) === null || t === void 0 || t.prepareRender(e);
  }
  render(e) {
    this._textAreaInput.writeNativeTextAreaContent("render"), this._render();
  }
  _render() {
    var e;
    if (this._visibleTextArea) {
      const n = this._visibleTextArea.visibleTextareaStart, s = this._visibleTextArea.visibleTextareaEnd, o = this._visibleTextArea.startPosition, a = this._visibleTextArea.endPosition;
      if (o && a && n && s && s.left >= this._scrollLeft && n.left <= this._scrollLeft + this._contentWidth) {
        const l = this._context.viewLayout.getVerticalOffsetForLineNumber(this._primaryCursorPosition.lineNumber) - this._scrollTop, d = this._newlinecount(this.textArea.domNode.value.substr(0, this.textArea.domNode.selectionStart));
        let c = this._visibleTextArea.widthOfHiddenLineTextBefore, h = this._contentLeft + n.left - this._scrollLeft, u = s.left - n.left + 1;
        if (h < this._contentLeft) {
          const b = this._contentLeft - h;
          h += b, c += b, u -= b;
        }
        u > this._contentWidth && (u = this._contentWidth);
        const g = this._context.viewModel.getViewLineData(o.lineNumber), f = g.tokens.findTokenIndexAtOffset(o.column - 1), m = g.tokens.findTokenIndexAtOffset(a.column - 1), _ = f === m, v = this._visibleTextArea.definePresentation(_ ? g.tokens.getPresentation(f) : null);
        this.textArea.domNode.scrollTop = d * this._lineHeight, this.textArea.domNode.scrollLeft = c, this._doRender({
          lastRenderPosition: null,
          top: l,
          left: h,
          width: u,
          height: this._lineHeight,
          useCover: !1,
          color: (ri.getColorMap() || [])[v.foreground],
          italic: v.italic,
          bold: v.bold,
          underline: v.underline,
          strikethrough: v.strikethrough
        });
      }
      return;
    }
    if (!this._primaryCursorVisibleRange) {
      this._renderAtTopLeft();
      return;
    }
    const t = this._contentLeft + this._primaryCursorVisibleRange.left - this._scrollLeft;
    if (t < this._contentLeft || t > this._contentLeft + this._contentWidth) {
      this._renderAtTopLeft();
      return;
    }
    const i = this._context.viewLayout.getVerticalOffsetForLineNumber(this._selections[0].positionLineNumber) - this._scrollTop;
    if (i < 0 || i > this._contentHeight) {
      this._renderAtTopLeft();
      return;
    }
    if (Je || this._accessibilitySupport === 2) {
      this._doRender({
        lastRenderPosition: this._primaryCursorPosition,
        top: i,
        left: this._textAreaWrapping ? this._contentLeft : t,
        width: this._textAreaWidth,
        height: this._lineHeight,
        useCover: !1
      }), this.textArea.domNode.scrollLeft = this._primaryCursorVisibleRange.left;
      const n = (e = this._textAreaInput.textAreaState.newlineCountBeforeSelection) !== null && e !== void 0 ? e : this._newlinecount(this.textArea.domNode.value.substr(0, this.textArea.domNode.selectionStart));
      this.textArea.domNode.scrollTop = n * this._lineHeight;
      return;
    }
    this._doRender({
      lastRenderPosition: this._primaryCursorPosition,
      top: i,
      left: this._textAreaWrapping ? this._contentLeft : t,
      width: this._textAreaWidth,
      height: KD ? 0 : 1,
      useCover: !1
    });
  }
  _newlinecount(e) {
    let t = 0, i = -1;
    do {
      if (i = e.indexOf(`
`, i + 1), i === -1)
        break;
      t++;
    } while (!0);
    return t;
  }
  _renderAtTopLeft() {
    this._doRender({
      lastRenderPosition: null,
      top: 0,
      left: 0,
      width: this._textAreaWidth,
      height: KD ? 0 : 1,
      useCover: !0
    });
  }
  _doRender(e) {
    this._lastRenderPosition = e.lastRenderPosition;
    const t = this.textArea, i = this.textAreaCover;
    _n(t, this._fontInfo), t.setTop(e.top), t.setLeft(e.left), t.setWidth(e.width), t.setHeight(e.height), t.setColor(e.color ? z.Format.CSS.formatHex(e.color) : ""), t.setFontStyle(e.italic ? "italic" : ""), e.bold && t.setFontWeight("bold"), t.setTextDecoration(`${e.underline ? " underline" : ""}${e.strikethrough ? " line-through" : ""}`), i.setTop(e.useCover ? e.top : 0), i.setLeft(e.useCover ? e.left : 0), i.setWidth(e.useCover ? e.width : 0), i.setHeight(e.useCover ? e.height : 0);
    const n = this._context.configuration.options;
    n.get(
      57
      /* EditorOption.glyphMargin */
    ) ? i.setClassName("monaco-editor-background textAreaCover " + Su.OUTER_CLASS_NAME) : n.get(
      68
      /* EditorOption.lineNumbers */
    ).renderType !== 0 ? i.setClassName("monaco-editor-background textAreaCover " + vb.CLASS_NAME) : i.setClassName("monaco-editor-background textAreaCover");
  }
};
Xx = uZ([
  CP(3, _t),
  CP(4, be)
], Xx);
function fZ(r, e, t, i) {
  if (e.length === 0)
    return 0;
  const n = r.createElement("div");
  n.style.position = "absolute", n.style.top = "-50000px", n.style.width = "50000px";
  const s = r.createElement("span");
  _n(s, t), s.style.whiteSpace = "pre", s.style.tabSize = `${i * t.spaceWidth}px`, s.append(e), n.appendChild(s), r.body.appendChild(n);
  const o = s.offsetWidth;
  return r.body.removeChild(n), o;
}
function pZ(r, e, t) {
  let i = 0;
  for (let s = 0; s < r.length; s++)
    r.charAt(s) === "	" ? i = Hi.nextIndentTabStop(i, e) : i++;
  let n = "";
  if (!t) {
    const s = Math.floor(i / e);
    i = i % e;
    for (let o = 0; o < s; o++)
      n += "	";
  }
  for (let s = 0; s < i; s++)
    n += " ";
  return n;
}
function I1(r, e, t) {
  let i = ns(r);
  return i === -1 && (i = r.length), pZ(r.substring(0, i), e, t) + r.substring(i);
}
const mZ = () => !0, _Z = () => !1, vZ = (r) => r === " " || r === "	";
class pg {
  static shouldRecreate(e) {
    return e.hasChanged(
      145
      /* EditorOption.layoutInfo */
    ) || e.hasChanged(
      131
      /* EditorOption.wordSeparators */
    ) || e.hasChanged(
      37
      /* EditorOption.emptySelectionClipboard */
    ) || e.hasChanged(
      77
      /* EditorOption.multiCursorMergeOverlapping */
    ) || e.hasChanged(
      79
      /* EditorOption.multiCursorPaste */
    ) || e.hasChanged(
      80
      /* EditorOption.multiCursorLimit */
    ) || e.hasChanged(
      6
      /* EditorOption.autoClosingBrackets */
    ) || e.hasChanged(
      7
      /* EditorOption.autoClosingComments */
    ) || e.hasChanged(
      11
      /* EditorOption.autoClosingQuotes */
    ) || e.hasChanged(
      9
      /* EditorOption.autoClosingDelete */
    ) || e.hasChanged(
      10
      /* EditorOption.autoClosingOvertype */
    ) || e.hasChanged(
      14
      /* EditorOption.autoSurround */
    ) || e.hasChanged(
      128
      /* EditorOption.useTabStops */
    ) || e.hasChanged(
      50
      /* EditorOption.fontInfo */
    ) || e.hasChanged(
      91
      /* EditorOption.readOnly */
    ) || e.hasChanged(
      130
      /* EditorOption.wordSegmenterLocales */
    );
  }
  constructor(e, t, i, n) {
    var s;
    this.languageConfigurationService = n, this._cursorMoveConfigurationBrand = void 0, this._languageId = e;
    const o = i.options, a = o.get(
      145
      /* EditorOption.layoutInfo */
    ), l = o.get(
      50
      /* EditorOption.fontInfo */
    );
    this.readOnly = o.get(
      91
      /* EditorOption.readOnly */
    ), this.tabSize = t.tabSize, this.indentSize = t.indentSize, this.insertSpaces = t.insertSpaces, this.stickyTabStops = o.get(
      116
      /* EditorOption.stickyTabStops */
    ), this.lineHeight = l.lineHeight, this.typicalHalfwidthCharacterWidth = l.typicalHalfwidthCharacterWidth, this.pageSize = Math.max(1, Math.floor(a.height / this.lineHeight) - 2), this.useTabStops = o.get(
      128
      /* EditorOption.useTabStops */
    ), this.wordSeparators = o.get(
      131
      /* EditorOption.wordSeparators */
    ), this.emptySelectionClipboard = o.get(
      37
      /* EditorOption.emptySelectionClipboard */
    ), this.copyWithSyntaxHighlighting = o.get(
      25
      /* EditorOption.copyWithSyntaxHighlighting */
    ), this.multiCursorMergeOverlapping = o.get(
      77
      /* EditorOption.multiCursorMergeOverlapping */
    ), this.multiCursorPaste = o.get(
      79
      /* EditorOption.multiCursorPaste */
    ), this.multiCursorLimit = o.get(
      80
      /* EditorOption.multiCursorLimit */
    ), this.autoClosingBrackets = o.get(
      6
      /* EditorOption.autoClosingBrackets */
    ), this.autoClosingComments = o.get(
      7
      /* EditorOption.autoClosingComments */
    ), this.autoClosingQuotes = o.get(
      11
      /* EditorOption.autoClosingQuotes */
    ), this.autoClosingDelete = o.get(
      9
      /* EditorOption.autoClosingDelete */
    ), this.autoClosingOvertype = o.get(
      10
      /* EditorOption.autoClosingOvertype */
    ), this.autoSurround = o.get(
      14
      /* EditorOption.autoSurround */
    ), this.autoIndent = o.get(
      12
      /* EditorOption.autoIndent */
    ), this.wordSegmenterLocales = o.get(
      130
      /* EditorOption.wordSegmenterLocales */
    ), this.surroundingPairs = {}, this._electricChars = null, this.shouldAutoCloseBefore = {
      quote: this._getShouldAutoClose(e, this.autoClosingQuotes, !0),
      comment: this._getShouldAutoClose(e, this.autoClosingComments, !1),
      bracket: this._getShouldAutoClose(e, this.autoClosingBrackets, !1)
    }, this.autoClosingPairs = this.languageConfigurationService.getLanguageConfiguration(e).getAutoClosingPairs();
    const d = this.languageConfigurationService.getLanguageConfiguration(e).getSurroundingPairs();
    if (d)
      for (const h of d)
        this.surroundingPairs[h.open] = h.close;
    const c = this.languageConfigurationService.getLanguageConfiguration(e).comments;
    this.blockCommentStartToken = (s = c == null ? void 0 : c.blockCommentStartToken) !== null && s !== void 0 ? s : null;
  }
  get electricChars() {
    var e;
    if (!this._electricChars) {
      this._electricChars = {};
      const t = (e = this.languageConfigurationService.getLanguageConfiguration(this._languageId).electricCharacter) === null || e === void 0 ? void 0 : e.getElectricCharacters();
      if (t)
        for (const i of t)
          this._electricChars[i] = !0;
    }
    return this._electricChars;
  }
  /**
   * Should return opening bracket type to match indentation with
   */
  onElectricCharacter(e, t, i) {
    const n = qh(t, i - 1), s = this.languageConfigurationService.getLanguageConfiguration(n.languageId).electricCharacter;
    return s ? s.onElectricCharacter(e, n, i - n.firstCharOffset) : null;
  }
  normalizeIndentation(e) {
    return I1(e, this.indentSize, this.insertSpaces);
  }
  _getShouldAutoClose(e, t, i) {
    switch (t) {
      case "beforeWhitespace":
        return vZ;
      case "languageDefined":
        return this._getLanguageDefinedShouldAutoClose(e, i);
      case "always":
        return mZ;
      case "never":
        return _Z;
    }
  }
  _getLanguageDefinedShouldAutoClose(e, t) {
    const i = this.languageConfigurationService.getLanguageConfiguration(e).getAutoCloseBeforeSet(t);
    return (n) => i.indexOf(n) !== -1;
  }
  /**
   * Returns a visible column from a column.
   * @see {@link CursorColumns}
   */
  visibleColumnFromColumn(e, t) {
    return Hi.visibleColumnFromColumn(e.getLineContent(t.lineNumber), t.column, this.tabSize);
  }
  /**
   * Returns a visible column from a column.
   * @see {@link CursorColumns}
   */
  columnFromVisibleColumn(e, t, i) {
    const n = Hi.columnFromVisibleColumn(e.getLineContent(t), i, this.tabSize), s = e.getLineMinColumn(t);
    if (n < s)
      return s;
    const o = e.getLineMaxColumn(t);
    return n > o ? o : n;
  }
}
let dt = class t2 {
  static fromModelState(e) {
    return new bZ(e);
  }
  static fromViewState(e) {
    return new CZ(e);
  }
  static fromModelSelection(e) {
    const t = ge.liftSelection(e), i = new un(L.fromPositions(t.getSelectionStart()), 0, 0, t.getPosition(), 0);
    return t2.fromModelState(i);
  }
  static fromModelSelections(e) {
    const t = [];
    for (let i = 0, n = e.length; i < n; i++)
      t[i] = this.fromModelSelection(e[i]);
    return t;
  }
  constructor(e, t) {
    this._cursorStateBrand = void 0, this.modelState = e, this.viewState = t;
  }
  equals(e) {
    return this.viewState.equals(e.viewState) && this.modelState.equals(e.modelState);
  }
};
class bZ {
  constructor(e) {
    this.modelState = e, this.viewState = null;
  }
}
class CZ {
  constructor(e) {
    this.modelState = null, this.viewState = e;
  }
}
class un {
  constructor(e, t, i, n, s) {
    this.selectionStart = e, this.selectionStartKind = t, this.selectionStartLeftoverVisibleColumns = i, this.position = n, this.leftoverVisibleColumns = s, this._singleCursorStateBrand = void 0, this.selection = un._computeSelection(this.selectionStart, this.position);
  }
  equals(e) {
    return this.selectionStartLeftoverVisibleColumns === e.selectionStartLeftoverVisibleColumns && this.leftoverVisibleColumns === e.leftoverVisibleColumns && this.selectionStartKind === e.selectionStartKind && this.position.equals(e.position) && this.selectionStart.equalsRange(e.selectionStart);
  }
  hasSelection() {
    return !this.selection.isEmpty() || !this.selectionStart.isEmpty();
  }
  move(e, t, i, n) {
    return e ? new un(this.selectionStart, this.selectionStartKind, this.selectionStartLeftoverVisibleColumns, new A(t, i), n) : new un(new L(t, i, t, i), 0, n, new A(t, i), n);
  }
  static _computeSelection(e, t) {
    return e.isEmpty() || !t.isBeforeOrEqual(e.getStartPosition()) ? ge.fromPositions(e.getStartPosition(), t) : ge.fromPositions(e.getEndPosition(), t);
  }
}
class ps {
  constructor(e, t, i) {
    this._editOperationResultBrand = void 0, this.type = e, this.commands = t, this.shouldPushStackElementBefore = i.shouldPushStackElementBefore, this.shouldPushStackElementAfter = i.shouldPushStackElementAfter;
  }
}
function Pd(r) {
  return r === "'" || r === '"' || r === "`";
}
class Vh {
  static columnSelect(e, t, i, n, s, o) {
    const a = Math.abs(s - i) + 1, l = i > s, d = n > o, c = n < o, h = [];
    for (let u = 0; u < a; u++) {
      const g = i + (l ? -u : u), f = e.columnFromVisibleColumn(t, g, n), m = e.columnFromVisibleColumn(t, g, o), _ = e.visibleColumnFromColumn(t, new A(g, f)), v = e.visibleColumnFromColumn(t, new A(g, m));
      c && (_ > o || v < n) || d && (v > n || _ < o) || h.push(new un(new L(g, f, g, f), 0, 0, new A(g, m), 0));
    }
    if (h.length === 0)
      for (let u = 0; u < a; u++) {
        const g = i + (l ? -u : u), f = t.getLineMaxColumn(g);
        h.push(new un(new L(g, f, g, f), 0, 0, new A(g, f), 0));
      }
    return {
      viewStates: h,
      reversed: l,
      fromLineNumber: i,
      fromVisualColumn: n,
      toLineNumber: s,
      toVisualColumn: o
    };
  }
  static columnSelectLeft(e, t, i) {
    let n = i.toViewVisualColumn;
    return n > 0 && n--, Vh.columnSelect(e, t, i.fromViewLineNumber, i.fromViewVisualColumn, i.toViewLineNumber, n);
  }
  static columnSelectRight(e, t, i) {
    let n = 0;
    const s = Math.min(i.fromViewLineNumber, i.toViewLineNumber), o = Math.max(i.fromViewLineNumber, i.toViewLineNumber);
    for (let l = s; l <= o; l++) {
      const d = t.getLineMaxColumn(l), c = e.visibleColumnFromColumn(t, new A(l, d));
      n = Math.max(n, c);
    }
    let a = i.toViewVisualColumn;
    return a < n && a++, this.columnSelect(e, t, i.fromViewLineNumber, i.fromViewVisualColumn, i.toViewLineNumber, a);
  }
  static columnSelectUp(e, t, i, n) {
    const s = n ? e.pageSize : 1, o = Math.max(1, i.toViewLineNumber - s);
    return this.columnSelect(e, t, i.fromViewLineNumber, i.fromViewVisualColumn, o, i.toViewVisualColumn);
  }
  static columnSelectDown(e, t, i, n) {
    const s = n ? e.pageSize : 1, o = Math.min(t.getLineCount(), i.toViewLineNumber + s);
    return this.columnSelect(e, t, i.fromViewLineNumber, i.fromViewVisualColumn, o, i.toViewVisualColumn);
  }
}
class Cn {
  constructor(e, t, i = !1) {
    this._range = e, this._text = t, this.insertsAutoWhitespace = i;
  }
  getEditOperations(e, t) {
    t.addTrackedEditOperation(this._range, this._text);
  }
  computeCursorState(e, t) {
    const n = t.getInverseEditOperations()[0].range;
    return ge.fromPositions(n.getEndPosition());
  }
}
class wZ {
  constructor(e, t) {
    this._range = e, this._text = t;
  }
  getEditOperations(e, t) {
    t.addTrackedEditOperation(this._range, this._text);
  }
  computeCursorState(e, t) {
    const n = t.getInverseEditOperations()[0].range;
    return ge.fromRange(
      n,
      0
      /* SelectionDirection.LTR */
    );
  }
}
class mC {
  constructor(e, t, i = !1) {
    this._range = e, this._text = t, this.insertsAutoWhitespace = i;
  }
  getEditOperations(e, t) {
    t.addTrackedEditOperation(this._range, this._text);
  }
  computeCursorState(e, t) {
    const n = t.getInverseEditOperations()[0].range;
    return ge.fromPositions(n.getStartPosition());
  }
}
class Rw {
  constructor(e, t, i, n, s = !1) {
    this._range = e, this._text = t, this._columnDeltaOffset = n, this._lineNumberDeltaOffset = i, this.insertsAutoWhitespace = s;
  }
  getEditOperations(e, t) {
    t.addTrackedEditOperation(this._range, this._text);
  }
  computeCursorState(e, t) {
    const n = t.getInverseEditOperations()[0].range;
    return ge.fromPositions(n.getEndPosition().delta(this._lineNumberDeltaOffset, this._columnDeltaOffset));
  }
}
class E1 {
  constructor(e, t, i, n = !1) {
    this._range = e, this._text = t, this._initialSelection = i, this._forceMoveMarkers = n, this._selectionId = null;
  }
  getEditOperations(e, t) {
    t.addTrackedEditOperation(this._range, this._text, this._forceMoveMarkers), this._selectionId = t.trackSelection(this._initialSelection);
  }
  computeCursorState(e, t) {
    return t.getTrackedSelection(this._selectionId);
  }
}
class jD {
  constructor(e, t, i) {
    this._cursorPositionBrand = void 0, this.lineNumber = e, this.column = t, this.leftoverVisibleColumns = i;
  }
}
class wt {
  static leftPosition(e, t) {
    if (t.column > e.getLineMinColumn(t.lineNumber))
      return t.delta(void 0, -f5(e.getLineContent(t.lineNumber), t.column - 1));
    if (t.lineNumber > 1) {
      const i = t.lineNumber - 1;
      return new A(i, e.getLineMaxColumn(i));
    } else
      return t;
  }
  static leftPositionAtomicSoftTabs(e, t, i) {
    if (t.column <= e.getLineIndentColumn(t.lineNumber)) {
      const n = e.getLineMinColumn(t.lineNumber), s = e.getLineContent(t.lineNumber), o = K_.atomicPosition(
        s,
        t.column - 1,
        i,
        0
        /* Direction.Left */
      );
      if (o !== -1 && o + 1 >= n)
        return new A(t.lineNumber, o + 1);
    }
    return this.leftPosition(e, t);
  }
  static left(e, t, i) {
    const n = e.stickyTabStops ? wt.leftPositionAtomicSoftTabs(t, i, e.tabSize) : wt.leftPosition(t, i);
    return new jD(n.lineNumber, n.column, 0);
  }
  /**
   * @param noOfColumns Must be either `1`
   * or `Math.round(viewModel.getLineContent(viewLineNumber).length / 2)` (for half lines).
  */
  static moveLeft(e, t, i, n, s) {
    let o, a;
    if (i.hasSelection() && !n)
      o = i.selection.startLineNumber, a = i.selection.startColumn;
    else {
      const l = i.position.delta(void 0, -(s - 1)), d = t.normalizePosition(
        wt.clipPositionColumn(l, t),
        0
        /* PositionAffinity.Left */
      ), c = wt.left(e, t, d);
      o = c.lineNumber, a = c.column;
    }
    return i.move(n, o, a, 0);
  }
  /**
   * Adjusts the column so that it is within min/max of the line.
  */
  static clipPositionColumn(e, t) {
    return new A(e.lineNumber, wt.clipRange(e.column, t.getLineMinColumn(e.lineNumber), t.getLineMaxColumn(e.lineNumber)));
  }
  static clipRange(e, t, i) {
    return e < t ? t : e > i ? i : e;
  }
  static rightPosition(e, t, i) {
    return i < e.getLineMaxColumn(t) ? i = i + GB(e.getLineContent(t), i - 1) : t < e.getLineCount() && (t = t + 1, i = e.getLineMinColumn(t)), new A(t, i);
  }
  static rightPositionAtomicSoftTabs(e, t, i, n, s) {
    if (i < e.getLineIndentColumn(t)) {
      const o = e.getLineContent(t), a = K_.atomicPosition(
        o,
        i - 1,
        n,
        1
        /* Direction.Right */
      );
      if (a !== -1)
        return new A(t, a + 1);
    }
    return this.rightPosition(e, t, i);
  }
  static right(e, t, i) {
    const n = e.stickyTabStops ? wt.rightPositionAtomicSoftTabs(t, i.lineNumber, i.column, e.tabSize, e.indentSize) : wt.rightPosition(t, i.lineNumber, i.column);
    return new jD(n.lineNumber, n.column, 0);
  }
  static moveRight(e, t, i, n, s) {
    let o, a;
    if (i.hasSelection() && !n)
      o = i.selection.endLineNumber, a = i.selection.endColumn;
    else {
      const l = i.position.delta(void 0, s - 1), d = t.normalizePosition(
        wt.clipPositionColumn(l, t),
        1
        /* PositionAffinity.Right */
      ), c = wt.right(e, t, d);
      o = c.lineNumber, a = c.column;
    }
    return i.move(n, o, a, 0);
  }
  static vertical(e, t, i, n, s, o, a, l) {
    const d = Hi.visibleColumnFromColumn(t.getLineContent(i), n, e.tabSize) + s, c = t.getLineCount(), h = i === 1 && n === 1, u = i === c && n === t.getLineMaxColumn(i), g = o < i ? h : u;
    if (i = o, i < 1 ? (i = 1, a ? n = t.getLineMinColumn(i) : n = Math.min(t.getLineMaxColumn(i), n)) : i > c ? (i = c, a ? n = t.getLineMaxColumn(i) : n = Math.min(t.getLineMaxColumn(i), n)) : n = e.columnFromVisibleColumn(t, i, d), g ? s = 0 : s = d - Hi.visibleColumnFromColumn(t.getLineContent(i), n, e.tabSize), l !== void 0) {
      const f = new A(i, n), m = t.normalizePosition(f, l);
      s = s + (n - m.column), i = m.lineNumber, n = m.column;
    }
    return new jD(i, n, s);
  }
  static down(e, t, i, n, s, o, a) {
    return this.vertical(
      e,
      t,
      i,
      n,
      s,
      i + o,
      a,
      4
      /* PositionAffinity.RightOfInjectedText */
    );
  }
  static moveDown(e, t, i, n, s) {
    let o, a;
    i.hasSelection() && !n ? (o = i.selection.endLineNumber, a = i.selection.endColumn) : (o = i.position.lineNumber, a = i.position.column);
    let l = 0, d;
    do
      if (d = wt.down(e, t, o + l, a, i.leftoverVisibleColumns, s, !0), t.normalizePosition(
        new A(d.lineNumber, d.column),
        2
        /* PositionAffinity.None */
      ).lineNumber > o)
        break;
    while (l++ < 10 && o + l < t.getLineCount());
    return i.move(n, d.lineNumber, d.column, d.leftoverVisibleColumns);
  }
  static translateDown(e, t, i) {
    const n = i.selection, s = wt.down(e, t, n.selectionStartLineNumber, n.selectionStartColumn, i.selectionStartLeftoverVisibleColumns, 1, !1), o = wt.down(e, t, n.positionLineNumber, n.positionColumn, i.leftoverVisibleColumns, 1, !1);
    return new un(new L(s.lineNumber, s.column, s.lineNumber, s.column), 0, s.leftoverVisibleColumns, new A(o.lineNumber, o.column), o.leftoverVisibleColumns);
  }
  static up(e, t, i, n, s, o, a) {
    return this.vertical(
      e,
      t,
      i,
      n,
      s,
      i - o,
      a,
      3
      /* PositionAffinity.LeftOfInjectedText */
    );
  }
  static moveUp(e, t, i, n, s) {
    let o, a;
    i.hasSelection() && !n ? (o = i.selection.startLineNumber, a = i.selection.startColumn) : (o = i.position.lineNumber, a = i.position.column);
    const l = wt.up(e, t, o, a, i.leftoverVisibleColumns, s, !0);
    return i.move(n, l.lineNumber, l.column, l.leftoverVisibleColumns);
  }
  static translateUp(e, t, i) {
    const n = i.selection, s = wt.up(e, t, n.selectionStartLineNumber, n.selectionStartColumn, i.selectionStartLeftoverVisibleColumns, 1, !1), o = wt.up(e, t, n.positionLineNumber, n.positionColumn, i.leftoverVisibleColumns, 1, !1);
    return new un(new L(s.lineNumber, s.column, s.lineNumber, s.column), 0, s.leftoverVisibleColumns, new A(o.lineNumber, o.column), o.leftoverVisibleColumns);
  }
  static _isBlankLine(e, t) {
    return e.getLineFirstNonWhitespaceColumn(t) === 0;
  }
  static moveToPrevBlankLine(e, t, i, n) {
    let s = i.position.lineNumber;
    for (; s > 1 && this._isBlankLine(t, s); )
      s--;
    for (; s > 1 && !this._isBlankLine(t, s); )
      s--;
    return i.move(n, s, t.getLineMinColumn(s), 0);
  }
  static moveToNextBlankLine(e, t, i, n) {
    const s = t.getLineCount();
    let o = i.position.lineNumber;
    for (; o < s && this._isBlankLine(t, o); )
      o++;
    for (; o < s && !this._isBlankLine(t, o); )
      o++;
    return i.move(n, o, t.getLineMinColumn(o), 0);
  }
  static moveToBeginningOfLine(e, t, i, n) {
    const s = i.position.lineNumber, o = t.getLineMinColumn(s), a = t.getLineFirstNonWhitespaceColumn(s) || o;
    let l;
    return i.position.column === a ? l = o : l = a, i.move(n, s, l, 0);
  }
  static moveToEndOfLine(e, t, i, n, s) {
    const o = i.position.lineNumber, a = t.getLineMaxColumn(o);
    return i.move(n, o, a, s ? 1073741824 - a : 0);
  }
  static moveToBeginningOfBuffer(e, t, i, n) {
    return i.move(n, 1, 1, 0);
  }
  static moveToEndOfBuffer(e, t, i, n) {
    const s = t.getLineCount(), o = t.getLineMaxColumn(s);
    return i.move(n, s, o, 0);
  }
}
class yu {
  static deleteRight(e, t, i, n) {
    const s = [];
    let o = e !== 3;
    for (let a = 0, l = n.length; a < l; a++) {
      const d = n[a];
      let c = d;
      if (c.isEmpty()) {
        const h = d.getPosition(), u = wt.right(t, i, h);
        c = new L(u.lineNumber, u.column, h.lineNumber, h.column);
      }
      if (c.isEmpty()) {
        s[a] = null;
        continue;
      }
      c.startLineNumber !== c.endLineNumber && (o = !0), s[a] = new Cn(c, "");
    }
    return [o, s];
  }
  static isAutoClosingPairDelete(e, t, i, n, s, o, a) {
    if (t === "never" && i === "never" || e === "never")
      return !1;
    for (let l = 0, d = o.length; l < d; l++) {
      const c = o[l], h = c.getPosition();
      if (!c.isEmpty())
        return !1;
      const u = s.getLineContent(h.lineNumber);
      if (h.column < 2 || h.column >= u.length + 1)
        return !1;
      const g = u.charAt(h.column - 2), f = n.get(g);
      if (!f)
        return !1;
      if (Pd(g)) {
        if (i === "never")
          return !1;
      } else if (t === "never")
        return !1;
      const m = u.charAt(h.column - 1);
      let _ = !1;
      for (const v of f)
        v.open === g && v.close === m && (_ = !0);
      if (!_)
        return !1;
      if (e === "auto") {
        let v = !1;
        for (let b = 0, C = a.length; b < C; b++) {
          const w = a[b];
          if (h.lineNumber === w.startLineNumber && h.column === w.startColumn) {
            v = !0;
            break;
          }
        }
        if (!v)
          return !1;
      }
    }
    return !0;
  }
  static _runAutoClosingPairDelete(e, t, i) {
    const n = [];
    for (let s = 0, o = i.length; s < o; s++) {
      const a = i[s].getPosition(), l = new L(a.lineNumber, a.column - 1, a.lineNumber, a.column + 1);
      n[s] = new Cn(l, "");
    }
    return [!0, n];
  }
  static deleteLeft(e, t, i, n, s) {
    if (this.isAutoClosingPairDelete(t.autoClosingDelete, t.autoClosingBrackets, t.autoClosingQuotes, t.autoClosingPairs.autoClosingPairsOpenByEnd, i, n, s))
      return this._runAutoClosingPairDelete(t, i, n);
    const o = [];
    let a = e !== 2;
    for (let l = 0, d = n.length; l < d; l++) {
      const c = yu.getDeleteRange(n[l], i, t);
      if (c.isEmpty()) {
        o[l] = null;
        continue;
      }
      c.startLineNumber !== c.endLineNumber && (a = !0), o[l] = new Cn(c, "");
    }
    return [a, o];
  }
  static getDeleteRange(e, t, i) {
    if (!e.isEmpty())
      return e;
    const n = e.getPosition();
    if (i.useTabStops && n.column > 1) {
      const s = t.getLineContent(n.lineNumber), o = ns(s), a = o === -1 ? (
        /* entire string is whitespace */
        s.length + 1
      ) : o + 1;
      if (n.column <= a) {
        const l = i.visibleColumnFromColumn(t, n), d = Hi.prevIndentTabStop(l, i.indentSize), c = i.columnFromVisibleColumn(t, n.lineNumber, d);
        return new L(n.lineNumber, c, n.lineNumber, n.column);
      }
    }
    return L.fromPositions(yu.getPositionAfterDeleteLeft(n, t), n);
  }
  static getPositionAfterDeleteLeft(e, t) {
    if (e.column > 1) {
      const i = p5(e.column - 1, t.getLineContent(e.lineNumber));
      return e.with(void 0, i + 1);
    } else if (e.lineNumber > 1) {
      const i = e.lineNumber - 1;
      return new A(i, t.getLineMaxColumn(i));
    } else
      return e;
  }
  static cut(e, t, i) {
    const n = [];
    let s = null;
    i.sort((o, a) => A.compare(o.getStartPosition(), a.getEndPosition()));
    for (let o = 0, a = i.length; o < a; o++) {
      const l = i[o];
      if (l.isEmpty())
        if (e.emptySelectionClipboard) {
          const d = l.getPosition();
          let c, h, u, g;
          d.lineNumber < t.getLineCount() ? (c = d.lineNumber, h = 1, u = d.lineNumber + 1, g = 1) : d.lineNumber > 1 && (s == null ? void 0 : s.endLineNumber) !== d.lineNumber ? (c = d.lineNumber - 1, h = t.getLineMaxColumn(d.lineNumber - 1), u = d.lineNumber, g = t.getLineMaxColumn(d.lineNumber)) : (c = d.lineNumber, h = 1, u = d.lineNumber, g = t.getLineMaxColumn(d.lineNumber));
          const f = new L(c, h, u, g);
          s = f, f.isEmpty() ? n[o] = null : n[o] = new Cn(f, "");
        } else
          n[o] = null;
      else
        n[o] = new Cn(l, "");
    }
    return new ps(0, n, {
      shouldPushStackElementBefore: !0,
      shouldPushStackElementAfter: !0
    });
  }
}
class vt {
  static _createWord(e, t, i, n, s) {
    return { start: n, end: s, wordType: t, nextCharClass: i };
  }
  static _createIntlWord(e, t) {
    return { start: e.index, end: e.index + e.segment.length, wordType: 1, nextCharClass: t };
  }
  static _findPreviousWordOnLine(e, t, i) {
    const n = t.getLineContent(i.lineNumber);
    return this._doFindPreviousWordOnLine(n, e, i);
  }
  static _doFindPreviousWordOnLine(e, t, i) {
    let n = 0;
    const s = t.findPrevIntlWordBeforeOrAtOffset(e, i.column - 2);
    for (let o = i.column - 2; o >= 0; o--) {
      const a = e.charCodeAt(o), l = t.get(a);
      if (s && o === s.index)
        return this._createIntlWord(s, l);
      if (l === 0) {
        if (n === 2)
          return this._createWord(e, n, l, o + 1, this._findEndOfWord(e, t, n, o + 1));
        n = 1;
      } else if (l === 2) {
        if (n === 1)
          return this._createWord(e, n, l, o + 1, this._findEndOfWord(e, t, n, o + 1));
        n = 2;
      } else if (l === 1 && n !== 0)
        return this._createWord(e, n, l, o + 1, this._findEndOfWord(e, t, n, o + 1));
    }
    return n !== 0 ? this._createWord(e, n, 1, 0, this._findEndOfWord(e, t, n, 0)) : null;
  }
  static _findEndOfWord(e, t, i, n) {
    const s = t.findNextIntlWordAtOrAfterOffset(e, n), o = e.length;
    for (let a = n; a < o; a++) {
      const l = e.charCodeAt(a), d = t.get(l);
      if (s && a === s.index + s.segment.length || d === 1 || i === 1 && d === 2 || i === 2 && d === 0)
        return a;
    }
    return o;
  }
  static _findNextWordOnLine(e, t, i) {
    const n = t.getLineContent(i.lineNumber);
    return this._doFindNextWordOnLine(n, e, i);
  }
  static _doFindNextWordOnLine(e, t, i) {
    let n = 0;
    const s = e.length, o = t.findNextIntlWordAtOrAfterOffset(e, i.column - 1);
    for (let a = i.column - 1; a < s; a++) {
      const l = e.charCodeAt(a), d = t.get(l);
      if (o && a === o.index)
        return this._createIntlWord(o, d);
      if (d === 0) {
        if (n === 2)
          return this._createWord(e, n, d, this._findStartOfWord(e, t, n, a - 1), a);
        n = 1;
      } else if (d === 2) {
        if (n === 1)
          return this._createWord(e, n, d, this._findStartOfWord(e, t, n, a - 1), a);
        n = 2;
      } else if (d === 1 && n !== 0)
        return this._createWord(e, n, d, this._findStartOfWord(e, t, n, a - 1), a);
    }
    return n !== 0 ? this._createWord(e, n, 1, this._findStartOfWord(e, t, n, s - 1), s) : null;
  }
  static _findStartOfWord(e, t, i, n) {
    const s = t.findPrevIntlWordBeforeOrAtOffset(e, n);
    for (let o = n; o >= 0; o--) {
      const a = e.charCodeAt(o), l = t.get(a);
      if (s && o === s.index)
        return o;
      if (l === 1 || i === 1 && l === 2 || i === 2 && l === 0)
        return o + 1;
    }
    return 0;
  }
  static moveWordLeft(e, t, i, n) {
    let s = i.lineNumber, o = i.column;
    o === 1 && s > 1 && (s = s - 1, o = t.getLineMaxColumn(s));
    let a = vt._findPreviousWordOnLine(e, t, new A(s, o));
    if (n === 0)
      return new A(s, a ? a.start + 1 : 1);
    if (n === 1)
      return a && a.wordType === 2 && a.end - a.start === 1 && a.nextCharClass === 0 && (a = vt._findPreviousWordOnLine(e, t, new A(s, a.start + 1))), new A(s, a ? a.start + 1 : 1);
    if (n === 3) {
      for (; a && a.wordType === 2; )
        a = vt._findPreviousWordOnLine(e, t, new A(s, a.start + 1));
      return new A(s, a ? a.start + 1 : 1);
    }
    return a && o <= a.end + 1 && (a = vt._findPreviousWordOnLine(e, t, new A(s, a.start + 1))), new A(s, a ? a.end + 1 : 1);
  }
  static _moveWordPartLeft(e, t) {
    const i = t.lineNumber, n = e.getLineMaxColumn(i);
    if (t.column === 1)
      return i > 1 ? new A(i - 1, e.getLineMaxColumn(i - 1)) : t;
    const s = e.getLineContent(i);
    for (let o = t.column - 1; o > 1; o--) {
      const a = s.charCodeAt(o - 2), l = s.charCodeAt(o - 1);
      if (a === 95 && l !== 95)
        return new A(i, o);
      if (a === 45 && l !== 45)
        return new A(i, o);
      if ((Bg(a) || Jb(a)) && Vd(l))
        return new A(i, o);
      if (Vd(a) && Vd(l) && o + 1 < n) {
        const d = s.charCodeAt(o);
        if (Bg(d) || Jb(d))
          return new A(i, o);
      }
    }
    return new A(i, 1);
  }
  static moveWordRight(e, t, i, n) {
    let s = i.lineNumber, o = i.column, a = !1;
    o === t.getLineMaxColumn(s) && s < t.getLineCount() && (a = !0, s = s + 1, o = 1);
    let l = vt._findNextWordOnLine(e, t, new A(s, o));
    if (n === 2)
      l && l.wordType === 2 && l.end - l.start === 1 && l.nextCharClass === 0 && (l = vt._findNextWordOnLine(e, t, new A(s, l.end + 1))), l ? o = l.end + 1 : o = t.getLineMaxColumn(s);
    else if (n === 3) {
      for (a && (o = 0); l && (l.wordType === 2 || l.start + 1 <= o); )
        l = vt._findNextWordOnLine(e, t, new A(s, l.end + 1));
      l ? o = l.start + 1 : o = t.getLineMaxColumn(s);
    } else
      l && !a && o >= l.start + 1 && (l = vt._findNextWordOnLine(e, t, new A(s, l.end + 1))), l ? o = l.start + 1 : o = t.getLineMaxColumn(s);
    return new A(s, o);
  }
  static _moveWordPartRight(e, t) {
    const i = t.lineNumber, n = e.getLineMaxColumn(i);
    if (t.column === n)
      return i < e.getLineCount() ? new A(i + 1, 1) : t;
    const s = e.getLineContent(i);
    for (let o = t.column + 1; o < n; o++) {
      const a = s.charCodeAt(o - 2), l = s.charCodeAt(o - 1);
      if (a !== 95 && l === 95)
        return new A(i, o);
      if (a !== 45 && l === 45)
        return new A(i, o);
      if ((Bg(a) || Jb(a)) && Vd(l))
        return new A(i, o);
      if (Vd(a) && Vd(l) && o + 1 < n) {
        const d = s.charCodeAt(o);
        if (Bg(d) || Jb(d))
          return new A(i, o);
      }
    }
    return new A(i, n);
  }
  static _deleteWordLeftWhitespace(e, t) {
    const i = e.getLineContent(t.lineNumber), n = t.column - 2, s = ja(i, n);
    return s + 1 < n ? new L(t.lineNumber, s + 2, t.lineNumber, t.column) : null;
  }
  static deleteWordLeft(e, t) {
    const i = e.wordSeparators, n = e.model, s = e.selection, o = e.whitespaceHeuristics;
    if (!s.isEmpty())
      return s;
    if (yu.isAutoClosingPairDelete(e.autoClosingDelete, e.autoClosingBrackets, e.autoClosingQuotes, e.autoClosingPairs.autoClosingPairsOpenByEnd, e.model, [e.selection], e.autoClosedCharacters)) {
      const h = e.selection.getPosition();
      return new L(h.lineNumber, h.column - 1, h.lineNumber, h.column + 1);
    }
    const a = new A(s.positionLineNumber, s.positionColumn);
    let l = a.lineNumber, d = a.column;
    if (l === 1 && d === 1)
      return null;
    if (o) {
      const h = this._deleteWordLeftWhitespace(n, a);
      if (h)
        return h;
    }
    let c = vt._findPreviousWordOnLine(i, n, a);
    return t === 0 ? c ? d = c.start + 1 : d > 1 ? d = 1 : (l--, d = n.getLineMaxColumn(l)) : (c && d <= c.end + 1 && (c = vt._findPreviousWordOnLine(i, n, new A(l, c.start + 1))), c ? d = c.end + 1 : d > 1 ? d = 1 : (l--, d = n.getLineMaxColumn(l))), new L(l, d, a.lineNumber, a.column);
  }
  static deleteInsideWord(e, t, i) {
    if (!i.isEmpty())
      return i;
    const n = new A(i.positionLineNumber, i.positionColumn), s = this._deleteInsideWordWhitespace(t, n);
    return s || this._deleteInsideWordDetermineDeleteRange(e, t, n);
  }
  static _charAtIsWhitespace(e, t) {
    const i = e.charCodeAt(t);
    return i === 32 || i === 9;
  }
  static _deleteInsideWordWhitespace(e, t) {
    const i = e.getLineContent(t.lineNumber), n = i.length;
    if (n === 0)
      return null;
    let s = Math.max(t.column - 2, 0);
    if (!this._charAtIsWhitespace(i, s))
      return null;
    let o = Math.min(t.column - 1, n - 1);
    if (!this._charAtIsWhitespace(i, o))
      return null;
    for (; s > 0 && this._charAtIsWhitespace(i, s - 1); )
      s--;
    for (; o + 1 < n && this._charAtIsWhitespace(i, o + 1); )
      o++;
    return new L(t.lineNumber, s + 1, t.lineNumber, o + 2);
  }
  static _deleteInsideWordDetermineDeleteRange(e, t, i) {
    const n = t.getLineContent(i.lineNumber), s = n.length;
    if (s === 0)
      return i.lineNumber > 1 ? new L(i.lineNumber - 1, t.getLineMaxColumn(i.lineNumber - 1), i.lineNumber, 1) : i.lineNumber < t.getLineCount() ? new L(i.lineNumber, 1, i.lineNumber + 1, 1) : new L(i.lineNumber, 1, i.lineNumber, 1);
    const o = (h) => h.start + 1 <= i.column && i.column <= h.end + 1, a = (h, u) => (h = Math.min(h, i.column), u = Math.max(u, i.column), new L(i.lineNumber, h, i.lineNumber, u)), l = (h) => {
      let u = h.start + 1, g = h.end + 1, f = !1;
      for (; g - 1 < s && this._charAtIsWhitespace(n, g - 1); )
        f = !0, g++;
      if (!f)
        for (; u > 1 && this._charAtIsWhitespace(n, u - 2); )
          u--;
      return a(u, g);
    }, d = vt._findPreviousWordOnLine(e, t, i);
    if (d && o(d))
      return l(d);
    const c = vt._findNextWordOnLine(e, t, i);
    return c && o(c) ? l(c) : d && c ? a(d.end + 1, c.start + 1) : d ? a(d.start + 1, d.end + 1) : c ? a(c.start + 1, c.end + 1) : a(1, s + 1);
  }
  static _deleteWordPartLeft(e, t) {
    if (!t.isEmpty())
      return t;
    const i = t.getPosition(), n = vt._moveWordPartLeft(e, i);
    return new L(i.lineNumber, i.column, n.lineNumber, n.column);
  }
  static _findFirstNonWhitespaceChar(e, t) {
    const i = e.length;
    for (let n = t; n < i; n++) {
      const s = e.charAt(n);
      if (s !== " " && s !== "	")
        return n;
    }
    return i;
  }
  static _deleteWordRightWhitespace(e, t) {
    const i = e.getLineContent(t.lineNumber), n = t.column - 1, s = this._findFirstNonWhitespaceChar(i, n);
    return n + 1 < s ? new L(t.lineNumber, t.column, t.lineNumber, s + 1) : null;
  }
  static deleteWordRight(e, t) {
    const i = e.wordSeparators, n = e.model, s = e.selection, o = e.whitespaceHeuristics;
    if (!s.isEmpty())
      return s;
    const a = new A(s.positionLineNumber, s.positionColumn);
    let l = a.lineNumber, d = a.column;
    const c = n.getLineCount(), h = n.getLineMaxColumn(l);
    if (l === c && d === h)
      return null;
    if (o) {
      const g = this._deleteWordRightWhitespace(n, a);
      if (g)
        return g;
    }
    let u = vt._findNextWordOnLine(i, n, a);
    return t === 2 ? u ? d = u.end + 1 : d < h || l === c ? d = h : (l++, u = vt._findNextWordOnLine(i, n, new A(l, 1)), u ? d = u.start + 1 : d = n.getLineMaxColumn(l)) : (u && d >= u.start + 1 && (u = vt._findNextWordOnLine(i, n, new A(l, u.end + 1))), u ? d = u.start + 1 : d < h || l === c ? d = h : (l++, u = vt._findNextWordOnLine(i, n, new A(l, 1)), u ? d = u.start + 1 : d = n.getLineMaxColumn(l))), new L(l, d, a.lineNumber, a.column);
  }
  static _deleteWordPartRight(e, t) {
    if (!t.isEmpty())
      return t;
    const i = t.getPosition(), n = vt._moveWordPartRight(e, i);
    return new L(i.lineNumber, i.column, n.lineNumber, n.column);
  }
  static _createWordAtPosition(e, t, i) {
    const n = new L(t, i.start + 1, t, i.end + 1);
    return {
      word: e.getValueInRange(n),
      startColumn: n.startColumn,
      endColumn: n.endColumn
    };
  }
  static getWordAtPosition(e, t, i, n) {
    const s = fr(t, i), o = vt._findPreviousWordOnLine(s, e, n);
    if (o && o.wordType === 1 && o.start <= n.column - 1 && n.column - 1 <= o.end)
      return vt._createWordAtPosition(e, n.lineNumber, o);
    const a = vt._findNextWordOnLine(s, e, n);
    return a && a.wordType === 1 && a.start <= n.column - 1 && n.column - 1 <= a.end ? vt._createWordAtPosition(e, n.lineNumber, a) : null;
  }
  static word(e, t, i, n, s) {
    const o = fr(e.wordSeparators, e.wordSegmenterLocales), a = vt._findPreviousWordOnLine(o, t, s), l = vt._findNextWordOnLine(o, t, s);
    if (!n) {
      let g, f;
      return a && a.wordType === 1 && a.start <= s.column - 1 && s.column - 1 <= a.end ? (g = a.start + 1, f = a.end + 1) : l && l.wordType === 1 && l.start <= s.column - 1 && s.column - 1 <= l.end ? (g = l.start + 1, f = l.end + 1) : (a ? g = a.end + 1 : g = 1, l ? f = l.start + 1 : f = t.getLineMaxColumn(s.lineNumber)), new un(new L(s.lineNumber, g, s.lineNumber, f), 1, 0, new A(s.lineNumber, f), 0);
    }
    let d, c;
    a && a.wordType === 1 && a.start < s.column - 1 && s.column - 1 < a.end ? (d = a.start + 1, c = a.end + 1) : l && l.wordType === 1 && l.start < s.column - 1 && s.column - 1 < l.end ? (d = l.start + 1, c = l.end + 1) : (d = s.column, c = s.column);
    const h = s.lineNumber;
    let u;
    if (i.selectionStart.containsPosition(s))
      u = i.selectionStart.endColumn;
    else if (s.isBeforeOrEqual(i.selectionStart.getStartPosition())) {
      u = d;
      const g = new A(h, u);
      i.selectionStart.containsPosition(g) && (u = i.selectionStart.endColumn);
    } else {
      u = c;
      const g = new A(h, u);
      i.selectionStart.containsPosition(g) && (u = i.selectionStart.startColumn);
    }
    return i.move(!0, h, u, 0);
  }
}
class T0 extends vt {
  static deleteWordPartLeft(e) {
    const t = _C([
      vt.deleteWordLeft(
        e,
        0
        /* WordNavigationType.WordStart */
      ),
      vt.deleteWordLeft(
        e,
        2
        /* WordNavigationType.WordEnd */
      ),
      vt._deleteWordPartLeft(e.model, e.selection)
    ]);
    return t.sort(L.compareRangesUsingEnds), t[2];
  }
  static deleteWordPartRight(e) {
    const t = _C([
      vt.deleteWordRight(
        e,
        0
        /* WordNavigationType.WordStart */
      ),
      vt.deleteWordRight(
        e,
        2
        /* WordNavigationType.WordEnd */
      ),
      vt._deleteWordPartRight(e.model, e.selection)
    ]);
    return t.sort(L.compareRangesUsingStarts), t[0];
  }
  static moveWordPartLeft(e, t, i) {
    const n = _C([
      vt.moveWordLeft(
        e,
        t,
        i,
        0
        /* WordNavigationType.WordStart */
      ),
      vt.moveWordLeft(
        e,
        t,
        i,
        2
        /* WordNavigationType.WordEnd */
      ),
      vt._moveWordPartLeft(t, i)
    ]);
    return n.sort(A.compare), n[2];
  }
  static moveWordPartRight(e, t, i) {
    const n = _C([
      vt.moveWordRight(
        e,
        t,
        i,
        0
        /* WordNavigationType.WordStart */
      ),
      vt.moveWordRight(
        e,
        t,
        i,
        2
        /* WordNavigationType.WordEnd */
      ),
      vt._moveWordPartRight(t, i)
    ]);
    return n.sort(A.compare), n[0];
  }
}
function _C(r) {
  return r.filter((e) => !!e);
}
class cn {
  static addCursorDown(e, t, i) {
    const n = [];
    let s = 0;
    for (let o = 0, a = t.length; o < a; o++) {
      const l = t[o];
      n[s++] = new dt(l.modelState, l.viewState), i ? n[s++] = dt.fromModelState(wt.translateDown(e.cursorConfig, e.model, l.modelState)) : n[s++] = dt.fromViewState(wt.translateDown(e.cursorConfig, e, l.viewState));
    }
    return n;
  }
  static addCursorUp(e, t, i) {
    const n = [];
    let s = 0;
    for (let o = 0, a = t.length; o < a; o++) {
      const l = t[o];
      n[s++] = new dt(l.modelState, l.viewState), i ? n[s++] = dt.fromModelState(wt.translateUp(e.cursorConfig, e.model, l.modelState)) : n[s++] = dt.fromViewState(wt.translateUp(e.cursorConfig, e, l.viewState));
    }
    return n;
  }
  static moveToBeginningOfLine(e, t, i) {
    const n = [];
    for (let s = 0, o = t.length; s < o; s++) {
      const a = t[s];
      n[s] = this._moveToLineStart(e, a, i);
    }
    return n;
  }
  static _moveToLineStart(e, t, i) {
    const n = t.viewState.position.column, s = t.modelState.position.column, o = n === s, a = t.viewState.position.lineNumber, l = e.getLineFirstNonWhitespaceColumn(a);
    return !o && !(n === l) ? this._moveToLineStartByView(e, t, i) : this._moveToLineStartByModel(e, t, i);
  }
  static _moveToLineStartByView(e, t, i) {
    return dt.fromViewState(wt.moveToBeginningOfLine(e.cursorConfig, e, t.viewState, i));
  }
  static _moveToLineStartByModel(e, t, i) {
    return dt.fromModelState(wt.moveToBeginningOfLine(e.cursorConfig, e.model, t.modelState, i));
  }
  static moveToEndOfLine(e, t, i, n) {
    const s = [];
    for (let o = 0, a = t.length; o < a; o++) {
      const l = t[o];
      s[o] = this._moveToLineEnd(e, l, i, n);
    }
    return s;
  }
  static _moveToLineEnd(e, t, i, n) {
    const s = t.viewState.position, o = e.getLineMaxColumn(s.lineNumber), a = s.column === o, l = t.modelState.position, d = e.model.getLineMaxColumn(l.lineNumber), c = o - s.column === d - l.column;
    return a || c ? this._moveToLineEndByModel(e, t, i, n) : this._moveToLineEndByView(e, t, i, n);
  }
  static _moveToLineEndByView(e, t, i, n) {
    return dt.fromViewState(wt.moveToEndOfLine(e.cursorConfig, e, t.viewState, i, n));
  }
  static _moveToLineEndByModel(e, t, i, n) {
    return dt.fromModelState(wt.moveToEndOfLine(e.cursorConfig, e.model, t.modelState, i, n));
  }
  static expandLineSelection(e, t) {
    const i = [];
    for (let n = 0, s = t.length; n < s; n++) {
      const o = t[n], a = o.modelState.selection.startLineNumber, l = e.model.getLineCount();
      let d = o.modelState.selection.endLineNumber, c;
      d === l ? c = e.model.getLineMaxColumn(l) : (d++, c = 1), i[n] = dt.fromModelState(new un(new L(a, 1, a, 1), 0, 0, new A(d, c), 0));
    }
    return i;
  }
  static moveToBeginningOfBuffer(e, t, i) {
    const n = [];
    for (let s = 0, o = t.length; s < o; s++) {
      const a = t[s];
      n[s] = dt.fromModelState(wt.moveToBeginningOfBuffer(e.cursorConfig, e.model, a.modelState, i));
    }
    return n;
  }
  static moveToEndOfBuffer(e, t, i) {
    const n = [];
    for (let s = 0, o = t.length; s < o; s++) {
      const a = t[s];
      n[s] = dt.fromModelState(wt.moveToEndOfBuffer(e.cursorConfig, e.model, a.modelState, i));
    }
    return n;
  }
  static selectAll(e, t) {
    const i = e.model.getLineCount(), n = e.model.getLineMaxColumn(i);
    return dt.fromModelState(new un(new L(1, 1, 1, 1), 0, 0, new A(i, n), 0));
  }
  static line(e, t, i, n, s) {
    const o = e.model.validatePosition(n), a = s ? e.coordinatesConverter.validateViewPosition(new A(s.lineNumber, s.column), o) : e.coordinatesConverter.convertModelPositionToViewPosition(o);
    if (!i) {
      const d = e.model.getLineCount();
      let c = o.lineNumber + 1, h = 1;
      return c > d && (c = d, h = e.model.getLineMaxColumn(c)), dt.fromModelState(new un(new L(o.lineNumber, 1, c, h), 2, 0, new A(c, h), 0));
    }
    const l = t.modelState.selectionStart.getStartPosition().lineNumber;
    if (o.lineNumber < l)
      return dt.fromViewState(t.viewState.move(!0, a.lineNumber, 1, 0));
    if (o.lineNumber > l) {
      const d = e.getLineCount();
      let c = a.lineNumber + 1, h = 1;
      return c > d && (c = d, h = e.getLineMaxColumn(c)), dt.fromViewState(t.viewState.move(!0, c, h, 0));
    } else {
      const d = t.modelState.selectionStart.getEndPosition();
      return dt.fromModelState(t.modelState.move(!0, d.lineNumber, d.column, 0));
    }
  }
  static word(e, t, i, n) {
    const s = e.model.validatePosition(n);
    return dt.fromModelState(vt.word(e.cursorConfig, e.model, t.modelState, i, s));
  }
  static cancelSelection(e, t) {
    if (!t.modelState.hasSelection())
      return new dt(t.modelState, t.viewState);
    const i = t.viewState.position.lineNumber, n = t.viewState.position.column;
    return dt.fromViewState(new un(new L(i, n, i, n), 0, 0, new A(i, n), 0));
  }
  static moveTo(e, t, i, n, s) {
    if (i) {
      if (t.modelState.selectionStartKind === 1)
        return this.word(e, t, i, n);
      if (t.modelState.selectionStartKind === 2)
        return this.line(e, t, i, n, s);
    }
    const o = e.model.validatePosition(n), a = s ? e.coordinatesConverter.validateViewPosition(new A(s.lineNumber, s.column), o) : e.coordinatesConverter.convertModelPositionToViewPosition(o);
    return dt.fromViewState(t.viewState.move(i, a.lineNumber, a.column, 0));
  }
  static simpleMove(e, t, i, n, s, o) {
    switch (i) {
      case 0:
        return o === 4 ? this._moveHalfLineLeft(e, t, n) : this._moveLeft(e, t, n, s);
      case 1:
        return o === 4 ? this._moveHalfLineRight(e, t, n) : this._moveRight(e, t, n, s);
      case 2:
        return o === 2 ? this._moveUpByViewLines(e, t, n, s) : this._moveUpByModelLines(e, t, n, s);
      case 3:
        return o === 2 ? this._moveDownByViewLines(e, t, n, s) : this._moveDownByModelLines(e, t, n, s);
      case 4:
        return o === 2 ? t.map((a) => dt.fromViewState(wt.moveToPrevBlankLine(e.cursorConfig, e, a.viewState, n))) : t.map((a) => dt.fromModelState(wt.moveToPrevBlankLine(e.cursorConfig, e.model, a.modelState, n)));
      case 5:
        return o === 2 ? t.map((a) => dt.fromViewState(wt.moveToNextBlankLine(e.cursorConfig, e, a.viewState, n))) : t.map((a) => dt.fromModelState(wt.moveToNextBlankLine(e.cursorConfig, e.model, a.modelState, n)));
      case 6:
        return this._moveToViewMinColumn(e, t, n);
      case 7:
        return this._moveToViewFirstNonWhitespaceColumn(e, t, n);
      case 8:
        return this._moveToViewCenterColumn(e, t, n);
      case 9:
        return this._moveToViewMaxColumn(e, t, n);
      case 10:
        return this._moveToViewLastNonWhitespaceColumn(e, t, n);
      default:
        return null;
    }
  }
  static viewportMove(e, t, i, n, s) {
    const o = e.getCompletelyVisibleViewRange(), a = e.coordinatesConverter.convertViewRangeToModelRange(o);
    switch (i) {
      case 11: {
        const l = this._firstLineNumberInRange(e.model, a, s), d = e.model.getLineFirstNonWhitespaceColumn(l);
        return [this._moveToModelPosition(e, t[0], n, l, d)];
      }
      case 13: {
        const l = this._lastLineNumberInRange(e.model, a, s), d = e.model.getLineFirstNonWhitespaceColumn(l);
        return [this._moveToModelPosition(e, t[0], n, l, d)];
      }
      case 12: {
        const l = Math.round((a.startLineNumber + a.endLineNumber) / 2), d = e.model.getLineFirstNonWhitespaceColumn(l);
        return [this._moveToModelPosition(e, t[0], n, l, d)];
      }
      case 14: {
        const l = [];
        for (let d = 0, c = t.length; d < c; d++) {
          const h = t[d];
          l[d] = this.findPositionInViewportIfOutside(e, h, o, n);
        }
        return l;
      }
      default:
        return null;
    }
  }
  static findPositionInViewportIfOutside(e, t, i, n) {
    const s = t.viewState.position.lineNumber;
    if (i.startLineNumber <= s && s <= i.endLineNumber - 1)
      return new dt(t.modelState, t.viewState);
    {
      let o;
      s > i.endLineNumber - 1 ? o = i.endLineNumber - 1 : s < i.startLineNumber ? o = i.startLineNumber : o = s;
      const a = wt.vertical(e.cursorConfig, e, s, t.viewState.position.column, t.viewState.leftoverVisibleColumns, o, !1);
      return dt.fromViewState(t.viewState.move(n, a.lineNumber, a.column, a.leftoverVisibleColumns));
    }
  }
  /**
   * Find the nth line start included in the range (from the start).
   */
  static _firstLineNumberInRange(e, t, i) {
    let n = t.startLineNumber;
    return t.startColumn !== e.getLineMinColumn(n) && n++, Math.min(t.endLineNumber, n + i - 1);
  }
  /**
   * Find the nth line start included in the range (from the end).
   */
  static _lastLineNumberInRange(e, t, i) {
    let n = t.startLineNumber;
    return t.startColumn !== e.getLineMinColumn(n) && n++, Math.max(n, t.endLineNumber - i + 1);
  }
  static _moveLeft(e, t, i, n) {
    return t.map((s) => dt.fromViewState(wt.moveLeft(e.cursorConfig, e, s.viewState, i, n)));
  }
  static _moveHalfLineLeft(e, t, i) {
    const n = [];
    for (let s = 0, o = t.length; s < o; s++) {
      const a = t[s], l = a.viewState.position.lineNumber, d = Math.round(e.getLineLength(l) / 2);
      n[s] = dt.fromViewState(wt.moveLeft(e.cursorConfig, e, a.viewState, i, d));
    }
    return n;
  }
  static _moveRight(e, t, i, n) {
    return t.map((s) => dt.fromViewState(wt.moveRight(e.cursorConfig, e, s.viewState, i, n)));
  }
  static _moveHalfLineRight(e, t, i) {
    const n = [];
    for (let s = 0, o = t.length; s < o; s++) {
      const a = t[s], l = a.viewState.position.lineNumber, d = Math.round(e.getLineLength(l) / 2);
      n[s] = dt.fromViewState(wt.moveRight(e.cursorConfig, e, a.viewState, i, d));
    }
    return n;
  }
  static _moveDownByViewLines(e, t, i, n) {
    const s = [];
    for (let o = 0, a = t.length; o < a; o++) {
      const l = t[o];
      s[o] = dt.fromViewState(wt.moveDown(e.cursorConfig, e, l.viewState, i, n));
    }
    return s;
  }
  static _moveDownByModelLines(e, t, i, n) {
    const s = [];
    for (let o = 0, a = t.length; o < a; o++) {
      const l = t[o];
      s[o] = dt.fromModelState(wt.moveDown(e.cursorConfig, e.model, l.modelState, i, n));
    }
    return s;
  }
  static _moveUpByViewLines(e, t, i, n) {
    const s = [];
    for (let o = 0, a = t.length; o < a; o++) {
      const l = t[o];
      s[o] = dt.fromViewState(wt.moveUp(e.cursorConfig, e, l.viewState, i, n));
    }
    return s;
  }
  static _moveUpByModelLines(e, t, i, n) {
    const s = [];
    for (let o = 0, a = t.length; o < a; o++) {
      const l = t[o];
      s[o] = dt.fromModelState(wt.moveUp(e.cursorConfig, e.model, l.modelState, i, n));
    }
    return s;
  }
  static _moveToViewPosition(e, t, i, n, s) {
    return dt.fromViewState(t.viewState.move(i, n, s, 0));
  }
  static _moveToModelPosition(e, t, i, n, s) {
    return dt.fromModelState(t.modelState.move(i, n, s, 0));
  }
  static _moveToViewMinColumn(e, t, i) {
    const n = [];
    for (let s = 0, o = t.length; s < o; s++) {
      const a = t[s], l = a.viewState.position.lineNumber, d = e.getLineMinColumn(l);
      n[s] = this._moveToViewPosition(e, a, i, l, d);
    }
    return n;
  }
  static _moveToViewFirstNonWhitespaceColumn(e, t, i) {
    const n = [];
    for (let s = 0, o = t.length; s < o; s++) {
      const a = t[s], l = a.viewState.position.lineNumber, d = e.getLineFirstNonWhitespaceColumn(l);
      n[s] = this._moveToViewPosition(e, a, i, l, d);
    }
    return n;
  }
  static _moveToViewCenterColumn(e, t, i) {
    const n = [];
    for (let s = 0, o = t.length; s < o; s++) {
      const a = t[s], l = a.viewState.position.lineNumber, d = Math.round((e.getLineMaxColumn(l) + e.getLineMinColumn(l)) / 2);
      n[s] = this._moveToViewPosition(e, a, i, l, d);
    }
    return n;
  }
  static _moveToViewMaxColumn(e, t, i) {
    const n = [];
    for (let s = 0, o = t.length; s < o; s++) {
      const a = t[s], l = a.viewState.position.lineNumber, d = e.getLineMaxColumn(l);
      n[s] = this._moveToViewPosition(e, a, i, l, d);
    }
    return n;
  }
  static _moveToViewLastNonWhitespaceColumn(e, t, i) {
    const n = [];
    for (let s = 0, o = t.length; s < o; s++) {
      const a = t[s], l = a.viewState.position.lineNumber, d = e.getLineLastNonWhitespaceColumn(l);
      n[s] = this._moveToViewPosition(e, a, i, l, d);
    }
    return n;
  }
}
var LS;
(function(r) {
  const e = function(i) {
    if (!ur(i))
      return !1;
    const n = i;
    return !(!Ws(n.to) || !Fs(n.select) && !ZB(n.select) || !Fs(n.by) && !Ws(n.by) || !Fs(n.value) && !Ic(n.value));
  };
  r.metadata = {
    description: "Move cursor to a logical position in the view",
    args: [
      {
        name: "Cursor move argument object",
        description: `Property-value pairs that can be passed through this argument:
					* 'to': A mandatory logical position value providing where to move the cursor.
						\`\`\`
						'left', 'right', 'up', 'down', 'prevBlankLine', 'nextBlankLine',
						'wrappedLineStart', 'wrappedLineEnd', 'wrappedLineColumnCenter'
						'wrappedLineFirstNonWhitespaceCharacter', 'wrappedLineLastNonWhitespaceCharacter'
						'viewPortTop', 'viewPortCenter', 'viewPortBottom', 'viewPortIfOutside'
						\`\`\`
					* 'by': Unit to move. Default is computed based on 'to' value.
						\`\`\`
						'line', 'wrappedLine', 'character', 'halfLine'
						\`\`\`
					* 'value': Number of units to move. Default is '1'.
					* 'select': If 'true' makes the selection. Default is 'false'.
				`,
        constraint: e,
        schema: {
          type: "object",
          required: ["to"],
          properties: {
            to: {
              type: "string",
              enum: ["left", "right", "up", "down", "prevBlankLine", "nextBlankLine", "wrappedLineStart", "wrappedLineEnd", "wrappedLineColumnCenter", "wrappedLineFirstNonWhitespaceCharacter", "wrappedLineLastNonWhitespaceCharacter", "viewPortTop", "viewPortCenter", "viewPortBottom", "viewPortIfOutside"]
            },
            by: {
              type: "string",
              enum: ["line", "wrappedLine", "character", "halfLine"]
            },
            value: {
              type: "number",
              default: 1
            },
            select: {
              type: "boolean",
              default: !1
            }
          }
        }
      }
    ]
  }, r.RawDirection = {
    Left: "left",
    Right: "right",
    Up: "up",
    Down: "down",
    PrevBlankLine: "prevBlankLine",
    NextBlankLine: "nextBlankLine",
    WrappedLineStart: "wrappedLineStart",
    WrappedLineFirstNonWhitespaceCharacter: "wrappedLineFirstNonWhitespaceCharacter",
    WrappedLineColumnCenter: "wrappedLineColumnCenter",
    WrappedLineEnd: "wrappedLineEnd",
    WrappedLineLastNonWhitespaceCharacter: "wrappedLineLastNonWhitespaceCharacter",
    ViewPortTop: "viewPortTop",
    ViewPortCenter: "viewPortCenter",
    ViewPortBottom: "viewPortBottom",
    ViewPortIfOutside: "viewPortIfOutside"
  }, r.RawUnit = {
    Line: "line",
    WrappedLine: "wrappedLine",
    Character: "character",
    HalfLine: "halfLine"
  };
  function t(i) {
    if (!i.to)
      return null;
    let n;
    switch (i.to) {
      case r.RawDirection.Left:
        n = 0;
        break;
      case r.RawDirection.Right:
        n = 1;
        break;
      case r.RawDirection.Up:
        n = 2;
        break;
      case r.RawDirection.Down:
        n = 3;
        break;
      case r.RawDirection.PrevBlankLine:
        n = 4;
        break;
      case r.RawDirection.NextBlankLine:
        n = 5;
        break;
      case r.RawDirection.WrappedLineStart:
        n = 6;
        break;
      case r.RawDirection.WrappedLineFirstNonWhitespaceCharacter:
        n = 7;
        break;
      case r.RawDirection.WrappedLineColumnCenter:
        n = 8;
        break;
      case r.RawDirection.WrappedLineEnd:
        n = 9;
        break;
      case r.RawDirection.WrappedLineLastNonWhitespaceCharacter:
        n = 10;
        break;
      case r.RawDirection.ViewPortTop:
        n = 11;
        break;
      case r.RawDirection.ViewPortBottom:
        n = 13;
        break;
      case r.RawDirection.ViewPortCenter:
        n = 12;
        break;
      case r.RawDirection.ViewPortIfOutside:
        n = 14;
        break;
      default:
        return null;
    }
    let s = 0;
    switch (i.by) {
      case r.RawUnit.Line:
        s = 1;
        break;
      case r.RawUnit.WrappedLine:
        s = 2;
        break;
      case r.RawUnit.Character:
        s = 3;
        break;
      case r.RawUnit.HalfLine:
        s = 4;
        break;
    }
    return {
      direction: n,
      unit: s,
      select: !!i.select,
      value: i.value || 1
    };
  }
  r.parse = t;
})(LS || (LS = {}));
class T1 {
  constructor(e, t, i) {
    this._indentRulesSupport = t, this._indentationLineProcessor = new i2(e, i);
  }
  /**
   * Apply the new indentation and return whether the indentation level should be increased after the given line number
   */
  shouldIncrease(e, t) {
    const i = this._indentationLineProcessor.getProcessedLine(e, t);
    return this._indentRulesSupport.shouldIncrease(i);
  }
  /**
   * Apply the new indentation and return whether the indentation level should be decreased after the given line number
   */
  shouldDecrease(e, t) {
    const i = this._indentationLineProcessor.getProcessedLine(e, t);
    return this._indentRulesSupport.shouldDecrease(i);
  }
  /**
   * Apply the new indentation and return whether the indentation level should remain unchanged at the given line number
   */
  shouldIgnore(e, t) {
    const i = this._indentationLineProcessor.getProcessedLine(e, t);
    return this._indentRulesSupport.shouldIgnore(i);
  }
  /**
   * Apply the new indentation and return whether the indentation level should increase on the line after the given line number
   */
  shouldIndentNextLine(e, t) {
    const i = this._indentationLineProcessor.getProcessedLine(e, t);
    return this._indentRulesSupport.shouldIndentNextLine(i);
  }
}
class N1 {
  constructor(e, t) {
    this.model = e, this.indentationLineProcessor = new i2(e, t);
  }
  /**
   * Returns the processed text, stripped from the language configuration brackets within the string, comment and regex tokens, around the given range
   */
  getProcessedTokenContextAroundRange(e) {
    const t = this._getProcessedTokensBeforeRange(e), i = this._getProcessedTokensAfterRange(e), n = this._getProcessedPreviousLineTokens(e);
    return { beforeRangeProcessedTokens: t, afterRangeProcessedTokens: i, previousLineProcessedTokens: n };
  }
  _getProcessedTokensBeforeRange(e) {
    this.model.tokenization.forceTokenization(e.startLineNumber);
    const t = this.model.tokenization.getLineTokens(e.startLineNumber), i = qh(t, e.startColumn - 1);
    let n;
    if (M1(this.model, e.getStartPosition())) {
      const o = e.startColumn - 1 - i.firstCharOffset, a = i.firstCharOffset, l = a + o;
      n = t.sliceAndInflate(a, l, 0);
    } else {
      const o = e.startColumn - 1;
      n = t.sliceAndInflate(0, o, 0);
    }
    return this.indentationLineProcessor.getProcessedTokens(n);
  }
  _getProcessedTokensAfterRange(e) {
    const t = e.isEmpty() ? e.getStartPosition() : e.getEndPosition();
    this.model.tokenization.forceTokenization(t.lineNumber);
    const i = this.model.tokenization.getLineTokens(t.lineNumber), n = qh(i, t.column - 1), s = t.column - 1 - n.firstCharOffset, o = n.firstCharOffset + s, a = n.firstCharOffset + n.getLineLength(), l = i.sliceAndInflate(o, a, 0);
    return this.indentationLineProcessor.getProcessedTokens(l);
  }
  _getProcessedPreviousLineTokens(e) {
    const t = (g) => {
      this.model.tokenization.forceTokenization(g);
      const f = this.model.tokenization.getLineTokens(g), m = this.model.getLineMaxColumn(g) - 1;
      return qh(f, m);
    };
    this.model.tokenization.forceTokenization(e.startLineNumber);
    const i = this.model.tokenization.getLineTokens(e.startLineNumber), n = qh(i, e.startColumn - 1), s = Ri.createEmpty("", n.languageIdCodec), o = e.startLineNumber - 1;
    if (o === 0 || !(n.firstCharOffset === 0))
      return s;
    const d = t(o);
    if (!(n.languageId === d.languageId))
      return s;
    const h = d.toIViewLineTokens();
    return this.indentationLineProcessor.getProcessedTokens(h);
  }
}
class i2 {
  constructor(e, t) {
    this.model = e, this.languageConfigurationService = t;
  }
  /**
   * Get the processed line for the given line number and potentially adjust the indentation level.
   * Remove the language configuration brackets from the regex, string and comment tokens.
   */
  getProcessedLine(e, t) {
    var i, n;
    const s = (l, d) => {
      const c = Tt(l);
      return d + l.substring(c.length);
    };
    (n = (i = this.model.tokenization).forceTokenization) === null || n === void 0 || n.call(i, e);
    const o = this.model.tokenization.getLineTokens(e);
    let a = this.getProcessedTokens(o).getLineContent();
    return t !== void 0 && (a = s(a, t)), a;
  }
  /**
   * Process the line with the given tokens, remove the language configuration brackets from the regex, string and comment tokens.
   */
  getProcessedTokens(e) {
    const t = (l) => l === 2 || l === 3 || l === 1, i = e.getLanguageId(0), s = this.languageConfigurationService.getLanguageConfiguration(i).bracketsNew.getBracketRegExp({ global: !0 }), o = [];
    return e.forEach((l) => {
      const d = e.getStandardTokenType(l);
      let c = e.getTokenText(l);
      t(d) && (c = c.replace(s, ""));
      const h = e.getMetadata(l);
      o.push({ text: c, metadata: h });
    }), Ri.createFromTextAndMetadata(o, e.languageIdCodec);
  }
}
function M1(r, e) {
  r.tokenization.forceTokenization(e.lineNumber);
  const t = r.tokenization.getLineTokens(e.lineNumber), i = qh(t, e.column - 1), n = i.firstCharOffset === 0, s = t.getLanguageId(0) === i.languageId;
  return !n && !s;
}
function bf(r, e, t, i) {
  e.tokenization.forceTokenization(t.startLineNumber);
  const n = e.getLanguageIdAtPosition(t.startLineNumber, t.startColumn), s = i.getLanguageConfiguration(n);
  if (!s)
    return null;
  const a = new N1(e, i).getProcessedTokenContextAroundRange(t), l = a.previousLineProcessedTokens.getLineContent(), d = a.beforeRangeProcessedTokens.getLineContent(), c = a.afterRangeProcessedTokens.getLineContent(), h = s.onEnter(r, l, d, c);
  if (!h)
    return null;
  const u = h.indentAction;
  let g = h.appendText;
  const f = h.removeText || 0;
  g ? u === Mi.Indent && (g = "	" + g) : u === Mi.Indent || u === Mi.IndentOutdent ? g = "	" : g = "";
  let m = pV(e, t.startLineNumber, t.startColumn);
  return f && (m = m.substring(0, m.length - f)), {
    indentAction: u,
    appendText: g,
    removeText: f,
    indentation: m
  };
}
var SZ = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, yZ = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, Aw;
const qD = /* @__PURE__ */ Object.create(null);
function _h(r, e) {
  if (e <= 0)
    return "";
  qD[r] || (qD[r] = ["", r]);
  const t = qD[r];
  for (let i = t.length; i <= e; i++)
    t[i] = t[i - 1] + r;
  return t[e];
}
let Eo = Aw = class {
  static unshiftIndent(e, t, i, n, s) {
    const o = Hi.visibleColumnFromColumn(e, t, i);
    if (s) {
      const a = _h(" ", n), d = Hi.prevIndentTabStop(o, n) / n;
      return _h(a, d);
    } else {
      const a = "	", d = Hi.prevRenderTabStop(o, i) / i;
      return _h(a, d);
    }
  }
  static shiftIndent(e, t, i, n, s) {
    const o = Hi.visibleColumnFromColumn(e, t, i);
    if (s) {
      const a = _h(" ", n), d = Hi.nextIndentTabStop(o, n) / n;
      return _h(a, d);
    } else {
      const a = "	", d = Hi.nextRenderTabStop(o, i) / i;
      return _h(a, d);
    }
  }
  constructor(e, t, i) {
    this._languageConfigurationService = i, this._opts = t, this._selection = e, this._selectionId = null, this._useLastEditRangeForCursorEndPosition = !1, this._selectionStartColumnStaysPut = !1;
  }
  _addEditOperation(e, t, i) {
    this._useLastEditRangeForCursorEndPosition ? e.addTrackedEditOperation(t, i) : e.addEditOperation(t, i);
  }
  getEditOperations(e, t) {
    const i = this._selection.startLineNumber;
    let n = this._selection.endLineNumber;
    this._selection.endColumn === 1 && i !== n && (n = n - 1);
    const { tabSize: s, indentSize: o, insertSpaces: a } = this._opts, l = i === n;
    if (this._opts.useTabStops) {
      this._selection.isEmpty() && /^\s*$/.test(e.getLineContent(i)) && (this._useLastEditRangeForCursorEndPosition = !0);
      let d = 0, c = 0;
      for (let h = i; h <= n; h++, d = c) {
        c = 0;
        const u = e.getLineContent(h);
        let g = ns(u);
        if (this._opts.isUnshift && (u.length === 0 || g === 0) || !l && !this._opts.isUnshift && u.length === 0)
          continue;
        if (g === -1 && (g = u.length), h > 1 && Hi.visibleColumnFromColumn(u, g + 1, s) % o !== 0 && e.tokenization.isCheapToTokenize(h - 1)) {
          const _ = bf(this._opts.autoIndent, e, new L(h - 1, e.getLineMaxColumn(h - 1), h - 1, e.getLineMaxColumn(h - 1)), this._languageConfigurationService);
          if (_) {
            if (c = d, _.appendText)
              for (let v = 0, b = _.appendText.length; v < b && c < o && _.appendText.charCodeAt(v) === 32; v++)
                c++;
            _.removeText && (c = Math.max(0, c - _.removeText));
            for (let v = 0; v < c && !(g === 0 || u.charCodeAt(g - 1) !== 32); v++)
              g--;
          }
        }
        if (this._opts.isUnshift && g === 0)
          continue;
        let f;
        this._opts.isUnshift ? f = Aw.unshiftIndent(u, g + 1, s, o, a) : f = Aw.shiftIndent(u, g + 1, s, o, a), this._addEditOperation(t, new L(h, 1, h, g + 1), f), h === i && !this._selection.isEmpty() && (this._selectionStartColumnStaysPut = this._selection.startColumn <= g + 1);
      }
    } else {
      !this._opts.isUnshift && this._selection.isEmpty() && e.getLineLength(i) === 0 && (this._useLastEditRangeForCursorEndPosition = !0);
      const d = a ? _h(" ", o) : "	";
      for (let c = i; c <= n; c++) {
        const h = e.getLineContent(c);
        let u = ns(h);
        if (!(this._opts.isUnshift && (h.length === 0 || u === 0)) && !(!l && !this._opts.isUnshift && h.length === 0) && (u === -1 && (u = h.length), !(this._opts.isUnshift && u === 0)))
          if (this._opts.isUnshift) {
            u = Math.min(u, o);
            for (let g = 0; g < u; g++)
              if (h.charCodeAt(g) === 9) {
                u = g + 1;
                break;
              }
            this._addEditOperation(t, new L(c, 1, c, u + 1), "");
          } else
            this._addEditOperation(t, new L(c, 1, c, 1), d), c === i && !this._selection.isEmpty() && (this._selectionStartColumnStaysPut = this._selection.startColumn === 1);
      }
    }
    this._selectionId = t.trackSelection(this._selection);
  }
  computeCursorState(e, t) {
    if (this._useLastEditRangeForCursorEndPosition) {
      const n = t.getInverseEditOperations()[0];
      return new ge(n.range.endLineNumber, n.range.endColumn, n.range.endLineNumber, n.range.endColumn);
    }
    const i = t.getTrackedSelection(this._selectionId);
    if (this._selectionStartColumnStaysPut) {
      const n = this._selection.startColumn;
      return i.startColumn <= n ? i : i.getDirection() === 0 ? new ge(i.startLineNumber, n, i.endLineNumber, i.endColumn) : new ge(i.endLineNumber, i.endColumn, i.startLineNumber, n);
    }
    return i;
  }
};
Eo = Aw = SZ([
  yZ(2, Ot)
], Eo);
class LZ {
  constructor(e, t, i) {
    this._range = e, this._charBeforeSelection = t, this._charAfterSelection = i;
  }
  getEditOperations(e, t) {
    t.addTrackedEditOperation(new L(this._range.startLineNumber, this._range.startColumn, this._range.startLineNumber, this._range.startColumn), this._charBeforeSelection), t.addTrackedEditOperation(new L(this._range.endLineNumber, this._range.endColumn, this._range.endLineNumber, this._range.endColumn), this._charAfterSelection);
  }
  computeCursorState(e, t) {
    const i = t.getInverseEditOperations(), n = i[0].range, s = i[1].range;
    return new ge(n.endLineNumber, n.endColumn, s.endLineNumber, s.endColumn - this._charAfterSelection.length);
  }
}
class DZ {
  constructor(e, t, i) {
    this._position = e, this._text = t, this._charAfter = i;
  }
  getEditOperations(e, t) {
    t.addTrackedEditOperation(new L(this._position.lineNumber, this._position.column, this._position.lineNumber, this._position.column), this._text + this._charAfter);
  }
  computeCursorState(e, t) {
    const n = t.getInverseEditOperations()[0].range;
    return new ge(n.endLineNumber, n.startColumn, n.endLineNumber, n.endColumn - this._charAfter.length);
  }
}
function kZ(r, e, t) {
  const i = r.tokenization.getLanguageIdAtPosition(e, 0);
  if (e > 1) {
    let n, s = -1;
    for (n = e - 1; n >= 1; n--) {
      if (r.tokenization.getLanguageIdAtPosition(n, 0) !== i)
        return s;
      const o = r.getLineContent(n);
      if (t.shouldIgnore(n) || /^\s+$/.test(o) || o === "") {
        s = n;
        continue;
      }
      return n;
    }
  }
  return -1;
}
function N0(r, e, t, i = !0, n) {
  if (r < 4)
    return null;
  const s = n.getLanguageConfiguration(e.tokenization.getLanguageId()).indentRulesSupport;
  if (!s)
    return null;
  const o = new T1(e, s, n);
  if (t <= 1)
    return {
      indentation: "",
      action: null
    };
  for (let l = t - 1; l > 0 && e.getLineContent(l) === ""; l--)
    if (l === 1)
      return {
        indentation: "",
        action: null
      };
  const a = kZ(e, t, o);
  if (a < 0)
    return null;
  if (a < 1)
    return {
      indentation: "",
      action: null
    };
  if (o.shouldIncrease(a) || o.shouldIndentNextLine(a)) {
    const l = e.getLineContent(a);
    return {
      indentation: Tt(l),
      action: Mi.Indent,
      line: a
    };
  } else if (o.shouldDecrease(a)) {
    const l = e.getLineContent(a);
    return {
      indentation: Tt(l),
      action: null,
      line: a
    };
  } else {
    if (a === 1)
      return {
        indentation: Tt(e.getLineContent(a)),
        action: null,
        line: a
      };
    const l = a - 1, d = s.getIndentMetadata(e.getLineContent(l));
    if (!(d & 3) && d & 4) {
      let c = 0;
      for (let h = l - 1; h > 0; h--)
        if (!o.shouldIndentNextLine(h)) {
          c = h;
          break;
        }
      return {
        indentation: Tt(e.getLineContent(c + 1)),
        action: null,
        line: c + 1
      };
    }
    if (i)
      return {
        indentation: Tt(e.getLineContent(a)),
        action: null,
        line: a
      };
    for (let c = a; c > 0; c--) {
      if (o.shouldIncrease(c))
        return {
          indentation: Tt(e.getLineContent(c)),
          action: Mi.Indent,
          line: c
        };
      if (o.shouldIndentNextLine(c)) {
        let h = 0;
        for (let u = c - 1; u > 0; u--)
          if (!o.shouldIndentNextLine(c)) {
            h = u;
            break;
          }
        return {
          indentation: Tt(e.getLineContent(h + 1)),
          action: null,
          line: h + 1
        };
      } else if (o.shouldDecrease(c))
        return {
          indentation: Tt(e.getLineContent(c)),
          action: null,
          line: c
        };
    }
    return {
      indentation: Tt(e.getLineContent(1)),
      action: null,
      line: 1
    };
  }
}
function n_(r, e, t, i, n, s) {
  if (r < 4)
    return null;
  const o = s.getLanguageConfiguration(t);
  if (!o)
    return null;
  const a = s.getLanguageConfiguration(t).indentRulesSupport;
  if (!a)
    return null;
  const l = new T1(e, a, s), d = N0(r, e, i, void 0, s);
  if (d) {
    const c = d.line;
    if (c !== void 0) {
      let h = !0;
      for (let u = c; u < i - 1; u++)
        if (!/^\s*$/.test(e.getLineContent(u))) {
          h = !1;
          break;
        }
      if (h) {
        const u = o.onEnter(r, "", e.getLineContent(c), "");
        if (u) {
          let g = Tt(e.getLineContent(c));
          return u.removeText && (g = g.substring(0, g.length - u.removeText)), u.indentAction === Mi.Indent || u.indentAction === Mi.IndentOutdent ? g = n.shiftIndent(g) : u.indentAction === Mi.Outdent && (g = n.unshiftIndent(g)), l.shouldDecrease(i) && (g = n.unshiftIndent(g)), u.appendText && (g += u.appendText), Tt(g);
        }
      }
    }
    return l.shouldDecrease(i) ? d.action === Mi.Indent ? d.indentation : n.unshiftIndent(d.indentation) : d.action === Mi.Indent ? n.shiftIndent(d.indentation) : d.indentation;
  }
  return null;
}
function xZ(r, e, t, i, n) {
  if (r < 4)
    return null;
  const s = e.getLanguageIdAtPosition(t.startLineNumber, t.startColumn), o = n.getLanguageConfiguration(s).indentRulesSupport;
  if (!o)
    return null;
  e.tokenization.forceTokenization(t.startLineNumber);
  const l = new N1(e, n).getProcessedTokenContextAroundRange(t), d = l.afterRangeProcessedTokens, c = l.beforeRangeProcessedTokens, h = Tt(c.getLineContent()), u = EZ(e, t.startLineNumber, c), g = M1(e, t.getStartPosition()), f = e.getLineContent(t.startLineNumber), m = Tt(f), _ = N0(r, u, t.startLineNumber + 1, void 0, n);
  if (!_) {
    const b = g ? m : h;
    return {
      beforeEnter: b,
      afterEnter: b
    };
  }
  let v = g ? m : _.indentation;
  return _.action === Mi.Indent && (v = i.shiftIndent(v)), o.shouldDecrease(d.getLineContent()) && (v = i.unshiftIndent(v)), {
    beforeEnter: g ? m : h,
    afterEnter: v
  };
}
function IZ(r, e, t, i, n, s) {
  if (r < 4 || M1(e, t.getStartPosition()))
    return null;
  const a = e.getLanguageIdAtPosition(t.startLineNumber, t.startColumn), l = s.getLanguageConfiguration(a).indentRulesSupport;
  if (!l)
    return null;
  const c = new N1(e, s).getProcessedTokenContextAroundRange(t), h = c.beforeRangeProcessedTokens.getLineContent(), u = c.afterRangeProcessedTokens.getLineContent(), g = h + u, f = h + i + u;
  if (!l.shouldDecrease(g) && l.shouldDecrease(f)) {
    const m = N0(r, e, t.startLineNumber, !1, s);
    if (!m)
      return null;
    let _ = m.indentation;
    return m.action !== Mi.Indent && (_ = n.unshiftIndent(_)), _;
  }
  return null;
}
function n2(r, e, t) {
  const i = t.getLanguageConfiguration(r.getLanguageId()).indentRulesSupport;
  return !i || e < 1 || e > r.getLineCount() ? null : i.getIndentMetadata(r.getLineContent(e));
}
function EZ(r, e, t) {
  return {
    tokenization: {
      getLineTokens: (n) => n === e ? t : r.tokenization.getLineTokens(n),
      getLanguageId: () => r.getLanguageId(),
      getLanguageIdAtPosition: (n, s) => r.getLanguageIdAtPosition(n, s)
    },
    getLineContent: (n) => n === e ? t.getLineContent() : r.getLineContent(n)
  };
}
class ni {
  static indent(e, t, i) {
    if (t === null || i === null)
      return [];
    const n = [];
    for (let s = 0, o = i.length; s < o; s++)
      n[s] = new Eo(i[s], {
        isUnshift: !1,
        tabSize: e.tabSize,
        indentSize: e.indentSize,
        insertSpaces: e.insertSpaces,
        useTabStops: e.useTabStops,
        autoIndent: e.autoIndent
      }, e.languageConfigurationService);
    return n;
  }
  static outdent(e, t, i) {
    const n = [];
    for (let s = 0, o = i.length; s < o; s++)
      n[s] = new Eo(i[s], {
        isUnshift: !0,
        tabSize: e.tabSize,
        indentSize: e.indentSize,
        insertSpaces: e.insertSpaces,
        useTabStops: e.useTabStops,
        autoIndent: e.autoIndent
      }, e.languageConfigurationService);
    return n;
  }
  static shiftIndent(e, t, i) {
    return i = i || 1, Eo.shiftIndent(t, t.length + i, e.tabSize, e.indentSize, e.insertSpaces);
  }
  static unshiftIndent(e, t, i) {
    return i = i || 1, Eo.unshiftIndent(t, t.length + i, e.tabSize, e.indentSize, e.insertSpaces);
  }
  static _distributedPaste(e, t, i, n) {
    const s = [];
    for (let o = 0, a = i.length; o < a; o++)
      s[o] = new Cn(i[o], n[o]);
    return new ps(0, s, {
      shouldPushStackElementBefore: !0,
      shouldPushStackElementAfter: !0
    });
  }
  static _simplePaste(e, t, i, n, s) {
    const o = [];
    for (let a = 0, l = i.length; a < l; a++) {
      const d = i[a], c = d.getPosition();
      if (s && !d.isEmpty() && (s = !1), s && n.indexOf(`
`) !== n.length - 1 && (s = !1), s) {
        const h = new L(c.lineNumber, 1, c.lineNumber, 1);
        o[a] = new E1(h, n, d, !0);
      } else
        o[a] = new Cn(d, n);
    }
    return new ps(0, o, {
      shouldPushStackElementBefore: !0,
      shouldPushStackElementAfter: !0
    });
  }
  static _distributePasteToCursors(e, t, i, n, s) {
    if (n || t.length === 1)
      return null;
    if (s && s.length === t.length)
      return s;
    if (e.multiCursorPaste === "spread") {
      i.charCodeAt(i.length - 1) === 10 && (i = i.substr(0, i.length - 1)), i.charCodeAt(i.length - 1) === 13 && (i = i.substr(0, i.length - 1));
      const o = vd(i);
      if (o.length === t.length)
        return o;
    }
    return null;
  }
  static paste(e, t, i, n, s, o) {
    const a = this._distributePasteToCursors(e, i, n, s, o);
    return a ? (i = i.sort(L.compareRangesUsingStarts), this._distributedPaste(e, t, i, a)) : this._simplePaste(e, t, i, n, s);
  }
  static _goodIndentForLine(e, t, i) {
    let n = null, s = "";
    const o = N0(e.autoIndent, t, i, !1, e.languageConfigurationService);
    if (o)
      n = o.action, s = o.indentation;
    else if (i > 1) {
      let a;
      for (a = i - 1; a >= 1; a--) {
        const c = t.getLineContent(a);
        if (ja(c) >= 0)
          break;
      }
      if (a < 1)
        return null;
      const l = t.getLineMaxColumn(a), d = bf(e.autoIndent, t, new L(a, l, a, l), e.languageConfigurationService);
      d && (s = d.indentation + d.appendText);
    }
    return n && (n === Mi.Indent && (s = ni.shiftIndent(e, s)), n === Mi.Outdent && (s = ni.unshiftIndent(e, s)), s = e.normalizeIndentation(s)), s || null;
  }
  static _replaceJumpToNextIndent(e, t, i, n) {
    let s = "";
    const o = i.getStartPosition();
    if (e.insertSpaces) {
      const a = e.visibleColumnFromColumn(t, o), l = e.indentSize, d = l - a % l;
      for (let c = 0; c < d; c++)
        s += " ";
    } else
      s = "	";
    return new Cn(i, s, n);
  }
  static tab(e, t, i) {
    const n = [];
    for (let s = 0, o = i.length; s < o; s++) {
      const a = i[s];
      if (a.isEmpty()) {
        const l = t.getLineContent(a.startLineNumber);
        if (/^\s*$/.test(l) && t.tokenization.isCheapToTokenize(a.startLineNumber)) {
          let d = this._goodIndentForLine(e, t, a.startLineNumber);
          d = d || "	";
          const c = e.normalizeIndentation(d);
          if (!l.startsWith(c)) {
            n[s] = new Cn(new L(a.startLineNumber, 1, a.startLineNumber, l.length + 1), c, !0);
            continue;
          }
        }
        n[s] = this._replaceJumpToNextIndent(e, t, a, !0);
      } else {
        if (a.startLineNumber === a.endLineNumber) {
          const l = t.getLineMaxColumn(a.startLineNumber);
          if (a.startColumn !== 1 || a.endColumn !== l) {
            n[s] = this._replaceJumpToNextIndent(e, t, a, !1);
            continue;
          }
        }
        n[s] = new Eo(a, {
          isUnshift: !1,
          tabSize: e.tabSize,
          indentSize: e.indentSize,
          insertSpaces: e.insertSpaces,
          useTabStops: e.useTabStops,
          autoIndent: e.autoIndent
        }, e.languageConfigurationService);
      }
    }
    return n;
  }
  static compositionType(e, t, i, n, s, o, a, l) {
    const d = n.map((c) => this._compositionType(i, c, s, o, a, l));
    return new ps(4, d, {
      shouldPushStackElementBefore: vC(
        e,
        4
        /* EditOperationType.TypingOther */
      ),
      shouldPushStackElementAfter: !1
    });
  }
  static _compositionType(e, t, i, n, s, o) {
    if (!t.isEmpty())
      return null;
    const a = t.getPosition(), l = Math.max(1, a.column - n), d = Math.min(e.getLineMaxColumn(a.lineNumber), a.column + s), c = new L(a.lineNumber, l, a.lineNumber, d);
    return e.getValueInRange(c) === i && o === 0 ? null : new Rw(c, i, 0, o);
  }
  static _typeCommand(e, t, i) {
    return i ? new mC(e, t, !0) : new Cn(e, t, !0);
  }
  static _enter(e, t, i, n) {
    if (e.autoIndent === 0)
      return ni._typeCommand(n, `
`, i);
    if (!t.tokenization.isCheapToTokenize(n.getStartPosition().lineNumber) || e.autoIndent === 1) {
      const l = t.getLineContent(n.startLineNumber), d = Tt(l).substring(0, n.startColumn - 1);
      return ni._typeCommand(n, `
` + e.normalizeIndentation(d), i);
    }
    const s = bf(e.autoIndent, t, n, e.languageConfigurationService);
    if (s) {
      if (s.indentAction === Mi.None)
        return ni._typeCommand(n, `
` + e.normalizeIndentation(s.indentation + s.appendText), i);
      if (s.indentAction === Mi.Indent)
        return ni._typeCommand(n, `
` + e.normalizeIndentation(s.indentation + s.appendText), i);
      if (s.indentAction === Mi.IndentOutdent) {
        const l = e.normalizeIndentation(s.indentation), d = e.normalizeIndentation(s.indentation + s.appendText), c = `
` + d + `
` + l;
        return i ? new mC(n, c, !0) : new Rw(n, c, -1, d.length - l.length, !0);
      } else if (s.indentAction === Mi.Outdent) {
        const l = ni.unshiftIndent(e, s.indentation);
        return ni._typeCommand(n, `
` + e.normalizeIndentation(l + s.appendText), i);
      }
    }
    const o = t.getLineContent(n.startLineNumber), a = Tt(o).substring(0, n.startColumn - 1);
    if (e.autoIndent >= 4) {
      const l = xZ(e.autoIndent, t, n, {
        unshiftIndent: (d) => ni.unshiftIndent(e, d),
        shiftIndent: (d) => ni.shiftIndent(e, d),
        normalizeIndentation: (d) => e.normalizeIndentation(d)
      }, e.languageConfigurationService);
      if (l) {
        let d = e.visibleColumnFromColumn(t, n.getEndPosition());
        const c = n.endColumn, h = t.getLineContent(n.endLineNumber), u = ns(h);
        if (u >= 0 ? n = n.setEndPosition(n.endLineNumber, Math.max(n.endColumn, u + 1)) : n = n.setEndPosition(n.endLineNumber, t.getLineMaxColumn(n.endLineNumber)), i)
          return new mC(n, `
` + e.normalizeIndentation(l.afterEnter), !0);
        {
          let g = 0;
          return c <= u + 1 && (e.insertSpaces || (d = Math.ceil(d / e.indentSize)), g = Math.min(d + 1 - e.normalizeIndentation(l.afterEnter).length - 1, 0)), new Rw(n, `
` + e.normalizeIndentation(l.afterEnter), 0, g, !0);
        }
      }
    }
    return ni._typeCommand(n, `
` + e.normalizeIndentation(a), i);
  }
  static _isAutoIndentType(e, t, i) {
    if (e.autoIndent < 4)
      return !1;
    for (let n = 0, s = i.length; n < s; n++)
      if (!t.tokenization.isCheapToTokenize(i[n].getEndPosition().lineNumber))
        return !1;
    return !0;
  }
  static _runAutoIndentType(e, t, i, n) {
    const s = pV(t, i.startLineNumber, i.startColumn), o = IZ(e.autoIndent, t, i, n, {
      shiftIndent: (a) => ni.shiftIndent(e, a),
      unshiftIndent: (a) => ni.unshiftIndent(e, a)
    }, e.languageConfigurationService);
    if (o === null)
      return null;
    if (o !== e.normalizeIndentation(s)) {
      const a = t.getLineFirstNonWhitespaceColumn(i.startLineNumber);
      return a === 0 ? ni._typeCommand(new L(i.startLineNumber, 1, i.endLineNumber, i.endColumn), e.normalizeIndentation(o) + n, !1) : ni._typeCommand(new L(i.startLineNumber, 1, i.endLineNumber, i.endColumn), e.normalizeIndentation(o) + t.getLineContent(i.startLineNumber).substring(a - 1, i.startColumn - 1) + n, !1);
    }
    return null;
  }
  static _isAutoClosingOvertype(e, t, i, n, s) {
    if (e.autoClosingOvertype === "never" || !e.autoClosingPairs.autoClosingPairsCloseSingleChar.has(s))
      return !1;
    for (let o = 0, a = i.length; o < a; o++) {
      const l = i[o];
      if (!l.isEmpty())
        return !1;
      const d = l.getPosition(), c = t.getLineContent(d.lineNumber);
      if (c.charAt(d.column - 1) !== s)
        return !1;
      const u = Pd(s);
      if ((d.column > 2 ? c.charCodeAt(d.column - 2) : 0) === 92 && u)
        return !1;
      if (e.autoClosingOvertype === "auto") {
        let f = !1;
        for (let m = 0, _ = n.length; m < _; m++) {
          const v = n[m];
          if (d.lineNumber === v.startLineNumber && d.column === v.startColumn) {
            f = !0;
            break;
          }
        }
        if (!f)
          return !1;
      }
    }
    return !0;
  }
  static _runAutoClosingOvertype(e, t, i, n, s) {
    const o = [];
    for (let a = 0, l = n.length; a < l; a++) {
      const c = n[a].getPosition(), h = new L(c.lineNumber, c.column, c.lineNumber, c.column + 1);
      o[a] = new Cn(h, s);
    }
    return new ps(4, o, {
      shouldPushStackElementBefore: vC(
        e,
        4
        /* EditOperationType.TypingOther */
      ),
      shouldPushStackElementAfter: !1
    });
  }
  static _isBeforeClosingBrace(e, t) {
    const i = t.charAt(0), n = e.autoClosingPairs.autoClosingPairsOpenByStart.get(i) || [], s = e.autoClosingPairs.autoClosingPairsCloseByStart.get(i) || [], o = n.some((l) => t.startsWith(l.open)), a = s.some((l) => t.startsWith(l.close));
    return !o && a;
  }
  /**
   * Determine if typing `ch` at all `positions` in the `model` results in an
   * auto closing open sequence being typed.
   *
   * Auto closing open sequences can consist of multiple characters, which
   * can lead to ambiguities. In such a case, the longest auto-closing open
   * sequence is returned.
   */
  static _findAutoClosingPairOpen(e, t, i, n) {
    const s = e.autoClosingPairs.autoClosingPairsOpenByEnd.get(n);
    if (!s)
      return null;
    let o = null;
    for (const a of s)
      if (o === null || a.open.length > o.open.length) {
        let l = !0;
        for (const d of i)
          if (t.getValueInRange(new L(d.lineNumber, d.column - a.open.length + 1, d.lineNumber, d.column)) + n !== a.open) {
            l = !1;
            break;
          }
        l && (o = a);
      }
    return o;
  }
  /**
   * Find another auto-closing pair that is contained by the one passed in.
   *
   * e.g. when having [(,)] and [(*,*)] as auto-closing pairs
   * this method will find [(,)] as a containment pair for [(*,*)]
   */
  static _findContainedAutoClosingPair(e, t) {
    if (t.open.length <= 1)
      return null;
    const i = t.close.charAt(t.close.length - 1), n = e.autoClosingPairs.autoClosingPairsCloseByEnd.get(i) || [];
    let s = null;
    for (const o of n)
      o.open !== t.open && t.open.includes(o.open) && t.close.endsWith(o.close) && (!s || o.open.length > s.open.length) && (s = o);
    return s;
  }
  static _getAutoClosingPairClose(e, t, i, n, s) {
    for (const f of i)
      if (!f.isEmpty())
        return null;
    const o = i.map((f) => {
      const m = f.getPosition();
      return s ? { lineNumber: m.lineNumber, beforeColumn: m.column - n.length, afterColumn: m.column } : { lineNumber: m.lineNumber, beforeColumn: m.column, afterColumn: m.column };
    }), a = this._findAutoClosingPairOpen(e, t, o.map((f) => new A(f.lineNumber, f.beforeColumn)), n);
    if (!a)
      return null;
    let l, d;
    if (Pd(n) ? (l = e.autoClosingQuotes, d = e.shouldAutoCloseBefore.quote) : (e.blockCommentStartToken ? a.open.includes(e.blockCommentStartToken) : !1) ? (l = e.autoClosingComments, d = e.shouldAutoCloseBefore.comment) : (l = e.autoClosingBrackets, d = e.shouldAutoCloseBefore.bracket), l === "never")
      return null;
    const h = this._findContainedAutoClosingPair(e, a), u = h ? h.close : "";
    let g = !0;
    for (const f of o) {
      const { lineNumber: m, beforeColumn: _, afterColumn: v } = f, b = t.getLineContent(m), C = b.substring(0, _ - 1), w = b.substring(v - 1);
      if (w.startsWith(u) || (g = !1), w.length > 0) {
        const E = w.charAt(0);
        if (!ni._isBeforeClosingBrace(e, w) && !d(E))
          return null;
      }
      if (a.open.length === 1 && (n === "'" || n === '"') && l !== "always") {
        const E = fr(e.wordSeparators, []);
        if (C.length > 0) {
          const N = C.charCodeAt(C.length - 1);
          if (E.get(N) === 0)
            return null;
        }
      }
      if (!t.tokenization.isCheapToTokenize(m))
        return null;
      t.tokenization.forceTokenization(m);
      const S = t.tokenization.getLineTokens(m), y = qh(S, _ - 1);
      if (!a.shouldAutoClose(y, _ - y.firstCharOffset))
        return null;
      const k = a.findNeutralCharacter();
      if (k) {
        const E = t.tokenization.getTokenTypeIfInsertingCharacter(m, _, k);
        if (!a.isOK(E))
          return null;
      }
    }
    return g ? a.close.substring(0, a.close.length - u.length) : a.close;
  }
  static _runAutoClosingOpenCharType(e, t, i, n, s, o, a) {
    const l = [];
    for (let d = 0, c = n.length; d < c; d++) {
      const h = n[d];
      l[d] = new s2(h, s, !o, a);
    }
    return new ps(4, l, {
      shouldPushStackElementBefore: !0,
      shouldPushStackElementAfter: !1
    });
  }
  static _shouldSurroundChar(e, t) {
    return Pd(t) ? e.autoSurround === "quotes" || e.autoSurround === "languageDefined" : e.autoSurround === "brackets" || e.autoSurround === "languageDefined";
  }
  static _isSurroundSelectionType(e, t, i, n) {
    if (!ni._shouldSurroundChar(e, n) || !e.surroundingPairs.hasOwnProperty(n))
      return !1;
    const s = Pd(n);
    for (const o of i) {
      if (o.isEmpty())
        return !1;
      let a = !0;
      for (let l = o.startLineNumber; l <= o.endLineNumber; l++) {
        const d = t.getLineContent(l), c = l === o.startLineNumber ? o.startColumn - 1 : 0, h = l === o.endLineNumber ? o.endColumn - 1 : d.length, u = d.substring(c, h);
        if (/[^ \t]/.test(u)) {
          a = !1;
          break;
        }
      }
      if (a)
        return !1;
      if (s && o.startLineNumber === o.endLineNumber && o.startColumn + 1 === o.endColumn) {
        const l = t.getValueInRange(o);
        if (Pd(l))
          return !1;
      }
    }
    return !0;
  }
  static _runSurroundSelectionType(e, t, i, n, s) {
    const o = [];
    for (let a = 0, l = n.length; a < l; a++) {
      const d = n[a], c = t.surroundingPairs[s];
      o[a] = new LZ(d, s, c);
    }
    return new ps(0, o, {
      shouldPushStackElementBefore: !0,
      shouldPushStackElementAfter: !0
    });
  }
  static _isTypeInterceptorElectricChar(e, t, i) {
    return !!(i.length === 1 && t.tokenization.isCheapToTokenize(i[0].getEndPosition().lineNumber));
  }
  static _typeInterceptorElectricChar(e, t, i, n, s) {
    if (!t.electricChars.hasOwnProperty(s) || !n.isEmpty())
      return null;
    const o = n.getPosition();
    i.tokenization.forceTokenization(o.lineNumber);
    const a = i.tokenization.getLineTokens(o.lineNumber);
    let l;
    try {
      l = t.onElectricCharacter(s, a, o.column);
    } catch (d) {
      return He(d), null;
    }
    if (!l)
      return null;
    if (l.matchOpenBracket) {
      const d = (a.getLineContent() + s).lastIndexOf(l.matchOpenBracket) + 1, c = i.bracketPairs.findMatchingBracketUp(
        l.matchOpenBracket,
        {
          lineNumber: o.lineNumber,
          column: d
        },
        500
        /* give at most 500ms to compute */
      );
      if (c) {
        if (c.startLineNumber === o.lineNumber)
          return null;
        const h = i.getLineContent(c.startLineNumber), u = Tt(h), g = t.normalizeIndentation(u), f = i.getLineContent(o.lineNumber), m = i.getLineFirstNonWhitespaceColumn(o.lineNumber) || o.column, _ = f.substring(m - 1, o.column - 1), v = g + _ + s, b = new L(o.lineNumber, 1, o.lineNumber, o.column), C = new Cn(b, v);
        return new ps(GD(v, e), [C], {
          shouldPushStackElementBefore: !1,
          shouldPushStackElementAfter: !0
        });
      }
    }
    return null;
  }
  /**
   * This is very similar with typing, but the character is already in the text buffer!
   */
  static compositionEndWithInterceptors(e, t, i, n, s, o) {
    if (!n)
      return null;
    let a = null;
    for (const h of n)
      if (a === null)
        a = h.insertedText;
      else if (a !== h.insertedText)
        return null;
    if (!a || a.length !== 1)
      return null;
    const l = a;
    let d = !1;
    for (const h of n)
      if (h.deletedText.length !== 0) {
        d = !0;
        break;
      }
    if (d) {
      if (!ni._shouldSurroundChar(t, l) || !t.surroundingPairs.hasOwnProperty(l))
        return null;
      const h = Pd(l);
      for (const f of n)
        if (f.deletedSelectionStart !== 0 || f.deletedSelectionEnd !== f.deletedText.length || /^[ \t]+$/.test(f.deletedText) || h && Pd(f.deletedText))
          return null;
      const u = [];
      for (const f of s) {
        if (!f.isEmpty())
          return null;
        u.push(f.getPosition());
      }
      if (u.length !== n.length)
        return null;
      const g = [];
      for (let f = 0, m = u.length; f < m; f++)
        g.push(new DZ(u[f], n[f].deletedText, t.surroundingPairs[l]));
      return new ps(4, g, {
        shouldPushStackElementBefore: !0,
        shouldPushStackElementAfter: !1
      });
    }
    if (this._isAutoClosingOvertype(t, i, s, o, l)) {
      const h = s.map((u) => new Cn(new L(u.positionLineNumber, u.positionColumn, u.positionLineNumber, u.positionColumn + 1), "", !1));
      return new ps(4, h, {
        shouldPushStackElementBefore: !0,
        shouldPushStackElementAfter: !1
      });
    }
    const c = this._getAutoClosingPairClose(t, i, s, l, !0);
    return c !== null ? this._runAutoClosingOpenCharType(e, t, i, s, l, !0, c) : null;
  }
  static typeWithInterceptors(e, t, i, n, s, o, a) {
    if (!e && a === `
`) {
      const c = [];
      for (let h = 0, u = s.length; h < u; h++)
        c[h] = ni._enter(i, n, !1, s[h]);
      return new ps(4, c, {
        shouldPushStackElementBefore: !0,
        shouldPushStackElementAfter: !1
      });
    }
    if (!e && this._isAutoIndentType(i, n, s)) {
      const c = [];
      let h = !1;
      for (let u = 0, g = s.length; u < g; u++)
        if (c[u] = this._runAutoIndentType(i, n, s[u], a), !c[u]) {
          h = !0;
          break;
        }
      if (!h)
        return new ps(4, c, {
          shouldPushStackElementBefore: !0,
          shouldPushStackElementAfter: !1
        });
    }
    if (this._isAutoClosingOvertype(i, n, s, o, a))
      return this._runAutoClosingOvertype(t, i, n, s, a);
    if (!e) {
      const c = this._getAutoClosingPairClose(i, n, s, a, !1);
      if (c)
        return this._runAutoClosingOpenCharType(t, i, n, s, a, !1, c);
    }
    if (!e && this._isSurroundSelectionType(i, n, s, a))
      return this._runSurroundSelectionType(t, i, n, s, a);
    if (!e && this._isTypeInterceptorElectricChar(i, n, s)) {
      const c = this._typeInterceptorElectricChar(t, i, n, s[0], a);
      if (c)
        return c;
    }
    const l = [];
    for (let c = 0, h = s.length; c < h; c++)
      l[c] = new Cn(s[c], a);
    const d = GD(a, t);
    return new ps(d, l, {
      shouldPushStackElementBefore: vC(t, d),
      shouldPushStackElementAfter: !1
    });
  }
  static typeWithoutInterceptors(e, t, i, n, s) {
    const o = [];
    for (let l = 0, d = n.length; l < d; l++)
      o[l] = new Cn(n[l], s);
    const a = GD(s, e);
    return new ps(a, o, {
      shouldPushStackElementBefore: vC(e, a),
      shouldPushStackElementAfter: !1
    });
  }
  static lineInsertBefore(e, t, i) {
    if (t === null || i === null)
      return [];
    const n = [];
    for (let s = 0, o = i.length; s < o; s++) {
      let a = i[s].positionLineNumber;
      if (a === 1)
        n[s] = new mC(new L(1, 1, 1, 1), `
`);
      else {
        a--;
        const l = t.getLineMaxColumn(a);
        n[s] = this._enter(e, t, !1, new L(a, l, a, l));
      }
    }
    return n;
  }
  static lineInsertAfter(e, t, i) {
    if (t === null || i === null)
      return [];
    const n = [];
    for (let s = 0, o = i.length; s < o; s++) {
      const a = i[s].positionLineNumber, l = t.getLineMaxColumn(a);
      n[s] = this._enter(e, t, !1, new L(a, l, a, l));
    }
    return n;
  }
  static lineBreakInsert(e, t, i) {
    const n = [];
    for (let s = 0, o = i.length; s < o; s++)
      n[s] = this._enter(e, t, !0, i[s]);
    return n;
  }
}
class s2 extends Rw {
  constructor(e, t, i, n) {
    super(e, (i ? t : "") + n, 0, -n.length), this._openCharacter = t, this._closeCharacter = n, this.closeCharacterRange = null, this.enclosingRange = null;
  }
  computeCursorState(e, t) {
    const n = t.getInverseEditOperations()[0].range;
    return this.closeCharacterRange = new L(n.startLineNumber, n.endColumn - this._closeCharacter.length, n.endLineNumber, n.endColumn), this.enclosingRange = new L(n.startLineNumber, n.endColumn - this._openCharacter.length - this._closeCharacter.length, n.endLineNumber, n.endColumn), super.computeCursorState(e, t);
  }
}
class TZ {
  constructor(e, t, i, n, s, o) {
    this.deletedText = e, this.deletedSelectionStart = t, this.deletedSelectionEnd = i, this.insertedText = n, this.insertedSelectionStart = s, this.insertedSelectionEnd = o;
  }
}
function GD(r, e) {
  return r === " " ? e === 5 || e === 6 ? 6 : 5 : 4;
}
function vC(r, e) {
  return SP(r) && !SP(e) ? !0 : r === 5 ? !1 : wP(r) !== wP(e);
}
function wP(r) {
  return r === 6 || r === 5 ? "space" : r;
}
function SP(r) {
  return r === 4 || r === 5 || r === 6;
}
var x;
(function(r) {
  r.editorSimpleInput = new oe("editorSimpleInput", !1, !0), r.editorTextFocus = new oe("editorTextFocus", !1, p("editorTextFocus", "Whether the editor text has focus (cursor is blinking)")), r.focus = new oe("editorFocus", !1, p("editorFocus", "Whether the editor or an editor widget has focus (e.g. focus is in the find widget)")), r.textInputFocus = new oe("textInputFocus", !1, p("textInputFocus", "Whether an editor or a rich text input has focus (cursor is blinking)")), r.readOnly = new oe("editorReadonly", !1, p("editorReadonly", "Whether the editor is read-only")), r.inDiffEditor = new oe("inDiffEditor", !1, p("inDiffEditor", "Whether the context is a diff editor")), r.isEmbeddedDiffEditor = new oe("isEmbeddedDiffEditor", !1, p("isEmbeddedDiffEditor", "Whether the context is an embedded diff editor")), r.inMultiDiffEditor = new oe("inMultiDiffEditor", !1, p("inMultiDiffEditor", "Whether the context is a multi diff editor")), r.multiDiffEditorAllCollapsed = new oe("multiDiffEditorAllCollapsed", void 0, p("multiDiffEditorAllCollapsed", "Whether all files in multi diff editor are collapsed")), r.hasChanges = new oe("diffEditorHasChanges", !1, p("diffEditorHasChanges", "Whether the diff editor has changes")), r.comparingMovedCode = new oe("comparingMovedCode", !1, p("comparingMovedCode", "Whether a moved code block is selected for comparison")), r.accessibleDiffViewerVisible = new oe("accessibleDiffViewerVisible", !1, p("accessibleDiffViewerVisible", "Whether the accessible diff viewer is visible")), r.diffEditorRenderSideBySideInlineBreakpointReached = new oe("diffEditorRenderSideBySideInlineBreakpointReached", !1, p("diffEditorRenderSideBySideInlineBreakpointReached", "Whether the diff editor render side by side inline breakpoint is reached")), r.diffEditorInlineMode = new oe("diffEditorInlineMode", !1, p("diffEditorInlineMode", "Whether inline mode is active")), r.diffEditorOriginalWritable = new oe("diffEditorOriginalWritable", !1, p("diffEditorOriginalWritable", "Whether modified is writable in the diff editor")), r.diffEditorModifiedWritable = new oe("diffEditorModifiedWritable", !1, p("diffEditorModifiedWritable", "Whether modified is writable in the diff editor")), r.diffEditorOriginalUri = new oe("diffEditorOriginalUri", "", p("diffEditorOriginalUri", "The uri of the original document")), r.diffEditorModifiedUri = new oe("diffEditorModifiedUri", "", p("diffEditorModifiedUri", "The uri of the modified document")), r.columnSelection = new oe("editorColumnSelection", !1, p("editorColumnSelection", "Whether `editor.columnSelection` is enabled")), r.writable = r.readOnly.toNegated(), r.hasNonEmptySelection = new oe("editorHasSelection", !1, p("editorHasSelection", "Whether the editor has text selected")), r.hasOnlyEmptySelection = r.hasNonEmptySelection.toNegated(), r.hasMultipleSelections = new oe("editorHasMultipleSelections", !1, p("editorHasMultipleSelections", "Whether the editor has multiple selections")), r.hasSingleSelection = r.hasMultipleSelections.toNegated(), r.tabMovesFocus = new oe("editorTabMovesFocus", !1, p("editorTabMovesFocus", "Whether `Tab` will move focus out of the editor")), r.tabDoesNotMoveFocus = r.tabMovesFocus.toNegated(), r.isInEmbeddedEditor = new oe("isInEmbeddedEditor", !1, !0), r.canUndo = new oe("canUndo", !1, !0), r.canRedo = new oe("canRedo", !1, !0), r.hoverVisible = new oe("editorHoverVisible", !1, p("editorHoverVisible", "Whether the editor hover is visible")), r.hoverFocused = new oe("editorHoverFocused", !1, p("editorHoverFocused", "Whether the editor hover is focused")), r.stickyScrollFocused = new oe("stickyScrollFocused", !1, p("stickyScrollFocused", "Whether the sticky scroll is focused")), r.stickyScrollVisible = new oe("stickyScrollVisible", !1, p("stickyScrollVisible", "Whether the sticky scroll is visible")), r.standaloneColorPickerVisible = new oe("standaloneColorPickerVisible", !1, p("standaloneColorPickerVisible", "Whether the standalone color picker is visible")), r.standaloneColorPickerFocused = new oe("standaloneColorPickerFocused", !1, p("standaloneColorPickerFocused", "Whether the standalone color picker is focused")), r.inCompositeEditor = new oe("inCompositeEditor", void 0, p("inCompositeEditor", "Whether the editor is part of a larger editor (e.g. notebooks)")), r.notInCompositeEditor = r.inCompositeEditor.toNegated(), r.languageId = new oe("editorLangId", "", p("editorLangId", "The language identifier of the editor")), r.hasCompletionItemProvider = new oe("editorHasCompletionItemProvider", !1, p("editorHasCompletionItemProvider", "Whether the editor has a completion item provider")), r.hasCodeActionsProvider = new oe("editorHasCodeActionsProvider", !1, p("editorHasCodeActionsProvider", "Whether the editor has a code actions provider")), r.hasCodeLensProvider = new oe("editorHasCodeLensProvider", !1, p("editorHasCodeLensProvider", "Whether the editor has a code lens provider")), r.hasDefinitionProvider = new oe("editorHasDefinitionProvider", !1, p("editorHasDefinitionProvider", "Whether the editor has a definition provider")), r.hasDeclarationProvider = new oe("editorHasDeclarationProvider", !1, p("editorHasDeclarationProvider", "Whether the editor has a declaration provider")), r.hasImplementationProvider = new oe("editorHasImplementationProvider", !1, p("editorHasImplementationProvider", "Whether the editor has an implementation provider")), r.hasTypeDefinitionProvider = new oe("editorHasTypeDefinitionProvider", !1, p("editorHasTypeDefinitionProvider", "Whether the editor has a type definition provider")), r.hasHoverProvider = new oe("editorHasHoverProvider", !1, p("editorHasHoverProvider", "Whether the editor has a hover provider")), r.hasDocumentHighlightProvider = new oe("editorHasDocumentHighlightProvider", !1, p("editorHasDocumentHighlightProvider", "Whether the editor has a document highlight provider")), r.hasDocumentSymbolProvider = new oe("editorHasDocumentSymbolProvider", !1, p("editorHasDocumentSymbolProvider", "Whether the editor has a document symbol provider")), r.hasReferenceProvider = new oe("editorHasReferenceProvider", !1, p("editorHasReferenceProvider", "Whether the editor has a reference provider")), r.hasRenameProvider = new oe("editorHasRenameProvider", !1, p("editorHasRenameProvider", "Whether the editor has a rename provider")), r.hasSignatureHelpProvider = new oe("editorHasSignatureHelpProvider", !1, p("editorHasSignatureHelpProvider", "Whether the editor has a signature help provider")), r.hasInlayHintsProvider = new oe("editorHasInlayHintsProvider", !1, p("editorHasInlayHintsProvider", "Whether the editor has an inline hints provider")), r.hasDocumentFormattingProvider = new oe("editorHasDocumentFormattingProvider", !1, p("editorHasDocumentFormattingProvider", "Whether the editor has a document formatting provider")), r.hasDocumentSelectionFormattingProvider = new oe("editorHasDocumentSelectionFormattingProvider", !1, p("editorHasDocumentSelectionFormattingProvider", "Whether the editor has a document selection formatting provider")), r.hasMultipleDocumentFormattingProvider = new oe("editorHasMultipleDocumentFormattingProvider", !1, p("editorHasMultipleDocumentFormattingProvider", "Whether the editor has multiple document formatting providers")), r.hasMultipleDocumentSelectionFormattingProvider = new oe("editorHasMultipleDocumentSelectionFormattingProvider", !1, p("editorHasMultipleDocumentSelectionFormattingProvider", "Whether the editor has multiple document selection formatting providers"));
})(x || (x = {}));
const mt = 0;
class ui extends Ui {
  runEditorCommand(e, t, i) {
    const n = t._getViewModel();
    n && this.runCoreEditorCommand(n, i || {});
  }
}
var bn;
(function(r) {
  const e = function(i) {
    if (!ur(i))
      return !1;
    const n = i;
    return !(!Ws(n.to) || !Fs(n.by) && !Ws(n.by) || !Fs(n.value) && !Ic(n.value) || !Fs(n.revealCursor) && !ZB(n.revealCursor));
  };
  r.metadata = {
    description: "Scroll editor in the given direction",
    args: [
      {
        name: "Editor scroll argument object",
        description: "Property-value pairs that can be passed through this argument:\n					* 'to': A mandatory direction value.\n						```\n						'up', 'down'\n						```\n					* 'by': Unit to move. Default is computed based on 'to' value.\n						```\n						'line', 'wrappedLine', 'page', 'halfPage', 'editor'\n						```\n					* 'value': Number of units to move. Default is '1'.\n					* 'revealCursor': If 'true' reveals the cursor if it is outside view port.\n				",
        constraint: e,
        schema: {
          type: "object",
          required: ["to"],
          properties: {
            to: {
              type: "string",
              enum: ["up", "down"]
            },
            by: {
              type: "string",
              enum: ["line", "wrappedLine", "page", "halfPage", "editor"]
            },
            value: {
              type: "number",
              default: 1
            },
            revealCursor: {
              type: "boolean"
            }
          }
        }
      }
    ]
  }, r.RawDirection = {
    Up: "up",
    Right: "right",
    Down: "down",
    Left: "left"
  }, r.RawUnit = {
    Line: "line",
    WrappedLine: "wrappedLine",
    Page: "page",
    HalfPage: "halfPage",
    Editor: "editor",
    Column: "column"
  };
  function t(i) {
    let n;
    switch (i.to) {
      case r.RawDirection.Up:
        n = 1;
        break;
      case r.RawDirection.Right:
        n = 2;
        break;
      case r.RawDirection.Down:
        n = 3;
        break;
      case r.RawDirection.Left:
        n = 4;
        break;
      default:
        return null;
    }
    let s;
    switch (i.by) {
      case r.RawUnit.Line:
        s = 1;
        break;
      case r.RawUnit.WrappedLine:
        s = 2;
        break;
      case r.RawUnit.Page:
        s = 3;
        break;
      case r.RawUnit.HalfPage:
        s = 4;
        break;
      case r.RawUnit.Editor:
        s = 5;
        break;
      case r.RawUnit.Column:
        s = 6;
        break;
      default:
        s = 2;
    }
    const o = Math.floor(i.value || 1), a = !!i.revealCursor;
    return {
      direction: n,
      unit: s,
      value: o,
      revealCursor: a,
      select: !!i.select
    };
  }
  r.parse = t;
})(bn || (bn = {}));
var Qg;
(function(r) {
  const e = function(t) {
    if (!ur(t))
      return !1;
    const i = t;
    return !(!Ic(i.lineNumber) && !Ws(i.lineNumber) || !Fs(i.at) && !Ws(i.at));
  };
  r.metadata = {
    description: "Reveal the given line at the given logical position",
    args: [
      {
        name: "Reveal line argument object",
        description: "Property-value pairs that can be passed through this argument:\n					* 'lineNumber': A mandatory line number value.\n					* 'at': Logical position at which line has to be revealed.\n						```\n						'top', 'center', 'bottom'\n						```\n				",
        constraint: e,
        schema: {
          type: "object",
          required: ["lineNumber"],
          properties: {
            lineNumber: {
              type: ["number", "string"]
            },
            at: {
              type: "string",
              enum: ["top", "center", "bottom"]
            }
          }
        }
      }
    ]
  }, r.RawAtArgument = {
    Top: "top",
    Center: "center",
    Bottom: "bottom"
  };
})(Qg || (Qg = {}));
class Jx {
  constructor(e) {
    e.addImplementation(1e4, "code-editor", (t, i) => {
      const n = t.get(ht).getFocusedCodeEditor();
      return n && n.hasTextFocus() ? this._runEditorCommand(t, n, i) : !1;
    }), e.addImplementation(1e3, "generic-dom-input-textarea", (t, i) => {
      const n = Ln();
      return n && ["input", "textarea"].indexOf(n.tagName.toLowerCase()) >= 0 ? (this.runDOMCommand(n), !0) : !1;
    }), e.addImplementation(0, "generic-dom", (t, i) => {
      const n = t.get(ht).getActiveCodeEditor();
      return n ? (n.focus(), this._runEditorCommand(t, n, i)) : !1;
    });
  }
  _runEditorCommand(e, t, i) {
    const n = this.runEditorCommand(e, t, i);
    return n || !0;
  }
}
var Ji;
(function(r) {
  class e extends ui {
    constructor(b) {
      super(b), this._inSelectionMode = b.inSelectionMode;
    }
    runCoreEditorCommand(b, C) {
      if (!C.position)
        return;
      b.model.pushStackElement(), b.setCursorStates(C.source, 3, [
        cn.moveTo(b, b.getPrimaryCursorState(), this._inSelectionMode, C.position, C.viewPosition)
      ]) && C.revealType !== 2 && b.revealAllCursors(C.source, !0, !0);
    }
  }
  r.MoveTo = se(new e({
    id: "_moveTo",
    inSelectionMode: !1,
    precondition: void 0
  })), r.MoveToSelect = se(new e({
    id: "_moveToSelect",
    inSelectionMode: !0,
    precondition: void 0
  }));
  class t extends ui {
    runCoreEditorCommand(b, C) {
      b.model.pushStackElement();
      const w = this._getColumnSelectResult(b, b.getPrimaryCursorState(), b.getCursorColumnSelectData(), C);
      w !== null && (b.setCursorStates(C.source, 3, w.viewStates.map((S) => dt.fromViewState(S))), b.setCursorColumnSelectData({
        isReal: !0,
        fromViewLineNumber: w.fromLineNumber,
        fromViewVisualColumn: w.fromVisualColumn,
        toViewLineNumber: w.toLineNumber,
        toViewVisualColumn: w.toVisualColumn
      }), w.reversed ? b.revealTopMostCursor(C.source) : b.revealBottomMostCursor(C.source));
    }
  }
  r.ColumnSelect = se(new class extends t {
    constructor() {
      super({
        id: "columnSelect",
        precondition: void 0
      });
    }
    _getColumnSelectResult(v, b, C, w) {
      if (typeof w.position > "u" || typeof w.viewPosition > "u" || typeof w.mouseColumn > "u")
        return null;
      const S = v.model.validatePosition(w.position), y = v.coordinatesConverter.validateViewPosition(new A(w.viewPosition.lineNumber, w.viewPosition.column), S), k = w.doColumnSelect ? C.fromViewLineNumber : y.lineNumber, E = w.doColumnSelect ? C.fromViewVisualColumn : w.mouseColumn - 1;
      return Vh.columnSelect(v.cursorConfig, v, k, E, y.lineNumber, w.mouseColumn - 1);
    }
  }()), r.CursorColumnSelectLeft = se(new class extends t {
    constructor() {
      super({
        id: "cursorColumnSelectLeft",
        precondition: void 0,
        kbOpts: {
          weight: mt,
          kbExpr: x.textInputFocus,
          primary: 3599,
          linux: { primary: 0 }
        }
      });
    }
    _getColumnSelectResult(v, b, C, w) {
      return Vh.columnSelectLeft(v.cursorConfig, v, C);
    }
  }()), r.CursorColumnSelectRight = se(new class extends t {
    constructor() {
      super({
        id: "cursorColumnSelectRight",
        precondition: void 0,
        kbOpts: {
          weight: mt,
          kbExpr: x.textInputFocus,
          primary: 3601,
          linux: { primary: 0 }
        }
      });
    }
    _getColumnSelectResult(v, b, C, w) {
      return Vh.columnSelectRight(v.cursorConfig, v, C);
    }
  }());
  class i extends t {
    constructor(b) {
      super(b), this._isPaged = b.isPaged;
    }
    _getColumnSelectResult(b, C, w, S) {
      return Vh.columnSelectUp(b.cursorConfig, b, w, this._isPaged);
    }
  }
  r.CursorColumnSelectUp = se(new i({
    isPaged: !1,
    id: "cursorColumnSelectUp",
    precondition: void 0,
    kbOpts: {
      weight: mt,
      kbExpr: x.textInputFocus,
      primary: 3600,
      linux: { primary: 0 }
    }
  })), r.CursorColumnSelectPageUp = se(new i({
    isPaged: !0,
    id: "cursorColumnSelectPageUp",
    precondition: void 0,
    kbOpts: {
      weight: mt,
      kbExpr: x.textInputFocus,
      primary: 3595,
      linux: { primary: 0 }
    }
  }));
  class n extends t {
    constructor(b) {
      super(b), this._isPaged = b.isPaged;
    }
    _getColumnSelectResult(b, C, w, S) {
      return Vh.columnSelectDown(b.cursorConfig, b, w, this._isPaged);
    }
  }
  r.CursorColumnSelectDown = se(new n({
    isPaged: !1,
    id: "cursorColumnSelectDown",
    precondition: void 0,
    kbOpts: {
      weight: mt,
      kbExpr: x.textInputFocus,
      primary: 3602,
      linux: { primary: 0 }
    }
  })), r.CursorColumnSelectPageDown = se(new n({
    isPaged: !0,
    id: "cursorColumnSelectPageDown",
    precondition: void 0,
    kbOpts: {
      weight: mt,
      kbExpr: x.textInputFocus,
      primary: 3596,
      linux: { primary: 0 }
    }
  }));
  class s extends ui {
    constructor() {
      super({
        id: "cursorMove",
        precondition: void 0,
        metadata: LS.metadata
      });
    }
    runCoreEditorCommand(b, C) {
      const w = LS.parse(C);
      w && this._runCursorMove(b, C.source, w);
    }
    _runCursorMove(b, C, w) {
      b.model.pushStackElement(), b.setCursorStates(C, 3, s._move(b, b.getCursorStates(), w)), b.revealAllCursors(C, !0);
    }
    static _move(b, C, w) {
      const S = w.select, y = w.value;
      switch (w.direction) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
        case 10:
          return cn.simpleMove(b, C, w.direction, S, y, w.unit);
        case 11:
        case 13:
        case 12:
        case 14:
          return cn.viewportMove(b, C, w.direction, S, y);
        default:
          return null;
      }
    }
  }
  r.CursorMoveImpl = s, r.CursorMove = se(new s());
  class o extends ui {
    constructor(b) {
      super(b), this._staticArgs = b.args;
    }
    runCoreEditorCommand(b, C) {
      let w = this._staticArgs;
      this._staticArgs.value === -1 && (w = {
        direction: this._staticArgs.direction,
        unit: this._staticArgs.unit,
        select: this._staticArgs.select,
        value: C.pageSize || b.cursorConfig.pageSize
      }), b.model.pushStackElement(), b.setCursorStates(C.source, 3, cn.simpleMove(b, b.getCursorStates(), w.direction, w.select, w.value, w.unit)), b.revealAllCursors(C.source, !0);
    }
  }
  r.CursorLeft = se(new o({
    args: {
      direction: 0,
      unit: 0,
      select: !1,
      value: 1
    },
    id: "cursorLeft",
    precondition: void 0,
    kbOpts: {
      weight: mt,
      kbExpr: x.textInputFocus,
      primary: 15,
      mac: { primary: 15, secondary: [
        288
        /* KeyCode.KeyB */
      ] }
    }
  })), r.CursorLeftSelect = se(new o({
    args: {
      direction: 0,
      unit: 0,
      select: !0,
      value: 1
    },
    id: "cursorLeftSelect",
    precondition: void 0,
    kbOpts: {
      weight: mt,
      kbExpr: x.textInputFocus,
      primary: 1039
      /* KeyCode.LeftArrow */
    }
  })), r.CursorRight = se(new o({
    args: {
      direction: 1,
      unit: 0,
      select: !1,
      value: 1
    },
    id: "cursorRight",
    precondition: void 0,
    kbOpts: {
      weight: mt,
      kbExpr: x.textInputFocus,
      primary: 17,
      mac: { primary: 17, secondary: [
        292
        /* KeyCode.KeyF */
      ] }
    }
  })), r.CursorRightSelect = se(new o({
    args: {
      direction: 1,
      unit: 0,
      select: !0,
      value: 1
    },
    id: "cursorRightSelect",
    precondition: void 0,
    kbOpts: {
      weight: mt,
      kbExpr: x.textInputFocus,
      primary: 1041
      /* KeyCode.RightArrow */
    }
  })), r.CursorUp = se(new o({
    args: {
      direction: 2,
      unit: 2,
      select: !1,
      value: 1
    },
    id: "cursorUp",
    precondition: void 0,
    kbOpts: {
      weight: mt,
      kbExpr: x.textInputFocus,
      primary: 16,
      mac: { primary: 16, secondary: [
        302
        /* KeyCode.KeyP */
      ] }
    }
  })), r.CursorUpSelect = se(new o({
    args: {
      direction: 2,
      unit: 2,
      select: !0,
      value: 1
    },
    id: "cursorUpSelect",
    precondition: void 0,
    kbOpts: {
      weight: mt,
      kbExpr: x.textInputFocus,
      primary: 1040,
      secondary: [
        3088
        /* KeyCode.UpArrow */
      ],
      mac: {
        primary: 1040
        /* KeyCode.UpArrow */
      },
      linux: {
        primary: 1040
        /* KeyCode.UpArrow */
      }
    }
  })), r.CursorPageUp = se(new o({
    args: {
      direction: 2,
      unit: 2,
      select: !1,
      value: -1
      /* Constants.PAGE_SIZE_MARKER */
    },
    id: "cursorPageUp",
    precondition: void 0,
    kbOpts: {
      weight: mt,
      kbExpr: x.textInputFocus,
      primary: 11
      /* KeyCode.PageUp */
    }
  })), r.CursorPageUpSelect = se(new o({
    args: {
      direction: 2,
      unit: 2,
      select: !0,
      value: -1
      /* Constants.PAGE_SIZE_MARKER */
    },
    id: "cursorPageUpSelect",
    precondition: void 0,
    kbOpts: {
      weight: mt,
      kbExpr: x.textInputFocus,
      primary: 1035
      /* KeyCode.PageUp */
    }
  })), r.CursorDown = se(new o({
    args: {
      direction: 3,
      unit: 2,
      select: !1,
      value: 1
    },
    id: "cursorDown",
    precondition: void 0,
    kbOpts: {
      weight: mt,
      kbExpr: x.textInputFocus,
      primary: 18,
      mac: { primary: 18, secondary: [
        300
        /* KeyCode.KeyN */
      ] }
    }
  })), r.CursorDownSelect = se(new o({
    args: {
      direction: 3,
      unit: 2,
      select: !0,
      value: 1
    },
    id: "cursorDownSelect",
    precondition: void 0,
    kbOpts: {
      weight: mt,
      kbExpr: x.textInputFocus,
      primary: 1042,
      secondary: [
        3090
        /* KeyCode.DownArrow */
      ],
      mac: {
        primary: 1042
        /* KeyCode.DownArrow */
      },
      linux: {
        primary: 1042
        /* KeyCode.DownArrow */
      }
    }
  })), r.CursorPageDown = se(new o({
    args: {
      direction: 3,
      unit: 2,
      select: !1,
      value: -1
      /* Constants.PAGE_SIZE_MARKER */
    },
    id: "cursorPageDown",
    precondition: void 0,
    kbOpts: {
      weight: mt,
      kbExpr: x.textInputFocus,
      primary: 12
      /* KeyCode.PageDown */
    }
  })), r.CursorPageDownSelect = se(new o({
    args: {
      direction: 3,
      unit: 2,
      select: !0,
      value: -1
      /* Constants.PAGE_SIZE_MARKER */
    },
    id: "cursorPageDownSelect",
    precondition: void 0,
    kbOpts: {
      weight: mt,
      kbExpr: x.textInputFocus,
      primary: 1036
      /* KeyCode.PageDown */
    }
  })), r.CreateCursor = se(new class extends ui {
    constructor() {
      super({
        id: "createCursor",
        precondition: void 0
      });
    }
    runCoreEditorCommand(v, b) {
      if (!b.position)
        return;
      let C;
      b.wholeLine ? C = cn.line(v, v.getPrimaryCursorState(), !1, b.position, b.viewPosition) : C = cn.moveTo(v, v.getPrimaryCursorState(), !1, b.position, b.viewPosition);
      const w = v.getCursorStates();
      if (w.length > 1) {
        const S = C.modelState ? C.modelState.position : null, y = C.viewState ? C.viewState.position : null;
        for (let k = 0, E = w.length; k < E; k++) {
          const N = w[k];
          if (!(S && !N.modelState.selection.containsPosition(S)) && !(y && !N.viewState.selection.containsPosition(y))) {
            w.splice(k, 1), v.model.pushStackElement(), v.setCursorStates(b.source, 3, w);
            return;
          }
        }
      }
      w.push(C), v.model.pushStackElement(), v.setCursorStates(b.source, 3, w);
    }
  }()), r.LastCursorMoveToSelect = se(new class extends ui {
    constructor() {
      super({
        id: "_lastCursorMoveToSelect",
        precondition: void 0
      });
    }
    runCoreEditorCommand(v, b) {
      if (!b.position)
        return;
      const C = v.getLastAddedCursorIndex(), w = v.getCursorStates(), S = w.slice(0);
      S[C] = cn.moveTo(v, w[C], !0, b.position, b.viewPosition), v.model.pushStackElement(), v.setCursorStates(b.source, 3, S);
    }
  }());
  class a extends ui {
    constructor(b) {
      super(b), this._inSelectionMode = b.inSelectionMode;
    }
    runCoreEditorCommand(b, C) {
      b.model.pushStackElement(), b.setCursorStates(C.source, 3, cn.moveToBeginningOfLine(b, b.getCursorStates(), this._inSelectionMode)), b.revealAllCursors(C.source, !0);
    }
  }
  r.CursorHome = se(new a({
    inSelectionMode: !1,
    id: "cursorHome",
    precondition: void 0,
    kbOpts: {
      weight: mt,
      kbExpr: x.textInputFocus,
      primary: 14,
      mac: { primary: 14, secondary: [
        2063
        /* KeyCode.LeftArrow */
      ] }
    }
  })), r.CursorHomeSelect = se(new a({
    inSelectionMode: !0,
    id: "cursorHomeSelect",
    precondition: void 0,
    kbOpts: {
      weight: mt,
      kbExpr: x.textInputFocus,
      primary: 1038,
      mac: { primary: 1038, secondary: [
        3087
        /* KeyCode.LeftArrow */
      ] }
    }
  }));
  class l extends ui {
    constructor(b) {
      super(b), this._inSelectionMode = b.inSelectionMode;
    }
    runCoreEditorCommand(b, C) {
      b.model.pushStackElement(), b.setCursorStates(C.source, 3, this._exec(b.getCursorStates())), b.revealAllCursors(C.source, !0);
    }
    _exec(b) {
      const C = [];
      for (let w = 0, S = b.length; w < S; w++) {
        const y = b[w], k = y.modelState.position.lineNumber;
        C[w] = dt.fromModelState(y.modelState.move(this._inSelectionMode, k, 1, 0));
      }
      return C;
    }
  }
  r.CursorLineStart = se(new l({
    inSelectionMode: !1,
    id: "cursorLineStart",
    precondition: void 0,
    kbOpts: {
      weight: mt,
      kbExpr: x.textInputFocus,
      primary: 0,
      mac: {
        primary: 287
        /* KeyCode.KeyA */
      }
    }
  })), r.CursorLineStartSelect = se(new l({
    inSelectionMode: !0,
    id: "cursorLineStartSelect",
    precondition: void 0,
    kbOpts: {
      weight: mt,
      kbExpr: x.textInputFocus,
      primary: 0,
      mac: {
        primary: 1311
        /* KeyCode.KeyA */
      }
    }
  }));
  class d extends ui {
    constructor(b) {
      super(b), this._inSelectionMode = b.inSelectionMode;
    }
    runCoreEditorCommand(b, C) {
      b.model.pushStackElement(), b.setCursorStates(C.source, 3, cn.moveToEndOfLine(b, b.getCursorStates(), this._inSelectionMode, C.sticky || !1)), b.revealAllCursors(C.source, !0);
    }
  }
  r.CursorEnd = se(new d({
    inSelectionMode: !1,
    id: "cursorEnd",
    precondition: void 0,
    kbOpts: {
      args: { sticky: !1 },
      weight: mt,
      kbExpr: x.textInputFocus,
      primary: 13,
      mac: { primary: 13, secondary: [
        2065
        /* KeyCode.RightArrow */
      ] }
    },
    metadata: {
      description: "Go to End",
      args: [{
        name: "args",
        schema: {
          type: "object",
          properties: {
            sticky: {
              description: p("stickydesc", "Stick to the end even when going to longer lines"),
              type: "boolean",
              default: !1
            }
          }
        }
      }]
    }
  })), r.CursorEndSelect = se(new d({
    inSelectionMode: !0,
    id: "cursorEndSelect",
    precondition: void 0,
    kbOpts: {
      args: { sticky: !1 },
      weight: mt,
      kbExpr: x.textInputFocus,
      primary: 1037,
      mac: { primary: 1037, secondary: [
        3089
        /* KeyCode.RightArrow */
      ] }
    },
    metadata: {
      description: "Select to End",
      args: [{
        name: "args",
        schema: {
          type: "object",
          properties: {
            sticky: {
              description: p("stickydesc", "Stick to the end even when going to longer lines"),
              type: "boolean",
              default: !1
            }
          }
        }
      }]
    }
  }));
  class c extends ui {
    constructor(b) {
      super(b), this._inSelectionMode = b.inSelectionMode;
    }
    runCoreEditorCommand(b, C) {
      b.model.pushStackElement(), b.setCursorStates(C.source, 3, this._exec(b, b.getCursorStates())), b.revealAllCursors(C.source, !0);
    }
    _exec(b, C) {
      const w = [];
      for (let S = 0, y = C.length; S < y; S++) {
        const k = C[S], E = k.modelState.position.lineNumber, N = b.model.getLineMaxColumn(E);
        w[S] = dt.fromModelState(k.modelState.move(this._inSelectionMode, E, N, 0));
      }
      return w;
    }
  }
  r.CursorLineEnd = se(new c({
    inSelectionMode: !1,
    id: "cursorLineEnd",
    precondition: void 0,
    kbOpts: {
      weight: mt,
      kbExpr: x.textInputFocus,
      primary: 0,
      mac: {
        primary: 291
        /* KeyCode.KeyE */
      }
    }
  })), r.CursorLineEndSelect = se(new c({
    inSelectionMode: !0,
    id: "cursorLineEndSelect",
    precondition: void 0,
    kbOpts: {
      weight: mt,
      kbExpr: x.textInputFocus,
      primary: 0,
      mac: {
        primary: 1315
        /* KeyCode.KeyE */
      }
    }
  }));
  class h extends ui {
    constructor(b) {
      super(b), this._inSelectionMode = b.inSelectionMode;
    }
    runCoreEditorCommand(b, C) {
      b.model.pushStackElement(), b.setCursorStates(C.source, 3, cn.moveToBeginningOfBuffer(b, b.getCursorStates(), this._inSelectionMode)), b.revealAllCursors(C.source, !0);
    }
  }
  r.CursorTop = se(new h({
    inSelectionMode: !1,
    id: "cursorTop",
    precondition: void 0,
    kbOpts: {
      weight: mt,
      kbExpr: x.textInputFocus,
      primary: 2062,
      mac: {
        primary: 2064
        /* KeyCode.UpArrow */
      }
    }
  })), r.CursorTopSelect = se(new h({
    inSelectionMode: !0,
    id: "cursorTopSelect",
    precondition: void 0,
    kbOpts: {
      weight: mt,
      kbExpr: x.textInputFocus,
      primary: 3086,
      mac: {
        primary: 3088
        /* KeyCode.UpArrow */
      }
    }
  }));
  class u extends ui {
    constructor(b) {
      super(b), this._inSelectionMode = b.inSelectionMode;
    }
    runCoreEditorCommand(b, C) {
      b.model.pushStackElement(), b.setCursorStates(C.source, 3, cn.moveToEndOfBuffer(b, b.getCursorStates(), this._inSelectionMode)), b.revealAllCursors(C.source, !0);
    }
  }
  r.CursorBottom = se(new u({
    inSelectionMode: !1,
    id: "cursorBottom",
    precondition: void 0,
    kbOpts: {
      weight: mt,
      kbExpr: x.textInputFocus,
      primary: 2061,
      mac: {
        primary: 2066
        /* KeyCode.DownArrow */
      }
    }
  })), r.CursorBottomSelect = se(new u({
    inSelectionMode: !0,
    id: "cursorBottomSelect",
    precondition: void 0,
    kbOpts: {
      weight: mt,
      kbExpr: x.textInputFocus,
      primary: 3085,
      mac: {
        primary: 3090
        /* KeyCode.DownArrow */
      }
    }
  }));
  class g extends ui {
    constructor() {
      super({
        id: "editorScroll",
        precondition: void 0,
        metadata: bn.metadata
      });
    }
    determineScrollMethod(b) {
      const C = [
        6
        /* EditorScroll_.Unit.Column */
      ], w = [
        1,
        2,
        3,
        4,
        5,
        6
        /* EditorScroll_.Unit.Column */
      ], S = [
        4,
        2
        /* EditorScroll_.Direction.Right */
      ], y = [
        1,
        3
        /* EditorScroll_.Direction.Down */
      ];
      return C.includes(b.unit) && S.includes(b.direction) ? this._runHorizontalEditorScroll.bind(this) : w.includes(b.unit) && y.includes(b.direction) ? this._runVerticalEditorScroll.bind(this) : null;
    }
    runCoreEditorCommand(b, C) {
      const w = bn.parse(C);
      if (!w)
        return;
      const S = this.determineScrollMethod(w);
      S && S(b, C.source, w);
    }
    _runVerticalEditorScroll(b, C, w) {
      const S = this._computeDesiredScrollTop(b, w);
      if (w.revealCursor) {
        const y = b.getCompletelyVisibleViewRangeAtScrollTop(S);
        b.setCursorStates(C, 3, [
          cn.findPositionInViewportIfOutside(b, b.getPrimaryCursorState(), y, w.select)
        ]);
      }
      b.viewLayout.setScrollPosition(
        { scrollTop: S },
        0
        /* ScrollType.Smooth */
      );
    }
    _computeDesiredScrollTop(b, C) {
      if (C.unit === 1) {
        const y = b.viewLayout.getFutureViewport(), k = b.getCompletelyVisibleViewRangeAtScrollTop(y.top), E = b.coordinatesConverter.convertViewRangeToModelRange(k);
        let N;
        C.direction === 1 ? N = Math.max(1, E.startLineNumber - C.value) : N = Math.min(b.model.getLineCount(), E.startLineNumber + C.value);
        const F = b.coordinatesConverter.convertModelPositionToViewPosition(new A(N, 1));
        return b.viewLayout.getVerticalOffsetForLineNumber(F.lineNumber);
      }
      if (C.unit === 5) {
        let y = 0;
        return C.direction === 3 && (y = b.model.getLineCount() - b.cursorConfig.pageSize), b.viewLayout.getVerticalOffsetForLineNumber(y);
      }
      let w;
      C.unit === 3 ? w = b.cursorConfig.pageSize * C.value : C.unit === 4 ? w = Math.round(b.cursorConfig.pageSize / 2) * C.value : w = C.value;
      const S = (C.direction === 1 ? -1 : 1) * w;
      return b.viewLayout.getCurrentScrollTop() + S * b.cursorConfig.lineHeight;
    }
    _runHorizontalEditorScroll(b, C, w) {
      const S = this._computeDesiredScrollLeft(b, w);
      b.viewLayout.setScrollPosition(
        { scrollLeft: S },
        0
        /* ScrollType.Smooth */
      );
    }
    _computeDesiredScrollLeft(b, C) {
      const w = (C.direction === 4 ? -1 : 1) * C.value;
      return b.viewLayout.getCurrentScrollLeft() + w * b.cursorConfig.typicalHalfwidthCharacterWidth;
    }
  }
  r.EditorScrollImpl = g, r.EditorScroll = se(new g()), r.ScrollLineUp = se(new class extends ui {
    constructor() {
      super({
        id: "scrollLineUp",
        precondition: void 0,
        kbOpts: {
          weight: mt,
          kbExpr: x.textInputFocus,
          primary: 2064,
          mac: {
            primary: 267
            /* KeyCode.PageUp */
          }
        }
      });
    }
    runCoreEditorCommand(v, b) {
      r.EditorScroll.runCoreEditorCommand(v, {
        to: bn.RawDirection.Up,
        by: bn.RawUnit.WrappedLine,
        value: 1,
        revealCursor: !1,
        select: !1,
        source: b.source
      });
    }
  }()), r.ScrollPageUp = se(new class extends ui {
    constructor() {
      super({
        id: "scrollPageUp",
        precondition: void 0,
        kbOpts: {
          weight: mt,
          kbExpr: x.textInputFocus,
          primary: 2059,
          win: {
            primary: 523
            /* KeyCode.PageUp */
          },
          linux: {
            primary: 523
            /* KeyCode.PageUp */
          }
        }
      });
    }
    runCoreEditorCommand(v, b) {
      r.EditorScroll.runCoreEditorCommand(v, {
        to: bn.RawDirection.Up,
        by: bn.RawUnit.Page,
        value: 1,
        revealCursor: !1,
        select: !1,
        source: b.source
      });
    }
  }()), r.ScrollEditorTop = se(new class extends ui {
    constructor() {
      super({
        id: "scrollEditorTop",
        precondition: void 0,
        kbOpts: {
          weight: mt,
          kbExpr: x.textInputFocus
        }
      });
    }
    runCoreEditorCommand(v, b) {
      r.EditorScroll.runCoreEditorCommand(v, {
        to: bn.RawDirection.Up,
        by: bn.RawUnit.Editor,
        value: 1,
        revealCursor: !1,
        select: !1,
        source: b.source
      });
    }
  }()), r.ScrollLineDown = se(new class extends ui {
    constructor() {
      super({
        id: "scrollLineDown",
        precondition: void 0,
        kbOpts: {
          weight: mt,
          kbExpr: x.textInputFocus,
          primary: 2066,
          mac: {
            primary: 268
            /* KeyCode.PageDown */
          }
        }
      });
    }
    runCoreEditorCommand(v, b) {
      r.EditorScroll.runCoreEditorCommand(v, {
        to: bn.RawDirection.Down,
        by: bn.RawUnit.WrappedLine,
        value: 1,
        revealCursor: !1,
        select: !1,
        source: b.source
      });
    }
  }()), r.ScrollPageDown = se(new class extends ui {
    constructor() {
      super({
        id: "scrollPageDown",
        precondition: void 0,
        kbOpts: {
          weight: mt,
          kbExpr: x.textInputFocus,
          primary: 2060,
          win: {
            primary: 524
            /* KeyCode.PageDown */
          },
          linux: {
            primary: 524
            /* KeyCode.PageDown */
          }
        }
      });
    }
    runCoreEditorCommand(v, b) {
      r.EditorScroll.runCoreEditorCommand(v, {
        to: bn.RawDirection.Down,
        by: bn.RawUnit.Page,
        value: 1,
        revealCursor: !1,
        select: !1,
        source: b.source
      });
    }
  }()), r.ScrollEditorBottom = se(new class extends ui {
    constructor() {
      super({
        id: "scrollEditorBottom",
        precondition: void 0,
        kbOpts: {
          weight: mt,
          kbExpr: x.textInputFocus
        }
      });
    }
    runCoreEditorCommand(v, b) {
      r.EditorScroll.runCoreEditorCommand(v, {
        to: bn.RawDirection.Down,
        by: bn.RawUnit.Editor,
        value: 1,
        revealCursor: !1,
        select: !1,
        source: b.source
      });
    }
  }()), r.ScrollLeft = se(new class extends ui {
    constructor() {
      super({
        id: "scrollLeft",
        precondition: void 0,
        kbOpts: {
          weight: mt,
          kbExpr: x.textInputFocus
        }
      });
    }
    runCoreEditorCommand(v, b) {
      r.EditorScroll.runCoreEditorCommand(v, {
        to: bn.RawDirection.Left,
        by: bn.RawUnit.Column,
        value: 2,
        revealCursor: !1,
        select: !1,
        source: b.source
      });
    }
  }()), r.ScrollRight = se(new class extends ui {
    constructor() {
      super({
        id: "scrollRight",
        precondition: void 0,
        kbOpts: {
          weight: mt,
          kbExpr: x.textInputFocus
        }
      });
    }
    runCoreEditorCommand(v, b) {
      r.EditorScroll.runCoreEditorCommand(v, {
        to: bn.RawDirection.Right,
        by: bn.RawUnit.Column,
        value: 2,
        revealCursor: !1,
        select: !1,
        source: b.source
      });
    }
  }());
  class f extends ui {
    constructor(b) {
      super(b), this._inSelectionMode = b.inSelectionMode;
    }
    runCoreEditorCommand(b, C) {
      C.position && (b.model.pushStackElement(), b.setCursorStates(C.source, 3, [
        cn.word(b, b.getPrimaryCursorState(), this._inSelectionMode, C.position)
      ]), C.revealType !== 2 && b.revealAllCursors(C.source, !0, !0));
    }
  }
  r.WordSelect = se(new f({
    inSelectionMode: !1,
    id: "_wordSelect",
    precondition: void 0
  })), r.WordSelectDrag = se(new f({
    inSelectionMode: !0,
    id: "_wordSelectDrag",
    precondition: void 0
  })), r.LastCursorWordSelect = se(new class extends ui {
    constructor() {
      super({
        id: "lastCursorWordSelect",
        precondition: void 0
      });
    }
    runCoreEditorCommand(v, b) {
      if (!b.position)
        return;
      const C = v.getLastAddedCursorIndex(), w = v.getCursorStates(), S = w.slice(0), y = w[C];
      S[C] = cn.word(v, y, y.modelState.hasSelection(), b.position), v.model.pushStackElement(), v.setCursorStates(b.source, 3, S);
    }
  }());
  class m extends ui {
    constructor(b) {
      super(b), this._inSelectionMode = b.inSelectionMode;
    }
    runCoreEditorCommand(b, C) {
      C.position && (b.model.pushStackElement(), b.setCursorStates(C.source, 3, [
        cn.line(b, b.getPrimaryCursorState(), this._inSelectionMode, C.position, C.viewPosition)
      ]), C.revealType !== 2 && b.revealAllCursors(C.source, !1, !0));
    }
  }
  r.LineSelect = se(new m({
    inSelectionMode: !1,
    id: "_lineSelect",
    precondition: void 0
  })), r.LineSelectDrag = se(new m({
    inSelectionMode: !0,
    id: "_lineSelectDrag",
    precondition: void 0
  }));
  class _ extends ui {
    constructor(b) {
      super(b), this._inSelectionMode = b.inSelectionMode;
    }
    runCoreEditorCommand(b, C) {
      if (!C.position)
        return;
      const w = b.getLastAddedCursorIndex(), S = b.getCursorStates(), y = S.slice(0);
      y[w] = cn.line(b, S[w], this._inSelectionMode, C.position, C.viewPosition), b.model.pushStackElement(), b.setCursorStates(C.source, 3, y);
    }
  }
  r.LastCursorLineSelect = se(new _({
    inSelectionMode: !1,
    id: "lastCursorLineSelect",
    precondition: void 0
  })), r.LastCursorLineSelectDrag = se(new _({
    inSelectionMode: !0,
    id: "lastCursorLineSelectDrag",
    precondition: void 0
  })), r.CancelSelection = se(new class extends ui {
    constructor() {
      super({
        id: "cancelSelection",
        precondition: x.hasNonEmptySelection,
        kbOpts: {
          weight: mt,
          kbExpr: x.textInputFocus,
          primary: 9,
          secondary: [
            1033
            /* KeyCode.Escape */
          ]
        }
      });
    }
    runCoreEditorCommand(v, b) {
      v.model.pushStackElement(), v.setCursorStates(b.source, 3, [
        cn.cancelSelection(v, v.getPrimaryCursorState())
      ]), v.revealAllCursors(b.source, !0);
    }
  }()), r.RemoveSecondaryCursors = se(new class extends ui {
    constructor() {
      super({
        id: "removeSecondaryCursors",
        precondition: x.hasMultipleSelections,
        kbOpts: {
          weight: mt + 1,
          kbExpr: x.textInputFocus,
          primary: 9,
          secondary: [
            1033
            /* KeyCode.Escape */
          ]
        }
      });
    }
    runCoreEditorCommand(v, b) {
      v.model.pushStackElement(), v.setCursorStates(b.source, 3, [
        v.getPrimaryCursorState()
      ]), v.revealAllCursors(b.source, !0), el(p("removedCursor", "Removed secondary cursors"));
    }
  }()), r.RevealLine = se(new class extends ui {
    constructor() {
      super({
        id: "revealLine",
        precondition: void 0,
        metadata: Qg.metadata
      });
    }
    runCoreEditorCommand(v, b) {
      const C = b, w = C.lineNumber || 0;
      let S = typeof w == "number" ? w + 1 : parseInt(w) + 1;
      S < 1 && (S = 1);
      const y = v.model.getLineCount();
      S > y && (S = y);
      const k = new L(S, 1, S, v.model.getLineMaxColumn(S));
      let E = 0;
      if (C.at)
        switch (C.at) {
          case Qg.RawAtArgument.Top:
            E = 3;
            break;
          case Qg.RawAtArgument.Center:
            E = 1;
            break;
          case Qg.RawAtArgument.Bottom:
            E = 4;
            break;
        }
      const N = v.coordinatesConverter.convertModelRangeToViewRange(k);
      v.revealRange(
        b.source,
        !1,
        N,
        E,
        0
        /* ScrollType.Smooth */
      );
    }
  }()), r.SelectAll = new class extends Jx {
    constructor() {
      super(W6);
    }
    runDOMCommand(v) {
      Oo && (v.focus(), v.select()), v.ownerDocument.execCommand("selectAll");
    }
    runEditorCommand(v, b, C) {
      const w = b._getViewModel();
      w && this.runCoreEditorCommand(w, C);
    }
    runCoreEditorCommand(v, b) {
      v.model.pushStackElement(), v.setCursorStates("keyboard", 3, [
        cn.selectAll(v, v.getPrimaryCursorState())
      ]);
    }
  }(), r.SetSelection = se(new class extends ui {
    constructor() {
      super({
        id: "setSelection",
        precondition: void 0
      });
    }
    runCoreEditorCommand(v, b) {
      b.selection && (v.model.pushStackElement(), v.setCursorStates(b.source, 3, [
        dt.fromModelSelection(b.selection)
      ]));
    }
  }());
})(Ji || (Ji = {}));
const NZ = U.and(x.textInputFocus, x.columnSelection);
function Rp(r, e) {
  ls.registerKeybindingRule({
    id: r,
    primary: e,
    when: NZ,
    weight: mt + 1
  });
}
Rp(
  Ji.CursorColumnSelectLeft.id,
  1039
  /* KeyCode.LeftArrow */
);
Rp(
  Ji.CursorColumnSelectRight.id,
  1041
  /* KeyCode.RightArrow */
);
Rp(
  Ji.CursorColumnSelectUp.id,
  1040
  /* KeyCode.UpArrow */
);
Rp(
  Ji.CursorColumnSelectPageUp.id,
  1035
  /* KeyCode.PageUp */
);
Rp(
  Ji.CursorColumnSelectDown.id,
  1042
  /* KeyCode.DownArrow */
);
Rp(
  Ji.CursorColumnSelectPageDown.id,
  1036
  /* KeyCode.PageDown */
);
function yP(r) {
  return r.register(), r;
}
var Cf;
(function(r) {
  class e extends Ui {
    runEditorCommand(i, n, s) {
      const o = n._getViewModel();
      o && this.runCoreEditingCommand(n, o, s || {});
    }
  }
  r.CoreEditingCommand = e, r.LineBreakInsert = se(new class extends e {
    constructor() {
      super({
        id: "lineBreakInsert",
        precondition: x.writable,
        kbOpts: {
          weight: mt,
          kbExpr: x.textInputFocus,
          primary: 0,
          mac: {
            primary: 301
            /* KeyCode.KeyO */
          }
        }
      });
    }
    runCoreEditingCommand(t, i, n) {
      t.pushUndoStop(), t.executeCommands(this.id, ni.lineBreakInsert(i.cursorConfig, i.model, i.getCursorStates().map((s) => s.modelState.selection)));
    }
  }()), r.Outdent = se(new class extends e {
    constructor() {
      super({
        id: "outdent",
        precondition: x.writable,
        kbOpts: {
          weight: mt,
          kbExpr: U.and(x.editorTextFocus, x.tabDoesNotMoveFocus),
          primary: 1026
          /* KeyCode.Tab */
        }
      });
    }
    runCoreEditingCommand(t, i, n) {
      t.pushUndoStop(), t.executeCommands(this.id, ni.outdent(i.cursorConfig, i.model, i.getCursorStates().map((s) => s.modelState.selection))), t.pushUndoStop();
    }
  }()), r.Tab = se(new class extends e {
    constructor() {
      super({
        id: "tab",
        precondition: x.writable,
        kbOpts: {
          weight: mt,
          kbExpr: U.and(x.editorTextFocus, x.tabDoesNotMoveFocus),
          primary: 2
          /* KeyCode.Tab */
        }
      });
    }
    runCoreEditingCommand(t, i, n) {
      t.pushUndoStop(), t.executeCommands(this.id, ni.tab(i.cursorConfig, i.model, i.getCursorStates().map((s) => s.modelState.selection))), t.pushUndoStop();
    }
  }()), r.DeleteLeft = se(new class extends e {
    constructor() {
      super({
        id: "deleteLeft",
        precondition: void 0,
        kbOpts: {
          weight: mt,
          kbExpr: x.textInputFocus,
          primary: 1,
          secondary: [
            1025
            /* KeyCode.Backspace */
          ],
          mac: { primary: 1, secondary: [
            1025,
            294,
            257
            /* KeyCode.Backspace */
          ] }
        }
      });
    }
    runCoreEditingCommand(t, i, n) {
      const [s, o] = yu.deleteLeft(i.getPrevEditOperationType(), i.cursorConfig, i.model, i.getCursorStates().map((a) => a.modelState.selection), i.getCursorAutoClosedCharacters());
      s && t.pushUndoStop(), t.executeCommands(this.id, o), i.setPrevEditOperationType(
        2
        /* EditOperationType.DeletingLeft */
      );
    }
  }()), r.DeleteRight = se(new class extends e {
    constructor() {
      super({
        id: "deleteRight",
        precondition: void 0,
        kbOpts: {
          weight: mt,
          kbExpr: x.textInputFocus,
          primary: 20,
          mac: { primary: 20, secondary: [
            290,
            276
            /* KeyCode.Delete */
          ] }
        }
      });
    }
    runCoreEditingCommand(t, i, n) {
      const [s, o] = yu.deleteRight(i.getPrevEditOperationType(), i.cursorConfig, i.model, i.getCursorStates().map((a) => a.modelState.selection));
      s && t.pushUndoStop(), t.executeCommands(this.id, o), i.setPrevEditOperationType(
        3
        /* EditOperationType.DeletingRight */
      );
    }
  }()), r.Undo = new class extends Jx {
    constructor() {
      super(sV);
    }
    runDOMCommand(t) {
      t.ownerDocument.execCommand("undo");
    }
    runEditorCommand(t, i, n) {
      if (!(!i.hasModel() || i.getOption(
        91
        /* EditorOption.readOnly */
      ) === !0))
        return i.getModel().undo();
    }
  }(), r.Redo = new class extends Jx {
    constructor() {
      super(oV);
    }
    runDOMCommand(t) {
      t.ownerDocument.execCommand("redo");
    }
    runEditorCommand(t, i, n) {
      if (!(!i.hasModel() || i.getOption(
        91
        /* EditorOption.readOnly */
      ) === !0))
        return i.getModel().redo();
    }
  }();
})(Cf || (Cf = {}));
class LP extends _0 {
  constructor(e, t, i) {
    super({
      id: e,
      precondition: void 0,
      metadata: i
    }), this._handlerId = t;
  }
  runCommand(e, t) {
    const i = e.get(ht).getFocusedCodeEditor();
    i && i.trigger("keyboard", this._handlerId, t);
  }
}
function tg(r, e) {
  yP(new LP("default:" + r, r)), yP(new LP(r, r, e));
}
tg("type", {
  description: "Type",
  args: [{
    name: "args",
    schema: {
      type: "object",
      required: ["text"],
      properties: {
        text: {
          type: "string"
        }
      }
    }
  }]
});
tg(
  "replacePreviousChar"
  /* Handler.ReplacePreviousChar */
);
tg(
  "compositionType"
  /* Handler.CompositionType */
);
tg(
  "compositionStart"
  /* Handler.CompositionStart */
);
tg(
  "compositionEnd"
  /* Handler.CompositionEnd */
);
tg(
  "paste"
  /* Handler.Paste */
);
tg(
  "cut"
  /* Handler.Cut */
);
class MZ {
  constructor(e, t, i, n) {
    this.configuration = e, this.viewModel = t, this.userInputEvents = i, this.commandDelegate = n;
  }
  paste(e, t, i, n) {
    this.commandDelegate.paste(e, t, i, n);
  }
  type(e) {
    this.commandDelegate.type(e);
  }
  compositionType(e, t, i, n) {
    this.commandDelegate.compositionType(e, t, i, n);
  }
  compositionStart() {
    this.commandDelegate.startComposition();
  }
  compositionEnd() {
    this.commandDelegate.endComposition();
  }
  cut() {
    this.commandDelegate.cut();
  }
  setSelection(e) {
    Ji.SetSelection.runCoreEditorCommand(this.viewModel, {
      source: "keyboard",
      selection: e
    });
  }
  _validateViewColumn(e) {
    const t = this.viewModel.getLineMinColumn(e.lineNumber);
    return e.column < t ? new A(e.lineNumber, t) : e;
  }
  _hasMulticursorModifier(e) {
    switch (this.configuration.options.get(
      78
      /* EditorOption.multiCursorModifier */
    )) {
      case "altKey":
        return e.altKey;
      case "ctrlKey":
        return e.ctrlKey;
      case "metaKey":
        return e.metaKey;
      default:
        return !1;
    }
  }
  _hasNonMulticursorModifier(e) {
    switch (this.configuration.options.get(
      78
      /* EditorOption.multiCursorModifier */
    )) {
      case "altKey":
        return e.ctrlKey || e.metaKey;
      case "ctrlKey":
        return e.altKey || e.metaKey;
      case "metaKey":
        return e.ctrlKey || e.altKey;
      default:
        return !1;
    }
  }
  dispatchMouse(e) {
    const t = this.configuration.options, i = os && t.get(
      107
      /* EditorOption.selectionClipboard */
    ), n = t.get(
      22
      /* EditorOption.columnSelection */
    );
    e.middleButton && !i ? this._columnSelect(e.position, e.mouseColumn, e.inSelectionMode) : e.startedOnLineNumbers ? this._hasMulticursorModifier(e) ? e.inSelectionMode ? this._lastCursorLineSelect(e.position, e.revealType) : this._createCursor(e.position, !0) : e.inSelectionMode ? this._lineSelectDrag(e.position, e.revealType) : this._lineSelect(e.position, e.revealType) : e.mouseDownCount >= 4 ? this._selectAll() : e.mouseDownCount === 3 ? this._hasMulticursorModifier(e) ? e.inSelectionMode ? this._lastCursorLineSelectDrag(e.position, e.revealType) : this._lastCursorLineSelect(e.position, e.revealType) : e.inSelectionMode ? this._lineSelectDrag(e.position, e.revealType) : this._lineSelect(e.position, e.revealType) : e.mouseDownCount === 2 ? e.onInjectedText || (this._hasMulticursorModifier(e) ? this._lastCursorWordSelect(e.position, e.revealType) : e.inSelectionMode ? this._wordSelectDrag(e.position, e.revealType) : this._wordSelect(e.position, e.revealType)) : this._hasMulticursorModifier(e) ? this._hasNonMulticursorModifier(e) || (e.shiftKey ? this._columnSelect(e.position, e.mouseColumn, !0) : e.inSelectionMode ? this._lastCursorMoveToSelect(e.position, e.revealType) : this._createCursor(e.position, !1)) : e.inSelectionMode ? e.altKey ? this._columnSelect(e.position, e.mouseColumn, !0) : n ? this._columnSelect(e.position, e.mouseColumn, !0) : this._moveToSelect(e.position, e.revealType) : this.moveTo(e.position, e.revealType);
  }
  _usualArgs(e, t) {
    return e = this._validateViewColumn(e), {
      source: "mouse",
      position: this._convertViewToModelPosition(e),
      viewPosition: e,
      revealType: t
    };
  }
  moveTo(e, t) {
    Ji.MoveTo.runCoreEditorCommand(this.viewModel, this._usualArgs(e, t));
  }
  _moveToSelect(e, t) {
    Ji.MoveToSelect.runCoreEditorCommand(this.viewModel, this._usualArgs(e, t));
  }
  _columnSelect(e, t, i) {
    e = this._validateViewColumn(e), Ji.ColumnSelect.runCoreEditorCommand(this.viewModel, {
      source: "mouse",
      position: this._convertViewToModelPosition(e),
      viewPosition: e,
      mouseColumn: t,
      doColumnSelect: i
    });
  }
  _createCursor(e, t) {
    e = this._validateViewColumn(e), Ji.CreateCursor.runCoreEditorCommand(this.viewModel, {
      source: "mouse",
      position: this._convertViewToModelPosition(e),
      viewPosition: e,
      wholeLine: t
    });
  }
  _lastCursorMoveToSelect(e, t) {
    Ji.LastCursorMoveToSelect.runCoreEditorCommand(this.viewModel, this._usualArgs(e, t));
  }
  _wordSelect(e, t) {
    Ji.WordSelect.runCoreEditorCommand(this.viewModel, this._usualArgs(e, t));
  }
  _wordSelectDrag(e, t) {
    Ji.WordSelectDrag.runCoreEditorCommand(this.viewModel, this._usualArgs(e, t));
  }
  _lastCursorWordSelect(e, t) {
    Ji.LastCursorWordSelect.runCoreEditorCommand(this.viewModel, this._usualArgs(e, t));
  }
  _lineSelect(e, t) {
    Ji.LineSelect.runCoreEditorCommand(this.viewModel, this._usualArgs(e, t));
  }
  _lineSelectDrag(e, t) {
    Ji.LineSelectDrag.runCoreEditorCommand(this.viewModel, this._usualArgs(e, t));
  }
  _lastCursorLineSelect(e, t) {
    Ji.LastCursorLineSelect.runCoreEditorCommand(this.viewModel, this._usualArgs(e, t));
  }
  _lastCursorLineSelectDrag(e, t) {
    Ji.LastCursorLineSelectDrag.runCoreEditorCommand(this.viewModel, this._usualArgs(e, t));
  }
  _selectAll() {
    Ji.SelectAll.runCoreEditorCommand(this.viewModel, { source: "mouse" });
  }
  // ----------------------
  _convertViewToModelPosition(e) {
    return this.viewModel.coordinatesConverter.convertViewPositionToModelPosition(e);
  }
  emitKeyDown(e) {
    this.userInputEvents.emitKeyDown(e);
  }
  emitKeyUp(e) {
    this.userInputEvents.emitKeyUp(e);
  }
  emitContextMenu(e) {
    this.userInputEvents.emitContextMenu(e);
  }
  emitMouseMove(e) {
    this.userInputEvents.emitMouseMove(e);
  }
  emitMouseLeave(e) {
    this.userInputEvents.emitMouseLeave(e);
  }
  emitMouseUp(e) {
    this.userInputEvents.emitMouseUp(e);
  }
  emitMouseDown(e) {
    this.userInputEvents.emitMouseDown(e);
  }
  emitMouseDrag(e) {
    this.userInputEvents.emitMouseDrag(e);
  }
  emitMouseDrop(e) {
    this.userInputEvents.emitMouseDrop(e);
  }
  emitMouseDropCanceled() {
    this.userInputEvents.emitMouseDropCanceled();
  }
  emitMouseWheel(e) {
    this.userInputEvents.emitMouseWheel(e);
  }
}
class o2 {
  constructor(e) {
    this._createLine = e, this._set(1, []);
  }
  flush() {
    this._set(1, []);
  }
  _set(e, t) {
    this._lines = t, this._rendLineNumberStart = e;
  }
  _get() {
    return {
      rendLineNumberStart: this._rendLineNumberStart,
      lines: this._lines
    };
  }
  /**
   * @returns Inclusive line number that is inside this collection
   */
  getStartLineNumber() {
    return this._rendLineNumberStart;
  }
  /**
   * @returns Inclusive line number that is inside this collection
   */
  getEndLineNumber() {
    return this._rendLineNumberStart + this._lines.length - 1;
  }
  getCount() {
    return this._lines.length;
  }
  getLine(e) {
    const t = e - this._rendLineNumberStart;
    if (t < 0 || t >= this._lines.length)
      throw new Li("Illegal value for lineNumber");
    return this._lines[t];
  }
  /**
   * @returns Lines that were removed from this collection
   */
  onLinesDeleted(e, t) {
    if (this.getCount() === 0)
      return null;
    const i = this.getStartLineNumber(), n = this.getEndLineNumber();
    if (t < i) {
      const l = t - e + 1;
      return this._rendLineNumberStart -= l, null;
    }
    if (e > n)
      return null;
    let s = 0, o = 0;
    for (let l = i; l <= n; l++) {
      const d = l - this._rendLineNumberStart;
      e <= l && l <= t && (o === 0 ? (s = d, o = 1) : o++);
    }
    if (e < i) {
      let l = 0;
      t < i ? l = t - e + 1 : l = i - e, this._rendLineNumberStart -= l;
    }
    return this._lines.splice(s, o);
  }
  onLinesChanged(e, t) {
    const i = e + t - 1;
    if (this.getCount() === 0)
      return !1;
    const n = this.getStartLineNumber(), s = this.getEndLineNumber();
    let o = !1;
    for (let a = e; a <= i; a++)
      a >= n && a <= s && (this._lines[a - this._rendLineNumberStart].onContentChanged(), o = !0);
    return o;
  }
  onLinesInserted(e, t) {
    if (this.getCount() === 0)
      return null;
    const i = t - e + 1, n = this.getStartLineNumber(), s = this.getEndLineNumber();
    if (e <= n)
      return this._rendLineNumberStart += i, null;
    if (e > s)
      return null;
    if (i + e > s)
      return this._lines.splice(e - this._rendLineNumberStart, s - e + 1);
    const o = [];
    for (let h = 0; h < i; h++)
      o[h] = this._createLine();
    const a = e - this._rendLineNumberStart, l = this._lines.slice(0, a), d = this._lines.slice(a, this._lines.length - i), c = this._lines.slice(this._lines.length - i, this._lines.length);
    return this._lines = l.concat(o).concat(d), c;
  }
  onTokensChanged(e) {
    if (this.getCount() === 0)
      return !1;
    const t = this.getStartLineNumber(), i = this.getEndLineNumber();
    let n = !1;
    for (let s = 0, o = e.length; s < o; s++) {
      const a = e[s];
      if (a.toLineNumber < t || a.fromLineNumber > i)
        continue;
      const l = Math.max(t, a.fromLineNumber), d = Math.min(i, a.toLineNumber);
      for (let c = l; c <= d; c++) {
        const h = c - this._rendLineNumberStart;
        this._lines[h].onTokensChanged(), n = !0;
      }
    }
    return n;
  }
}
class r2 {
  constructor(e) {
    this._host = e, this.domNode = this._createDomNode(), this._linesCollection = new o2(() => this._host.createVisibleLine());
  }
  _createDomNode() {
    const e = bt(document.createElement("div"));
    return e.setClassName("view-layer"), e.setPosition("absolute"), e.domNode.setAttribute("role", "presentation"), e.domNode.setAttribute("aria-hidden", "true"), e;
  }
  // ---- begin view event handlers
  onConfigurationChanged(e) {
    return !!e.hasChanged(
      145
      /* EditorOption.layoutInfo */
    );
  }
  onFlushed(e) {
    return this._linesCollection.flush(), !0;
  }
  onLinesChanged(e) {
    return this._linesCollection.onLinesChanged(e.fromLineNumber, e.count);
  }
  onLinesDeleted(e) {
    const t = this._linesCollection.onLinesDeleted(e.fromLineNumber, e.toLineNumber);
    if (t)
      for (let i = 0, n = t.length; i < n; i++) {
        const s = t[i].getDomNode();
        s && this.domNode.domNode.removeChild(s);
      }
    return !0;
  }
  onLinesInserted(e) {
    const t = this._linesCollection.onLinesInserted(e.fromLineNumber, e.toLineNumber);
    if (t)
      for (let i = 0, n = t.length; i < n; i++) {
        const s = t[i].getDomNode();
        s && this.domNode.domNode.removeChild(s);
      }
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged;
  }
  onTokensChanged(e) {
    return this._linesCollection.onTokensChanged(e.ranges);
  }
  onZonesChanged(e) {
    return !0;
  }
  // ---- end view event handlers
  getStartLineNumber() {
    return this._linesCollection.getStartLineNumber();
  }
  getEndLineNumber() {
    return this._linesCollection.getEndLineNumber();
  }
  getVisibleLine(e) {
    return this._linesCollection.getLine(e);
  }
  renderLines(e) {
    const t = this._linesCollection._get(), i = new Pl(this.domNode.domNode, this._host, e), n = {
      rendLineNumberStart: t.rendLineNumberStart,
      lines: t.lines,
      linesLength: t.lines.length
    }, s = i.render(n, e.startLineNumber, e.endLineNumber, e.relativeVerticalOffset);
    this._linesCollection._set(s.rendLineNumberStart, s.lines);
  }
}
class Pl {
  constructor(e, t, i) {
    this.domNode = e, this.host = t, this.viewportData = i;
  }
  render(e, t, i, n) {
    const s = {
      rendLineNumberStart: e.rendLineNumberStart,
      lines: e.lines.slice(0),
      linesLength: e.linesLength
    };
    if (s.rendLineNumberStart + s.linesLength - 1 < t || i < s.rendLineNumberStart) {
      s.rendLineNumberStart = t, s.linesLength = i - t + 1, s.lines = [];
      for (let o = t; o <= i; o++)
        s.lines[o - t] = this.host.createVisibleLine();
      return this._finishRendering(s, !0, n), s;
    }
    if (this._renderUntouchedLines(s, Math.max(t - s.rendLineNumberStart, 0), Math.min(i - s.rendLineNumberStart, s.linesLength - 1), n, t), s.rendLineNumberStart > t) {
      const o = t, a = Math.min(i, s.rendLineNumberStart - 1);
      o <= a && (this._insertLinesBefore(s, o, a, n, t), s.linesLength += a - o + 1);
    } else if (s.rendLineNumberStart < t) {
      const o = Math.min(s.linesLength, t - s.rendLineNumberStart);
      o > 0 && (this._removeLinesBefore(s, o), s.linesLength -= o);
    }
    if (s.rendLineNumberStart = t, s.rendLineNumberStart + s.linesLength - 1 < i) {
      const o = s.rendLineNumberStart + s.linesLength, a = i;
      o <= a && (this._insertLinesAfter(s, o, a, n, t), s.linesLength += a - o + 1);
    } else if (s.rendLineNumberStart + s.linesLength - 1 > i) {
      const o = Math.max(0, i - s.rendLineNumberStart + 1), l = s.linesLength - 1 - o + 1;
      l > 0 && (this._removeLinesAfter(s, l), s.linesLength -= l);
    }
    return this._finishRendering(s, !1, n), s;
  }
  _renderUntouchedLines(e, t, i, n, s) {
    const o = e.rendLineNumberStart, a = e.lines;
    for (let l = t; l <= i; l++) {
      const d = o + l;
      a[l].layoutLine(d, n[d - s], this.viewportData.lineHeight);
    }
  }
  _insertLinesBefore(e, t, i, n, s) {
    const o = [];
    let a = 0;
    for (let l = t; l <= i; l++)
      o[a++] = this.host.createVisibleLine();
    e.lines = o.concat(e.lines);
  }
  _removeLinesBefore(e, t) {
    for (let i = 0; i < t; i++) {
      const n = e.lines[i].getDomNode();
      n && this.domNode.removeChild(n);
    }
    e.lines.splice(0, t);
  }
  _insertLinesAfter(e, t, i, n, s) {
    const o = [];
    let a = 0;
    for (let l = t; l <= i; l++)
      o[a++] = this.host.createVisibleLine();
    e.lines = e.lines.concat(o);
  }
  _removeLinesAfter(e, t) {
    const i = e.linesLength - t;
    for (let n = 0; n < t; n++) {
      const s = e.lines[i + n].getDomNode();
      s && this.domNode.removeChild(s);
    }
    e.lines.splice(i, t);
  }
  _finishRenderingNewLines(e, t, i, n) {
    Pl._ttPolicy && (i = Pl._ttPolicy.createHTML(i));
    const s = this.domNode.lastChild;
    t || !s ? this.domNode.innerHTML = i : s.insertAdjacentHTML("afterend", i);
    let o = this.domNode.lastChild;
    for (let a = e.linesLength - 1; a >= 0; a--) {
      const l = e.lines[a];
      n[a] && (l.setDomNode(o), o = o.previousSibling);
    }
  }
  _finishRenderingInvalidLines(e, t, i) {
    const n = document.createElement("div");
    Pl._ttPolicy && (t = Pl._ttPolicy.createHTML(t)), n.innerHTML = t;
    for (let s = 0; s < e.linesLength; s++) {
      const o = e.lines[s];
      if (i[s]) {
        const a = n.firstChild, l = o.getDomNode();
        l.parentNode.replaceChild(a, l), o.setDomNode(a);
      }
    }
  }
  _finishRendering(e, t, i) {
    const n = Pl._sb, s = e.linesLength, o = e.lines, a = e.rendLineNumberStart, l = [];
    {
      n.reset();
      let d = !1;
      for (let c = 0; c < s; c++) {
        const h = o[c];
        l[c] = !1, !(h.getDomNode() || !h.renderLine(c + a, i[c], this.viewportData.lineHeight, this.viewportData, n)) && (l[c] = !0, d = !0);
      }
      d && this._finishRenderingNewLines(e, t, n.build(), l);
    }
    {
      n.reset();
      let d = !1;
      const c = [];
      for (let h = 0; h < s; h++) {
        const u = o[h];
        c[h] = !1, !(l[h] || !u.renderLine(h + a, i[h], this.viewportData.lineHeight, this.viewportData, n)) && (c[h] = !0, d = !0);
      }
      d && this._finishRenderingInvalidLines(e, n.build(), c);
    }
  }
}
Pl._ttPolicy = wd("editorViewLayer", { createHTML: (r) => r });
Pl._sb = new Tp(1e5);
class a2 extends Gs {
  constructor(e) {
    super(e), this._visibleLines = new r2(this), this.domNode = this._visibleLines.domNode;
    const i = this._context.configuration.options.get(
      50
      /* EditorOption.fontInfo */
    );
    _n(this.domNode, i), this._dynamicOverlays = [], this._isFocused = !1, this.domNode.setClassName("view-overlays");
  }
  shouldRender() {
    if (super.shouldRender())
      return !0;
    for (let e = 0, t = this._dynamicOverlays.length; e < t; e++)
      if (this._dynamicOverlays[e].shouldRender())
        return !0;
    return !1;
  }
  dispose() {
    super.dispose();
    for (let e = 0, t = this._dynamicOverlays.length; e < t; e++)
      this._dynamicOverlays[e].dispose();
    this._dynamicOverlays = [];
  }
  getDomNode() {
    return this.domNode;
  }
  // ---- begin IVisibleLinesHost
  createVisibleLine() {
    return new RZ(this._dynamicOverlays);
  }
  // ---- end IVisibleLinesHost
  addDynamicOverlay(e) {
    this._dynamicOverlays.push(e);
  }
  // ----- event handlers
  onConfigurationChanged(e) {
    this._visibleLines.onConfigurationChanged(e);
    const i = this._context.configuration.options.get(
      50
      /* EditorOption.fontInfo */
    );
    return _n(this.domNode, i), !0;
  }
  onFlushed(e) {
    return this._visibleLines.onFlushed(e);
  }
  onFocusChanged(e) {
    return this._isFocused = e.isFocused, !0;
  }
  onLinesChanged(e) {
    return this._visibleLines.onLinesChanged(e);
  }
  onLinesDeleted(e) {
    return this._visibleLines.onLinesDeleted(e);
  }
  onLinesInserted(e) {
    return this._visibleLines.onLinesInserted(e);
  }
  onScrollChanged(e) {
    return this._visibleLines.onScrollChanged(e) || !0;
  }
  onTokensChanged(e) {
    return this._visibleLines.onTokensChanged(e);
  }
  onZonesChanged(e) {
    return this._visibleLines.onZonesChanged(e);
  }
  // ----- end event handlers
  prepareRender(e) {
    const t = this._dynamicOverlays.filter((i) => i.shouldRender());
    for (let i = 0, n = t.length; i < n; i++) {
      const s = t[i];
      s.prepareRender(e), s.onDidRender();
    }
  }
  render(e) {
    this._viewOverlaysRender(e), this.domNode.toggleClassName("focused", this._isFocused);
  }
  _viewOverlaysRender(e) {
    this._visibleLines.renderLines(e.viewportData);
  }
}
class RZ {
  constructor(e) {
    this._dynamicOverlays = e, this._domNode = null, this._renderedContent = null;
  }
  getDomNode() {
    return this._domNode ? this._domNode.domNode : null;
  }
  setDomNode(e) {
    this._domNode = bt(e);
  }
  onContentChanged() {
  }
  onTokensChanged() {
  }
  renderLine(e, t, i, n, s) {
    let o = "";
    for (let a = 0, l = this._dynamicOverlays.length; a < l; a++) {
      const d = this._dynamicOverlays[a];
      o += d.render(n.startLineNumber, e);
    }
    return this._renderedContent === o ? !1 : (this._renderedContent = o, s.appendString('<div style="top:'), s.appendString(String(t)), s.appendString("px;height:"), s.appendString(String(i)), s.appendString('px;">'), s.appendString(o), s.appendString("</div>"), !0);
  }
  layoutLine(e, t, i) {
    this._domNode && (this._domNode.setTop(t), this._domNode.setHeight(i));
  }
}
class AZ extends a2 {
  constructor(e) {
    super(e);
    const i = this._context.configuration.options.get(
      145
      /* EditorOption.layoutInfo */
    );
    this._contentWidth = i.contentWidth, this.domNode.setHeight(0);
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    const i = this._context.configuration.options.get(
      145
      /* EditorOption.layoutInfo */
    );
    return this._contentWidth = i.contentWidth, super.onConfigurationChanged(e) || !0;
  }
  onScrollChanged(e) {
    return super.onScrollChanged(e) || e.scrollWidthChanged;
  }
  // --- end event handlers
  _viewOverlaysRender(e) {
    super._viewOverlaysRender(e), this.domNode.setWidth(Math.max(e.scrollWidth, this._contentWidth));
  }
}
class PZ extends a2 {
  constructor(e) {
    super(e);
    const t = this._context.configuration.options, i = t.get(
      145
      /* EditorOption.layoutInfo */
    );
    this._contentLeft = i.contentLeft, this.domNode.setClassName("margin-view-overlays"), this.domNode.setWidth(1), _n(this.domNode, t.get(
      50
      /* EditorOption.fontInfo */
    ));
  }
  onConfigurationChanged(e) {
    const t = this._context.configuration.options;
    _n(this.domNode, t.get(
      50
      /* EditorOption.fontInfo */
    ));
    const i = t.get(
      145
      /* EditorOption.layoutInfo */
    );
    return this._contentLeft = i.contentLeft, super.onConfigurationChanged(e) || !0;
  }
  onScrollChanged(e) {
    return super.onScrollChanged(e) || e.scrollHeightChanged;
  }
  _viewOverlaysRender(e) {
    super._viewOverlaysRender(e);
    const t = Math.min(e.scrollHeight, 1e6);
    this.domNode.setHeight(t), this.domNode.setWidth(this._contentLeft);
  }
}
class M0 {
  constructor(e) {
    this.onKeyDown = null, this.onKeyUp = null, this.onContextMenu = null, this.onMouseMove = null, this.onMouseLeave = null, this.onMouseDown = null, this.onMouseUp = null, this.onMouseDrag = null, this.onMouseDrop = null, this.onMouseDropCanceled = null, this.onMouseWheel = null, this._coordinatesConverter = e;
  }
  emitKeyDown(e) {
    var t;
    (t = this.onKeyDown) === null || t === void 0 || t.call(this, e);
  }
  emitKeyUp(e) {
    var t;
    (t = this.onKeyUp) === null || t === void 0 || t.call(this, e);
  }
  emitContextMenu(e) {
    var t;
    (t = this.onContextMenu) === null || t === void 0 || t.call(this, this._convertViewToModelMouseEvent(e));
  }
  emitMouseMove(e) {
    var t;
    (t = this.onMouseMove) === null || t === void 0 || t.call(this, this._convertViewToModelMouseEvent(e));
  }
  emitMouseLeave(e) {
    var t;
    (t = this.onMouseLeave) === null || t === void 0 || t.call(this, this._convertViewToModelMouseEvent(e));
  }
  emitMouseDown(e) {
    var t;
    (t = this.onMouseDown) === null || t === void 0 || t.call(this, this._convertViewToModelMouseEvent(e));
  }
  emitMouseUp(e) {
    var t;
    (t = this.onMouseUp) === null || t === void 0 || t.call(this, this._convertViewToModelMouseEvent(e));
  }
  emitMouseDrag(e) {
    var t;
    (t = this.onMouseDrag) === null || t === void 0 || t.call(this, this._convertViewToModelMouseEvent(e));
  }
  emitMouseDrop(e) {
    var t;
    (t = this.onMouseDrop) === null || t === void 0 || t.call(this, this._convertViewToModelMouseEvent(e));
  }
  emitMouseDropCanceled() {
    var e;
    (e = this.onMouseDropCanceled) === null || e === void 0 || e.call(this);
  }
  emitMouseWheel(e) {
    var t;
    (t = this.onMouseWheel) === null || t === void 0 || t.call(this, e);
  }
  _convertViewToModelMouseEvent(e) {
    return e.target ? {
      event: e.event,
      target: this._convertViewToModelMouseTarget(e.target)
    } : e;
  }
  _convertViewToModelMouseTarget(e) {
    return M0.convertViewToModelMouseTarget(e, this._coordinatesConverter);
  }
  static convertViewToModelMouseTarget(e, t) {
    const i = { ...e };
    return i.position && (i.position = t.convertViewPositionToModelPosition(i.position)), i.range && (i.range = t.convertViewRangeToModelRange(i.range)), (i.type === 5 || i.type === 8) && (i.detail = this.convertViewToModelViewZoneData(i.detail, t)), i;
  }
  static convertViewToModelViewZoneData(e, t) {
    return {
      viewZoneId: e.viewZoneId,
      positionBefore: e.positionBefore ? t.convertViewPositionToModelPosition(e.positionBefore) : e.positionBefore,
      positionAfter: e.positionAfter ? t.convertViewPositionToModelPosition(e.positionAfter) : e.positionAfter,
      position: t.convertViewPositionToModelPosition(e.position),
      afterLineNumber: t.convertViewPositionToModelPosition(new A(e.afterLineNumber, 1)).lineNumber
    };
  }
}
class OZ extends Gs {
  constructor(e) {
    super(e), this.blocks = [], this.contentWidth = -1, this.contentLeft = 0, this.domNode = bt(document.createElement("div")), this.domNode.setAttribute("role", "presentation"), this.domNode.setAttribute("aria-hidden", "true"), this.domNode.setClassName("blockDecorations-container"), this.update();
  }
  update() {
    let e = !1;
    const i = this._context.configuration.options.get(
      145
      /* EditorOption.layoutInfo */
    ), n = i.contentWidth - i.verticalScrollbarWidth;
    this.contentWidth !== n && (this.contentWidth = n, e = !0);
    const s = i.contentLeft;
    return this.contentLeft !== s && (this.contentLeft = s, e = !0), e;
  }
  dispose() {
    super.dispose();
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    return this.update();
  }
  onScrollChanged(e) {
    return e.scrollTopChanged || e.scrollLeftChanged;
  }
  onDecorationsChanged(e) {
    return !0;
  }
  onZonesChanged(e) {
    return !0;
  }
  // --- end event handlers
  prepareRender(e) {
  }
  render(e) {
    var t;
    let i = 0;
    const n = e.getDecorationsInViewport();
    for (const s of n) {
      if (!s.options.blockClassName)
        continue;
      let o = this.blocks[i];
      o || (o = this.blocks[i] = bt(document.createElement("div")), this.domNode.appendChild(o));
      let a, l;
      s.options.blockIsAfterEnd ? (a = e.getVerticalOffsetAfterLineNumber(s.range.endLineNumber, !1), l = e.getVerticalOffsetAfterLineNumber(s.range.endLineNumber, !0)) : (a = e.getVerticalOffsetForLineNumber(s.range.startLineNumber, !0), l = s.range.isEmpty() && !s.options.blockDoesNotCollapse ? e.getVerticalOffsetForLineNumber(s.range.startLineNumber, !1) : e.getVerticalOffsetAfterLineNumber(s.range.endLineNumber, !0));
      const [d, c, h, u] = (t = s.options.blockPadding) !== null && t !== void 0 ? t : [0, 0, 0, 0];
      o.setClassName("blockDecorations-block " + s.options.blockClassName), o.setLeft(this.contentLeft - u), o.setWidth(this.contentWidth + u + c), o.setTop(a - e.scrollTop - d), o.setHeight(l - a + d + h), i++;
    }
    for (let s = i; s < this.blocks.length; s++)
      this.blocks[s].domNode.remove();
    this.blocks.length = i;
  }
}
class FZ extends Gs {
  constructor(e, t) {
    super(e), this._viewDomNode = t, this._widgets = {}, this.domNode = bt(document.createElement("div")), Jr.write(
      this.domNode,
      1
      /* PartFingerprint.ContentWidgets */
    ), this.domNode.setClassName("contentWidgets"), this.domNode.setPosition("absolute"), this.domNode.setTop(0), this.overflowingContentWidgetsDomNode = bt(document.createElement("div")), Jr.write(
      this.overflowingContentWidgetsDomNode,
      2
      /* PartFingerprint.OverflowingContentWidgets */
    ), this.overflowingContentWidgetsDomNode.setClassName("overflowingContentWidgets");
  }
  dispose() {
    super.dispose(), this._widgets = {};
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    const t = Object.keys(this._widgets);
    for (const i of t)
      this._widgets[i].onConfigurationChanged(e);
    return !0;
  }
  onDecorationsChanged(e) {
    return !0;
  }
  onFlushed(e) {
    return !0;
  }
  onLineMappingChanged(e) {
    return this._updateAnchorsViewPositions(), !0;
  }
  onLinesChanged(e) {
    return this._updateAnchorsViewPositions(), !0;
  }
  onLinesDeleted(e) {
    return this._updateAnchorsViewPositions(), !0;
  }
  onLinesInserted(e) {
    return this._updateAnchorsViewPositions(), !0;
  }
  onScrollChanged(e) {
    return !0;
  }
  onZonesChanged(e) {
    return !0;
  }
  // ---- end view event handlers
  _updateAnchorsViewPositions() {
    const e = Object.keys(this._widgets);
    for (const t of e)
      this._widgets[t].updateAnchorViewPosition();
  }
  addWidget(e) {
    const t = new WZ(this._context, this._viewDomNode, e);
    this._widgets[t.id] = t, t.allowEditorOverflow ? this.overflowingContentWidgetsDomNode.appendChild(t.domNode) : this.domNode.appendChild(t.domNode), this.setShouldRender();
  }
  setWidgetPosition(e, t, i, n, s) {
    this._widgets[e.getId()].setPosition(t, i, n, s), this.setShouldRender();
  }
  removeWidget(e) {
    const t = e.getId();
    if (this._widgets.hasOwnProperty(t)) {
      const i = this._widgets[t];
      delete this._widgets[t];
      const n = i.domNode.domNode;
      n.parentNode.removeChild(n), n.removeAttribute("monaco-visible-content-widget"), this.setShouldRender();
    }
  }
  shouldSuppressMouseDownOnWidget(e) {
    return this._widgets.hasOwnProperty(e) ? this._widgets[e].suppressMouseDown : !1;
  }
  onBeforeRender(e) {
    const t = Object.keys(this._widgets);
    for (const i of t)
      this._widgets[i].onBeforeRender(e);
  }
  prepareRender(e) {
    const t = Object.keys(this._widgets);
    for (const i of t)
      this._widgets[i].prepareRender(e);
  }
  render(e) {
    const t = Object.keys(this._widgets);
    for (const i of t)
      this._widgets[i].render(e);
  }
}
class WZ {
  constructor(e, t, i) {
    this._primaryAnchor = new tm(null, null), this._secondaryAnchor = new tm(null, null), this._context = e, this._viewDomNode = t, this._actual = i, this.domNode = bt(this._actual.getDomNode()), this.id = this._actual.getId(), this.allowEditorOverflow = this._actual.allowEditorOverflow || !1, this.suppressMouseDown = this._actual.suppressMouseDown || !1;
    const n = this._context.configuration.options, s = n.get(
      145
      /* EditorOption.layoutInfo */
    );
    this._fixedOverflowWidgets = n.get(
      42
      /* EditorOption.fixedOverflowWidgets */
    ), this._contentWidth = s.contentWidth, this._contentLeft = s.contentLeft, this._lineHeight = n.get(
      67
      /* EditorOption.lineHeight */
    ), this._affinity = null, this._preference = [], this._cachedDomNodeOffsetWidth = -1, this._cachedDomNodeOffsetHeight = -1, this._maxWidth = this._getMaxWidth(), this._isVisible = !1, this._renderData = null, this.domNode.setPosition(this._fixedOverflowWidgets && this.allowEditorOverflow ? "fixed" : "absolute"), this.domNode.setDisplay("none"), this.domNode.setVisibility("hidden"), this.domNode.setAttribute("widgetId", this.id), this.domNode.setMaxWidth(this._maxWidth);
  }
  onConfigurationChanged(e) {
    const t = this._context.configuration.options;
    if (this._lineHeight = t.get(
      67
      /* EditorOption.lineHeight */
    ), e.hasChanged(
      145
      /* EditorOption.layoutInfo */
    )) {
      const i = t.get(
        145
        /* EditorOption.layoutInfo */
      );
      this._contentLeft = i.contentLeft, this._contentWidth = i.contentWidth, this._maxWidth = this._getMaxWidth();
    }
  }
  updateAnchorViewPosition() {
    this._setPosition(this._affinity, this._primaryAnchor.modelPosition, this._secondaryAnchor.modelPosition);
  }
  _setPosition(e, t, i) {
    this._affinity = e, this._primaryAnchor = n(t, this._context.viewModel, this._affinity), this._secondaryAnchor = n(i, this._context.viewModel, this._affinity);
    function n(s, o, a) {
      if (!s)
        return new tm(null, null);
      const l = o.model.validatePosition(s);
      if (o.coordinatesConverter.modelPositionIsVisible(l)) {
        const d = o.coordinatesConverter.convertModelPositionToViewPosition(l, a ?? void 0);
        return new tm(s, d);
      }
      return new tm(s, null);
    }
  }
  _getMaxWidth() {
    const e = this.domNode.domNode.ownerDocument, t = e.defaultView;
    return this.allowEditorOverflow ? (t == null ? void 0 : t.innerWidth) || e.documentElement.offsetWidth || e.body.offsetWidth : this._contentWidth;
  }
  setPosition(e, t, i, n) {
    this._setPosition(n, e, t), this._preference = i, this._primaryAnchor.viewPosition && this._preference && this._preference.length > 0 ? this.domNode.setDisplay("block") : this.domNode.setDisplay("none"), this._cachedDomNodeOffsetWidth = -1, this._cachedDomNodeOffsetHeight = -1;
  }
  _layoutBoxInViewport(e, t, i, n) {
    const s = e.top, o = s, a = e.top + e.height, l = n.viewportHeight - a, d = s - i, c = o >= i, h = a, u = l >= i;
    let g = e.left;
    return g + t > n.scrollLeft + n.viewportWidth && (g = n.scrollLeft + n.viewportWidth - t), g < n.scrollLeft && (g = n.scrollLeft), { fitsAbove: c, aboveTop: d, fitsBelow: u, belowTop: h, left: g };
  }
  _layoutHorizontalSegmentInPage(e, t, i, n) {
    var s;
    const l = Math.max(15, t.left - n), d = Math.min(t.left + t.width + n, e.width - 15), h = this._viewDomNode.domNode.ownerDocument.defaultView;
    let u = t.left + i - ((s = h == null ? void 0 : h.scrollX) !== null && s !== void 0 ? s : 0);
    if (u + n > d) {
      const g = u - (d - n);
      u -= g, i -= g;
    }
    if (u < l) {
      const g = u - l;
      u -= g, i -= g;
    }
    return [i, u];
  }
  _layoutBoxInPage(e, t, i, n) {
    var s, o;
    const a = e.top - i, l = e.top + e.height, d = Ei(this._viewDomNode.domNode), c = this._viewDomNode.domNode.ownerDocument, h = c.defaultView, u = d.top + a - ((s = h == null ? void 0 : h.scrollY) !== null && s !== void 0 ? s : 0), g = d.top + l - ((o = h == null ? void 0 : h.scrollY) !== null && o !== void 0 ? o : 0), f = Rc(c.body), [m, _] = this._layoutHorizontalSegmentInPage(f, d, e.left - n.scrollLeft + this._contentLeft, t), v = 22, b = 22, C = u >= v, w = g + i <= f.height - b;
    return this._fixedOverflowWidgets ? {
      fitsAbove: C,
      aboveTop: Math.max(u, v),
      fitsBelow: w,
      belowTop: g,
      left: _
    } : { fitsAbove: C, aboveTop: a, fitsBelow: w, belowTop: l, left: m };
  }
  _prepareRenderWidgetAtExactPositionOverflowing(e) {
    return new im(e.top, e.left + this._contentLeft);
  }
  /**
   * Compute the coordinates above and below the primary and secondary anchors.
   * The content widget *must* touch the primary anchor.
   * The content widget should touch if possible the secondary anchor.
   */
  _getAnchorsCoordinates(e) {
    var t, i;
    const n = a(this._primaryAnchor.viewPosition, this._affinity, this._lineHeight), s = ((t = this._secondaryAnchor.viewPosition) === null || t === void 0 ? void 0 : t.lineNumber) === ((i = this._primaryAnchor.viewPosition) === null || i === void 0 ? void 0 : i.lineNumber) ? this._secondaryAnchor.viewPosition : null, o = a(s, this._affinity, this._lineHeight);
    return { primary: n, secondary: o };
    function a(l, d, c) {
      if (!l)
        return null;
      const h = e.visibleRangeForPosition(l);
      if (!h)
        return null;
      const u = l.column === 1 && d === 3 ? 0 : h.left, g = e.getVerticalOffsetForLineNumber(l.lineNumber) - e.scrollTop;
      return new DP(g, u, c);
    }
  }
  _reduceAnchorCoordinates(e, t, i) {
    if (!t)
      return e;
    const n = this._context.configuration.options.get(
      50
      /* EditorOption.fontInfo */
    );
    let s = t.left;
    return s < e.left ? s = Math.max(s, e.left - i + n.typicalFullwidthCharacterWidth) : s = Math.min(s, e.left + i - n.typicalFullwidthCharacterWidth), new DP(e.top, s, e.height);
  }
  _prepareRenderWidget(e) {
    if (!this._preference || this._preference.length === 0)
      return null;
    const { primary: t, secondary: i } = this._getAnchorsCoordinates(e);
    if (!t)
      return {
        kind: "offViewport",
        preserveFocus: this.domNode.domNode.contains(this.domNode.domNode.ownerDocument.activeElement)
      };
    if (this._cachedDomNodeOffsetWidth === -1 || this._cachedDomNodeOffsetHeight === -1) {
      let o = null;
      if (typeof this._actual.beforeRender == "function" && (o = ZD(this._actual.beforeRender, this._actual)), o)
        this._cachedDomNodeOffsetWidth = o.width, this._cachedDomNodeOffsetHeight = o.height;
      else {
        const l = this.domNode.domNode.getBoundingClientRect();
        this._cachedDomNodeOffsetWidth = Math.round(l.width), this._cachedDomNodeOffsetHeight = Math.round(l.height);
      }
    }
    const n = this._reduceAnchorCoordinates(t, i, this._cachedDomNodeOffsetWidth);
    let s;
    this.allowEditorOverflow ? s = this._layoutBoxInPage(n, this._cachedDomNodeOffsetWidth, this._cachedDomNodeOffsetHeight, e) : s = this._layoutBoxInViewport(n, this._cachedDomNodeOffsetWidth, this._cachedDomNodeOffsetHeight, e);
    for (let o = 1; o <= 2; o++)
      for (const a of this._preference)
        if (a === 1) {
          if (!s)
            return null;
          if (o === 2 || s.fitsAbove)
            return {
              kind: "inViewport",
              coordinate: new im(s.aboveTop, s.left),
              position: 1
              /* ContentWidgetPositionPreference.ABOVE */
            };
        } else if (a === 2) {
          if (!s)
            return null;
          if (o === 2 || s.fitsBelow)
            return {
              kind: "inViewport",
              coordinate: new im(s.belowTop, s.left),
              position: 2
              /* ContentWidgetPositionPreference.BELOW */
            };
        } else
          return this.allowEditorOverflow ? {
            kind: "inViewport",
            coordinate: this._prepareRenderWidgetAtExactPositionOverflowing(new im(n.top, n.left)),
            position: 0
            /* ContentWidgetPositionPreference.EXACT */
          } : {
            kind: "inViewport",
            coordinate: new im(n.top, n.left),
            position: 0
            /* ContentWidgetPositionPreference.EXACT */
          };
    return null;
  }
  /**
   * On this first pass, we ensure that the content widget (if it is in the viewport) has the max width set correctly.
   */
  onBeforeRender(e) {
    !this._primaryAnchor.viewPosition || !this._preference || this._primaryAnchor.viewPosition.lineNumber < e.startLineNumber || this._primaryAnchor.viewPosition.lineNumber > e.endLineNumber || this.domNode.setMaxWidth(this._maxWidth);
  }
  prepareRender(e) {
    this._renderData = this._prepareRenderWidget(e);
  }
  render(e) {
    var t;
    if (!this._renderData || this._renderData.kind === "offViewport") {
      this._isVisible && (this.domNode.removeAttribute("monaco-visible-content-widget"), this._isVisible = !1, ((t = this._renderData) === null || t === void 0 ? void 0 : t.kind) === "offViewport" && this._renderData.preserveFocus ? this.domNode.setTop(-1e3) : this.domNode.setVisibility("hidden")), typeof this._actual.afterRender == "function" && ZD(this._actual.afterRender, this._actual, null);
      return;
    }
    this.allowEditorOverflow ? (this.domNode.setTop(this._renderData.coordinate.top), this.domNode.setLeft(this._renderData.coordinate.left)) : (this.domNode.setTop(this._renderData.coordinate.top + e.scrollTop - e.bigNumbersDelta), this.domNode.setLeft(this._renderData.coordinate.left)), this._isVisible || (this.domNode.setVisibility("inherit"), this.domNode.setAttribute("monaco-visible-content-widget", "true"), this._isVisible = !0), typeof this._actual.afterRender == "function" && ZD(this._actual.afterRender, this._actual, this._renderData.position);
  }
}
class tm {
  constructor(e, t) {
    this.modelPosition = e, this.viewPosition = t;
  }
}
class im {
  constructor(e, t) {
    this.top = e, this.left = t, this._coordinateBrand = void 0;
  }
}
class DP {
  constructor(e, t, i) {
    this.top = e, this.left = t, this.height = i, this._anchorCoordinateBrand = void 0;
  }
}
function ZD(r, e, ...t) {
  try {
    return r.call(e, ...t);
  } catch {
    return null;
  }
}
class l2 extends eg {
  constructor(e) {
    super(), this._context = e;
    const t = this._context.configuration.options, i = t.get(
      145
      /* EditorOption.layoutInfo */
    );
    this._renderLineHighlight = t.get(
      96
      /* EditorOption.renderLineHighlight */
    ), this._renderLineHighlightOnlyWhenFocus = t.get(
      97
      /* EditorOption.renderLineHighlightOnlyWhenFocus */
    ), this._wordWrap = i.isViewportWrapping, this._contentLeft = i.contentLeft, this._contentWidth = i.contentWidth, this._selectionIsEmpty = !0, this._focused = !1, this._cursorLineNumbers = [1], this._selections = [new ge(1, 1, 1, 1)], this._renderData = null, this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this), super.dispose();
  }
  _readFromSelections() {
    let e = !1;
    const t = /* @__PURE__ */ new Set();
    for (const s of this._selections)
      t.add(s.positionLineNumber);
    const i = Array.from(t);
    i.sort((s, o) => s - o), ci(this._cursorLineNumbers, i) || (this._cursorLineNumbers = i, e = !0);
    const n = this._selections.every((s) => s.isEmpty());
    return this._selectionIsEmpty !== n && (this._selectionIsEmpty = n, e = !0), e;
  }
  // --- begin event handlers
  onThemeChanged(e) {
    return this._readFromSelections();
  }
  onConfigurationChanged(e) {
    const t = this._context.configuration.options, i = t.get(
      145
      /* EditorOption.layoutInfo */
    );
    return this._renderLineHighlight = t.get(
      96
      /* EditorOption.renderLineHighlight */
    ), this._renderLineHighlightOnlyWhenFocus = t.get(
      97
      /* EditorOption.renderLineHighlightOnlyWhenFocus */
    ), this._wordWrap = i.isViewportWrapping, this._contentLeft = i.contentLeft, this._contentWidth = i.contentWidth, !0;
  }
  onCursorStateChanged(e) {
    return this._selections = e.selections, this._readFromSelections();
  }
  onFlushed(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollWidthChanged || e.scrollTopChanged;
  }
  onZonesChanged(e) {
    return !0;
  }
  onFocusChanged(e) {
    return this._renderLineHighlightOnlyWhenFocus ? (this._focused = e.isFocused, !0) : !1;
  }
  // --- end event handlers
  prepareRender(e) {
    if (!this._shouldRenderThis()) {
      this._renderData = null;
      return;
    }
    const t = e.visibleRange.startLineNumber, i = e.visibleRange.endLineNumber, n = [];
    for (let o = t; o <= i; o++) {
      const a = o - t;
      n[a] = "";
    }
    if (this._wordWrap) {
      const o = this._renderOne(e, !1);
      for (const a of this._cursorLineNumbers) {
        const l = this._context.viewModel.coordinatesConverter, d = l.convertViewPositionToModelPosition(new A(a, 1)).lineNumber, c = l.convertModelPositionToViewPosition(new A(d, 1)).lineNumber, h = l.convertModelPositionToViewPosition(new A(d, this._context.viewModel.model.getLineMaxColumn(d))).lineNumber, u = Math.max(c, t), g = Math.min(h, i);
        for (let f = u; f <= g; f++) {
          const m = f - t;
          n[m] = o;
        }
      }
    }
    const s = this._renderOne(e, !0);
    for (const o of this._cursorLineNumbers) {
      if (o < t || o > i)
        continue;
      const a = o - t;
      n[a] = s;
    }
    this._renderData = n;
  }
  render(e, t) {
    if (!this._renderData)
      return "";
    const i = t - e;
    return i >= this._renderData.length ? "" : this._renderData[i];
  }
  _shouldRenderInMargin() {
    return (this._renderLineHighlight === "gutter" || this._renderLineHighlight === "all") && (!this._renderLineHighlightOnlyWhenFocus || this._focused);
  }
  _shouldRenderInContent() {
    return (this._renderLineHighlight === "line" || this._renderLineHighlight === "all") && this._selectionIsEmpty && (!this._renderLineHighlightOnlyWhenFocus || this._focused);
  }
}
class BZ extends l2 {
  _renderOne(e, t) {
    return `<div class="${"current-line" + (this._shouldRenderInMargin() ? " current-line-both" : "") + (t ? " current-line-exact" : "")}" style="width:${Math.max(e.scrollWidth, this._contentWidth)}px;"></div>`;
  }
  _shouldRenderThis() {
    return this._shouldRenderInContent();
  }
  _shouldRenderOther() {
    return this._shouldRenderInMargin();
  }
}
class HZ extends l2 {
  _renderOne(e, t) {
    return `<div class="${"current-line" + (this._shouldRenderInMargin() ? " current-line-margin" : "") + (this._shouldRenderOther() ? " current-line-margin-both" : "") + (this._shouldRenderInMargin() && t ? " current-line-exact-margin" : "")}" style="width:${this._contentLeft}px"></div>`;
  }
  _shouldRenderThis() {
    return !0;
  }
  _shouldRenderOther() {
    return this._shouldRenderInContent();
  }
}
Ho((r, e) => {
  const t = r.getColor(KV);
  if (t && (e.addRule(`.monaco-editor .view-overlays .current-line { background-color: ${t}; }`), e.addRule(`.monaco-editor .margin-view-overlays .current-line-margin { background-color: ${t}; border: none; }`)), !t || t.isTransparent() || r.defines(bP)) {
    const i = r.getColor(bP);
    i && (e.addRule(`.monaco-editor .view-overlays .current-line-exact { border: 2px solid ${i}; }`), e.addRule(`.monaco-editor .margin-view-overlays .current-line-exact-margin { border: 2px solid ${i}; }`), jr(r.type) && (e.addRule(".monaco-editor .view-overlays .current-line-exact { border-width: 1px; }"), e.addRule(".monaco-editor .margin-view-overlays .current-line-exact-margin { border-width: 1px; }")));
  }
});
class VZ extends eg {
  constructor(e) {
    super(), this._context = e;
    const t = this._context.configuration.options;
    this._typicalHalfwidthCharacterWidth = t.get(
      50
      /* EditorOption.fontInfo */
    ).typicalHalfwidthCharacterWidth, this._renderResult = null, this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this), this._renderResult = null, super.dispose();
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    const t = this._context.configuration.options;
    return this._typicalHalfwidthCharacterWidth = t.get(
      50
      /* EditorOption.fontInfo */
    ).typicalHalfwidthCharacterWidth, !0;
  }
  onDecorationsChanged(e) {
    return !0;
  }
  onFlushed(e) {
    return !0;
  }
  onLinesChanged(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged || e.scrollWidthChanged;
  }
  onZonesChanged(e) {
    return !0;
  }
  // --- end event handlers
  prepareRender(e) {
    const t = e.getDecorationsInViewport();
    let i = [], n = 0;
    for (let l = 0, d = t.length; l < d; l++) {
      const c = t[l];
      c.options.className && (i[n++] = c);
    }
    i = i.sort((l, d) => {
      if (l.options.zIndex < d.options.zIndex)
        return -1;
      if (l.options.zIndex > d.options.zIndex)
        return 1;
      const c = l.options.className, h = d.options.className;
      return c < h ? -1 : c > h ? 1 : L.compareRangesUsingStarts(l.range, d.range);
    });
    const s = e.visibleRange.startLineNumber, o = e.visibleRange.endLineNumber, a = [];
    for (let l = s; l <= o; l++) {
      const d = l - s;
      a[d] = "";
    }
    this._renderWholeLineDecorations(e, i, a), this._renderNormalDecorations(e, i, a), this._renderResult = a;
  }
  _renderWholeLineDecorations(e, t, i) {
    const n = e.visibleRange.startLineNumber, s = e.visibleRange.endLineNumber;
    for (let o = 0, a = t.length; o < a; o++) {
      const l = t[o];
      if (!l.options.isWholeLine)
        continue;
      const d = '<div class="cdr ' + l.options.className + '" style="left:0;width:100%;"></div>', c = Math.max(l.range.startLineNumber, n), h = Math.min(l.range.endLineNumber, s);
      for (let u = c; u <= h; u++) {
        const g = u - n;
        i[g] += d;
      }
    }
  }
  _renderNormalDecorations(e, t, i) {
    var n;
    const s = e.visibleRange.startLineNumber;
    let o = null, a = !1, l = null, d = !1;
    for (let c = 0, h = t.length; c < h; c++) {
      const u = t[c];
      if (u.options.isWholeLine)
        continue;
      const g = u.options.className, f = !!u.options.showIfCollapsed;
      let m = u.range;
      if (f && m.endColumn === 1 && m.endLineNumber !== m.startLineNumber && (m = new L(m.startLineNumber, m.startColumn, m.endLineNumber - 1, this._context.viewModel.getLineMaxColumn(m.endLineNumber - 1))), o === g && a === f && L.areIntersectingOrTouching(l, m)) {
        l = L.plusRange(l, m);
        continue;
      }
      o !== null && this._renderNormalDecoration(e, l, o, d, a, s, i), o = g, a = f, l = m, d = (n = u.options.shouldFillLineOnLineBreak) !== null && n !== void 0 ? n : !1;
    }
    o !== null && this._renderNormalDecoration(e, l, o, d, a, s, i);
  }
  _renderNormalDecoration(e, t, i, n, s, o, a) {
    const l = e.linesVisibleRangesForRange(
      t,
      /*TODO@Alex*/
      i === "findMatch"
    );
    if (l)
      for (let d = 0, c = l.length; d < c; d++) {
        const h = l[d];
        if (h.outsideRenderedLine)
          continue;
        const u = h.lineNumber - o;
        if (s && h.ranges.length === 1) {
          const g = h.ranges[0];
          if (g.width < this._typicalHalfwidthCharacterWidth) {
            const f = Math.round(g.left + g.width / 2), m = Math.max(0, Math.round(f - this._typicalHalfwidthCharacterWidth / 2));
            h.ranges[0] = new x0(m, this._typicalHalfwidthCharacterWidth);
          }
        }
        for (let g = 0, f = h.ranges.length; g < f; g++) {
          const m = n && h.continuesOnNextLine && f === 1, _ = h.ranges[g], v = '<div class="cdr ' + i + '" style="left:' + String(_.left) + "px;width:" + (m ? "100%;" : String(_.width) + "px;") + '"></div>';
          a[u] += v;
        }
      }
  }
  render(e, t) {
    if (!this._renderResult)
      return "";
    const i = t - e;
    return i < 0 || i >= this._renderResult.length ? "" : this._renderResult[i];
  }
}
class zZ extends Gs {
  constructor(e, t, i, n) {
    super(e);
    const s = this._context.configuration.options, o = s.get(
      103
      /* EditorOption.scrollbar */
    ), a = s.get(
      75
      /* EditorOption.mouseWheelScrollSensitivity */
    ), l = s.get(
      40
      /* EditorOption.fastScrollSensitivity */
    ), d = s.get(
      106
      /* EditorOption.scrollPredominantAxis */
    ), c = {
      listenOnDomNode: i.domNode,
      className: "editor-scrollable " + Qx(e.theme.type),
      useShadows: !1,
      lazyRender: !0,
      vertical: o.vertical,
      horizontal: o.horizontal,
      verticalHasArrows: o.verticalHasArrows,
      horizontalHasArrows: o.horizontalHasArrows,
      verticalScrollbarSize: o.verticalScrollbarSize,
      verticalSliderSize: o.verticalSliderSize,
      horizontalScrollbarSize: o.horizontalScrollbarSize,
      horizontalSliderSize: o.horizontalSliderSize,
      handleMouseWheel: o.handleMouseWheel,
      alwaysConsumeMouseWheel: o.alwaysConsumeMouseWheel,
      arrowSize: o.arrowSize,
      mouseWheelScrollSensitivity: a,
      fastScrollSensitivity: l,
      scrollPredominantAxis: d,
      scrollByPage: o.scrollByPage
    };
    this.scrollbar = this._register(new I0(t.domNode, c, this._context.viewLayout.getScrollable())), Jr.write(
      this.scrollbar.getDomNode(),
      6
      /* PartFingerprint.ScrollableElement */
    ), this.scrollbarDomNode = bt(this.scrollbar.getDomNode()), this.scrollbarDomNode.setPosition("absolute"), this._setLayout();
    const h = (u, g, f) => {
      const m = {};
      {
        const _ = u.scrollTop;
        _ && (m.scrollTop = this._context.viewLayout.getCurrentScrollTop() + _, u.scrollTop = 0);
      }
      if (f) {
        const _ = u.scrollLeft;
        _ && (m.scrollLeft = this._context.viewLayout.getCurrentScrollLeft() + _, u.scrollLeft = 0);
      }
      this._context.viewModel.viewLayout.setScrollPosition(
        m,
        1
        /* ScrollType.Immediate */
      );
    };
    this._register(W(i.domNode, "scroll", (u) => h(i.domNode, !0, !0))), this._register(W(t.domNode, "scroll", (u) => h(t.domNode, !0, !1))), this._register(W(n.domNode, "scroll", (u) => h(n.domNode, !0, !1))), this._register(W(this.scrollbarDomNode.domNode, "scroll", (u) => h(this.scrollbarDomNode.domNode, !0, !1)));
  }
  dispose() {
    super.dispose();
  }
  _setLayout() {
    const e = this._context.configuration.options, t = e.get(
      145
      /* EditorOption.layoutInfo */
    );
    this.scrollbarDomNode.setLeft(t.contentLeft), e.get(
      73
      /* EditorOption.minimap */
    ).side === "right" ? this.scrollbarDomNode.setWidth(t.contentWidth + t.minimap.minimapWidth) : this.scrollbarDomNode.setWidth(t.contentWidth), this.scrollbarDomNode.setHeight(t.height);
  }
  getOverviewRulerLayoutInfo() {
    return this.scrollbar.getOverviewRulerLayoutInfo();
  }
  getDomNode() {
    return this.scrollbarDomNode;
  }
  delegateVerticalScrollbarPointerDown(e) {
    this.scrollbar.delegateVerticalScrollbarPointerDown(e);
  }
  delegateScrollFromMouseWheelEvent(e) {
    this.scrollbar.delegateScrollFromMouseWheelEvent(e);
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    if (e.hasChanged(
      103
      /* EditorOption.scrollbar */
    ) || e.hasChanged(
      75
      /* EditorOption.mouseWheelScrollSensitivity */
    ) || e.hasChanged(
      40
      /* EditorOption.fastScrollSensitivity */
    )) {
      const t = this._context.configuration.options, i = t.get(
        103
        /* EditorOption.scrollbar */
      ), n = t.get(
        75
        /* EditorOption.mouseWheelScrollSensitivity */
      ), s = t.get(
        40
        /* EditorOption.fastScrollSensitivity */
      ), o = t.get(
        106
        /* EditorOption.scrollPredominantAxis */
      ), a = {
        vertical: i.vertical,
        horizontal: i.horizontal,
        verticalScrollbarSize: i.verticalScrollbarSize,
        horizontalScrollbarSize: i.horizontalScrollbarSize,
        scrollByPage: i.scrollByPage,
        handleMouseWheel: i.handleMouseWheel,
        mouseWheelScrollSensitivity: n,
        fastScrollSensitivity: s,
        scrollPredominantAxis: o
      };
      this.scrollbar.updateOptions(a);
    }
    return e.hasChanged(
      145
      /* EditorOption.layoutInfo */
    ) && this._setLayout(), !0;
  }
  onScrollChanged(e) {
    return !0;
  }
  onThemeChanged(e) {
    return this.scrollbar.updateClassName("editor-scrollable " + Qx(this._context.theme.type)), !0;
  }
  // --- end event handlers
  prepareRender(e) {
  }
  render(e) {
    this.scrollbar.renderNow();
  }
}
class eI {
  constructor(e, t, i, n, s) {
    this.startLineNumber = e, this.endLineNumber = t, this.className = i, this.tooltip = n, this._decorationToRenderBrand = void 0, this.zIndex = s ?? 0;
  }
}
class UZ {
  constructor(e, t, i) {
    this.className = e, this.zIndex = t, this.tooltip = i;
  }
}
class $Z {
  constructor() {
    this.decorations = [];
  }
  add(e) {
    this.decorations.push(e);
  }
  getDecorations() {
    return this.decorations;
  }
}
class d2 extends eg {
  /**
   * Returns an array with an element for each visible line number.
   */
  _render(e, t, i) {
    const n = [];
    for (let a = e; a <= t; a++) {
      const l = a - e;
      n[l] = new $Z();
    }
    if (i.length === 0)
      return n;
    i.sort((a, l) => a.className === l.className ? a.startLineNumber === l.startLineNumber ? a.endLineNumber - l.endLineNumber : a.startLineNumber - l.startLineNumber : a.className < l.className ? -1 : 1);
    let s = null, o = 0;
    for (let a = 0, l = i.length; a < l; a++) {
      const d = i[a], c = d.className, h = d.zIndex;
      let u = Math.max(d.startLineNumber, e) - e;
      const g = Math.min(d.endLineNumber, t) - e;
      s === c ? (u = Math.max(o + 1, u), o = Math.max(o, g)) : (s = c, o = g);
      for (let f = u; f <= o; f++)
        n[f].add(new UZ(c, h, d.tooltip));
    }
    return n;
  }
}
class KZ extends Gs {
  constructor(e) {
    super(e), this._widgets = {}, this._context = e;
    const t = this._context.configuration.options, i = t.get(
      145
      /* EditorOption.layoutInfo */
    );
    this.domNode = bt(document.createElement("div")), this.domNode.setClassName("glyph-margin-widgets"), this.domNode.setPosition("absolute"), this.domNode.setTop(0), this._lineHeight = t.get(
      67
      /* EditorOption.lineHeight */
    ), this._glyphMargin = t.get(
      57
      /* EditorOption.glyphMargin */
    ), this._glyphMarginLeft = i.glyphMarginLeft, this._glyphMarginWidth = i.glyphMarginWidth, this._glyphMarginDecorationLaneCount = i.glyphMarginDecorationLaneCount, this._managedDomNodes = [], this._decorationGlyphsToRender = [];
  }
  dispose() {
    this._managedDomNodes = [], this._decorationGlyphsToRender = [], this._widgets = {}, super.dispose();
  }
  getWidgets() {
    return Object.values(this._widgets);
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    const t = this._context.configuration.options, i = t.get(
      145
      /* EditorOption.layoutInfo */
    );
    return this._lineHeight = t.get(
      67
      /* EditorOption.lineHeight */
    ), this._glyphMargin = t.get(
      57
      /* EditorOption.glyphMargin */
    ), this._glyphMarginLeft = i.glyphMarginLeft, this._glyphMarginWidth = i.glyphMarginWidth, this._glyphMarginDecorationLaneCount = i.glyphMarginDecorationLaneCount, !0;
  }
  onDecorationsChanged(e) {
    return !0;
  }
  onFlushed(e) {
    return !0;
  }
  onLinesChanged(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged;
  }
  onZonesChanged(e) {
    return !0;
  }
  // --- end event handlers
  // --- begin widget management
  addWidget(e) {
    const t = bt(e.getDomNode());
    this._widgets[e.getId()] = {
      widget: e,
      preference: e.getPosition(),
      domNode: t,
      renderInfo: null
    }, t.setPosition("absolute"), t.setDisplay("none"), t.setAttribute("widgetId", e.getId()), this.domNode.appendChild(t), this.setShouldRender();
  }
  setWidgetPosition(e, t) {
    const i = this._widgets[e.getId()];
    return i.preference.lane === t.lane && i.preference.zIndex === t.zIndex && L.equalsRange(i.preference.range, t.range) ? !1 : (i.preference = t, this.setShouldRender(), !0);
  }
  removeWidget(e) {
    var t;
    const i = e.getId();
    if (this._widgets[i]) {
      const s = this._widgets[i].domNode.domNode;
      delete this._widgets[i], (t = s.parentNode) === null || t === void 0 || t.removeChild(s), this.setShouldRender();
    }
  }
  // --- end widget management
  _collectDecorationBasedGlyphRenderRequest(e, t) {
    var i, n, s;
    const o = e.visibleRange.startLineNumber, a = e.visibleRange.endLineNumber, l = e.getDecorationsInViewport();
    for (const d of l) {
      const c = d.options.glyphMarginClassName;
      if (!c)
        continue;
      const h = Math.max(d.range.startLineNumber, o), u = Math.min(d.range.endLineNumber, a), g = (n = (i = d.options.glyphMargin) === null || i === void 0 ? void 0 : i.position) !== null && n !== void 0 ? n : Ec.Center, f = (s = d.options.zIndex) !== null && s !== void 0 ? s : 0;
      for (let m = h; m <= u; m++) {
        const _ = this._context.viewModel.coordinatesConverter.convertViewPositionToModelPosition(new A(m, 0)), v = this._context.viewModel.glyphLanes.getLanesAtLine(_.lineNumber).indexOf(g);
        t.push(new jZ(m, v, f, c));
      }
    }
  }
  _collectWidgetBasedGlyphRenderRequest(e, t) {
    const i = e.visibleRange.startLineNumber, n = e.visibleRange.endLineNumber;
    for (const s of Object.values(this._widgets)) {
      const o = s.preference.range, { startLineNumber: a, endLineNumber: l } = this._context.viewModel.coordinatesConverter.convertModelRangeToViewRange(L.lift(o));
      if (!a || !l || l < i || a > n)
        continue;
      const d = Math.max(a, i), c = this._context.viewModel.coordinatesConverter.convertViewPositionToModelPosition(new A(d, 0)), h = this._context.viewModel.glyphLanes.getLanesAtLine(c.lineNumber).indexOf(s.preference.lane);
      t.push(new qZ(d, h, s.preference.zIndex, s));
    }
  }
  _collectSortedGlyphRenderRequests(e) {
    const t = [];
    return this._collectDecorationBasedGlyphRenderRequest(e, t), this._collectWidgetBasedGlyphRenderRequest(e, t), t.sort((i, n) => i.lineNumber === n.lineNumber ? i.laneIndex === n.laneIndex ? i.zIndex === n.zIndex ? n.type === i.type ? i.type === 0 && n.type === 0 ? i.className < n.className ? -1 : 1 : 0 : n.type - i.type : n.zIndex - i.zIndex : i.laneIndex - n.laneIndex : i.lineNumber - n.lineNumber), t;
  }
  /**
   * Will store render information in each widget's renderInfo and in `_decorationGlyphsToRender`.
   */
  prepareRender(e) {
    if (!this._glyphMargin) {
      this._decorationGlyphsToRender = [];
      return;
    }
    for (const n of Object.values(this._widgets))
      n.renderInfo = null;
    const t = new ad(this._collectSortedGlyphRenderRequests(e)), i = [];
    for (; t.length > 0; ) {
      const n = t.peek();
      if (!n)
        break;
      const s = t.takeWhile((a) => a.lineNumber === n.lineNumber && a.laneIndex === n.laneIndex);
      if (!s || s.length === 0)
        break;
      const o = s[0];
      if (o.type === 0) {
        const a = [];
        for (const l of s) {
          if (l.zIndex !== o.zIndex || l.type !== o.type)
            break;
          (a.length === 0 || a[a.length - 1] !== l.className) && a.push(l.className);
        }
        i.push(o.accept(a.join(" ")));
      } else
        o.widget.renderInfo = {
          lineNumber: o.lineNumber,
          laneIndex: o.laneIndex
        };
    }
    this._decorationGlyphsToRender = i;
  }
  render(e) {
    if (!this._glyphMargin) {
      for (const i of Object.values(this._widgets))
        i.domNode.setDisplay("none");
      for (; this._managedDomNodes.length > 0; ) {
        const i = this._managedDomNodes.pop();
        i == null || i.domNode.remove();
      }
      return;
    }
    const t = Math.round(this._glyphMarginWidth / this._glyphMarginDecorationLaneCount);
    for (const i of Object.values(this._widgets))
      if (!i.renderInfo)
        i.domNode.setDisplay("none");
      else {
        const n = e.viewportData.relativeVerticalOffset[i.renderInfo.lineNumber - e.viewportData.startLineNumber], s = this._glyphMarginLeft + i.renderInfo.laneIndex * this._lineHeight;
        i.domNode.setDisplay("block"), i.domNode.setTop(n), i.domNode.setLeft(s), i.domNode.setWidth(t), i.domNode.setHeight(this._lineHeight);
      }
    for (let i = 0; i < this._decorationGlyphsToRender.length; i++) {
      const n = this._decorationGlyphsToRender[i], s = e.viewportData.relativeVerticalOffset[n.lineNumber - e.viewportData.startLineNumber], o = this._glyphMarginLeft + n.laneIndex * this._lineHeight;
      let a;
      i < this._managedDomNodes.length ? a = this._managedDomNodes[i] : (a = bt(document.createElement("div")), this._managedDomNodes.push(a), this.domNode.appendChild(a)), a.setClassName("cgmr codicon " + n.combinedClassName), a.setPosition("absolute"), a.setTop(s), a.setLeft(o), a.setWidth(t), a.setHeight(this._lineHeight);
    }
    for (; this._managedDomNodes.length > this._decorationGlyphsToRender.length; ) {
      const i = this._managedDomNodes.pop();
      i == null || i.domNode.remove();
    }
  }
}
class jZ {
  constructor(e, t, i, n) {
    this.lineNumber = e, this.laneIndex = t, this.zIndex = i, this.className = n, this.type = 0;
  }
  accept(e) {
    return new GZ(this.lineNumber, this.laneIndex, e);
  }
}
class qZ {
  constructor(e, t, i, n) {
    this.lineNumber = e, this.laneIndex = t, this.zIndex = i, this.widget = n, this.type = 1;
  }
}
class GZ {
  constructor(e, t, i) {
    this.lineNumber = e, this.laneIndex = t, this.combinedClassName = i;
  }
}
class c2 extends P {
  constructor() {
    super(...arguments), this._isDisposed = !1;
  }
  dispose() {
    super.dispose(), this._isDisposed = !0;
  }
  assertNotDisposed() {
    if (this._isDisposed)
      throw new Error("TextModelPart is disposed!");
  }
}
function R0(r, e) {
  let t = 0, i = 0;
  const n = r.length;
  for (; i < n; ) {
    const s = r.charCodeAt(i);
    if (s === 32)
      t++;
    else if (s === 9)
      t = t - t % e + e;
    else
      break;
    i++;
  }
  return i === n ? -1 : t;
}
var lu;
(function(r) {
  r[r.Disabled = 0] = "Disabled", r[r.EnabledForActive = 1] = "EnabledForActive", r[r.Enabled = 2] = "Enabled";
})(lu || (lu = {}));
class Yh {
  constructor(e, t, i, n, s, o) {
    if (this.visibleColumn = e, this.column = t, this.className = i, this.horizontalLine = n, this.forWrappedLinesAfterColumn = s, this.forWrappedLinesBeforeOrAtColumn = o, e !== -1 == (t !== -1))
      throw new Error();
  }
}
class s_ {
  constructor(e, t) {
    this.top = e, this.endColumn = t;
  }
}
class ZZ extends c2 {
  constructor(e, t) {
    super(), this.textModel = e, this.languageConfigurationService = t;
  }
  getLanguageConfiguration(e) {
    return this.languageConfigurationService.getLanguageConfiguration(e);
  }
  _computeIndentLevel(e) {
    return R0(this.textModel.getLineContent(e + 1), this.textModel.getOptions().tabSize);
  }
  getActiveIndentGuide(e, t, i) {
    this.assertNotDisposed();
    const n = this.textModel.getLineCount();
    if (e < 1 || e > n)
      throw new Li("Illegal value for lineNumber");
    const s = this.getLanguageConfiguration(this.textModel.getLanguageId()).foldingRules, o = !!(s && s.offSide);
    let a = -2, l = -1, d = -2, c = -1;
    const h = (k) => {
      if (a !== -1 && (a === -2 || a > k - 1)) {
        a = -1, l = -1;
        for (let E = k - 2; E >= 0; E--) {
          const N = this._computeIndentLevel(E);
          if (N >= 0) {
            a = E, l = N;
            break;
          }
        }
      }
      if (d === -2) {
        d = -1, c = -1;
        for (let E = k; E < n; E++) {
          const N = this._computeIndentLevel(E);
          if (N >= 0) {
            d = E, c = N;
            break;
          }
        }
      }
    };
    let u = -2, g = -1, f = -2, m = -1;
    const _ = (k) => {
      if (u === -2) {
        u = -1, g = -1;
        for (let E = k - 2; E >= 0; E--) {
          const N = this._computeIndentLevel(E);
          if (N >= 0) {
            u = E, g = N;
            break;
          }
        }
      }
      if (f !== -1 && (f === -2 || f < k - 1)) {
        f = -1, m = -1;
        for (let E = k; E < n; E++) {
          const N = this._computeIndentLevel(E);
          if (N >= 0) {
            f = E, m = N;
            break;
          }
        }
      }
    };
    let v = 0, b = !0, C = 0, w = !0, S = 0, y = 0;
    for (let k = 0; b || w; k++) {
      const E = e - k, N = e + k;
      k > 1 && (E < 1 || E < t) && (b = !1), k > 1 && (N > n || N > i) && (w = !1), k > 5e4 && (b = !1, w = !1);
      let F = -1;
      if (b && E >= 1) {
        const Z = this._computeIndentLevel(E - 1);
        Z >= 0 ? (d = E - 1, c = Z, F = Math.ceil(Z / this.textModel.getOptions().indentSize)) : (h(E), F = this._getIndentLevelForWhitespaceLine(o, l, c));
      }
      let V = -1;
      if (w && N <= n) {
        const Z = this._computeIndentLevel(N - 1);
        Z >= 0 ? (u = N - 1, g = Z, V = Math.ceil(Z / this.textModel.getOptions().indentSize)) : (_(N), V = this._getIndentLevelForWhitespaceLine(o, g, m));
      }
      if (k === 0) {
        y = F;
        continue;
      }
      if (k === 1) {
        if (N <= n && V >= 0 && y + 1 === V) {
          b = !1, v = N, C = N, S = V;
          continue;
        }
        if (E >= 1 && F >= 0 && F - 1 === y) {
          w = !1, v = E, C = E, S = F;
          continue;
        }
        if (v = e, C = e, S = y, S === 0)
          return { startLineNumber: v, endLineNumber: C, indent: S };
      }
      b && (F >= S ? v = E : b = !1), w && (V >= S ? C = N : w = !1);
    }
    return { startLineNumber: v, endLineNumber: C, indent: S };
  }
  getLinesBracketGuides(e, t, i, n) {
    var s;
    const o = [];
    for (let u = e; u <= t; u++)
      o.push([]);
    const a = !0, l = this.textModel.bracketPairs.getBracketPairsInRangeWithMinIndentation(new L(e, 1, t, this.textModel.getLineMaxColumn(t))).toArray();
    let d;
    if (i && l.length > 0) {
      const u = (e <= i.lineNumber && i.lineNumber <= t ? l : this.textModel.bracketPairs.getBracketPairsInRange(L.fromPositions(i)).toArray()).filter((g) => L.strictContainsPosition(g.range, i));
      d = (s = N_(u, (g) => a)) === null || s === void 0 ? void 0 : s.range;
    }
    const c = this.textModel.getOptions().bracketPairColorizationOptions.independentColorPoolPerBracketType, h = new h2();
    for (const u of l) {
      if (!u.closingBracketRange)
        continue;
      const g = d && u.range.equalsRange(d);
      if (!g && !n.includeInactive)
        continue;
      const f = h.getInlineClassName(u.nestingLevel, u.nestingLevelOfEqualBracketType, c) + (n.highlightActive && g ? " " + h.activeClassName : ""), m = u.openingBracketRange.getStartPosition(), _ = u.closingBracketRange.getStartPosition(), v = n.horizontalGuides === lu.Enabled || n.horizontalGuides === lu.EnabledForActive && g;
      if (u.range.startLineNumber === u.range.endLineNumber) {
        v && o[u.range.startLineNumber - e].push(new Yh(-1, u.openingBracketRange.getEndPosition().column, f, new s_(!1, _.column), -1, -1));
        continue;
      }
      const b = this.getVisibleColumnFromPosition(_), C = this.getVisibleColumnFromPosition(u.openingBracketRange.getStartPosition()), w = Math.min(C, b, u.minVisibleColumnIndentation + 1);
      let S = !1;
      ns(this.textModel.getLineContent(u.closingBracketRange.startLineNumber)) < u.closingBracketRange.startColumn - 1 && (S = !0);
      const E = Math.max(m.lineNumber, e), N = Math.min(_.lineNumber, t), F = S ? 1 : 0;
      for (let V = E; V < N + F; V++)
        o[V - e].push(new Yh(w, -1, f, null, V === m.lineNumber ? m.column : -1, V === _.lineNumber ? _.column : -1));
      v && (m.lineNumber >= e && C > w && o[m.lineNumber - e].push(new Yh(w, -1, f, new s_(!1, m.column), -1, -1)), _.lineNumber <= t && b > w && o[_.lineNumber - e].push(new Yh(w, -1, f, new s_(!S, _.column), -1, -1)));
    }
    for (const u of o)
      u.sort((g, f) => g.visibleColumn - f.visibleColumn);
    return o;
  }
  getVisibleColumnFromPosition(e) {
    return Hi.visibleColumnFromColumn(this.textModel.getLineContent(e.lineNumber), e.column, this.textModel.getOptions().tabSize) + 1;
  }
  getLinesIndentGuides(e, t) {
    this.assertNotDisposed();
    const i = this.textModel.getLineCount();
    if (e < 1 || e > i)
      throw new Error("Illegal value for startLineNumber");
    if (t < 1 || t > i)
      throw new Error("Illegal value for endLineNumber");
    const n = this.textModel.getOptions(), s = this.getLanguageConfiguration(this.textModel.getLanguageId()).foldingRules, o = !!(s && s.offSide), a = new Array(t - e + 1);
    let l = -2, d = -1, c = -2, h = -1;
    for (let u = e; u <= t; u++) {
      const g = u - e, f = this._computeIndentLevel(u - 1);
      if (f >= 0) {
        l = u - 1, d = f, a[g] = Math.ceil(f / n.indentSize);
        continue;
      }
      if (l === -2) {
        l = -1, d = -1;
        for (let m = u - 2; m >= 0; m--) {
          const _ = this._computeIndentLevel(m);
          if (_ >= 0) {
            l = m, d = _;
            break;
          }
        }
      }
      if (c !== -1 && (c === -2 || c < u - 1)) {
        c = -1, h = -1;
        for (let m = u; m < i; m++) {
          const _ = this._computeIndentLevel(m);
          if (_ >= 0) {
            c = m, h = _;
            break;
          }
        }
      }
      a[g] = this._getIndentLevelForWhitespaceLine(o, d, h);
    }
    return a;
  }
  _getIndentLevelForWhitespaceLine(e, t, i) {
    const n = this.textModel.getOptions();
    return t === -1 || i === -1 ? 0 : t < i ? 1 + Math.floor(t / n.indentSize) : t === i || e ? Math.ceil(i / n.indentSize) : 1 + Math.floor(i / n.indentSize);
  }
}
class h2 {
  constructor() {
    this.activeClassName = "indent-active";
  }
  getInlineClassName(e, t, i) {
    return this.getInlineClassNameOfLevel(i ? t : e);
  }
  getInlineClassNameOfLevel(e) {
    return `bracket-indent-guide lvl-${e % 30}`;
  }
}
class YZ extends eg {
  constructor(e) {
    super(), this._context = e, this._primaryPosition = null;
    const t = this._context.configuration.options, i = t.get(
      146
      /* EditorOption.wrappingInfo */
    ), n = t.get(
      50
      /* EditorOption.fontInfo */
    );
    this._spaceWidth = n.spaceWidth, this._maxIndentLeft = i.wrappingColumn === -1 ? -1 : i.wrappingColumn * n.typicalHalfwidthCharacterWidth, this._bracketPairGuideOptions = t.get(
      16
      /* EditorOption.guides */
    ), this._renderResult = null, this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this), this._renderResult = null, super.dispose();
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    const t = this._context.configuration.options, i = t.get(
      146
      /* EditorOption.wrappingInfo */
    ), n = t.get(
      50
      /* EditorOption.fontInfo */
    );
    return this._spaceWidth = n.spaceWidth, this._maxIndentLeft = i.wrappingColumn === -1 ? -1 : i.wrappingColumn * n.typicalHalfwidthCharacterWidth, this._bracketPairGuideOptions = t.get(
      16
      /* EditorOption.guides */
    ), !0;
  }
  onCursorStateChanged(e) {
    var t;
    const n = e.selections[0].getPosition();
    return !((t = this._primaryPosition) === null || t === void 0) && t.equals(n) ? !1 : (this._primaryPosition = n, !0);
  }
  onDecorationsChanged(e) {
    return !0;
  }
  onFlushed(e) {
    return !0;
  }
  onLinesChanged(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged;
  }
  onZonesChanged(e) {
    return !0;
  }
  onLanguageConfigurationChanged(e) {
    return !0;
  }
  // --- end event handlers
  prepareRender(e) {
    var t, i, n, s;
    if (!this._bracketPairGuideOptions.indentation && this._bracketPairGuideOptions.bracketPairs === !1) {
      this._renderResult = null;
      return;
    }
    const o = e.visibleRange.startLineNumber, a = e.visibleRange.endLineNumber, l = e.scrollWidth, d = this._primaryPosition, c = this.getGuidesByLine(o, Math.min(a + 1, this._context.viewModel.getLineCount()), d), h = [];
    for (let u = o; u <= a; u++) {
      const g = u - o, f = c[g];
      let m = "";
      const _ = (i = (t = e.visibleRangeForPosition(new A(u, 1))) === null || t === void 0 ? void 0 : t.left) !== null && i !== void 0 ? i : 0;
      for (const v of f) {
        const b = v.column === -1 ? _ + (v.visibleColumn - 1) * this._spaceWidth : e.visibleRangeForPosition(new A(u, v.column)).left;
        if (b > l || this._maxIndentLeft > 0 && b > this._maxIndentLeft)
          break;
        const C = v.horizontalLine ? v.horizontalLine.top ? "horizontal-top" : "horizontal-bottom" : "vertical", w = v.horizontalLine ? ((s = (n = e.visibleRangeForPosition(new A(u, v.horizontalLine.endColumn))) === null || n === void 0 ? void 0 : n.left) !== null && s !== void 0 ? s : b + this._spaceWidth) - b : this._spaceWidth;
        m += `<div class="core-guide ${v.className} ${C}" style="left:${b}px;width:${w}px"></div>`;
      }
      h[g] = m;
    }
    this._renderResult = h;
  }
  getGuidesByLine(e, t, i) {
    const n = this._bracketPairGuideOptions.bracketPairs !== !1 ? this._context.viewModel.getBracketGuidesInRangeByLine(e, t, i, {
      highlightActive: this._bracketPairGuideOptions.highlightActiveBracketPair,
      horizontalGuides: this._bracketPairGuideOptions.bracketPairsHorizontal === !0 ? lu.Enabled : this._bracketPairGuideOptions.bracketPairsHorizontal === "active" ? lu.EnabledForActive : lu.Disabled,
      includeInactive: this._bracketPairGuideOptions.bracketPairs === !0
    }) : null, s = this._bracketPairGuideOptions.indentation ? this._context.viewModel.getLinesIndentGuides(e, t) : null;
    let o = 0, a = 0, l = 0;
    if (this._bracketPairGuideOptions.highlightActiveIndentation !== !1 && i) {
      const h = this._context.viewModel.getActiveIndentGuide(i.lineNumber, e, t);
      o = h.startLineNumber, a = h.endLineNumber, l = h.indent;
    }
    const { indentSize: d } = this._context.viewModel.model.getOptions(), c = [];
    for (let h = e; h <= t; h++) {
      const u = new Array();
      c.push(u);
      const g = n ? n[h - e] : [], f = new ad(g), m = s ? s[h - e] : 0;
      for (let _ = 1; _ <= m; _++) {
        const v = (_ - 1) * d + 1, b = (
          // Disable active indent guide if there are bracket guides.
          (this._bracketPairGuideOptions.highlightActiveIndentation === "always" || g.length === 0) && o <= h && h <= a && _ === l
        );
        u.push(...f.takeWhile((w) => w.visibleColumn < v) || []);
        const C = f.peek();
        (!C || C.visibleColumn !== v || C.horizontalLine) && u.push(new Yh(v, -1, `core-guide-indent lvl-${(_ - 1) % 30}` + (b ? " indent-active" : ""), null, -1, -1));
      }
      u.push(...f.takeWhile((_) => !0) || []);
    }
    return c;
  }
  render(e, t) {
    if (!this._renderResult)
      return "";
    const i = t - e;
    return i < 0 || i >= this._renderResult.length ? "" : this._renderResult[i];
  }
}
function mg(r) {
  if (!(r && r.isTransparent()))
    return r;
}
Ho((r, e) => {
  const t = [
    { bracketColor: ZV, guideColor: J7, guideColorActive: oZ },
    { bracketColor: YV, guideColor: eZ, guideColorActive: rZ },
    { bracketColor: QV, guideColor: tZ, guideColorActive: aZ },
    { bracketColor: XV, guideColor: iZ, guideColorActive: lZ },
    { bracketColor: JV, guideColor: nZ, guideColorActive: dZ },
    { bracketColor: e2, guideColor: sZ, guideColorActive: cZ }
  ], i = new h2(), n = [
    { indentColor: mb, indentColorActive: _b },
    { indentColor: P7, indentColorActive: H7 },
    { indentColor: O7, indentColorActive: V7 },
    { indentColor: F7, indentColorActive: z7 },
    { indentColor: W7, indentColorActive: U7 },
    { indentColor: B7, indentColorActive: $7 }
  ], s = t.map((a) => {
    var l, d;
    const c = r.getColor(a.bracketColor), h = r.getColor(a.guideColor), u = r.getColor(a.guideColorActive), g = mg((l = mg(h)) !== null && l !== void 0 ? l : c == null ? void 0 : c.transparent(0.3)), f = mg((d = mg(u)) !== null && d !== void 0 ? d : c);
    if (!(!g || !f))
      return {
        guideColor: g,
        guideColorActive: f
      };
  }).filter(qa), o = n.map((a) => {
    const l = r.getColor(a.indentColor), d = r.getColor(a.indentColorActive), c = mg(l), h = mg(d);
    if (!(!c || !h))
      return {
        indentColor: c,
        indentColorActive: h
      };
  }).filter(qa);
  if (s.length > 0) {
    for (let a = 0; a < 30; a++) {
      const l = s[a % s.length];
      e.addRule(`.monaco-editor .${i.getInlineClassNameOfLevel(a).replace(/ /g, ".")} { --guide-color: ${l.guideColor}; --guide-color-active: ${l.guideColorActive}; }`);
    }
    e.addRule(".monaco-editor .vertical { box-shadow: 1px 0 0 0 var(--guide-color) inset; }"), e.addRule(".monaco-editor .horizontal-top { border-top: 1px solid var(--guide-color); }"), e.addRule(".monaco-editor .horizontal-bottom { border-bottom: 1px solid var(--guide-color); }"), e.addRule(`.monaco-editor .vertical.${i.activeClassName} { box-shadow: 1px 0 0 0 var(--guide-color-active) inset; }`), e.addRule(`.monaco-editor .horizontal-top.${i.activeClassName} { border-top: 1px solid var(--guide-color-active); }`), e.addRule(`.monaco-editor .horizontal-bottom.${i.activeClassName} { border-bottom: 1px solid var(--guide-color-active); }`);
  }
  if (o.length > 0) {
    for (let a = 0; a < 30; a++) {
      const l = o[a % o.length];
      e.addRule(`.monaco-editor .lines-content .core-guide-indent.lvl-${a} { --indent-color: ${l.indentColor}; --indent-color-active: ${l.indentColorActive}; }`);
    }
    e.addRule(".monaco-editor .lines-content .core-guide-indent { box-shadow: 1px 0 0 0 var(--indent-color) inset; }"), e.addRule(".monaco-editor .lines-content .core-guide-indent.indent-active { box-shadow: 1px 0 0 0 var(--indent-color-active) inset; }");
  }
});
class YD {
  get didDomLayout() {
    return this._didDomLayout;
  }
  readClientRect() {
    if (!this._clientRectRead) {
      this._clientRectRead = !0;
      const e = this._domNode.getBoundingClientRect();
      this.markDidDomLayout(), this._clientRectDeltaLeft = e.left, this._clientRectScale = e.width / this._domNode.offsetWidth;
    }
  }
  get clientRectDeltaLeft() {
    return this._clientRectRead || this.readClientRect(), this._clientRectDeltaLeft;
  }
  get clientRectScale() {
    return this._clientRectRead || this.readClientRect(), this._clientRectScale;
  }
  constructor(e, t) {
    this._domNode = e, this.endNode = t, this._didDomLayout = !1, this._clientRectDeltaLeft = 0, this._clientRectScale = 1, this._clientRectRead = !1;
  }
  markDidDomLayout() {
    this._didDomLayout = !0;
  }
}
class QZ {
  constructor() {
    this._currentVisibleRange = new L(1, 1, 1, 1);
  }
  getCurrentVisibleRange() {
    return this._currentVisibleRange;
  }
  setCurrentVisibleRange(e) {
    this._currentVisibleRange = e;
  }
}
class XZ {
  constructor(e, t, i, n, s, o, a) {
    this.minimalReveal = e, this.lineNumber = t, this.startColumn = i, this.endColumn = n, this.startScrollTop = s, this.stopScrollTop = o, this.scrollType = a, this.type = "range", this.minLineNumber = t, this.maxLineNumber = t;
  }
}
class JZ {
  constructor(e, t, i, n, s) {
    this.minimalReveal = e, this.selections = t, this.startScrollTop = i, this.stopScrollTop = n, this.scrollType = s, this.type = "selections";
    let o = t[0].startLineNumber, a = t[0].endLineNumber;
    for (let l = 1, d = t.length; l < d; l++) {
      const c = t[l];
      o = Math.min(o, c.startLineNumber), a = Math.max(a, c.endLineNumber);
    }
    this.minLineNumber = o, this.maxLineNumber = a;
  }
}
class A0 extends Gs {
  constructor(e, t) {
    super(e), this._linesContent = t, this._textRangeRestingSpot = document.createElement("div"), this._visibleLines = new r2(this), this.domNode = this._visibleLines.domNode;
    const i = this._context.configuration, n = this._context.configuration.options, s = n.get(
      50
      /* EditorOption.fontInfo */
    ), o = n.get(
      146
      /* EditorOption.wrappingInfo */
    );
    this._lineHeight = n.get(
      67
      /* EditorOption.lineHeight */
    ), this._typicalHalfwidthCharacterWidth = s.typicalHalfwidthCharacterWidth, this._isViewportWrapping = o.isViewportWrapping, this._revealHorizontalRightPadding = n.get(
      100
      /* EditorOption.revealHorizontalRightPadding */
    ), this._cursorSurroundingLines = n.get(
      29
      /* EditorOption.cursorSurroundingLines */
    ), this._cursorSurroundingLinesStyle = n.get(
      30
      /* EditorOption.cursorSurroundingLinesStyle */
    ), this._canUseLayerHinting = !n.get(
      32
      /* EditorOption.disableLayerHinting */
    ), this._viewLineOptions = new fP(i, this._context.theme.type), Jr.write(
      this.domNode,
      8
      /* PartFingerprint.ViewLines */
    ), this.domNode.setClassName(`view-lines ${vf}`), _n(this.domNode, s), this._maxLineWidth = 0, this._asyncUpdateLineWidths = new xt(() => {
      this._updateLineWidthsSlow();
    }, 200), this._asyncCheckMonospaceFontAssumptions = new xt(() => {
      this._checkMonospaceFontAssumptions();
    }, 2e3), this._lastRenderedData = new QZ(), this._horizontalRevealRequest = null, this._stickyScrollEnabled = n.get(
      115
      /* EditorOption.stickyScroll */
    ).enabled, this._maxNumberStickyLines = n.get(
      115
      /* EditorOption.stickyScroll */
    ).maxLineCount;
  }
  dispose() {
    this._asyncUpdateLineWidths.dispose(), this._asyncCheckMonospaceFontAssumptions.dispose(), super.dispose();
  }
  getDomNode() {
    return this.domNode;
  }
  // ---- begin IVisibleLinesHost
  createVisibleLine() {
    return new Aa(this._viewLineOptions);
  }
  // ---- end IVisibleLinesHost
  // ---- begin view event handlers
  onConfigurationChanged(e) {
    this._visibleLines.onConfigurationChanged(e), e.hasChanged(
      146
      /* EditorOption.wrappingInfo */
    ) && (this._maxLineWidth = 0);
    const t = this._context.configuration.options, i = t.get(
      50
      /* EditorOption.fontInfo */
    ), n = t.get(
      146
      /* EditorOption.wrappingInfo */
    );
    return this._lineHeight = t.get(
      67
      /* EditorOption.lineHeight */
    ), this._typicalHalfwidthCharacterWidth = i.typicalHalfwidthCharacterWidth, this._isViewportWrapping = n.isViewportWrapping, this._revealHorizontalRightPadding = t.get(
      100
      /* EditorOption.revealHorizontalRightPadding */
    ), this._cursorSurroundingLines = t.get(
      29
      /* EditorOption.cursorSurroundingLines */
    ), this._cursorSurroundingLinesStyle = t.get(
      30
      /* EditorOption.cursorSurroundingLinesStyle */
    ), this._canUseLayerHinting = !t.get(
      32
      /* EditorOption.disableLayerHinting */
    ), this._stickyScrollEnabled = t.get(
      115
      /* EditorOption.stickyScroll */
    ).enabled, this._maxNumberStickyLines = t.get(
      115
      /* EditorOption.stickyScroll */
    ).maxLineCount, _n(this.domNode, i), this._onOptionsMaybeChanged(), e.hasChanged(
      145
      /* EditorOption.layoutInfo */
    ) && (this._maxLineWidth = 0), !0;
  }
  _onOptionsMaybeChanged() {
    const e = this._context.configuration, t = new fP(e, this._context.theme.type);
    if (!this._viewLineOptions.equals(t)) {
      this._viewLineOptions = t;
      const i = this._visibleLines.getStartLineNumber(), n = this._visibleLines.getEndLineNumber();
      for (let s = i; s <= n; s++)
        this._visibleLines.getVisibleLine(s).onOptionsChanged(this._viewLineOptions);
      return !0;
    }
    return !1;
  }
  onCursorStateChanged(e) {
    const t = this._visibleLines.getStartLineNumber(), i = this._visibleLines.getEndLineNumber();
    let n = !1;
    for (let s = t; s <= i; s++)
      n = this._visibleLines.getVisibleLine(s).onSelectionChanged() || n;
    return n;
  }
  onDecorationsChanged(e) {
    {
      const t = this._visibleLines.getStartLineNumber(), i = this._visibleLines.getEndLineNumber();
      for (let n = t; n <= i; n++)
        this._visibleLines.getVisibleLine(n).onDecorationsChanged();
    }
    return !0;
  }
  onFlushed(e) {
    const t = this._visibleLines.onFlushed(e);
    return this._maxLineWidth = 0, t;
  }
  onLinesChanged(e) {
    return this._visibleLines.onLinesChanged(e);
  }
  onLinesDeleted(e) {
    return this._visibleLines.onLinesDeleted(e);
  }
  onLinesInserted(e) {
    return this._visibleLines.onLinesInserted(e);
  }
  onRevealRangeRequest(e) {
    const t = this._computeScrollTopToRevealRange(this._context.viewLayout.getFutureViewport(), e.source, e.minimalReveal, e.range, e.selections, e.verticalType);
    if (t === -1)
      return !1;
    let i = this._context.viewLayout.validateScrollPosition({ scrollTop: t });
    e.revealHorizontal ? e.range && e.range.startLineNumber !== e.range.endLineNumber ? i = {
      scrollTop: i.scrollTop,
      scrollLeft: 0
    } : e.range ? this._horizontalRevealRequest = new XZ(e.minimalReveal, e.range.startLineNumber, e.range.startColumn, e.range.endColumn, this._context.viewLayout.getCurrentScrollTop(), i.scrollTop, e.scrollType) : e.selections && e.selections.length > 0 && (this._horizontalRevealRequest = new JZ(e.minimalReveal, e.selections, this._context.viewLayout.getCurrentScrollTop(), i.scrollTop, e.scrollType)) : this._horizontalRevealRequest = null;
    const s = Math.abs(this._context.viewLayout.getCurrentScrollTop() - i.scrollTop) <= this._lineHeight ? 1 : e.scrollType;
    return this._context.viewModel.viewLayout.setScrollPosition(i, s), !0;
  }
  onScrollChanged(e) {
    if (this._horizontalRevealRequest && e.scrollLeftChanged && (this._horizontalRevealRequest = null), this._horizontalRevealRequest && e.scrollTopChanged) {
      const t = Math.min(this._horizontalRevealRequest.startScrollTop, this._horizontalRevealRequest.stopScrollTop), i = Math.max(this._horizontalRevealRequest.startScrollTop, this._horizontalRevealRequest.stopScrollTop);
      (e.scrollTop < t || e.scrollTop > i) && (this._horizontalRevealRequest = null);
    }
    return this.domNode.setWidth(e.scrollWidth), this._visibleLines.onScrollChanged(e) || !0;
  }
  onTokensChanged(e) {
    return this._visibleLines.onTokensChanged(e);
  }
  onZonesChanged(e) {
    return this._context.viewModel.viewLayout.setMaxLineWidth(this._maxLineWidth), this._visibleLines.onZonesChanged(e);
  }
  onThemeChanged(e) {
    return this._onOptionsMaybeChanged();
  }
  // ---- end view event handlers
  // ----------- HELPERS FOR OTHERS
  getPositionFromDOMInfo(e, t) {
    const i = this._getViewLineDomNode(e);
    if (i === null)
      return null;
    const n = this._getLineNumberFor(i);
    if (n === -1 || n < 1 || n > this._context.viewModel.getLineCount())
      return null;
    if (this._context.viewModel.getLineMaxColumn(n) === 1)
      return new A(n, 1);
    const s = this._visibleLines.getStartLineNumber(), o = this._visibleLines.getEndLineNumber();
    if (n < s || n > o)
      return null;
    let a = this._visibleLines.getVisibleLine(n).getColumnOfNodeOffset(e, t);
    const l = this._context.viewModel.getLineMinColumn(n);
    return a < l && (a = l), new A(n, a);
  }
  _getViewLineDomNode(e) {
    for (; e && e.nodeType === 1; ) {
      if (e.className === Aa.CLASS_NAME)
        return e;
      e = e.parentElement;
    }
    return null;
  }
  /**
   * @returns the line number of this view line dom node.
   */
  _getLineNumberFor(e) {
    const t = this._visibleLines.getStartLineNumber(), i = this._visibleLines.getEndLineNumber();
    for (let n = t; n <= i; n++) {
      const s = this._visibleLines.getVisibleLine(n);
      if (e === s.getDomNode())
        return n;
    }
    return -1;
  }
  getLineWidth(e) {
    const t = this._visibleLines.getStartLineNumber(), i = this._visibleLines.getEndLineNumber();
    if (e < t || e > i)
      return -1;
    const n = new YD(this.domNode.domNode, this._textRangeRestingSpot), s = this._visibleLines.getVisibleLine(e).getWidth(n);
    return this._updateLineWidthsSlowIfDomDidLayout(n), s;
  }
  linesVisibleRangesForRange(e, t) {
    if (this.shouldRender())
      return null;
    const i = e.endLineNumber, n = L.intersectRanges(e, this._lastRenderedData.getCurrentVisibleRange());
    if (!n)
      return null;
    const s = [];
    let o = 0;
    const a = new YD(this.domNode.domNode, this._textRangeRestingSpot);
    let l = 0;
    t && (l = this._context.viewModel.coordinatesConverter.convertViewPositionToModelPosition(new A(n.startLineNumber, 1)).lineNumber);
    const d = this._visibleLines.getStartLineNumber(), c = this._visibleLines.getEndLineNumber();
    for (let h = n.startLineNumber; h <= n.endLineNumber; h++) {
      if (h < d || h > c)
        continue;
      const u = h === n.startLineNumber ? n.startColumn : 1, g = h !== n.endLineNumber, f = g ? this._context.viewModel.getLineMaxColumn(h) : n.endColumn, m = this._visibleLines.getVisibleLine(h).getVisibleRangesForRange(h, u, f, a);
      if (m) {
        if (t && h < i) {
          const _ = l;
          l = this._context.viewModel.coordinatesConverter.convertViewPositionToModelPosition(new A(h + 1, 1)).lineNumber, _ !== l && (m.ranges[m.ranges.length - 1].width += this._typicalHalfwidthCharacterWidth);
        }
        s[o++] = new X9(m.outsideRenderedLine, h, x0.from(m.ranges), g);
      }
    }
    return this._updateLineWidthsSlowIfDomDidLayout(a), o === 0 ? null : s;
  }
  _visibleRangesForLineRange(e, t, i) {
    if (this.shouldRender() || e < this._visibleLines.getStartLineNumber() || e > this._visibleLines.getEndLineNumber())
      return null;
    const n = new YD(this.domNode.domNode, this._textRangeRestingSpot), s = this._visibleLines.getVisibleLine(e).getVisibleRangesForRange(e, t, i, n);
    return this._updateLineWidthsSlowIfDomDidLayout(n), s;
  }
  visibleRangeForPosition(e) {
    const t = this._visibleRangesForLineRange(e.lineNumber, e.column, e.column);
    return t ? new J9(t.outsideRenderedLine, t.ranges[0].left) : null;
  }
  /**
   * Updates the max line width if it is fast to compute.
   * Returns true if all lines were taken into account.
   * Returns false if some lines need to be reevaluated (in a slow fashion).
   */
  _updateLineWidthsFast() {
    return this._updateLineWidths(!0);
  }
  _updateLineWidthsSlow() {
    this._updateLineWidths(!1);
  }
  /**
   * Update the line widths using DOM layout information after someone else
   * has caused a synchronous layout.
   */
  _updateLineWidthsSlowIfDomDidLayout(e) {
    e.didDomLayout && (this._asyncUpdateLineWidths.isScheduled() || (this._asyncUpdateLineWidths.cancel(), this._updateLineWidthsSlow()));
  }
  _updateLineWidths(e) {
    const t = this._visibleLines.getStartLineNumber(), i = this._visibleLines.getEndLineNumber();
    let n = 1, s = !0;
    for (let o = t; o <= i; o++) {
      const a = this._visibleLines.getVisibleLine(o);
      if (e && !a.getWidthIsFast()) {
        s = !1;
        continue;
      }
      n = Math.max(n, a.getWidth(null));
    }
    return s && t === 1 && i === this._context.viewModel.getLineCount() && (this._maxLineWidth = 0), this._ensureMaxLineWidth(n), s;
  }
  _checkMonospaceFontAssumptions() {
    let e = -1, t = -1;
    const i = this._visibleLines.getStartLineNumber(), n = this._visibleLines.getEndLineNumber();
    for (let s = i; s <= n; s++) {
      const o = this._visibleLines.getVisibleLine(s);
      if (o.needsMonospaceFontCheck()) {
        const a = o.getWidth(null);
        a > t && (t = a, e = s);
      }
    }
    if (e !== -1 && !this._visibleLines.getVisibleLine(e).monospaceAssumptionsAreValid())
      for (let s = i; s <= n; s++)
        this._visibleLines.getVisibleLine(s).onMonospaceAssumptionsInvalidated();
  }
  prepareRender() {
    throw new Error("Not supported");
  }
  render() {
    throw new Error("Not supported");
  }
  renderText(e) {
    if (this._visibleLines.renderLines(e), this._lastRenderedData.setCurrentVisibleRange(e.visibleRange), this.domNode.setWidth(this._context.viewLayout.getScrollWidth()), this.domNode.setHeight(Math.min(this._context.viewLayout.getScrollHeight(), 1e6)), this._horizontalRevealRequest) {
      const i = this._horizontalRevealRequest;
      if (e.startLineNumber <= i.minLineNumber && i.maxLineNumber <= e.endLineNumber) {
        this._horizontalRevealRequest = null, this.onDidRender();
        const n = this._computeScrollLeftToReveal(i);
        n && (this._isViewportWrapping || this._ensureMaxLineWidth(n.maxHorizontalOffset), this._context.viewModel.viewLayout.setScrollPosition({
          scrollLeft: n.scrollLeft
        }, i.scrollType));
      }
    }
    if (this._updateLineWidthsFast() ? this._asyncUpdateLineWidths.cancel() : this._asyncUpdateLineWidths.schedule(), os && !this._asyncCheckMonospaceFontAssumptions.isScheduled()) {
      const i = this._visibleLines.getStartLineNumber(), n = this._visibleLines.getEndLineNumber();
      for (let s = i; s <= n; s++)
        if (this._visibleLines.getVisibleLine(s).needsMonospaceFontCheck()) {
          this._asyncCheckMonospaceFontAssumptions.schedule();
          break;
        }
    }
    this._linesContent.setLayerHinting(this._canUseLayerHinting), this._linesContent.setContain("strict");
    const t = this._context.viewLayout.getCurrentScrollTop() - e.bigNumbersDelta;
    this._linesContent.setTop(-t), this._linesContent.setLeft(-this._context.viewLayout.getCurrentScrollLeft());
  }
  // --- width
  _ensureMaxLineWidth(e) {
    const t = Math.ceil(e);
    this._maxLineWidth < t && (this._maxLineWidth = t, this._context.viewModel.viewLayout.setMaxLineWidth(this._maxLineWidth));
  }
  _computeScrollTopToRevealRange(e, t, i, n, s, o) {
    const a = e.top, l = e.height, d = a + l;
    let c, h, u;
    if (s && s.length > 0) {
      let v = s[0].startLineNumber, b = s[0].endLineNumber;
      for (let C = 1, w = s.length; C < w; C++) {
        const S = s[C];
        v = Math.min(v, S.startLineNumber), b = Math.max(b, S.endLineNumber);
      }
      c = !1, h = this._context.viewLayout.getVerticalOffsetForLineNumber(v), u = this._context.viewLayout.getVerticalOffsetForLineNumber(b) + this._lineHeight;
    } else if (n)
      c = !0, h = this._context.viewLayout.getVerticalOffsetForLineNumber(n.startLineNumber), u = this._context.viewLayout.getVerticalOffsetForLineNumber(n.endLineNumber) + this._lineHeight;
    else
      return -1;
    const g = (t === "mouse" || i) && this._cursorSurroundingLinesStyle === "default";
    let f = 0, m = 0;
    if (g)
      i || (f = this._lineHeight);
    else {
      const v = Math.min(l / this._lineHeight / 2, this._cursorSurroundingLines);
      this._stickyScrollEnabled ? f = Math.max(v, this._maxNumberStickyLines) * this._lineHeight : f = v * this._lineHeight, m = Math.max(0, v - 1) * this._lineHeight;
    }
    i || (o === 0 || o === 4) && (m += this._lineHeight), h -= f, u += m;
    let _;
    if (u - h > l) {
      if (!c)
        return -1;
      _ = h;
    } else if (o === 5 || o === 6)
      if (o === 6 && a <= h && u <= d)
        _ = a;
      else {
        const v = Math.max(5 * this._lineHeight, l * 0.2), b = h - v, C = u - l;
        _ = Math.max(C, b);
      }
    else if (o === 1 || o === 2)
      if (o === 2 && a <= h && u <= d)
        _ = a;
      else {
        const v = (h + u) / 2;
        _ = Math.max(0, v - l / 2);
      }
    else
      _ = this._computeMinimumScrolling(
        a,
        d,
        h,
        u,
        o === 3,
        o === 4
        /* viewEvents.VerticalRevealType.Bottom */
      );
    return _;
  }
  _computeScrollLeftToReveal(e) {
    const t = this._context.viewLayout.getCurrentViewport(), i = this._context.configuration.options.get(
      145
      /* EditorOption.layoutInfo */
    ), n = t.left, s = n + t.width - i.verticalScrollbarWidth;
    let o = 1073741824, a = 0;
    if (e.type === "range") {
      const d = this._visibleRangesForLineRange(e.lineNumber, e.startColumn, e.endColumn);
      if (!d)
        return null;
      for (const c of d.ranges)
        o = Math.min(o, Math.round(c.left)), a = Math.max(a, Math.round(c.left + c.width));
    } else
      for (const d of e.selections) {
        if (d.startLineNumber !== d.endLineNumber)
          return null;
        const c = this._visibleRangesForLineRange(d.startLineNumber, d.startColumn, d.endColumn);
        if (!c)
          return null;
        for (const h of c.ranges)
          o = Math.min(o, Math.round(h.left)), a = Math.max(a, Math.round(h.left + h.width));
      }
    return e.minimalReveal || (o = Math.max(0, o - A0.HORIZONTAL_EXTRA_PX), a += this._revealHorizontalRightPadding), e.type === "selections" && a - o > t.width ? null : {
      scrollLeft: this._computeMinimumScrolling(n, s, o, a),
      maxHorizontalOffset: a
    };
  }
  _computeMinimumScrolling(e, t, i, n, s, o) {
    e = e | 0, t = t | 0, i = i | 0, n = n | 0, s = !!s, o = !!o;
    const a = t - e;
    if (n - i < a) {
      if (s)
        return i;
      if (o)
        return Math.max(0, n - a);
      if (i < e)
        return i;
      if (n > t)
        return Math.max(0, n - a);
    } else
      return i;
    return e;
  }
}
A0.HORIZONTAL_EXTRA_PX = 30;
class eY extends d2 {
  constructor(e) {
    super(), this._context = e;
    const i = this._context.configuration.options.get(
      145
      /* EditorOption.layoutInfo */
    );
    this._decorationsLeft = i.decorationsLeft, this._decorationsWidth = i.decorationsWidth, this._renderResult = null, this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this), this._renderResult = null, super.dispose();
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    const i = this._context.configuration.options.get(
      145
      /* EditorOption.layoutInfo */
    );
    return this._decorationsLeft = i.decorationsLeft, this._decorationsWidth = i.decorationsWidth, !0;
  }
  onDecorationsChanged(e) {
    return !0;
  }
  onFlushed(e) {
    return !0;
  }
  onLinesChanged(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged;
  }
  onZonesChanged(e) {
    return !0;
  }
  // --- end event handlers
  _getDecorations(e) {
    var t, i;
    const n = e.getDecorationsInViewport(), s = [];
    let o = 0;
    for (let a = 0, l = n.length; a < l; a++) {
      const d = n[a], c = d.options.linesDecorationsClassName, h = d.options.zIndex;
      c && (s[o++] = new eI(d.range.startLineNumber, d.range.endLineNumber, c, (t = d.options.linesDecorationsTooltip) !== null && t !== void 0 ? t : null, h));
      const u = d.options.firstLineDecorationClassName;
      u && (s[o++] = new eI(d.range.startLineNumber, d.range.startLineNumber, u, (i = d.options.linesDecorationsTooltip) !== null && i !== void 0 ? i : null, h));
    }
    return s;
  }
  prepareRender(e) {
    const t = e.visibleRange.startLineNumber, i = e.visibleRange.endLineNumber, n = this._render(t, i, this._getDecorations(e)), s = this._decorationsLeft.toString(), o = this._decorationsWidth.toString(), a = '" style="left:' + s + "px;width:" + o + 'px;"></div>', l = [];
    for (let d = t; d <= i; d++) {
      const c = d - t, h = n[c].getDecorations();
      let u = "";
      for (const g of h) {
        let f = '<div class="cldr ' + g.className;
        g.tooltip !== null && (f += '" title="' + g.tooltip), f += a, u += f;
      }
      l[c] = u;
    }
    this._renderResult = l;
  }
  render(e, t) {
    return this._renderResult ? this._renderResult[t - e] : "";
  }
}
class tY extends d2 {
  constructor(e) {
    super(), this._context = e, this._renderResult = null, this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this), this._renderResult = null, super.dispose();
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    return !0;
  }
  onDecorationsChanged(e) {
    return !0;
  }
  onFlushed(e) {
    return !0;
  }
  onLinesChanged(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged;
  }
  onZonesChanged(e) {
    return !0;
  }
  // --- end event handlers
  _getDecorations(e) {
    const t = e.getDecorationsInViewport(), i = [];
    let n = 0;
    for (let s = 0, o = t.length; s < o; s++) {
      const a = t[s], l = a.options.marginClassName, d = a.options.zIndex;
      l && (i[n++] = new eI(a.range.startLineNumber, a.range.endLineNumber, l, null, d));
    }
    return i;
  }
  prepareRender(e) {
    const t = e.visibleRange.startLineNumber, i = e.visibleRange.endLineNumber, n = this._render(t, i, this._getDecorations(e)), s = [];
    for (let o = t; o <= i; o++) {
      const a = o - t, l = n[a].getDecorations();
      let d = "";
      for (const c of l)
        d += '<div class="cmdr ' + c.className + '" style=""></div>';
      s[a] = d;
    }
    this._renderResult = s;
  }
  render(e, t) {
    return this._renderResult ? this._renderResult[t - e] : "";
  }
}
class ho {
  constructor(e, t, i, n) {
    this._rgba8Brand = void 0, this.r = ho._clamp(e), this.g = ho._clamp(t), this.b = ho._clamp(i), this.a = ho._clamp(n);
  }
  equals(e) {
    return this.r === e.r && this.g === e.g && this.b === e.b && this.a === e.a;
  }
  static _clamp(e) {
    return e < 0 ? 0 : e > 255 ? 255 : e | 0;
  }
}
ho.Empty = new ho(0, 0, 0, 0);
class bb extends P {
  static getInstance() {
    return this._INSTANCE || (this._INSTANCE = T_(new bb())), this._INSTANCE;
  }
  constructor() {
    super(), this._onDidChange = new R(), this.onDidChange = this._onDidChange.event, this._updateColorMap(), this._register(ri.onDidChange((e) => {
      e.changedColorMap && this._updateColorMap();
    }));
  }
  _updateColorMap() {
    const e = ri.getColorMap();
    if (!e) {
      this._colors = [ho.Empty], this._backgroundIsLight = !0;
      return;
    }
    this._colors = [ho.Empty];
    for (let i = 1; i < e.length; i++) {
      const n = e[i].rgba;
      this._colors[i] = new ho(n.r, n.g, n.b, Math.round(n.a * 255));
    }
    const t = e[
      2
      /* ColorId.DefaultBackground */
    ].getRelativeLuminance();
    this._backgroundIsLight = t >= 0.5, this._onDidChange.fire(void 0);
  }
  getColor(e) {
    return (e < 1 || e >= this._colors.length) && (e = 2), this._colors[e];
  }
  backgroundIsLight() {
    return this._backgroundIsLight;
  }
}
bb._INSTANCE = null;
const iY = (() => {
  const r = [];
  for (let e = 32; e <= 126; e++)
    r.push(e);
  return r.push(
    65533
    /* Constants.UNKNOWN_CODE */
  ), r;
})(), nY = (r, e) => (r -= 32, r < 0 || r > 96 ? e <= 2 ? (r + 96) % 96 : 95 : r);
class G_ {
  constructor(e, t) {
    this.scale = t, this._minimapCharRendererBrand = void 0, this.charDataNormal = G_.soften(e, 12 / 15), this.charDataLight = G_.soften(e, 50 / 60);
  }
  static soften(e, t) {
    const i = new Uint8ClampedArray(e.length);
    for (let n = 0, s = e.length; n < s; n++)
      i[n] = YB(e[n] * t);
    return i;
  }
  renderChar(e, t, i, n, s, o, a, l, d, c, h) {
    const u = 1 * this.scale, g = 2 * this.scale, f = h ? 1 : g;
    if (t + u > e.width || i + f > e.height) {
      console.warn("bad render request outside image data");
      return;
    }
    const m = c ? this.charDataLight : this.charDataNormal, _ = nY(n, d), v = e.width * 4, b = a.r, C = a.g, w = a.b, S = s.r - b, y = s.g - C, k = s.b - w, E = Math.max(o, l), N = e.data;
    let F = _ * u * g, V = i * v + t * 4;
    for (let Z = 0; Z < f; Z++) {
      let H = V;
      for (let re = 0; re < u; re++) {
        const ue = m[F++] / 255 * (o / 255);
        N[H++] = b + S * ue, N[H++] = C + y * ue, N[H++] = w + k * ue, N[H++] = E;
      }
      V += v;
    }
  }
  blockRenderChar(e, t, i, n, s, o, a, l) {
    const d = 1 * this.scale, c = 2 * this.scale, h = l ? 1 : c;
    if (t + d > e.width || i + h > e.height) {
      console.warn("bad render request outside image data");
      return;
    }
    const u = e.width * 4, g = 0.5 * (s / 255), f = o.r, m = o.g, _ = o.b, v = n.r - f, b = n.g - m, C = n.b - _, w = f + v * g, S = m + b * g, y = _ + C * g, k = Math.max(s, a), E = e.data;
    let N = i * u + t * 4;
    for (let F = 0; F < h; F++) {
      let V = N;
      for (let Z = 0; Z < d; Z++)
        E[V++] = w, E[V++] = S, E[V++] = y, E[V++] = k;
      N += u;
    }
  }
}
const kP = {
  0: 0,
  1: 1,
  2: 2,
  3: 3,
  4: 4,
  5: 5,
  6: 6,
  7: 7,
  8: 8,
  9: 9,
  A: 10,
  B: 11,
  C: 12,
  D: 13,
  E: 14,
  F: 15
}, xP = (r) => {
  const e = new Uint8ClampedArray(r.length / 2);
  for (let t = 0; t < r.length; t += 2)
    e[t >> 1] = kP[r[t]] << 4 | kP[r[t + 1]] & 15;
  return e;
}, IP = {
  1: Ff(() => xP("0000511D6300CF609C709645A78432005642574171487021003C451900274D35D762755E8B629C5BA856AF57BA649530C167D1512A272A3F6038604460398526BCA2A968DB6F8957C768BE5FBE2FB467CF5D8D5B795DC7625B5DFF50DE64C466DB2FC47CD860A65E9A2EB96CB54CE06DA763AB2EA26860524D3763536601005116008177A8705E53AB738E6A982F88BAA35B5F5B626D9C636B449B737E5B7B678598869A662F6B5B8542706C704C80736A607578685B70594A49715A4522E792")),
  2: Ff(() => xP("000000000000000055394F383D2800008B8B1F210002000081B1CBCBCC820000847AAF6B9AAF2119BE08B8881AD60000A44FD07DCCF107015338130C00000000385972265F390B406E2437634B4B48031B12B8A0847000001E15B29A402F0000000000004B33460B00007A752C2A0000000000004D3900000084394B82013400ABA5CFC7AD9C0302A45A3E5A98AB000089A43382D97900008BA54AA087A70A0248A6A7AE6DBE0000BF6F94987EA40A01A06DCFA7A7A9030496C32F77891D0000A99FB1A0AFA80603B29AB9CA75930D010C0948354D3900000C0948354F37460D0028BE673D8400000000AF9D7B6E00002B007AA8933400007AA642675C2700007984CFB9C3985B768772A8A6B7B20000CAAECAAFC4B700009F94A6009F840009D09F9BA4CA9C0000CC8FC76DC87F0000C991C472A2000000A894A48CA7B501079BA2C9C69BA20000B19A5D3FA89000005CA6009DA2960901B0A7F0669FB200009D009E00B7890000DAD0F5D092820000D294D4C48BD10000B5A7A4A3B1A50402CAB6CBA6A2000000B5A7A4A3B1A8044FCDADD19D9CB00000B7778F7B8AAE0803C9AB5D3F5D3F00009EA09EA0BAB006039EA0989A8C7900009B9EF4D6B7C00000A9A7816CACA80000ABAC84705D3F000096DA635CDC8C00006F486F266F263D4784006124097B00374F6D2D6D2D6D4A3A95872322000000030000000000008D8939130000000000002E22A5C9CBC70600AB25C0B5C9B400061A2DB04CA67001082AA6BEBEBFC606002321DACBC19E03087AA08B6768380000282FBAC0B8CA7A88AD25BBA5A29900004C396C5894A6000040485A6E356E9442A32CD17EADA70000B4237923628600003E2DE9C1D7B500002F25BBA5A2990000231DB6AFB4A804023025C0B5CAB588062B2CBDBEC0C706882435A75CA20000002326BD6A82A908048B4B9A5A668000002423A09CB4BB060025259C9D8A7900001C1FCAB2C7C700002A2A9387ABA200002626A4A47D6E9D14333163A0C87500004B6F9C2D643A257049364936493647358A34438355497F1A0000A24C1D590000D38DFFBDD4CD3126"))
};
class o_ {
  /**
   * Creates a new character renderer factory with the given scale.
   */
  static create(e, t) {
    if (this.lastCreated && e === this.lastCreated.scale && t === this.lastFontFamily)
      return this.lastCreated;
    let i;
    return IP[e] ? i = new G_(IP[e](), e) : i = o_.createFromSampleData(o_.createSampleData(t).data, e), this.lastFontFamily = t, this.lastCreated = i, i;
  }
  /**
   * Creates the font sample data, writing to a canvas.
   */
  static createSampleData(e) {
    const t = document.createElement("canvas"), i = t.getContext("2d");
    t.style.height = "16px", t.height = 16, t.width = 96 * 10, t.style.width = 96 * 10 + "px", i.fillStyle = "#ffffff", i.font = `bold 16px ${e}`, i.textBaseline = "middle";
    let n = 0;
    for (const s of iY)
      i.fillText(String.fromCharCode(s), n, 16 / 2), n += 10;
    return i.getImageData(
      0,
      0,
      96 * 10,
      16
      /* Constants.SAMPLED_CHAR_HEIGHT */
    );
  }
  /**
   * Creates a character renderer from the canvas sample data.
   */
  static createFromSampleData(e, t) {
    if (e.length !== 61440)
      throw new Error("Unexpected source in MinimapCharRenderer");
    const n = o_._downsample(e, t);
    return new G_(n, t);
  }
  static _downsampleChar(e, t, i, n, s) {
    const o = 1 * s, a = 2 * s;
    let l = n, d = 0;
    for (let c = 0; c < a; c++) {
      const h = c / a * 16, u = (c + 1) / a * 16;
      for (let g = 0; g < o; g++) {
        const f = g / o * 10, m = (g + 1) / o * 10;
        let _ = 0, v = 0;
        for (let C = h; C < u; C++) {
          const w = t + Math.floor(C) * 3840, S = 1 - (C - Math.floor(C));
          for (let y = f; y < m; y++) {
            const k = 1 - (y - Math.floor(y)), E = w + Math.floor(y) * 4, N = k * S;
            v += N, _ += e[E] * e[E + 3] / 255 * N;
          }
        }
        const b = _ / v;
        d = Math.max(d, b), i[l++] = YB(b);
      }
    }
    return d;
  }
  static _downsample(e, t) {
    const i = 2 * t * 1 * t, n = i * 96, s = new Uint8ClampedArray(n);
    let o = 0, a = 0, l = 0;
    for (let d = 0; d < 96; d++)
      l = Math.max(l, this._downsampleChar(e, a, s, o, t)), o += i, a += 10 * 4;
    if (l > 0) {
      const d = 255 / l;
      for (let c = 0; c < n; c++)
        s[c] *= d;
    }
    return s;
  }
}
const sY = Ks ? '"Segoe WPC", "Segoe UI", sans-serif' : Je ? "-apple-system, BlinkMacSystemFont, sans-serif" : 'system-ui, "Ubuntu", "Droid Sans", sans-serif', oY = 140, rY = 2;
class wf {
  constructor(e, t, i) {
    const n = e.options, s = n.get(
      143
      /* EditorOption.pixelRatio */
    ), o = n.get(
      145
      /* EditorOption.layoutInfo */
    ), a = o.minimap, l = n.get(
      50
      /* EditorOption.fontInfo */
    ), d = n.get(
      73
      /* EditorOption.minimap */
    );
    this.renderMinimap = a.renderMinimap, this.size = d.size, this.minimapHeightIsEditorHeight = a.minimapHeightIsEditorHeight, this.scrollBeyondLastLine = n.get(
      105
      /* EditorOption.scrollBeyondLastLine */
    ), this.paddingTop = n.get(
      84
      /* EditorOption.padding */
    ).top, this.paddingBottom = n.get(
      84
      /* EditorOption.padding */
    ).bottom, this.showSlider = d.showSlider, this.autohide = d.autohide, this.pixelRatio = s, this.typicalHalfwidthCharacterWidth = l.typicalHalfwidthCharacterWidth, this.lineHeight = n.get(
      67
      /* EditorOption.lineHeight */
    ), this.minimapLeft = a.minimapLeft, this.minimapWidth = a.minimapWidth, this.minimapHeight = o.height, this.canvasInnerWidth = a.minimapCanvasInnerWidth, this.canvasInnerHeight = a.minimapCanvasInnerHeight, this.canvasOuterWidth = a.minimapCanvasOuterWidth, this.canvasOuterHeight = a.minimapCanvasOuterHeight, this.isSampling = a.minimapIsSampling, this.editorHeight = o.height, this.fontScale = a.minimapScale, this.minimapLineHeight = a.minimapLineHeight, this.minimapCharWidth = 1 * this.fontScale, this.sectionHeaderFontFamily = sY, this.sectionHeaderFontSize = d.sectionHeaderFontSize * s, this.sectionHeaderLetterSpacing = d.sectionHeaderLetterSpacing, this.sectionHeaderFontColor = wf._getSectionHeaderColor(t, i.getColor(
      1
      /* ColorId.DefaultForeground */
    )), this.charRenderer = Ff(() => o_.create(this.fontScale, l.fontFamily)), this.defaultBackgroundColor = i.getColor(
      2
      /* ColorId.DefaultBackground */
    ), this.backgroundColor = wf._getMinimapBackground(t, this.defaultBackgroundColor), this.foregroundAlpha = wf._getMinimapForegroundOpacity(t);
  }
  static _getMinimapBackground(e, t) {
    const i = e.getColor(KG);
    return i ? new ho(i.rgba.r, i.rgba.g, i.rgba.b, Math.round(255 * i.rgba.a)) : t;
  }
  static _getMinimapForegroundOpacity(e) {
    const t = e.getColor(jG);
    return t ? ho._clamp(Math.round(255 * t.rgba.a)) : 255;
  }
  static _getSectionHeaderColor(e, t) {
    const i = e.getColor(No);
    return i ? new ho(i.rgba.r, i.rgba.g, i.rgba.b, Math.round(255 * i.rgba.a)) : t;
  }
  equals(e) {
    return this.renderMinimap === e.renderMinimap && this.size === e.size && this.minimapHeightIsEditorHeight === e.minimapHeightIsEditorHeight && this.scrollBeyondLastLine === e.scrollBeyondLastLine && this.paddingTop === e.paddingTop && this.paddingBottom === e.paddingBottom && this.showSlider === e.showSlider && this.autohide === e.autohide && this.pixelRatio === e.pixelRatio && this.typicalHalfwidthCharacterWidth === e.typicalHalfwidthCharacterWidth && this.lineHeight === e.lineHeight && this.minimapLeft === e.minimapLeft && this.minimapWidth === e.minimapWidth && this.minimapHeight === e.minimapHeight && this.canvasInnerWidth === e.canvasInnerWidth && this.canvasInnerHeight === e.canvasInnerHeight && this.canvasOuterWidth === e.canvasOuterWidth && this.canvasOuterHeight === e.canvasOuterHeight && this.isSampling === e.isSampling && this.editorHeight === e.editorHeight && this.fontScale === e.fontScale && this.minimapLineHeight === e.minimapLineHeight && this.minimapCharWidth === e.minimapCharWidth && this.sectionHeaderFontSize === e.sectionHeaderFontSize && this.sectionHeaderLetterSpacing === e.sectionHeaderLetterSpacing && this.defaultBackgroundColor && this.defaultBackgroundColor.equals(e.defaultBackgroundColor) && this.backgroundColor && this.backgroundColor.equals(e.backgroundColor) && this.foregroundAlpha === e.foregroundAlpha;
  }
}
class r_ {
  constructor(e, t, i, n, s, o, a, l, d) {
    this.scrollTop = e, this.scrollHeight = t, this.sliderNeeded = i, this._computedSliderRatio = n, this.sliderTop = s, this.sliderHeight = o, this.topPaddingLineCount = a, this.startLineNumber = l, this.endLineNumber = d;
  }
  /**
   * Compute a desired `scrollPosition` such that the slider moves by `delta`.
   */
  getDesiredScrollTopFromDelta(e) {
    return Math.round(this.scrollTop + e / this._computedSliderRatio);
  }
  getDesiredScrollTopFromTouchLocation(e) {
    return Math.round((e - this.sliderHeight / 2) / this._computedSliderRatio);
  }
  /**
   * Intersect a line range with `this.startLineNumber` and `this.endLineNumber`.
   */
  intersectWithViewport(e) {
    const t = Math.max(this.startLineNumber, e.startLineNumber), i = Math.min(this.endLineNumber, e.endLineNumber);
    return t > i ? null : [t, i];
  }
  /**
   * Get the inner minimap y coordinate for a line number.
   */
  getYForLineNumber(e, t) {
    return +(e - this.startLineNumber + this.topPaddingLineCount) * t;
  }
  static create(e, t, i, n, s, o, a, l, d, c, h) {
    const u = e.pixelRatio, g = e.minimapLineHeight, f = Math.floor(e.canvasInnerHeight / g), m = e.lineHeight;
    if (e.minimapHeightIsEditorHeight) {
      let y = l * e.lineHeight + e.paddingTop + e.paddingBottom;
      e.scrollBeyondLastLine && (y += Math.max(0, s - e.lineHeight - e.paddingBottom));
      const k = Math.max(1, Math.floor(s * s / y)), E = Math.max(0, e.minimapHeight - k), N = E / (c - s), F = d * N, V = E > 0, Z = Math.floor(e.canvasInnerHeight / e.minimapLineHeight), H = Math.floor(e.paddingTop / e.lineHeight);
      return new r_(d, c, V, N, F, k, H, 1, Math.min(a, Z));
    }
    let _;
    if (o && i !== a) {
      const y = i - t + 1;
      _ = Math.floor(y * g / u);
    } else {
      const y = s / m;
      _ = Math.floor(y * g / u);
    }
    const v = Math.floor(e.paddingTop / m);
    let b = Math.floor(e.paddingBottom / m);
    if (e.scrollBeyondLastLine) {
      const y = s / m;
      b = Math.max(b, y - 1);
    }
    let C;
    if (b > 0) {
      const y = s / m;
      C = (v + a + b - y - 1) * g / u;
    } else
      C = Math.max(0, (v + a) * g / u - _);
    C = Math.min(e.minimapHeight - _, C);
    const w = C / (c - s), S = d * w;
    if (f >= v + a + b) {
      const y = C > 0;
      return new r_(d, c, y, w, S, _, v, 1, a);
    } else {
      let y;
      t > 1 ? y = t + v : y = Math.max(1, d / m);
      let k, E = Math.max(1, Math.floor(y - S * u / g));
      E < v ? (k = v - E + 1, E = 1) : (k = 0, E = Math.max(1, E - v)), h && h.scrollHeight === c && (h.scrollTop > d && (E = Math.min(E, h.startLineNumber), k = Math.max(k, h.topPaddingLineCount)), h.scrollTop < d && (E = Math.max(E, h.startLineNumber), k = Math.min(k, h.topPaddingLineCount)));
      const N = Math.min(a, E - k + f - 1), F = (d - n) / m;
      let V;
      return d >= e.paddingTop ? V = (t - E + k + F) * g / u : V = d / e.paddingTop * (k + F) * g / u, new r_(d, c, !0, w, V, _, k, E, N);
    }
  }
}
class DS {
  constructor(e) {
    this.dy = e;
  }
  onContentChanged() {
    this.dy = -1;
  }
  onTokensChanged() {
    this.dy = -1;
  }
}
DS.INVALID = new DS(-1);
class EP {
  constructor(e, t, i) {
    this.renderedLayout = e, this._imageData = t, this._renderedLines = new o2(() => DS.INVALID), this._renderedLines._set(e.startLineNumber, i);
  }
  /**
   * Check if the current RenderData matches accurately the new desired layout and no painting is needed.
   */
  linesEquals(e) {
    if (!this.scrollEquals(e))
      return !1;
    const i = this._renderedLines._get().lines;
    for (let n = 0, s = i.length; n < s; n++)
      if (i[n].dy === -1)
        return !1;
    return !0;
  }
  /**
   * Check if the current RenderData matches the new layout's scroll position
   */
  scrollEquals(e) {
    return this.renderedLayout.startLineNumber === e.startLineNumber && this.renderedLayout.endLineNumber === e.endLineNumber;
  }
  _get() {
    const e = this._renderedLines._get();
    return {
      imageData: this._imageData,
      rendLineNumberStart: e.rendLineNumberStart,
      lines: e.lines
    };
  }
  onLinesChanged(e, t) {
    return this._renderedLines.onLinesChanged(e, t);
  }
  onLinesDeleted(e, t) {
    this._renderedLines.onLinesDeleted(e, t);
  }
  onLinesInserted(e, t) {
    this._renderedLines.onLinesInserted(e, t);
  }
  onTokensChanged(e) {
    return this._renderedLines.onTokensChanged(e);
  }
}
class R1 {
  constructor(e, t, i, n) {
    this._backgroundFillData = R1._createBackgroundFillData(t, i, n), this._buffers = [
      e.createImageData(t, i),
      e.createImageData(t, i)
    ], this._lastUsedBuffer = 0;
  }
  getBuffer() {
    this._lastUsedBuffer = 1 - this._lastUsedBuffer;
    const e = this._buffers[this._lastUsedBuffer];
    return e.data.set(this._backgroundFillData), e;
  }
  static _createBackgroundFillData(e, t, i) {
    const n = i.r, s = i.g, o = i.b, a = i.a, l = new Uint8ClampedArray(e * t * 4);
    let d = 0;
    for (let c = 0; c < t; c++)
      for (let h = 0; h < e; h++)
        l[d] = n, l[d + 1] = s, l[d + 2] = o, l[d + 3] = a, d += 4;
    return l;
  }
}
class Z_ {
  static compute(e, t, i) {
    if (e.renderMinimap === 0 || !e.isSampling)
      return [null, []];
    const { minimapLineCount: n } = hf.computeContainedMinimapLineCount({
      viewLineCount: t,
      scrollBeyondLastLine: e.scrollBeyondLastLine,
      paddingTop: e.paddingTop,
      paddingBottom: e.paddingBottom,
      height: e.editorHeight,
      lineHeight: e.lineHeight,
      pixelRatio: e.pixelRatio
    }), s = t / n, o = s / 2;
    if (!i || i.minimapLines.length === 0) {
      const _ = [];
      if (_[0] = 1, n > 1) {
        for (let v = 0, b = n - 1; v < b; v++)
          _[v] = Math.round(v * s + o);
        _[n - 1] = t;
      }
      return [new Z_(s, _), []];
    }
    const a = i.minimapLines, l = a.length, d = [];
    let c = 0, h = 0, u = 1;
    const g = 10;
    let f = [], m = null;
    for (let _ = 0; _ < n; _++) {
      const v = Math.max(u, Math.round(_ * s)), b = Math.max(v, Math.round((_ + 1) * s));
      for (; c < l && a[c] < v; ) {
        if (f.length < g) {
          const w = c + 1 + h;
          m && m.type === "deleted" && m._oldIndex === c - 1 ? m.deleteToLineNumber++ : (m = { type: "deleted", _oldIndex: c, deleteFromLineNumber: w, deleteToLineNumber: w }, f.push(m)), h--;
        }
        c++;
      }
      let C;
      if (c < l && a[c] <= b)
        C = a[c], c++;
      else if (_ === 0 ? C = 1 : _ + 1 === n ? C = t : C = Math.round(_ * s + o), f.length < g) {
        const w = c + 1 + h;
        m && m.type === "inserted" && m._i === _ - 1 ? m.insertToLineNumber++ : (m = { type: "inserted", _i: _, insertFromLineNumber: w, insertToLineNumber: w }, f.push(m)), h++;
      }
      d[_] = C, u = C;
    }
    if (f.length < g)
      for (; c < l; ) {
        const _ = c + 1 + h;
        m && m.type === "deleted" && m._oldIndex === c - 1 ? m.deleteToLineNumber++ : (m = { type: "deleted", _oldIndex: c, deleteFromLineNumber: _, deleteToLineNumber: _ }, f.push(m)), h--, c++;
      }
    else
      f = [{ type: "flush" }];
    return [new Z_(s, d), f];
  }
  constructor(e, t) {
    this.samplingRatio = e, this.minimapLines = t;
  }
  modelLineToMinimapLine(e) {
    return Math.min(this.minimapLines.length, Math.max(1, Math.round(e / this.samplingRatio)));
  }
  /**
   * Will return null if the model line ranges are not intersecting with a sampled model line.
   */
  modelLineRangeToMinimapLineRange(e, t) {
    let i = this.modelLineToMinimapLine(e) - 1;
    for (; i > 0 && this.minimapLines[i - 1] >= e; )
      i--;
    let n = this.modelLineToMinimapLine(t) - 1;
    for (; n + 1 < this.minimapLines.length && this.minimapLines[n + 1] <= t; )
      n++;
    if (i === n) {
      const s = this.minimapLines[i];
      if (s < e || s > t)
        return null;
    }
    return [i + 1, n + 1];
  }
  /**
   * Will always return a range, even if it is not intersecting with a sampled model line.
   */
  decorationLineRangeToMinimapLineRange(e, t) {
    let i = this.modelLineToMinimapLine(e), n = this.modelLineToMinimapLine(t);
    return e !== t && n === i && (n === this.minimapLines.length ? i > 1 && i-- : n++), [i, n];
  }
  onLinesDeleted(e) {
    const t = e.toLineNumber - e.fromLineNumber + 1;
    let i = this.minimapLines.length, n = 0;
    for (let s = this.minimapLines.length - 1; s >= 0 && !(this.minimapLines[s] < e.fromLineNumber); s--)
      this.minimapLines[s] <= e.toLineNumber ? (this.minimapLines[s] = Math.max(1, e.fromLineNumber - 1), i = Math.min(i, s), n = Math.max(n, s)) : this.minimapLines[s] -= t;
    return [i, n];
  }
  onLinesInserted(e) {
    const t = e.toLineNumber - e.fromLineNumber + 1;
    for (let i = this.minimapLines.length - 1; i >= 0 && !(this.minimapLines[i] < e.fromLineNumber); i--)
      this.minimapLines[i] += t;
  }
}
class aY extends Gs {
  constructor(e) {
    super(e), this._sectionHeaderCache = new Cd(10, 1.5), this.tokensColorTracker = bb.getInstance(), this._selections = [], this._minimapSelections = null, this.options = new wf(this._context.configuration, this._context.theme, this.tokensColorTracker);
    const [t] = Z_.compute(this.options, this._context.viewModel.getLineCount(), null);
    this._samplingState = t, this._shouldCheckSampling = !1, this._actual = new Xg(e.theme, this);
  }
  dispose() {
    this._actual.dispose(), super.dispose();
  }
  getDomNode() {
    return this._actual.getDomNode();
  }
  _onOptionsMaybeChanged() {
    const e = new wf(this._context.configuration, this._context.theme, this.tokensColorTracker);
    return this.options.equals(e) ? !1 : (this.options = e, this._recreateLineSampling(), this._actual.onDidChangeOptions(), !0);
  }
  // ---- begin view event handlers
  onConfigurationChanged(e) {
    return this._onOptionsMaybeChanged();
  }
  onCursorStateChanged(e) {
    return this._selections = e.selections, this._minimapSelections = null, this._actual.onSelectionChanged();
  }
  onDecorationsChanged(e) {
    return e.affectsMinimap ? this._actual.onDecorationsChanged() : !1;
  }
  onFlushed(e) {
    return this._samplingState && (this._shouldCheckSampling = !0), this._actual.onFlushed();
  }
  onLinesChanged(e) {
    if (this._samplingState) {
      const t = this._samplingState.modelLineRangeToMinimapLineRange(e.fromLineNumber, e.fromLineNumber + e.count - 1);
      return t ? this._actual.onLinesChanged(t[0], t[1] - t[0] + 1) : !1;
    } else
      return this._actual.onLinesChanged(e.fromLineNumber, e.count);
  }
  onLinesDeleted(e) {
    if (this._samplingState) {
      const [t, i] = this._samplingState.onLinesDeleted(e);
      return t <= i && this._actual.onLinesChanged(t + 1, i - t + 1), this._shouldCheckSampling = !0, !0;
    } else
      return this._actual.onLinesDeleted(e.fromLineNumber, e.toLineNumber);
  }
  onLinesInserted(e) {
    return this._samplingState ? (this._samplingState.onLinesInserted(e), this._shouldCheckSampling = !0, !0) : this._actual.onLinesInserted(e.fromLineNumber, e.toLineNumber);
  }
  onScrollChanged(e) {
    return this._actual.onScrollChanged();
  }
  onThemeChanged(e) {
    return this._actual.onThemeChanged(), this._onOptionsMaybeChanged(), !0;
  }
  onTokensChanged(e) {
    if (this._samplingState) {
      const t = [];
      for (const i of e.ranges) {
        const n = this._samplingState.modelLineRangeToMinimapLineRange(i.fromLineNumber, i.toLineNumber);
        n && t.push({ fromLineNumber: n[0], toLineNumber: n[1] });
      }
      return t.length ? this._actual.onTokensChanged(t) : !1;
    } else
      return this._actual.onTokensChanged(e.ranges);
  }
  onTokensColorsChanged(e) {
    return this._onOptionsMaybeChanged(), this._actual.onTokensColorsChanged();
  }
  onZonesChanged(e) {
    return this._actual.onZonesChanged();
  }
  // --- end event handlers
  prepareRender(e) {
    this._shouldCheckSampling && (this._shouldCheckSampling = !1, this._recreateLineSampling());
  }
  render(e) {
    let t = e.visibleRange.startLineNumber, i = e.visibleRange.endLineNumber;
    this._samplingState && (t = this._samplingState.modelLineToMinimapLine(t), i = this._samplingState.modelLineToMinimapLine(i));
    const n = {
      viewportContainsWhitespaceGaps: e.viewportData.whitespaceViewportData.length > 0,
      scrollWidth: e.scrollWidth,
      scrollHeight: e.scrollHeight,
      viewportStartLineNumber: t,
      viewportEndLineNumber: i,
      viewportStartLineNumberVerticalOffset: e.getVerticalOffsetForLineNumber(t),
      scrollTop: e.scrollTop,
      scrollLeft: e.scrollLeft,
      viewportWidth: e.viewportWidth,
      viewportHeight: e.viewportHeight
    };
    this._actual.render(n);
  }
  //#region IMinimapModel
  _recreateLineSampling() {
    this._minimapSelections = null;
    const e = !!this._samplingState, [t, i] = Z_.compute(this.options, this._context.viewModel.getLineCount(), this._samplingState);
    if (this._samplingState = t, e && this._samplingState)
      for (const n of i)
        switch (n.type) {
          case "deleted":
            this._actual.onLinesDeleted(n.deleteFromLineNumber, n.deleteToLineNumber);
            break;
          case "inserted":
            this._actual.onLinesInserted(n.insertFromLineNumber, n.insertToLineNumber);
            break;
          case "flush":
            this._actual.onFlushed();
            break;
        }
  }
  getLineCount() {
    return this._samplingState ? this._samplingState.minimapLines.length : this._context.viewModel.getLineCount();
  }
  getRealLineCount() {
    return this._context.viewModel.getLineCount();
  }
  getLineContent(e) {
    return this._samplingState ? this._context.viewModel.getLineContent(this._samplingState.minimapLines[e - 1]) : this._context.viewModel.getLineContent(e);
  }
  getLineMaxColumn(e) {
    return this._samplingState ? this._context.viewModel.getLineMaxColumn(this._samplingState.minimapLines[e - 1]) : this._context.viewModel.getLineMaxColumn(e);
  }
  getMinimapLinesRenderingData(e, t, i) {
    if (this._samplingState) {
      const n = [];
      for (let s = 0, o = t - e + 1; s < o; s++)
        i[s] ? n[s] = this._context.viewModel.getViewLineData(this._samplingState.minimapLines[e + s - 1]) : n[s] = null;
      return n;
    }
    return this._context.viewModel.getMinimapLinesRenderingData(e, t, i).data;
  }
  getSelections() {
    if (this._minimapSelections === null)
      if (this._samplingState) {
        this._minimapSelections = [];
        for (const e of this._selections) {
          const [t, i] = this._samplingState.decorationLineRangeToMinimapLineRange(e.startLineNumber, e.endLineNumber);
          this._minimapSelections.push(new ge(t, e.startColumn, i, e.endColumn));
        }
      } else
        this._minimapSelections = this._selections;
    return this._minimapSelections;
  }
  getMinimapDecorationsInViewport(e, t) {
    const i = this._getMinimapDecorationsInViewport(e, t).filter((n) => {
      var s;
      return !(!((s = n.options.minimap) === null || s === void 0) && s.sectionHeaderStyle);
    });
    if (this._samplingState) {
      const n = [];
      for (const s of i) {
        if (!s.options.minimap)
          continue;
        const o = s.range, a = this._samplingState.modelLineToMinimapLine(o.startLineNumber), l = this._samplingState.modelLineToMinimapLine(o.endLineNumber);
        n.push(new wV(new L(a, o.startColumn, l, o.endColumn), s.options));
      }
      return n;
    }
    return i;
  }
  getSectionHeaderDecorationsInViewport(e, t) {
    const i = this.options.minimapLineHeight, s = this.options.sectionHeaderFontSize / i;
    return e = Math.floor(Math.max(1, e - s)), this._getMinimapDecorationsInViewport(e, t).filter((o) => {
      var a;
      return !!(!((a = o.options.minimap) === null || a === void 0) && a.sectionHeaderStyle);
    });
  }
  _getMinimapDecorationsInViewport(e, t) {
    let i;
    if (this._samplingState) {
      const n = this._samplingState.minimapLines[e - 1], s = this._samplingState.minimapLines[t - 1];
      i = new L(n, 1, s, this._context.viewModel.getLineMaxColumn(s));
    } else
      i = new L(e, 1, t, this._context.viewModel.getLineMaxColumn(t));
    return this._context.viewModel.getMinimapDecorationsInRange(i);
  }
  getSectionHeaderText(e, t) {
    var i;
    const n = (i = e.options.minimap) === null || i === void 0 ? void 0 : i.sectionHeaderText;
    if (!n)
      return null;
    const s = this._sectionHeaderCache.get(n);
    if (s)
      return s;
    const o = t(n);
    return this._sectionHeaderCache.set(n, o), o;
  }
  getOptions() {
    return this._context.viewModel.model.getOptions();
  }
  revealLineNumber(e) {
    this._samplingState && (e = this._samplingState.minimapLines[e - 1]), this._context.viewModel.revealRange(
      "mouse",
      !1,
      new L(e, 1, e, 1),
      1,
      0
      /* ScrollType.Smooth */
    );
  }
  setScrollTop(e) {
    this._context.viewModel.viewLayout.setScrollPosition(
      {
        scrollTop: e
      },
      1
      /* ScrollType.Immediate */
    );
  }
}
class Xg extends P {
  constructor(e, t) {
    super(), this._renderDecorations = !1, this._gestureInProgress = !1, this._theme = e, this._model = t, this._lastRenderData = null, this._buffers = null, this._selectionColor = this._theme.getColor(cP), this._domNode = bt(document.createElement("div")), Jr.write(
      this._domNode,
      9
      /* PartFingerprint.Minimap */
    ), this._domNode.setClassName(this._getMinimapDomNodeClassName()), this._domNode.setPosition("absolute"), this._domNode.setAttribute("role", "presentation"), this._domNode.setAttribute("aria-hidden", "true"), this._shadow = bt(document.createElement("div")), this._shadow.setClassName("minimap-shadow-hidden"), this._domNode.appendChild(this._shadow), this._canvas = bt(document.createElement("canvas")), this._canvas.setPosition("absolute"), this._canvas.setLeft(0), this._domNode.appendChild(this._canvas), this._decorationsCanvas = bt(document.createElement("canvas")), this._decorationsCanvas.setPosition("absolute"), this._decorationsCanvas.setClassName("minimap-decorations-layer"), this._decorationsCanvas.setLeft(0), this._domNode.appendChild(this._decorationsCanvas), this._slider = bt(document.createElement("div")), this._slider.setPosition("absolute"), this._slider.setClassName("minimap-slider"), this._slider.setLayerHinting(!0), this._slider.setContain("strict"), this._domNode.appendChild(this._slider), this._sliderHorizontal = bt(document.createElement("div")), this._sliderHorizontal.setPosition("absolute"), this._sliderHorizontal.setClassName("minimap-slider-horizontal"), this._slider.appendChild(this._sliderHorizontal), this._applyLayout(), this._pointerDownListener = pi(this._domNode.domNode, Q.POINTER_DOWN, (i) => {
      if (i.preventDefault(), this._model.options.renderMinimap === 0 || !this._lastRenderData)
        return;
      if (this._model.options.size !== "proportional") {
        if (i.button === 0 && this._lastRenderData) {
          const d = Ei(this._slider.domNode), c = d.top + d.height / 2;
          this._startSliderDragging(i, c, this._lastRenderData.renderedLayout);
        }
        return;
      }
      const s = this._model.options.minimapLineHeight, o = this._model.options.canvasInnerHeight / this._model.options.canvasOuterHeight * i.offsetY;
      let l = Math.floor(o / s) + this._lastRenderData.renderedLayout.startLineNumber - this._lastRenderData.renderedLayout.topPaddingLineCount;
      l = Math.min(l, this._model.getLineCount()), this._model.revealLineNumber(l);
    }), this._sliderPointerMoveMonitor = new Np(), this._sliderPointerDownListener = pi(this._slider.domNode, Q.POINTER_DOWN, (i) => {
      i.preventDefault(), i.stopPropagation(), i.button === 0 && this._lastRenderData && this._startSliderDragging(i, i.pageY, this._lastRenderData.renderedLayout);
    }), this._gestureDisposable = At.addTarget(this._domNode.domNode), this._sliderTouchStartListener = W(this._domNode.domNode, Pt.Start, (i) => {
      i.preventDefault(), i.stopPropagation(), this._lastRenderData && (this._slider.toggleClassName("active", !0), this._gestureInProgress = !0, this.scrollDueToTouchEvent(i));
    }, { passive: !1 }), this._sliderTouchMoveListener = W(this._domNode.domNode, Pt.Change, (i) => {
      i.preventDefault(), i.stopPropagation(), this._lastRenderData && this._gestureInProgress && this.scrollDueToTouchEvent(i);
    }, { passive: !1 }), this._sliderTouchEndListener = pi(this._domNode.domNode, Pt.End, (i) => {
      i.preventDefault(), i.stopPropagation(), this._gestureInProgress = !1, this._slider.toggleClassName("active", !1);
    });
  }
  _startSliderDragging(e, t, i) {
    if (!e.target || !(e.target instanceof Element))
      return;
    const n = e.pageX;
    this._slider.toggleClassName("active", !0);
    const s = (o, a) => {
      const l = Ei(this._domNode.domNode), d = Math.min(Math.abs(a - n), Math.abs(a - l.left), Math.abs(a - l.left - l.width));
      if (Ks && d > oY) {
        this._model.setScrollTop(i.scrollTop);
        return;
      }
      const c = o - t;
      this._model.setScrollTop(i.getDesiredScrollTopFromDelta(c));
    };
    e.pageY !== t && s(e.pageY, n), this._sliderPointerMoveMonitor.startMonitoring(e.target, e.pointerId, e.buttons, (o) => s(o.pageY, o.pageX), () => {
      this._slider.toggleClassName("active", !1);
    });
  }
  scrollDueToTouchEvent(e) {
    const t = this._domNode.domNode.getBoundingClientRect().top, i = this._lastRenderData.renderedLayout.getDesiredScrollTopFromTouchLocation(e.pageY - t);
    this._model.setScrollTop(i);
  }
  dispose() {
    this._pointerDownListener.dispose(), this._sliderPointerMoveMonitor.dispose(), this._sliderPointerDownListener.dispose(), this._gestureDisposable.dispose(), this._sliderTouchStartListener.dispose(), this._sliderTouchMoveListener.dispose(), this._sliderTouchEndListener.dispose(), super.dispose();
  }
  _getMinimapDomNodeClassName() {
    const e = ["minimap"];
    return this._model.options.showSlider === "always" ? e.push("slider-always") : e.push("slider-mouseover"), this._model.options.autohide && e.push("autohide"), e.join(" ");
  }
  getDomNode() {
    return this._domNode;
  }
  _applyLayout() {
    this._domNode.setLeft(this._model.options.minimapLeft), this._domNode.setWidth(this._model.options.minimapWidth), this._domNode.setHeight(this._model.options.minimapHeight), this._shadow.setHeight(this._model.options.minimapHeight), this._canvas.setWidth(this._model.options.canvasOuterWidth), this._canvas.setHeight(this._model.options.canvasOuterHeight), this._canvas.domNode.width = this._model.options.canvasInnerWidth, this._canvas.domNode.height = this._model.options.canvasInnerHeight, this._decorationsCanvas.setWidth(this._model.options.canvasOuterWidth), this._decorationsCanvas.setHeight(this._model.options.canvasOuterHeight), this._decorationsCanvas.domNode.width = this._model.options.canvasInnerWidth, this._decorationsCanvas.domNode.height = this._model.options.canvasInnerHeight, this._slider.setWidth(this._model.options.minimapWidth);
  }
  _getBuffer() {
    return this._buffers || this._model.options.canvasInnerWidth > 0 && this._model.options.canvasInnerHeight > 0 && (this._buffers = new R1(this._canvas.domNode.getContext("2d"), this._model.options.canvasInnerWidth, this._model.options.canvasInnerHeight, this._model.options.backgroundColor)), this._buffers ? this._buffers.getBuffer() : null;
  }
  // ---- begin view event handlers
  onDidChangeOptions() {
    this._lastRenderData = null, this._buffers = null, this._applyLayout(), this._domNode.setClassName(this._getMinimapDomNodeClassName());
  }
  onSelectionChanged() {
    return this._renderDecorations = !0, !0;
  }
  onDecorationsChanged() {
    return this._renderDecorations = !0, !0;
  }
  onFlushed() {
    return this._lastRenderData = null, !0;
  }
  onLinesChanged(e, t) {
    return this._lastRenderData ? this._lastRenderData.onLinesChanged(e, t) : !1;
  }
  onLinesDeleted(e, t) {
    var i;
    return (i = this._lastRenderData) === null || i === void 0 || i.onLinesDeleted(e, t), !0;
  }
  onLinesInserted(e, t) {
    var i;
    return (i = this._lastRenderData) === null || i === void 0 || i.onLinesInserted(e, t), !0;
  }
  onScrollChanged() {
    return this._renderDecorations = !0, !0;
  }
  onThemeChanged() {
    return this._selectionColor = this._theme.getColor(cP), this._renderDecorations = !0, !0;
  }
  onTokensChanged(e) {
    return this._lastRenderData ? this._lastRenderData.onTokensChanged(e) : !1;
  }
  onTokensColorsChanged() {
    return this._lastRenderData = null, this._buffers = null, !0;
  }
  onZonesChanged() {
    return this._lastRenderData = null, !0;
  }
  // --- end event handlers
  render(e) {
    if (this._model.options.renderMinimap === 0) {
      this._shadow.setClassName("minimap-shadow-hidden"), this._sliderHorizontal.setWidth(0), this._sliderHorizontal.setHeight(0);
      return;
    }
    e.scrollLeft + e.viewportWidth >= e.scrollWidth ? this._shadow.setClassName("minimap-shadow-hidden") : this._shadow.setClassName("minimap-shadow-visible");
    const i = r_.create(this._model.options, e.viewportStartLineNumber, e.viewportEndLineNumber, e.viewportStartLineNumberVerticalOffset, e.viewportHeight, e.viewportContainsWhitespaceGaps, this._model.getLineCount(), this._model.getRealLineCount(), e.scrollTop, e.scrollHeight, this._lastRenderData ? this._lastRenderData.renderedLayout : null);
    this._slider.setDisplay(i.sliderNeeded ? "block" : "none"), this._slider.setTop(i.sliderTop), this._slider.setHeight(i.sliderHeight), this._sliderHorizontal.setLeft(0), this._sliderHorizontal.setWidth(this._model.options.minimapWidth), this._sliderHorizontal.setTop(0), this._sliderHorizontal.setHeight(i.sliderHeight), this.renderDecorations(i), this._lastRenderData = this.renderLines(i);
  }
  renderDecorations(e) {
    if (this._renderDecorations) {
      this._renderDecorations = !1;
      const t = this._model.getSelections();
      t.sort(L.compareRangesUsingStarts);
      const i = this._model.getMinimapDecorationsInViewport(e.startLineNumber, e.endLineNumber);
      i.sort((u, g) => (u.options.zIndex || 0) - (g.options.zIndex || 0));
      const { canvasInnerWidth: n, canvasInnerHeight: s } = this._model.options, o = this._model.options.minimapLineHeight, a = this._model.options.minimapCharWidth, l = this._model.getOptions().tabSize, d = this._decorationsCanvas.domNode.getContext("2d");
      d.clearRect(0, 0, n, s);
      const c = new TP(e.startLineNumber, e.endLineNumber, !1);
      this._renderSelectionLineHighlights(d, t, c, e, o), this._renderDecorationsLineHighlights(d, i, c, e, o);
      const h = new TP(e.startLineNumber, e.endLineNumber, null);
      this._renderSelectionsHighlights(d, t, h, e, o, l, a, n), this._renderDecorationsHighlights(d, i, h, e, o, l, a, n), this._renderSectionHeaders(e);
    }
  }
  _renderSelectionLineHighlights(e, t, i, n, s) {
    if (!this._selectionColor || this._selectionColor.isTransparent())
      return;
    e.fillStyle = this._selectionColor.transparent(0.5).toString();
    let o = 0, a = 0;
    for (const l of t) {
      const d = n.intersectWithViewport(l);
      if (!d)
        continue;
      const [c, h] = d;
      for (let f = c; f <= h; f++)
        i.set(f, !0);
      const u = n.getYForLineNumber(c, s), g = n.getYForLineNumber(h, s);
      a >= u || (a > o && e.fillRect(Ca, o, e.canvas.width, a - o), o = u), a = g;
    }
    a > o && e.fillRect(Ca, o, e.canvas.width, a - o);
  }
  _renderDecorationsLineHighlights(e, t, i, n, s) {
    const o = /* @__PURE__ */ new Map();
    for (let a = t.length - 1; a >= 0; a--) {
      const l = t[a], d = l.options.minimap;
      if (!d || d.position !== 1)
        continue;
      const c = n.intersectWithViewport(l.range);
      if (!c)
        continue;
      const [h, u] = c, g = d.getColor(this._theme.value);
      if (!g || g.isTransparent())
        continue;
      let f = o.get(g.toString());
      f || (f = g.transparent(0.5).toString(), o.set(g.toString(), f)), e.fillStyle = f;
      for (let m = h; m <= u; m++) {
        if (i.has(m))
          continue;
        i.set(m, !0);
        const _ = n.getYForLineNumber(h, s);
        e.fillRect(Ca, _, e.canvas.width, s);
      }
    }
  }
  _renderSelectionsHighlights(e, t, i, n, s, o, a, l) {
    if (!(!this._selectionColor || this._selectionColor.isTransparent()))
      for (const d of t) {
        const c = n.intersectWithViewport(d);
        if (!c)
          continue;
        const [h, u] = c;
        for (let g = h; g <= u; g++)
          this.renderDecorationOnLine(e, i, d, this._selectionColor, n, g, s, s, o, a, l);
      }
  }
  _renderDecorationsHighlights(e, t, i, n, s, o, a, l) {
    for (const d of t) {
      const c = d.options.minimap;
      if (!c)
        continue;
      const h = n.intersectWithViewport(d.range);
      if (!h)
        continue;
      const [u, g] = h, f = c.getColor(this._theme.value);
      if (!(!f || f.isTransparent()))
        for (let m = u; m <= g; m++)
          switch (c.position) {
            case 1:
              this.renderDecorationOnLine(e, i, d.range, f, n, m, s, s, o, a, l);
              continue;
            case 2: {
              const _ = n.getYForLineNumber(m, s);
              this.renderDecoration(e, f, 2, _, rY, s);
              continue;
            }
          }
    }
  }
  renderDecorationOnLine(e, t, i, n, s, o, a, l, d, c, h) {
    const u = s.getYForLineNumber(o, l);
    if (u + a < 0 || u > this._model.options.canvasInnerHeight)
      return;
    const { startLineNumber: g, endLineNumber: f } = i, m = g === o ? i.startColumn : 1, _ = f === o ? i.endColumn : this._model.getLineMaxColumn(o), v = this.getXOffsetForPosition(t, o, m, d, c, h), b = this.getXOffsetForPosition(t, o, _, d, c, h);
    this.renderDecoration(e, n, v, u, b - v, a);
  }
  getXOffsetForPosition(e, t, i, n, s, o) {
    if (i === 1)
      return Ca;
    if ((i - 1) * s >= o)
      return o;
    let l = e.get(t);
    if (!l) {
      const d = this._model.getLineContent(t);
      l = [Ca];
      let c = Ca;
      for (let h = 1; h < d.length + 1; h++) {
        const u = d.charCodeAt(h - 1), g = u === 9 ? n * s : kc(u) ? 2 * s : s, f = c + g;
        if (f >= o) {
          l[h] = o;
          break;
        }
        l[h] = f, c = f;
      }
      e.set(t, l);
    }
    return i - 1 < l.length ? l[i - 1] : o;
  }
  renderDecoration(e, t, i, n, s, o) {
    e.fillStyle = t && t.toString() || "", e.fillRect(i, n, s, o);
  }
  _renderSectionHeaders(e) {
    var t;
    const i = this._model.options.minimapLineHeight, n = this._model.options.sectionHeaderFontSize, s = this._model.options.sectionHeaderLetterSpacing, o = n * 1.5, { canvasInnerWidth: a } = this._model.options, l = this._model.options.backgroundColor, d = `rgb(${l.r} ${l.g} ${l.b} / .7)`, c = this._model.options.sectionHeaderFontColor, h = `rgb(${c.r} ${c.g} ${c.b})`, u = h, g = this._decorationsCanvas.domNode.getContext("2d");
    g.letterSpacing = s + "px", g.font = "500 " + n + "px " + this._model.options.sectionHeaderFontFamily, g.strokeStyle = u, g.lineWidth = 0.2;
    const f = this._model.getSectionHeaderDecorationsInViewport(e.startLineNumber, e.endLineNumber);
    f.sort((_, v) => _.range.startLineNumber - v.range.startLineNumber);
    const m = Xg._fitSectionHeader.bind(null, g, a - Ca);
    for (const _ of f) {
      const v = e.getYForLineNumber(_.range.startLineNumber, i) + n, b = v - n, C = b + 2, w = this._model.getSectionHeaderText(_, m);
      Xg._renderSectionLabel(g, w, ((t = _.options.minimap) === null || t === void 0 ? void 0 : t.sectionHeaderStyle) === 2, d, h, a, b, o, v, C);
    }
  }
  static _fitSectionHeader(e, t, i) {
    if (!i)
      return i;
    const n = "", s = e.measureText(i).width, o = e.measureText(n).width;
    if (s <= t || s <= o)
      return i;
    const a = i.length, l = s / i.length, d = Math.floor((t - o) / l) - 1;
    let c = Math.ceil(d / 2);
    for (; c > 0 && /\s/.test(i[c - 1]); )
      --c;
    return i.substring(0, c) + n + i.substring(a - (d - c));
  }
  static _renderSectionLabel(e, t, i, n, s, o, a, l, d, c) {
    t && (e.fillStyle = n, e.fillRect(0, a, o, l), e.fillStyle = s, e.fillText(t, Ca, d)), i && (e.beginPath(), e.moveTo(0, c), e.lineTo(o, c), e.closePath(), e.stroke());
  }
  renderLines(e) {
    const t = e.startLineNumber, i = e.endLineNumber, n = this._model.options.minimapLineHeight;
    if (this._lastRenderData && this._lastRenderData.linesEquals(e)) {
      const ue = this._lastRenderData._get();
      return new EP(e, ue.imageData, ue.lines);
    }
    const s = this._getBuffer();
    if (!s)
      return null;
    const [o, a, l] = Xg._renderUntouchedLines(s, e.topPaddingLineCount, t, i, n, this._lastRenderData), d = this._model.getMinimapLinesRenderingData(t, i, l), c = this._model.getOptions().tabSize, h = this._model.options.defaultBackgroundColor, u = this._model.options.backgroundColor, g = this._model.options.foregroundAlpha, f = this._model.tokensColorTracker, m = f.backgroundIsLight(), _ = this._model.options.renderMinimap, v = this._model.options.charRenderer(), b = this._model.options.fontScale, C = this._model.options.minimapCharWidth, S = (_ === 1 ? 2 : 3) * b, y = n > S ? Math.floor((n - S) / 2) : 0, k = u.a / 255, E = new ho(Math.round((u.r - h.r) * k + h.r), Math.round((u.g - h.g) * k + h.g), Math.round((u.b - h.b) * k + h.b), 255);
    let N = e.topPaddingLineCount * n;
    const F = [];
    for (let ue = 0, Ve = i - t + 1; ue < Ve; ue++)
      l[ue] && Xg._renderLine(s, E, u.a, m, _, C, f, g, v, N, y, c, d[ue], b, n), F[ue] = new DS(N), N += n;
    const V = o === -1 ? 0 : o, H = (a === -1 ? s.height : a) - V;
    return this._canvas.domNode.getContext("2d").putImageData(s, 0, 0, 0, V, s.width, H), new EP(e, s, F);
  }
  static _renderUntouchedLines(e, t, i, n, s, o) {
    const a = [];
    if (!o) {
      for (let N = 0, F = n - i + 1; N < F; N++)
        a[N] = !0;
      return [-1, -1, a];
    }
    const l = o._get(), d = l.imageData.data, c = l.rendLineNumberStart, h = l.lines, u = h.length, g = e.width, f = e.data, m = (n - i + 1) * s * g * 4;
    let _ = -1, v = -1, b = -1, C = -1, w = -1, S = -1, y = t * s;
    for (let N = i; N <= n; N++) {
      const F = N - i, V = N - c, Z = V >= 0 && V < u ? h[V].dy : -1;
      if (Z === -1) {
        a[F] = !0, y += s;
        continue;
      }
      const H = Z * g * 4, re = (Z + s) * g * 4, ue = y * g * 4, Ve = (y + s) * g * 4;
      C === H && S === ue ? (C = re, S = Ve) : (b !== -1 && (f.set(d.subarray(b, C), w), _ === -1 && b === 0 && b === w && (_ = C), v === -1 && C === m && b === w && (v = b)), b = H, C = re, w = ue, S = Ve), a[F] = !1, y += s;
    }
    b !== -1 && (f.set(d.subarray(b, C), w), _ === -1 && b === 0 && b === w && (_ = C), v === -1 && C === m && b === w && (v = b));
    const k = _ === -1 ? -1 : _ / (g * 4), E = v === -1 ? -1 : v / (g * 4);
    return [k, E, a];
  }
  static _renderLine(e, t, i, n, s, o, a, l, d, c, h, u, g, f, m) {
    const _ = g.content, v = g.tokens, b = e.width - o, C = m === 1;
    let w = Ca, S = 0, y = 0;
    for (let k = 0, E = v.getCount(); k < E; k++) {
      const N = v.getEndOffset(k), F = v.getForeground(k), V = a.getColor(F);
      for (; S < N; S++) {
        if (w > b)
          return;
        const Z = _.charCodeAt(S);
        if (Z === 9) {
          const H = u - (S + y) % u;
          y += H - 1, w += H * o;
        } else if (Z === 32)
          w += o;
        else {
          const H = kc(Z) ? 2 : 1;
          for (let re = 0; re < H; re++)
            if (s === 2 ? d.blockRenderChar(e, w, c + h, V, l, t, i, C) : d.renderChar(e, w, c + h, Z, V, l, t, i, f, n, C), w += o, w > b)
              return;
        }
      }
    }
  }
}
class TP {
  constructor(e, t, i) {
    this._startLineNumber = e, this._endLineNumber = t, this._defaultValue = i, this._values = [];
    for (let n = 0, s = this._endLineNumber - this._startLineNumber + 1; n < s; n++)
      this._values[n] = i;
  }
  has(e) {
    return this.get(e) !== this._defaultValue;
  }
  set(e, t) {
    e < this._startLineNumber || e > this._endLineNumber || (this._values[e - this._startLineNumber] = t);
  }
  get(e) {
    return e < this._startLineNumber || e > this._endLineNumber ? this._defaultValue : this._values[e - this._startLineNumber];
  }
}
class lY extends Gs {
  constructor(e, t) {
    super(e), this._viewDomNode = t;
    const n = this._context.configuration.options.get(
      145
      /* EditorOption.layoutInfo */
    );
    this._widgets = {}, this._verticalScrollbarWidth = n.verticalScrollbarWidth, this._minimapWidth = n.minimap.minimapWidth, this._horizontalScrollbarHeight = n.horizontalScrollbarHeight, this._editorHeight = n.height, this._editorWidth = n.width, this._viewDomNodeRect = { top: 0, left: 0, width: 0, height: 0 }, this._domNode = bt(document.createElement("div")), Jr.write(
      this._domNode,
      4
      /* PartFingerprint.OverlayWidgets */
    ), this._domNode.setClassName("overlayWidgets"), this.overflowingOverlayWidgetsDomNode = bt(document.createElement("div")), Jr.write(
      this.overflowingOverlayWidgetsDomNode,
      5
      /* PartFingerprint.OverflowingOverlayWidgets */
    ), this.overflowingOverlayWidgetsDomNode.setClassName("overflowingOverlayWidgets");
  }
  dispose() {
    super.dispose(), this._widgets = {};
  }
  getDomNode() {
    return this._domNode;
  }
  // ---- begin view event handlers
  onConfigurationChanged(e) {
    const i = this._context.configuration.options.get(
      145
      /* EditorOption.layoutInfo */
    );
    return this._verticalScrollbarWidth = i.verticalScrollbarWidth, this._minimapWidth = i.minimap.minimapWidth, this._horizontalScrollbarHeight = i.horizontalScrollbarHeight, this._editorHeight = i.height, this._editorWidth = i.width, !0;
  }
  // ---- end view event handlers
  addWidget(e) {
    const t = bt(e.getDomNode());
    this._widgets[e.getId()] = {
      widget: e,
      preference: null,
      domNode: t
    }, t.setPosition("absolute"), t.setAttribute("widgetId", e.getId()), e.allowEditorOverflow ? this.overflowingOverlayWidgetsDomNode.appendChild(t) : this._domNode.appendChild(t), this.setShouldRender(), this._updateMaxMinWidth();
  }
  setWidgetPosition(e, t) {
    const i = this._widgets[e.getId()], n = t ? t.preference : null, s = t == null ? void 0 : t.stackOridinal;
    return i.preference === n && i.stack === s ? (this._updateMaxMinWidth(), !1) : (i.preference = n, i.stack = s, this.setShouldRender(), this._updateMaxMinWidth(), !0);
  }
  removeWidget(e) {
    const t = e.getId();
    if (this._widgets.hasOwnProperty(t)) {
      const n = this._widgets[t].domNode.domNode;
      delete this._widgets[t], n.remove(), this.setShouldRender(), this._updateMaxMinWidth();
    }
  }
  _updateMaxMinWidth() {
    var e, t;
    let i = 0;
    const n = Object.keys(this._widgets);
    for (let s = 0, o = n.length; s < o; s++) {
      const a = n[s], d = (t = (e = this._widgets[a].widget).getMinContentWidthInPx) === null || t === void 0 ? void 0 : t.call(e);
      typeof d < "u" && (i = Math.max(i, d));
    }
    this._context.viewLayout.setOverlayWidgetsMinWidth(i);
  }
  _renderWidget(e, t) {
    const i = e.domNode;
    if (e.preference === null) {
      i.setTop("");
      return;
    }
    const n = 2 * this._verticalScrollbarWidth + this._minimapWidth;
    if (e.preference === 0 || e.preference === 1) {
      if (e.preference === 1) {
        const s = i.domNode.clientHeight;
        i.setTop(this._editorHeight - s - 2 * this._horizontalScrollbarHeight);
      } else
        i.setTop(0);
      e.stack !== void 0 ? (i.setTop(t[e.preference]), t[e.preference] += i.domNode.clientWidth) : i.setRight(n);
    } else if (e.preference === 2)
      i.domNode.style.right = "50%", e.stack !== void 0 ? (i.setTop(t[
        2
        /* OverlayWidgetPositionPreference.TOP_CENTER */
      ]), t[
        2
        /* OverlayWidgetPositionPreference.TOP_CENTER */
      ] += i.domNode.clientHeight) : i.setTop(0);
    else {
      const { top: s, left: o } = e.preference;
      if (this._context.configuration.options.get(
        42
        /* EditorOption.fixedOverflowWidgets */
      ) && e.widget.allowEditorOverflow) {
        const l = this._viewDomNodeRect;
        i.setTop(s + l.top), i.setLeft(o + l.left), i.setPosition("fixed");
      } else
        i.setTop(s), i.setLeft(o), i.setPosition("absolute");
    }
  }
  prepareRender(e) {
    this._viewDomNodeRect = Ei(this._viewDomNode.domNode);
  }
  render(e) {
    this._domNode.setWidth(this._editorWidth);
    const t = Object.keys(this._widgets), i = Array.from({ length: 3 }, () => 0);
    t.sort((n, s) => (this._widgets[n].stack || 0) - (this._widgets[s].stack || 0));
    for (let n = 0, s = t.length; n < s; n++) {
      const o = t[n];
      this._renderWidget(this._widgets[o], i);
    }
  }
}
class dY {
  constructor(e, t) {
    const i = e.options;
    this.lineHeight = i.get(
      67
      /* EditorOption.lineHeight */
    ), this.pixelRatio = i.get(
      143
      /* EditorOption.pixelRatio */
    ), this.overviewRulerLanes = i.get(
      83
      /* EditorOption.overviewRulerLanes */
    ), this.renderBorder = i.get(
      82
      /* EditorOption.overviewRulerBorder */
    );
    const n = t.getColor(j7);
    this.borderColor = n ? n.toString() : null, this.hideCursor = i.get(
      59
      /* EditorOption.hideCursorInOverviewRuler */
    );
    const s = t.getColor($a);
    this.cursorColorSingle = s ? s.transparent(0.7).toString() : null;
    const o = t.getColor(jV);
    this.cursorColorPrimary = o ? o.transparent(0.7).toString() : null;
    const a = t.getColor(qV);
    this.cursorColorSecondary = a ? a.transparent(0.7).toString() : null, this.themeType = t.type;
    const l = i.get(
      73
      /* EditorOption.minimap */
    ), d = l.enabled, c = l.side, h = t.getColor(q7), u = ri.getDefaultBackground();
    h ? this.backgroundColor = h : d && c === "right" ? this.backgroundColor = u : this.backgroundColor = null;
    const f = i.get(
      145
      /* EditorOption.layoutInfo */
    ).overviewRuler;
    this.top = f.top, this.right = f.right, this.domWidth = f.width, this.domHeight = f.height, this.overviewRulerLanes === 0 ? (this.canvasWidth = 0, this.canvasHeight = 0) : (this.canvasWidth = this.domWidth * this.pixelRatio | 0, this.canvasHeight = this.domHeight * this.pixelRatio | 0);
    const [m, _] = this._initLanes(1, this.canvasWidth, this.overviewRulerLanes);
    this.x = m, this.w = _;
  }
  _initLanes(e, t, i) {
    const n = t - e;
    if (i >= 3) {
      const s = Math.floor(n / 3), o = Math.floor(n / 3), a = n - s - o, l = e, d = l + s, c = l + s + a;
      return [
        [
          0,
          l,
          // Left
          d,
          // Center
          l,
          // Left | Center
          c,
          // Right
          l,
          // Left | Right
          d,
          // Center | Right
          l
          // Left | Center | Right
        ],
        [
          0,
          s,
          // Left
          a,
          // Center
          s + a,
          // Left | Center
          o,
          // Right
          s + a + o,
          // Left | Right
          a + o,
          // Center | Right
          s + a + o
          // Left | Center | Right
        ]
      ];
    } else if (i === 2) {
      const s = Math.floor(n / 2), o = n - s, a = e, l = a + s;
      return [
        [
          0,
          a,
          // Left
          a,
          // Center
          a,
          // Left | Center
          l,
          // Right
          a,
          // Left | Right
          a,
          // Center | Right
          a
          // Left | Center | Right
        ],
        [
          0,
          s,
          // Left
          s,
          // Center
          s,
          // Left | Center
          o,
          // Right
          s + o,
          // Left | Right
          s + o,
          // Center | Right
          s + o
          // Left | Center | Right
        ]
      ];
    } else {
      const s = e, o = n;
      return [
        [
          0,
          s,
          // Left
          s,
          // Center
          s,
          // Left | Center
          s,
          // Right
          s,
          // Left | Right
          s,
          // Center | Right
          s
          // Left | Center | Right
        ],
        [
          0,
          o,
          // Left
          o,
          // Center
          o,
          // Left | Center
          o,
          // Right
          o,
          // Left | Right
          o,
          // Center | Right
          o
          // Left | Center | Right
        ]
      ];
    }
  }
  equals(e) {
    return this.lineHeight === e.lineHeight && this.pixelRatio === e.pixelRatio && this.overviewRulerLanes === e.overviewRulerLanes && this.renderBorder === e.renderBorder && this.borderColor === e.borderColor && this.hideCursor === e.hideCursor && this.cursorColorSingle === e.cursorColorSingle && this.cursorColorPrimary === e.cursorColorPrimary && this.cursorColorSecondary === e.cursorColorSecondary && this.themeType === e.themeType && z.equals(this.backgroundColor, e.backgroundColor) && this.top === e.top && this.right === e.right && this.domWidth === e.domWidth && this.domHeight === e.domHeight && this.canvasWidth === e.canvasWidth && this.canvasHeight === e.canvasHeight;
  }
}
class cY extends Gs {
  constructor(e) {
    super(e), this._actualShouldRender = 0, this._renderedDecorations = [], this._renderedCursorPositions = [], this._domNode = bt(document.createElement("canvas")), this._domNode.setClassName("decorationsOverviewRuler"), this._domNode.setPosition("absolute"), this._domNode.setLayerHinting(!0), this._domNode.setContain("strict"), this._domNode.setAttribute("aria-hidden", "true"), this._updateSettings(!1), this._tokensColorTrackerListener = ri.onDidChange((t) => {
      t.changedColorMap && this._updateSettings(!0);
    }), this._cursorPositions = [{ position: new A(1, 1), color: this._settings.cursorColorSingle }];
  }
  dispose() {
    super.dispose(), this._tokensColorTrackerListener.dispose();
  }
  _updateSettings(e) {
    const t = new dY(this._context.configuration, this._context.theme);
    return this._settings && this._settings.equals(t) ? !1 : (this._settings = t, this._domNode.setTop(this._settings.top), this._domNode.setRight(this._settings.right), this._domNode.setWidth(this._settings.domWidth), this._domNode.setHeight(this._settings.domHeight), this._domNode.domNode.width = this._settings.canvasWidth, this._domNode.domNode.height = this._settings.canvasHeight, e && this._render(), !0);
  }
  // ---- begin view event handlers
  _markRenderingIsNeeded() {
    return this._actualShouldRender = 2, !0;
  }
  _markRenderingIsMaybeNeeded() {
    return this._actualShouldRender = 1, !0;
  }
  onConfigurationChanged(e) {
    return this._updateSettings(!1) ? this._markRenderingIsNeeded() : !1;
  }
  onCursorStateChanged(e) {
    this._cursorPositions = [];
    for (let t = 0, i = e.selections.length; t < i; t++) {
      let n = this._settings.cursorColorSingle;
      i > 1 && (n = t === 0 ? this._settings.cursorColorPrimary : this._settings.cursorColorSecondary), this._cursorPositions.push({ position: e.selections[t].getPosition(), color: n });
    }
    return this._cursorPositions.sort((t, i) => A.compare(t.position, i.position)), this._markRenderingIsMaybeNeeded();
  }
  onDecorationsChanged(e) {
    return e.affectsOverviewRuler ? this._markRenderingIsMaybeNeeded() : !1;
  }
  onFlushed(e) {
    return this._markRenderingIsNeeded();
  }
  onScrollChanged(e) {
    return e.scrollHeightChanged ? this._markRenderingIsNeeded() : !1;
  }
  onZonesChanged(e) {
    return this._markRenderingIsNeeded();
  }
  onThemeChanged(e) {
    return this._updateSettings(!1) ? this._markRenderingIsNeeded() : !1;
  }
  // ---- end view event handlers
  getDomNode() {
    return this._domNode.domNode;
  }
  prepareRender(e) {
  }
  render(e) {
    this._render(), this._actualShouldRender = 0;
  }
  _render() {
    const e = this._settings.backgroundColor;
    if (this._settings.overviewRulerLanes === 0) {
      this._domNode.setBackgroundColor(e ? z.Format.CSS.formatHexA(e) : ""), this._domNode.setDisplay("none");
      return;
    }
    const t = this._context.viewModel.getAllOverviewRulerDecorations(this._context.theme);
    if (t.sort(W_.compareByRenderingProps), this._actualShouldRender === 1 && !W_.equalsArr(this._renderedDecorations, t) && (this._actualShouldRender = 2), this._actualShouldRender === 1 && !ci(this._renderedCursorPositions, this._cursorPositions, (f, m) => f.position.lineNumber === m.position.lineNumber && f.color === m.color) && (this._actualShouldRender = 2), this._actualShouldRender === 1)
      return;
    this._renderedDecorations = t, this._renderedCursorPositions = this._cursorPositions, this._domNode.setDisplay("block");
    const i = this._settings.canvasWidth, n = this._settings.canvasHeight, s = this._settings.lineHeight, o = this._context.viewLayout, a = this._context.viewLayout.getScrollHeight(), l = n / a, d = 6 * this._settings.pixelRatio | 0, c = d / 2 | 0, h = this._domNode.domNode.getContext("2d");
    e ? e.isOpaque() ? (h.fillStyle = z.Format.CSS.formatHexA(e), h.fillRect(0, 0, i, n)) : (h.clearRect(0, 0, i, n), h.fillStyle = z.Format.CSS.formatHexA(e), h.fillRect(0, 0, i, n)) : h.clearRect(0, 0, i, n);
    const u = this._settings.x, g = this._settings.w;
    for (const f of t) {
      const m = f.color, _ = f.data;
      h.fillStyle = m;
      let v = 0, b = 0, C = 0;
      for (let w = 0, S = _.length / 3; w < S; w++) {
        const y = _[3 * w], k = _[3 * w + 1], E = _[3 * w + 2];
        let N = o.getVerticalOffsetForLineNumber(k) * l | 0, F = (o.getVerticalOffsetForLineNumber(E) + s) * l | 0;
        if (F - N < d) {
          let Z = (N + F) / 2 | 0;
          Z < c ? Z = c : Z + c > n && (Z = n - c), N = Z - c, F = Z + c;
        }
        N > C + 1 || y !== v ? (w !== 0 && h.fillRect(u[v], b, g[v], C - b), v = y, b = N, C = F) : F > C && (C = F);
      }
      h.fillRect(u[v], b, g[v], C - b);
    }
    if (!this._settings.hideCursor) {
      const f = 2 * this._settings.pixelRatio | 0, m = f / 2 | 0, _ = this._settings.x[
        7
        /* OverviewRulerLane.Full */
      ], v = this._settings.w[
        7
        /* OverviewRulerLane.Full */
      ];
      let b = -100, C = -100, w = null;
      for (let S = 0, y = this._cursorPositions.length; S < y; S++) {
        const k = this._cursorPositions[S].color;
        if (!k)
          continue;
        const E = this._cursorPositions[S].position;
        let N = o.getVerticalOffsetForLineNumber(E.lineNumber) * l | 0;
        N < m ? N = m : N + m > n && (N = n - m);
        const F = N - m, V = F + f;
        F > C + 1 || k !== w ? (S !== 0 && w && h.fillRect(_, b, v, C - b), b = F, C = V) : V > C && (C = V), w = k, h.fillStyle = k;
      }
      w && h.fillRect(_, b, v, C - b);
    }
    this._settings.renderBorder && this._settings.borderColor && this._settings.overviewRulerLanes > 0 && (h.beginPath(), h.lineWidth = 1, h.strokeStyle = this._settings.borderColor, h.moveTo(0, 0), h.lineTo(0, n), h.stroke(), h.moveTo(0, 0), h.lineTo(i, 0), h.stroke());
  }
}
class NP {
  constructor(e, t, i) {
    this._colorZoneBrand = void 0, this.from = e | 0, this.to = t | 0, this.colorId = i | 0;
  }
  static compare(e, t) {
    return e.colorId === t.colorId ? e.from === t.from ? e.to - t.to : e.from - t.from : e.colorId - t.colorId;
  }
}
class u2 {
  constructor(e, t, i, n) {
    this._overviewRulerZoneBrand = void 0, this.startLineNumber = e, this.endLineNumber = t, this.heightInLines = i, this.color = n, this._colorZone = null;
  }
  static compare(e, t) {
    return e.color === t.color ? e.startLineNumber === t.startLineNumber ? e.heightInLines === t.heightInLines ? e.endLineNumber - t.endLineNumber : e.heightInLines - t.heightInLines : e.startLineNumber - t.startLineNumber : e.color < t.color ? -1 : 1;
  }
  setColorZone(e) {
    this._colorZone = e;
  }
  getColorZones() {
    return this._colorZone;
  }
}
class hY {
  constructor(e) {
    this._getVerticalOffsetForLine = e, this._zones = [], this._colorZonesInvalid = !1, this._lineHeight = 0, this._domWidth = 0, this._domHeight = 0, this._outerHeight = 0, this._pixelRatio = 1, this._lastAssignedId = 0, this._color2Id = /* @__PURE__ */ Object.create(null), this._id2Color = [];
  }
  getId2Color() {
    return this._id2Color;
  }
  setZones(e) {
    this._zones = e, this._zones.sort(u2.compare);
  }
  setLineHeight(e) {
    return this._lineHeight === e ? !1 : (this._lineHeight = e, this._colorZonesInvalid = !0, !0);
  }
  setPixelRatio(e) {
    this._pixelRatio = e, this._colorZonesInvalid = !0;
  }
  getDOMWidth() {
    return this._domWidth;
  }
  getCanvasWidth() {
    return this._domWidth * this._pixelRatio;
  }
  setDOMWidth(e) {
    return this._domWidth === e ? !1 : (this._domWidth = e, this._colorZonesInvalid = !0, !0);
  }
  getDOMHeight() {
    return this._domHeight;
  }
  getCanvasHeight() {
    return this._domHeight * this._pixelRatio;
  }
  setDOMHeight(e) {
    return this._domHeight === e ? !1 : (this._domHeight = e, this._colorZonesInvalid = !0, !0);
  }
  getOuterHeight() {
    return this._outerHeight;
  }
  setOuterHeight(e) {
    return this._outerHeight === e ? !1 : (this._outerHeight = e, this._colorZonesInvalid = !0, !0);
  }
  resolveColorZones() {
    const e = this._colorZonesInvalid, t = Math.floor(this._lineHeight), i = Math.floor(this.getCanvasHeight()), n = Math.floor(this._outerHeight), s = i / n, o = Math.floor(4 * this._pixelRatio / 2), a = [];
    for (let l = 0, d = this._zones.length; l < d; l++) {
      const c = this._zones[l];
      if (!e) {
        const w = c.getColorZones();
        if (w) {
          a.push(w);
          continue;
        }
      }
      const h = this._getVerticalOffsetForLine(c.startLineNumber), u = c.heightInLines === 0 ? this._getVerticalOffsetForLine(c.endLineNumber) + t : h + c.heightInLines * t, g = Math.floor(s * h), f = Math.floor(s * u);
      let m = Math.floor((g + f) / 2), _ = f - m;
      _ < o && (_ = o), m - _ < 0 && (m = _), m + _ > i && (m = i - _);
      const v = c.color;
      let b = this._color2Id[v];
      b || (b = ++this._lastAssignedId, this._color2Id[v] = b, this._id2Color[b] = v);
      const C = new NP(m - _, m + _, b);
      c.setColorZone(C), a.push(C);
    }
    return this._colorZonesInvalid = !1, a.sort(NP.compare), a;
  }
}
class uY extends fb {
  constructor(e, t) {
    super(), this._context = e;
    const i = this._context.configuration.options;
    this._domNode = bt(document.createElement("canvas")), this._domNode.setClassName(t), this._domNode.setPosition("absolute"), this._domNode.setLayerHinting(!0), this._domNode.setContain("strict"), this._zoneManager = new hY((n) => this._context.viewLayout.getVerticalOffsetForLineNumber(n)), this._zoneManager.setDOMWidth(0), this._zoneManager.setDOMHeight(0), this._zoneManager.setOuterHeight(this._context.viewLayout.getScrollHeight()), this._zoneManager.setLineHeight(i.get(
      67
      /* EditorOption.lineHeight */
    )), this._zoneManager.setPixelRatio(i.get(
      143
      /* EditorOption.pixelRatio */
    )), this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this), super.dispose();
  }
  // ---- begin view event handlers
  onConfigurationChanged(e) {
    const t = this._context.configuration.options;
    return e.hasChanged(
      67
      /* EditorOption.lineHeight */
    ) && (this._zoneManager.setLineHeight(t.get(
      67
      /* EditorOption.lineHeight */
    )), this._render()), e.hasChanged(
      143
      /* EditorOption.pixelRatio */
    ) && (this._zoneManager.setPixelRatio(t.get(
      143
      /* EditorOption.pixelRatio */
    )), this._domNode.setWidth(this._zoneManager.getDOMWidth()), this._domNode.setHeight(this._zoneManager.getDOMHeight()), this._domNode.domNode.width = this._zoneManager.getCanvasWidth(), this._domNode.domNode.height = this._zoneManager.getCanvasHeight(), this._render()), !0;
  }
  onFlushed(e) {
    return this._render(), !0;
  }
  onScrollChanged(e) {
    return e.scrollHeightChanged && (this._zoneManager.setOuterHeight(e.scrollHeight), this._render()), !0;
  }
  onZonesChanged(e) {
    return this._render(), !0;
  }
  // ---- end view event handlers
  getDomNode() {
    return this._domNode.domNode;
  }
  setLayout(e) {
    this._domNode.setTop(e.top), this._domNode.setRight(e.right);
    let t = !1;
    t = this._zoneManager.setDOMWidth(e.width) || t, t = this._zoneManager.setDOMHeight(e.height) || t, t && (this._domNode.setWidth(this._zoneManager.getDOMWidth()), this._domNode.setHeight(this._zoneManager.getDOMHeight()), this._domNode.domNode.width = this._zoneManager.getCanvasWidth(), this._domNode.domNode.height = this._zoneManager.getCanvasHeight(), this._render());
  }
  setZones(e) {
    this._zoneManager.setZones(e), this._render();
  }
  _render() {
    if (this._zoneManager.getOuterHeight() === 0)
      return !1;
    const e = this._zoneManager.getCanvasWidth(), t = this._zoneManager.getCanvasHeight(), i = this._zoneManager.resolveColorZones(), n = this._zoneManager.getId2Color(), s = this._domNode.domNode.getContext("2d");
    return s.clearRect(0, 0, e, t), i.length > 0 && this._renderOneLane(s, i, n, e), !0;
  }
  _renderOneLane(e, t, i, n) {
    let s = 0, o = 0, a = 0;
    for (const l of t) {
      const d = l.colorId, c = l.from, h = l.to;
      d !== s ? (e.fillRect(0, o, n, a - o), s = d, e.fillStyle = i[s], o = c, a = h) : a >= c ? a = Math.max(a, h) : (e.fillRect(0, o, n, a - o), o = c, a = h);
    }
    e.fillRect(0, o, n, a - o);
  }
}
class gY extends Gs {
  constructor(e) {
    super(e), this.domNode = bt(document.createElement("div")), this.domNode.setAttribute("role", "presentation"), this.domNode.setAttribute("aria-hidden", "true"), this.domNode.setClassName("view-rulers"), this._renderedRulers = [];
    const t = this._context.configuration.options;
    this._rulers = t.get(
      102
      /* EditorOption.rulers */
    ), this._typicalHalfwidthCharacterWidth = t.get(
      50
      /* EditorOption.fontInfo */
    ).typicalHalfwidthCharacterWidth;
  }
  dispose() {
    super.dispose();
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    const t = this._context.configuration.options;
    return this._rulers = t.get(
      102
      /* EditorOption.rulers */
    ), this._typicalHalfwidthCharacterWidth = t.get(
      50
      /* EditorOption.fontInfo */
    ).typicalHalfwidthCharacterWidth, !0;
  }
  onScrollChanged(e) {
    return e.scrollHeightChanged;
  }
  // --- end event handlers
  prepareRender(e) {
  }
  _ensureRulersCount() {
    const e = this._renderedRulers.length, t = this._rulers.length;
    if (e === t)
      return;
    if (e < t) {
      const { tabSize: n } = this._context.viewModel.model.getOptions(), s = n;
      let o = t - e;
      for (; o > 0; ) {
        const a = bt(document.createElement("div"));
        a.setClassName("view-ruler"), a.setWidth(s), this.domNode.appendChild(a), this._renderedRulers.push(a), o--;
      }
      return;
    }
    let i = e - t;
    for (; i > 0; ) {
      const n = this._renderedRulers.pop();
      this.domNode.removeChild(n), i--;
    }
  }
  render(e) {
    this._ensureRulersCount();
    for (let t = 0, i = this._rulers.length; t < i; t++) {
      const n = this._renderedRulers[t], s = this._rulers[t];
      n.setBoxShadow(s.color ? `1px 0 0 0 ${s.color} inset` : ""), n.setHeight(Math.min(e.scrollHeight, 1e6)), n.setLeft(s.column * this._typicalHalfwidthCharacterWidth);
    }
  }
}
class fY extends Gs {
  constructor(e) {
    super(e), this._scrollTop = 0, this._width = 0, this._updateWidth(), this._shouldShow = !1;
    const i = this._context.configuration.options.get(
      103
      /* EditorOption.scrollbar */
    );
    this._useShadows = i.useShadows, this._domNode = bt(document.createElement("div")), this._domNode.setAttribute("role", "presentation"), this._domNode.setAttribute("aria-hidden", "true");
  }
  dispose() {
    super.dispose();
  }
  _updateShouldShow() {
    const e = this._useShadows && this._scrollTop > 0;
    return this._shouldShow !== e ? (this._shouldShow = e, !0) : !1;
  }
  getDomNode() {
    return this._domNode;
  }
  _updateWidth() {
    const t = this._context.configuration.options.get(
      145
      /* EditorOption.layoutInfo */
    );
    t.minimap.renderMinimap === 0 || t.minimap.minimapWidth > 0 && t.minimap.minimapLeft === 0 ? this._width = t.width : this._width = t.width - t.verticalScrollbarWidth;
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    const i = this._context.configuration.options.get(
      103
      /* EditorOption.scrollbar */
    );
    return this._useShadows = i.useShadows, this._updateWidth(), this._updateShouldShow(), !0;
  }
  onScrollChanged(e) {
    return this._scrollTop = e.scrollTop, this._updateShouldShow();
  }
  // --- end event handlers
  prepareRender(e) {
  }
  render(e) {
    this._domNode.setWidth(this._width), this._domNode.setClassName(this._shouldShow ? "scroll-decoration" : "");
  }
}
class pY {
  constructor(e) {
    this.left = e.left, this.width = e.width, this.startStyle = null, this.endStyle = null;
  }
}
class mY {
  constructor(e, t) {
    this.lineNumber = e, this.ranges = t;
  }
}
function _Y(r) {
  return new pY(r);
}
function vY(r) {
  return new mY(r.lineNumber, r.ranges.map(_Y));
}
class wi extends eg {
  constructor(e) {
    super(), this._previousFrameVisibleRangesWithStyle = [], this._context = e;
    const t = this._context.configuration.options;
    this._roundedSelection = t.get(
      101
      /* EditorOption.roundedSelection */
    ), this._typicalHalfwidthCharacterWidth = t.get(
      50
      /* EditorOption.fontInfo */
    ).typicalHalfwidthCharacterWidth, this._selections = [], this._renderResult = null, this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this), this._renderResult = null, super.dispose();
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    const t = this._context.configuration.options;
    return this._roundedSelection = t.get(
      101
      /* EditorOption.roundedSelection */
    ), this._typicalHalfwidthCharacterWidth = t.get(
      50
      /* EditorOption.fontInfo */
    ).typicalHalfwidthCharacterWidth, !0;
  }
  onCursorStateChanged(e) {
    return this._selections = e.selections.slice(0), !0;
  }
  onDecorationsChanged(e) {
    return !0;
  }
  onFlushed(e) {
    return !0;
  }
  onLinesChanged(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged;
  }
  onZonesChanged(e) {
    return !0;
  }
  // --- end event handlers
  _visibleRangesHaveGaps(e) {
    for (let t = 0, i = e.length; t < i; t++)
      if (e[t].ranges.length > 1)
        return !0;
    return !1;
  }
  _enrichVisibleRangesWithStyle(e, t, i) {
    const n = this._typicalHalfwidthCharacterWidth / 4;
    let s = null, o = null;
    if (i && i.length > 0 && t.length > 0) {
      const a = t[0].lineNumber;
      if (a === e.startLineNumber)
        for (let d = 0; !s && d < i.length; d++)
          i[d].lineNumber === a && (s = i[d].ranges[0]);
      const l = t[t.length - 1].lineNumber;
      if (l === e.endLineNumber)
        for (let d = i.length - 1; !o && d >= 0; d--)
          i[d].lineNumber === l && (o = i[d].ranges[0]);
      s && !s.startStyle && (s = null), o && !o.startStyle && (o = null);
    }
    for (let a = 0, l = t.length; a < l; a++) {
      const d = t[a].ranges[0], c = d.left, h = d.left + d.width, u = {
        top: 0,
        bottom: 0
        /* CornerStyle.EXTERN */
      }, g = {
        top: 0,
        bottom: 0
        /* CornerStyle.EXTERN */
      };
      if (a > 0) {
        const f = t[a - 1].ranges[0].left, m = t[a - 1].ranges[0].left + t[a - 1].ranges[0].width;
        bC(c - f) < n ? u.top = 2 : c > f && (u.top = 1), bC(h - m) < n ? g.top = 2 : f < h && h < m && (g.top = 1);
      } else s && (u.top = s.startStyle.top, g.top = s.endStyle.top);
      if (a + 1 < l) {
        const f = t[a + 1].ranges[0].left, m = t[a + 1].ranges[0].left + t[a + 1].ranges[0].width;
        bC(c - f) < n ? u.bottom = 2 : f < c && c < m && (u.bottom = 1), bC(h - m) < n ? g.bottom = 2 : h < m && (g.bottom = 1);
      } else o && (u.bottom = o.startStyle.bottom, g.bottom = o.endStyle.bottom);
      d.startStyle = u, d.endStyle = g;
    }
  }
  _getVisibleRangesWithStyle(e, t, i) {
    const s = (t.linesVisibleRangesForRange(e, !0) || []).map(vY);
    return !this._visibleRangesHaveGaps(s) && this._roundedSelection && this._enrichVisibleRangesWithStyle(t.visibleRange, s, i), s;
  }
  _createSelectionPiece(e, t, i, n, s) {
    return '<div class="cslr ' + i + '" style="top:' + e.toString() + "px;bottom:" + t.toString() + "px;left:" + n.toString() + "px;width:" + s.toString() + 'px;"></div>';
  }
  _actualRenderOneSelection(e, t, i, n) {
    if (n.length === 0)
      return;
    const s = !!n[0].ranges[0].startStyle, o = n[0].lineNumber, a = n[n.length - 1].lineNumber;
    for (let l = 0, d = n.length; l < d; l++) {
      const c = n[l], h = c.lineNumber, u = h - t, g = i && h === o ? 1 : 0, f = i && h !== o && h === a ? 1 : 0;
      let m = "", _ = "";
      for (let v = 0, b = c.ranges.length; v < b; v++) {
        const C = c.ranges[v];
        if (s) {
          const S = C.startStyle, y = C.endStyle;
          if (S.top === 1 || S.bottom === 1) {
            m += this._createSelectionPiece(g, f, wi.SELECTION_CLASS_NAME, C.left - wi.ROUNDED_PIECE_WIDTH, wi.ROUNDED_PIECE_WIDTH);
            let k = wi.EDITOR_BACKGROUND_CLASS_NAME;
            S.top === 1 && (k += " " + wi.SELECTION_TOP_RIGHT), S.bottom === 1 && (k += " " + wi.SELECTION_BOTTOM_RIGHT), m += this._createSelectionPiece(g, f, k, C.left - wi.ROUNDED_PIECE_WIDTH, wi.ROUNDED_PIECE_WIDTH);
          }
          if (y.top === 1 || y.bottom === 1) {
            m += this._createSelectionPiece(g, f, wi.SELECTION_CLASS_NAME, C.left + C.width, wi.ROUNDED_PIECE_WIDTH);
            let k = wi.EDITOR_BACKGROUND_CLASS_NAME;
            y.top === 1 && (k += " " + wi.SELECTION_TOP_LEFT), y.bottom === 1 && (k += " " + wi.SELECTION_BOTTOM_LEFT), m += this._createSelectionPiece(g, f, k, C.left + C.width, wi.ROUNDED_PIECE_WIDTH);
          }
        }
        let w = wi.SELECTION_CLASS_NAME;
        if (s) {
          const S = C.startStyle, y = C.endStyle;
          S.top === 0 && (w += " " + wi.SELECTION_TOP_LEFT), S.bottom === 0 && (w += " " + wi.SELECTION_BOTTOM_LEFT), y.top === 0 && (w += " " + wi.SELECTION_TOP_RIGHT), y.bottom === 0 && (w += " " + wi.SELECTION_BOTTOM_RIGHT);
        }
        _ += this._createSelectionPiece(g, f, w, C.left, C.width);
      }
      e[u][0] += m, e[u][1] += _;
    }
  }
  prepareRender(e) {
    const t = [], i = e.visibleRange.startLineNumber, n = e.visibleRange.endLineNumber;
    for (let o = i; o <= n; o++) {
      const a = o - i;
      t[a] = ["", ""];
    }
    const s = [];
    for (let o = 0, a = this._selections.length; o < a; o++) {
      const l = this._selections[o];
      if (l.isEmpty()) {
        s[o] = null;
        continue;
      }
      const d = this._getVisibleRangesWithStyle(l, e, this._previousFrameVisibleRangesWithStyle[o]);
      s[o] = d, this._actualRenderOneSelection(t, i, this._selections.length > 1, d);
    }
    this._previousFrameVisibleRangesWithStyle = s, this._renderResult = t.map(([o, a]) => o + a);
  }
  render(e, t) {
    if (!this._renderResult)
      return "";
    const i = t - e;
    return i < 0 || i >= this._renderResult.length ? "" : this._renderResult[i];
  }
}
wi.SELECTION_CLASS_NAME = "selected-text";
wi.SELECTION_TOP_LEFT = "top-left-radius";
wi.SELECTION_BOTTOM_LEFT = "bottom-left-radius";
wi.SELECTION_TOP_RIGHT = "top-right-radius";
wi.SELECTION_BOTTOM_RIGHT = "bottom-right-radius";
wi.EDITOR_BACKGROUND_CLASS_NAME = "monaco-editor-background";
wi.ROUNDED_PIECE_WIDTH = 10;
Ho((r, e) => {
  const t = r.getColor(LG);
  t && !t.isTransparent() && e.addRule(`.monaco-editor .view-line span.inline-selected-text { color: ${t}; }`);
});
function bC(r) {
  return r < 0 ? -r : r;
}
class MP {
  constructor(e, t, i, n, s, o, a) {
    this.top = e, this.left = t, this.paddingLeft = i, this.width = n, this.height = s, this.textContent = o, this.textContentClassName = a;
  }
}
var Ql;
(function(r) {
  r[r.Single = 0] = "Single", r[r.MultiPrimary = 1] = "MultiPrimary", r[r.MultiSecondary = 2] = "MultiSecondary";
})(Ql || (Ql = {}));
class RP {
  constructor(e, t) {
    this._context = e;
    const i = this._context.configuration.options, n = i.get(
      50
      /* EditorOption.fontInfo */
    );
    this._cursorStyle = i.get(
      28
      /* EditorOption.cursorStyle */
    ), this._lineHeight = i.get(
      67
      /* EditorOption.lineHeight */
    ), this._typicalHalfwidthCharacterWidth = n.typicalHalfwidthCharacterWidth, this._lineCursorWidth = Math.min(i.get(
      31
      /* EditorOption.cursorWidth */
    ), this._typicalHalfwidthCharacterWidth), this._isVisible = !0, this._domNode = bt(document.createElement("div")), this._domNode.setClassName(`cursor ${vf}`), this._domNode.setHeight(this._lineHeight), this._domNode.setTop(0), this._domNode.setLeft(0), _n(this._domNode, n), this._domNode.setDisplay("none"), this._position = new A(1, 1), this._pluralityClass = "", this.setPlurality(t), this._lastRenderedContent = "", this._renderData = null;
  }
  getDomNode() {
    return this._domNode;
  }
  getPosition() {
    return this._position;
  }
  setPlurality(e) {
    switch (e) {
      default:
      case Ql.Single:
        this._pluralityClass = "";
        break;
      case Ql.MultiPrimary:
        this._pluralityClass = "cursor-primary";
        break;
      case Ql.MultiSecondary:
        this._pluralityClass = "cursor-secondary";
        break;
    }
  }
  show() {
    this._isVisible || (this._domNode.setVisibility("inherit"), this._isVisible = !0);
  }
  hide() {
    this._isVisible && (this._domNode.setVisibility("hidden"), this._isVisible = !1);
  }
  onConfigurationChanged(e) {
    const t = this._context.configuration.options, i = t.get(
      50
      /* EditorOption.fontInfo */
    );
    return this._cursorStyle = t.get(
      28
      /* EditorOption.cursorStyle */
    ), this._lineHeight = t.get(
      67
      /* EditorOption.lineHeight */
    ), this._typicalHalfwidthCharacterWidth = i.typicalHalfwidthCharacterWidth, this._lineCursorWidth = Math.min(t.get(
      31
      /* EditorOption.cursorWidth */
    ), this._typicalHalfwidthCharacterWidth), _n(this._domNode, i), !0;
  }
  onCursorPositionChanged(e, t) {
    return t ? this._domNode.domNode.style.transitionProperty = "none" : this._domNode.domNode.style.transitionProperty = "", this._position = e, !0;
  }
  /**
   * If `this._position` is inside a grapheme, returns the position where the grapheme starts.
   * Also returns the next grapheme.
   */
  _getGraphemeAwarePosition() {
    const { lineNumber: e, column: t } = this._position, i = this._context.viewModel.getLineContent(e), [n, s] = m5(i, t - 1);
    return [new A(e, n + 1), i.substring(n, s)];
  }
  _prepareRender(e) {
    let t = "", i = "";
    const [n, s] = this._getGraphemeAwarePosition();
    if (this._cursorStyle === gn.Line || this._cursorStyle === gn.LineThin) {
      const u = e.visibleRangeForPosition(n);
      if (!u || u.outsideRenderedLine)
        return null;
      const g = we(this._domNode.domNode);
      let f;
      this._cursorStyle === gn.Line ? (f = IA(g, this._lineCursorWidth > 0 ? this._lineCursorWidth : 2), f > 2 && (t = s, i = this._getTokenClassName(n))) : f = IA(g, 1);
      let m = u.left, _ = 0;
      f >= 2 && m >= 1 && (_ = 1, m -= _);
      const v = e.getVerticalOffsetForLineNumber(n.lineNumber) - e.bigNumbersDelta;
      return new MP(v, m, _, f, this._lineHeight, t, i);
    }
    const o = e.linesVisibleRangesForRange(new L(n.lineNumber, n.column, n.lineNumber, n.column + s.length), !1);
    if (!o || o.length === 0)
      return null;
    const a = o[0];
    if (a.outsideRenderedLine || a.ranges.length === 0)
      return null;
    const l = a.ranges[0], d = s === "	" ? this._typicalHalfwidthCharacterWidth : l.width < 1 ? this._typicalHalfwidthCharacterWidth : l.width;
    this._cursorStyle === gn.Block && (t = s, i = this._getTokenClassName(n));
    let c = e.getVerticalOffsetForLineNumber(n.lineNumber) - e.bigNumbersDelta, h = this._lineHeight;
    return (this._cursorStyle === gn.Underline || this._cursorStyle === gn.UnderlineThin) && (c += this._lineHeight - 2, h = 2), new MP(c, l.left, 0, d, h, t, i);
  }
  _getTokenClassName(e) {
    const t = this._context.viewModel.getViewLineData(e.lineNumber), i = t.tokens.findTokenIndexAtOffset(e.column - 1);
    return t.tokens.getClassName(i);
  }
  prepareRender(e) {
    this._renderData = this._prepareRender(e);
  }
  render(e) {
    return this._renderData ? (this._lastRenderedContent !== this._renderData.textContent && (this._lastRenderedContent = this._renderData.textContent, this._domNode.domNode.textContent = this._lastRenderedContent), this._domNode.setClassName(`cursor ${this._pluralityClass} ${vf} ${this._renderData.textContentClassName}`), this._domNode.setDisplay("block"), this._domNode.setTop(this._renderData.top), this._domNode.setLeft(this._renderData.left), this._domNode.setPaddingLeft(this._renderData.paddingLeft), this._domNode.setWidth(this._renderData.width), this._domNode.setLineHeight(this._renderData.height), this._domNode.setHeight(this._renderData.height), {
      domNode: this._domNode.domNode,
      position: this._position,
      contentLeft: this._renderData.left,
      height: this._renderData.height,
      width: 2
    }) : (this._domNode.setDisplay("none"), null);
  }
}
class Y_ extends Gs {
  constructor(e) {
    super(e);
    const t = this._context.configuration.options;
    this._readOnly = t.get(
      91
      /* EditorOption.readOnly */
    ), this._cursorBlinking = t.get(
      26
      /* EditorOption.cursorBlinking */
    ), this._cursorStyle = t.get(
      28
      /* EditorOption.cursorStyle */
    ), this._cursorSmoothCaretAnimation = t.get(
      27
      /* EditorOption.cursorSmoothCaretAnimation */
    ), this._selectionIsEmpty = !0, this._isComposingInput = !1, this._isVisible = !1, this._primaryCursor = new RP(this._context, Ql.Single), this._secondaryCursors = [], this._renderData = [], this._domNode = bt(document.createElement("div")), this._domNode.setAttribute("role", "presentation"), this._domNode.setAttribute("aria-hidden", "true"), this._updateDomClassName(), this._domNode.appendChild(this._primaryCursor.getDomNode()), this._startCursorBlinkAnimation = new vr(), this._cursorFlatBlinkInterval = new n1(), this._blinkingEnabled = !1, this._editorHasFocus = !1, this._updateBlinking();
  }
  dispose() {
    super.dispose(), this._startCursorBlinkAnimation.dispose(), this._cursorFlatBlinkInterval.dispose();
  }
  getDomNode() {
    return this._domNode;
  }
  // --- begin event handlers
  onCompositionStart(e) {
    return this._isComposingInput = !0, this._updateBlinking(), !0;
  }
  onCompositionEnd(e) {
    return this._isComposingInput = !1, this._updateBlinking(), !0;
  }
  onConfigurationChanged(e) {
    const t = this._context.configuration.options;
    this._readOnly = t.get(
      91
      /* EditorOption.readOnly */
    ), this._cursorBlinking = t.get(
      26
      /* EditorOption.cursorBlinking */
    ), this._cursorStyle = t.get(
      28
      /* EditorOption.cursorStyle */
    ), this._cursorSmoothCaretAnimation = t.get(
      27
      /* EditorOption.cursorSmoothCaretAnimation */
    ), this._updateBlinking(), this._updateDomClassName(), this._primaryCursor.onConfigurationChanged(e);
    for (let i = 0, n = this._secondaryCursors.length; i < n; i++)
      this._secondaryCursors[i].onConfigurationChanged(e);
    return !0;
  }
  _onCursorPositionChanged(e, t, i) {
    const n = this._secondaryCursors.length !== t.length || this._cursorSmoothCaretAnimation === "explicit" && i !== 3;
    if (this._primaryCursor.setPlurality(t.length ? Ql.MultiPrimary : Ql.Single), this._primaryCursor.onCursorPositionChanged(e, n), this._updateBlinking(), this._secondaryCursors.length < t.length) {
      const s = t.length - this._secondaryCursors.length;
      for (let o = 0; o < s; o++) {
        const a = new RP(this._context, Ql.MultiSecondary);
        this._domNode.domNode.insertBefore(a.getDomNode().domNode, this._primaryCursor.getDomNode().domNode.nextSibling), this._secondaryCursors.push(a);
      }
    } else if (this._secondaryCursors.length > t.length) {
      const s = this._secondaryCursors.length - t.length;
      for (let o = 0; o < s; o++)
        this._domNode.removeChild(this._secondaryCursors[0].getDomNode()), this._secondaryCursors.splice(0, 1);
    }
    for (let s = 0; s < t.length; s++)
      this._secondaryCursors[s].onCursorPositionChanged(t[s], n);
  }
  onCursorStateChanged(e) {
    const t = [];
    for (let n = 0, s = e.selections.length; n < s; n++)
      t[n] = e.selections[n].getPosition();
    this._onCursorPositionChanged(t[0], t.slice(1), e.reason);
    const i = e.selections[0].isEmpty();
    return this._selectionIsEmpty !== i && (this._selectionIsEmpty = i, this._updateDomClassName()), !0;
  }
  onDecorationsChanged(e) {
    return !0;
  }
  onFlushed(e) {
    return !0;
  }
  onFocusChanged(e) {
    return this._editorHasFocus = e.isFocused, this._updateBlinking(), !1;
  }
  onLinesChanged(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return !0;
  }
  onTokensChanged(e) {
    const t = (i) => {
      for (let n = 0, s = e.ranges.length; n < s; n++)
        if (e.ranges[n].fromLineNumber <= i.lineNumber && i.lineNumber <= e.ranges[n].toLineNumber)
          return !0;
      return !1;
    };
    if (t(this._primaryCursor.getPosition()))
      return !0;
    for (const i of this._secondaryCursors)
      if (t(i.getPosition()))
        return !0;
    return !1;
  }
  onZonesChanged(e) {
    return !0;
  }
  // --- end event handlers
  // ---- blinking logic
  _getCursorBlinking() {
    return this._isComposingInput || !this._editorHasFocus ? 0 : this._readOnly ? 5 : this._cursorBlinking;
  }
  _updateBlinking() {
    this._startCursorBlinkAnimation.cancel(), this._cursorFlatBlinkInterval.cancel();
    const e = this._getCursorBlinking(), t = e === 0, i = e === 5;
    t ? this._hide() : this._show(), this._blinkingEnabled = !1, this._updateDomClassName(), !t && !i && (e === 1 ? this._cursorFlatBlinkInterval.cancelAndSet(() => {
      this._isVisible ? this._hide() : this._show();
    }, Y_.BLINK_INTERVAL, we(this._domNode.domNode)) : this._startCursorBlinkAnimation.setIfNotSet(() => {
      this._blinkingEnabled = !0, this._updateDomClassName();
    }, Y_.BLINK_INTERVAL));
  }
  // --- end blinking logic
  _updateDomClassName() {
    this._domNode.setClassName(this._getClassName());
  }
  _getClassName() {
    let e = "cursors-layer";
    switch (this._selectionIsEmpty || (e += " has-selection"), this._cursorStyle) {
      case gn.Line:
        e += " cursor-line-style";
        break;
      case gn.Block:
        e += " cursor-block-style";
        break;
      case gn.Underline:
        e += " cursor-underline-style";
        break;
      case gn.LineThin:
        e += " cursor-line-thin-style";
        break;
      case gn.BlockOutline:
        e += " cursor-block-outline-style";
        break;
      case gn.UnderlineThin:
        e += " cursor-underline-thin-style";
        break;
      default:
        e += " cursor-line-style";
    }
    if (this._blinkingEnabled)
      switch (this._getCursorBlinking()) {
        case 1:
          e += " cursor-blink";
          break;
        case 2:
          e += " cursor-smooth";
          break;
        case 3:
          e += " cursor-phase";
          break;
        case 4:
          e += " cursor-expand";
          break;
        case 5:
          e += " cursor-solid";
          break;
        default:
          e += " cursor-solid";
      }
    else
      e += " cursor-solid";
    return (this._cursorSmoothCaretAnimation === "on" || this._cursorSmoothCaretAnimation === "explicit") && (e += " cursor-smooth-caret-animation"), e;
  }
  _show() {
    this._primaryCursor.show();
    for (let e = 0, t = this._secondaryCursors.length; e < t; e++)
      this._secondaryCursors[e].show();
    this._isVisible = !0;
  }
  _hide() {
    this._primaryCursor.hide();
    for (let e = 0, t = this._secondaryCursors.length; e < t; e++)
      this._secondaryCursors[e].hide();
    this._isVisible = !1;
  }
  // ---- IViewPart implementation
  prepareRender(e) {
    this._primaryCursor.prepareRender(e);
    for (let t = 0, i = this._secondaryCursors.length; t < i; t++)
      this._secondaryCursors[t].prepareRender(e);
  }
  render(e) {
    const t = [];
    let i = 0;
    const n = this._primaryCursor.render(e);
    n && (t[i++] = n);
    for (let s = 0, o = this._secondaryCursors.length; s < o; s++) {
      const a = this._secondaryCursors[s].render(e);
      a && (t[i++] = a);
    }
    this._renderData = t;
  }
  getLastRenderData() {
    return this._renderData;
  }
}
Y_.BLINK_INTERVAL = 500;
Ho((r, e) => {
  const t = [
    { class: ".cursor", foreground: $a, background: Zl },
    { class: ".cursor-primary", foreground: jV, background: M7 },
    { class: ".cursor-secondary", foreground: qV, background: R7 }
  ];
  for (const i of t) {
    const n = r.getColor(i.foreground);
    if (n) {
      let s = r.getColor(i.background);
      s || (s = n.opposite()), e.addRule(`.monaco-editor .cursors-layer ${i.class} { background-color: ${n}; border-color: ${n}; color: ${s}; }`), jr(r.type) && e.addRule(`.monaco-editor .cursors-layer.has-selection ${i.class} { border-left: 1px solid ${s}; border-right: 1px solid ${s}; }`);
    }
  }
});
const QD = () => {
  throw new Error("Invalid change accessor");
};
class bY extends Gs {
  constructor(e) {
    super(e);
    const t = this._context.configuration.options, i = t.get(
      145
      /* EditorOption.layoutInfo */
    );
    this._lineHeight = t.get(
      67
      /* EditorOption.lineHeight */
    ), this._contentWidth = i.contentWidth, this._contentLeft = i.contentLeft, this.domNode = bt(document.createElement("div")), this.domNode.setClassName("view-zones"), this.domNode.setPosition("absolute"), this.domNode.setAttribute("role", "presentation"), this.domNode.setAttribute("aria-hidden", "true"), this.marginDomNode = bt(document.createElement("div")), this.marginDomNode.setClassName("margin-view-zones"), this.marginDomNode.setPosition("absolute"), this.marginDomNode.setAttribute("role", "presentation"), this.marginDomNode.setAttribute("aria-hidden", "true"), this._zones = {};
  }
  dispose() {
    super.dispose(), this._zones = {};
  }
  // ---- begin view event handlers
  _recomputeWhitespacesProps() {
    const e = this._context.viewLayout.getWhitespaces(), t = /* @__PURE__ */ new Map();
    for (const n of e)
      t.set(n.id, n);
    let i = !1;
    return this._context.viewModel.changeWhitespace((n) => {
      const s = Object.keys(this._zones);
      for (let o = 0, a = s.length; o < a; o++) {
        const l = s[o], d = this._zones[l], c = this._computeWhitespaceProps(d.delegate);
        d.isInHiddenArea = c.isInHiddenArea;
        const h = t.get(l);
        h && (h.afterLineNumber !== c.afterViewLineNumber || h.height !== c.heightInPx) && (n.changeOneWhitespace(l, c.afterViewLineNumber, c.heightInPx), this._safeCallOnComputedHeight(d.delegate, c.heightInPx), i = !0);
      }
    }), i;
  }
  onConfigurationChanged(e) {
    const t = this._context.configuration.options, i = t.get(
      145
      /* EditorOption.layoutInfo */
    );
    return this._lineHeight = t.get(
      67
      /* EditorOption.lineHeight */
    ), this._contentWidth = i.contentWidth, this._contentLeft = i.contentLeft, e.hasChanged(
      67
      /* EditorOption.lineHeight */
    ) && this._recomputeWhitespacesProps(), !0;
  }
  onLineMappingChanged(e) {
    return this._recomputeWhitespacesProps();
  }
  onLinesDeleted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged || e.scrollWidthChanged;
  }
  onZonesChanged(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  // ---- end view event handlers
  _getZoneOrdinal(e) {
    var t, i;
    return (i = (t = e.ordinal) !== null && t !== void 0 ? t : e.afterColumn) !== null && i !== void 0 ? i : 1e4;
  }
  _computeWhitespaceProps(e) {
    if (e.afterLineNumber === 0)
      return {
        isInHiddenArea: !1,
        afterViewLineNumber: 0,
        heightInPx: this._heightInPixels(e),
        minWidthInPx: this._minWidthInPixels(e)
      };
    let t;
    if (typeof e.afterColumn < "u")
      t = this._context.viewModel.model.validatePosition({
        lineNumber: e.afterLineNumber,
        column: e.afterColumn
      });
    else {
      const o = this._context.viewModel.model.validatePosition({
        lineNumber: e.afterLineNumber,
        column: 1
      }).lineNumber;
      t = new A(o, this._context.viewModel.model.getLineMaxColumn(o));
    }
    let i;
    t.column === this._context.viewModel.model.getLineMaxColumn(t.lineNumber) ? i = this._context.viewModel.model.validatePosition({
      lineNumber: t.lineNumber + 1,
      column: 1
    }) : i = this._context.viewModel.model.validatePosition({
      lineNumber: t.lineNumber,
      column: t.column + 1
    });
    const n = this._context.viewModel.coordinatesConverter.convertModelPositionToViewPosition(t, e.afterColumnAffinity, !0), s = e.showInHiddenAreas || this._context.viewModel.coordinatesConverter.modelPositionIsVisible(i);
    return {
      isInHiddenArea: !s,
      afterViewLineNumber: n.lineNumber,
      heightInPx: s ? this._heightInPixels(e) : 0,
      minWidthInPx: this._minWidthInPixels(e)
    };
  }
  changeViewZones(e) {
    let t = !1;
    return this._context.viewModel.changeWhitespace((i) => {
      const n = {
        addZone: (s) => (t = !0, this._addZone(i, s)),
        removeZone: (s) => {
          s && (t = this._removeZone(i, s) || t);
        },
        layoutZone: (s) => {
          s && (t = this._layoutZone(i, s) || t);
        }
      };
      CY(e, n), n.addZone = QD, n.removeZone = QD, n.layoutZone = QD;
    }), t;
  }
  _addZone(e, t) {
    const i = this._computeWhitespaceProps(t), s = {
      whitespaceId: e.insertWhitespace(i.afterViewLineNumber, this._getZoneOrdinal(t), i.heightInPx, i.minWidthInPx),
      delegate: t,
      isInHiddenArea: i.isInHiddenArea,
      isVisible: !1,
      domNode: bt(t.domNode),
      marginDomNode: t.marginDomNode ? bt(t.marginDomNode) : null
    };
    return this._safeCallOnComputedHeight(s.delegate, i.heightInPx), s.domNode.setPosition("absolute"), s.domNode.domNode.style.width = "100%", s.domNode.setDisplay("none"), s.domNode.setAttribute("monaco-view-zone", s.whitespaceId), this.domNode.appendChild(s.domNode), s.marginDomNode && (s.marginDomNode.setPosition("absolute"), s.marginDomNode.domNode.style.width = "100%", s.marginDomNode.setDisplay("none"), s.marginDomNode.setAttribute("monaco-view-zone", s.whitespaceId), this.marginDomNode.appendChild(s.marginDomNode)), this._zones[s.whitespaceId] = s, this.setShouldRender(), s.whitespaceId;
  }
  _removeZone(e, t) {
    if (this._zones.hasOwnProperty(t)) {
      const i = this._zones[t];
      return delete this._zones[t], e.removeWhitespace(i.whitespaceId), i.domNode.removeAttribute("monaco-visible-view-zone"), i.domNode.removeAttribute("monaco-view-zone"), i.domNode.domNode.parentNode.removeChild(i.domNode.domNode), i.marginDomNode && (i.marginDomNode.removeAttribute("monaco-visible-view-zone"), i.marginDomNode.removeAttribute("monaco-view-zone"), i.marginDomNode.domNode.parentNode.removeChild(i.marginDomNode.domNode)), this.setShouldRender(), !0;
    }
    return !1;
  }
  _layoutZone(e, t) {
    if (this._zones.hasOwnProperty(t)) {
      const i = this._zones[t], n = this._computeWhitespaceProps(i.delegate);
      return i.isInHiddenArea = n.isInHiddenArea, e.changeOneWhitespace(i.whitespaceId, n.afterViewLineNumber, n.heightInPx), this._safeCallOnComputedHeight(i.delegate, n.heightInPx), this.setShouldRender(), !0;
    }
    return !1;
  }
  shouldSuppressMouseDownOnViewZone(e) {
    return this._zones.hasOwnProperty(e) ? !!this._zones[e].delegate.suppressMouseDown : !1;
  }
  _heightInPixels(e) {
    return typeof e.heightInPx == "number" ? e.heightInPx : typeof e.heightInLines == "number" ? this._lineHeight * e.heightInLines : this._lineHeight;
  }
  _minWidthInPixels(e) {
    return typeof e.minWidthInPx == "number" ? e.minWidthInPx : 0;
  }
  _safeCallOnComputedHeight(e, t) {
    if (typeof e.onComputedHeight == "function")
      try {
        e.onComputedHeight(t);
      } catch (i) {
        He(i);
      }
  }
  _safeCallOnDomNodeTop(e, t) {
    if (typeof e.onDomNodeTop == "function")
      try {
        e.onDomNodeTop(t);
      } catch (i) {
        He(i);
      }
  }
  prepareRender(e) {
  }
  render(e) {
    const t = e.viewportData.whitespaceViewportData, i = {};
    let n = !1;
    for (const o of t)
      this._zones[o.id].isInHiddenArea || (i[o.id] = o, n = !0);
    const s = Object.keys(this._zones);
    for (let o = 0, a = s.length; o < a; o++) {
      const l = s[o], d = this._zones[l];
      let c = 0, h = 0, u = "none";
      i.hasOwnProperty(l) ? (c = i[l].verticalOffset - e.bigNumbersDelta, h = i[l].height, u = "block", d.isVisible || (d.domNode.setAttribute("monaco-visible-view-zone", "true"), d.isVisible = !0), this._safeCallOnDomNodeTop(d.delegate, e.getScrolledTopFromAbsoluteTop(i[l].verticalOffset))) : (d.isVisible && (d.domNode.removeAttribute("monaco-visible-view-zone"), d.isVisible = !1), this._safeCallOnDomNodeTop(d.delegate, e.getScrolledTopFromAbsoluteTop(-1e6))), d.domNode.setTop(c), d.domNode.setHeight(h), d.domNode.setDisplay(u), d.marginDomNode && (d.marginDomNode.setTop(c), d.marginDomNode.setHeight(h), d.marginDomNode.setDisplay(u));
    }
    n && (this.domNode.setWidth(Math.max(e.scrollWidth, this._contentWidth)), this.marginDomNode.setWidth(this._contentLeft));
  }
}
function CY(r, e) {
  try {
    return r(e);
  } catch (t) {
    He(t);
  }
}
class wY extends eg {
  constructor(e) {
    super(), this._context = e, this._options = new AP(this._context.configuration), this._selection = [], this._renderResult = null, this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this), this._renderResult = null, super.dispose();
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    const t = new AP(this._context.configuration);
    return this._options.equals(t) ? e.hasChanged(
      145
      /* EditorOption.layoutInfo */
    ) : (this._options = t, !0);
  }
  onCursorStateChanged(e) {
    return this._selection = e.selections, this._options.renderWhitespace === "selection";
  }
  onDecorationsChanged(e) {
    return !0;
  }
  onFlushed(e) {
    return !0;
  }
  onLinesChanged(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged;
  }
  onZonesChanged(e) {
    return !0;
  }
  // --- end event handlers
  prepareRender(e) {
    if (this._options.renderWhitespace === "none") {
      this._renderResult = null;
      return;
    }
    const t = e.visibleRange.startLineNumber, n = e.visibleRange.endLineNumber - t + 1, s = new Array(n);
    for (let a = 0; a < n; a++)
      s[a] = !0;
    const o = this._context.viewModel.getMinimapLinesRenderingData(e.viewportData.startLineNumber, e.viewportData.endLineNumber, s);
    this._renderResult = [];
    for (let a = e.viewportData.startLineNumber; a <= e.viewportData.endLineNumber; a++) {
      const l = a - e.viewportData.startLineNumber, d = o.data[l];
      let c = null;
      if (this._options.renderWhitespace === "selection") {
        const h = this._selection;
        for (const u of h) {
          if (u.endLineNumber < a || u.startLineNumber > a)
            continue;
          const g = u.startLineNumber === a ? u.startColumn : d.minColumn, f = u.endLineNumber === a ? u.endColumn : d.maxColumn;
          g < f && (c || (c = []), c.push(new vV(g - 1, f - 1)));
        }
      }
      this._renderResult[l] = this._applyRenderWhitespace(e, a, c, d);
    }
  }
  _applyRenderWhitespace(e, t, i, n) {
    if (this._options.renderWhitespace === "selection" && !i || this._options.renderWhitespace === "trailing" && n.continuesWithWrappedLine)
      return "";
    const s = this._context.theme.getColor(Yl), o = this._options.renderWithSVG, a = n.content, l = this._options.stopRenderingLineAfter === -1 ? a.length : Math.min(this._options.stopRenderingLineAfter, a.length), d = n.continuesWithWrappedLine, c = n.minColumn - 1, h = this._options.renderWhitespace === "boundary", u = this._options.renderWhitespace === "trailing", g = this._options.lineHeight, f = this._options.middotWidth, m = this._options.wsmiddotWidth, _ = this._options.spaceWidth, v = Math.abs(m - _), b = Math.abs(f - _), C = v < b ? 11825 : 183, w = this._options.canUseHalfwidthRightwardsArrow;
    let S = "", y = !1, k = ns(a), E;
    k === -1 ? (y = !0, k = l, E = l) : E = ja(a);
    let N = 0, F = i && i[N], V = 0;
    for (let Z = c; Z < l; Z++) {
      const H = a.charCodeAt(Z);
      if (F && Z >= F.endOffset && (N++, F = i && i[N]), H !== 9 && H !== 32 || u && !y && Z <= E)
        continue;
      if (h && Z >= k && Z <= E && H === 32) {
        const ue = Z - 1 >= 0 ? a.charCodeAt(Z - 1) : 0, Ve = Z + 1 < l ? a.charCodeAt(Z + 1) : 0;
        if (ue !== 32 && Ve !== 32)
          continue;
      }
      if (h && d && Z === l - 1) {
        const ue = Z - 1 >= 0 ? a.charCodeAt(Z - 1) : 0;
        if (H === 32 && ue !== 32 && ue !== 9)
          continue;
      }
      if (i && (!F || F.startOffset > Z || F.endOffset <= Z))
        continue;
      const re = e.visibleRangeForPosition(new A(t, Z + 1));
      re && (o ? (V = Math.max(V, re.left), H === 9 ? S += this._renderArrow(g, _, re.left) : S += `<circle cx="${(re.left + _ / 2).toFixed(2)}" cy="${(g / 2).toFixed(2)}" r="${(_ / 7).toFixed(2)}" />`) : H === 9 ? S += `<div class="mwh" style="left:${re.left}px;height:${g}px;">${w ? "" : ""}</div>` : S += `<div class="mwh" style="left:${re.left}px;height:${g}px;">${String.fromCharCode(C)}</div>`);
    }
    return o ? (V = Math.round(V + _), `<svg style="bottom:0;position:absolute;width:${V}px;height:${g}px" viewBox="0 0 ${V} ${g}" xmlns="http://www.w3.org/2000/svg" fill="${s}">` + S + "</svg>") : S;
  }
  _renderArrow(e, t, i) {
    const n = t / 7, s = t, o = e / 2, a = i, l = { x: 0, y: n / 2 }, d = { x: 100 / 125 * s, y: l.y }, c = { x: d.x - 0.2 * d.x, y: d.y + 0.2 * d.x }, h = { x: c.x + 0.1 * d.x, y: c.y + 0.1 * d.x }, u = { x: h.x + 0.35 * d.x, y: h.y - 0.35 * d.x }, g = { x: u.x, y: -u.y }, f = { x: h.x, y: -h.y }, m = { x: c.x, y: -c.y }, _ = { x: d.x, y: -d.y }, v = { x: l.x, y: -l.y };
    return `<path d="M ${[l, d, c, h, u, g, f, m, _, v].map((w) => `${(a + w.x).toFixed(2)} ${(o + w.y).toFixed(2)}`).join(" L ")}" />`;
  }
  render(e, t) {
    if (!this._renderResult)
      return "";
    const i = t - e;
    return i < 0 || i >= this._renderResult.length ? "" : this._renderResult[i];
  }
}
class AP {
  constructor(e) {
    const t = e.options, i = t.get(
      50
      /* EditorOption.fontInfo */
    ), n = t.get(
      38
      /* EditorOption.experimentalWhitespaceRendering */
    );
    n === "off" ? (this.renderWhitespace = "none", this.renderWithSVG = !1) : n === "svg" ? (this.renderWhitespace = t.get(
      99
      /* EditorOption.renderWhitespace */
    ), this.renderWithSVG = !0) : (this.renderWhitespace = t.get(
      99
      /* EditorOption.renderWhitespace */
    ), this.renderWithSVG = !1), this.spaceWidth = i.spaceWidth, this.middotWidth = i.middotWidth, this.wsmiddotWidth = i.wsmiddotWidth, this.canUseHalfwidthRightwardsArrow = i.canUseHalfwidthRightwardsArrow, this.lineHeight = t.get(
      67
      /* EditorOption.lineHeight */
    ), this.stopRenderingLineAfter = t.get(
      117
      /* EditorOption.stopRenderingLineAfter */
    );
  }
  equals(e) {
    return this.renderWhitespace === e.renderWhitespace && this.renderWithSVG === e.renderWithSVG && this.spaceWidth === e.spaceWidth && this.middotWidth === e.middotWidth && this.wsmiddotWidth === e.wsmiddotWidth && this.canUseHalfwidthRightwardsArrow === e.canUseHalfwidthRightwardsArrow && this.lineHeight === e.lineHeight && this.stopRenderingLineAfter === e.stopRenderingLineAfter;
  }
}
class SY {
  constructor(e, t, i, n) {
    this.selections = e, this.startLineNumber = t.startLineNumber | 0, this.endLineNumber = t.endLineNumber | 0, this.relativeVerticalOffset = t.relativeVerticalOffset, this.bigNumbersDelta = t.bigNumbersDelta | 0, this.lineHeight = t.lineHeight | 0, this.whitespaceViewportData = i, this._model = n, this.visibleRange = new L(t.startLineNumber, this._model.getLineMinColumn(t.startLineNumber), t.endLineNumber, this._model.getLineMaxColumn(t.endLineNumber));
  }
  getViewLineRenderingData(e) {
    return this._model.getViewportViewLineRenderingData(this.visibleRange, e);
  }
  getDecorationsInViewport() {
    return this._model.getDecorationsInViewport(this.visibleRange);
  }
}
class yY {
  get type() {
    return this._theme.type;
  }
  get value() {
    return this._theme;
  }
  constructor(e) {
    this._theme = e;
  }
  update(e) {
    this._theme = e;
  }
  getColor(e) {
    return this._theme.getColor(e);
  }
}
class LY {
  constructor(e, t, i) {
    this.configuration = e, this.theme = new yY(t), this.viewModel = i, this.viewLayout = i.viewLayout;
  }
  addEventHandler(e) {
    this.viewModel.addViewEventHandler(e);
  }
  removeEventHandler(e) {
    this.viewModel.removeViewEventHandler(e);
  }
}
var DY = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, kY = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
let tI = class extends fb {
  constructor(e, t, i, n, s, o, a) {
    super(), this._instantiationService = a, this._shouldRecomputeGlyphMarginLanes = !1, this._selections = [new ge(1, 1, 1, 1)], this._renderAnimationFrame = null;
    const l = new MZ(t, n, s, e);
    this._context = new LY(t, i, n), this._context.addEventHandler(this), this._viewParts = [], this._textAreaHandler = this._instantiationService.createInstance(Xx, this._context, l, this._createTextAreaHandlerHelper()), this._viewParts.push(this._textAreaHandler), this._linesContent = bt(document.createElement("div")), this._linesContent.setClassName("lines-content monaco-editor-background"), this._linesContent.setPosition("absolute"), this.domNode = bt(document.createElement("div")), this.domNode.setClassName(this._getEditorClassName()), this.domNode.setAttribute("role", "code"), this._overflowGuardContainer = bt(document.createElement("div")), Jr.write(
      this._overflowGuardContainer,
      3
      /* PartFingerprint.OverflowGuard */
    ), this._overflowGuardContainer.setClassName("overflow-guard"), this._scrollbar = new zZ(this._context, this._linesContent, this.domNode, this._overflowGuardContainer), this._viewParts.push(this._scrollbar), this._viewLines = new A0(this._context, this._linesContent), this._viewZones = new bY(this._context), this._viewParts.push(this._viewZones);
    const d = new cY(this._context);
    this._viewParts.push(d);
    const c = new fY(this._context);
    this._viewParts.push(c);
    const h = new AZ(this._context);
    this._viewParts.push(h), h.addDynamicOverlay(new BZ(this._context)), h.addDynamicOverlay(new wi(this._context)), h.addDynamicOverlay(new YZ(this._context)), h.addDynamicOverlay(new VZ(this._context)), h.addDynamicOverlay(new wY(this._context));
    const u = new PZ(this._context);
    this._viewParts.push(u), u.addDynamicOverlay(new HZ(this._context)), u.addDynamicOverlay(new tY(this._context)), u.addDynamicOverlay(new eY(this._context)), u.addDynamicOverlay(new vb(this._context)), this._glyphMarginWidgets = new KZ(this._context), this._viewParts.push(this._glyphMarginWidgets);
    const g = new Su(this._context);
    g.getDomNode().appendChild(this._viewZones.marginDomNode), g.getDomNode().appendChild(u.getDomNode()), g.getDomNode().appendChild(this._glyphMarginWidgets.domNode), this._viewParts.push(g), this._contentWidgets = new FZ(this._context, this.domNode), this._viewParts.push(this._contentWidgets), this._viewCursors = new Y_(this._context), this._viewParts.push(this._viewCursors), this._overlayWidgets = new lY(this._context, this.domNode), this._viewParts.push(this._overlayWidgets);
    const f = new gY(this._context);
    this._viewParts.push(f);
    const m = new OZ(this._context);
    this._viewParts.push(m);
    const _ = new aY(this._context);
    if (this._viewParts.push(_), d) {
      const v = this._scrollbar.getOverviewRulerLayoutInfo();
      v.parent.insertBefore(d.getDomNode(), v.insertBefore);
    }
    this._linesContent.appendChild(h.getDomNode()), this._linesContent.appendChild(f.domNode), this._linesContent.appendChild(this._viewZones.domNode), this._linesContent.appendChild(this._viewLines.getDomNode()), this._linesContent.appendChild(this._contentWidgets.domNode), this._linesContent.appendChild(this._viewCursors.getDomNode()), this._overflowGuardContainer.appendChild(g.getDomNode()), this._overflowGuardContainer.appendChild(this._scrollbar.getDomNode()), this._overflowGuardContainer.appendChild(c.getDomNode()), this._overflowGuardContainer.appendChild(this._textAreaHandler.textArea), this._overflowGuardContainer.appendChild(this._textAreaHandler.textAreaCover), this._overflowGuardContainer.appendChild(this._overlayWidgets.getDomNode()), this._overflowGuardContainer.appendChild(_.getDomNode()), this._overflowGuardContainer.appendChild(m.domNode), this.domNode.appendChild(this._overflowGuardContainer), o ? (o.appendChild(this._contentWidgets.overflowingContentWidgetsDomNode.domNode), o.appendChild(this._overlayWidgets.overflowingOverlayWidgetsDomNode.domNode)) : (this.domNode.appendChild(this._contentWidgets.overflowingContentWidgetsDomNode), this.domNode.appendChild(this._overlayWidgets.overflowingOverlayWidgetsDomNode)), this._applyLayout(), this._pointerHandler = this._register(new E7(this._context, l, this._createPointerHandlerHelper()));
  }
  _computeGlyphMarginLanes() {
    const e = this._context.viewModel.model, t = this._context.viewModel.glyphLanes;
    let i = [], n = 0;
    i = i.concat(e.getAllMarginDecorations().map((s) => {
      var o, a, l;
      const d = (a = (o = s.options.glyphMargin) === null || o === void 0 ? void 0 : o.position) !== null && a !== void 0 ? a : Ec.Center;
      return n = Math.max(n, s.range.endLineNumber), { range: s.range, lane: d, persist: (l = s.options.glyphMargin) === null || l === void 0 ? void 0 : l.persistLane };
    })), i = i.concat(this._glyphMarginWidgets.getWidgets().map((s) => {
      const o = e.validateRange(s.preference.range);
      return n = Math.max(n, o.endLineNumber), { range: o, lane: s.preference.lane };
    })), i.sort((s, o) => L.compareRangesUsingStarts(s.range, o.range)), t.reset(n);
    for (const s of i)
      t.push(s.lane, s.range, s.persist);
    return t;
  }
  _createPointerHandlerHelper() {
    return {
      viewDomNode: this.domNode.domNode,
      linesContentDomNode: this._linesContent.domNode,
      viewLinesDomNode: this._viewLines.getDomNode().domNode,
      focusTextArea: () => {
        this.focus();
      },
      dispatchTextAreaEvent: (e) => {
        this._textAreaHandler.textArea.domNode.dispatchEvent(e);
      },
      getLastRenderData: () => {
        const e = this._viewCursors.getLastRenderData() || [], t = this._textAreaHandler.getLastRenderData();
        return new s7(e, t);
      },
      renderNow: () => {
        this.render(!0, !1);
      },
      shouldSuppressMouseDownOnViewZone: (e) => this._viewZones.shouldSuppressMouseDownOnViewZone(e),
      shouldSuppressMouseDownOnWidget: (e) => this._contentWidgets.shouldSuppressMouseDownOnWidget(e),
      getPositionFromDOMInfo: (e, t) => (this._flushAccumulatedAndRenderNow(), this._viewLines.getPositionFromDOMInfo(e, t)),
      visibleRangeForPosition: (e, t) => (this._flushAccumulatedAndRenderNow(), this._viewLines.visibleRangeForPosition(new A(e, t))),
      getLineWidth: (e) => (this._flushAccumulatedAndRenderNow(), this._viewLines.getLineWidth(e))
    };
  }
  _createTextAreaHandlerHelper() {
    return {
      visibleRangeForPosition: (e) => (this._flushAccumulatedAndRenderNow(), this._viewLines.visibleRangeForPosition(e))
    };
  }
  _applyLayout() {
    const t = this._context.configuration.options.get(
      145
      /* EditorOption.layoutInfo */
    );
    this.domNode.setWidth(t.width), this.domNode.setHeight(t.height), this._overflowGuardContainer.setWidth(t.width), this._overflowGuardContainer.setHeight(t.height), this._linesContent.setWidth(16777216), this._linesContent.setHeight(16777216);
  }
  _getEditorClassName() {
    const e = this._textAreaHandler.isFocused() ? " focused" : "";
    return this._context.configuration.options.get(
      142
      /* EditorOption.editorClassName */
    ) + " " + Qx(this._context.theme.type) + e;
  }
  // --- begin event handlers
  handleEvents(e) {
    super.handleEvents(e), this._scheduleRender();
  }
  onConfigurationChanged(e) {
    return this.domNode.setClassName(this._getEditorClassName()), this._applyLayout(), !1;
  }
  onCursorStateChanged(e) {
    return this._selections = e.selections, !1;
  }
  onDecorationsChanged(e) {
    return e.affectsGlyphMargin && (this._shouldRecomputeGlyphMarginLanes = !0), !1;
  }
  onFocusChanged(e) {
    return this.domNode.setClassName(this._getEditorClassName()), !1;
  }
  onThemeChanged(e) {
    return this._context.theme.update(e.theme), this.domNode.setClassName(this._getEditorClassName()), !1;
  }
  // --- end event handlers
  dispose() {
    this._renderAnimationFrame !== null && (this._renderAnimationFrame.dispose(), this._renderAnimationFrame = null), this._contentWidgets.overflowingContentWidgetsDomNode.domNode.remove(), this._context.removeEventHandler(this), this._viewLines.dispose();
    for (const e of this._viewParts)
      e.dispose();
    super.dispose();
  }
  _scheduleRender() {
    if (this._store.isDisposed)
      throw new Li();
    if (this._renderAnimationFrame === null) {
      const e = this._createCoordinatedRendering();
      this._renderAnimationFrame = iI.INSTANCE.scheduleCoordinatedRendering({
        window: we(this.domNode.domNode),
        prepareRenderText: () => {
          if (this._store.isDisposed)
            throw new Li();
          try {
            return e.prepareRenderText();
          } finally {
            this._renderAnimationFrame = null;
          }
        },
        renderText: () => {
          if (this._store.isDisposed)
            throw new Li();
          return e.renderText();
        },
        prepareRender: (t, i) => {
          if (this._store.isDisposed)
            throw new Li();
          return e.prepareRender(t, i);
        },
        render: (t, i) => {
          if (this._store.isDisposed)
            throw new Li();
          return e.render(t, i);
        }
      });
    }
  }
  _flushAccumulatedAndRenderNow() {
    const e = this._createCoordinatedRendering();
    sc(() => e.prepareRenderText());
    const t = sc(() => e.renderText());
    if (t) {
      const [i, n] = t;
      sc(() => e.prepareRender(i, n)), sc(() => e.render(i, n));
    }
  }
  _getViewPartsToRender() {
    const e = [];
    let t = 0;
    for (const i of this._viewParts)
      i.shouldRender() && (e[t++] = i);
    return e;
  }
  _createCoordinatedRendering() {
    return {
      prepareRenderText: () => {
        if (this._shouldRecomputeGlyphMarginLanes) {
          this._shouldRecomputeGlyphMarginLanes = !1;
          const e = this._computeGlyphMarginLanes();
          this._context.configuration.setGlyphMarginDecorationLaneCount(e.requiredLanes);
        }
        Jd.onRenderStart();
      },
      renderText: () => {
        if (!this.domNode.domNode.isConnected)
          return null;
        let e = this._getViewPartsToRender();
        if (!this._viewLines.shouldRender() && e.length === 0)
          return null;
        const t = this._context.viewLayout.getLinesViewportData();
        this._context.viewModel.setViewport(t.startLineNumber, t.endLineNumber, t.centeredLineNumber);
        const i = new SY(this._selections, t, this._context.viewLayout.getWhitespaceViewportData(), this._context.viewModel);
        return this._contentWidgets.shouldRender() && this._contentWidgets.onBeforeRender(i), this._viewLines.shouldRender() && (this._viewLines.renderText(i), this._viewLines.onDidRender(), e = this._getViewPartsToRender()), [e, new Q9(this._context.viewLayout, i, this._viewLines)];
      },
      prepareRender: (e, t) => {
        for (const i of e)
          i.prepareRender(t);
      },
      render: (e, t) => {
        for (const i of e)
          i.render(t), i.onDidRender();
      }
    };
  }
  // --- BEGIN CodeEditor helpers
  delegateVerticalScrollbarPointerDown(e) {
    this._scrollbar.delegateVerticalScrollbarPointerDown(e);
  }
  delegateScrollFromMouseWheelEvent(e) {
    this._scrollbar.delegateScrollFromMouseWheelEvent(e);
  }
  restoreState(e) {
    this._context.viewModel.viewLayout.setScrollPosition(
      {
        scrollTop: e.scrollTop,
        scrollLeft: e.scrollLeft
      },
      1
      /* ScrollType.Immediate */
    ), this._context.viewModel.visibleLinesStabilized();
  }
  getOffsetForColumn(e, t) {
    const i = this._context.viewModel.model.validatePosition({
      lineNumber: e,
      column: t
    }), n = this._context.viewModel.coordinatesConverter.convertModelPositionToViewPosition(i);
    this._flushAccumulatedAndRenderNow();
    const s = this._viewLines.visibleRangeForPosition(new A(n.lineNumber, n.column));
    return s ? s.left : -1;
  }
  getTargetAtClientPoint(e, t) {
    const i = this._pointerHandler.getTargetAtClientPoint(e, t);
    return i ? M0.convertViewToModelMouseTarget(i, this._context.viewModel.coordinatesConverter) : null;
  }
  createOverviewRuler(e) {
    return new uY(this._context, e);
  }
  change(e) {
    this._viewZones.changeViewZones(e), this._scheduleRender();
  }
  render(e, t) {
    if (t) {
      this._viewLines.forceShouldRender();
      for (const i of this._viewParts)
        i.forceShouldRender();
    }
    e ? this._flushAccumulatedAndRenderNow() : this._scheduleRender();
  }
  writeScreenReaderContent(e) {
    this._textAreaHandler.writeScreenReaderContent(e);
  }
  focus() {
    this._textAreaHandler.focusTextArea();
  }
  isFocused() {
    return this._textAreaHandler.isFocused();
  }
  setAriaOptions(e) {
    this._textAreaHandler.setAriaOptions(e);
  }
  addContentWidget(e) {
    this._contentWidgets.addWidget(e.widget), this.layoutContentWidget(e), this._scheduleRender();
  }
  layoutContentWidget(e) {
    var t, i, n, s, o, a, l, d;
    this._contentWidgets.setWidgetPosition(e.widget, (i = (t = e.position) === null || t === void 0 ? void 0 : t.position) !== null && i !== void 0 ? i : null, (s = (n = e.position) === null || n === void 0 ? void 0 : n.secondaryPosition) !== null && s !== void 0 ? s : null, (a = (o = e.position) === null || o === void 0 ? void 0 : o.preference) !== null && a !== void 0 ? a : null, (d = (l = e.position) === null || l === void 0 ? void 0 : l.positionAffinity) !== null && d !== void 0 ? d : null), this._scheduleRender();
  }
  removeContentWidget(e) {
    this._contentWidgets.removeWidget(e.widget), this._scheduleRender();
  }
  addOverlayWidget(e) {
    this._overlayWidgets.addWidget(e.widget), this.layoutOverlayWidget(e), this._scheduleRender();
  }
  layoutOverlayWidget(e) {
    this._overlayWidgets.setWidgetPosition(e.widget, e.position) && this._scheduleRender();
  }
  removeOverlayWidget(e) {
    this._overlayWidgets.removeWidget(e.widget), this._scheduleRender();
  }
  addGlyphMarginWidget(e) {
    this._glyphMarginWidgets.addWidget(e.widget), this._shouldRecomputeGlyphMarginLanes = !0, this._scheduleRender();
  }
  layoutGlyphMarginWidget(e) {
    const t = e.position;
    this._glyphMarginWidgets.setWidgetPosition(e.widget, t) && (this._shouldRecomputeGlyphMarginLanes = !0, this._scheduleRender());
  }
  removeGlyphMarginWidget(e) {
    this._glyphMarginWidgets.removeWidget(e.widget), this._shouldRecomputeGlyphMarginLanes = !0, this._scheduleRender();
  }
};
tI = DY([
  kY(6, be)
], tI);
function sc(r) {
  try {
    return r();
  } catch (e) {
    return He(e), null;
  }
}
class iI {
  constructor() {
    this._coordinatedRenderings = [], this._animationFrameRunners = /* @__PURE__ */ new Map();
  }
  scheduleCoordinatedRendering(e) {
    return this._coordinatedRenderings.push(e), this._scheduleRender(e.window), {
      dispose: () => {
        const t = this._coordinatedRenderings.indexOf(e);
        if (t !== -1 && (this._coordinatedRenderings.splice(t, 1), this._coordinatedRenderings.length === 0)) {
          for (const [i, n] of this._animationFrameRunners)
            n.dispose();
          this._animationFrameRunners.clear();
        }
      }
    };
  }
  _scheduleRender(e) {
    if (!this._animationFrameRunners.has(e)) {
      const t = () => {
        this._animationFrameRunners.delete(e), this._onRenderScheduled();
      };
      this._animationFrameRunners.set(e, hS(e, t, 100));
    }
  }
  _onRenderScheduled() {
    const e = this._coordinatedRenderings.slice(0);
    this._coordinatedRenderings = [];
    for (const i of e)
      sc(() => i.prepareRenderText());
    const t = [];
    for (let i = 0, n = e.length; i < n; i++) {
      const s = e[i];
      t[i] = sc(() => s.renderText());
    }
    for (let i = 0, n = e.length; i < n; i++) {
      const s = e[i], o = t[i];
      if (!o)
        continue;
      const [a, l] = o;
      sc(() => s.prepareRender(a, l));
    }
    for (let i = 0, n = e.length; i < n; i++) {
      const s = e[i], o = t[i];
      if (!o)
        continue;
      const [a, l] = o;
      sc(() => s.render(a, l));
    }
  }
}
iI.INSTANCE = new iI();
class a_ {
  constructor(e, t, i, n, s) {
    this.injectionOffsets = e, this.injectionOptions = t, this.breakOffsets = i, this.breakOffsetsVisibleColumn = n, this.wrappedTextIndentLength = s;
  }
  getOutputLineCount() {
    return this.breakOffsets.length;
  }
  getMinOutputOffset(e) {
    return e > 0 ? this.wrappedTextIndentLength : 0;
  }
  getLineLength(e) {
    const t = e > 0 ? this.breakOffsets[e - 1] : 0;
    let n = this.breakOffsets[e] - t;
    return e > 0 && (n += this.wrappedTextIndentLength), n;
  }
  getMaxOutputOffset(e) {
    return this.getLineLength(e);
  }
  translateToInputOffset(e, t) {
    e > 0 && (t = Math.max(0, t - this.wrappedTextIndentLength));
    let n = e === 0 ? t : this.breakOffsets[e - 1] + t;
    if (this.injectionOffsets !== null)
      for (let s = 0; s < this.injectionOffsets.length && n > this.injectionOffsets[s]; s++)
        n < this.injectionOffsets[s] + this.injectionOptions[s].content.length ? n = this.injectionOffsets[s] : n -= this.injectionOptions[s].content.length;
    return n;
  }
  translateToOutputPosition(e, t = 2) {
    let i = e;
    if (this.injectionOffsets !== null)
      for (let n = 0; n < this.injectionOffsets.length && !(e < this.injectionOffsets[n] || t !== 1 && e === this.injectionOffsets[n]); n++)
        i += this.injectionOptions[n].content.length;
    return this.offsetInInputWithInjectionsToOutputPosition(i, t);
  }
  offsetInInputWithInjectionsToOutputPosition(e, t = 2) {
    let i = 0, n = this.breakOffsets.length - 1, s = 0, o = 0;
    for (; i <= n; ) {
      s = i + (n - i) / 2 | 0;
      const l = this.breakOffsets[s];
      if (o = s > 0 ? this.breakOffsets[s - 1] : 0, t === 0)
        if (e <= o)
          n = s - 1;
        else if (e > l)
          i = s + 1;
        else
          break;
      else if (e < o)
        n = s - 1;
      else if (e >= l)
        i = s + 1;
      else
        break;
    }
    let a = e - o;
    return s > 0 && (a += this.wrappedTextIndentLength), new CC(s, a);
  }
  normalizeOutputPosition(e, t, i) {
    if (this.injectionOffsets !== null) {
      const n = this.outputPositionToOffsetInInputWithInjections(e, t), s = this.normalizeOffsetInInputWithInjectionsAroundInjections(n, i);
      if (s !== n)
        return this.offsetInInputWithInjectionsToOutputPosition(s, i);
    }
    if (i === 0) {
      if (e > 0 && t === this.getMinOutputOffset(e))
        return new CC(e - 1, this.getMaxOutputOffset(e - 1));
    } else if (i === 1) {
      const n = this.getOutputLineCount() - 1;
      if (e < n && t === this.getMaxOutputOffset(e))
        return new CC(e + 1, this.getMinOutputOffset(e + 1));
    }
    return new CC(e, t);
  }
  outputPositionToOffsetInInputWithInjections(e, t) {
    return e > 0 && (t = Math.max(0, t - this.wrappedTextIndentLength)), (e > 0 ? this.breakOffsets[e - 1] : 0) + t;
  }
  normalizeOffsetInInputWithInjectionsAroundInjections(e, t) {
    const i = this.getInjectedTextAtOffset(e);
    if (!i)
      return e;
    if (t === 2) {
      if (e === i.offsetInInputWithInjections + i.length && PP(this.injectionOptions[i.injectedTextIndex].cursorStops))
        return i.offsetInInputWithInjections + i.length;
      {
        let n = i.offsetInInputWithInjections;
        if (OP(this.injectionOptions[i.injectedTextIndex].cursorStops))
          return n;
        let s = i.injectedTextIndex - 1;
        for (; s >= 0 && this.injectionOffsets[s] === this.injectionOffsets[i.injectedTextIndex] && !(PP(this.injectionOptions[s].cursorStops) || (n -= this.injectionOptions[s].content.length, OP(this.injectionOptions[s].cursorStops))); )
          s--;
        return n;
      }
    } else if (t === 1 || t === 4) {
      let n = i.offsetInInputWithInjections + i.length, s = i.injectedTextIndex;
      for (; s + 1 < this.injectionOffsets.length && this.injectionOffsets[s + 1] === this.injectionOffsets[s]; )
        n += this.injectionOptions[s + 1].content.length, s++;
      return n;
    } else if (t === 0 || t === 3) {
      let n = i.offsetInInputWithInjections, s = i.injectedTextIndex;
      for (; s - 1 >= 0 && this.injectionOffsets[s - 1] === this.injectionOffsets[s]; )
        n -= this.injectionOptions[s - 1].content.length, s--;
      return n;
    }
    $N();
  }
  getInjectedText(e, t) {
    const i = this.outputPositionToOffsetInInputWithInjections(e, t), n = this.getInjectedTextAtOffset(i);
    return n ? {
      options: this.injectionOptions[n.injectedTextIndex]
    } : null;
  }
  getInjectedTextAtOffset(e) {
    const t = this.injectionOffsets, i = this.injectionOptions;
    if (t !== null) {
      let n = 0;
      for (let s = 0; s < t.length; s++) {
        const o = i[s].content.length, a = t[s] + n, l = t[s] + n + o;
        if (a > e)
          break;
        if (e <= l)
          return {
            injectedTextIndex: s,
            offsetInInputWithInjections: a,
            length: o
          };
        n += o;
      }
    }
  }
}
function PP(r) {
  return r == null ? !0 : r === Ba.Right || r === Ba.Both;
}
function OP(r) {
  return r == null ? !0 : r === Ba.Left || r === Ba.Both;
}
class CC {
  constructor(e, t) {
    this.outputLineIndex = e, this.outputOffset = t;
  }
  toString() {
    return `${this.outputLineIndex}:${this.outputOffset}`;
  }
  toPosition(e) {
    return new A(e + this.outputLineIndex, this.outputOffset + 1);
  }
}
class xY {
  constructor() {
    this.changeType = 1;
  }
}
class ea {
  static applyInjectedText(e, t) {
    if (!t || t.length === 0)
      return e;
    let i = "", n = 0;
    for (const s of t)
      i += e.substring(n, s.column - 1), n = s.column - 1, i += s.options.content;
    return i += e.substring(n), i;
  }
  static fromDecorations(e) {
    const t = [];
    for (const i of e)
      i.options.before && i.options.before.content.length > 0 && t.push(new ea(i.ownerId, i.range.startLineNumber, i.range.startColumn, i.options.before, 0)), i.options.after && i.options.after.content.length > 0 && t.push(new ea(i.ownerId, i.range.endLineNumber, i.range.endColumn, i.options.after, 1));
    return t.sort((i, n) => i.lineNumber === n.lineNumber ? i.column === n.column ? i.order - n.order : i.column - n.column : i.lineNumber - n.lineNumber), t;
  }
  constructor(e, t, i, n, s) {
    this.ownerId = e, this.lineNumber = t, this.column = i, this.options = n, this.order = s;
  }
}
class FP {
  constructor(e, t, i) {
    this.changeType = 2, this.lineNumber = e, this.detail = t, this.injectedText = i;
  }
}
class IY {
  constructor(e, t) {
    this.changeType = 3, this.fromLineNumber = e, this.toLineNumber = t;
  }
}
class EY {
  constructor(e, t, i, n) {
    this.changeType = 4, this.injectedTexts = n, this.fromLineNumber = e, this.toLineNumber = t, this.detail = i;
  }
}
class TY {
  constructor() {
    this.changeType = 5;
  }
}
class Sf {
  constructor(e, t, i, n) {
    this.changes = e, this.versionId = t, this.isUndoing = i, this.isRedoing = n, this.resultingSelection = null;
  }
  containsEvent(e) {
    for (let t = 0, i = this.changes.length; t < i; t++)
      if (this.changes[t].changeType === e)
        return !0;
    return !1;
  }
  static merge(e, t) {
    const i = [].concat(e.changes).concat(t.changes), n = t.versionId, s = e.isUndoing || t.isUndoing, o = e.isRedoing || t.isRedoing;
    return new Sf(i, n, s, o);
  }
}
class g2 {
  constructor(e) {
    this.changes = e;
  }
}
class du {
  constructor(e, t) {
    this.rawContentChangedEvent = e, this.contentChangedEvent = t;
  }
  merge(e) {
    const t = Sf.merge(this.rawContentChangedEvent, e.rawContentChangedEvent), i = du._mergeChangeEvents(this.contentChangedEvent, e.contentChangedEvent);
    return new du(t, i);
  }
  static _mergeChangeEvents(e, t) {
    const i = [].concat(e.changes).concat(t.changes), n = t.eol, s = t.versionId, o = e.isUndoing || t.isUndoing, a = e.isRedoing || t.isRedoing, l = e.isFlush || t.isFlush, d = e.isEolChange && t.isEolChange;
    return {
      changes: i,
      eol: n,
      isEolChange: d,
      versionId: s,
      isUndoing: o,
      isRedoing: a,
      isFlush: l
    };
  }
}
const XD = wd("domLineBreaksComputer", { createHTML: (r) => r });
class A1 {
  static create(e) {
    return new A1(new WeakRef(e));
  }
  constructor(e) {
    this.targetWindow = e;
  }
  createLineBreaksComputer(e, t, i, n, s) {
    const o = [], a = [];
    return {
      addRequest: (l, d, c) => {
        o.push(l), a.push(d);
      },
      finalize: () => NY(Xd(this.targetWindow.deref()), o, e, t, i, n, s, a)
    };
  }
}
function NY(r, e, t, i, n, s, o, a) {
  var l;
  function d(F) {
    const V = a[F];
    if (V) {
      const Z = ea.applyInjectedText(e[F], V), H = V.map((ue) => ue.options), re = V.map((ue) => ue.column - 1);
      return new a_(re, H, [Z.length], [], 0);
    } else
      return null;
  }
  if (n === -1) {
    const F = [];
    for (let V = 0, Z = e.length; V < Z; V++)
      F[V] = d(V);
    return F;
  }
  const c = Math.round(n * t.typicalHalfwidthCharacterWidth), u = Math.round(i * (s === 3 ? 2 : s === 2 ? 1 : 0)), g = Math.ceil(t.spaceWidth * u), f = document.createElement("div");
  _n(f, t);
  const m = new Tp(1e4), _ = [], v = [], b = [], C = [], w = [];
  for (let F = 0; F < e.length; F++) {
    const V = ea.applyInjectedText(e[F], a[F]);
    let Z = 0, H = 0, re = c;
    if (s !== 0)
      if (Z = ns(V), Z === -1)
        Z = 0;
      else {
        for (let ze = 0; ze < Z; ze++) {
          const pe = V.charCodeAt(ze) === 9 ? i - H % i : 1;
          H += pe;
        }
        const Ye = Math.ceil(t.spaceWidth * H);
        Ye + t.typicalFullwidthCharacterWidth > c ? (Z = 0, H = 0) : re = c - Ye;
      }
    const ue = V.substr(Z), Ve = MY(ue, H, i, re, m, g);
    _[F] = Z, v[F] = H, b[F] = ue, C[F] = Ve[0], w[F] = Ve[1];
  }
  const S = m.build(), y = (l = XD == null ? void 0 : XD.createHTML(S)) !== null && l !== void 0 ? l : S;
  f.innerHTML = y, f.style.position = "absolute", f.style.top = "10000", o === "keepAll" ? (f.style.wordBreak = "keep-all", f.style.overflowWrap = "anywhere") : (f.style.wordBreak = "inherit", f.style.overflowWrap = "break-word"), r.document.body.appendChild(f);
  const k = document.createRange(), E = Array.prototype.slice.call(f.children, 0), N = [];
  for (let F = 0; F < e.length; F++) {
    const V = E[F], Z = RY(k, V, b[F], C[F]);
    if (Z === null) {
      N[F] = d(F);
      continue;
    }
    const H = _[F], re = v[F] + u, ue = w[F], Ve = [];
    for (let $e = 0, Be = Z.length; $e < Be; $e++)
      Ve[$e] = ue[Z[$e]];
    if (H !== 0)
      for (let $e = 0, Be = Z.length; $e < Be; $e++)
        Z[$e] += H;
    let Ye, ze;
    const pe = a[F];
    pe ? (Ye = pe.map(($e) => $e.options), ze = pe.map(($e) => $e.column - 1)) : (Ye = null, ze = null), N[F] = new a_(ze, Ye, Z, Ve, re);
  }
  return r.document.body.removeChild(f), N;
}
function MY(r, e, t, i, n, s) {
  if (s !== 0) {
    const u = String(s);
    n.appendString('<div style="text-indent: -'), n.appendString(u), n.appendString("px; padding-left: "), n.appendString(u), n.appendString("px; box-sizing: border-box; width:");
  } else
    n.appendString('<div style="width:');
  n.appendString(String(i)), n.appendString('px;">');
  const o = r.length;
  let a = e, l = 0;
  const d = [], c = [];
  let h = 0 < o ? r.charCodeAt(0) : 0;
  n.appendString("<span>");
  for (let u = 0; u < o; u++) {
    u !== 0 && u % 16384 === 0 && n.appendString("</span><span>"), d[u] = l, c[u] = a;
    const g = h;
    h = u + 1 < o ? r.charCodeAt(u + 1) : 0;
    let f = 1, m = 1;
    switch (g) {
      case 9:
        f = t - a % t, m = f;
        for (let _ = 1; _ <= f; _++)
          _ < f ? n.appendCharCode(160) : n.appendASCIICharCode(
            32
            /* CharCode.Space */
          );
        break;
      case 32:
        h === 32 ? n.appendCharCode(160) : n.appendASCIICharCode(
          32
          /* CharCode.Space */
        );
        break;
      case 60:
        n.appendString("&lt;");
        break;
      case 62:
        n.appendString("&gt;");
        break;
      case 38:
        n.appendString("&amp;");
        break;
      case 0:
        n.appendString("&#00;");
        break;
      case 65279:
      case 8232:
      case 8233:
      case 133:
        n.appendCharCode(65533);
        break;
      default:
        kc(g) && m++, g < 32 ? n.appendCharCode(9216 + g) : n.appendCharCode(g);
    }
    l += f, a += m;
  }
  return n.appendString("</span>"), d[r.length] = l, c[r.length] = a, n.appendString("</div>"), [d, c];
}
function RY(r, e, t, i) {
  if (t.length <= 1)
    return null;
  const n = Array.prototype.slice.call(e.children, 0), s = [];
  try {
    nI(r, n, i, 0, null, t.length - 1, null, s);
  } catch (o) {
    return console.log(o), null;
  }
  return s.length === 0 ? null : (s.push(t.length), s);
}
function nI(r, e, t, i, n, s, o, a) {
  if (i === s || (n = n || JD(r, e, t[i], t[i + 1]), o = o || JD(r, e, t[s], t[s + 1]), Math.abs(n[0].top - o[0].top) <= 0.1))
    return;
  if (i + 1 === s) {
    a.push(s);
    return;
  }
  const l = i + (s - i) / 2 | 0, d = JD(r, e, t[l], t[l + 1]);
  nI(r, e, t, i, n, l, d, a), nI(r, e, t, l, d, s, o, a);
}
function JD(r, e, t, i) {
  return r.setStart(
    e[t / 16384 | 0].firstChild,
    t % 16384
    /* Constants.SPAN_MODULO_LIMIT */
  ), r.setEnd(
    e[i / 16384 | 0].firstChild,
    i % 16384
    /* Constants.SPAN_MODULO_LIMIT */
  ), r.getClientRects();
}
class AY extends P {
  constructor() {
    super(), this._editor = null, this._instantiationService = null, this._instances = this._register(new KN()), this._pending = /* @__PURE__ */ new Map(), this._finishedInstantiation = [], this._finishedInstantiation[
      0
      /* EditorContributionInstantiation.Eager */
    ] = !1, this._finishedInstantiation[
      1
      /* EditorContributionInstantiation.AfterFirstRender */
    ] = !1, this._finishedInstantiation[
      2
      /* EditorContributionInstantiation.BeforeFirstInteraction */
    ] = !1, this._finishedInstantiation[
      3
      /* EditorContributionInstantiation.Eventually */
    ] = !1;
  }
  initialize(e, t, i) {
    this._editor = e, this._instantiationService = i;
    for (const n of t) {
      if (this._pending.has(n.id)) {
        He(new Error(`Cannot have two contributions with the same id ${n.id}`));
        continue;
      }
      this._pending.set(n.id, n);
    }
    this._instantiateSome(
      0
      /* EditorContributionInstantiation.Eager */
    ), this._register(ym(we(this._editor.getDomNode()), () => {
      this._instantiateSome(
        1
        /* EditorContributionInstantiation.AfterFirstRender */
      );
    })), this._register(ym(we(this._editor.getDomNode()), () => {
      this._instantiateSome(
        2
        /* EditorContributionInstantiation.BeforeFirstInteraction */
      );
    })), this._register(ym(we(this._editor.getDomNode()), () => {
      this._instantiateSome(
        3
        /* EditorContributionInstantiation.Eventually */
      );
    }, 5e3));
  }
  saveViewState() {
    const e = {};
    for (const [t, i] of this._instances)
      typeof i.saveViewState == "function" && (e[t] = i.saveViewState());
    return e;
  }
  restoreViewState(e) {
    for (const [t, i] of this._instances)
      typeof i.restoreViewState == "function" && i.restoreViewState(e[t]);
  }
  get(e) {
    return this._instantiateById(e), this._instances.get(e) || null;
  }
  onBeforeInteractionEvent() {
    this._instantiateSome(
      2
      /* EditorContributionInstantiation.BeforeFirstInteraction */
    );
  }
  onAfterModelAttached() {
    var e;
    return ym(we((e = this._editor) === null || e === void 0 ? void 0 : e.getDomNode()), () => {
      this._instantiateSome(
        1
        /* EditorContributionInstantiation.AfterFirstRender */
      );
    }, 50);
  }
  _instantiateSome(e) {
    if (this._finishedInstantiation[e])
      return;
    this._finishedInstantiation[e] = !0;
    const t = this._findPendingContributionsByInstantiation(e);
    for (const i of t)
      this._instantiateById(i.id);
  }
  _findPendingContributionsByInstantiation(e) {
    const t = [];
    for (const [, i] of this._pending)
      i.instantiation === e && t.push(i);
    return t;
  }
  _instantiateById(e) {
    const t = this._pending.get(e);
    if (t) {
      if (this._pending.delete(e), !this._instantiationService || !this._editor)
        throw new Error("Cannot instantiate contributions before being initialized!");
      try {
        const i = this._instantiationService.createInstance(t.ctor, this._editor);
        this._instances.set(t.id, i), typeof i.restoreViewState == "function" && t.instantiation !== 0 && console.warn(`Editor contribution '${t.id}' should be eager instantiated because it uses saveViewState / restoreViewState.`);
      } catch (i) {
        He(i);
      }
    }
  }
}
class f2 {
  constructor(e, t, i, n, s, o, a) {
    this.id = e, this.label = t, this.alias = i, this.metadata = n, this._precondition = s, this._run = o, this._contextKeyService = a;
  }
  isSupported() {
    return this._contextKeyService.contextMatchesRules(this._precondition);
  }
  run(e) {
    return this.isSupported() ? this._run(e) : Promise.resolve(void 0);
  }
}
function Oc(r) {
  let e = 0, t = 0, i = 0, n = 0;
  for (let s = 0, o = r.length; s < o; s++) {
    const a = r.charCodeAt(s);
    a === 13 ? (e === 0 && (t = s), e++, s + 1 < o && r.charCodeAt(s + 1) === 10 ? (n |= 2, s++) : n |= 3, i = s + 1) : a === 10 && (n |= 1, e === 0 && (t = s), e++, i = s + 1);
  }
  return e === 0 && (t = r.length), [e, t, r.length - i, n];
}
class WP {
  constructor(e, t, i, n) {
    this.range = e, this.nestingLevel = t, this.nestingLevelOfEqualBracketType = i, this.isInvalid = n;
  }
}
class PY {
  constructor(e, t, i, n, s, o) {
    this.range = e, this.openingBracketRange = t, this.closingBracketRange = i, this.nestingLevel = n, this.nestingLevelOfEqualBracketType = s, this.bracketPairNode = o;
  }
  get openingBracketInfo() {
    return this.bracketPairNode.openingBracket.bracketInfo;
  }
}
class OY extends PY {
  constructor(e, t, i, n, s, o, a) {
    super(e, t, i, n, s, o), this.minVisibleColumnIndentation = a;
  }
}
function FY(r, e, t, i) {
  return r !== t ? Ii(t - r, i) : Ii(0, i - e);
}
const is = 0;
function kS(r) {
  return r === 0;
}
const uo = 2 ** 26;
function Ii(r, e) {
  return r * uo + e;
}
function Ao(r) {
  const e = r, t = Math.floor(e / uo), i = e - t * uo;
  return new Tc(t, i);
}
function WY(r) {
  return Math.floor(r / uo);
}
function li(r, e) {
  let t = r + e;
  return e >= uo && (t = t - r % uo), t;
}
function BY(r, e) {
  return r.reduce((t, i) => li(t, e(i)), is);
}
function p2(r, e) {
  return r === e;
}
function Q_(r, e) {
  const t = r, i = e;
  if (i - t <= 0)
    return is;
  const s = Math.floor(t / uo), o = Math.floor(i / uo), a = i - o * uo;
  if (s === o) {
    const l = t - s * uo;
    return Ii(0, a - l);
  } else
    return Ii(o - s, a);
}
function yf(r, e) {
  return r < e;
}
function Lf(r, e) {
  return r <= e;
}
function Am(r, e) {
  return r >= e;
}
function Jg(r) {
  return Ii(r.lineNumber - 1, r.column - 1);
}
function cu(r, e) {
  const t = r, i = Math.floor(t / uo), n = t - i * uo, s = e, o = Math.floor(s / uo), a = s - o * uo;
  return new L(i + 1, n + 1, o + 1, a + 1);
}
function HY(r) {
  const e = vd(r);
  return Ii(e.length - 1, e[e.length - 1].length);
}
class Xl {
  static fromModelContentChanges(e) {
    return e.map((i) => {
      const n = L.lift(i.range);
      return new Xl(Jg(n.getStartPosition()), Jg(n.getEndPosition()), HY(i.text));
    }).reverse();
  }
  constructor(e, t, i) {
    this.startOffset = e, this.endOffset = t, this.newLength = i;
  }
  toString() {
    return `[${Ao(this.startOffset)}...${Ao(this.endOffset)}) -> ${Ao(this.newLength)}`;
  }
}
class VY {
  /**
   * @param edits Must be sorted by offset in ascending order.
  */
  constructor(e) {
    this.nextEditIdx = 0, this.deltaOldToNewLineCount = 0, this.deltaOldToNewColumnCount = 0, this.deltaLineIdxInOld = -1, this.edits = e.map((t) => P1.from(t));
  }
  /**
   * @param offset Must be equal to or greater than the last offset this method has been called with.
  */
  getOffsetBeforeChange(e) {
    return this.adjustNextEdit(e), this.translateCurToOld(e);
  }
  /**
   * @param offset Must be equal to or greater than the last offset this method has been called with.
   * Returns null if there is no edit anymore.
  */
  getDistanceToNextChange(e) {
    this.adjustNextEdit(e);
    const t = this.edits[this.nextEditIdx], i = t ? this.translateOldToCur(t.offsetObj) : null;
    return i === null ? null : Q_(e, i);
  }
  translateOldToCur(e) {
    return e.lineCount === this.deltaLineIdxInOld ? Ii(e.lineCount + this.deltaOldToNewLineCount, e.columnCount + this.deltaOldToNewColumnCount) : Ii(e.lineCount + this.deltaOldToNewLineCount, e.columnCount);
  }
  translateCurToOld(e) {
    const t = Ao(e);
    return t.lineCount - this.deltaOldToNewLineCount === this.deltaLineIdxInOld ? Ii(t.lineCount - this.deltaOldToNewLineCount, t.columnCount - this.deltaOldToNewColumnCount) : Ii(t.lineCount - this.deltaOldToNewLineCount, t.columnCount);
  }
  adjustNextEdit(e) {
    for (; this.nextEditIdx < this.edits.length; ) {
      const t = this.edits[this.nextEditIdx], i = this.translateOldToCur(t.endOffsetAfterObj);
      if (Lf(i, e)) {
        this.nextEditIdx++;
        const n = Ao(i), s = Ao(this.translateOldToCur(t.endOffsetBeforeObj)), o = n.lineCount - s.lineCount;
        this.deltaOldToNewLineCount += o;
        const a = this.deltaLineIdxInOld === t.endOffsetBeforeObj.lineCount ? this.deltaOldToNewColumnCount : 0, l = n.columnCount - s.columnCount;
        this.deltaOldToNewColumnCount = a + l, this.deltaLineIdxInOld = t.endOffsetBeforeObj.lineCount;
      } else
        break;
    }
  }
}
class P1 {
  static from(e) {
    return new P1(e.startOffset, e.endOffset, e.newLength);
  }
  constructor(e, t, i) {
    this.endOffsetBeforeObj = Ao(t), this.endOffsetAfterObj = Ao(li(e, i)), this.offsetObj = Ao(e);
  }
}
const Pw = [];
class Pi {
  static create(e, t) {
    if (e <= 128 && t.length === 0) {
      let i = Pi.cache[e];
      return i || (i = new Pi(e, t), Pi.cache[e] = i), i;
    }
    return new Pi(e, t);
  }
  static getEmpty() {
    return this.empty;
  }
  constructor(e, t) {
    this.items = e, this.additionalItems = t;
  }
  add(e, t) {
    const i = t.getKey(e);
    let n = i >> 5;
    if (n === 0) {
      const o = 1 << i | this.items;
      return o === this.items ? this : Pi.create(o, this.additionalItems);
    }
    n--;
    const s = this.additionalItems.slice(0);
    for (; s.length < n; )
      s.push(0);
    return s[n] |= 1 << (i & 31), Pi.create(this.items, s);
  }
  merge(e) {
    const t = this.items | e.items;
    if (this.additionalItems === Pw && e.additionalItems === Pw)
      return t === this.items ? this : t === e.items ? e : Pi.create(t, Pw);
    const i = [];
    for (let n = 0; n < Math.max(this.additionalItems.length, e.additionalItems.length); n++) {
      const s = this.additionalItems[n] || 0, o = e.additionalItems[n] || 0;
      i.push(s | o);
    }
    return Pi.create(t, i);
  }
  intersects(e) {
    if (this.items & e.items)
      return !0;
    for (let t = 0; t < Math.min(this.additionalItems.length, e.additionalItems.length); t++)
      if (this.additionalItems[t] & e.additionalItems[t])
        return !0;
    return !1;
  }
}
Pi.cache = new Array(129);
Pi.empty = Pi.create(0, Pw);
const BP = {
  getKey(r) {
    return r;
  }
};
class m2 {
  constructor() {
    this.items = /* @__PURE__ */ new Map();
  }
  getKey(e) {
    let t = this.items.get(e);
    return t === void 0 && (t = this.items.size, this.items.set(e, t)), t;
  }
}
class O1 {
  /**
   * The length of the entire node, which should equal the sum of lengths of all children.
  */
  get length() {
    return this._length;
  }
  constructor(e) {
    this._length = e;
  }
}
class X_ extends O1 {
  static create(e, t, i) {
    let n = e.length;
    return t && (n = li(n, t.length)), i && (n = li(n, i.length)), new X_(n, e, t, i, t ? t.missingOpeningBracketIds : Pi.getEmpty());
  }
  get kind() {
    return 2;
  }
  get listHeight() {
    return 0;
  }
  get childrenLength() {
    return 3;
  }
  getChild(e) {
    switch (e) {
      case 0:
        return this.openingBracket;
      case 1:
        return this.child;
      case 2:
        return this.closingBracket;
    }
    throw new Error("Invalid child index");
  }
  /**
   * Avoid using this property, it allocates an array!
  */
  get children() {
    const e = [];
    return e.push(this.openingBracket), this.child && e.push(this.child), this.closingBracket && e.push(this.closingBracket), e;
  }
  constructor(e, t, i, n, s) {
    super(e), this.openingBracket = t, this.child = i, this.closingBracket = n, this.missingOpeningBracketIds = s;
  }
  canBeReused(e) {
    return !(this.closingBracket === null || e.intersects(this.missingOpeningBracketIds));
  }
  deepClone() {
    return new X_(this.length, this.openingBracket.deepClone(), this.child && this.child.deepClone(), this.closingBracket && this.closingBracket.deepClone(), this.missingOpeningBracketIds);
  }
  computeMinIndentation(e, t) {
    return this.child ? this.child.computeMinIndentation(li(e, this.openingBracket.length), t) : Number.MAX_SAFE_INTEGER;
  }
}
class tl extends O1 {
  /**
   * This method uses more memory-efficient list nodes that can only store 2 or 3 children.
  */
  static create23(e, t, i, n = !1) {
    let s = e.length, o = e.missingOpeningBracketIds;
    if (e.listHeight !== t.listHeight)
      throw new Error("Invalid list heights");
    if (s = li(s, t.length), o = o.merge(t.missingOpeningBracketIds), i) {
      if (e.listHeight !== i.listHeight)
        throw new Error("Invalid list heights");
      s = li(s, i.length), o = o.merge(i.missingOpeningBracketIds);
    }
    return n ? new zY(s, e.listHeight + 1, e, t, i, o) : new J_(s, e.listHeight + 1, e, t, i, o);
  }
  static getEmpty() {
    return new UY(is, 0, [], Pi.getEmpty());
  }
  get kind() {
    return 4;
  }
  get missingOpeningBracketIds() {
    return this._missingOpeningBracketIds;
  }
  /**
   * Use ListAstNode.create.
  */
  constructor(e, t, i) {
    super(e), this.listHeight = t, this._missingOpeningBracketIds = i, this.cachedMinIndentation = -1;
  }
  throwIfImmutable() {
  }
  makeLastElementMutable() {
    this.throwIfImmutable();
    const e = this.childrenLength;
    if (e === 0)
      return;
    const t = this.getChild(e - 1), i = t.kind === 4 ? t.toMutable() : t;
    return t !== i && this.setChild(e - 1, i), i;
  }
  makeFirstElementMutable() {
    if (this.throwIfImmutable(), this.childrenLength === 0)
      return;
    const t = this.getChild(0), i = t.kind === 4 ? t.toMutable() : t;
    return t !== i && this.setChild(0, i), i;
  }
  canBeReused(e) {
    if (e.intersects(this.missingOpeningBracketIds) || this.childrenLength === 0)
      return !1;
    let t = this;
    for (; t.kind === 4; ) {
      const i = t.childrenLength;
      if (i === 0)
        throw new Li();
      t = t.getChild(i - 1);
    }
    return t.canBeReused(e);
  }
  handleChildrenChanged() {
    this.throwIfImmutable();
    const e = this.childrenLength;
    let t = this.getChild(0).length, i = this.getChild(0).missingOpeningBracketIds;
    for (let n = 1; n < e; n++) {
      const s = this.getChild(n);
      t = li(t, s.length), i = i.merge(s.missingOpeningBracketIds);
    }
    this._length = t, this._missingOpeningBracketIds = i, this.cachedMinIndentation = -1;
  }
  computeMinIndentation(e, t) {
    if (this.cachedMinIndentation !== -1)
      return this.cachedMinIndentation;
    let i = Number.MAX_SAFE_INTEGER, n = e;
    for (let s = 0; s < this.childrenLength; s++) {
      const o = this.getChild(s);
      o && (i = Math.min(i, o.computeMinIndentation(n, t)), n = li(n, o.length));
    }
    return this.cachedMinIndentation = i, i;
  }
}
class J_ extends tl {
  get childrenLength() {
    return this._item3 !== null ? 3 : 2;
  }
  getChild(e) {
    switch (e) {
      case 0:
        return this._item1;
      case 1:
        return this._item2;
      case 2:
        return this._item3;
    }
    throw new Error("Invalid child index");
  }
  setChild(e, t) {
    switch (e) {
      case 0:
        this._item1 = t;
        return;
      case 1:
        this._item2 = t;
        return;
      case 2:
        this._item3 = t;
        return;
    }
    throw new Error("Invalid child index");
  }
  get children() {
    return this._item3 ? [this._item1, this._item2, this._item3] : [this._item1, this._item2];
  }
  get item1() {
    return this._item1;
  }
  get item2() {
    return this._item2;
  }
  get item3() {
    return this._item3;
  }
  constructor(e, t, i, n, s, o) {
    super(e, t, o), this._item1 = i, this._item2 = n, this._item3 = s;
  }
  deepClone() {
    return new J_(this.length, this.listHeight, this._item1.deepClone(), this._item2.deepClone(), this._item3 ? this._item3.deepClone() : null, this.missingOpeningBracketIds);
  }
  appendChildOfSameHeight(e) {
    if (this._item3)
      throw new Error("Cannot append to a full (2,3) tree node");
    this.throwIfImmutable(), this._item3 = e, this.handleChildrenChanged();
  }
  unappendChild() {
    if (!this._item3)
      throw new Error("Cannot remove from a non-full (2,3) tree node");
    this.throwIfImmutable();
    const e = this._item3;
    return this._item3 = null, this.handleChildrenChanged(), e;
  }
  prependChildOfSameHeight(e) {
    if (this._item3)
      throw new Error("Cannot prepend to a full (2,3) tree node");
    this.throwIfImmutable(), this._item3 = this._item2, this._item2 = this._item1, this._item1 = e, this.handleChildrenChanged();
  }
  unprependChild() {
    if (!this._item3)
      throw new Error("Cannot remove from a non-full (2,3) tree node");
    this.throwIfImmutable();
    const e = this._item1;
    return this._item1 = this._item2, this._item2 = this._item3, this._item3 = null, this.handleChildrenChanged(), e;
  }
  toMutable() {
    return this;
  }
}
class zY extends J_ {
  toMutable() {
    return new J_(this.length, this.listHeight, this.item1, this.item2, this.item3, this.missingOpeningBracketIds);
  }
  throwIfImmutable() {
    throw new Error("this instance is immutable");
  }
}
class xS extends tl {
  get childrenLength() {
    return this._children.length;
  }
  getChild(e) {
    return this._children[e];
  }
  setChild(e, t) {
    this._children[e] = t;
  }
  get children() {
    return this._children;
  }
  constructor(e, t, i, n) {
    super(e, t, n), this._children = i;
  }
  deepClone() {
    const e = new Array(this._children.length);
    for (let t = 0; t < this._children.length; t++)
      e[t] = this._children[t].deepClone();
    return new xS(this.length, this.listHeight, e, this.missingOpeningBracketIds);
  }
  appendChildOfSameHeight(e) {
    this.throwIfImmutable(), this._children.push(e), this.handleChildrenChanged();
  }
  unappendChild() {
    this.throwIfImmutable();
    const e = this._children.pop();
    return this.handleChildrenChanged(), e;
  }
  prependChildOfSameHeight(e) {
    this.throwIfImmutable(), this._children.unshift(e), this.handleChildrenChanged();
  }
  unprependChild() {
    this.throwIfImmutable();
    const e = this._children.shift();
    return this.handleChildrenChanged(), e;
  }
  toMutable() {
    return this;
  }
}
class UY extends xS {
  toMutable() {
    return new xS(this.length, this.listHeight, [...this.children], this.missingOpeningBracketIds);
  }
  throwIfImmutable() {
    throw new Error("this instance is immutable");
  }
}
const $Y = [];
class F1 extends O1 {
  get listHeight() {
    return 0;
  }
  get childrenLength() {
    return 0;
  }
  getChild(e) {
    return null;
  }
  get children() {
    return $Y;
  }
  deepClone() {
    return this;
  }
}
class zh extends F1 {
  get kind() {
    return 0;
  }
  get missingOpeningBracketIds() {
    return Pi.getEmpty();
  }
  canBeReused(e) {
    return !0;
  }
  computeMinIndentation(e, t) {
    const i = Ao(e), n = (i.columnCount === 0 ? i.lineCount : i.lineCount + 1) + 1, s = WY(li(e, this.length)) + 1;
    let o = Number.MAX_SAFE_INTEGER;
    for (let a = n; a <= s; a++) {
      const l = t.getLineFirstNonWhitespaceColumn(a), d = t.getLineContent(a);
      if (l === 0)
        continue;
      const c = Hi.visibleColumnFromColumn(d, l, t.getOptions().tabSize);
      o = Math.min(o, c);
    }
    return o;
  }
}
class IS extends F1 {
  static create(e, t, i) {
    return new IS(e, t, i);
  }
  get kind() {
    return 1;
  }
  get missingOpeningBracketIds() {
    return Pi.getEmpty();
  }
  constructor(e, t, i) {
    super(e), this.bracketInfo = t, this.bracketIds = i;
  }
  get text() {
    return this.bracketInfo.bracketText;
  }
  get languageId() {
    return this.bracketInfo.languageId;
  }
  canBeReused(e) {
    return !1;
  }
  computeMinIndentation(e, t) {
    return Number.MAX_SAFE_INTEGER;
  }
}
class KY extends F1 {
  get kind() {
    return 3;
  }
  constructor(e, t) {
    super(t), this.missingOpeningBracketIds = e;
  }
  canBeReused(e) {
    return !e.intersects(this.missingOpeningBracketIds);
  }
  computeMinIndentation(e, t) {
    return Number.MAX_SAFE_INTEGER;
  }
}
let Gd = class {
  constructor(e, t, i, n, s) {
    this.length = e, this.kind = t, this.bracketId = i, this.bracketIds = n, this.astNode = s;
  }
};
class _2 {
  constructor(e, t) {
    this.textModel = e, this.bracketTokens = t, this.reader = new jY(this.textModel, this.bracketTokens), this._offset = is, this.didPeek = !1, this.peeked = null, this.textBufferLineCount = e.getLineCount(), this.textBufferLastLineLength = e.getLineLength(this.textBufferLineCount);
  }
  get offset() {
    return this._offset;
  }
  get length() {
    return Ii(this.textBufferLineCount - 1, this.textBufferLastLineLength);
  }
  skip(e) {
    this.didPeek = !1, this._offset = li(this._offset, e);
    const t = Ao(this._offset);
    this.reader.setPosition(t.lineCount, t.columnCount);
  }
  read() {
    let e;
    return this.peeked ? (this.didPeek = !1, e = this.peeked) : e = this.reader.read(), e && (this._offset = li(this._offset, e.length)), e;
  }
  peek() {
    return this.didPeek || (this.peeked = this.reader.read(), this.didPeek = !0), this.peeked;
  }
}
class jY {
  constructor(e, t) {
    this.textModel = e, this.bracketTokens = t, this.lineIdx = 0, this.line = null, this.lineCharOffset = 0, this.lineTokens = null, this.lineTokenOffset = 0, this.peekedToken = null, this.textBufferLineCount = e.getLineCount(), this.textBufferLastLineLength = e.getLineLength(this.textBufferLineCount);
  }
  setPosition(e, t) {
    e === this.lineIdx ? (this.lineCharOffset = t, this.line !== null && (this.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset))) : (this.lineIdx = e, this.lineCharOffset = t, this.line = null), this.peekedToken = null;
  }
  read() {
    if (this.peekedToken) {
      const s = this.peekedToken;
      return this.peekedToken = null, this.lineCharOffset += s.length, s;
    }
    if (this.lineIdx > this.textBufferLineCount - 1 || this.lineIdx === this.textBufferLineCount - 1 && this.lineCharOffset >= this.textBufferLastLineLength)
      return null;
    this.line === null && (this.lineTokens = this.textModel.tokenization.getLineTokens(this.lineIdx + 1), this.line = this.lineTokens.getLineContent(), this.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset));
    const e = this.lineIdx, t = this.lineCharOffset;
    let i = 0;
    for (; ; ) {
      const s = this.lineTokens, o = s.getCount();
      let a = null;
      if (this.lineTokenOffset < o) {
        const l = s.getMetadata(this.lineTokenOffset);
        for (; this.lineTokenOffset + 1 < o && l === s.getMetadata(this.lineTokenOffset + 1); )
          this.lineTokenOffset++;
        const d = yn.getTokenType(l) === 0, c = yn.containsBalancedBrackets(l), h = s.getEndOffset(this.lineTokenOffset);
        if (c && d && this.lineCharOffset < h) {
          const u = s.getLanguageId(this.lineTokenOffset), g = this.line.substring(this.lineCharOffset, h), f = this.bracketTokens.getSingleLanguageBracketTokens(u), m = f.regExpGlobal;
          if (m) {
            m.lastIndex = 0;
            const _ = m.exec(g);
            _ && (a = f.getToken(_[0]), a && (this.lineCharOffset += _.index));
          }
        }
        if (i += h - this.lineCharOffset, a)
          if (e !== this.lineIdx || t !== this.lineCharOffset) {
            this.peekedToken = a;
            break;
          } else
            return this.lineCharOffset += a.length, a;
        else
          this.lineTokenOffset++, this.lineCharOffset = h;
      } else if (this.lineIdx === this.textBufferLineCount - 1 || (this.lineIdx++, this.lineTokens = this.textModel.tokenization.getLineTokens(this.lineIdx + 1), this.lineTokenOffset = 0, this.line = this.lineTokens.getLineContent(), this.lineCharOffset = 0, i += 33, i > 1e3))
        break;
      if (i > 1500)
        break;
    }
    const n = FY(e, t, this.lineIdx, this.lineCharOffset);
    return new Gd(n, 0, -1, Pi.getEmpty(), new zh(n));
  }
}
class qY {
  constructor(e, t) {
    this.text = e, this._offset = is, this.idx = 0;
    const i = t.getRegExpStr(), n = i ? new RegExp(i + `|
`, "gi") : null, s = [];
    let o, a = 0, l = 0, d = 0, c = 0;
    const h = [];
    for (let f = 0; f < 60; f++)
      h.push(new Gd(Ii(0, f), 0, -1, Pi.getEmpty(), new zh(Ii(0, f))));
    const u = [];
    for (let f = 0; f < 60; f++)
      u.push(new Gd(Ii(1, f), 0, -1, Pi.getEmpty(), new zh(Ii(1, f))));
    if (n)
      for (n.lastIndex = 0; (o = n.exec(e)) !== null; ) {
        const f = o.index, m = o[0];
        if (m === `
`)
          a++, l = f + 1;
        else {
          if (d !== f) {
            let _;
            if (c === a) {
              const v = f - d;
              if (v < h.length)
                _ = h[v];
              else {
                const b = Ii(0, v);
                _ = new Gd(b, 0, -1, Pi.getEmpty(), new zh(b));
              }
            } else {
              const v = a - c, b = f - l;
              if (v === 1 && b < u.length)
                _ = u[b];
              else {
                const C = Ii(v, b);
                _ = new Gd(C, 0, -1, Pi.getEmpty(), new zh(C));
              }
            }
            s.push(_);
          }
          s.push(t.getToken(m)), d = f + m.length, c = a;
        }
      }
    const g = e.length;
    if (d !== g) {
      const f = c === a ? Ii(0, g - d) : Ii(a - c, g - l);
      s.push(new Gd(f, 0, -1, Pi.getEmpty(), new zh(f)));
    }
    this.length = Ii(a, g - l), this.tokens = s;
  }
  get offset() {
    return this._offset;
  }
  read() {
    return this.tokens[this.idx++] || null;
  }
  peek() {
    return this.tokens[this.idx] || null;
  }
  skip(e) {
    throw new _5();
  }
}
class W1 {
  static createFromLanguage(e, t) {
    function i(s) {
      return t.getKey(`${s.languageId}:::${s.bracketText}`);
    }
    const n = /* @__PURE__ */ new Map();
    for (const s of e.bracketsNew.openingBrackets) {
      const o = Ii(0, s.bracketText.length), a = i(s), l = Pi.getEmpty().add(a, BP);
      n.set(s.bracketText, new Gd(o, 1, a, l, IS.create(o, s, l)));
    }
    for (const s of e.bracketsNew.closingBrackets) {
      const o = Ii(0, s.bracketText.length);
      let a = Pi.getEmpty();
      const l = s.getOpeningBrackets();
      for (const d of l)
        a = a.add(i(d), BP);
      n.set(s.bracketText, new Gd(o, 2, i(l[0]), a, IS.create(o, s, a)));
    }
    return new W1(n);
  }
  constructor(e) {
    this.map = e, this.hasRegExp = !1, this._regExpGlobal = null;
  }
  getRegExpStr() {
    if (this.isEmpty)
      return null;
    {
      const e = [...this.map.keys()];
      return e.sort(), e.reverse(), e.map((t) => GY(t)).join("|");
    }
  }
  /**
   * Returns null if there is no such regexp (because there are no brackets).
  */
  get regExpGlobal() {
    if (!this.hasRegExp) {
      const e = this.getRegExpStr();
      this._regExpGlobal = e ? new RegExp(e, "gi") : null, this.hasRegExp = !0;
    }
    return this._regExpGlobal;
  }
  getToken(e) {
    return this.map.get(e.toLowerCase());
  }
  findClosingTokenText(e) {
    for (const [t, i] of this.map)
      if (i.kind === 2 && i.bracketIds.intersects(e))
        return t;
  }
  get isEmpty() {
    return this.map.size === 0;
  }
}
function GY(r) {
  let e = gr(r);
  return /^[\w ]+/.test(r) && (e = `\\b${e}`), /[\w ]+$/.test(r) && (e = `${e}\\b`), e;
}
class v2 {
  constructor(e, t) {
    this.denseKeyProvider = e, this.getLanguageConfiguration = t, this.languageIdToBracketTokens = /* @__PURE__ */ new Map();
  }
  didLanguageChange(e) {
    return this.languageIdToBracketTokens.has(e);
  }
  getSingleLanguageBracketTokens(e) {
    let t = this.languageIdToBracketTokens.get(e);
    return t || (t = W1.createFromLanguage(this.getLanguageConfiguration(e), this.denseKeyProvider), this.languageIdToBracketTokens.set(e, t)), t;
  }
}
function ZY(r) {
  if (r.length === 0)
    return null;
  if (r.length === 1)
    return r[0];
  let e = 0;
  function t() {
    if (e >= r.length)
      return null;
    const o = e, a = r[o].listHeight;
    for (e++; e < r.length && r[e].listHeight === a; )
      e++;
    return e - o >= 2 ? b2(o === 0 && e === r.length ? r : r.slice(o, e), !1) : r[o];
  }
  let i = t(), n = t();
  if (!n)
    return i;
  for (let o = t(); o; o = t())
    HP(i, n) <= HP(n, o) ? (i = ek(i, n), n = o) : n = ek(n, o);
  return ek(i, n);
}
function b2(r, e = !1) {
  if (r.length === 0)
    return null;
  if (r.length === 1)
    return r[0];
  let t = r.length;
  for (; t > 3; ) {
    const i = t >> 1;
    for (let n = 0; n < i; n++) {
      const s = n << 1;
      r[n] = tl.create23(r[s], r[s + 1], s + 3 === t ? r[s + 2] : null, e);
    }
    t = i;
  }
  return tl.create23(r[0], r[1], t >= 3 ? r[2] : null, e);
}
function HP(r, e) {
  return Math.abs(r.listHeight - e.listHeight);
}
function ek(r, e) {
  return r.listHeight === e.listHeight ? tl.create23(r, e, null, !1) : r.listHeight > e.listHeight ? YY(r, e) : QY(e, r);
}
function YY(r, e) {
  r = r.toMutable();
  let t = r;
  const i = [];
  let n;
  for (; ; ) {
    if (e.listHeight === t.listHeight) {
      n = e;
      break;
    }
    if (t.kind !== 4)
      throw new Error("unexpected");
    i.push(t), t = t.makeLastElementMutable();
  }
  for (let s = i.length - 1; s >= 0; s--) {
    const o = i[s];
    n ? o.childrenLength >= 3 ? n = tl.create23(o.unappendChild(), n, null, !1) : (o.appendChildOfSameHeight(n), n = void 0) : o.handleChildrenChanged();
  }
  return n ? tl.create23(r, n, null, !1) : r;
}
function QY(r, e) {
  r = r.toMutable();
  let t = r;
  const i = [];
  for (; e.listHeight !== t.listHeight; ) {
    if (t.kind !== 4)
      throw new Error("unexpected");
    i.push(t), t = t.makeFirstElementMutable();
  }
  let n = e;
  for (let s = i.length - 1; s >= 0; s--) {
    const o = i[s];
    n ? o.childrenLength >= 3 ? n = tl.create23(n, o.unprependChild(), null, !1) : (o.prependChildOfSameHeight(n), n = void 0) : o.handleChildrenChanged();
  }
  return n ? tl.create23(n, r, null, !1) : r;
}
class XY {
  constructor(e) {
    this.lastOffset = is, this.nextNodes = [e], this.offsets = [is], this.idxs = [];
  }
  /**
   * Returns the longest node at `offset` that satisfies the predicate.
   * @param offset must be greater than or equal to the last offset this method has been called with!
  */
  readLongestNodeAt(e, t) {
    if (yf(e, this.lastOffset))
      throw new Error("Invalid offset");
    for (this.lastOffset = e; ; ) {
      const i = nm(this.nextNodes);
      if (!i)
        return;
      const n = nm(this.offsets);
      if (yf(e, n))
        return;
      if (yf(n, e))
        if (li(n, i.length) <= e)
          this.nextNodeAfterCurrent();
        else {
          const s = tk(i);
          s !== -1 ? (this.nextNodes.push(i.getChild(s)), this.offsets.push(n), this.idxs.push(s)) : this.nextNodeAfterCurrent();
        }
      else {
        if (t(i))
          return this.nextNodeAfterCurrent(), i;
        {
          const s = tk(i);
          if (s === -1) {
            this.nextNodeAfterCurrent();
            return;
          } else
            this.nextNodes.push(i.getChild(s)), this.offsets.push(n), this.idxs.push(s);
        }
      }
    }
  }
  // Navigates to the longest node that continues after the current node.
  nextNodeAfterCurrent() {
    for (; ; ) {
      const e = nm(this.offsets), t = nm(this.nextNodes);
      if (this.nextNodes.pop(), this.offsets.pop(), this.idxs.length === 0)
        break;
      const i = nm(this.nextNodes), n = tk(i, this.idxs[this.idxs.length - 1]);
      if (n !== -1) {
        this.nextNodes.push(i.getChild(n)), this.offsets.push(li(e, t.length)), this.idxs[this.idxs.length - 1] = n;
        break;
      } else
        this.idxs.pop();
    }
  }
}
function tk(r, e = -1) {
  for (; ; ) {
    if (e++, e >= r.childrenLength)
      return -1;
    if (r.getChild(e))
      return e;
  }
}
function nm(r) {
  return r.length > 0 ? r[r.length - 1] : void 0;
}
function sI(r, e, t, i) {
  return new JY(r, e, t, i).parseDocument();
}
class JY {
  constructor(e, t, i, n) {
    if (this.tokenizer = e, this.createImmutableLists = n, this._itemsConstructed = 0, this._itemsFromCache = 0, i && n)
      throw new Error("Not supported");
    this.oldNodeReader = i ? new XY(i) : void 0, this.positionMapper = new VY(t);
  }
  parseDocument() {
    this._itemsConstructed = 0, this._itemsFromCache = 0;
    let e = this.parseList(Pi.getEmpty(), 0);
    return e || (e = tl.getEmpty()), e;
  }
  parseList(e, t) {
    const i = [];
    for (; ; ) {
      let s = this.tryReadChildFromCache(e);
      if (!s) {
        const o = this.tokenizer.peek();
        if (!o || o.kind === 2 && o.bracketIds.intersects(e))
          break;
        s = this.parseChild(e, t + 1);
      }
      s.kind === 4 && s.childrenLength === 0 || i.push(s);
    }
    return this.oldNodeReader ? ZY(i) : b2(i, this.createImmutableLists);
  }
  tryReadChildFromCache(e) {
    if (this.oldNodeReader) {
      const t = this.positionMapper.getDistanceToNextChange(this.tokenizer.offset);
      if (t === null || !kS(t)) {
        const i = this.oldNodeReader.readLongestNodeAt(this.positionMapper.getOffsetBeforeChange(this.tokenizer.offset), (n) => t !== null && !yf(n.length, t) ? !1 : n.canBeReused(e));
        if (i)
          return this._itemsFromCache++, this.tokenizer.skip(i.length), i;
      }
    }
  }
  parseChild(e, t) {
    this._itemsConstructed++;
    const i = this.tokenizer.read();
    switch (i.kind) {
      case 2:
        return new KY(i.bracketIds, i.length);
      case 0:
        return i.astNode;
      case 1: {
        if (t > 300)
          return new zh(i.length);
        const n = e.merge(i.bracketIds), s = this.parseList(n, t + 1), o = this.tokenizer.peek();
        return o && o.kind === 2 && (o.bracketId === i.bracketId || o.bracketIds.intersects(i.bracketIds)) ? (this.tokenizer.read(), X_.create(i.astNode, s, o.astNode)) : X_.create(i.astNode, s, null);
      }
      default:
        throw new Error("unexpected");
    }
  }
}
function ES(r, e) {
  if (r.length === 0)
    return e;
  if (e.length === 0)
    return r;
  const t = new ad(VP(r)), i = VP(e);
  i.push({ modified: !1, lengthBefore: void 0, lengthAfter: void 0 });
  let n = t.dequeue();
  function s(d) {
    if (d === void 0) {
      const h = t.takeWhile((u) => !0) || [];
      return n && h.unshift(n), h;
    }
    const c = [];
    for (; n && !kS(d); ) {
      const [h, u] = n.splitAt(d);
      c.push(h), d = Q_(h.lengthAfter, d), n = u ?? t.dequeue();
    }
    return kS(d) || c.push(new oc(!1, d, d)), c;
  }
  const o = [];
  function a(d, c, h) {
    if (o.length > 0 && p2(o[o.length - 1].endOffset, d)) {
      const u = o[o.length - 1];
      o[o.length - 1] = new Xl(u.startOffset, c, li(u.newLength, h));
    } else
      o.push({ startOffset: d, endOffset: c, newLength: h });
  }
  let l = is;
  for (const d of i) {
    const c = s(d.lengthBefore);
    if (d.modified) {
      const h = BY(c, (g) => g.lengthBefore), u = li(l, h);
      a(l, u, d.lengthAfter), l = u;
    } else
      for (const h of c) {
        const u = l;
        l = li(l, h.lengthBefore), h.modified && a(u, l, h.lengthAfter);
      }
  }
  return o;
}
class oc {
  constructor(e, t, i) {
    this.modified = e, this.lengthBefore = t, this.lengthAfter = i;
  }
  splitAt(e) {
    const t = Q_(e, this.lengthAfter);
    return p2(t, is) ? [this, void 0] : this.modified ? [
      new oc(this.modified, this.lengthBefore, e),
      new oc(this.modified, is, t)
    ] : [
      new oc(this.modified, e, e),
      new oc(this.modified, t, t)
    ];
  }
  toString() {
    return `${this.modified ? "M" : "U"}:${Ao(this.lengthBefore)} -> ${Ao(this.lengthAfter)}`;
  }
}
function VP(r) {
  const e = [];
  let t = is;
  for (const i of r) {
    const n = Q_(t, i.startOffset);
    kS(n) || e.push(new oc(!1, n, n));
    const s = Q_(i.startOffset, i.endOffset);
    e.push(new oc(!0, s, i.newLength)), t = i.endOffset;
  }
  return e;
}
class eQ extends P {
  didLanguageChange(e) {
    return this.brackets.didLanguageChange(e);
  }
  constructor(e, t) {
    if (super(), this.textModel = e, this.getLanguageConfiguration = t, this.didChangeEmitter = new R(), this.denseKeyProvider = new m2(), this.brackets = new v2(this.denseKeyProvider, this.getLanguageConfiguration), this.onDidChange = this.didChangeEmitter.event, this.queuedTextEditsForInitialAstWithoutTokens = [], this.queuedTextEdits = [], e.tokenization.hasTokens)
      e.tokenization.backgroundTokenizationState === 2 ? (this.initialAstWithoutTokens = void 0, this.astWithTokens = this.parseDocumentFromTextBuffer([], void 0, !1)) : (this.initialAstWithoutTokens = this.parseDocumentFromTextBuffer([], void 0, !0), this.astWithTokens = this.initialAstWithoutTokens);
    else {
      const i = this.brackets.getSingleLanguageBracketTokens(this.textModel.getLanguageId()), n = new qY(this.textModel.getValue(), i);
      this.initialAstWithoutTokens = sI(n, [], void 0, !0), this.astWithTokens = this.initialAstWithoutTokens;
    }
  }
  //#region TextModel events
  handleDidChangeBackgroundTokenizationState() {
    if (this.textModel.tokenization.backgroundTokenizationState === 2) {
      const e = this.initialAstWithoutTokens === void 0;
      this.initialAstWithoutTokens = void 0, e || this.didChangeEmitter.fire();
    }
  }
  handleDidChangeTokens({ ranges: e }) {
    const t = e.map((i) => new Xl(Ii(i.fromLineNumber - 1, 0), Ii(i.toLineNumber, 0), Ii(i.toLineNumber - i.fromLineNumber + 1, 0)));
    this.handleEdits(t, !0), this.initialAstWithoutTokens || this.didChangeEmitter.fire();
  }
  handleContentChanged(e) {
    const t = Xl.fromModelContentChanges(e.changes);
    this.handleEdits(t, !1);
  }
  handleEdits(e, t) {
    const i = ES(this.queuedTextEdits, e);
    this.queuedTextEdits = i, this.initialAstWithoutTokens && !t && (this.queuedTextEditsForInitialAstWithoutTokens = ES(this.queuedTextEditsForInitialAstWithoutTokens, e));
  }
  //#endregion
  flushQueue() {
    this.queuedTextEdits.length > 0 && (this.astWithTokens = this.parseDocumentFromTextBuffer(this.queuedTextEdits, this.astWithTokens, !1), this.queuedTextEdits = []), this.queuedTextEditsForInitialAstWithoutTokens.length > 0 && (this.initialAstWithoutTokens && (this.initialAstWithoutTokens = this.parseDocumentFromTextBuffer(this.queuedTextEditsForInitialAstWithoutTokens, this.initialAstWithoutTokens, !1)), this.queuedTextEditsForInitialAstWithoutTokens = []);
  }
  /**
   * @pure (only if isPure = true)
  */
  parseDocumentFromTextBuffer(e, t, i) {
    const n = t, s = new _2(this.textModel, this.brackets);
    return sI(s, e, n, i);
  }
  getBracketsInRange(e, t) {
    this.flushQueue();
    const i = Ii(e.startLineNumber - 1, e.startColumn - 1), n = Ii(e.endLineNumber - 1, e.endColumn - 1);
    return new Zm((s) => {
      const o = this.initialAstWithoutTokens || this.astWithTokens;
      oI(o, is, o.length, i, n, s, 0, 0, /* @__PURE__ */ new Map(), t);
    });
  }
  getBracketPairsInRange(e, t) {
    this.flushQueue();
    const i = Jg(e.getStartPosition()), n = Jg(e.getEndPosition());
    return new Zm((s) => {
      const o = this.initialAstWithoutTokens || this.astWithTokens, a = new tQ(s, t, this.textModel);
      rI(o, is, o.length, i, n, a, 0, /* @__PURE__ */ new Map());
    });
  }
  getFirstBracketAfter(e) {
    this.flushQueue();
    const t = this.initialAstWithoutTokens || this.astWithTokens;
    return w2(t, is, t.length, Jg(e));
  }
  getFirstBracketBefore(e) {
    this.flushQueue();
    const t = this.initialAstWithoutTokens || this.astWithTokens;
    return C2(t, is, t.length, Jg(e));
  }
}
function C2(r, e, t, i) {
  if (r.kind === 4 || r.kind === 2) {
    const n = [];
    for (const s of r.children)
      t = li(e, s.length), n.push({ nodeOffsetStart: e, nodeOffsetEnd: t }), e = t;
    for (let s = n.length - 1; s >= 0; s--) {
      const { nodeOffsetStart: o, nodeOffsetEnd: a } = n[s];
      if (yf(o, i)) {
        const l = C2(r.children[s], o, a, i);
        if (l)
          return l;
      }
    }
    return null;
  } else {
    if (r.kind === 3)
      return null;
    if (r.kind === 1) {
      const n = cu(e, t);
      return {
        bracketInfo: r.bracketInfo,
        range: n
      };
    }
  }
  return null;
}
function w2(r, e, t, i) {
  if (r.kind === 4 || r.kind === 2) {
    for (const n of r.children) {
      if (t = li(e, n.length), yf(i, t)) {
        const s = w2(n, e, t, i);
        if (s)
          return s;
      }
      e = t;
    }
    return null;
  } else {
    if (r.kind === 3)
      return null;
    if (r.kind === 1) {
      const n = cu(e, t);
      return {
        bracketInfo: r.bracketInfo,
        range: n
      };
    }
  }
  return null;
}
function oI(r, e, t, i, n, s, o, a, l, d, c = !1) {
  if (o > 200)
    return !0;
  e: for (; ; )
    switch (r.kind) {
      case 4: {
        const h = r.childrenLength;
        for (let u = 0; u < h; u++) {
          const g = r.getChild(u);
          if (g) {
            if (t = li(e, g.length), Lf(e, n) && Am(t, i)) {
              if (Am(t, n)) {
                r = g;
                continue e;
              }
              if (!oI(g, e, t, i, n, s, o, 0, l, d))
                return !1;
            }
            e = t;
          }
        }
        return !0;
      }
      case 2: {
        const h = !d || !r.closingBracket || r.closingBracket.bracketInfo.closesColorized(r.openingBracket.bracketInfo);
        let u = 0;
        if (l) {
          let f = l.get(r.openingBracket.text);
          f === void 0 && (f = 0), u = f, h && (f++, l.set(r.openingBracket.text, f));
        }
        const g = r.childrenLength;
        for (let f = 0; f < g; f++) {
          const m = r.getChild(f);
          if (m) {
            if (t = li(e, m.length), Lf(e, n) && Am(t, i)) {
              if (Am(t, n) && m.kind !== 1) {
                r = m, h ? (o++, a = u + 1) : a = u;
                continue e;
              }
              if ((h || m.kind !== 1 || !r.closingBracket) && !oI(m, e, t, i, n, s, h ? o + 1 : o, h ? u + 1 : u, l, d, !r.closingBracket))
                return !1;
            }
            e = t;
          }
        }
        return l == null || l.set(r.openingBracket.text, u), !0;
      }
      case 3: {
        const h = cu(e, t);
        return s(new WP(h, o - 1, 0, !0));
      }
      case 1: {
        const h = cu(e, t);
        return s(new WP(h, o - 1, a - 1, c));
      }
      case 0:
        return !0;
    }
}
class tQ {
  constructor(e, t, i) {
    this.push = e, this.includeMinIndentation = t, this.textModel = i;
  }
}
function rI(r, e, t, i, n, s, o, a) {
  var l;
  if (o > 200)
    return !0;
  let d = !0;
  if (r.kind === 2) {
    let c = 0;
    if (a) {
      let g = a.get(r.openingBracket.text);
      g === void 0 && (g = 0), c = g, g++, a.set(r.openingBracket.text, g);
    }
    const h = li(e, r.openingBracket.length);
    let u = -1;
    if (s.includeMinIndentation && (u = r.computeMinIndentation(e, s.textModel)), d = s.push(new OY(cu(e, t), cu(e, h), r.closingBracket ? cu(li(h, ((l = r.child) === null || l === void 0 ? void 0 : l.length) || is), t) : void 0, o, c, r, u)), e = h, d && r.child) {
      const g = r.child;
      if (t = li(e, g.length), Lf(e, n) && Am(t, i) && (d = rI(g, e, t, i, n, s, o + 1, a), !d))
        return !1;
    }
    a == null || a.set(r.openingBracket.text, c);
  } else {
    let c = e;
    for (const h of r.children) {
      const u = c;
      if (c = li(c, h.length), Lf(u, n) && Lf(i, c) && (d = rI(h, u, c, i, n, s, o, a), !d))
        return !1;
    }
  }
  return d;
}
class iQ extends P {
  get canBuildAST() {
    return this.textModel.getValueLength() <= 5e6;
  }
  constructor(e, t) {
    super(), this.textModel = e, this.languageConfigurationService = t, this.bracketPairsTree = this._register(new Yi()), this.onDidChangeEmitter = new R(), this.onDidChange = this.onDidChangeEmitter.event, this.bracketsRequested = !1, this._register(this.languageConfigurationService.onDidChange((i) => {
      var n;
      (!i.languageId || !((n = this.bracketPairsTree.value) === null || n === void 0) && n.object.didLanguageChange(i.languageId)) && (this.bracketPairsTree.clear(), this.updateBracketPairsTree());
    }));
  }
  //#region TextModel events
  handleDidChangeOptions(e) {
    this.bracketPairsTree.clear(), this.updateBracketPairsTree();
  }
  handleDidChangeLanguage(e) {
    this.bracketPairsTree.clear(), this.updateBracketPairsTree();
  }
  handleDidChangeContent(e) {
    var t;
    (t = this.bracketPairsTree.value) === null || t === void 0 || t.object.handleContentChanged(e);
  }
  handleDidChangeBackgroundTokenizationState() {
    var e;
    (e = this.bracketPairsTree.value) === null || e === void 0 || e.object.handleDidChangeBackgroundTokenizationState();
  }
  handleDidChangeTokens(e) {
    var t;
    (t = this.bracketPairsTree.value) === null || t === void 0 || t.object.handleDidChangeTokens(e);
  }
  //#endregion
  updateBracketPairsTree() {
    if (this.bracketsRequested && this.canBuildAST) {
      if (!this.bracketPairsTree.value) {
        const e = new q();
        this.bracketPairsTree.value = nQ(e.add(new eQ(this.textModel, (t) => this.languageConfigurationService.getLanguageConfiguration(t))), e), e.add(this.bracketPairsTree.value.object.onDidChange((t) => this.onDidChangeEmitter.fire(t))), this.onDidChangeEmitter.fire();
      }
    } else
      this.bracketPairsTree.value && (this.bracketPairsTree.clear(), this.onDidChangeEmitter.fire());
  }
  /**
   * Returns all bracket pairs that intersect the given range.
   * The result is sorted by the start position.
  */
  getBracketPairsInRange(e) {
    var t;
    return this.bracketsRequested = !0, this.updateBracketPairsTree(), ((t = this.bracketPairsTree.value) === null || t === void 0 ? void 0 : t.object.getBracketPairsInRange(e, !1)) || Zm.empty;
  }
  getBracketPairsInRangeWithMinIndentation(e) {
    var t;
    return this.bracketsRequested = !0, this.updateBracketPairsTree(), ((t = this.bracketPairsTree.value) === null || t === void 0 ? void 0 : t.object.getBracketPairsInRange(e, !0)) || Zm.empty;
  }
  getBracketsInRange(e, t = !1) {
    var i;
    return this.bracketsRequested = !0, this.updateBracketPairsTree(), ((i = this.bracketPairsTree.value) === null || i === void 0 ? void 0 : i.object.getBracketsInRange(e, t)) || Zm.empty;
  }
  findMatchingBracketUp(e, t, i) {
    const n = this.textModel.validatePosition(t), s = this.textModel.getLanguageIdAtPosition(n.lineNumber, n.column);
    if (this.canBuildAST) {
      const o = this.languageConfigurationService.getLanguageConfiguration(s).bracketsNew.getClosingBracketInfo(e);
      if (!o)
        return null;
      const a = this.getBracketPairsInRange(L.fromPositions(t, t)).findLast((l) => o.closes(l.openingBracketInfo));
      return a ? a.openingBracketRange : null;
    } else {
      const o = e.toLowerCase(), a = this.languageConfigurationService.getLanguageConfiguration(s).brackets;
      if (!a)
        return null;
      const l = a.textIsBracket[o];
      return l ? wC(this._findMatchingBracketUp(l, n, ik(i))) : null;
    }
  }
  matchBracket(e, t) {
    if (this.canBuildAST) {
      const i = this.getBracketPairsInRange(L.fromPositions(e, e)).filter((n) => n.closingBracketRange !== void 0 && (n.openingBracketRange.containsPosition(e) || n.closingBracketRange.containsPosition(e))).findLastMaxBy(cr((n) => n.openingBracketRange.containsPosition(e) ? n.openingBracketRange : n.closingBracketRange, L.compareRangesUsingStarts));
      return i ? [i.openingBracketRange, i.closingBracketRange] : null;
    } else {
      const i = ik(t);
      return this._matchBracket(this.textModel.validatePosition(e), i);
    }
  }
  _establishBracketSearchOffsets(e, t, i, n) {
    const s = t.getCount(), o = t.getLanguageId(n);
    let a = Math.max(0, e.column - 1 - i.maxBracketLength);
    for (let d = n - 1; d >= 0; d--) {
      const c = t.getEndOffset(d);
      if (c <= a)
        break;
      if (wa(t.getStandardTokenType(d)) || t.getLanguageId(d) !== o) {
        a = c;
        break;
      }
    }
    let l = Math.min(t.getLineContent().length, e.column - 1 + i.maxBracketLength);
    for (let d = n + 1; d < s; d++) {
      const c = t.getStartOffset(d);
      if (c >= l)
        break;
      if (wa(t.getStandardTokenType(d)) || t.getLanguageId(d) !== o) {
        l = c;
        break;
      }
    }
    return { searchStartOffset: a, searchEndOffset: l };
  }
  _matchBracket(e, t) {
    const i = e.lineNumber, n = this.textModel.tokenization.getLineTokens(i), s = this.textModel.getLineContent(i), o = n.findTokenIndexAtOffset(e.column - 1);
    if (o < 0)
      return null;
    const a = this.languageConfigurationService.getLanguageConfiguration(n.getLanguageId(o)).brackets;
    if (a && !wa(n.getStandardTokenType(o))) {
      let { searchStartOffset: l, searchEndOffset: d } = this._establishBracketSearchOffsets(e, n, a, o), c = null;
      for (; ; ) {
        const h = Qo.findNextBracketInRange(a.forwardRegex, i, s, l, d);
        if (!h)
          break;
        if (h.startColumn <= e.column && e.column <= h.endColumn) {
          const u = s.substring(h.startColumn - 1, h.endColumn - 1).toLowerCase(), g = this._matchFoundBracket(h, a.textIsBracket[u], a.textIsOpenBracket[u], t);
          if (g) {
            if (g instanceof El)
              return null;
            c = g;
          }
        }
        l = h.endColumn - 1;
      }
      if (c)
        return c;
    }
    if (o > 0 && n.getStartOffset(o) === e.column - 1) {
      const l = o - 1, d = this.languageConfigurationService.getLanguageConfiguration(n.getLanguageId(l)).brackets;
      if (d && !wa(n.getStandardTokenType(l))) {
        const { searchStartOffset: c, searchEndOffset: h } = this._establishBracketSearchOffsets(e, n, d, l), u = Qo.findPrevBracketInRange(d.reversedRegex, i, s, c, h);
        if (u && u.startColumn <= e.column && e.column <= u.endColumn) {
          const g = s.substring(u.startColumn - 1, u.endColumn - 1).toLowerCase(), f = this._matchFoundBracket(u, d.textIsBracket[g], d.textIsOpenBracket[g], t);
          if (f)
            return f instanceof El ? null : f;
        }
      }
    }
    return null;
  }
  _matchFoundBracket(e, t, i, n) {
    if (!t)
      return null;
    const s = i ? this._findMatchingBracketDown(t, e.getEndPosition(), n) : this._findMatchingBracketUp(t, e.getStartPosition(), n);
    return s ? s instanceof El ? s : [e, s] : null;
  }
  _findMatchingBracketUp(e, t, i) {
    const n = e.languageId, s = e.reversedRegex;
    let o = -1, a = 0;
    const l = (d, c, h, u) => {
      for (; ; ) {
        if (i && ++a % 100 === 0 && !i())
          return El.INSTANCE;
        const g = Qo.findPrevBracketInRange(s, d, c, h, u);
        if (!g)
          break;
        const f = c.substring(g.startColumn - 1, g.endColumn - 1).toLowerCase();
        if (e.isOpen(f) ? o++ : e.isClose(f) && o--, o === 0)
          return g;
        u = g.startColumn - 1;
      }
      return null;
    };
    for (let d = t.lineNumber; d >= 1; d--) {
      const c = this.textModel.tokenization.getLineTokens(d), h = c.getCount(), u = this.textModel.getLineContent(d);
      let g = h - 1, f = u.length, m = u.length;
      d === t.lineNumber && (g = c.findTokenIndexAtOffset(t.column - 1), f = t.column - 1, m = t.column - 1);
      let _ = !0;
      for (; g >= 0; g--) {
        const v = c.getLanguageId(g) === n && !wa(c.getStandardTokenType(g));
        if (v)
          _ ? f = c.getStartOffset(g) : (f = c.getStartOffset(g), m = c.getEndOffset(g));
        else if (_ && f !== m) {
          const b = l(d, u, f, m);
          if (b)
            return b;
        }
        _ = v;
      }
      if (_ && f !== m) {
        const v = l(d, u, f, m);
        if (v)
          return v;
      }
    }
    return null;
  }
  _findMatchingBracketDown(e, t, i) {
    const n = e.languageId, s = e.forwardRegex;
    let o = 1, a = 0;
    const l = (c, h, u, g) => {
      for (; ; ) {
        if (i && ++a % 100 === 0 && !i())
          return El.INSTANCE;
        const f = Qo.findNextBracketInRange(s, c, h, u, g);
        if (!f)
          break;
        const m = h.substring(f.startColumn - 1, f.endColumn - 1).toLowerCase();
        if (e.isOpen(m) ? o++ : e.isClose(m) && o--, o === 0)
          return f;
        u = f.endColumn - 1;
      }
      return null;
    }, d = this.textModel.getLineCount();
    for (let c = t.lineNumber; c <= d; c++) {
      const h = this.textModel.tokenization.getLineTokens(c), u = h.getCount(), g = this.textModel.getLineContent(c);
      let f = 0, m = 0, _ = 0;
      c === t.lineNumber && (f = h.findTokenIndexAtOffset(t.column - 1), m = t.column - 1, _ = t.column - 1);
      let v = !0;
      for (; f < u; f++) {
        const b = h.getLanguageId(f) === n && !wa(h.getStandardTokenType(f));
        if (b)
          v || (m = h.getStartOffset(f)), _ = h.getEndOffset(f);
        else if (v && m !== _) {
          const C = l(c, g, m, _);
          if (C)
            return C;
        }
        v = b;
      }
      if (v && m !== _) {
        const b = l(c, g, m, _);
        if (b)
          return b;
      }
    }
    return null;
  }
  findPrevBracket(e) {
    var t;
    const i = this.textModel.validatePosition(e);
    if (this.canBuildAST)
      return this.bracketsRequested = !0, this.updateBracketPairsTree(), ((t = this.bracketPairsTree.value) === null || t === void 0 ? void 0 : t.object.getFirstBracketBefore(i)) || null;
    let n = null, s = null, o = null;
    for (let a = i.lineNumber; a >= 1; a--) {
      const l = this.textModel.tokenization.getLineTokens(a), d = l.getCount(), c = this.textModel.getLineContent(a);
      let h = d - 1, u = c.length, g = c.length;
      if (a === i.lineNumber) {
        h = l.findTokenIndexAtOffset(i.column - 1), u = i.column - 1, g = i.column - 1;
        const m = l.getLanguageId(h);
        n !== m && (n = m, s = this.languageConfigurationService.getLanguageConfiguration(n).brackets, o = this.languageConfigurationService.getLanguageConfiguration(n).bracketsNew);
      }
      let f = !0;
      for (; h >= 0; h--) {
        const m = l.getLanguageId(h);
        if (n !== m) {
          if (s && o && f && u !== g) {
            const v = Qo.findPrevBracketInRange(s.reversedRegex, a, c, u, g);
            if (v)
              return this._toFoundBracket(o, v);
            f = !1;
          }
          n = m, s = this.languageConfigurationService.getLanguageConfiguration(n).brackets, o = this.languageConfigurationService.getLanguageConfiguration(n).bracketsNew;
        }
        const _ = !!s && !wa(l.getStandardTokenType(h));
        if (_)
          f ? u = l.getStartOffset(h) : (u = l.getStartOffset(h), g = l.getEndOffset(h));
        else if (o && s && f && u !== g) {
          const v = Qo.findPrevBracketInRange(s.reversedRegex, a, c, u, g);
          if (v)
            return this._toFoundBracket(o, v);
        }
        f = _;
      }
      if (o && s && f && u !== g) {
        const m = Qo.findPrevBracketInRange(s.reversedRegex, a, c, u, g);
        if (m)
          return this._toFoundBracket(o, m);
      }
    }
    return null;
  }
  findNextBracket(e) {
    var t;
    const i = this.textModel.validatePosition(e);
    if (this.canBuildAST)
      return this.bracketsRequested = !0, this.updateBracketPairsTree(), ((t = this.bracketPairsTree.value) === null || t === void 0 ? void 0 : t.object.getFirstBracketAfter(i)) || null;
    const n = this.textModel.getLineCount();
    let s = null, o = null, a = null;
    for (let l = i.lineNumber; l <= n; l++) {
      const d = this.textModel.tokenization.getLineTokens(l), c = d.getCount(), h = this.textModel.getLineContent(l);
      let u = 0, g = 0, f = 0;
      if (l === i.lineNumber) {
        u = d.findTokenIndexAtOffset(i.column - 1), g = i.column - 1, f = i.column - 1;
        const _ = d.getLanguageId(u);
        s !== _ && (s = _, o = this.languageConfigurationService.getLanguageConfiguration(s).brackets, a = this.languageConfigurationService.getLanguageConfiguration(s).bracketsNew);
      }
      let m = !0;
      for (; u < c; u++) {
        const _ = d.getLanguageId(u);
        if (s !== _) {
          if (a && o && m && g !== f) {
            const b = Qo.findNextBracketInRange(o.forwardRegex, l, h, g, f);
            if (b)
              return this._toFoundBracket(a, b);
            m = !1;
          }
          s = _, o = this.languageConfigurationService.getLanguageConfiguration(s).brackets, a = this.languageConfigurationService.getLanguageConfiguration(s).bracketsNew;
        }
        const v = !!o && !wa(d.getStandardTokenType(u));
        if (v)
          m || (g = d.getStartOffset(u)), f = d.getEndOffset(u);
        else if (a && o && m && g !== f) {
          const b = Qo.findNextBracketInRange(o.forwardRegex, l, h, g, f);
          if (b)
            return this._toFoundBracket(a, b);
        }
        m = v;
      }
      if (a && o && m && g !== f) {
        const _ = Qo.findNextBracketInRange(o.forwardRegex, l, h, g, f);
        if (_)
          return this._toFoundBracket(a, _);
      }
    }
    return null;
  }
  findEnclosingBrackets(e, t) {
    const i = this.textModel.validatePosition(e);
    if (this.canBuildAST) {
      const g = L.fromPositions(i), f = this.getBracketPairsInRange(L.fromPositions(i, i)).findLast((m) => m.closingBracketRange !== void 0 && m.range.strictContainsRange(g));
      return f ? [f.openingBracketRange, f.closingBracketRange] : null;
    }
    const n = ik(t), s = this.textModel.getLineCount(), o = /* @__PURE__ */ new Map();
    let a = [];
    const l = (g, f) => {
      if (!o.has(g)) {
        const m = [];
        for (let _ = 0, v = f ? f.brackets.length : 0; _ < v; _++)
          m[_] = 0;
        o.set(g, m);
      }
      a = o.get(g);
    };
    let d = 0;
    const c = (g, f, m, _, v) => {
      for (; ; ) {
        if (n && ++d % 100 === 0 && !n())
          return El.INSTANCE;
        const b = Qo.findNextBracketInRange(g.forwardRegex, f, m, _, v);
        if (!b)
          break;
        const C = m.substring(b.startColumn - 1, b.endColumn - 1).toLowerCase(), w = g.textIsBracket[C];
        if (w && (w.isOpen(C) ? a[w.index]++ : w.isClose(C) && a[w.index]--, a[w.index] === -1))
          return this._matchFoundBracket(b, w, !1, n);
        _ = b.endColumn - 1;
      }
      return null;
    };
    let h = null, u = null;
    for (let g = i.lineNumber; g <= s; g++) {
      const f = this.textModel.tokenization.getLineTokens(g), m = f.getCount(), _ = this.textModel.getLineContent(g);
      let v = 0, b = 0, C = 0;
      if (g === i.lineNumber) {
        v = f.findTokenIndexAtOffset(i.column - 1), b = i.column - 1, C = i.column - 1;
        const S = f.getLanguageId(v);
        h !== S && (h = S, u = this.languageConfigurationService.getLanguageConfiguration(h).brackets, l(h, u));
      }
      let w = !0;
      for (; v < m; v++) {
        const S = f.getLanguageId(v);
        if (h !== S) {
          if (u && w && b !== C) {
            const k = c(u, g, _, b, C);
            if (k)
              return wC(k);
            w = !1;
          }
          h = S, u = this.languageConfigurationService.getLanguageConfiguration(h).brackets, l(h, u);
        }
        const y = !!u && !wa(f.getStandardTokenType(v));
        if (y)
          w || (b = f.getStartOffset(v)), C = f.getEndOffset(v);
        else if (u && w && b !== C) {
          const k = c(u, g, _, b, C);
          if (k)
            return wC(k);
        }
        w = y;
      }
      if (u && w && b !== C) {
        const S = c(u, g, _, b, C);
        if (S)
          return wC(S);
      }
    }
    return null;
  }
  _toFoundBracket(e, t) {
    if (!t)
      return null;
    let i = this.textModel.getValueInRange(t);
    i = i.toLowerCase();
    const n = e.getBracketInfo(i);
    return n ? {
      range: t,
      bracketInfo: n
    } : null;
  }
}
function nQ(r, e) {
  return {
    object: r,
    dispose: () => e == null ? void 0 : e.dispose()
  };
}
function ik(r) {
  if (typeof r > "u")
    return () => !0;
  {
    const e = Date.now();
    return () => Date.now() - e <= r;
  }
}
class El {
  constructor() {
    this._searchCanceledBrand = void 0;
  }
}
El.INSTANCE = new El();
function wC(r) {
  return r instanceof El ? null : r;
}
class sQ extends P {
  constructor(e) {
    super(), this.textModel = e, this.colorProvider = new S2(), this.onDidChangeEmitter = new R(), this.onDidChange = this.onDidChangeEmitter.event, this.colorizationOptions = e.getOptions().bracketPairColorizationOptions, this._register(e.bracketPairs.onDidChange((t) => {
      this.onDidChangeEmitter.fire();
    }));
  }
  //#region TextModel events
  handleDidChangeOptions(e) {
    this.colorizationOptions = this.textModel.getOptions().bracketPairColorizationOptions;
  }
  //#endregion
  getDecorationsInRange(e, t, i, n) {
    return n ? [] : t === void 0 ? [] : this.colorizationOptions.enabled ? this.textModel.bracketPairs.getBracketsInRange(e, !0).map((o) => ({
      id: `bracket${o.range.toString()}-${o.nestingLevel}`,
      options: {
        description: "BracketPairColorization",
        inlineClassName: this.colorProvider.getInlineClassName(o, this.colorizationOptions.independentColorPoolPerBracketType)
      },
      ownerId: 0,
      range: o.range
    })).toArray() : [];
  }
  getAllDecorations(e, t) {
    return e === void 0 ? [] : this.colorizationOptions.enabled ? this.getDecorationsInRange(new L(1, 1, this.textModel.getLineCount(), 1), e, t) : [];
  }
}
class S2 {
  constructor() {
    this.unexpectedClosingBracketClassName = "unexpected-closing-bracket";
  }
  getInlineClassName(e, t) {
    return e.isInvalid ? this.unexpectedClosingBracketClassName : this.getInlineClassNameOfLevel(t ? e.nestingLevelOfEqualBracketType : e.nestingLevel);
  }
  getInlineClassNameOfLevel(e) {
    return `bracket-highlighting-${e % 30}`;
  }
}
Ho((r, e) => {
  const t = [
    ZV,
    YV,
    QV,
    XV,
    JV,
    e2
  ], i = new S2();
  e.addRule(`.monaco-editor .${i.unexpectedClosingBracketClassName} { color: ${r.getColor(X7)}; }`);
  const n = t.map((s) => r.getColor(s)).filter((s) => !!s).filter((s) => !s.isTransparent());
  for (let s = 0; s < 30; s++) {
    const o = n[s % n.length];
    e.addRule(`.monaco-editor .${i.getInlineClassNameOfLevel(s)} { color: ${o}; }`);
  }
});
function SC(r) {
  return r.replace(/\n/g, "\\n").replace(/\r/g, "\\r");
}
class wn {
  get oldLength() {
    return this.oldText.length;
  }
  get oldEnd() {
    return this.oldPosition + this.oldText.length;
  }
  get newLength() {
    return this.newText.length;
  }
  get newEnd() {
    return this.newPosition + this.newText.length;
  }
  constructor(e, t, i, n) {
    this.oldPosition = e, this.oldText = t, this.newPosition = i, this.newText = n;
  }
  toString() {
    return this.oldText.length === 0 ? `(insert@${this.oldPosition} "${SC(this.newText)}")` : this.newText.length === 0 ? `(delete@${this.oldPosition} "${SC(this.oldText)}")` : `(replace@${this.oldPosition} "${SC(this.oldText)}" with "${SC(this.newText)}")`;
  }
  static _writeStringSize(e) {
    return 4 + 2 * e.length;
  }
  static _writeString(e, t, i) {
    const n = t.length;
    Er(e, n, i), i += 4;
    for (let s = 0; s < n; s++)
      K6(e, t.charCodeAt(s), i), i += 2;
    return i;
  }
  static _readString(e, t) {
    const i = Ir(e, t);
    return t += 4, q6(e, t, i);
  }
  writeSize() {
    return 8 + wn._writeStringSize(this.oldText) + wn._writeStringSize(this.newText);
  }
  write(e, t) {
    return Er(e, this.oldPosition, t), t += 4, Er(e, this.newPosition, t), t += 4, t = wn._writeString(e, this.oldText, t), t = wn._writeString(e, this.newText, t), t;
  }
  static read(e, t, i) {
    const n = Ir(e, t);
    t += 4;
    const s = Ir(e, t);
    t += 4;
    const o = wn._readString(e, t);
    t += wn._writeStringSize(o);
    const a = wn._readString(e, t);
    return t += wn._writeStringSize(a), i.push(new wn(n, o, s, a)), t;
  }
}
function oQ(r, e) {
  return r === null || r.length === 0 ? e : new La(r, e).compress();
}
class La {
  constructor(e, t) {
    this._prevEdits = e, this._currEdits = t, this._result = [], this._resultLen = 0, this._prevLen = this._prevEdits.length, this._prevDeltaOffset = 0, this._currLen = this._currEdits.length, this._currDeltaOffset = 0;
  }
  compress() {
    let e = 0, t = 0, i = this._getPrev(e), n = this._getCurr(t);
    for (; e < this._prevLen || t < this._currLen; ) {
      if (i === null) {
        this._acceptCurr(n), n = this._getCurr(++t);
        continue;
      }
      if (n === null) {
        this._acceptPrev(i), i = this._getPrev(++e);
        continue;
      }
      if (n.oldEnd <= i.newPosition) {
        this._acceptCurr(n), n = this._getCurr(++t);
        continue;
      }
      if (i.newEnd <= n.oldPosition) {
        this._acceptPrev(i), i = this._getPrev(++e);
        continue;
      }
      if (n.oldPosition < i.newPosition) {
        const [d, c] = La._splitCurr(n, i.newPosition - n.oldPosition);
        this._acceptCurr(d), n = c;
        continue;
      }
      if (i.newPosition < n.oldPosition) {
        const [d, c] = La._splitPrev(i, n.oldPosition - i.newPosition);
        this._acceptPrev(d), i = c;
        continue;
      }
      let a, l;
      if (n.oldEnd === i.newEnd)
        a = i, l = n, i = this._getPrev(++e), n = this._getCurr(++t);
      else if (n.oldEnd < i.newEnd) {
        const [d, c] = La._splitPrev(i, n.oldLength);
        a = d, l = n, i = c, n = this._getCurr(++t);
      } else {
        const [d, c] = La._splitCurr(n, i.newLength);
        a = i, l = d, i = this._getPrev(++e), n = c;
      }
      this._result[this._resultLen++] = new wn(a.oldPosition, a.oldText, l.newPosition, l.newText), this._prevDeltaOffset += a.newLength - a.oldLength, this._currDeltaOffset += l.newLength - l.oldLength;
    }
    const s = La._merge(this._result);
    return La._removeNoOps(s);
  }
  _acceptCurr(e) {
    this._result[this._resultLen++] = La._rebaseCurr(this._prevDeltaOffset, e), this._currDeltaOffset += e.newLength - e.oldLength;
  }
  _getCurr(e) {
    return e < this._currLen ? this._currEdits[e] : null;
  }
  _acceptPrev(e) {
    this._result[this._resultLen++] = La._rebasePrev(this._currDeltaOffset, e), this._prevDeltaOffset += e.newLength - e.oldLength;
  }
  _getPrev(e) {
    return e < this._prevLen ? this._prevEdits[e] : null;
  }
  static _rebaseCurr(e, t) {
    return new wn(t.oldPosition - e, t.oldText, t.newPosition, t.newText);
  }
  static _rebasePrev(e, t) {
    return new wn(t.oldPosition, t.oldText, t.newPosition + e, t.newText);
  }
  static _splitPrev(e, t) {
    const i = e.newText.substr(0, t), n = e.newText.substr(t);
    return [
      new wn(e.oldPosition, e.oldText, e.newPosition, i),
      new wn(e.oldEnd, "", e.newPosition + t, n)
    ];
  }
  static _splitCurr(e, t) {
    const i = e.oldText.substr(0, t), n = e.oldText.substr(t);
    return [
      new wn(e.oldPosition, i, e.newPosition, e.newText),
      new wn(e.oldPosition + t, n, e.newEnd, "")
    ];
  }
  static _merge(e) {
    if (e.length === 0)
      return e;
    const t = [];
    let i = 0, n = e[0];
    for (let s = 1; s < e.length; s++) {
      const o = e[s];
      n.oldEnd === o.oldPosition ? n = new wn(n.oldPosition, n.oldText + o.oldText, n.newPosition, n.newText + o.newText) : (t[i++] = n, n = o);
    }
    return t[i++] = n, t;
  }
  static _removeNoOps(e) {
    if (e.length === 0)
      return e;
    const t = [];
    let i = 0;
    for (let n = 0; n < e.length; n++) {
      const s = e[n];
      s.oldText !== s.newText && (t[i++] = s);
    }
    return t;
  }
}
function Td(r) {
  return r === 47 || r === 92;
}
function y2(r) {
  return r.replace(/[\\/]/g, ir.sep);
}
function rQ(r) {
  return r.indexOf("/") === -1 && (r = y2(r)), /^[a-zA-Z]:(\/|$)/.test(r) && (r = "/" + r), r;
}
function zP(r, e = ir.sep) {
  if (!r)
    return "";
  const t = r.length, i = r.charCodeAt(0);
  if (Td(i)) {
    if (Td(r.charCodeAt(1)) && !Td(r.charCodeAt(2))) {
      let s = 3;
      const o = s;
      for (; s < t && !Td(r.charCodeAt(s)); s++)
        ;
      if (o !== s && !Td(r.charCodeAt(s + 1))) {
        for (s += 1; s < t; s++)
          if (Td(r.charCodeAt(s)))
            return r.slice(0, s + 1).replace(/[\\/]/g, e);
      }
    }
    return e;
  } else if (L2(i) && r.charCodeAt(1) === 58)
    return Td(r.charCodeAt(2)) ? r.slice(0, 2) + e : r.slice(0, 2);
  let n = r.indexOf("://");
  if (n !== -1) {
    for (n += 3; n < t; n++)
      if (Td(r.charCodeAt(n)))
        return r.slice(0, n + 1);
  }
  return "";
}
function aI(r, e, t, i = $r) {
  if (r === e)
    return !0;
  if (!r || !e || e.length > r.length)
    return !1;
  if (t) {
    if (!BN(r, e))
      return !1;
    if (e.length === r.length)
      return !0;
    let s = e.length;
    return e.charAt(e.length - 1) === i && s--, r.charAt(s) === i;
  }
  return e.charAt(e.length - 1) !== i && (e += i), r.indexOf(e) === 0;
}
function L2(r) {
  return r >= 65 && r <= 90 || r >= 97 && r <= 122;
}
function aQ(r, e = Ks) {
  return e ? L2(r.charCodeAt(0)) && r.charCodeAt(1) === 58 : !1;
}
function Sa(r) {
  return v5(r, !0);
}
class lQ {
  constructor(e) {
    this._ignorePathCasing = e;
  }
  compare(e, t, i = !1) {
    return e === t ? 0 : M_(this.getComparisonKey(e, i), this.getComparisonKey(t, i));
  }
  isEqual(e, t, i = !1) {
    return e === t ? !0 : !e || !t ? !1 : this.getComparisonKey(e, i) === this.getComparisonKey(t, i);
  }
  getComparisonKey(e, t = !1) {
    return e.with({
      path: this._ignorePathCasing(e) ? e.path.toLowerCase() : void 0,
      fragment: t ? null : void 0
    }).toString();
  }
  isEqualOrParent(e, t, i = !1) {
    if (e.scheme === t.scheme) {
      if (e.scheme === Ne.file)
        return aI(Sa(e), Sa(t), this._ignorePathCasing(e)) && e.query === t.query && (i || e.fragment === t.fragment);
      if ($P(e.authority, t.authority))
        return aI(e.path, t.path, this._ignorePathCasing(e), "/") && e.query === t.query && (i || e.fragment === t.fragment);
    }
    return !1;
  }
  // --- path math
  joinPath(e, ...t) {
    return Ee.joinPath(e, ...t);
  }
  basenameOrAuthority(e) {
    return Fo(e) || e.authority;
  }
  basename(e) {
    return ir.basename(e.path);
  }
  extname(e) {
    return ir.extname(e.path);
  }
  dirname(e) {
    if (e.path.length === 0)
      return e;
    let t;
    return e.scheme === Ne.file ? t = Ee.file(QB(Sa(e))).path : (t = ir.dirname(e.path), e.authority && t.length && t.charCodeAt(0) !== 47 && (console.error(`dirname("${e.toString})) resulted in a relative path`), t = "/")), e.with({
      path: t
    });
  }
  normalizePath(e) {
    if (!e.path.length)
      return e;
    let t;
    return e.scheme === Ne.file ? t = Ee.file(XB(Sa(e))).path : t = ir.normalize(e.path), e.with({
      path: t
    });
  }
  relativePath(e, t) {
    if (e.scheme !== t.scheme || !$P(e.authority, t.authority))
      return;
    if (e.scheme === Ne.file) {
      const s = b5(Sa(e), Sa(t));
      return Ks ? y2(s) : s;
    }
    let i = e.path || "/";
    const n = t.path || "/";
    if (this._ignorePathCasing(e)) {
      let s = 0;
      for (const o = Math.min(i.length, n.length); s < o && !(i.charCodeAt(s) !== n.charCodeAt(s) && i.charAt(s).toLowerCase() !== n.charAt(s).toLowerCase()); s++)
        ;
      i = n.substr(0, s) + i.substr(s);
    }
    return ir.relative(i, n);
  }
  resolvePath(e, t) {
    if (e.scheme === Ne.file) {
      const i = Ee.file(C5(Sa(e), t));
      return e.with({
        authority: i.authority,
        path: i.path
      });
    }
    return t = rQ(t), e.with({
      path: ir.resolve(e.path, t)
    });
  }
  // --- misc
  isAbsolutePath(e) {
    return !!e.path && e.path[0] === "/";
  }
  isEqualAuthority(e, t) {
    return e === t || e !== void 0 && t !== void 0 && Wg(e, t);
  }
  hasTrailingPathSeparator(e, t = $r) {
    if (e.scheme === Ne.file) {
      const i = Sa(e);
      return i.length > zP(i).length && i[i.length - 1] === t;
    } else {
      const i = e.path;
      return i.length > 1 && i.charCodeAt(i.length - 1) === 47 && !/^[a-zA-Z]:(\/$|\\$)/.test(e.fsPath);
    }
  }
  removeTrailingPathSeparator(e, t = $r) {
    return KP(e, t) ? e.with({ path: e.path.substr(0, e.path.length - 1) }) : e;
  }
  addTrailingPathSeparator(e, t = $r) {
    let i = !1;
    if (e.scheme === Ne.file) {
      const n = Sa(e);
      i = n !== void 0 && n.length === zP(n).length && n[n.length - 1] === t;
    } else {
      t = "/";
      const n = e.path;
      i = n.length === 1 && n.charCodeAt(n.length - 1) === 47;
    }
    return !i && !KP(e, t) ? e.with({ path: e.path + "/" }) : e;
  }
}
const Zt = new lQ(() => !1), B1 = Zt.isEqual.bind(Zt);
Zt.isEqualOrParent.bind(Zt);
Zt.getComparisonKey.bind(Zt);
const dQ = Zt.basenameOrAuthority.bind(Zt), Fo = Zt.basename.bind(Zt), cQ = Zt.extname.bind(Zt), P0 = Zt.dirname.bind(Zt), hQ = Zt.joinPath.bind(Zt), uQ = Zt.normalizePath.bind(Zt), gQ = Zt.relativePath.bind(Zt), UP = Zt.resolvePath.bind(Zt);
Zt.isAbsolutePath.bind(Zt);
const $P = Zt.isEqualAuthority.bind(Zt), KP = Zt.hasTrailingPathSeparator.bind(Zt);
Zt.removeTrailingPathSeparator.bind(Zt);
Zt.addTrailingPathSeparator.bind(Zt);
var Fc;
(function(r) {
  r.META_DATA_LABEL = "label", r.META_DATA_DESCRIPTION = "description", r.META_DATA_SIZE = "size", r.META_DATA_MIME = "mime";
  function e(t) {
    const i = /* @__PURE__ */ new Map();
    t.path.substring(t.path.indexOf(";") + 1, t.path.lastIndexOf(";")).split(";").forEach((o) => {
      const [a, l] = o.split(":");
      a && l && i.set(a, l);
    });
    const s = t.path.substring(0, t.path.indexOf(";"));
    return s && i.set(r.META_DATA_MIME, s), i;
  }
  r.parseMetaData = e;
})(Fc || (Fc = {}));
function _g(r) {
  return r.toString();
}
class en {
  static create(e, t) {
    const i = e.getAlternativeVersionId(), n = lI(e);
    return new en(i, i, n, n, t, t, []);
  }
  constructor(e, t, i, n, s, o, a) {
    this.beforeVersionId = e, this.afterVersionId = t, this.beforeEOL = i, this.afterEOL = n, this.beforeCursorState = s, this.afterCursorState = o, this.changes = a;
  }
  append(e, t, i, n, s) {
    t.length > 0 && (this.changes = oQ(this.changes, t)), this.afterEOL = i, this.afterVersionId = n, this.afterCursorState = s;
  }
  static _writeSelectionsSize(e) {
    return 4 + 4 * 4 * (e ? e.length : 0);
  }
  static _writeSelections(e, t, i) {
    if (Er(e, t ? t.length : 0, i), i += 4, t)
      for (const n of t)
        Er(e, n.selectionStartLineNumber, i), i += 4, Er(e, n.selectionStartColumn, i), i += 4, Er(e, n.positionLineNumber, i), i += 4, Er(e, n.positionColumn, i), i += 4;
    return i;
  }
  static _readSelections(e, t, i) {
    const n = Ir(e, t);
    t += 4;
    for (let s = 0; s < n; s++) {
      const o = Ir(e, t);
      t += 4;
      const a = Ir(e, t);
      t += 4;
      const l = Ir(e, t);
      t += 4;
      const d = Ir(e, t);
      t += 4, i.push(new ge(o, a, l, d));
    }
    return t;
  }
  serialize() {
    let e = 10 + en._writeSelectionsSize(this.beforeCursorState) + en._writeSelectionsSize(this.afterCursorState) + 4;
    for (const n of this.changes)
      e += n.writeSize();
    const t = new Uint8Array(e);
    let i = 0;
    Er(t, this.beforeVersionId, i), i += 4, Er(t, this.afterVersionId, i), i += 4, FA(t, this.beforeEOL, i), i += 1, FA(t, this.afterEOL, i), i += 1, i = en._writeSelections(t, this.beforeCursorState, i), i = en._writeSelections(t, this.afterCursorState, i), Er(t, this.changes.length, i), i += 4;
    for (const n of this.changes)
      i = n.write(t, i);
    return t.buffer;
  }
  static deserialize(e) {
    const t = new Uint8Array(e);
    let i = 0;
    const n = Ir(t, i);
    i += 4;
    const s = Ir(t, i);
    i += 4;
    const o = OA(t, i);
    i += 1;
    const a = OA(t, i);
    i += 1;
    const l = [];
    i = en._readSelections(t, i, l);
    const d = [];
    i = en._readSelections(t, i, d);
    const c = Ir(t, i);
    i += 4;
    const h = [];
    for (let u = 0; u < c; u++)
      i = wn.read(t, i, h);
    return new en(n, s, o, a, l, d, h);
  }
}
class D2 {
  get type() {
    return 0;
  }
  get resource() {
    return Ee.isUri(this.model) ? this.model : this.model.uri;
  }
  constructor(e, t, i, n) {
    this.label = e, this.code = t, this.model = i, this._data = en.create(i, n);
  }
  toString() {
    return (this._data instanceof en ? this._data : en.deserialize(this._data)).changes.map((t) => t.toString()).join(", ");
  }
  matchesResource(e) {
    return (Ee.isUri(this.model) ? this.model : this.model.uri).toString() === e.toString();
  }
  setModel(e) {
    this.model = e;
  }
  canAppend(e) {
    return this.model === e && this._data instanceof en;
  }
  append(e, t, i, n, s) {
    this._data instanceof en && this._data.append(e, t, i, n, s);
  }
  close() {
    this._data instanceof en && (this._data = this._data.serialize());
  }
  open() {
    this._data instanceof en || (this._data = en.deserialize(this._data));
  }
  undo() {
    if (Ee.isUri(this.model))
      throw new Error("Invalid SingleModelEditStackElement");
    this._data instanceof en && (this._data = this._data.serialize());
    const e = en.deserialize(this._data);
    this.model._applyUndo(e.changes, e.beforeEOL, e.beforeVersionId, e.beforeCursorState);
  }
  redo() {
    if (Ee.isUri(this.model))
      throw new Error("Invalid SingleModelEditStackElement");
    this._data instanceof en && (this._data = this._data.serialize());
    const e = en.deserialize(this._data);
    this.model._applyRedo(e.changes, e.afterEOL, e.afterVersionId, e.afterCursorState);
  }
  heapSize() {
    return this._data instanceof en && (this._data = this._data.serialize()), this._data.byteLength + 168;
  }
}
class fQ {
  get resources() {
    return this._editStackElementsArr.map((e) => e.resource);
  }
  constructor(e, t, i) {
    this.label = e, this.code = t, this.type = 1, this._isOpen = !0, this._editStackElementsArr = i.slice(0), this._editStackElementsMap = /* @__PURE__ */ new Map();
    for (const n of this._editStackElementsArr) {
      const s = _g(n.resource);
      this._editStackElementsMap.set(s, n);
    }
    this._delegate = null;
  }
  prepareUndoRedo() {
    if (this._delegate)
      return this._delegate.prepareUndoRedo(this);
  }
  matchesResource(e) {
    const t = _g(e);
    return this._editStackElementsMap.has(t);
  }
  setModel(e) {
    const t = _g(Ee.isUri(e) ? e : e.uri);
    this._editStackElementsMap.has(t) && this._editStackElementsMap.get(t).setModel(e);
  }
  canAppend(e) {
    if (!this._isOpen)
      return !1;
    const t = _g(e.uri);
    return this._editStackElementsMap.has(t) ? this._editStackElementsMap.get(t).canAppend(e) : !1;
  }
  append(e, t, i, n, s) {
    const o = _g(e.uri);
    this._editStackElementsMap.get(o).append(e, t, i, n, s);
  }
  close() {
    this._isOpen = !1;
  }
  open() {
  }
  undo() {
    this._isOpen = !1;
    for (const e of this._editStackElementsArr)
      e.undo();
  }
  redo() {
    for (const e of this._editStackElementsArr)
      e.redo();
  }
  heapSize(e) {
    const t = _g(e);
    return this._editStackElementsMap.has(t) ? this._editStackElementsMap.get(t).heapSize() : 0;
  }
  split() {
    return this._editStackElementsArr;
  }
  toString() {
    const e = [];
    for (const t of this._editStackElementsArr)
      e.push(`${Fo(t.resource)}: ${t}`);
    return `{${e.join(", ")}}`;
  }
}
function lI(r) {
  return r.getEOL() === `
` ? 0 : 1;
}
function Tl(r) {
  return r ? r instanceof D2 || r instanceof fQ : !1;
}
class H1 {
  constructor(e, t) {
    this._model = e, this._undoRedoService = t;
  }
  pushStackElement() {
    const e = this._undoRedoService.getLastElement(this._model.uri);
    Tl(e) && e.close();
  }
  popStackElement() {
    const e = this._undoRedoService.getLastElement(this._model.uri);
    Tl(e) && e.open();
  }
  clear() {
    this._undoRedoService.removeElements(this._model.uri);
  }
  _getOrCreateEditStackElement(e, t) {
    const i = this._undoRedoService.getLastElement(this._model.uri);
    if (Tl(i) && i.canAppend(this._model))
      return i;
    const n = new D2(p("edit", "Typing"), "undoredo.textBufferEdit", this._model, e);
    return this._undoRedoService.pushElement(n, t), n;
  }
  pushEOL(e) {
    const t = this._getOrCreateEditStackElement(null, void 0);
    this._model.setEOL(e), t.append(this._model, [], lI(this._model), this._model.getAlternativeVersionId(), null);
  }
  pushEditOperation(e, t, i, n) {
    const s = this._getOrCreateEditStackElement(e, n), o = this._model.applyEdits(t, !0), a = H1._computeCursorState(i, o), l = o.map((d, c) => ({ index: c, textChange: d.textChange }));
    return l.sort((d, c) => d.textChange.oldPosition === c.textChange.oldPosition ? d.index - c.index : d.textChange.oldPosition - c.textChange.oldPosition), s.append(this._model, l.map((d) => d.textChange), lI(this._model), this._model.getAlternativeVersionId(), a), a;
  }
  static _computeCursorState(e, t) {
    try {
      return e ? e(t) : null;
    } catch (i) {
      return He(i), null;
    }
  }
}
class pQ {
  constructor() {
    this.spacesDiff = 0, this.looksLikeAlignment = !1;
  }
}
function mQ(r, e, t, i, n) {
  n.spacesDiff = 0, n.looksLikeAlignment = !1;
  let s;
  for (s = 0; s < e && s < i; s++) {
    const u = r.charCodeAt(s), g = t.charCodeAt(s);
    if (u !== g)
      break;
  }
  let o = 0, a = 0;
  for (let u = s; u < e; u++)
    r.charCodeAt(u) === 32 ? o++ : a++;
  let l = 0, d = 0;
  for (let u = s; u < i; u++)
    t.charCodeAt(u) === 32 ? l++ : d++;
  if (o > 0 && a > 0 || l > 0 && d > 0)
    return;
  const c = Math.abs(a - d), h = Math.abs(o - l);
  if (c === 0) {
    n.spacesDiff = h, h > 0 && 0 <= l - 1 && l - 1 < r.length && l < t.length && t.charCodeAt(l) !== 32 && r.charCodeAt(l - 1) === 32 && r.charCodeAt(r.length - 1) === 44 && (n.looksLikeAlignment = !0);
    return;
  }
  if (h % c === 0) {
    n.spacesDiff = h / c;
    return;
  }
}
function jP(r, e, t) {
  const i = Math.min(r.getLineCount(), 1e4);
  let n = 0, s = 0, o = "", a = 0;
  const l = [2, 4, 6, 8, 3, 5, 7], d = 8, c = [0, 0, 0, 0, 0, 0, 0, 0, 0], h = new pQ();
  for (let f = 1; f <= i; f++) {
    const m = r.getLineLength(f), _ = r.getLineContent(f), v = m <= 65536;
    let b = !1, C = 0, w = 0, S = 0;
    for (let k = 0, E = m; k < E; k++) {
      const N = v ? _.charCodeAt(k) : r.getLineCharCode(f, k);
      if (N === 9)
        S++;
      else if (N === 32)
        w++;
      else {
        b = !0, C = k;
        break;
      }
    }
    if (!b || (S > 0 ? n++ : w > 1 && s++, mQ(o, a, _, C, h), h.looksLikeAlignment && !(t && e === h.spacesDiff)))
      continue;
    const y = h.spacesDiff;
    y <= d && c[y]++, o = _, a = C;
  }
  let u = t;
  n !== s && (u = n < s);
  let g = e;
  if (u) {
    let f = u ? 0 : 0.1 * i;
    l.forEach((m) => {
      const _ = c[m];
      _ > f && (f = _, g = m);
    }), g === 4 && c[4] > 0 && c[2] > 0 && c[2] >= c[4] / 2 && (g = 2);
  }
  return {
    insertSpaces: u,
    tabSize: g
  };
}
function ms(r) {
  return (r.metadata & 1) >>> 0;
}
function Kt(r, e) {
  r.metadata = r.metadata & 254 | e << 0;
}
function Dn(r) {
  return (r.metadata & 2) >>> 1 === 1;
}
function Vt(r, e) {
  r.metadata = r.metadata & 253 | (e ? 1 : 0) << 1;
}
function k2(r) {
  return (r.metadata & 4) >>> 2 === 1;
}
function qP(r, e) {
  r.metadata = r.metadata & 251 | (e ? 1 : 0) << 2;
}
function x2(r) {
  return (r.metadata & 64) >>> 6 === 1;
}
function GP(r, e) {
  r.metadata = r.metadata & 191 | (e ? 1 : 0) << 6;
}
function _Q(r) {
  return (r.metadata & 24) >>> 3;
}
function ZP(r, e) {
  r.metadata = r.metadata & 231 | e << 3;
}
function vQ(r) {
  return (r.metadata & 32) >>> 5 === 1;
}
function YP(r, e) {
  r.metadata = r.metadata & 223 | (e ? 1 : 0) << 5;
}
class I2 {
  constructor(e, t, i) {
    this.metadata = 0, this.parent = this, this.left = this, this.right = this, Kt(
      this,
      1
      /* NodeColor.Red */
    ), this.start = t, this.end = i, this.delta = 0, this.maxEnd = i, this.id = e, this.ownerId = 0, this.options = null, qP(this, !1), GP(this, !1), ZP(
      this,
      1
      /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */
    ), YP(this, !1), this.cachedVersionId = 0, this.cachedAbsoluteStart = t, this.cachedAbsoluteEnd = i, this.range = null, Vt(this, !1);
  }
  reset(e, t, i, n) {
    this.start = t, this.end = i, this.maxEnd = i, this.cachedVersionId = e, this.cachedAbsoluteStart = t, this.cachedAbsoluteEnd = i, this.range = n;
  }
  setOptions(e) {
    this.options = e;
    const t = this.options.className;
    qP(this, t === "squiggly-error" || t === "squiggly-warning" || t === "squiggly-info"), GP(this, this.options.glyphMarginClassName !== null), ZP(this, this.options.stickiness), YP(this, this.options.collapseOnReplaceEdit);
  }
  setCachedOffsets(e, t, i) {
    this.cachedVersionId !== i && (this.range = null), this.cachedVersionId = i, this.cachedAbsoluteStart = e, this.cachedAbsoluteEnd = t;
  }
  detach() {
    this.parent = null, this.left = null, this.right = null;
  }
}
const Qe = new I2(null, 0, 0);
Qe.parent = Qe;
Qe.left = Qe;
Qe.right = Qe;
Kt(
  Qe,
  0
  /* NodeColor.Black */
);
class nk {
  constructor() {
    this.root = Qe, this.requestNormalizeDelta = !1;
  }
  intervalSearch(e, t, i, n, s, o) {
    return this.root === Qe ? [] : kQ(this, e, t, i, n, s, o);
  }
  search(e, t, i, n) {
    return this.root === Qe ? [] : DQ(this, e, t, i, n);
  }
  /**
   * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!
   */
  collectNodesFromOwner(e) {
    return yQ(this, e);
  }
  /**
   * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!
   */
  collectNodesPostOrder() {
    return LQ(this);
  }
  insert(e) {
    QP(this, e), this._normalizeDeltaIfNecessary();
  }
  delete(e) {
    XP(this, e), this._normalizeDeltaIfNecessary();
  }
  resolveNode(e, t) {
    const i = e;
    let n = 0;
    for (; e !== this.root; )
      e === e.parent.right && (n += e.parent.delta), e = e.parent;
    const s = i.start + n, o = i.end + n;
    i.setCachedOffsets(s, o, t);
  }
  acceptReplace(e, t, i, n) {
    const s = wQ(this, e, e + t);
    for (let o = 0, a = s.length; o < a; o++) {
      const l = s[o];
      XP(this, l);
    }
    this._normalizeDeltaIfNecessary(), SQ(this, e, e + t, i), this._normalizeDeltaIfNecessary();
    for (let o = 0, a = s.length; o < a; o++) {
      const l = s[o];
      l.start = l.cachedAbsoluteStart, l.end = l.cachedAbsoluteEnd, CQ(l, e, e + t, i, n), l.maxEnd = l.end, QP(this, l);
    }
    this._normalizeDeltaIfNecessary();
  }
  _normalizeDeltaIfNecessary() {
    this.requestNormalizeDelta && (this.requestNormalizeDelta = !1, bQ(this));
  }
}
function bQ(r) {
  let e = r.root, t = 0;
  for (; e !== Qe; ) {
    if (e.left !== Qe && !Dn(e.left)) {
      e = e.left;
      continue;
    }
    if (e.right !== Qe && !Dn(e.right)) {
      t += e.delta, e = e.right;
      continue;
    }
    e.start = t + e.start, e.end = t + e.end, e.delta = 0, Wc(e), Vt(e, !0), Vt(e.left, !1), Vt(e.right, !1), e === e.parent.right && (t -= e.parent.delta), e = e.parent;
  }
  Vt(r.root, !1);
}
function vg(r, e, t, i) {
  return r < t ? !0 : r > t || i === 1 ? !1 : i === 2 ? !0 : e;
}
function CQ(r, e, t, i, n) {
  const s = _Q(r), o = s === 0 || s === 2, a = s === 1 || s === 2, l = t - e, d = i, c = Math.min(l, d), h = r.start;
  let u = !1;
  const g = r.end;
  let f = !1;
  e <= h && g <= t && vQ(r) && (r.start = e, u = !0, r.end = e, f = !0);
  {
    const _ = n ? 1 : l > 0 ? 2 : 0;
    !u && vg(h, o, e, _) && (u = !0), !f && vg(g, a, e, _) && (f = !0);
  }
  if (c > 0 && !n) {
    const _ = l > d ? 2 : 0;
    !u && vg(h, o, e + c, _) && (u = !0), !f && vg(g, a, e + c, _) && (f = !0);
  }
  {
    const _ = n ? 1 : 0;
    !u && vg(h, o, t, _) && (r.start = e + d, u = !0), !f && vg(g, a, t, _) && (r.end = e + d, f = !0);
  }
  const m = d - l;
  u || (r.start = Math.max(0, h + m)), f || (r.end = Math.max(0, g + m)), r.start > r.end && (r.end = r.start);
}
function wQ(r, e, t) {
  let i = r.root, n = 0, s = 0, o = 0, a = 0;
  const l = [];
  let d = 0;
  for (; i !== Qe; ) {
    if (Dn(i)) {
      Vt(i.left, !1), Vt(i.right, !1), i === i.parent.right && (n -= i.parent.delta), i = i.parent;
      continue;
    }
    if (!Dn(i.left)) {
      if (s = n + i.maxEnd, s < e) {
        Vt(i, !0);
        continue;
      }
      if (i.left !== Qe) {
        i = i.left;
        continue;
      }
    }
    if (o = n + i.start, o > t) {
      Vt(i, !0);
      continue;
    }
    if (a = n + i.end, a >= e && (i.setCachedOffsets(o, a, 0), l[d++] = i), Vt(i, !0), i.right !== Qe && !Dn(i.right)) {
      n += i.delta, i = i.right;
      continue;
    }
  }
  return Vt(r.root, !1), l;
}
function SQ(r, e, t, i) {
  let n = r.root, s = 0, o = 0, a = 0;
  const l = i - (t - e);
  for (; n !== Qe; ) {
    if (Dn(n)) {
      Vt(n.left, !1), Vt(n.right, !1), n === n.parent.right && (s -= n.parent.delta), Wc(n), n = n.parent;
      continue;
    }
    if (!Dn(n.left)) {
      if (o = s + n.maxEnd, o < e) {
        Vt(n, !0);
        continue;
      }
      if (n.left !== Qe) {
        n = n.left;
        continue;
      }
    }
    if (a = s + n.start, a > t) {
      n.start += l, n.end += l, n.delta += l, (n.delta < -1073741824 || n.delta > 1073741824) && (r.requestNormalizeDelta = !0), Vt(n, !0);
      continue;
    }
    if (Vt(n, !0), n.right !== Qe && !Dn(n.right)) {
      s += n.delta, n = n.right;
      continue;
    }
  }
  Vt(r.root, !1);
}
function yQ(r, e) {
  let t = r.root;
  const i = [];
  let n = 0;
  for (; t !== Qe; ) {
    if (Dn(t)) {
      Vt(t.left, !1), Vt(t.right, !1), t = t.parent;
      continue;
    }
    if (t.left !== Qe && !Dn(t.left)) {
      t = t.left;
      continue;
    }
    if (t.ownerId === e && (i[n++] = t), Vt(t, !0), t.right !== Qe && !Dn(t.right)) {
      t = t.right;
      continue;
    }
  }
  return Vt(r.root, !1), i;
}
function LQ(r) {
  let e = r.root;
  const t = [];
  let i = 0;
  for (; e !== Qe; ) {
    if (Dn(e)) {
      Vt(e.left, !1), Vt(e.right, !1), e = e.parent;
      continue;
    }
    if (e.left !== Qe && !Dn(e.left)) {
      e = e.left;
      continue;
    }
    if (e.right !== Qe && !Dn(e.right)) {
      e = e.right;
      continue;
    }
    t[i++] = e, Vt(e, !0);
  }
  return Vt(r.root, !1), t;
}
function DQ(r, e, t, i, n) {
  let s = r.root, o = 0, a = 0, l = 0;
  const d = [];
  let c = 0;
  for (; s !== Qe; ) {
    if (Dn(s)) {
      Vt(s.left, !1), Vt(s.right, !1), s === s.parent.right && (o -= s.parent.delta), s = s.parent;
      continue;
    }
    if (s.left !== Qe && !Dn(s.left)) {
      s = s.left;
      continue;
    }
    a = o + s.start, l = o + s.end, s.setCachedOffsets(a, l, i);
    let h = !0;
    if (e && s.ownerId && s.ownerId !== e && (h = !1), t && k2(s) && (h = !1), n && !x2(s) && (h = !1), h && (d[c++] = s), Vt(s, !0), s.right !== Qe && !Dn(s.right)) {
      o += s.delta, s = s.right;
      continue;
    }
  }
  return Vt(r.root, !1), d;
}
function kQ(r, e, t, i, n, s, o) {
  let a = r.root, l = 0, d = 0, c = 0, h = 0;
  const u = [];
  let g = 0;
  for (; a !== Qe; ) {
    if (Dn(a)) {
      Vt(a.left, !1), Vt(a.right, !1), a === a.parent.right && (l -= a.parent.delta), a = a.parent;
      continue;
    }
    if (!Dn(a.left)) {
      if (d = l + a.maxEnd, d < e) {
        Vt(a, !0);
        continue;
      }
      if (a.left !== Qe) {
        a = a.left;
        continue;
      }
    }
    if (c = l + a.start, c > t) {
      Vt(a, !0);
      continue;
    }
    if (h = l + a.end, h >= e) {
      a.setCachedOffsets(c, h, s);
      let f = !0;
      i && a.ownerId && a.ownerId !== i && (f = !1), n && k2(a) && (f = !1), o && !x2(a) && (f = !1), f && (u[g++] = a);
    }
    if (Vt(a, !0), a.right !== Qe && !Dn(a.right)) {
      l += a.delta, a = a.right;
      continue;
    }
  }
  return Vt(r.root, !1), u;
}
function QP(r, e) {
  if (r.root === Qe)
    return e.parent = Qe, e.left = Qe, e.right = Qe, Kt(
      e,
      0
      /* NodeColor.Black */
    ), r.root = e, r.root;
  xQ(r, e), Od(e.parent);
  let t = e;
  for (; t !== r.root && ms(t.parent) === 1; )
    if (t.parent === t.parent.parent.left) {
      const i = t.parent.parent.right;
      ms(i) === 1 ? (Kt(
        t.parent,
        0
        /* NodeColor.Black */
      ), Kt(
        i,
        0
        /* NodeColor.Black */
      ), Kt(
        t.parent.parent,
        1
        /* NodeColor.Red */
      ), t = t.parent.parent) : (t === t.parent.right && (t = t.parent, l_(r, t)), Kt(
        t.parent,
        0
        /* NodeColor.Black */
      ), Kt(
        t.parent.parent,
        1
        /* NodeColor.Red */
      ), d_(r, t.parent.parent));
    } else {
      const i = t.parent.parent.left;
      ms(i) === 1 ? (Kt(
        t.parent,
        0
        /* NodeColor.Black */
      ), Kt(
        i,
        0
        /* NodeColor.Black */
      ), Kt(
        t.parent.parent,
        1
        /* NodeColor.Red */
      ), t = t.parent.parent) : (t === t.parent.left && (t = t.parent, d_(r, t)), Kt(
        t.parent,
        0
        /* NodeColor.Black */
      ), Kt(
        t.parent.parent,
        1
        /* NodeColor.Red */
      ), l_(r, t.parent.parent));
    }
  return Kt(
    r.root,
    0
    /* NodeColor.Black */
  ), e;
}
function xQ(r, e) {
  let t = 0, i = r.root;
  const n = e.start, s = e.end;
  for (; ; )
    if (EQ(n, s, i.start + t, i.end + t) < 0)
      if (i.left === Qe) {
        e.start -= t, e.end -= t, e.maxEnd -= t, i.left = e;
        break;
      } else
        i = i.left;
    else if (i.right === Qe) {
      e.start -= t + i.delta, e.end -= t + i.delta, e.maxEnd -= t + i.delta, i.right = e;
      break;
    } else
      t += i.delta, i = i.right;
  e.parent = i, e.left = Qe, e.right = Qe, Kt(
    e,
    1
    /* NodeColor.Red */
  );
}
function XP(r, e) {
  let t, i;
  if (e.left === Qe ? (t = e.right, i = e, t.delta += e.delta, (t.delta < -1073741824 || t.delta > 1073741824) && (r.requestNormalizeDelta = !0), t.start += e.delta, t.end += e.delta) : e.right === Qe ? (t = e.left, i = e) : (i = IQ(e.right), t = i.right, t.start += i.delta, t.end += i.delta, t.delta += i.delta, (t.delta < -1073741824 || t.delta > 1073741824) && (r.requestNormalizeDelta = !0), i.start += e.delta, i.end += e.delta, i.delta = e.delta, (i.delta < -1073741824 || i.delta > 1073741824) && (r.requestNormalizeDelta = !0)), i === r.root) {
    r.root = t, Kt(
      t,
      0
      /* NodeColor.Black */
    ), e.detach(), sk(), Wc(t), r.root.parent = Qe;
    return;
  }
  const n = ms(i) === 1;
  if (i === i.parent.left ? i.parent.left = t : i.parent.right = t, i === e ? t.parent = i.parent : (i.parent === e ? t.parent = i : t.parent = i.parent, i.left = e.left, i.right = e.right, i.parent = e.parent, Kt(i, ms(e)), e === r.root ? r.root = i : e === e.parent.left ? e.parent.left = i : e.parent.right = i, i.left !== Qe && (i.left.parent = i), i.right !== Qe && (i.right.parent = i)), e.detach(), n) {
    Od(t.parent), i !== e && (Od(i), Od(i.parent)), sk();
    return;
  }
  Od(t), Od(t.parent), i !== e && (Od(i), Od(i.parent));
  let s;
  for (; t !== r.root && ms(t) === 0; )
    t === t.parent.left ? (s = t.parent.right, ms(s) === 1 && (Kt(
      s,
      0
      /* NodeColor.Black */
    ), Kt(
      t.parent,
      1
      /* NodeColor.Red */
    ), l_(r, t.parent), s = t.parent.right), ms(s.left) === 0 && ms(s.right) === 0 ? (Kt(
      s,
      1
      /* NodeColor.Red */
    ), t = t.parent) : (ms(s.right) === 0 && (Kt(
      s.left,
      0
      /* NodeColor.Black */
    ), Kt(
      s,
      1
      /* NodeColor.Red */
    ), d_(r, s), s = t.parent.right), Kt(s, ms(t.parent)), Kt(
      t.parent,
      0
      /* NodeColor.Black */
    ), Kt(
      s.right,
      0
      /* NodeColor.Black */
    ), l_(r, t.parent), t = r.root)) : (s = t.parent.left, ms(s) === 1 && (Kt(
      s,
      0
      /* NodeColor.Black */
    ), Kt(
      t.parent,
      1
      /* NodeColor.Red */
    ), d_(r, t.parent), s = t.parent.left), ms(s.left) === 0 && ms(s.right) === 0 ? (Kt(
      s,
      1
      /* NodeColor.Red */
    ), t = t.parent) : (ms(s.left) === 0 && (Kt(
      s.right,
      0
      /* NodeColor.Black */
    ), Kt(
      s,
      1
      /* NodeColor.Red */
    ), l_(r, s), s = t.parent.left), Kt(s, ms(t.parent)), Kt(
      t.parent,
      0
      /* NodeColor.Black */
    ), Kt(
      s.left,
      0
      /* NodeColor.Black */
    ), d_(r, t.parent), t = r.root));
  Kt(
    t,
    0
    /* NodeColor.Black */
  ), sk();
}
function IQ(r) {
  for (; r.left !== Qe; )
    r = r.left;
  return r;
}
function sk() {
  Qe.parent = Qe, Qe.delta = 0, Qe.start = 0, Qe.end = 0;
}
function l_(r, e) {
  const t = e.right;
  t.delta += e.delta, (t.delta < -1073741824 || t.delta > 1073741824) && (r.requestNormalizeDelta = !0), t.start += e.delta, t.end += e.delta, e.right = t.left, t.left !== Qe && (t.left.parent = e), t.parent = e.parent, e.parent === Qe ? r.root = t : e === e.parent.left ? e.parent.left = t : e.parent.right = t, t.left = e, e.parent = t, Wc(e), Wc(t);
}
function d_(r, e) {
  const t = e.left;
  e.delta -= t.delta, (e.delta < -1073741824 || e.delta > 1073741824) && (r.requestNormalizeDelta = !0), e.start -= t.delta, e.end -= t.delta, e.left = t.right, t.right !== Qe && (t.right.parent = e), t.parent = e.parent, e.parent === Qe ? r.root = t : e === e.parent.right ? e.parent.right = t : e.parent.left = t, t.right = e, e.parent = t, Wc(e), Wc(t);
}
function E2(r) {
  let e = r.end;
  if (r.left !== Qe) {
    const t = r.left.maxEnd;
    t > e && (e = t);
  }
  if (r.right !== Qe) {
    const t = r.right.maxEnd + r.delta;
    t > e && (e = t);
  }
  return e;
}
function Wc(r) {
  r.maxEnd = E2(r);
}
function Od(r) {
  for (; r !== Qe; ) {
    const e = E2(r);
    if (r.maxEnd === e)
      return;
    r.maxEnd = e, r = r.parent;
  }
}
function EQ(r, e, t, i) {
  return r === t ? e - i : r - t;
}
class dI {
  constructor(e, t) {
    this.piece = e, this.color = t, this.size_left = 0, this.lf_left = 0, this.parent = this, this.left = this, this.right = this;
  }
  next() {
    if (this.right !== We)
      return V1(this.right);
    let e = this;
    for (; e.parent !== We && e.parent.left !== e; )
      e = e.parent;
    return e.parent === We ? We : e.parent;
  }
  prev() {
    if (this.left !== We)
      return T2(this.left);
    let e = this;
    for (; e.parent !== We && e.parent.right !== e; )
      e = e.parent;
    return e.parent === We ? We : e.parent;
  }
  detach() {
    this.parent = null, this.left = null, this.right = null;
  }
}
const We = new dI(
  null,
  0
  /* NodeColor.Black */
);
We.parent = We;
We.left = We;
We.right = We;
We.color = 0;
function V1(r) {
  for (; r.left !== We; )
    r = r.left;
  return r;
}
function T2(r) {
  for (; r.right !== We; )
    r = r.right;
  return r;
}
function z1(r) {
  return r === We ? 0 : r.size_left + r.piece.length + z1(r.right);
}
function U1(r) {
  return r === We ? 0 : r.lf_left + r.piece.lineFeedCnt + U1(r.right);
}
function ok() {
  We.parent = We;
}
function c_(r, e) {
  const t = e.right;
  t.size_left += e.size_left + (e.piece ? e.piece.length : 0), t.lf_left += e.lf_left + (e.piece ? e.piece.lineFeedCnt : 0), e.right = t.left, t.left !== We && (t.left.parent = e), t.parent = e.parent, e.parent === We ? r.root = t : e.parent.left === e ? e.parent.left = t : e.parent.right = t, t.left = e, e.parent = t;
}
function h_(r, e) {
  const t = e.left;
  e.left = t.right, t.right !== We && (t.right.parent = e), t.parent = e.parent, e.size_left -= t.size_left + (t.piece ? t.piece.length : 0), e.lf_left -= t.lf_left + (t.piece ? t.piece.lineFeedCnt : 0), e.parent === We ? r.root = t : e === e.parent.right ? e.parent.right = t : e.parent.left = t, t.right = e, e.parent = t;
}
function yC(r, e) {
  let t, i;
  if (e.left === We ? (i = e, t = i.right) : e.right === We ? (i = e, t = i.left) : (i = V1(e.right), t = i.right), i === r.root) {
    r.root = t, t.color = 0, e.detach(), ok(), r.root.parent = We;
    return;
  }
  const n = i.color === 1;
  if (i === i.parent.left ? i.parent.left = t : i.parent.right = t, i === e ? (t.parent = i.parent, Pm(r, t)) : (i.parent === e ? t.parent = i : t.parent = i.parent, Pm(r, t), i.left = e.left, i.right = e.right, i.parent = e.parent, i.color = e.color, e === r.root ? r.root = i : e === e.parent.left ? e.parent.left = i : e.parent.right = i, i.left !== We && (i.left.parent = i), i.right !== We && (i.right.parent = i), i.size_left = e.size_left, i.lf_left = e.lf_left, Pm(r, i)), e.detach(), t.parent.left === t) {
    const o = z1(t), a = U1(t);
    if (o !== t.parent.size_left || a !== t.parent.lf_left) {
      const l = o - t.parent.size_left, d = a - t.parent.lf_left;
      t.parent.size_left = o, t.parent.lf_left = a, Ll(r, t.parent, l, d);
    }
  }
  if (Pm(r, t.parent), n) {
    ok();
    return;
  }
  let s;
  for (; t !== r.root && t.color === 0; )
    t === t.parent.left ? (s = t.parent.right, s.color === 1 && (s.color = 0, t.parent.color = 1, c_(r, t.parent), s = t.parent.right), s.left.color === 0 && s.right.color === 0 ? (s.color = 1, t = t.parent) : (s.right.color === 0 && (s.left.color = 0, s.color = 1, h_(r, s), s = t.parent.right), s.color = t.parent.color, t.parent.color = 0, s.right.color = 0, c_(r, t.parent), t = r.root)) : (s = t.parent.left, s.color === 1 && (s.color = 0, t.parent.color = 1, h_(r, t.parent), s = t.parent.left), s.left.color === 0 && s.right.color === 0 ? (s.color = 1, t = t.parent) : (s.left.color === 0 && (s.right.color = 0, s.color = 1, c_(r, s), s = t.parent.left), s.color = t.parent.color, t.parent.color = 0, s.left.color = 0, h_(r, t.parent), t = r.root));
  t.color = 0, ok();
}
function JP(r, e) {
  for (Pm(r, e); e !== r.root && e.parent.color === 1; )
    if (e.parent === e.parent.parent.left) {
      const t = e.parent.parent.right;
      t.color === 1 ? (e.parent.color = 0, t.color = 0, e.parent.parent.color = 1, e = e.parent.parent) : (e === e.parent.right && (e = e.parent, c_(r, e)), e.parent.color = 0, e.parent.parent.color = 1, h_(r, e.parent.parent));
    } else {
      const t = e.parent.parent.left;
      t.color === 1 ? (e.parent.color = 0, t.color = 0, e.parent.parent.color = 1, e = e.parent.parent) : (e === e.parent.left && (e = e.parent, h_(r, e)), e.parent.color = 0, e.parent.parent.color = 1, c_(r, e.parent.parent));
    }
  r.root.color = 0;
}
function Ll(r, e, t, i) {
  for (; e !== r.root && e !== We; )
    e.parent.left === e && (e.parent.size_left += t, e.parent.lf_left += i), e = e.parent;
}
function Pm(r, e) {
  let t = 0, i = 0;
  if (e !== r.root) {
    for (; e !== r.root && e === e.parent.right; )
      e = e.parent;
    if (e !== r.root)
      for (e = e.parent, t = z1(e.left) - e.size_left, i = U1(e.left) - e.lf_left, e.size_left += t, e.lf_left += i; e !== r.root && (t !== 0 || i !== 0); )
        e.parent.left === e && (e.parent.size_left += t, e.parent.lf_left += i), e = e.parent;
  }
}
const _l = 65535;
function N2(r) {
  let e;
  return r[r.length - 1] < 65536 ? e = new Uint16Array(r.length) : e = new Uint32Array(r.length), e.set(r, 0), e;
}
class TQ {
  constructor(e, t, i, n, s) {
    this.lineStarts = e, this.cr = t, this.lf = i, this.crlf = n, this.isBasicASCII = s;
  }
}
function Dl(r, e = !0) {
  const t = [0];
  let i = 1;
  for (let n = 0, s = r.length; n < s; n++) {
    const o = r.charCodeAt(n);
    o === 13 ? n + 1 < s && r.charCodeAt(n + 1) === 10 ? (t[i++] = n + 2, n++) : t[i++] = n + 1 : o === 10 && (t[i++] = n + 1);
  }
  return e ? N2(t) : t;
}
function NQ(r, e) {
  r.length = 0, r[0] = 0;
  let t = 1, i = 0, n = 0, s = 0, o = !0;
  for (let l = 0, d = e.length; l < d; l++) {
    const c = e.charCodeAt(l);
    c === 13 ? l + 1 < d && e.charCodeAt(l + 1) === 10 ? (s++, r[t++] = l + 2, l++) : (i++, r[t++] = l + 1) : c === 10 ? (n++, r[t++] = l + 1) : o && c !== 9 && (c < 32 || c > 126) && (o = !1);
  }
  const a = new TQ(N2(r), i, n, s, o);
  return r.length = 0, a;
}
class Es {
  constructor(e, t, i, n, s) {
    this.bufferIndex = e, this.start = t, this.end = i, this.lineFeedCnt = n, this.length = s;
  }
}
class Uh {
  constructor(e, t) {
    this.buffer = e, this.lineStarts = t;
  }
}
class MQ {
  constructor(e, t) {
    this._pieces = [], this._tree = e, this._BOM = t, this._index = 0, e.root !== We && e.iterate(e.root, (i) => (i !== We && this._pieces.push(i.piece), !0));
  }
  read() {
    return this._pieces.length === 0 ? this._index === 0 ? (this._index++, this._BOM) : null : this._index > this._pieces.length - 1 ? null : this._index === 0 ? this._BOM + this._tree.getPieceContent(this._pieces[this._index++]) : this._tree.getPieceContent(this._pieces[this._index++]);
  }
}
class RQ {
  constructor(e) {
    this._limit = e, this._cache = [];
  }
  get(e) {
    for (let t = this._cache.length - 1; t >= 0; t--) {
      const i = this._cache[t];
      if (i.nodeStartOffset <= e && i.nodeStartOffset + i.node.piece.length >= e)
        return i;
    }
    return null;
  }
  get2(e) {
    for (let t = this._cache.length - 1; t >= 0; t--) {
      const i = this._cache[t];
      if (i.nodeStartLineNumber && i.nodeStartLineNumber < e && i.nodeStartLineNumber + i.node.piece.lineFeedCnt >= e)
        return i;
    }
    return null;
  }
  set(e) {
    this._cache.length >= this._limit && this._cache.shift(), this._cache.push(e);
  }
  validate(e) {
    let t = !1;
    const i = this._cache;
    for (let n = 0; n < i.length; n++) {
      const s = i[n];
      if (s.node.parent === null || s.nodeStartOffset >= e) {
        i[n] = null, t = !0;
        continue;
      }
    }
    if (t) {
      const n = [];
      for (const s of i)
        s !== null && n.push(s);
      this._cache = n;
    }
  }
}
class AQ {
  constructor(e, t, i) {
    this.create(e, t, i);
  }
  create(e, t, i) {
    this._buffers = [
      new Uh("", [0])
    ], this._lastChangeBufferPos = { line: 0, column: 0 }, this.root = We, this._lineCnt = 1, this._length = 0, this._EOL = t, this._EOLLength = t.length, this._EOLNormalized = i;
    let n = null;
    for (let s = 0, o = e.length; s < o; s++)
      if (e[s].buffer.length > 0) {
        e[s].lineStarts || (e[s].lineStarts = Dl(e[s].buffer));
        const a = new Es(s + 1, { line: 0, column: 0 }, { line: e[s].lineStarts.length - 1, column: e[s].buffer.length - e[s].lineStarts[e[s].lineStarts.length - 1] }, e[s].lineStarts.length - 1, e[s].buffer.length);
        this._buffers.push(e[s]), n = this.rbInsertRight(n, a);
      }
    this._searchCache = new RQ(1), this._lastVisitedLine = { lineNumber: 0, value: "" }, this.computeBufferMetadata();
  }
  normalizeEOL(e) {
    const t = _l, i = t - Math.floor(t / 3), n = i * 2;
    let s = "", o = 0;
    const a = [];
    if (this.iterate(this.root, (l) => {
      const d = this.getNodeContent(l), c = d.length;
      if (o <= i || o + c < n)
        return s += d, o += c, !0;
      const h = s.replace(/\r\n|\r|\n/g, e);
      return a.push(new Uh(h, Dl(h))), s = d, o = c, !0;
    }), o > 0) {
      const l = s.replace(/\r\n|\r|\n/g, e);
      a.push(new Uh(l, Dl(l)));
    }
    this.create(a, e, !0);
  }
  // #region Buffer API
  getEOL() {
    return this._EOL;
  }
  setEOL(e) {
    this._EOL = e, this._EOLLength = this._EOL.length, this.normalizeEOL(e);
  }
  createSnapshot(e) {
    return new MQ(this, e);
  }
  getOffsetAt(e, t) {
    let i = 0, n = this.root;
    for (; n !== We; )
      if (n.left !== We && n.lf_left + 1 >= e)
        n = n.left;
      else if (n.lf_left + n.piece.lineFeedCnt + 1 >= e) {
        i += n.size_left;
        const s = this.getAccumulatedValue(n, e - n.lf_left - 2);
        return i += s + t - 1;
      } else
        e -= n.lf_left + n.piece.lineFeedCnt, i += n.size_left + n.piece.length, n = n.right;
    return i;
  }
  getPositionAt(e) {
    e = Math.floor(e), e = Math.max(0, e);
    let t = this.root, i = 0;
    const n = e;
    for (; t !== We; )
      if (t.size_left !== 0 && t.size_left >= e)
        t = t.left;
      else if (t.size_left + t.piece.length >= e) {
        const s = this.getIndexOf(t, e - t.size_left);
        if (i += t.lf_left + s.index, s.index === 0) {
          const o = this.getOffsetAt(i + 1, 1), a = n - o;
          return new A(i + 1, a + 1);
        }
        return new A(i + 1, s.remainder + 1);
      } else if (e -= t.size_left + t.piece.length, i += t.lf_left + t.piece.lineFeedCnt, t.right === We) {
        const s = this.getOffsetAt(i + 1, 1), o = n - e - s;
        return new A(i + 1, o + 1);
      } else
        t = t.right;
    return new A(1, 1);
  }
  getValueInRange(e, t) {
    if (e.startLineNumber === e.endLineNumber && e.startColumn === e.endColumn)
      return "";
    const i = this.nodeAt2(e.startLineNumber, e.startColumn), n = this.nodeAt2(e.endLineNumber, e.endColumn), s = this.getValueInRange2(i, n);
    return t ? t !== this._EOL || !this._EOLNormalized ? s.replace(/\r\n|\r|\n/g, t) : t === this.getEOL() && this._EOLNormalized ? s : s.replace(/\r\n|\r|\n/g, t) : s;
  }
  getValueInRange2(e, t) {
    if (e.node === t.node) {
      const a = e.node, l = this._buffers[a.piece.bufferIndex].buffer, d = this.offsetInBuffer(a.piece.bufferIndex, a.piece.start);
      return l.substring(d + e.remainder, d + t.remainder);
    }
    let i = e.node;
    const n = this._buffers[i.piece.bufferIndex].buffer, s = this.offsetInBuffer(i.piece.bufferIndex, i.piece.start);
    let o = n.substring(s + e.remainder, s + i.piece.length);
    for (i = i.next(); i !== We; ) {
      const a = this._buffers[i.piece.bufferIndex].buffer, l = this.offsetInBuffer(i.piece.bufferIndex, i.piece.start);
      if (i === t.node) {
        o += a.substring(l, l + t.remainder);
        break;
      } else
        o += a.substr(l, i.piece.length);
      i = i.next();
    }
    return o;
  }
  getLinesContent() {
    const e = [];
    let t = 0, i = "", n = !1;
    return this.iterate(this.root, (s) => {
      if (s === We)
        return !0;
      const o = s.piece;
      let a = o.length;
      if (a === 0)
        return !0;
      const l = this._buffers[o.bufferIndex].buffer, d = this._buffers[o.bufferIndex].lineStarts, c = o.start.line, h = o.end.line;
      let u = d[c] + o.start.column;
      if (n && (l.charCodeAt(u) === 10 && (u++, a--), e[t++] = i, i = "", n = !1, a === 0))
        return !0;
      if (c === h)
        return !this._EOLNormalized && l.charCodeAt(u + a - 1) === 13 ? (n = !0, i += l.substr(u, a - 1)) : i += l.substr(u, a), !0;
      i += this._EOLNormalized ? l.substring(u, Math.max(u, d[c + 1] - this._EOLLength)) : l.substring(u, d[c + 1]).replace(/(\r\n|\r|\n)$/, ""), e[t++] = i;
      for (let g = c + 1; g < h; g++)
        i = this._EOLNormalized ? l.substring(d[g], d[g + 1] - this._EOLLength) : l.substring(d[g], d[g + 1]).replace(/(\r\n|\r|\n)$/, ""), e[t++] = i;
      return !this._EOLNormalized && l.charCodeAt(d[h] + o.end.column - 1) === 13 ? (n = !0, o.end.column === 0 ? t-- : i = l.substr(d[h], o.end.column - 1)) : i = l.substr(d[h], o.end.column), !0;
    }), n && (e[t++] = i, i = ""), e[t++] = i, e;
  }
  getLength() {
    return this._length;
  }
  getLineCount() {
    return this._lineCnt;
  }
  getLineContent(e) {
    return this._lastVisitedLine.lineNumber === e ? this._lastVisitedLine.value : (this._lastVisitedLine.lineNumber = e, e === this._lineCnt ? this._lastVisitedLine.value = this.getLineRawContent(e) : this._EOLNormalized ? this._lastVisitedLine.value = this.getLineRawContent(e, this._EOLLength) : this._lastVisitedLine.value = this.getLineRawContent(e).replace(/(\r\n|\r|\n)$/, ""), this._lastVisitedLine.value);
  }
  _getCharCode(e) {
    if (e.remainder === e.node.piece.length) {
      const t = e.node.next();
      if (!t)
        return 0;
      const i = this._buffers[t.piece.bufferIndex], n = this.offsetInBuffer(t.piece.bufferIndex, t.piece.start);
      return i.buffer.charCodeAt(n);
    } else {
      const t = this._buffers[e.node.piece.bufferIndex], n = this.offsetInBuffer(e.node.piece.bufferIndex, e.node.piece.start) + e.remainder;
      return t.buffer.charCodeAt(n);
    }
  }
  getLineCharCode(e, t) {
    const i = this.nodeAt2(e, t + 1);
    return this._getCharCode(i);
  }
  getLineLength(e) {
    if (e === this.getLineCount()) {
      const t = this.getOffsetAt(e, 1);
      return this.getLength() - t;
    }
    return this.getOffsetAt(e + 1, 1) - this.getOffsetAt(e, 1) - this._EOLLength;
  }
  findMatchesInNode(e, t, i, n, s, o, a, l, d, c, h) {
    const u = this._buffers[e.piece.bufferIndex], g = this.offsetInBuffer(e.piece.bufferIndex, e.piece.start), f = this.offsetInBuffer(e.piece.bufferIndex, s), m = this.offsetInBuffer(e.piece.bufferIndex, o);
    let _;
    const v = { line: 0, column: 0 };
    let b, C;
    t._wordSeparators ? (b = u.buffer.substring(f, m), C = (w) => w + f, t.reset(0)) : (b = u.buffer, C = (w) => w, t.reset(f));
    do
      if (_ = t.next(b), _) {
        if (C(_.index) >= m)
          return c;
        this.positionInBuffer(e, C(_.index) - g, v);
        const w = this.getLineFeedCnt(e.piece.bufferIndex, s, v), S = v.line === s.line ? v.column - s.column + n : v.column + 1, y = S + _[0].length;
        if (h[c++] = iA(new L(i + w, S, i + w, y), _, l), C(_.index) + _[0].length >= m || c >= d)
          return c;
      }
    while (_);
    return c;
  }
  findMatchesLineByLine(e, t, i, n) {
    const s = [];
    let o = 0;
    const a = new w5(t.wordSeparators, t.regex);
    let l = this.nodeAt2(e.startLineNumber, e.startColumn);
    if (l === null)
      return [];
    const d = this.nodeAt2(e.endLineNumber, e.endColumn);
    if (d === null)
      return [];
    let c = this.positionInBuffer(l.node, l.remainder);
    const h = this.positionInBuffer(d.node, d.remainder);
    if (l.node === d.node)
      return this.findMatchesInNode(l.node, a, e.startLineNumber, e.startColumn, c, h, t, i, n, o, s), s;
    let u = e.startLineNumber, g = l.node;
    for (; g !== d.node; ) {
      const m = this.getLineFeedCnt(g.piece.bufferIndex, c, g.piece.end);
      if (m >= 1) {
        const v = this._buffers[g.piece.bufferIndex].lineStarts, b = this.offsetInBuffer(g.piece.bufferIndex, g.piece.start), C = v[c.line + m], w = u === e.startLineNumber ? e.startColumn : 1;
        if (o = this.findMatchesInNode(g, a, u, w, c, this.positionInBuffer(g, C - b), t, i, n, o, s), o >= n)
          return s;
        u += m;
      }
      const _ = u === e.startLineNumber ? e.startColumn - 1 : 0;
      if (u === e.endLineNumber) {
        const v = this.getLineContent(u).substring(_, e.endColumn - 1);
        return o = this._findMatchesInLine(t, a, v, e.endLineNumber, _, o, s, i, n), s;
      }
      if (o = this._findMatchesInLine(t, a, this.getLineContent(u).substr(_), u, _, o, s, i, n), o >= n)
        return s;
      u++, l = this.nodeAt2(u, 1), g = l.node, c = this.positionInBuffer(l.node, l.remainder);
    }
    if (u === e.endLineNumber) {
      const m = u === e.startLineNumber ? e.startColumn - 1 : 0, _ = this.getLineContent(u).substring(m, e.endColumn - 1);
      return o = this._findMatchesInLine(t, a, _, e.endLineNumber, m, o, s, i, n), s;
    }
    const f = u === e.startLineNumber ? e.startColumn : 1;
    return o = this.findMatchesInNode(d.node, a, u, f, c, h, t, i, n, o, s), s;
  }
  _findMatchesInLine(e, t, i, n, s, o, a, l, d) {
    const c = e.wordSeparators;
    if (!l && e.simpleSearch) {
      const u = e.simpleSearch, g = u.length, f = i.length;
      let m = -g;
      for (; (m = i.indexOf(u, m + g)) !== -1; )
        if ((!c || S5(c, i, f, m, g)) && (a[o++] = new JB(new L(n, m + 1 + s, n, m + 1 + g + s), null), o >= d))
          return o;
      return o;
    }
    let h;
    t.reset(0);
    do
      if (h = t.next(i), h && (a[o++] = iA(new L(n, h.index + 1 + s, n, h.index + 1 + h[0].length + s), h, l), o >= d))
        return o;
    while (h);
    return o;
  }
  // #endregion
  // #region Piece Table
  insert(e, t, i = !1) {
    if (this._EOLNormalized = this._EOLNormalized && i, this._lastVisitedLine.lineNumber = 0, this._lastVisitedLine.value = "", this.root !== We) {
      const { node: n, remainder: s, nodeStartOffset: o } = this.nodeAt(e), a = n.piece, l = a.bufferIndex, d = this.positionInBuffer(n, s);
      if (n.piece.bufferIndex === 0 && a.end.line === this._lastChangeBufferPos.line && a.end.column === this._lastChangeBufferPos.column && o + a.length === e && t.length < _l) {
        this.appendToNode(n, t), this.computeBufferMetadata();
        return;
      }
      if (o === e)
        this.insertContentToNodeLeft(t, n), this._searchCache.validate(e);
      else if (o + n.piece.length > e) {
        const c = [];
        let h = new Es(a.bufferIndex, d, a.end, this.getLineFeedCnt(a.bufferIndex, d, a.end), this.offsetInBuffer(l, a.end) - this.offsetInBuffer(l, d));
        if (this.shouldCheckCRLF() && this.endWithCR(t) && this.nodeCharCodeAt(n, s) === 10) {
          const m = { line: h.start.line + 1, column: 0 };
          h = new Es(h.bufferIndex, m, h.end, this.getLineFeedCnt(h.bufferIndex, m, h.end), h.length - 1), t += `
`;
        }
        if (this.shouldCheckCRLF() && this.startWithLF(t))
          if (this.nodeCharCodeAt(n, s - 1) === 13) {
            const m = this.positionInBuffer(n, s - 1);
            this.deleteNodeTail(n, m), t = "\r" + t, n.piece.length === 0 && c.push(n);
          } else
            this.deleteNodeTail(n, d);
        else
          this.deleteNodeTail(n, d);
        const u = this.createNewPieces(t);
        h.length > 0 && this.rbInsertRight(n, h);
        let g = n;
        for (let f = 0; f < u.length; f++)
          g = this.rbInsertRight(g, u[f]);
        this.deleteNodes(c);
      } else
        this.insertContentToNodeRight(t, n);
    } else {
      const n = this.createNewPieces(t);
      let s = this.rbInsertLeft(null, n[0]);
      for (let o = 1; o < n.length; o++)
        s = this.rbInsertRight(s, n[o]);
    }
    this.computeBufferMetadata();
  }
  delete(e, t) {
    if (this._lastVisitedLine.lineNumber = 0, this._lastVisitedLine.value = "", t <= 0 || this.root === We)
      return;
    const i = this.nodeAt(e), n = this.nodeAt(e + t), s = i.node, o = n.node;
    if (s === o) {
      const u = this.positionInBuffer(s, i.remainder), g = this.positionInBuffer(s, n.remainder);
      if (i.nodeStartOffset === e) {
        if (t === s.piece.length) {
          const f = s.next();
          yC(this, s), this.validateCRLFWithPrevNode(f), this.computeBufferMetadata();
          return;
        }
        this.deleteNodeHead(s, g), this._searchCache.validate(e), this.validateCRLFWithPrevNode(s), this.computeBufferMetadata();
        return;
      }
      if (i.nodeStartOffset + s.piece.length === e + t) {
        this.deleteNodeTail(s, u), this.validateCRLFWithNextNode(s), this.computeBufferMetadata();
        return;
      }
      this.shrinkNode(s, u, g), this.computeBufferMetadata();
      return;
    }
    const a = [], l = this.positionInBuffer(s, i.remainder);
    this.deleteNodeTail(s, l), this._searchCache.validate(e), s.piece.length === 0 && a.push(s);
    const d = this.positionInBuffer(o, n.remainder);
    this.deleteNodeHead(o, d), o.piece.length === 0 && a.push(o);
    const c = s.next();
    for (let u = c; u !== We && u !== o; u = u.next())
      a.push(u);
    const h = s.piece.length === 0 ? s.prev() : s;
    this.deleteNodes(a), this.validateCRLFWithNextNode(h), this.computeBufferMetadata();
  }
  insertContentToNodeLeft(e, t) {
    const i = [];
    if (this.shouldCheckCRLF() && this.endWithCR(e) && this.startWithLF(t)) {
      const o = t.piece, a = { line: o.start.line + 1, column: 0 }, l = new Es(o.bufferIndex, a, o.end, this.getLineFeedCnt(o.bufferIndex, a, o.end), o.length - 1);
      t.piece = l, e += `
`, Ll(this, t, -1, -1), t.piece.length === 0 && i.push(t);
    }
    const n = this.createNewPieces(e);
    let s = this.rbInsertLeft(t, n[n.length - 1]);
    for (let o = n.length - 2; o >= 0; o--)
      s = this.rbInsertLeft(s, n[o]);
    this.validateCRLFWithPrevNode(s), this.deleteNodes(i);
  }
  insertContentToNodeRight(e, t) {
    this.adjustCarriageReturnFromNext(e, t) && (e += `
`);
    const i = this.createNewPieces(e), n = this.rbInsertRight(t, i[0]);
    let s = n;
    for (let o = 1; o < i.length; o++)
      s = this.rbInsertRight(s, i[o]);
    this.validateCRLFWithPrevNode(n);
  }
  positionInBuffer(e, t, i) {
    const n = e.piece, s = e.piece.bufferIndex, o = this._buffers[s].lineStarts, l = o[n.start.line] + n.start.column + t;
    let d = n.start.line, c = n.end.line, h = 0, u = 0, g = 0;
    for (; d <= c && (h = d + (c - d) / 2 | 0, g = o[h], h !== c); )
      if (u = o[h + 1], l < g)
        c = h - 1;
      else if (l >= u)
        d = h + 1;
      else
        break;
    return i ? (i.line = h, i.column = l - g, null) : {
      line: h,
      column: l - g
    };
  }
  getLineFeedCnt(e, t, i) {
    if (i.column === 0)
      return i.line - t.line;
    const n = this._buffers[e].lineStarts;
    if (i.line === n.length - 1)
      return i.line - t.line;
    const s = n[i.line + 1], o = n[i.line] + i.column;
    if (s > o + 1)
      return i.line - t.line;
    const a = o - 1;
    return this._buffers[e].buffer.charCodeAt(a) === 13 ? i.line - t.line + 1 : i.line - t.line;
  }
  offsetInBuffer(e, t) {
    return this._buffers[e].lineStarts[t.line] + t.column;
  }
  deleteNodes(e) {
    for (let t = 0; t < e.length; t++)
      yC(this, e[t]);
  }
  createNewPieces(e) {
    if (e.length > _l) {
      const c = [];
      for (; e.length > _l; ) {
        const u = e.charCodeAt(_l - 1);
        let g;
        u === 13 || u >= 55296 && u <= 56319 ? (g = e.substring(0, _l - 1), e = e.substring(_l - 1)) : (g = e.substring(0, _l), e = e.substring(_l));
        const f = Dl(g);
        c.push(new Es(
          this._buffers.length,
          /* buffer index */
          { line: 0, column: 0 },
          { line: f.length - 1, column: g.length - f[f.length - 1] },
          f.length - 1,
          g.length
        )), this._buffers.push(new Uh(g, f));
      }
      const h = Dl(e);
      return c.push(new Es(
        this._buffers.length,
        /* buffer index */
        { line: 0, column: 0 },
        { line: h.length - 1, column: e.length - h[h.length - 1] },
        h.length - 1,
        e.length
      )), this._buffers.push(new Uh(e, h)), c;
    }
    let t = this._buffers[0].buffer.length;
    const i = Dl(e, !1);
    let n = this._lastChangeBufferPos;
    if (this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 1] === t && t !== 0 && this.startWithLF(e) && this.endWithCR(this._buffers[0].buffer)) {
      this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line, column: this._lastChangeBufferPos.column + 1 }, n = this._lastChangeBufferPos;
      for (let c = 0; c < i.length; c++)
        i[c] += t + 1;
      this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(i.slice(1)), this._buffers[0].buffer += "_" + e, t += 1;
    } else {
      if (t !== 0)
        for (let c = 0; c < i.length; c++)
          i[c] += t;
      this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(i.slice(1)), this._buffers[0].buffer += e;
    }
    const s = this._buffers[0].buffer.length, o = this._buffers[0].lineStarts.length - 1, a = s - this._buffers[0].lineStarts[o], l = { line: o, column: a }, d = new Es(
      0,
      /** todo@peng */
      n,
      l,
      this.getLineFeedCnt(0, n, l),
      s - t
    );
    return this._lastChangeBufferPos = l, [d];
  }
  getLineRawContent(e, t = 0) {
    let i = this.root, n = "";
    const s = this._searchCache.get2(e);
    if (s) {
      i = s.node;
      const o = this.getAccumulatedValue(i, e - s.nodeStartLineNumber - 1), a = this._buffers[i.piece.bufferIndex].buffer, l = this.offsetInBuffer(i.piece.bufferIndex, i.piece.start);
      if (s.nodeStartLineNumber + i.piece.lineFeedCnt === e)
        n = a.substring(l + o, l + i.piece.length);
      else {
        const d = this.getAccumulatedValue(i, e - s.nodeStartLineNumber);
        return a.substring(l + o, l + d - t);
      }
    } else {
      let o = 0;
      const a = e;
      for (; i !== We; )
        if (i.left !== We && i.lf_left >= e - 1)
          i = i.left;
        else if (i.lf_left + i.piece.lineFeedCnt > e - 1) {
          const l = this.getAccumulatedValue(i, e - i.lf_left - 2), d = this.getAccumulatedValue(i, e - i.lf_left - 1), c = this._buffers[i.piece.bufferIndex].buffer, h = this.offsetInBuffer(i.piece.bufferIndex, i.piece.start);
          return o += i.size_left, this._searchCache.set({
            node: i,
            nodeStartOffset: o,
            nodeStartLineNumber: a - (e - 1 - i.lf_left)
          }), c.substring(h + l, h + d - t);
        } else if (i.lf_left + i.piece.lineFeedCnt === e - 1) {
          const l = this.getAccumulatedValue(i, e - i.lf_left - 2), d = this._buffers[i.piece.bufferIndex].buffer, c = this.offsetInBuffer(i.piece.bufferIndex, i.piece.start);
          n = d.substring(c + l, c + i.piece.length);
          break;
        } else
          e -= i.lf_left + i.piece.lineFeedCnt, o += i.size_left + i.piece.length, i = i.right;
    }
    for (i = i.next(); i !== We; ) {
      const o = this._buffers[i.piece.bufferIndex].buffer;
      if (i.piece.lineFeedCnt > 0) {
        const a = this.getAccumulatedValue(i, 0), l = this.offsetInBuffer(i.piece.bufferIndex, i.piece.start);
        return n += o.substring(l, l + a - t), n;
      } else {
        const a = this.offsetInBuffer(i.piece.bufferIndex, i.piece.start);
        n += o.substr(a, i.piece.length);
      }
      i = i.next();
    }
    return n;
  }
  computeBufferMetadata() {
    let e = this.root, t = 1, i = 0;
    for (; e !== We; )
      t += e.lf_left + e.piece.lineFeedCnt, i += e.size_left + e.piece.length, e = e.right;
    this._lineCnt = t, this._length = i, this._searchCache.validate(this._length);
  }
  // #region node operations
  getIndexOf(e, t) {
    const i = e.piece, n = this.positionInBuffer(e, t), s = n.line - i.start.line;
    if (this.offsetInBuffer(i.bufferIndex, i.end) - this.offsetInBuffer(i.bufferIndex, i.start) === t) {
      const o = this.getLineFeedCnt(e.piece.bufferIndex, i.start, n);
      if (o !== s)
        return { index: o, remainder: 0 };
    }
    return { index: s, remainder: n.column };
  }
  getAccumulatedValue(e, t) {
    if (t < 0)
      return 0;
    const i = e.piece, n = this._buffers[i.bufferIndex].lineStarts, s = i.start.line + t + 1;
    return s > i.end.line ? n[i.end.line] + i.end.column - n[i.start.line] - i.start.column : n[s] - n[i.start.line] - i.start.column;
  }
  deleteNodeTail(e, t) {
    const i = e.piece, n = i.lineFeedCnt, s = this.offsetInBuffer(i.bufferIndex, i.end), o = t, a = this.offsetInBuffer(i.bufferIndex, o), l = this.getLineFeedCnt(i.bufferIndex, i.start, o), d = l - n, c = a - s, h = i.length + c;
    e.piece = new Es(i.bufferIndex, i.start, o, l, h), Ll(this, e, c, d);
  }
  deleteNodeHead(e, t) {
    const i = e.piece, n = i.lineFeedCnt, s = this.offsetInBuffer(i.bufferIndex, i.start), o = t, a = this.getLineFeedCnt(i.bufferIndex, o, i.end), l = this.offsetInBuffer(i.bufferIndex, o), d = a - n, c = s - l, h = i.length + c;
    e.piece = new Es(i.bufferIndex, o, i.end, a, h), Ll(this, e, c, d);
  }
  shrinkNode(e, t, i) {
    const n = e.piece, s = n.start, o = n.end, a = n.length, l = n.lineFeedCnt, d = t, c = this.getLineFeedCnt(n.bufferIndex, n.start, d), h = this.offsetInBuffer(n.bufferIndex, t) - this.offsetInBuffer(n.bufferIndex, s);
    e.piece = new Es(n.bufferIndex, n.start, d, c, h), Ll(this, e, h - a, c - l);
    const u = new Es(n.bufferIndex, i, o, this.getLineFeedCnt(n.bufferIndex, i, o), this.offsetInBuffer(n.bufferIndex, o) - this.offsetInBuffer(n.bufferIndex, i)), g = this.rbInsertRight(e, u);
    this.validateCRLFWithPrevNode(g);
  }
  appendToNode(e, t) {
    this.adjustCarriageReturnFromNext(t, e) && (t += `
`);
    const i = this.shouldCheckCRLF() && this.startWithLF(t) && this.endWithCR(e), n = this._buffers[0].buffer.length;
    this._buffers[0].buffer += t;
    const s = Dl(t, !1);
    for (let g = 0; g < s.length; g++)
      s[g] += n;
    if (i) {
      const g = this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 2];
      this._buffers[0].lineStarts.pop(), this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line - 1, column: n - g };
    }
    this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(s.slice(1));
    const o = this._buffers[0].lineStarts.length - 1, a = this._buffers[0].buffer.length - this._buffers[0].lineStarts[o], l = { line: o, column: a }, d = e.piece.length + t.length, c = e.piece.lineFeedCnt, h = this.getLineFeedCnt(0, e.piece.start, l), u = h - c;
    e.piece = new Es(e.piece.bufferIndex, e.piece.start, l, h, d), this._lastChangeBufferPos = l, Ll(this, e, t.length, u);
  }
  nodeAt(e) {
    let t = this.root;
    const i = this._searchCache.get(e);
    if (i)
      return {
        node: i.node,
        nodeStartOffset: i.nodeStartOffset,
        remainder: e - i.nodeStartOffset
      };
    let n = 0;
    for (; t !== We; )
      if (t.size_left > e)
        t = t.left;
      else if (t.size_left + t.piece.length >= e) {
        n += t.size_left;
        const s = {
          node: t,
          remainder: e - t.size_left,
          nodeStartOffset: n
        };
        return this._searchCache.set(s), s;
      } else
        e -= t.size_left + t.piece.length, n += t.size_left + t.piece.length, t = t.right;
    return null;
  }
  nodeAt2(e, t) {
    let i = this.root, n = 0;
    for (; i !== We; )
      if (i.left !== We && i.lf_left >= e - 1)
        i = i.left;
      else if (i.lf_left + i.piece.lineFeedCnt > e - 1) {
        const s = this.getAccumulatedValue(i, e - i.lf_left - 2), o = this.getAccumulatedValue(i, e - i.lf_left - 1);
        return n += i.size_left, {
          node: i,
          remainder: Math.min(s + t - 1, o),
          nodeStartOffset: n
        };
      } else if (i.lf_left + i.piece.lineFeedCnt === e - 1) {
        const s = this.getAccumulatedValue(i, e - i.lf_left - 2);
        if (s + t - 1 <= i.piece.length)
          return {
            node: i,
            remainder: s + t - 1,
            nodeStartOffset: n
          };
        t -= i.piece.length - s;
        break;
      } else
        e -= i.lf_left + i.piece.lineFeedCnt, n += i.size_left + i.piece.length, i = i.right;
    for (i = i.next(); i !== We; ) {
      if (i.piece.lineFeedCnt > 0) {
        const s = this.getAccumulatedValue(i, 0), o = this.offsetOfNode(i);
        return {
          node: i,
          remainder: Math.min(t - 1, s),
          nodeStartOffset: o
        };
      } else if (i.piece.length >= t - 1) {
        const s = this.offsetOfNode(i);
        return {
          node: i,
          remainder: t - 1,
          nodeStartOffset: s
        };
      } else
        t -= i.piece.length;
      i = i.next();
    }
    return null;
  }
  nodeCharCodeAt(e, t) {
    if (e.piece.lineFeedCnt < 1)
      return -1;
    const i = this._buffers[e.piece.bufferIndex], n = this.offsetInBuffer(e.piece.bufferIndex, e.piece.start) + t;
    return i.buffer.charCodeAt(n);
  }
  offsetOfNode(e) {
    if (!e)
      return 0;
    let t = e.size_left;
    for (; e !== this.root; )
      e.parent.right === e && (t += e.parent.size_left + e.parent.piece.length), e = e.parent;
    return t;
  }
  // #endregion
  // #region CRLF
  shouldCheckCRLF() {
    return !(this._EOLNormalized && this._EOL === `
`);
  }
  startWithLF(e) {
    if (typeof e == "string")
      return e.charCodeAt(0) === 10;
    if (e === We || e.piece.lineFeedCnt === 0)
      return !1;
    const t = e.piece, i = this._buffers[t.bufferIndex].lineStarts, n = t.start.line, s = i[n] + t.start.column;
    return n === i.length - 1 || i[n + 1] > s + 1 ? !1 : this._buffers[t.bufferIndex].buffer.charCodeAt(s) === 10;
  }
  endWithCR(e) {
    return typeof e == "string" ? e.charCodeAt(e.length - 1) === 13 : e === We || e.piece.lineFeedCnt === 0 ? !1 : this.nodeCharCodeAt(e, e.piece.length - 1) === 13;
  }
  validateCRLFWithPrevNode(e) {
    if (this.shouldCheckCRLF() && this.startWithLF(e)) {
      const t = e.prev();
      this.endWithCR(t) && this.fixCRLF(t, e);
    }
  }
  validateCRLFWithNextNode(e) {
    if (this.shouldCheckCRLF() && this.endWithCR(e)) {
      const t = e.next();
      this.startWithLF(t) && this.fixCRLF(e, t);
    }
  }
  fixCRLF(e, t) {
    const i = [], n = this._buffers[e.piece.bufferIndex].lineStarts;
    let s;
    e.piece.end.column === 0 ? s = { line: e.piece.end.line - 1, column: n[e.piece.end.line] - n[e.piece.end.line - 1] - 1 } : s = { line: e.piece.end.line, column: e.piece.end.column - 1 };
    const o = e.piece.length - 1, a = e.piece.lineFeedCnt - 1;
    e.piece = new Es(e.piece.bufferIndex, e.piece.start, s, a, o), Ll(this, e, -1, -1), e.piece.length === 0 && i.push(e);
    const l = { line: t.piece.start.line + 1, column: 0 }, d = t.piece.length - 1, c = this.getLineFeedCnt(t.piece.bufferIndex, l, t.piece.end);
    t.piece = new Es(t.piece.bufferIndex, l, t.piece.end, c, d), Ll(this, t, -1, -1), t.piece.length === 0 && i.push(t);
    const h = this.createNewPieces(`\r
`);
    this.rbInsertRight(e, h[0]);
    for (let u = 0; u < i.length; u++)
      yC(this, i[u]);
  }
  adjustCarriageReturnFromNext(e, t) {
    if (this.shouldCheckCRLF() && this.endWithCR(e)) {
      const i = t.next();
      if (this.startWithLF(i)) {
        if (e += `
`, i.piece.length === 1)
          yC(this, i);
        else {
          const n = i.piece, s = { line: n.start.line + 1, column: 0 }, o = n.length - 1, a = this.getLineFeedCnt(n.bufferIndex, s, n.end);
          i.piece = new Es(n.bufferIndex, s, n.end, a, o), Ll(this, i, -1, -1);
        }
        return !0;
      }
    }
    return !1;
  }
  // #endregion
  // #endregion
  // #region Tree operations
  iterate(e, t) {
    if (e === We)
      return t(We);
    const i = this.iterate(e.left, t);
    return i && t(e) && this.iterate(e.right, t);
  }
  getNodeContent(e) {
    if (e === We)
      return "";
    const t = this._buffers[e.piece.bufferIndex], i = e.piece, n = this.offsetInBuffer(i.bufferIndex, i.start), s = this.offsetInBuffer(i.bufferIndex, i.end);
    return t.buffer.substring(n, s);
  }
  getPieceContent(e) {
    const t = this._buffers[e.bufferIndex], i = this.offsetInBuffer(e.bufferIndex, e.start), n = this.offsetInBuffer(e.bufferIndex, e.end);
    return t.buffer.substring(i, n);
  }
  /**
   *      node              node
   *     /  \              /  \
   *    a   b    <----   a    b
   *                         /
   *                        z
   */
  rbInsertRight(e, t) {
    const i = new dI(
      t,
      1
      /* NodeColor.Red */
    );
    if (i.left = We, i.right = We, i.parent = We, i.size_left = 0, i.lf_left = 0, this.root === We)
      this.root = i, i.color = 0;
    else if (e.right === We)
      e.right = i, i.parent = e;
    else {
      const s = V1(e.right);
      s.left = i, i.parent = s;
    }
    return JP(this, i), i;
  }
  /**
   *      node              node
   *     /  \              /  \
   *    a   b     ---->   a    b
   *                       \
   *                        z
   */
  rbInsertLeft(e, t) {
    const i = new dI(
      t,
      1
      /* NodeColor.Red */
    );
    if (i.left = We, i.right = We, i.parent = We, i.size_left = 0, i.lf_left = 0, this.root === We)
      this.root = i, i.color = 0;
    else if (e.left === We)
      e.left = i, i.parent = e;
    else {
      const n = T2(e.left);
      n.right = i, i.parent = n;
    }
    return JP(this, i), i;
  }
}
class Df extends P {
  constructor(e, t, i, n, s, o, a) {
    super(), this._onDidChangeContent = this._register(new R()), this._BOM = t, this._mightContainNonBasicASCII = !o, this._mightContainRTL = n, this._mightContainUnusualLineTerminators = s, this._pieceTree = new AQ(e, i, a);
  }
  mightContainRTL() {
    return this._mightContainRTL;
  }
  mightContainUnusualLineTerminators() {
    return this._mightContainUnusualLineTerminators;
  }
  resetMightContainUnusualLineTerminators() {
    this._mightContainUnusualLineTerminators = !1;
  }
  mightContainNonBasicASCII() {
    return this._mightContainNonBasicASCII;
  }
  getBOM() {
    return this._BOM;
  }
  getEOL() {
    return this._pieceTree.getEOL();
  }
  createSnapshot(e) {
    return this._pieceTree.createSnapshot(e ? this._BOM : "");
  }
  getOffsetAt(e, t) {
    return this._pieceTree.getOffsetAt(e, t);
  }
  getPositionAt(e) {
    return this._pieceTree.getPositionAt(e);
  }
  getRangeAt(e, t) {
    const i = e + t, n = this.getPositionAt(e), s = this.getPositionAt(i);
    return new L(n.lineNumber, n.column, s.lineNumber, s.column);
  }
  getValueInRange(e, t = 0) {
    if (e.isEmpty())
      return "";
    const i = this._getEndOfLine(t);
    return this._pieceTree.getValueInRange(e, i);
  }
  getValueLengthInRange(e, t = 0) {
    if (e.isEmpty())
      return 0;
    if (e.startLineNumber === e.endLineNumber)
      return e.endColumn - e.startColumn;
    const i = this.getOffsetAt(e.startLineNumber, e.startColumn), n = this.getOffsetAt(e.endLineNumber, e.endColumn);
    let s = 0;
    const o = this._getEndOfLine(t), a = this.getEOL();
    if (o.length !== a.length) {
      const l = o.length - a.length, d = e.endLineNumber - e.startLineNumber;
      s = l * d;
    }
    return n - i + s;
  }
  getCharacterCountInRange(e, t = 0) {
    if (this._mightContainNonBasicASCII) {
      let i = 0;
      const n = e.startLineNumber, s = e.endLineNumber;
      for (let o = n; o <= s; o++) {
        const a = this.getLineContent(o), l = o === n ? e.startColumn - 1 : 0, d = o === s ? e.endColumn - 1 : a.length;
        for (let c = l; c < d; c++)
          $n(a.charCodeAt(c)) ? (i = i + 1, c = c + 1) : i = i + 1;
      }
      return i += this._getEndOfLine(t).length * (s - n), i;
    }
    return this.getValueLengthInRange(e, t);
  }
  getLength() {
    return this._pieceTree.getLength();
  }
  getLineCount() {
    return this._pieceTree.getLineCount();
  }
  getLinesContent() {
    return this._pieceTree.getLinesContent();
  }
  getLineContent(e) {
    return this._pieceTree.getLineContent(e);
  }
  getLineCharCode(e, t) {
    return this._pieceTree.getLineCharCode(e, t);
  }
  getLineLength(e) {
    return this._pieceTree.getLineLength(e);
  }
  getLineFirstNonWhitespaceColumn(e) {
    const t = ns(this.getLineContent(e));
    return t === -1 ? 0 : t + 1;
  }
  getLineLastNonWhitespaceColumn(e) {
    const t = ja(this.getLineContent(e));
    return t === -1 ? 0 : t + 2;
  }
  _getEndOfLine(e) {
    switch (e) {
      case 1:
        return `
`;
      case 2:
        return `\r
`;
      case 0:
        return this.getEOL();
      default:
        throw new Error("Unknown EOL preference");
    }
  }
  setEOL(e) {
    this._pieceTree.setEOL(e);
  }
  applyEdits(e, t, i) {
    let n = this._mightContainRTL, s = this._mightContainUnusualLineTerminators, o = this._mightContainNonBasicASCII, a = !0, l = [];
    for (let m = 0; m < e.length; m++) {
      const _ = e[m];
      a && _._isTracked && (a = !1);
      const v = _.range;
      if (_.text) {
        let y = !0;
        o || (y = !e0(_.text), o = y), !n && y && (n = Of(_.text)), !s && y && (s = eH(_.text));
      }
      let b = "", C = 0, w = 0, S = 0;
      if (_.text) {
        let y;
        [C, w, S, y] = Oc(_.text);
        const k = this.getEOL();
        y === 0 || y === (k === `\r
` ? 2 : 1) ? b = _.text : b = _.text.replace(/\r\n|\r|\n/g, k);
      }
      l[m] = {
        sortIndex: m,
        identifier: _.identifier || null,
        range: v,
        rangeOffset: this.getOffsetAt(v.startLineNumber, v.startColumn),
        rangeLength: this.getValueLengthInRange(v),
        text: b,
        eolCount: C,
        firstLineLength: w,
        lastLineLength: S,
        forceMoveMarkers: !!_.forceMoveMarkers,
        isAutoWhitespaceEdit: _.isAutoWhitespaceEdit || !1
      };
    }
    l.sort(Df._sortOpsAscending);
    let d = !1;
    for (let m = 0, _ = l.length - 1; m < _; m++) {
      const v = l[m].range.getEndPosition(), b = l[m + 1].range.getStartPosition();
      if (b.isBeforeOrEqual(v)) {
        if (b.isBefore(v))
          throw new Error("Overlapping ranges are not allowed!");
        d = !0;
      }
    }
    a && (l = this._reduceOperations(l));
    const c = i || t ? Df._getInverseEditRanges(l) : [], h = [];
    if (t)
      for (let m = 0; m < l.length; m++) {
        const _ = l[m], v = c[m];
        if (_.isAutoWhitespaceEdit && _.range.isEmpty())
          for (let b = v.startLineNumber; b <= v.endLineNumber; b++) {
            let C = "";
            b === v.startLineNumber && (C = this.getLineContent(_.range.startLineNumber), ns(C) !== -1) || h.push({ lineNumber: b, oldContent: C });
          }
      }
    let u = null;
    if (i) {
      let m = 0;
      u = [];
      for (let _ = 0; _ < l.length; _++) {
        const v = l[_], b = c[_], C = this.getValueInRange(v.range), w = v.rangeOffset + m;
        m += v.text.length - C.length, u[_] = {
          sortIndex: v.sortIndex,
          identifier: v.identifier,
          range: b,
          text: C,
          textChange: new wn(v.rangeOffset, C, w, v.text)
        };
      }
      d || u.sort((_, v) => _.sortIndex - v.sortIndex);
    }
    this._mightContainRTL = n, this._mightContainUnusualLineTerminators = s, this._mightContainNonBasicASCII = o;
    const g = this._doApplyEdits(l);
    let f = null;
    if (t && h.length > 0) {
      h.sort((m, _) => _.lineNumber - m.lineNumber), f = [];
      for (let m = 0, _ = h.length; m < _; m++) {
        const v = h[m].lineNumber;
        if (m > 0 && h[m - 1].lineNumber === v)
          continue;
        const b = h[m].oldContent, C = this.getLineContent(v);
        C.length === 0 || C === b || ns(C) !== -1 || f.push(v);
      }
    }
    return this._onDidChangeContent.fire(), new y5(u, g, f);
  }
  /**
   * Transform operations such that they represent the same logic edit,
   * but that they also do not cause OOM crashes.
   */
  _reduceOperations(e) {
    return e.length < 1e3 ? e : [this._toSingleEditOperation(e)];
  }
  _toSingleEditOperation(e) {
    let t = !1;
    const i = e[0].range, n = e[e.length - 1].range, s = new L(i.startLineNumber, i.startColumn, n.endLineNumber, n.endColumn);
    let o = i.startLineNumber, a = i.startColumn;
    const l = [];
    for (let g = 0, f = e.length; g < f; g++) {
      const m = e[g], _ = m.range;
      t = t || m.forceMoveMarkers, l.push(this.getValueInRange(new L(o, a, _.startLineNumber, _.startColumn))), m.text.length > 0 && l.push(m.text), o = _.endLineNumber, a = _.endColumn;
    }
    const d = l.join(""), [c, h, u] = Oc(d);
    return {
      sortIndex: 0,
      identifier: e[0].identifier,
      range: s,
      rangeOffset: this.getOffsetAt(s.startLineNumber, s.startColumn),
      rangeLength: this.getValueLengthInRange(
        s,
        0
        /* EndOfLinePreference.TextDefined */
      ),
      text: d,
      eolCount: c,
      firstLineLength: h,
      lastLineLength: u,
      forceMoveMarkers: t,
      isAutoWhitespaceEdit: !1
    };
  }
  _doApplyEdits(e) {
    e.sort(Df._sortOpsDescending);
    const t = [];
    for (let i = 0; i < e.length; i++) {
      const n = e[i], s = n.range.startLineNumber, o = n.range.startColumn, a = n.range.endLineNumber, l = n.range.endColumn;
      if (s === a && o === l && n.text.length === 0)
        continue;
      n.text ? (this._pieceTree.delete(n.rangeOffset, n.rangeLength), this._pieceTree.insert(n.rangeOffset, n.text, !0)) : this._pieceTree.delete(n.rangeOffset, n.rangeLength);
      const d = new L(s, o, a, l);
      t.push({
        range: d,
        rangeLength: n.rangeLength,
        text: n.text,
        rangeOffset: n.rangeOffset,
        forceMoveMarkers: n.forceMoveMarkers
      });
    }
    return t;
  }
  findMatchesLineByLine(e, t, i, n) {
    return this._pieceTree.findMatchesLineByLine(e, t, i, n);
  }
  /**
   * Assumes `operations` are validated and sorted ascending
   */
  static _getInverseEditRanges(e) {
    const t = [];
    let i = 0, n = 0, s = null;
    for (let o = 0, a = e.length; o < a; o++) {
      const l = e[o];
      let d, c;
      s ? s.range.endLineNumber === l.range.startLineNumber ? (d = i, c = n + (l.range.startColumn - s.range.endColumn)) : (d = i + (l.range.startLineNumber - s.range.endLineNumber), c = l.range.startColumn) : (d = l.range.startLineNumber, c = l.range.startColumn);
      let h;
      if (l.text.length > 0) {
        const u = l.eolCount + 1;
        u === 1 ? h = new L(d, c, d, c + l.firstLineLength) : h = new L(d, c, d + u - 1, l.lastLineLength + 1);
      } else
        h = new L(d, c, d, c);
      i = h.endLineNumber, n = h.endColumn, t.push(h), s = l;
    }
    return t;
  }
  static _sortOpsAscending(e, t) {
    const i = L.compareRangesUsingEnds(e.range, t.range);
    return i === 0 ? e.sortIndex - t.sortIndex : i;
  }
  static _sortOpsDescending(e, t) {
    const i = L.compareRangesUsingEnds(e.range, t.range);
    return i === 0 ? t.sortIndex - e.sortIndex : -i;
  }
}
class PQ {
  constructor(e, t, i, n, s, o, a, l, d) {
    this._chunks = e, this._bom = t, this._cr = i, this._lf = n, this._crlf = s, this._containsRTL = o, this._containsUnusualLineTerminators = a, this._isBasicASCII = l, this._normalizeEOL = d;
  }
  _getEOL(e) {
    const t = this._cr + this._lf + this._crlf, i = this._cr + this._crlf;
    return t === 0 ? e === 1 ? `
` : `\r
` : i > t / 2 ? `\r
` : `
`;
  }
  create(e) {
    const t = this._getEOL(e), i = this._chunks;
    if (this._normalizeEOL && (t === `\r
` && (this._cr > 0 || this._lf > 0) || t === `
` && (this._cr > 0 || this._crlf > 0)))
      for (let s = 0, o = i.length; s < o; s++) {
        const a = i[s].buffer.replace(/\r\n|\r|\n/g, t), l = Dl(a);
        i[s] = new Uh(a, l);
      }
    const n = new Df(i, this._bom, t, this._containsRTL, this._containsUnusualLineTerminators, this._isBasicASCII, this._normalizeEOL);
    return { textBuffer: n, disposable: n };
  }
}
class M2 {
  constructor() {
    this.chunks = [], this.BOM = "", this._hasPreviousChar = !1, this._previousChar = 0, this._tmpLineStarts = [], this.cr = 0, this.lf = 0, this.crlf = 0, this.containsRTL = !1, this.containsUnusualLineTerminators = !1, this.isBasicASCII = !0;
  }
  acceptChunk(e) {
    if (e.length === 0)
      return;
    this.chunks.length === 0 && UN(e) && (this.BOM = L5, e = e.substr(1));
    const t = e.charCodeAt(e.length - 1);
    t === 13 || t >= 55296 && t <= 56319 ? (this._acceptChunk1(e.substr(0, e.length - 1), !1), this._hasPreviousChar = !0, this._previousChar = t) : (this._acceptChunk1(e, !1), this._hasPreviousChar = !1, this._previousChar = t);
  }
  _acceptChunk1(e, t) {
    !t && e.length === 0 || (this._hasPreviousChar ? this._acceptChunk2(String.fromCharCode(this._previousChar) + e) : this._acceptChunk2(e));
  }
  _acceptChunk2(e) {
    const t = NQ(this._tmpLineStarts, e);
    this.chunks.push(new Uh(e, t.lineStarts)), this.cr += t.cr, this.lf += t.lf, this.crlf += t.crlf, t.isBasicASCII || (this.isBasicASCII = !1, this.containsRTL || (this.containsRTL = Of(e)), this.containsUnusualLineTerminators || (this.containsUnusualLineTerminators = eH(e)));
  }
  finish(e = !0) {
    return this._finish(), new PQ(this.chunks, this.BOM, this.cr, this.lf, this.crlf, this.containsRTL, this.containsUnusualLineTerminators, this.isBasicASCII, e);
  }
  _finish() {
    if (this.chunks.length === 0 && this._acceptChunk1("", !0), this._hasPreviousChar) {
      this._hasPreviousChar = !1;
      const e = this.chunks[this.chunks.length - 1];
      e.buffer += String.fromCharCode(this._previousChar);
      const t = Dl(e.buffer);
      e.lineStarts = t, this._previousChar === 13 && this.cr++;
    }
  }
}
class OQ {
  constructor(e) {
    this._default = e, this._store = [];
  }
  get(e) {
    return e < this._store.length ? this._store[e] : this._default;
  }
  set(e, t) {
    for (; e >= this._store.length; )
      this._store[this._store.length] = this._default;
    this._store[e] = t;
  }
  replace(e, t, i) {
    if (e >= this._store.length)
      return;
    if (t === 0) {
      this.insert(e, i);
      return;
    } else if (i === 0) {
      this.delete(e, t);
      return;
    }
    const n = this._store.slice(0, e), s = this._store.slice(e + t), o = FQ(i, this._default);
    this._store = n.concat(o, s);
  }
  delete(e, t) {
    t === 0 || e >= this._store.length || this._store.splice(e, t);
  }
  insert(e, t) {
    if (t === 0 || e >= this._store.length)
      return;
    const i = [];
    for (let n = 0; n < t; n++)
      i[n] = this._default;
    this._store = jN(this._store, e, i);
  }
}
function FQ(r, e) {
  const t = [];
  for (let i = 0; i < r; i++)
    t[i] = e;
  return t;
}
class WQ {
  /**
   * (Inclusive) start line number for these tokens.
   */
  get startLineNumber() {
    return this._startLineNumber;
  }
  /**
   * (Inclusive) end line number for these tokens.
   */
  get endLineNumber() {
    return this._startLineNumber + this._tokens.length - 1;
  }
  constructor(e, t) {
    this._startLineNumber = e, this._tokens = t;
  }
  /**
   * @see {@link _tokens}
   */
  getLineTokens(e) {
    return this._tokens[e - this._startLineNumber];
  }
  appendLineTokens(e) {
    this._tokens.push(e);
  }
}
class cI {
  constructor() {
    this._tokens = [];
  }
  add(e, t) {
    if (this._tokens.length > 0) {
      const i = this._tokens[this._tokens.length - 1];
      if (i.endLineNumber + 1 === e) {
        i.appendLineTokens(t);
        return;
      }
    }
    this._tokens.push(new WQ(e, [t]));
  }
  finalize() {
    return this._tokens;
  }
}
class BQ {
  constructor(e, t) {
    this.tokenizationSupport = t, this.initialState = this.tokenizationSupport.getInitialState(), this.store = new hI(e);
  }
  getStartState(e) {
    return this.store.getStartState(e, this.initialState);
  }
  getFirstInvalidLine() {
    return this.store.getFirstInvalidLine(this.initialState);
  }
}
class HQ extends BQ {
  constructor(e, t, i, n) {
    super(e, t), this._textModel = i, this._languageIdCodec = n;
  }
  updateTokensUntilLine(e, t) {
    const i = this._textModel.getLanguageId();
    for (; ; ) {
      const n = this.getFirstInvalidLine();
      if (!n || n.lineNumber > t)
        break;
      const s = this._textModel.getLineContent(n.lineNumber), o = sm(this._languageIdCodec, i, this.tokenizationSupport, s, !0, n.startState);
      e.add(n.lineNumber, o.tokens), this.store.setEndState(n.lineNumber, o.endState);
    }
  }
  /** assumes state is up to date */
  getTokenTypeIfInsertingCharacter(e, t) {
    const i = this.getStartState(e.lineNumber);
    if (!i)
      return 0;
    const n = this._textModel.getLanguageId(), s = this._textModel.getLineContent(e.lineNumber), o = s.substring(0, e.column - 1) + t + s.substring(e.column - 1), a = sm(this._languageIdCodec, n, this.tokenizationSupport, o, !0, i), l = new Ri(a.tokens, o, this._languageIdCodec);
    if (l.getCount() === 0)
      return 0;
    const d = l.findTokenIndexAtOffset(e.column - 1);
    return l.getStandardTokenType(d);
  }
  /** assumes state is up to date */
  tokenizeLineWithEdit(e, t, i) {
    const n = e.lineNumber, s = e.column, o = this.getStartState(n);
    if (!o)
      return null;
    const a = this._textModel.getLineContent(n), l = a.substring(0, s - 1) + i + a.substring(s - 1 + t), d = this._textModel.getLanguageIdAtPosition(n, 0), c = sm(this._languageIdCodec, d, this.tokenizationSupport, l, !0, o);
    return new Ri(c.tokens, l, this._languageIdCodec);
  }
  hasAccurateTokensForLine(e) {
    const t = this.store.getFirstInvalidEndStateLineNumberOrMax();
    return e < t;
  }
  isCheapToTokenize(e) {
    const t = this.store.getFirstInvalidEndStateLineNumberOrMax();
    return e < t || e === t && this._textModel.getLineLength(e) < 2048;
  }
  /**
   * The result is not cached.
   */
  tokenizeHeuristically(e, t, i) {
    if (i <= this.store.getFirstInvalidEndStateLineNumberOrMax())
      return { heuristicTokens: !1 };
    if (t <= this.store.getFirstInvalidEndStateLineNumberOrMax())
      return this.updateTokensUntilLine(e, i), { heuristicTokens: !1 };
    let n = this.guessStartState(t);
    const s = this._textModel.getLanguageId();
    for (let o = t; o <= i; o++) {
      const a = this._textModel.getLineContent(o), l = sm(this._languageIdCodec, s, this.tokenizationSupport, a, !0, n);
      e.add(o, l.tokens), n = l.endState;
    }
    return { heuristicTokens: !0 };
  }
  guessStartState(e) {
    let t = this._textModel.getLineFirstNonWhitespaceColumn(e);
    const i = [];
    let n = null;
    for (let a = e - 1; t > 1 && a >= 1; a--) {
      const l = this._textModel.getLineFirstNonWhitespaceColumn(a);
      if (l !== 0 && l < t && (i.push(this._textModel.getLineContent(a)), t = l, n = this.getStartState(a), n))
        break;
    }
    n || (n = this.tokenizationSupport.getInitialState()), i.reverse();
    const s = this._textModel.getLanguageId();
    let o = n;
    for (const a of i)
      o = sm(this._languageIdCodec, s, this.tokenizationSupport, a, !1, o).endState;
    return o;
  }
}
class hI {
  constructor(e) {
    this.lineCount = e, this._tokenizationStateStore = new VQ(), this._invalidEndStatesLineNumbers = new zQ(), this._invalidEndStatesLineNumbers.addRange(new tn(1, e + 1));
  }
  getEndState(e) {
    return this._tokenizationStateStore.getEndState(e);
  }
  /**
   * @returns if the end state has changed.
   */
  setEndState(e, t) {
    if (!t)
      throw new Li("Cannot set null/undefined state");
    this._invalidEndStatesLineNumbers.delete(e);
    const i = this._tokenizationStateStore.setEndState(e, t);
    return i && e < this.lineCount && this._invalidEndStatesLineNumbers.addRange(new tn(e + 1, e + 2)), i;
  }
  acceptChange(e, t) {
    this.lineCount += t - e.length, this._tokenizationStateStore.acceptChange(e, t), this._invalidEndStatesLineNumbers.addRangeAndResize(new tn(e.startLineNumber, e.endLineNumberExclusive), t);
  }
  acceptChanges(e) {
    for (const t of e) {
      const [i] = Oc(t.text);
      this.acceptChange(new Yt(t.range.startLineNumber, t.range.endLineNumber + 1), i + 1);
    }
  }
  invalidateEndStateRange(e) {
    this._invalidEndStatesLineNumbers.addRange(new tn(e.startLineNumber, e.endLineNumberExclusive));
  }
  getFirstInvalidEndStateLineNumber() {
    return this._invalidEndStatesLineNumbers.min;
  }
  getFirstInvalidEndStateLineNumberOrMax() {
    return this.getFirstInvalidEndStateLineNumber() || Number.MAX_SAFE_INTEGER;
  }
  allStatesValid() {
    return this._invalidEndStatesLineNumbers.min === null;
  }
  getStartState(e, t) {
    return e === 1 ? t : this.getEndState(e - 1);
  }
  getFirstInvalidLine(e) {
    const t = this.getFirstInvalidEndStateLineNumber();
    if (t === null)
      return null;
    const i = this.getStartState(t, e);
    if (!i)
      throw new Li("Start state must be defined");
    return { lineNumber: t, startState: i };
  }
}
class VQ {
  constructor() {
    this._lineEndStates = new OQ(null);
  }
  getEndState(e) {
    return this._lineEndStates.get(e);
  }
  setEndState(e, t) {
    const i = this._lineEndStates.get(e);
    return i && i.equals(t) ? !1 : (this._lineEndStates.set(e, t), !0);
  }
  acceptChange(e, t) {
    let i = e.length;
    t > 0 && i > 0 && (i--, t--), this._lineEndStates.replace(e.startLineNumber, i, t);
  }
}
class zQ {
  constructor() {
    this._ranges = [];
  }
  get min() {
    return this._ranges.length === 0 ? null : this._ranges[0].start;
  }
  delete(e) {
    const t = this._ranges.findIndex((i) => i.contains(e));
    if (t !== -1) {
      const i = this._ranges[t];
      i.start === e ? i.endExclusive === e + 1 ? this._ranges.splice(t, 1) : this._ranges[t] = new tn(e + 1, i.endExclusive) : i.endExclusive === e + 1 ? this._ranges[t] = new tn(i.start, e) : this._ranges.splice(t, 1, new tn(i.start, e), new tn(e + 1, i.endExclusive));
    }
  }
  addRange(e) {
    tn.addRange(e, this._ranges);
  }
  addRangeAndResize(e, t) {
    let i = 0;
    for (; !(i >= this._ranges.length || e.start <= this._ranges[i].endExclusive); )
      i++;
    let n = i;
    for (; !(n >= this._ranges.length || e.endExclusive < this._ranges[n].start); )
      n++;
    const s = t - e.length;
    for (let o = n; o < this._ranges.length; o++)
      this._ranges[o] = this._ranges[o].delta(s);
    if (i === n) {
      const o = new tn(e.start, e.start + t);
      o.isEmpty || this._ranges.splice(i, 0, o);
    } else {
      const o = Math.min(e.start, this._ranges[i].start), a = Math.max(e.endExclusive, this._ranges[n - 1].endExclusive), l = new tn(o, a + s);
      l.isEmpty ? this._ranges.splice(i, n - i) : this._ranges.splice(i, n - i, l);
    }
  }
  toString() {
    return this._ranges.map((e) => e.toString()).join(" + ");
  }
}
function sm(r, e, t, i, n, s) {
  let o = null;
  if (t)
    try {
      o = t.tokenizeEncoded(i, n, s.clone());
    } catch (a) {
      He(a);
    }
  return o || (o = S0(r.encodeLanguageId(e), s)), Ri.convertToEndOffset(o.tokens, i.length), o;
}
class UQ {
  constructor(e, t) {
    this._tokenizerWithStateStore = e, this._backgroundTokenStore = t, this._isDisposed = !1, this._isScheduled = !1;
  }
  dispose() {
    this._isDisposed = !0;
  }
  handleChanges() {
    this._beginBackgroundTokenization();
  }
  _beginBackgroundTokenization() {
    this._isScheduled || !this._tokenizerWithStateStore._textModel.isAttachedToEditor() || !this._hasLinesToTokenize() || (this._isScheduled = !0, xH((e) => {
      this._isScheduled = !1, this._backgroundTokenizeWithDeadline(e);
    }));
  }
  /**
   * Tokenize until the deadline occurs, but try to yield every 1-2ms.
   */
  _backgroundTokenizeWithDeadline(e) {
    const t = Date.now() + e.timeRemaining(), i = () => {
      this._isDisposed || !this._tokenizerWithStateStore._textModel.isAttachedToEditor() || !this._hasLinesToTokenize() || (this._backgroundTokenizeForAtLeast1ms(), Date.now() < t ? UB(i) : this._beginBackgroundTokenization());
    };
    i();
  }
  /**
   * Tokenize for at least 1ms.
   */
  _backgroundTokenizeForAtLeast1ms() {
    const e = this._tokenizerWithStateStore._textModel.getLineCount(), t = new cI(), i = rs.create(!1);
    do
      if (i.elapsed() > 1 || this._tokenizeOneInvalidLine(t) >= e)
        break;
    while (this._hasLinesToTokenize());
    this._backgroundTokenStore.setTokens(t.finalize()), this.checkFinished();
  }
  _hasLinesToTokenize() {
    return this._tokenizerWithStateStore ? !this._tokenizerWithStateStore.store.allStatesValid() : !1;
  }
  _tokenizeOneInvalidLine(e) {
    var t;
    const i = (t = this._tokenizerWithStateStore) === null || t === void 0 ? void 0 : t.getFirstInvalidLine();
    return i ? (this._tokenizerWithStateStore.updateTokensUntilLine(e, i.lineNumber), i.lineNumber) : this._tokenizerWithStateStore._textModel.getLineCount() + 1;
  }
  checkFinished() {
    this._isDisposed || this._tokenizerWithStateStore.store.allStatesValid() && this._backgroundTokenStore.backgroundTokenizationFinished();
  }
  requestTokens(e, t) {
    this._tokenizerWithStateStore.store.invalidateEndStateRange(new Yt(e, t));
  }
}
const kl = new Uint32Array(0).buffer;
class ka {
  static deleteBeginning(e, t) {
    return e === null || e === kl ? e : ka.delete(e, 0, t);
  }
  static deleteEnding(e, t) {
    if (e === null || e === kl)
      return e;
    const i = Ol(e), n = i[i.length - 2];
    return ka.delete(e, t, n);
  }
  static delete(e, t, i) {
    if (e === null || e === kl || t === i)
      return e;
    const n = Ol(e), s = n.length >>> 1;
    if (t === 0 && n[n.length - 2] === i)
      return kl;
    const o = Ri.findIndexInTokensArray(n, t), a = o > 0 ? n[o - 1 << 1] : 0, l = n[o << 1];
    if (i < l) {
      const g = i - t;
      for (let f = o; f < s; f++)
        n[f << 1] -= g;
      return e;
    }
    let d, c;
    a !== t ? (n[o << 1] = t, d = o + 1 << 1, c = t) : (d = o << 1, c = a);
    const h = i - t;
    for (let g = o + 1; g < s; g++) {
      const f = n[g << 1] - h;
      f > c && (n[d++] = f, n[d++] = n[(g << 1) + 1], c = f);
    }
    if (d === n.length)
      return e;
    const u = new Uint32Array(d);
    return u.set(n.subarray(0, d), 0), u.buffer;
  }
  static append(e, t) {
    if (t === kl)
      return e;
    if (e === kl)
      return t;
    if (e === null)
      return e;
    if (t === null)
      return null;
    const i = Ol(e), n = Ol(t), s = n.length >>> 1, o = new Uint32Array(i.length + n.length);
    o.set(i, 0);
    let a = i.length;
    const l = i[i.length - 2];
    for (let d = 0; d < s; d++)
      o[a++] = n[d << 1] + l, o[a++] = n[(d << 1) + 1];
    return o.buffer;
  }
  static insert(e, t, i) {
    if (e === null || e === kl)
      return e;
    const n = Ol(e), s = n.length >>> 1;
    let o = Ri.findIndexInTokensArray(n, t);
    o > 0 && n[o - 1 << 1] === t && o--;
    for (let a = o; a < s; a++)
      n[a << 1] += i;
    return e;
  }
}
function Ol(r) {
  return r instanceof Uint32Array ? r : new Uint32Array(r);
}
class ev {
  constructor(e) {
    this._lineTokens = [], this._len = 0, this._languageIdCodec = e;
  }
  flush() {
    this._lineTokens = [], this._len = 0;
  }
  get hasTokens() {
    return this._lineTokens.length > 0;
  }
  getTokens(e, t, i) {
    let n = null;
    if (t < this._len && (n = this._lineTokens[t]), n !== null && n !== kl)
      return new Ri(Ol(n), i, this._languageIdCodec);
    const s = new Uint32Array(2);
    return s[0] = i.length, s[1] = eO(this._languageIdCodec.encodeLanguageId(e)), new Ri(s, i, this._languageIdCodec);
  }
  static _massageTokens(e, t, i) {
    const n = i ? Ol(i) : null;
    if (t === 0) {
      let s = !1;
      if (n && n.length > 1 && (s = yn.getLanguageId(n[1]) !== e), !s)
        return kl;
    }
    if (!n || n.length === 0) {
      const s = new Uint32Array(2);
      return s[0] = t, s[1] = eO(e), s.buffer;
    }
    return n[n.length - 2] = t, n.byteOffset === 0 && n.byteLength === n.buffer.byteLength ? n.buffer : n;
  }
  _ensureLine(e) {
    for (; e >= this._len; )
      this._lineTokens[this._len] = null, this._len++;
  }
  _deleteLines(e, t) {
    t !== 0 && (e + t > this._len && (t = this._len - e), this._lineTokens.splice(e, t), this._len -= t);
  }
  _insertLines(e, t) {
    if (t === 0)
      return;
    const i = [];
    for (let n = 0; n < t; n++)
      i[n] = null;
    this._lineTokens = jN(this._lineTokens, e, i), this._len += t;
  }
  setTokens(e, t, i, n, s) {
    const o = ev._massageTokens(this._languageIdCodec.encodeLanguageId(e), i, n);
    this._ensureLine(t);
    const a = this._lineTokens[t];
    return this._lineTokens[t] = o, s ? !ev._equals(a, o) : !1;
  }
  static _equals(e, t) {
    if (!e || !t)
      return !e && !t;
    const i = Ol(e), n = Ol(t);
    if (i.length !== n.length)
      return !1;
    for (let s = 0, o = i.length; s < o; s++)
      if (i[s] !== n[s])
        return !1;
    return !0;
  }
  //#region Editing
  acceptEdit(e, t, i) {
    this._acceptDeleteRange(e), this._acceptInsertText(new A(e.startLineNumber, e.startColumn), t, i);
  }
  _acceptDeleteRange(e) {
    const t = e.startLineNumber - 1;
    if (t >= this._len)
      return;
    if (e.startLineNumber === e.endLineNumber) {
      if (e.startColumn === e.endColumn)
        return;
      this._lineTokens[t] = ka.delete(this._lineTokens[t], e.startColumn - 1, e.endColumn - 1);
      return;
    }
    this._lineTokens[t] = ka.deleteEnding(this._lineTokens[t], e.startColumn - 1);
    const i = e.endLineNumber - 1;
    let n = null;
    i < this._len && (n = ka.deleteBeginning(this._lineTokens[i], e.endColumn - 1)), this._lineTokens[t] = ka.append(this._lineTokens[t], n), this._deleteLines(e.startLineNumber, e.endLineNumber - e.startLineNumber);
  }
  _acceptInsertText(e, t, i) {
    if (t === 0 && i === 0)
      return;
    const n = e.lineNumber - 1;
    if (!(n >= this._len)) {
      if (t === 0) {
        this._lineTokens[n] = ka.insert(this._lineTokens[n], e.column - 1, i);
        return;
      }
      this._lineTokens[n] = ka.deleteEnding(this._lineTokens[n], e.column - 1), this._lineTokens[n] = ka.insert(this._lineTokens[n], e.column - 1, i), this._insertLines(e.lineNumber, t);
    }
  }
  //#endregion
  setMultilineTokens(e, t) {
    if (e.length === 0)
      return { changes: [] };
    const i = [];
    for (let n = 0, s = e.length; n < s; n++) {
      const o = e[n];
      let a = 0, l = 0, d = !1;
      for (let c = o.startLineNumber; c <= o.endLineNumber; c++)
        d ? (this.setTokens(t.getLanguageId(), c - 1, t.getLineLength(c), o.getLineTokens(c), !1), l = c) : this.setTokens(t.getLanguageId(), c - 1, t.getLineLength(c), o.getLineTokens(c), !0) && (d = !0, a = c, l = c);
      d && i.push({ fromLineNumber: a, toLineNumber: l });
    }
    return { changes: i };
  }
}
function eO(r) {
  return (r << 0 | 0 | 0 | 32768 | 2 << 24 | 1024) >>> 0;
}
class $1 {
  constructor(e) {
    this._pieces = [], this._isComplete = !1, this._languageIdCodec = e;
  }
  flush() {
    this._pieces = [], this._isComplete = !1;
  }
  isEmpty() {
    return this._pieces.length === 0;
  }
  set(e, t) {
    this._pieces = e || [], this._isComplete = t;
  }
  setPartial(e, t) {
    let i = e;
    if (t.length > 0) {
      const s = t[0].getRange(), o = t[t.length - 1].getRange();
      if (!s || !o)
        return e;
      i = e.plusRange(s).plusRange(o);
    }
    let n = null;
    for (let s = 0, o = this._pieces.length; s < o; s++) {
      const a = this._pieces[s];
      if (a.endLineNumber < i.startLineNumber)
        continue;
      if (a.startLineNumber > i.endLineNumber) {
        n = n || { index: s };
        break;
      }
      if (a.removeTokens(i), a.isEmpty()) {
        this._pieces.splice(s, 1), s--, o--;
        continue;
      }
      if (a.endLineNumber < i.startLineNumber)
        continue;
      if (a.startLineNumber > i.endLineNumber) {
        n = n || { index: s };
        continue;
      }
      const [l, d] = a.split(i);
      if (l.isEmpty()) {
        n = n || { index: s };
        continue;
      }
      d.isEmpty() || (this._pieces.splice(s, 1, l, d), s++, o++, n = n || { index: s });
    }
    return n = n || { index: this._pieces.length }, t.length > 0 && (this._pieces = jN(this._pieces, n.index, t)), i;
  }
  isComplete() {
    return this._isComplete;
  }
  addSparseTokens(e, t) {
    if (t.getLineContent().length === 0)
      return t;
    const i = this._pieces;
    if (i.length === 0)
      return t;
    const n = $1._findFirstPieceWithLine(i, e), s = i[n].getLineTokens(e);
    if (!s)
      return t;
    const o = t.getCount(), a = s.getCount();
    let l = 0;
    const d = [];
    let c = 0, h = 0;
    const u = (g, f) => {
      g !== h && (h = g, d[c++] = g, d[c++] = f);
    };
    for (let g = 0; g < a; g++) {
      const f = s.getStartCharacter(g), m = s.getEndCharacter(g), _ = s.getMetadata(g), v = ((_ & 1 ? 2048 : 0) | (_ & 2 ? 4096 : 0) | (_ & 4 ? 8192 : 0) | (_ & 8 ? 16384 : 0) | (_ & 16 ? 16744448 : 0) | (_ & 32 ? 4278190080 : 0)) >>> 0, b = ~v >>> 0;
      for (; l < o && t.getEndOffset(l) <= f; )
        u(t.getEndOffset(l), t.getMetadata(l)), l++;
      for (l < o && t.getStartOffset(l) < f && u(f, t.getMetadata(l)); l < o && t.getEndOffset(l) < m; )
        u(t.getEndOffset(l), t.getMetadata(l) & b | _ & v), l++;
      if (l < o)
        u(m, t.getMetadata(l) & b | _ & v), t.getEndOffset(l) === m && l++;
      else {
        const C = Math.min(Math.max(0, l - 1), o - 1);
        u(m, t.getMetadata(C) & b | _ & v);
      }
    }
    for (; l < o; )
      u(t.getEndOffset(l), t.getMetadata(l)), l++;
    return new Ri(new Uint32Array(d), t.getLineContent(), this._languageIdCodec);
  }
  static _findFirstPieceWithLine(e, t) {
    let i = 0, n = e.length - 1;
    for (; i < n; ) {
      let s = i + Math.floor((n - i) / 2);
      if (e[s].endLineNumber < t)
        i = s + 1;
      else if (e[s].startLineNumber > t)
        n = s - 1;
      else {
        for (; s > i && e[s - 1].startLineNumber <= t && t <= e[s - 1].endLineNumber; )
          s--;
        return s;
      }
    }
    return i;
  }
  acceptEdit(e, t, i, n, s) {
    for (const o of this._pieces)
      o.acceptEdit(e, t, i, n, s);
  }
}
class TS extends c2 {
  constructor(e, t, i, n, s, o) {
    super(), this._languageService = e, this._languageConfigurationService = t, this._textModel = i, this._bracketPairsTextModelPart = n, this._languageId = s, this._attachedViews = o, this._semanticTokens = new $1(this._languageService.languageIdCodec), this._onDidChangeLanguage = this._register(new R()), this.onDidChangeLanguage = this._onDidChangeLanguage.event, this._onDidChangeLanguageConfiguration = this._register(new R()), this.onDidChangeLanguageConfiguration = this._onDidChangeLanguageConfiguration.event, this._onDidChangeTokens = this._register(new R()), this.onDidChangeTokens = this._onDidChangeTokens.event, this.grammarTokens = this._register(new $Q(this._languageService.languageIdCodec, this._textModel, () => this._languageId, this._attachedViews)), this._register(this._languageConfigurationService.onDidChange((a) => {
      a.affects(this._languageId) && this._onDidChangeLanguageConfiguration.fire({});
    })), this._register(this.grammarTokens.onDidChangeTokens((a) => {
      this._emitModelTokensChangedEvent(a);
    })), this._register(this.grammarTokens.onDidChangeBackgroundTokenizationState((a) => {
      this._bracketPairsTextModelPart.handleDidChangeBackgroundTokenizationState();
    }));
  }
  handleDidChangeContent(e) {
    if (e.isFlush)
      this._semanticTokens.flush();
    else if (!e.isEolChange)
      for (const t of e.changes) {
        const [i, n, s] = Oc(t.text);
        this._semanticTokens.acceptEdit(
          t.range,
          i,
          n,
          s,
          t.text.length > 0 ? t.text.charCodeAt(0) : 0
          /* CharCode.Null */
        );
      }
    this.grammarTokens.handleDidChangeContent(e);
  }
  handleDidChangeAttached() {
    this.grammarTokens.handleDidChangeAttached();
  }
  /**
   * Includes grammar and semantic tokens.
   */
  getLineTokens(e) {
    this.validateLineNumber(e);
    const t = this.grammarTokens.getLineTokens(e);
    return this._semanticTokens.addSparseTokens(e, t);
  }
  _emitModelTokensChangedEvent(e) {
    this._textModel._isDisposing() || (this._bracketPairsTextModelPart.handleDidChangeTokens(e), this._onDidChangeTokens.fire(e));
  }
  // #region Grammar Tokens
  validateLineNumber(e) {
    if (e < 1 || e > this._textModel.getLineCount())
      throw new Li("Illegal value for lineNumber");
  }
  get hasTokens() {
    return this.grammarTokens.hasTokens;
  }
  resetTokenization() {
    this.grammarTokens.resetTokenization();
  }
  get backgroundTokenizationState() {
    return this.grammarTokens.backgroundTokenizationState;
  }
  forceTokenization(e) {
    this.validateLineNumber(e), this.grammarTokens.forceTokenization(e);
  }
  hasAccurateTokensForLine(e) {
    return this.validateLineNumber(e), this.grammarTokens.hasAccurateTokensForLine(e);
  }
  isCheapToTokenize(e) {
    return this.validateLineNumber(e), this.grammarTokens.isCheapToTokenize(e);
  }
  tokenizeIfCheap(e) {
    this.validateLineNumber(e), this.grammarTokens.tokenizeIfCheap(e);
  }
  getTokenTypeIfInsertingCharacter(e, t, i) {
    return this.grammarTokens.getTokenTypeIfInsertingCharacter(e, t, i);
  }
  tokenizeLineWithEdit(e, t, i) {
    return this.grammarTokens.tokenizeLineWithEdit(e, t, i);
  }
  // #endregion
  // #region Semantic Tokens
  setSemanticTokens(e, t) {
    this._semanticTokens.set(e, t), this._emitModelTokensChangedEvent({
      semanticTokensApplied: e !== null,
      ranges: [{ fromLineNumber: 1, toLineNumber: this._textModel.getLineCount() }]
    });
  }
  hasCompleteSemanticTokens() {
    return this._semanticTokens.isComplete();
  }
  hasSomeSemanticTokens() {
    return !this._semanticTokens.isEmpty();
  }
  setPartialSemanticTokens(e, t) {
    if (this.hasCompleteSemanticTokens())
      return;
    const i = this._textModel.validateRange(this._semanticTokens.setPartial(e, t));
    this._emitModelTokensChangedEvent({
      semanticTokensApplied: !0,
      ranges: [
        {
          fromLineNumber: i.startLineNumber,
          toLineNumber: i.endLineNumber
        }
      ]
    });
  }
  // #endregion
  // #region Utility Methods
  getWordAtPosition(e) {
    this.assertNotDisposed();
    const t = this._textModel.validatePosition(e), i = this._textModel.getLineContent(t.lineNumber), n = this.getLineTokens(t.lineNumber), s = n.findTokenIndexAtOffset(t.column - 1), [o, a] = TS._findLanguageBoundaries(n, s), l = nA(t.column, this.getLanguageConfiguration(n.getLanguageId(s)).getWordDefinition(), i.substring(o, a), o);
    if (l && l.startColumn <= e.column && e.column <= l.endColumn)
      return l;
    if (s > 0 && o === t.column - 1) {
      const [d, c] = TS._findLanguageBoundaries(n, s - 1), h = nA(t.column, this.getLanguageConfiguration(n.getLanguageId(s - 1)).getWordDefinition(), i.substring(d, c), d);
      if (h && h.startColumn <= e.column && e.column <= h.endColumn)
        return h;
    }
    return null;
  }
  getLanguageConfiguration(e) {
    return this._languageConfigurationService.getLanguageConfiguration(e);
  }
  static _findLanguageBoundaries(e, t) {
    const i = e.getLanguageId(t);
    let n = 0;
    for (let o = t; o >= 0 && e.getLanguageId(o) === i; o--)
      n = e.getStartOffset(o);
    let s = e.getLineContent().length;
    for (let o = t, a = e.getCount(); o < a && e.getLanguageId(o) === i; o++)
      s = e.getEndOffset(o);
    return [n, s];
  }
  getWordUntilPosition(e) {
    const t = this.getWordAtPosition(e);
    return t ? {
      word: t.word.substr(0, e.column - t.startColumn),
      startColumn: t.startColumn,
      endColumn: e.column
    } : { word: "", startColumn: e.column, endColumn: e.column };
  }
  // #endregion
  // #region Language Id handling
  getLanguageId() {
    return this._languageId;
  }
  getLanguageIdAtPosition(e, t) {
    const i = this._textModel.validatePosition(new A(e, t)), n = this.getLineTokens(i.lineNumber);
    return n.getLanguageId(n.findTokenIndexAtOffset(i.column - 1));
  }
  setLanguageId(e, t = "api") {
    if (this._languageId === e)
      return;
    const i = {
      oldLanguage: this._languageId,
      newLanguage: e,
      source: t
    };
    this._languageId = e, this._bracketPairsTextModelPart.handleDidChangeLanguage(i), this.grammarTokens.resetTokenization(), this._onDidChangeLanguage.fire(i), this._onDidChangeLanguageConfiguration.fire({});
  }
}
class $Q extends P {
  get backgroundTokenizationState() {
    return this._backgroundTokenizationState;
  }
  constructor(e, t, i, n) {
    super(), this._languageIdCodec = e, this._textModel = t, this.getLanguageId = i, this._tokenizer = null, this._defaultBackgroundTokenizer = null, this._backgroundTokenizer = this._register(new Yi()), this._tokens = new ev(this._languageIdCodec), this._debugBackgroundTokenizer = this._register(new Yi()), this._backgroundTokenizationState = 1, this._onDidChangeBackgroundTokenizationState = this._register(new R()), this.onDidChangeBackgroundTokenizationState = this._onDidChangeBackgroundTokenizationState.event, this._onDidChangeTokens = this._register(new R()), this.onDidChangeTokens = this._onDidChangeTokens.event, this._attachedViewStates = this._register(new KN()), this._register(ri.onDidChange((s) => {
      const o = this.getLanguageId();
      s.changedLanguages.indexOf(o) !== -1 && this.resetTokenization();
    })), this.resetTokenization(), this._register(n.onDidChangeVisibleRanges(({ view: s, state: o }) => {
      if (o) {
        let a = this._attachedViewStates.get(s);
        a || (a = new KQ(() => this.refreshRanges(a.lineRanges)), this._attachedViewStates.set(s, a)), a.handleStateChange(o);
      } else
        this._attachedViewStates.deleteAndDispose(s);
    }));
  }
  resetTokenization(e = !0) {
    var t;
    this._tokens.flush(), (t = this._debugBackgroundTokens) === null || t === void 0 || t.flush(), this._debugBackgroundStates && (this._debugBackgroundStates = new hI(this._textModel.getLineCount())), e && this._onDidChangeTokens.fire({
      semanticTokensApplied: !1,
      ranges: [
        {
          fromLineNumber: 1,
          toLineNumber: this._textModel.getLineCount()
        }
      ]
    });
    const i = () => {
      if (this._textModel.isTooLargeForTokenization())
        return [null, null];
      const o = ri.get(this.getLanguageId());
      if (!o)
        return [null, null];
      let a;
      try {
        a = o.getInitialState();
      } catch (l) {
        return He(l), [null, null];
      }
      return [o, a];
    }, [n, s] = i();
    if (n && s ? this._tokenizer = new HQ(this._textModel.getLineCount(), n, this._textModel, this._languageIdCodec) : this._tokenizer = null, this._backgroundTokenizer.clear(), this._defaultBackgroundTokenizer = null, this._tokenizer) {
      const o = {
        setTokens: (a) => {
          this.setTokens(a);
        },
        backgroundTokenizationFinished: () => {
          if (this._backgroundTokenizationState === 2)
            return;
          const a = 2;
          this._backgroundTokenizationState = a, this._onDidChangeBackgroundTokenizationState.fire();
        },
        setEndState: (a, l) => {
          var d;
          if (!this._tokenizer)
            return;
          const c = this._tokenizer.store.getFirstInvalidEndStateLineNumber();
          c !== null && a >= c && ((d = this._tokenizer) === null || d === void 0 || d.store.setEndState(a, l));
        }
      };
      n && n.createBackgroundTokenizer && !n.backgroundTokenizerShouldOnlyVerifyTokens && (this._backgroundTokenizer.value = n.createBackgroundTokenizer(this._textModel, o)), !this._backgroundTokenizer.value && !this._textModel.isTooLargeForTokenization() && (this._backgroundTokenizer.value = this._defaultBackgroundTokenizer = new UQ(this._tokenizer, o), this._defaultBackgroundTokenizer.handleChanges()), n != null && n.backgroundTokenizerShouldOnlyVerifyTokens && n.createBackgroundTokenizer ? (this._debugBackgroundTokens = new ev(this._languageIdCodec), this._debugBackgroundStates = new hI(this._textModel.getLineCount()), this._debugBackgroundTokenizer.clear(), this._debugBackgroundTokenizer.value = n.createBackgroundTokenizer(this._textModel, {
        setTokens: (a) => {
          var l;
          (l = this._debugBackgroundTokens) === null || l === void 0 || l.setMultilineTokens(a, this._textModel);
        },
        backgroundTokenizationFinished() {
        },
        setEndState: (a, l) => {
          var d;
          (d = this._debugBackgroundStates) === null || d === void 0 || d.setEndState(a, l);
        }
      })) : (this._debugBackgroundTokens = void 0, this._debugBackgroundStates = void 0, this._debugBackgroundTokenizer.value = void 0);
    }
    this.refreshAllVisibleLineTokens();
  }
  handleDidChangeAttached() {
    var e;
    (e = this._defaultBackgroundTokenizer) === null || e === void 0 || e.handleChanges();
  }
  handleDidChangeContent(e) {
    var t, i, n;
    if (e.isFlush)
      this.resetTokenization(!1);
    else if (!e.isEolChange) {
      for (const s of e.changes) {
        const [o, a] = Oc(s.text);
        this._tokens.acceptEdit(s.range, o, a), (t = this._debugBackgroundTokens) === null || t === void 0 || t.acceptEdit(s.range, o, a);
      }
      (i = this._debugBackgroundStates) === null || i === void 0 || i.acceptChanges(e.changes), this._tokenizer && this._tokenizer.store.acceptChanges(e.changes), (n = this._defaultBackgroundTokenizer) === null || n === void 0 || n.handleChanges();
    }
  }
  setTokens(e) {
    const { changes: t } = this._tokens.setMultilineTokens(e, this._textModel);
    return t.length > 0 && this._onDidChangeTokens.fire({ semanticTokensApplied: !1, ranges: t }), { changes: t };
  }
  refreshAllVisibleLineTokens() {
    const e = Yt.joinMany([...this._attachedViewStates].map(([t, i]) => i.lineRanges));
    this.refreshRanges(e);
  }
  refreshRanges(e) {
    for (const t of e)
      this.refreshRange(t.startLineNumber, t.endLineNumberExclusive - 1);
  }
  refreshRange(e, t) {
    var i, n;
    if (!this._tokenizer)
      return;
    e = Math.max(1, Math.min(this._textModel.getLineCount(), e)), t = Math.min(this._textModel.getLineCount(), t);
    const s = new cI(), { heuristicTokens: o } = this._tokenizer.tokenizeHeuristically(s, e, t), a = this.setTokens(s.finalize());
    if (o)
      for (const l of a.changes)
        (i = this._backgroundTokenizer.value) === null || i === void 0 || i.requestTokens(l.fromLineNumber, l.toLineNumber + 1);
    (n = this._defaultBackgroundTokenizer) === null || n === void 0 || n.checkFinished();
  }
  forceTokenization(e) {
    var t, i;
    const n = new cI();
    (t = this._tokenizer) === null || t === void 0 || t.updateTokensUntilLine(n, e), this.setTokens(n.finalize()), (i = this._defaultBackgroundTokenizer) === null || i === void 0 || i.checkFinished();
  }
  hasAccurateTokensForLine(e) {
    return this._tokenizer ? this._tokenizer.hasAccurateTokensForLine(e) : !0;
  }
  isCheapToTokenize(e) {
    return this._tokenizer ? this._tokenizer.isCheapToTokenize(e) : !0;
  }
  tokenizeIfCheap(e) {
    this.isCheapToTokenize(e) && this.forceTokenization(e);
  }
  getLineTokens(e) {
    var t;
    const i = this._textModel.getLineContent(e), n = this._tokens.getTokens(this._textModel.getLanguageId(), e - 1, i);
    if (this._debugBackgroundTokens && this._debugBackgroundStates && this._tokenizer && this._debugBackgroundStates.getFirstInvalidEndStateLineNumberOrMax() > e && this._tokenizer.store.getFirstInvalidEndStateLineNumberOrMax() > e) {
      const s = this._debugBackgroundTokens.getTokens(this._textModel.getLanguageId(), e - 1, i);
      !n.equals(s) && (!((t = this._debugBackgroundTokenizer.value) === null || t === void 0) && t.reportMismatchingTokens) && this._debugBackgroundTokenizer.value.reportMismatchingTokens(e);
    }
    return n;
  }
  getTokenTypeIfInsertingCharacter(e, t, i) {
    if (!this._tokenizer)
      return 0;
    const n = this._textModel.validatePosition(new A(e, t));
    return this.forceTokenization(n.lineNumber), this._tokenizer.getTokenTypeIfInsertingCharacter(n, i);
  }
  tokenizeLineWithEdit(e, t, i) {
    if (!this._tokenizer)
      return null;
    const n = this._textModel.validatePosition(e);
    return this.forceTokenization(n.lineNumber), this._tokenizer.tokenizeLineWithEdit(n, t, i);
  }
  get hasTokens() {
    return this._tokens.hasTokens;
  }
}
class KQ extends P {
  get lineRanges() {
    return this._lineRanges;
  }
  constructor(e) {
    super(), this._refreshTokens = e, this.runner = this._register(new xt(() => this.update(), 50)), this._computedLineRanges = [], this._lineRanges = [];
  }
  update() {
    ci(this._computedLineRanges, this._lineRanges, (e, t) => e.equals(t)) || (this._computedLineRanges = this._lineRanges, this._refreshTokens());
  }
  handleStateChange(e) {
    this._lineRanges = e.visibleLineRanges, e.stabilized ? (this.runner.cancel(), this.update()) : this.runner.schedule();
  }
}
const O0 = et("undoRedoService");
class R2 {
  constructor(e, t) {
    this.resource = e, this.elements = t;
  }
}
class Yf {
  constructor() {
    this.id = Yf._ID++, this.order = 1;
  }
  nextOrder() {
    return this.id === 0 ? 0 : this.order++;
  }
}
Yf._ID = 0;
Yf.None = new Yf();
class Pa {
  constructor() {
    this.id = Pa._ID++, this.order = 1;
  }
  nextOrder() {
    return this.id === 0 ? 0 : this.order++;
  }
}
Pa._ID = 0;
Pa.None = new Pa();
var jQ = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, rk = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, Th;
function qQ(r) {
  const e = new M2();
  return e.acceptChunk(r), e.finish();
}
function GQ(r) {
  const e = new M2();
  let t;
  for (; typeof (t = r.read()) == "string"; )
    e.acceptChunk(t);
  return e.finish();
}
function tO(r, e) {
  let t;
  return typeof r == "string" ? t = qQ(r) : x5(r) ? t = GQ(r) : t = r, t.create(e);
}
let LC = 0;
const ZQ = 999, YQ = 1e4;
class QQ {
  constructor(e) {
    this._source = e, this._eos = !1;
  }
  read() {
    if (this._eos)
      return null;
    const e = [];
    let t = 0, i = 0;
    do {
      const n = this._source.read();
      if (n === null)
        return this._eos = !0, t === 0 ? null : e.join("");
      if (n.length > 0 && (e[t++] = n, i += n.length), i >= 64 * 1024)
        return e.join("");
    } while (!0);
  }
}
const om = () => {
  throw new Error("Invalid change accessor");
};
let il = Th = class extends P {
  static resolveOptions(e, t) {
    if (t.detectIndentation) {
      const i = jP(e, t.tabSize, t.insertSpaces);
      return new Sw({
        tabSize: i.tabSize,
        indentSize: "tabSize",
        // TODO@Alex: guess indentSize independent of tabSize
        insertSpaces: i.insertSpaces,
        trimAutoWhitespace: t.trimAutoWhitespace,
        defaultEOL: t.defaultEOL,
        bracketPairColorizationOptions: t.bracketPairColorizationOptions
      });
    }
    return new Sw(t);
  }
  get onDidChangeLanguage() {
    return this._tokenizationTextModelPart.onDidChangeLanguage;
  }
  get onDidChangeLanguageConfiguration() {
    return this._tokenizationTextModelPart.onDidChangeLanguageConfiguration;
  }
  get onDidChangeTokens() {
    return this._tokenizationTextModelPart.onDidChangeTokens;
  }
  onDidChangeContent(e) {
    return this._eventEmitter.slowEvent((t) => e(t.contentChangedEvent));
  }
  onDidChangeContentOrInjectedText(e) {
    return Ur(this._eventEmitter.fastEvent((t) => e(t)), this._onDidChangeInjectedText.event((t) => e(t)));
  }
  _isDisposing() {
    return this.__isDisposing;
  }
  get tokenization() {
    return this._tokenizationTextModelPart;
  }
  get bracketPairs() {
    return this._bracketPairs;
  }
  get guides() {
    return this._guidesTextModelPart;
  }
  constructor(e, t, i, n = null, s, o, a) {
    super(), this._undoRedoService = s, this._languageService = o, this._languageConfigurationService = a, this._onWillDispose = this._register(new R()), this.onWillDispose = this._onWillDispose.event, this._onDidChangeDecorations = this._register(new nX((g) => this.handleBeforeFireDecorationsChangedEvent(g))), this.onDidChangeDecorations = this._onDidChangeDecorations.event, this._onDidChangeOptions = this._register(new R()), this.onDidChangeOptions = this._onDidChangeOptions.event, this._onDidChangeAttached = this._register(new R()), this.onDidChangeAttached = this._onDidChangeAttached.event, this._onDidChangeInjectedText = this._register(new R()), this._eventEmitter = this._register(new sX()), this._languageSelectionListener = this._register(new Yi()), this._deltaDecorationCallCnt = 0, this._attachedViews = new oX(), LC++, this.id = "$model" + LC, this.isForSimpleWidget = i.isForSimpleWidget, typeof n > "u" || n === null ? this._associatedResource = Ee.parse("inmemory://model/" + LC) : this._associatedResource = n, this._attachedEditorCount = 0;
    const { textBuffer: l, disposable: d } = tO(e, i.defaultEOL);
    this._buffer = l, this._bufferDisposable = d, this._options = Th.resolveOptions(this._buffer, i);
    const c = typeof t == "string" ? t : t.languageId;
    typeof t != "string" && (this._languageSelectionListener.value = t.onDidChange(() => this._setLanguage(t.languageId))), this._bracketPairs = this._register(new iQ(this, this._languageConfigurationService)), this._guidesTextModelPart = this._register(new ZZ(this, this._languageConfigurationService)), this._decorationProvider = this._register(new sQ(this)), this._tokenizationTextModelPart = new TS(this._languageService, this._languageConfigurationService, this, this._bracketPairs, c, this._attachedViews);
    const h = this._buffer.getLineCount(), u = this._buffer.getValueLengthInRange(
      new L(1, 1, h, this._buffer.getLineLength(h) + 1),
      0
      /* model.EndOfLinePreference.TextDefined */
    );
    i.largeFileOptimizations ? (this._isTooLargeForTokenization = u > Th.LARGE_FILE_SIZE_THRESHOLD || h > Th.LARGE_FILE_LINE_COUNT_THRESHOLD, this._isTooLargeForHeapOperation = u > Th.LARGE_FILE_HEAP_OPERATION_THRESHOLD) : (this._isTooLargeForTokenization = !1, this._isTooLargeForHeapOperation = !1), this._isTooLargeForSyncing = u > Th._MODEL_SYNC_LIMIT, this._versionId = 1, this._alternativeVersionId = 1, this._initialUndoRedoSnapshot = null, this._isDisposed = !1, this.__isDisposing = !1, this._instanceId = tH(LC), this._lastDecorationId = 0, this._decorations = /* @__PURE__ */ Object.create(null), this._decorationsTree = new iO(), this._commandManager = new H1(this, this._undoRedoService), this._isUndoing = !1, this._isRedoing = !1, this._trimAutoWhitespaceLines = null, this._register(this._decorationProvider.onDidChange(() => {
      this._onDidChangeDecorations.beginDeferredEmit(), this._onDidChangeDecorations.fire(), this._onDidChangeDecorations.endDeferredEmit();
    })), this._languageService.requestRichLanguageFeatures(c);
  }
  dispose() {
    this.__isDisposing = !0, this._onWillDispose.fire(), this._tokenizationTextModelPart.dispose(), this._isDisposed = !0, super.dispose(), this._bufferDisposable.dispose(), this.__isDisposing = !1;
    const e = new Df([], "", `
`, !1, !1, !0, !0);
    e.dispose(), this._buffer = e, this._bufferDisposable = P.None;
  }
  _assertNotDisposed() {
    if (this._isDisposed)
      throw new Error("Model is disposed!");
  }
  _emitContentChangedEvent(e, t) {
    this.__isDisposing || (this._tokenizationTextModelPart.handleDidChangeContent(t), this._bracketPairs.handleDidChangeContent(t), this._eventEmitter.fire(new du(e, t)));
  }
  setValue(e) {
    if (this._assertNotDisposed(), e == null)
      throw Ro();
    const { textBuffer: t, disposable: i } = tO(e, this._options.defaultEOL);
    this._setValueFromTextBuffer(t, i);
  }
  _createContentChanged2(e, t, i, n, s, o, a, l) {
    return {
      changes: [{
        range: e,
        rangeOffset: t,
        rangeLength: i,
        text: n
      }],
      eol: this._buffer.getEOL(),
      isEolChange: l,
      versionId: this.getVersionId(),
      isUndoing: s,
      isRedoing: o,
      isFlush: a
    };
  }
  _setValueFromTextBuffer(e, t) {
    this._assertNotDisposed();
    const i = this.getFullModelRange(), n = this.getValueLengthInRange(i), s = this.getLineCount(), o = this.getLineMaxColumn(s);
    this._buffer = e, this._bufferDisposable.dispose(), this._bufferDisposable = t, this._increaseVersionId(), this._decorations = /* @__PURE__ */ Object.create(null), this._decorationsTree = new iO(), this._commandManager.clear(), this._trimAutoWhitespaceLines = null, this._emitContentChangedEvent(new Sf([
      new xY()
    ], this._versionId, !1, !1), this._createContentChanged2(new L(1, 1, s, o), 0, n, this.getValue(), !1, !1, !0, !1));
  }
  setEOL(e) {
    this._assertNotDisposed();
    const t = e === 1 ? `\r
` : `
`;
    if (this._buffer.getEOL() === t)
      return;
    const i = this.getFullModelRange(), n = this.getValueLengthInRange(i), s = this.getLineCount(), o = this.getLineMaxColumn(s);
    this._onBeforeEOLChange(), this._buffer.setEOL(t), this._increaseVersionId(), this._onAfterEOLChange(), this._emitContentChangedEvent(new Sf([
      new TY()
    ], this._versionId, !1, !1), this._createContentChanged2(new L(1, 1, s, o), 0, n, this.getValue(), !1, !1, !1, !0));
  }
  _onBeforeEOLChange() {
    this._decorationsTree.ensureAllNodesHaveRanges(this);
  }
  _onAfterEOLChange() {
    const e = this.getVersionId(), t = this._decorationsTree.collectNodesPostOrder();
    for (let i = 0, n = t.length; i < n; i++) {
      const s = t[i], o = s.range, a = s.cachedAbsoluteStart - s.start, l = this._buffer.getOffsetAt(o.startLineNumber, o.startColumn), d = this._buffer.getOffsetAt(o.endLineNumber, o.endColumn);
      s.cachedAbsoluteStart = l, s.cachedAbsoluteEnd = d, s.cachedVersionId = e, s.start = l - a, s.end = d - a, Wc(s);
    }
  }
  onBeforeAttached() {
    return this._attachedEditorCount++, this._attachedEditorCount === 1 && (this._tokenizationTextModelPart.handleDidChangeAttached(), this._onDidChangeAttached.fire(void 0)), this._attachedViews.attachView();
  }
  onBeforeDetached(e) {
    this._attachedEditorCount--, this._attachedEditorCount === 0 && (this._tokenizationTextModelPart.handleDidChangeAttached(), this._onDidChangeAttached.fire(void 0)), this._attachedViews.detachView(e);
  }
  isAttachedToEditor() {
    return this._attachedEditorCount > 0;
  }
  getAttachedEditorCount() {
    return this._attachedEditorCount;
  }
  isTooLargeForSyncing() {
    return this._isTooLargeForSyncing;
  }
  isTooLargeForTokenization() {
    return this._isTooLargeForTokenization;
  }
  isTooLargeForHeapOperation() {
    return this._isTooLargeForHeapOperation;
  }
  isDisposed() {
    return this._isDisposed;
  }
  isDominatedByLongLines() {
    if (this._assertNotDisposed(), this.isTooLargeForTokenization())
      return !1;
    let e = 0, t = 0;
    const i = this._buffer.getLineCount();
    for (let n = 1; n <= i; n++) {
      const s = this._buffer.getLineLength(n);
      s >= YQ ? t += s : e += s;
    }
    return t > e;
  }
  get uri() {
    return this._associatedResource;
  }
  //#region Options
  getOptions() {
    return this._assertNotDisposed(), this._options;
  }
  getFormattingOptions() {
    return {
      tabSize: this._options.indentSize,
      insertSpaces: this._options.insertSpaces
    };
  }
  updateOptions(e) {
    this._assertNotDisposed();
    const t = typeof e.tabSize < "u" ? e.tabSize : this._options.tabSize, i = typeof e.indentSize < "u" ? e.indentSize : this._options.originalIndentSize, n = typeof e.insertSpaces < "u" ? e.insertSpaces : this._options.insertSpaces, s = typeof e.trimAutoWhitespace < "u" ? e.trimAutoWhitespace : this._options.trimAutoWhitespace, o = typeof e.bracketColorizationOptions < "u" ? e.bracketColorizationOptions : this._options.bracketPairColorizationOptions, a = new Sw({
      tabSize: t,
      indentSize: i,
      insertSpaces: n,
      defaultEOL: this._options.defaultEOL,
      trimAutoWhitespace: s,
      bracketPairColorizationOptions: o
    });
    if (this._options.equals(a))
      return;
    const l = this._options.createChangeEvent(a);
    this._options = a, this._bracketPairs.handleDidChangeOptions(l), this._decorationProvider.handleDidChangeOptions(l), this._onDidChangeOptions.fire(l);
  }
  detectIndentation(e, t) {
    this._assertNotDisposed();
    const i = jP(this._buffer, t, e);
    this.updateOptions({
      insertSpaces: i.insertSpaces,
      tabSize: i.tabSize,
      indentSize: i.tabSize
      // TODO@Alex: guess indentSize independent of tabSize
    });
  }
  normalizeIndentation(e) {
    return this._assertNotDisposed(), I1(e, this._options.indentSize, this._options.insertSpaces);
  }
  //#endregion
  //#region Reading
  getVersionId() {
    return this._assertNotDisposed(), this._versionId;
  }
  mightContainRTL() {
    return this._buffer.mightContainRTL();
  }
  mightContainUnusualLineTerminators() {
    return this._buffer.mightContainUnusualLineTerminators();
  }
  removeUnusualLineTerminators(e = null) {
    const t = this.findMatches(
      D5.source,
      !1,
      !0,
      !1,
      null,
      !1,
      1073741824
      /* Constants.MAX_SAFE_SMALL_INTEGER */
    );
    this._buffer.resetMightContainUnusualLineTerminators(), this.pushEditOperations(e, t.map((i) => ({ range: i.range, text: null })), () => null);
  }
  mightContainNonBasicASCII() {
    return this._buffer.mightContainNonBasicASCII();
  }
  getAlternativeVersionId() {
    return this._assertNotDisposed(), this._alternativeVersionId;
  }
  getInitialUndoRedoSnapshot() {
    return this._assertNotDisposed(), this._initialUndoRedoSnapshot;
  }
  getOffsetAt(e) {
    this._assertNotDisposed();
    const t = this._validatePosition(
      e.lineNumber,
      e.column,
      0
      /* StringOffsetValidationType.Relaxed */
    );
    return this._buffer.getOffsetAt(t.lineNumber, t.column);
  }
  getPositionAt(e) {
    this._assertNotDisposed();
    const t = Math.min(this._buffer.getLength(), Math.max(0, e));
    return this._buffer.getPositionAt(t);
  }
  _increaseVersionId() {
    this._versionId = this._versionId + 1, this._alternativeVersionId = this._versionId;
  }
  _overwriteVersionId(e) {
    this._versionId = e;
  }
  _overwriteAlternativeVersionId(e) {
    this._alternativeVersionId = e;
  }
  _overwriteInitialUndoRedoSnapshot(e) {
    this._initialUndoRedoSnapshot = e;
  }
  getValue(e, t = !1) {
    if (this._assertNotDisposed(), this.isTooLargeForHeapOperation())
      throw new Li("Operation would exceed heap memory limits");
    const i = this.getFullModelRange(), n = this.getValueInRange(i, e);
    return t ? this._buffer.getBOM() + n : n;
  }
  createSnapshot(e = !1) {
    return new QQ(this._buffer.createSnapshot(e));
  }
  getValueLength(e, t = !1) {
    this._assertNotDisposed();
    const i = this.getFullModelRange(), n = this.getValueLengthInRange(i, e);
    return t ? this._buffer.getBOM().length + n : n;
  }
  getValueInRange(e, t = 0) {
    return this._assertNotDisposed(), this._buffer.getValueInRange(this.validateRange(e), t);
  }
  getValueLengthInRange(e, t = 0) {
    return this._assertNotDisposed(), this._buffer.getValueLengthInRange(this.validateRange(e), t);
  }
  getCharacterCountInRange(e, t = 0) {
    return this._assertNotDisposed(), this._buffer.getCharacterCountInRange(this.validateRange(e), t);
  }
  getLineCount() {
    return this._assertNotDisposed(), this._buffer.getLineCount();
  }
  getLineContent(e) {
    if (this._assertNotDisposed(), e < 1 || e > this.getLineCount())
      throw new Li("Illegal value for lineNumber");
    return this._buffer.getLineContent(e);
  }
  getLineLength(e) {
    if (this._assertNotDisposed(), e < 1 || e > this.getLineCount())
      throw new Li("Illegal value for lineNumber");
    return this._buffer.getLineLength(e);
  }
  getLinesContent() {
    if (this._assertNotDisposed(), this.isTooLargeForHeapOperation())
      throw new Li("Operation would exceed heap memory limits");
    return this._buffer.getLinesContent();
  }
  getEOL() {
    return this._assertNotDisposed(), this._buffer.getEOL();
  }
  getEndOfLineSequence() {
    return this._assertNotDisposed(), this._buffer.getEOL() === `
` ? 0 : 1;
  }
  getLineMinColumn(e) {
    return this._assertNotDisposed(), 1;
  }
  getLineMaxColumn(e) {
    if (this._assertNotDisposed(), e < 1 || e > this.getLineCount())
      throw new Li("Illegal value for lineNumber");
    return this._buffer.getLineLength(e) + 1;
  }
  getLineFirstNonWhitespaceColumn(e) {
    if (this._assertNotDisposed(), e < 1 || e > this.getLineCount())
      throw new Li("Illegal value for lineNumber");
    return this._buffer.getLineFirstNonWhitespaceColumn(e);
  }
  getLineLastNonWhitespaceColumn(e) {
    if (this._assertNotDisposed(), e < 1 || e > this.getLineCount())
      throw new Li("Illegal value for lineNumber");
    return this._buffer.getLineLastNonWhitespaceColumn(e);
  }
  /**
   * Validates `range` is within buffer bounds, but allows it to sit in between surrogate pairs, etc.
   * Will try to not allocate if possible.
   */
  _validateRangeRelaxedNoAllocations(e) {
    const t = this._buffer.getLineCount(), i = e.startLineNumber, n = e.startColumn;
    let s = Math.floor(typeof i == "number" && !isNaN(i) ? i : 1), o = Math.floor(typeof n == "number" && !isNaN(n) ? n : 1);
    if (s < 1)
      s = 1, o = 1;
    else if (s > t)
      s = t, o = this.getLineMaxColumn(s);
    else if (o <= 1)
      o = 1;
    else {
      const h = this.getLineMaxColumn(s);
      o >= h && (o = h);
    }
    const a = e.endLineNumber, l = e.endColumn;
    let d = Math.floor(typeof a == "number" && !isNaN(a) ? a : 1), c = Math.floor(typeof l == "number" && !isNaN(l) ? l : 1);
    if (d < 1)
      d = 1, c = 1;
    else if (d > t)
      d = t, c = this.getLineMaxColumn(d);
    else if (c <= 1)
      c = 1;
    else {
      const h = this.getLineMaxColumn(d);
      c >= h && (c = h);
    }
    return i === s && n === o && a === d && l === c && e instanceof L && !(e instanceof ge) ? e : new L(s, o, d, c);
  }
  _isValidPosition(e, t, i) {
    if (typeof e != "number" || typeof t != "number" || isNaN(e) || isNaN(t) || e < 1 || t < 1 || (e | 0) !== e || (t | 0) !== t)
      return !1;
    const n = this._buffer.getLineCount();
    if (e > n)
      return !1;
    if (t === 1)
      return !0;
    const s = this.getLineMaxColumn(e);
    if (t > s)
      return !1;
    if (i === 1) {
      const o = this._buffer.getLineCharCode(e, t - 2);
      if ($n(o))
        return !1;
    }
    return !0;
  }
  _validatePosition(e, t, i) {
    const n = Math.floor(typeof e == "number" && !isNaN(e) ? e : 1), s = Math.floor(typeof t == "number" && !isNaN(t) ? t : 1), o = this._buffer.getLineCount();
    if (n < 1)
      return new A(1, 1);
    if (n > o)
      return new A(o, this.getLineMaxColumn(o));
    if (s <= 1)
      return new A(n, 1);
    const a = this.getLineMaxColumn(n);
    if (s >= a)
      return new A(n, a);
    if (i === 1) {
      const l = this._buffer.getLineCharCode(n, s - 2);
      if ($n(l))
        return new A(n, s - 1);
    }
    return new A(n, s);
  }
  validatePosition(e) {
    return this._assertNotDisposed(), e instanceof A && this._isValidPosition(e.lineNumber, e.column, 1) ? e : this._validatePosition(e.lineNumber, e.column, 1);
  }
  _isValidRange(e, t) {
    const i = e.startLineNumber, n = e.startColumn, s = e.endLineNumber, o = e.endColumn;
    if (!this._isValidPosition(
      i,
      n,
      0
      /* StringOffsetValidationType.Relaxed */
    ) || !this._isValidPosition(
      s,
      o,
      0
      /* StringOffsetValidationType.Relaxed */
    ))
      return !1;
    if (t === 1) {
      const a = n > 1 ? this._buffer.getLineCharCode(i, n - 2) : 0, l = o > 1 && o <= this._buffer.getLineLength(s) ? this._buffer.getLineCharCode(s, o - 2) : 0, d = $n(a), c = $n(l);
      return !d && !c;
    }
    return !0;
  }
  validateRange(e) {
    if (this._assertNotDisposed(), e instanceof L && !(e instanceof ge) && this._isValidRange(e, 1))
      return e;
    const i = this._validatePosition(
      e.startLineNumber,
      e.startColumn,
      0
      /* StringOffsetValidationType.Relaxed */
    ), n = this._validatePosition(
      e.endLineNumber,
      e.endColumn,
      0
      /* StringOffsetValidationType.Relaxed */
    ), s = i.lineNumber, o = i.column, a = n.lineNumber, l = n.column;
    {
      const d = o > 1 ? this._buffer.getLineCharCode(s, o - 2) : 0, c = l > 1 && l <= this._buffer.getLineLength(a) ? this._buffer.getLineCharCode(a, l - 2) : 0, h = $n(d), u = $n(c);
      return !h && !u ? new L(s, o, a, l) : s === a && o === l ? new L(s, o - 1, a, l - 1) : h && u ? new L(s, o - 1, a, l + 1) : h ? new L(s, o - 1, a, l) : new L(s, o, a, l + 1);
    }
  }
  modifyPosition(e, t) {
    this._assertNotDisposed();
    const i = this.getOffsetAt(e) + t;
    return this.getPositionAt(Math.min(this._buffer.getLength(), Math.max(0, i)));
  }
  getFullModelRange() {
    this._assertNotDisposed();
    const e = this.getLineCount();
    return new L(1, 1, e, this.getLineMaxColumn(e));
  }
  findMatchesLineByLine(e, t, i, n) {
    return this._buffer.findMatchesLineByLine(e, t, i, n);
  }
  findMatches(e, t, i, n, s, o, a = ZQ) {
    this._assertNotDisposed();
    let l = null;
    t !== null && (Array.isArray(t) || (t = [t]), t.every((h) => L.isIRange(h)) && (l = t.map((h) => this.validateRange(h)))), l === null && (l = [this.getFullModelRange()]), l = l.sort((h, u) => h.startLineNumber - u.startLineNumber || h.startColumn - u.startColumn);
    const d = [];
    d.push(l.reduce((h, u) => L.areIntersecting(h, u) ? h.plusRange(u) : (d.push(h), u)));
    let c;
    if (!i && e.indexOf(`
`) < 0) {
      const u = new Ih(e, i, n, s).parseSearchRequest();
      if (!u)
        return [];
      c = (g) => this.findMatchesLineByLine(g, u, o, a);
    } else
      c = (h) => eC.findMatches(this, new Ih(e, i, n, s), h, o, a);
    return d.map(c).reduce((h, u) => h.concat(u), []);
  }
  findNextMatch(e, t, i, n, s, o) {
    this._assertNotDisposed();
    const a = this.validatePosition(t);
    if (!i && e.indexOf(`
`) < 0) {
      const d = new Ih(e, i, n, s).parseSearchRequest();
      if (!d)
        return null;
      const c = this.getLineCount();
      let h = new L(a.lineNumber, a.column, c, this.getLineMaxColumn(c)), u = this.findMatchesLineByLine(h, d, o, 1);
      return eC.findNextMatch(this, new Ih(e, i, n, s), a, o), u.length > 0 || (h = new L(1, 1, a.lineNumber, this.getLineMaxColumn(a.lineNumber)), u = this.findMatchesLineByLine(h, d, o, 1), u.length > 0) ? u[0] : null;
    }
    return eC.findNextMatch(this, new Ih(e, i, n, s), a, o);
  }
  findPreviousMatch(e, t, i, n, s, o) {
    this._assertNotDisposed();
    const a = this.validatePosition(t);
    return eC.findPreviousMatch(this, new Ih(e, i, n, s), a, o);
  }
  //#endregion
  //#region Editing
  pushStackElement() {
    this._commandManager.pushStackElement();
  }
  popStackElement() {
    this._commandManager.popStackElement();
  }
  pushEOL(e) {
    if ((this.getEOL() === `
` ? 0 : 1) !== e)
      try {
        this._onDidChangeDecorations.beginDeferredEmit(), this._eventEmitter.beginDeferredEmit(), this._initialUndoRedoSnapshot === null && (this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri)), this._commandManager.pushEOL(e);
      } finally {
        this._eventEmitter.endDeferredEmit(), this._onDidChangeDecorations.endDeferredEmit();
      }
  }
  _validateEditOperation(e) {
    return e instanceof bD ? e : new bD(e.identifier || null, this.validateRange(e.range), e.text, e.forceMoveMarkers || !1, e.isAutoWhitespaceEdit || !1, e._isTracked || !1);
  }
  _validateEditOperations(e) {
    const t = [];
    for (let i = 0, n = e.length; i < n; i++)
      t[i] = this._validateEditOperation(e[i]);
    return t;
  }
  pushEditOperations(e, t, i, n) {
    try {
      return this._onDidChangeDecorations.beginDeferredEmit(), this._eventEmitter.beginDeferredEmit(), this._pushEditOperations(e, this._validateEditOperations(t), i, n);
    } finally {
      this._eventEmitter.endDeferredEmit(), this._onDidChangeDecorations.endDeferredEmit();
    }
  }
  _pushEditOperations(e, t, i, n) {
    if (this._options.trimAutoWhitespace && this._trimAutoWhitespaceLines) {
      const s = t.map((a) => ({
        range: this.validateRange(a.range),
        text: a.text
      }));
      let o = !0;
      if (e)
        for (let a = 0, l = e.length; a < l; a++) {
          const d = e[a];
          let c = !1;
          for (let h = 0, u = s.length; h < u; h++) {
            const g = s[h].range, f = g.startLineNumber > d.endLineNumber, m = d.startLineNumber > g.endLineNumber;
            if (!f && !m) {
              c = !0;
              break;
            }
          }
          if (!c) {
            o = !1;
            break;
          }
        }
      if (o)
        for (let a = 0, l = this._trimAutoWhitespaceLines.length; a < l; a++) {
          const d = this._trimAutoWhitespaceLines[a], c = this.getLineMaxColumn(d);
          let h = !0;
          for (let u = 0, g = s.length; u < g; u++) {
            const f = s[u].range, m = s[u].text;
            if (!(d < f.startLineNumber || d > f.endLineNumber) && !(d === f.startLineNumber && f.startColumn === c && f.isEmpty() && m && m.length > 0 && m.charAt(0) === `
`) && !(d === f.startLineNumber && f.startColumn === 1 && f.isEmpty() && m && m.length > 0 && m.charAt(m.length - 1) === `
`)) {
              h = !1;
              break;
            }
          }
          if (h) {
            const u = new L(d, 1, d, c);
            t.push(new bD(null, u, null, !1, !1, !1));
          }
        }
      this._trimAutoWhitespaceLines = null;
    }
    return this._initialUndoRedoSnapshot === null && (this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri)), this._commandManager.pushEditOperation(e, t, i, n);
  }
  _applyUndo(e, t, i, n) {
    const s = e.map((o) => {
      const a = this.getPositionAt(o.newPosition), l = this.getPositionAt(o.newEnd);
      return {
        range: new L(a.lineNumber, a.column, l.lineNumber, l.column),
        text: o.oldText
      };
    });
    this._applyUndoRedoEdits(s, t, !0, !1, i, n);
  }
  _applyRedo(e, t, i, n) {
    const s = e.map((o) => {
      const a = this.getPositionAt(o.oldPosition), l = this.getPositionAt(o.oldEnd);
      return {
        range: new L(a.lineNumber, a.column, l.lineNumber, l.column),
        text: o.newText
      };
    });
    this._applyUndoRedoEdits(s, t, !1, !0, i, n);
  }
  _applyUndoRedoEdits(e, t, i, n, s, o) {
    try {
      this._onDidChangeDecorations.beginDeferredEmit(), this._eventEmitter.beginDeferredEmit(), this._isUndoing = i, this._isRedoing = n, this.applyEdits(e, !1), this.setEOL(t), this._overwriteAlternativeVersionId(s);
    } finally {
      this._isUndoing = !1, this._isRedoing = !1, this._eventEmitter.endDeferredEmit(o), this._onDidChangeDecorations.endDeferredEmit();
    }
  }
  applyEdits(e, t = !1) {
    try {
      this._onDidChangeDecorations.beginDeferredEmit(), this._eventEmitter.beginDeferredEmit();
      const i = this._validateEditOperations(e);
      return this._doApplyEdits(i, t);
    } finally {
      this._eventEmitter.endDeferredEmit(), this._onDidChangeDecorations.endDeferredEmit();
    }
  }
  _doApplyEdits(e, t) {
    const i = this._buffer.getLineCount(), n = this._buffer.applyEdits(e, this._options.trimAutoWhitespace, t), s = this._buffer.getLineCount(), o = n.changes;
    if (this._trimAutoWhitespaceLines = n.trimAutoWhitespaceLineNumbers, o.length !== 0) {
      for (let d = 0, c = o.length; d < c; d++) {
        const h = o[d];
        this._decorationsTree.acceptReplace(h.rangeOffset, h.rangeLength, h.text.length, h.forceMoveMarkers);
      }
      const a = [];
      this._increaseVersionId();
      let l = i;
      for (let d = 0, c = o.length; d < c; d++) {
        const h = o[d], [u] = Oc(h.text);
        this._onDidChangeDecorations.fire();
        const g = h.range.startLineNumber, f = h.range.endLineNumber, m = f - g, _ = u, v = Math.min(m, _), b = _ - m, C = s - l - b + g, w = C, S = C + _, y = this._decorationsTree.getInjectedTextInInterval(this, this.getOffsetAt(new A(w, 1)), this.getOffsetAt(new A(S, this.getLineMaxColumn(S))), 0), k = ea.fromDecorations(y), E = new ad(k);
        for (let N = v; N >= 0; N--) {
          const F = g + N, V = C + N;
          E.takeFromEndWhile((H) => H.lineNumber > V);
          const Z = E.takeFromEndWhile((H) => H.lineNumber === V);
          a.push(new FP(F, this.getLineContent(V), Z));
        }
        if (v < m) {
          const N = g + v;
          a.push(new IY(N + 1, f));
        }
        if (v < _) {
          const N = new ad(k), F = g + v, V = _ - v, Z = s - l - V + F + 1, H = [], re = [];
          for (let ue = 0; ue < V; ue++) {
            const Ve = Z + ue;
            re[ue] = this.getLineContent(Ve), N.takeWhile((Ye) => Ye.lineNumber < Ve), H[ue] = N.takeWhile((Ye) => Ye.lineNumber === Ve);
          }
          a.push(new EY(F + 1, g + _, re, H));
        }
        l += b;
      }
      this._emitContentChangedEvent(new Sf(a, this.getVersionId(), this._isUndoing, this._isRedoing), {
        changes: o,
        eol: this._buffer.getEOL(),
        isEolChange: !1,
        versionId: this.getVersionId(),
        isUndoing: this._isUndoing,
        isRedoing: this._isRedoing,
        isFlush: !1
      });
    }
    return n.reverseEdits === null ? void 0 : n.reverseEdits;
  }
  undo() {
    return this._undoRedoService.undo(this.uri);
  }
  canUndo() {
    return this._undoRedoService.canUndo(this.uri);
  }
  redo() {
    return this._undoRedoService.redo(this.uri);
  }
  canRedo() {
    return this._undoRedoService.canRedo(this.uri);
  }
  //#endregion
  //#region Decorations
  handleBeforeFireDecorationsChangedEvent(e) {
    if (e === null || e.size === 0)
      return;
    const i = Array.from(e).map((n) => new FP(n, this.getLineContent(n), this._getInjectedTextInLine(n)));
    this._onDidChangeInjectedText.fire(new g2(i));
  }
  changeDecorations(e, t = 0) {
    this._assertNotDisposed();
    try {
      return this._onDidChangeDecorations.beginDeferredEmit(), this._changeDecorations(t, e);
    } finally {
      this._onDidChangeDecorations.endDeferredEmit();
    }
  }
  _changeDecorations(e, t) {
    const i = {
      addDecoration: (s, o) => this._deltaDecorationsImpl(e, [], [{ range: s, options: o }])[0],
      changeDecoration: (s, o) => {
        this._changeDecorationImpl(s, o);
      },
      changeDecorationOptions: (s, o) => {
        this._changeDecorationOptionsImpl(s, sO(o));
      },
      removeDecoration: (s) => {
        this._deltaDecorationsImpl(e, [s], []);
      },
      deltaDecorations: (s, o) => s.length === 0 && o.length === 0 ? [] : this._deltaDecorationsImpl(e, s, o)
    };
    let n = null;
    try {
      n = t(i);
    } catch (s) {
      He(s);
    }
    return i.addDecoration = om, i.changeDecoration = om, i.changeDecorationOptions = om, i.removeDecoration = om, i.deltaDecorations = om, n;
  }
  deltaDecorations(e, t, i = 0) {
    if (this._assertNotDisposed(), e || (e = []), e.length === 0 && t.length === 0)
      return [];
    try {
      return this._deltaDecorationCallCnt++, this._deltaDecorationCallCnt > 1 && (console.warn("Invoking deltaDecorations recursively could lead to leaking decorations."), He(new Error("Invoking deltaDecorations recursively could lead to leaking decorations."))), this._onDidChangeDecorations.beginDeferredEmit(), this._deltaDecorationsImpl(i, e, t);
    } finally {
      this._onDidChangeDecorations.endDeferredEmit(), this._deltaDecorationCallCnt--;
    }
  }
  _getTrackedRange(e) {
    return this.getDecorationRange(e);
  }
  _setTrackedRange(e, t, i) {
    const n = e ? this._decorations[e] : null;
    if (!n)
      return t ? this._deltaDecorationsImpl(0, [], [{ range: t, options: nO[i] }], !0)[0] : null;
    if (!t)
      return this._decorationsTree.delete(n), delete this._decorations[n.id], null;
    const s = this._validateRangeRelaxedNoAllocations(t), o = this._buffer.getOffsetAt(s.startLineNumber, s.startColumn), a = this._buffer.getOffsetAt(s.endLineNumber, s.endColumn);
    return this._decorationsTree.delete(n), n.reset(this.getVersionId(), o, a, s), n.setOptions(nO[i]), this._decorationsTree.insert(n), n.id;
  }
  removeAllDecorationsWithOwnerId(e) {
    if (this._isDisposed)
      return;
    const t = this._decorationsTree.collectNodesFromOwner(e);
    for (let i = 0, n = t.length; i < n; i++) {
      const s = t[i];
      this._decorationsTree.delete(s), delete this._decorations[s.id];
    }
  }
  getDecorationOptions(e) {
    const t = this._decorations[e];
    return t ? t.options : null;
  }
  getDecorationRange(e) {
    const t = this._decorations[e];
    return t ? this._decorationsTree.getNodeRange(this, t) : null;
  }
  getLineDecorations(e, t = 0, i = !1) {
    return e < 1 || e > this.getLineCount() ? [] : this.getLinesDecorations(e, e, t, i);
  }
  getLinesDecorations(e, t, i = 0, n = !1, s = !1) {
    const o = this.getLineCount(), a = Math.min(o, Math.max(1, e)), l = Math.min(o, Math.max(1, t)), d = this.getLineMaxColumn(l), c = new L(a, 1, l, d), h = this._getDecorationsInRange(c, i, n, s);
    return sA(h, this._decorationProvider.getDecorationsInRange(c, i, n)), h;
  }
  getDecorationsInRange(e, t = 0, i = !1, n = !1, s = !1) {
    const o = this.validateRange(e), a = this._getDecorationsInRange(o, t, i, s);
    return sA(a, this._decorationProvider.getDecorationsInRange(o, t, i, n)), a;
  }
  getOverviewRulerDecorations(e = 0, t = !1) {
    return this._decorationsTree.getAll(this, e, t, !0, !1);
  }
  getInjectedTextDecorations(e = 0) {
    return this._decorationsTree.getAllInjectedText(this, e);
  }
  _getInjectedTextInLine(e) {
    const t = this._buffer.getOffsetAt(e, 1), i = t + this._buffer.getLineLength(e), n = this._decorationsTree.getInjectedTextInInterval(this, t, i, 0);
    return ea.fromDecorations(n).filter((s) => s.lineNumber === e);
  }
  getAllDecorations(e = 0, t = !1) {
    let i = this._decorationsTree.getAll(this, e, t, !1, !1);
    return i = i.concat(this._decorationProvider.getAllDecorations(e, t)), i;
  }
  getAllMarginDecorations(e = 0) {
    return this._decorationsTree.getAll(this, e, !1, !1, !0);
  }
  _getDecorationsInRange(e, t, i, n) {
    const s = this._buffer.getOffsetAt(e.startLineNumber, e.startColumn), o = this._buffer.getOffsetAt(e.endLineNumber, e.endColumn);
    return this._decorationsTree.getAllInInterval(this, s, o, t, i, n);
  }
  getRangeAt(e, t) {
    return this._buffer.getRangeAt(e, t - e);
  }
  _changeDecorationImpl(e, t) {
    const i = this._decorations[e];
    if (!i)
      return;
    if (i.options.after) {
      const a = this.getDecorationRange(e);
      this._onDidChangeDecorations.recordLineAffectedByInjectedText(a.endLineNumber);
    }
    if (i.options.before) {
      const a = this.getDecorationRange(e);
      this._onDidChangeDecorations.recordLineAffectedByInjectedText(a.startLineNumber);
    }
    const n = this._validateRangeRelaxedNoAllocations(t), s = this._buffer.getOffsetAt(n.startLineNumber, n.startColumn), o = this._buffer.getOffsetAt(n.endLineNumber, n.endColumn);
    this._decorationsTree.delete(i), i.reset(this.getVersionId(), s, o, n), this._decorationsTree.insert(i), this._onDidChangeDecorations.checkAffectedAndFire(i.options), i.options.after && this._onDidChangeDecorations.recordLineAffectedByInjectedText(n.endLineNumber), i.options.before && this._onDidChangeDecorations.recordLineAffectedByInjectedText(n.startLineNumber);
  }
  _changeDecorationOptionsImpl(e, t) {
    const i = this._decorations[e];
    if (!i)
      return;
    const n = !!(i.options.overviewRuler && i.options.overviewRuler.color), s = !!(t.overviewRuler && t.overviewRuler.color);
    if (this._onDidChangeDecorations.checkAffectedAndFire(i.options), this._onDidChangeDecorations.checkAffectedAndFire(t), i.options.after || t.after) {
      const l = this._decorationsTree.getNodeRange(this, i);
      this._onDidChangeDecorations.recordLineAffectedByInjectedText(l.endLineNumber);
    }
    if (i.options.before || t.before) {
      const l = this._decorationsTree.getNodeRange(this, i);
      this._onDidChangeDecorations.recordLineAffectedByInjectedText(l.startLineNumber);
    }
    const o = n !== s, a = JQ(t) !== Ow(i);
    o || a ? (this._decorationsTree.delete(i), i.setOptions(t), this._decorationsTree.insert(i)) : i.setOptions(t);
  }
  _deltaDecorationsImpl(e, t, i, n = !1) {
    const s = this.getVersionId(), o = t.length;
    let a = 0;
    const l = i.length;
    let d = 0;
    this._onDidChangeDecorations.beginDeferredEmit();
    try {
      const c = new Array(l);
      for (; a < o || d < l; ) {
        let h = null;
        if (a < o) {
          do
            h = this._decorations[t[a++]];
          while (!h && a < o);
          if (h) {
            if (h.options.after) {
              const u = this._decorationsTree.getNodeRange(this, h);
              this._onDidChangeDecorations.recordLineAffectedByInjectedText(u.endLineNumber);
            }
            if (h.options.before) {
              const u = this._decorationsTree.getNodeRange(this, h);
              this._onDidChangeDecorations.recordLineAffectedByInjectedText(u.startLineNumber);
            }
            this._decorationsTree.delete(h), n || this._onDidChangeDecorations.checkAffectedAndFire(h.options);
          }
        }
        if (d < l) {
          if (!h) {
            const v = ++this._lastDecorationId, b = `${this._instanceId};${v}`;
            h = new I2(b, 0, 0), this._decorations[b] = h;
          }
          const u = i[d], g = this._validateRangeRelaxedNoAllocations(u.range), f = sO(u.options), m = this._buffer.getOffsetAt(g.startLineNumber, g.startColumn), _ = this._buffer.getOffsetAt(g.endLineNumber, g.endColumn);
          h.ownerId = e, h.reset(s, m, _, g), h.setOptions(f), h.options.after && this._onDidChangeDecorations.recordLineAffectedByInjectedText(g.endLineNumber), h.options.before && this._onDidChangeDecorations.recordLineAffectedByInjectedText(g.startLineNumber), n || this._onDidChangeDecorations.checkAffectedAndFire(f), this._decorationsTree.insert(h), c[d] = h.id, d++;
        } else
          h && delete this._decorations[h.id];
      }
      return c;
    } finally {
      this._onDidChangeDecorations.endDeferredEmit();
    }
  }
  //#endregion
  //#region Tokenization
  // TODO move them to the tokenization part.
  getLanguageId() {
    return this.tokenization.getLanguageId();
  }
  setLanguage(e, t) {
    typeof e == "string" ? (this._languageSelectionListener.clear(), this._setLanguage(e, t)) : (this._languageSelectionListener.value = e.onDidChange(() => this._setLanguage(e.languageId, t)), this._setLanguage(e.languageId, t));
  }
  _setLanguage(e, t) {
    this.tokenization.setLanguageId(e, t), this._languageService.requestRichLanguageFeatures(e);
  }
  getLanguageIdAtPosition(e, t) {
    return this.tokenization.getLanguageIdAtPosition(e, t);
  }
  getWordAtPosition(e) {
    return this._tokenizationTextModelPart.getWordAtPosition(e);
  }
  getWordUntilPosition(e) {
    return this._tokenizationTextModelPart.getWordUntilPosition(e);
  }
  //#endregion
  normalizePosition(e, t) {
    return e;
  }
  /**
   * Gets the column at which indentation stops at a given line.
   * @internal
  */
  getLineIndentColumn(e) {
    return XQ(this.getLineContent(e)) + 1;
  }
};
il._MODEL_SYNC_LIMIT = 50 * 1024 * 1024;
il.LARGE_FILE_SIZE_THRESHOLD = 20 * 1024 * 1024;
il.LARGE_FILE_LINE_COUNT_THRESHOLD = 300 * 1e3;
il.LARGE_FILE_HEAP_OPERATION_THRESHOLD = 256 * 1024 * 1024;
il.DEFAULT_CREATION_OPTIONS = {
  isForSimpleWidget: !1,
  tabSize: Tn.tabSize,
  indentSize: Tn.indentSize,
  insertSpaces: Tn.insertSpaces,
  detectIndentation: !1,
  defaultEOL: 1,
  trimAutoWhitespace: Tn.trimAutoWhitespace,
  largeFileOptimizations: Tn.largeFileOptimizations,
  bracketPairColorizationOptions: Tn.bracketPairColorizationOptions
};
il = Th = jQ([
  rk(4, O0),
  rk(5, Jt),
  rk(6, Ot)
], il);
function XQ(r) {
  let e = 0;
  for (const t of r)
    if (t === " " || t === "	")
      e++;
    else
      break;
  return e;
}
function ak(r) {
  return !!(r.options.overviewRuler && r.options.overviewRuler.color);
}
function JQ(r) {
  return !!r.after || !!r.before;
}
function Ow(r) {
  return !!r.options.after || !!r.options.before;
}
class iO {
  constructor() {
    this._decorationsTree0 = new nk(), this._decorationsTree1 = new nk(), this._injectedTextDecorationsTree = new nk();
  }
  ensureAllNodesHaveRanges(e) {
    this.getAll(e, 0, !1, !1, !1);
  }
  _ensureNodesHaveRanges(e, t) {
    for (const i of t)
      i.range === null && (i.range = e.getRangeAt(i.cachedAbsoluteStart, i.cachedAbsoluteEnd));
    return t;
  }
  getAllInInterval(e, t, i, n, s, o) {
    const a = e.getVersionId(), l = this._intervalSearch(t, i, n, s, a, o);
    return this._ensureNodesHaveRanges(e, l);
  }
  _intervalSearch(e, t, i, n, s, o) {
    const a = this._decorationsTree0.intervalSearch(e, t, i, n, s, o), l = this._decorationsTree1.intervalSearch(e, t, i, n, s, o), d = this._injectedTextDecorationsTree.intervalSearch(e, t, i, n, s, o);
    return a.concat(l).concat(d);
  }
  getInjectedTextInInterval(e, t, i, n) {
    const s = e.getVersionId(), o = this._injectedTextDecorationsTree.intervalSearch(t, i, n, !1, s, !1);
    return this._ensureNodesHaveRanges(e, o).filter((a) => a.options.showIfCollapsed || !a.range.isEmpty());
  }
  getAllInjectedText(e, t) {
    const i = e.getVersionId(), n = this._injectedTextDecorationsTree.search(t, !1, i, !1);
    return this._ensureNodesHaveRanges(e, n).filter((s) => s.options.showIfCollapsed || !s.range.isEmpty());
  }
  getAll(e, t, i, n, s) {
    const o = e.getVersionId(), a = this._search(t, i, n, o, s);
    return this._ensureNodesHaveRanges(e, a);
  }
  _search(e, t, i, n, s) {
    if (i)
      return this._decorationsTree1.search(e, t, n, s);
    {
      const o = this._decorationsTree0.search(e, t, n, s), a = this._decorationsTree1.search(e, t, n, s), l = this._injectedTextDecorationsTree.search(e, t, n, s);
      return o.concat(a).concat(l);
    }
  }
  collectNodesFromOwner(e) {
    const t = this._decorationsTree0.collectNodesFromOwner(e), i = this._decorationsTree1.collectNodesFromOwner(e), n = this._injectedTextDecorationsTree.collectNodesFromOwner(e);
    return t.concat(i).concat(n);
  }
  collectNodesPostOrder() {
    const e = this._decorationsTree0.collectNodesPostOrder(), t = this._decorationsTree1.collectNodesPostOrder(), i = this._injectedTextDecorationsTree.collectNodesPostOrder();
    return e.concat(t).concat(i);
  }
  insert(e) {
    Ow(e) ? this._injectedTextDecorationsTree.insert(e) : ak(e) ? this._decorationsTree1.insert(e) : this._decorationsTree0.insert(e);
  }
  delete(e) {
    Ow(e) ? this._injectedTextDecorationsTree.delete(e) : ak(e) ? this._decorationsTree1.delete(e) : this._decorationsTree0.delete(e);
  }
  getNodeRange(e, t) {
    const i = e.getVersionId();
    return t.cachedVersionId !== i && this._resolveNode(t, i), t.range === null && (t.range = e.getRangeAt(t.cachedAbsoluteStart, t.cachedAbsoluteEnd)), t.range;
  }
  _resolveNode(e, t) {
    Ow(e) ? this._injectedTextDecorationsTree.resolveNode(e, t) : ak(e) ? this._decorationsTree1.resolveNode(e, t) : this._decorationsTree0.resolveNode(e, t);
  }
  acceptReplace(e, t, i, n) {
    this._decorationsTree0.acceptReplace(e, t, i, n), this._decorationsTree1.acceptReplace(e, t, i, n), this._injectedTextDecorationsTree.acceptReplace(e, t, i, n);
  }
}
function ga(r) {
  return r.replace(/[^a-z0-9\-_]/gi, " ");
}
class A2 {
  constructor(e) {
    this.color = e.color || "", this.darkColor = e.darkColor || "";
  }
}
class eX extends A2 {
  constructor(e) {
    super(e), this._resolvedColor = null, this.position = typeof e.position == "number" ? e.position : _r.Center;
  }
  getColor(e) {
    return this._resolvedColor || (e.type !== "light" && this.darkColor ? this._resolvedColor = this._resolveColor(this.darkColor, e) : this._resolvedColor = this._resolveColor(this.color, e)), this._resolvedColor;
  }
  invalidateCachedColor() {
    this._resolvedColor = null;
  }
  _resolveColor(e, t) {
    if (typeof e == "string")
      return e;
    const i = e ? t.getColor(e.id) : null;
    return i ? i.toString() : "";
  }
}
class tX {
  constructor(e) {
    var t;
    this.position = (t = e == null ? void 0 : e.position) !== null && t !== void 0 ? t : Ec.Center, this.persistLane = e == null ? void 0 : e.persistLane;
  }
}
class iX extends A2 {
  constructor(e) {
    var t, i;
    super(e), this.position = e.position, this.sectionHeaderStyle = (t = e.sectionHeaderStyle) !== null && t !== void 0 ? t : null, this.sectionHeaderText = (i = e.sectionHeaderText) !== null && i !== void 0 ? i : null;
  }
  getColor(e) {
    return this._resolvedColor || (e.type !== "light" && this.darkColor ? this._resolvedColor = this._resolveColor(this.darkColor, e) : this._resolvedColor = this._resolveColor(this.color, e)), this._resolvedColor;
  }
  invalidateCachedColor() {
    this._resolvedColor = void 0;
  }
  _resolveColor(e, t) {
    return typeof e == "string" ? z.fromHex(e) : t.getColor(e.id);
  }
}
class Bc {
  static from(e) {
    return e instanceof Bc ? e : new Bc(e);
  }
  constructor(e) {
    this.content = e.content || "", this.inlineClassName = e.inlineClassName || null, this.inlineClassNameAffectsLetterSpacing = e.inlineClassNameAffectsLetterSpacing || !1, this.attachedData = e.attachedData || null, this.cursorStops = e.cursorStops || null;
  }
}
class Fe {
  static register(e) {
    return new Fe(e);
  }
  static createDynamic(e) {
    return new Fe(e);
  }
  constructor(e) {
    var t, i, n, s, o, a;
    this.description = e.description, this.blockClassName = e.blockClassName ? ga(e.blockClassName) : null, this.blockDoesNotCollapse = (t = e.blockDoesNotCollapse) !== null && t !== void 0 ? t : null, this.blockIsAfterEnd = (i = e.blockIsAfterEnd) !== null && i !== void 0 ? i : null, this.blockPadding = (n = e.blockPadding) !== null && n !== void 0 ? n : null, this.stickiness = e.stickiness || 0, this.zIndex = e.zIndex || 0, this.className = e.className ? ga(e.className) : null, this.shouldFillLineOnLineBreak = (s = e.shouldFillLineOnLineBreak) !== null && s !== void 0 ? s : null, this.hoverMessage = e.hoverMessage || null, this.glyphMarginHoverMessage = e.glyphMarginHoverMessage || null, this.lineNumberHoverMessage = e.lineNumberHoverMessage || null, this.isWholeLine = e.isWholeLine || !1, this.showIfCollapsed = e.showIfCollapsed || !1, this.collapseOnReplaceEdit = e.collapseOnReplaceEdit || !1, this.overviewRuler = e.overviewRuler ? new eX(e.overviewRuler) : null, this.minimap = e.minimap ? new iX(e.minimap) : null, this.glyphMargin = e.glyphMarginClassName ? new tX(e.glyphMargin) : null, this.glyphMarginClassName = e.glyphMarginClassName ? ga(e.glyphMarginClassName) : null, this.linesDecorationsClassName = e.linesDecorationsClassName ? ga(e.linesDecorationsClassName) : null, this.lineNumberClassName = e.lineNumberClassName ? ga(e.lineNumberClassName) : null, this.linesDecorationsTooltip = e.linesDecorationsTooltip ? k5(e.linesDecorationsTooltip) : null, this.firstLineDecorationClassName = e.firstLineDecorationClassName ? ga(e.firstLineDecorationClassName) : null, this.marginClassName = e.marginClassName ? ga(e.marginClassName) : null, this.inlineClassName = e.inlineClassName ? ga(e.inlineClassName) : null, this.inlineClassNameAffectsLetterSpacing = e.inlineClassNameAffectsLetterSpacing || !1, this.beforeContentClassName = e.beforeContentClassName ? ga(e.beforeContentClassName) : null, this.afterContentClassName = e.afterContentClassName ? ga(e.afterContentClassName) : null, this.after = e.after ? Bc.from(e.after) : null, this.before = e.before ? Bc.from(e.before) : null, this.hideInCommentTokens = (o = e.hideInCommentTokens) !== null && o !== void 0 ? o : !1, this.hideInStringTokens = (a = e.hideInStringTokens) !== null && a !== void 0 ? a : !1;
  }
}
Fe.EMPTY = Fe.register({ description: "empty" });
const nO = [
  Fe.register({
    description: "tracked-range-always-grows-when-typing-at-edges",
    stickiness: 0
    /* model.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */
  }),
  Fe.register({
    description: "tracked-range-never-grows-when-typing-at-edges",
    stickiness: 1
    /* model.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */
  }),
  Fe.register({
    description: "tracked-range-grows-only-when-typing-before",
    stickiness: 2
    /* model.TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */
  }),
  Fe.register({
    description: "tracked-range-grows-only-when-typing-after",
    stickiness: 3
    /* model.TrackedRangeStickiness.GrowsOnlyWhenTypingAfter */
  })
];
function sO(r) {
  return r instanceof Fe ? r : Fe.createDynamic(r);
}
class nX extends P {
  constructor(e) {
    super(), this.handleBeforeFire = e, this._actual = this._register(new R()), this.event = this._actual.event, this._affectedInjectedTextLines = null, this._deferredCnt = 0, this._shouldFireDeferred = !1, this._affectsMinimap = !1, this._affectsOverviewRuler = !1, this._affectsGlyphMargin = !1, this._affectsLineNumber = !1;
  }
  beginDeferredEmit() {
    this._deferredCnt++;
  }
  endDeferredEmit() {
    var e;
    this._deferredCnt--, this._deferredCnt === 0 && (this._shouldFireDeferred && this.doFire(), (e = this._affectedInjectedTextLines) === null || e === void 0 || e.clear(), this._affectedInjectedTextLines = null);
  }
  recordLineAffectedByInjectedText(e) {
    this._affectedInjectedTextLines || (this._affectedInjectedTextLines = /* @__PURE__ */ new Set()), this._affectedInjectedTextLines.add(e);
  }
  checkAffectedAndFire(e) {
    var t, i;
    this._affectsMinimap || (this._affectsMinimap = !!(!((t = e.minimap) === null || t === void 0) && t.position)), this._affectsOverviewRuler || (this._affectsOverviewRuler = !!(!((i = e.overviewRuler) === null || i === void 0) && i.color)), this._affectsGlyphMargin || (this._affectsGlyphMargin = !!e.glyphMarginClassName), this._affectsLineNumber || (this._affectsLineNumber = !!e.lineNumberClassName), this.tryFire();
  }
  fire() {
    this._affectsMinimap = !0, this._affectsOverviewRuler = !0, this._affectsGlyphMargin = !0, this.tryFire();
  }
  tryFire() {
    this._deferredCnt === 0 ? this.doFire() : this._shouldFireDeferred = !0;
  }
  doFire() {
    this.handleBeforeFire(this._affectedInjectedTextLines);
    const e = {
      affectsMinimap: this._affectsMinimap,
      affectsOverviewRuler: this._affectsOverviewRuler,
      affectsGlyphMargin: this._affectsGlyphMargin,
      affectsLineNumber: this._affectsLineNumber
    };
    this._shouldFireDeferred = !1, this._affectsMinimap = !1, this._affectsOverviewRuler = !1, this._affectsGlyphMargin = !1, this._actual.fire(e);
  }
}
class sX extends P {
  constructor() {
    super(), this._fastEmitter = this._register(new R()), this.fastEvent = this._fastEmitter.event, this._slowEmitter = this._register(new R()), this.slowEvent = this._slowEmitter.event, this._deferredCnt = 0, this._deferredEvent = null;
  }
  beginDeferredEmit() {
    this._deferredCnt++;
  }
  endDeferredEmit(e = null) {
    if (this._deferredCnt--, this._deferredCnt === 0 && this._deferredEvent !== null) {
      this._deferredEvent.rawContentChangedEvent.resultingSelection = e;
      const t = this._deferredEvent;
      this._deferredEvent = null, this._fastEmitter.fire(t), this._slowEmitter.fire(t);
    }
  }
  fire(e) {
    if (this._deferredCnt > 0) {
      this._deferredEvent ? this._deferredEvent = this._deferredEvent.merge(e) : this._deferredEvent = e;
      return;
    }
    this._fastEmitter.fire(e), this._slowEmitter.fire(e);
  }
}
class oX {
  constructor() {
    this._onDidChangeVisibleRanges = new R(), this.onDidChangeVisibleRanges = this._onDidChangeVisibleRanges.event, this._views = /* @__PURE__ */ new Set();
  }
  attachView() {
    const e = new rX((t) => {
      this._onDidChangeVisibleRanges.fire({ view: e, state: t });
    });
    return this._views.add(e), e;
  }
  detachView(e) {
    this._views.delete(e), this._onDidChangeVisibleRanges.fire({ view: e, state: void 0 });
  }
}
class rX {
  constructor(e) {
    this.handleStateChange = e;
  }
  setVisibleLines(e, t) {
    const i = e.map((n) => new Yt(n.startLineNumber, n.endLineNumber + 1));
    this.handleStateChange({ visibleLineRanges: i, stabilized: t });
  }
}
class K1 {
  static create(e) {
    return new K1(e.get(
      134
      /* EditorOption.wordWrapBreakBeforeCharacters */
    ), e.get(
      133
      /* EditorOption.wordWrapBreakAfterCharacters */
    ));
  }
  constructor(e, t) {
    this.classifier = new aX(e, t);
  }
  createLineBreaksComputer(e, t, i, n, s) {
    const o = [], a = [], l = [];
    return {
      addRequest: (d, c, h) => {
        o.push(d), a.push(c), l.push(h);
      },
      finalize: () => {
        const d = e.typicalFullwidthCharacterWidth / e.typicalHalfwidthCharacterWidth, c = [];
        for (let h = 0, u = o.length; h < u; h++) {
          const g = a[h], f = l[h];
          f && !f.injectionOptions && !g ? c[h] = lX(this.classifier, f, o[h], t, i, d, n, s) : c[h] = dX(this.classifier, o[h], g, t, i, d, n, s);
        }
        return uI.length = 0, gI.length = 0, c;
      }
    };
  }
}
class aX extends I5 {
  constructor(e, t) {
    super(
      0
      /* CharacterClass.NONE */
    );
    for (let i = 0; i < e.length; i++)
      this.set(
        e.charCodeAt(i),
        1
        /* CharacterClass.BREAK_BEFORE */
      );
    for (let i = 0; i < t.length; i++)
      this.set(
        t.charCodeAt(i),
        2
        /* CharacterClass.BREAK_AFTER */
      );
  }
  get(e) {
    return e >= 0 && e < 256 ? this._asciiMap[e] : e >= 12352 && e <= 12543 || e >= 13312 && e <= 19903 || e >= 19968 && e <= 40959 ? 3 : this._map.get(e) || this._defaultValue;
  }
}
let uI = [], gI = [];
function lX(r, e, t, i, n, s, o, a) {
  if (n === -1)
    return null;
  const l = t.length;
  if (l <= 1)
    return null;
  const d = a === "keepAll", c = e.breakOffsets, h = e.breakOffsetsVisibleColumn, u = P2(t, i, n, s, o), g = n - u, f = uI, m = gI;
  let _ = 0, v = 0, b = 0, C = n;
  const w = c.length;
  let S = 0;
  if (S >= 0) {
    let y = Math.abs(h[S] - C);
    for (; S + 1 < w; ) {
      const k = Math.abs(h[S + 1] - C);
      if (k >= y)
        break;
      y = k, S++;
    }
  }
  for (; S < w; ) {
    let y = S < 0 ? 0 : c[S], k = S < 0 ? 0 : h[S];
    v > y && (y = v, k = b);
    let E = 0, N = 0, F = 0, V = 0;
    if (k <= C) {
      let H = k, re = y === 0 ? 0 : t.charCodeAt(y - 1), ue = y === 0 ? 0 : r.get(re), Ve = !0;
      for (let Ye = y; Ye < l; Ye++) {
        const ze = Ye, pe = t.charCodeAt(Ye);
        let $e, Be;
        if ($n(pe) ? (Ye++, $e = 0, Be = 2) : ($e = r.get(pe), Be = u_(pe, H, i, s)), ze > v && fI(re, ue, pe, $e, d) && (E = ze, N = H), H += Be, H > C) {
          ze > v ? (F = ze, V = H - Be) : (F = Ye + 1, V = H), H - N > g && (E = 0), Ve = !1;
          break;
        }
        re = pe, ue = $e;
      }
      if (Ve) {
        _ > 0 && (f[_] = c[c.length - 1], m[_] = h[c.length - 1], _++);
        break;
      }
    }
    if (E === 0) {
      let H = k, re = t.charCodeAt(y), ue = r.get(re), Ve = !1;
      for (let Ye = y - 1; Ye >= v; Ye--) {
        const ze = Ye + 1, pe = t.charCodeAt(Ye);
        if (pe === 9) {
          Ve = !0;
          break;
        }
        let $e, Be;
        if (iH(pe) ? (Ye--, $e = 0, Be = 2) : ($e = r.get(pe), Be = kc(pe) ? s : 1), H <= C) {
          if (F === 0 && (F = ze, V = H), H <= C - g)
            break;
          if (fI(pe, $e, re, ue, d)) {
            E = ze, N = H;
            break;
          }
        }
        H -= Be, re = pe, ue = $e;
      }
      if (E !== 0) {
        const Ye = g - (V - N);
        if (Ye <= i) {
          const ze = t.charCodeAt(F);
          let pe;
          $n(ze) ? pe = 2 : pe = u_(ze, V, i, s), Ye - pe < 0 && (E = 0);
        }
      }
      if (Ve) {
        S--;
        continue;
      }
    }
    if (E === 0 && (E = F, N = V), E <= v) {
      const H = t.charCodeAt(v);
      $n(H) ? (E = v + 2, N = b + 2) : (E = v + 1, N = b + u_(H, b, i, s));
    }
    for (v = E, f[_] = E, b = N, m[_] = N, _++, C = N + g; S < 0 || S < w && h[S] < N; )
      S++;
    let Z = Math.abs(h[S] - C);
    for (; S + 1 < w; ) {
      const H = Math.abs(h[S + 1] - C);
      if (H >= Z)
        break;
      Z = H, S++;
    }
  }
  return _ === 0 ? null : (f.length = _, m.length = _, uI = e.breakOffsets, gI = e.breakOffsetsVisibleColumn, e.breakOffsets = f, e.breakOffsetsVisibleColumn = m, e.wrappedTextIndentLength = u, e);
}
function dX(r, e, t, i, n, s, o, a) {
  const l = ea.applyInjectedText(e, t);
  let d, c;
  if (t && t.length > 0 ? (d = t.map((N) => N.options), c = t.map((N) => N.column - 1)) : (d = null, c = null), n === -1)
    return d ? new a_(c, d, [l.length], [], 0) : null;
  const h = l.length;
  if (h <= 1)
    return d ? new a_(c, d, [l.length], [], 0) : null;
  const u = a === "keepAll", g = P2(l, i, n, s, o), f = n - g, m = [], _ = [];
  let v = 0, b = 0, C = 0, w = n, S = l.charCodeAt(0), y = r.get(S), k = u_(S, 0, i, s), E = 1;
  $n(S) && (k += 1, S = l.charCodeAt(1), y = r.get(S), E++);
  for (let N = E; N < h; N++) {
    const F = N, V = l.charCodeAt(N);
    let Z, H;
    $n(V) ? (N++, Z = 0, H = 2) : (Z = r.get(V), H = u_(V, k, i, s)), fI(S, y, V, Z, u) && (b = F, C = k), k += H, k > w && ((b === 0 || k - C > f) && (b = F, C = k - H), m[v] = b, _[v] = C, v++, w = C + f, b = 0), S = V, y = Z;
  }
  return v === 0 && (!t || t.length === 0) ? null : (m[v] = h, _[v] = k, new a_(c, d, m, _, g));
}
function u_(r, e, t, i) {
  return r === 9 ? t - e % t : kc(r) || r < 32 ? i : 1;
}
function oO(r, e) {
  return e - r % e;
}
function fI(r, e, t, i, n) {
  return t !== 32 && (e === 2 && i !== 2 || e !== 1 && i === 1 || !n && e === 3 && i !== 2 || !n && i === 3 && e !== 1);
}
function P2(r, e, t, i, n) {
  let s = 0;
  if (n !== 0) {
    const o = ns(r);
    if (o !== -1) {
      for (let l = 0; l < o; l++) {
        const d = r.charCodeAt(l) === 9 ? oO(s, e) : 1;
        s += d;
      }
      const a = n === 3 ? 2 : n === 2 ? 1 : 0;
      for (let l = 0; l < a; l++) {
        const d = oO(s, e);
        s += d;
      }
      s + i > t && (s = 0);
    }
  }
  return s;
}
class NS {
  constructor(e) {
    this._selTrackedRange = null, this._trackSelection = !0, this._setState(e, new un(new L(1, 1, 1, 1), 0, 0, new A(1, 1), 0), new un(new L(1, 1, 1, 1), 0, 0, new A(1, 1), 0));
  }
  dispose(e) {
    this._removeTrackedRange(e);
  }
  startTrackingSelection(e) {
    this._trackSelection = !0, this._updateTrackedRange(e);
  }
  stopTrackingSelection(e) {
    this._trackSelection = !1, this._removeTrackedRange(e);
  }
  _updateTrackedRange(e) {
    this._trackSelection && (this._selTrackedRange = e.model._setTrackedRange(
      this._selTrackedRange,
      this.modelState.selection,
      0
      /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */
    ));
  }
  _removeTrackedRange(e) {
    this._selTrackedRange = e.model._setTrackedRange(
      this._selTrackedRange,
      null,
      0
      /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */
    );
  }
  asCursorState() {
    return new dt(this.modelState, this.viewState);
  }
  readSelectionFromMarkers(e) {
    const t = e.model._getTrackedRange(this._selTrackedRange);
    return this.modelState.selection.isEmpty() && !t.isEmpty() ? ge.fromRange(t.collapseToEnd(), this.modelState.selection.getDirection()) : ge.fromRange(t, this.modelState.selection.getDirection());
  }
  ensureValidState(e) {
    this._setState(e, this.modelState, this.viewState);
  }
  setState(e, t, i) {
    this._setState(e, t, i);
  }
  static _validatePositionWithCache(e, t, i, n) {
    return t.equals(i) ? n : e.normalizePosition(
      t,
      2
      /* PositionAffinity.None */
    );
  }
  static _validateViewState(e, t) {
    const i = t.position, n = t.selectionStart.getStartPosition(), s = t.selectionStart.getEndPosition(), o = e.normalizePosition(
      i,
      2
      /* PositionAffinity.None */
    ), a = this._validatePositionWithCache(e, n, i, o), l = this._validatePositionWithCache(e, s, n, a);
    return i.equals(o) && n.equals(a) && s.equals(l) ? t : new un(L.fromPositions(a, l), t.selectionStartKind, t.selectionStartLeftoverVisibleColumns + n.column - a.column, o, t.leftoverVisibleColumns + i.column - o.column);
  }
  _setState(e, t, i) {
    if (i && (i = NS._validateViewState(e.viewModel, i)), t) {
      const n = e.model.validateRange(t.selectionStart), s = t.selectionStart.equalsRange(n) ? t.selectionStartLeftoverVisibleColumns : 0, o = e.model.validatePosition(t.position), a = t.position.equals(o) ? t.leftoverVisibleColumns : 0;
      t = new un(n, t.selectionStartKind, s, o, a);
    } else {
      if (!i)
        return;
      const n = e.model.validateRange(e.coordinatesConverter.convertViewRangeToModelRange(i.selectionStart)), s = e.model.validatePosition(e.coordinatesConverter.convertViewPositionToModelPosition(i.position));
      t = new un(n, i.selectionStartKind, i.selectionStartLeftoverVisibleColumns, s, i.leftoverVisibleColumns);
    }
    if (i) {
      const n = e.coordinatesConverter.validateViewRange(i.selectionStart, t.selectionStart), s = e.coordinatesConverter.validateViewPosition(i.position, t.position);
      i = new un(n, t.selectionStartKind, t.selectionStartLeftoverVisibleColumns, s, t.leftoverVisibleColumns);
    } else {
      const n = e.coordinatesConverter.convertModelPositionToViewPosition(new A(t.selectionStart.startLineNumber, t.selectionStart.startColumn)), s = e.coordinatesConverter.convertModelPositionToViewPosition(new A(t.selectionStart.endLineNumber, t.selectionStart.endColumn)), o = new L(n.lineNumber, n.column, s.lineNumber, s.column), a = e.coordinatesConverter.convertModelPositionToViewPosition(t.position);
      i = new un(o, t.selectionStartKind, t.selectionStartLeftoverVisibleColumns, a, t.leftoverVisibleColumns);
    }
    this.modelState = t, this.viewState = i, this._updateTrackedRange(e);
  }
}
class rO {
  constructor(e) {
    this.context = e, this.cursors = [new NS(e)], this.lastAddedCursorIndex = 0;
  }
  dispose() {
    for (const e of this.cursors)
      e.dispose(this.context);
  }
  startTrackingSelections() {
    for (const e of this.cursors)
      e.startTrackingSelection(this.context);
  }
  stopTrackingSelections() {
    for (const e of this.cursors)
      e.stopTrackingSelection(this.context);
  }
  updateContext(e) {
    this.context = e;
  }
  ensureValidState() {
    for (const e of this.cursors)
      e.ensureValidState(this.context);
  }
  readSelectionFromMarkers() {
    return this.cursors.map((e) => e.readSelectionFromMarkers(this.context));
  }
  getAll() {
    return this.cursors.map((e) => e.asCursorState());
  }
  getViewPositions() {
    return this.cursors.map((e) => e.viewState.position);
  }
  getTopMostViewPosition() {
    return E5(this.cursors, cr((e) => e.viewState.position, A.compare)).viewState.position;
  }
  getBottomMostViewPosition() {
    return T5(this.cursors, cr((e) => e.viewState.position, A.compare)).viewState.position;
  }
  getSelections() {
    return this.cursors.map((e) => e.modelState.selection);
  }
  getViewSelections() {
    return this.cursors.map((e) => e.viewState.selection);
  }
  setSelections(e) {
    this.setStates(dt.fromModelSelections(e));
  }
  getPrimaryCursor() {
    return this.cursors[0].asCursorState();
  }
  setStates(e) {
    e !== null && (this.cursors[0].setState(this.context, e[0].modelState, e[0].viewState), this._setSecondaryStates(e.slice(1)));
  }
  /**
   * Creates or disposes secondary cursors as necessary to match the number of `secondarySelections`.
   */
  _setSecondaryStates(e) {
    const t = this.cursors.length - 1, i = e.length;
    if (t < i) {
      const n = i - t;
      for (let s = 0; s < n; s++)
        this._addSecondaryCursor();
    } else if (t > i) {
      const n = t - i;
      for (let s = 0; s < n; s++)
        this._removeSecondaryCursor(this.cursors.length - 2);
    }
    for (let n = 0; n < i; n++)
      this.cursors[n + 1].setState(this.context, e[n].modelState, e[n].viewState);
  }
  killSecondaryCursors() {
    this._setSecondaryStates([]);
  }
  _addSecondaryCursor() {
    this.cursors.push(new NS(this.context)), this.lastAddedCursorIndex = this.cursors.length - 1;
  }
  getLastAddedCursorIndex() {
    return this.cursors.length === 1 || this.lastAddedCursorIndex === 0 ? 0 : this.lastAddedCursorIndex;
  }
  _removeSecondaryCursor(e) {
    this.lastAddedCursorIndex >= e + 1 && this.lastAddedCursorIndex--, this.cursors[e + 1].dispose(this.context), this.cursors.splice(e + 1, 1);
  }
  normalize() {
    if (this.cursors.length === 1)
      return;
    const e = this.cursors.slice(0), t = [];
    for (let i = 0, n = e.length; i < n; i++)
      t.push({
        index: i,
        selection: e[i].modelState.selection
      });
    t.sort(cr((i) => i.selection, L.compareRangesUsingStarts));
    for (let i = 0; i < t.length - 1; i++) {
      const n = t[i], s = t[i + 1], o = n.selection, a = s.selection;
      if (!this.context.cursorConfig.multiCursorMergeOverlapping)
        continue;
      let l;
      if (a.isEmpty() || o.isEmpty() ? l = a.getStartPosition().isBeforeOrEqual(o.getEndPosition()) : l = a.getStartPosition().isBefore(o.getEndPosition()), l) {
        const d = n.index < s.index ? i : i + 1, c = n.index < s.index ? i + 1 : i, h = t[c].index, u = t[d].index, g = t[c].selection, f = t[d].selection;
        if (!g.equalsSelection(f)) {
          const m = g.plusRange(f), _ = g.selectionStartLineNumber === g.startLineNumber && g.selectionStartColumn === g.startColumn, v = f.selectionStartLineNumber === f.startLineNumber && f.selectionStartColumn === f.startColumn;
          let b;
          h === this.lastAddedCursorIndex ? (b = _, this.lastAddedCursorIndex = u) : b = v;
          let C;
          b ? C = new ge(m.startLineNumber, m.startColumn, m.endLineNumber, m.endColumn) : C = new ge(m.endLineNumber, m.endColumn, m.startLineNumber, m.startColumn), t[d].selection = C;
          const w = dt.fromModelSelection(C);
          e[u].setState(this.context, w.modelState, w.viewState);
        }
        for (const m of t)
          m.index > h && m.index--;
        e.splice(h, 1), t.splice(c, 1), this._removeSecondaryCursor(h - 1), i--;
      }
    }
  }
}
class aO {
  constructor(e, t, i, n) {
    this._cursorContextBrand = void 0, this.model = e, this.viewModel = t, this.coordinatesConverter = i, this.cursorConfig = n;
  }
}
class cX {
  constructor() {
    this.type = 0;
  }
}
class hX {
  constructor() {
    this.type = 1;
  }
}
class uX {
  constructor(e) {
    this.type = 2, this._source = e;
  }
  hasChanged(e) {
    return this._source.hasChanged(e);
  }
}
class gX {
  constructor(e, t, i) {
    this.selections = e, this.modelSelections = t, this.reason = i, this.type = 3;
  }
}
class vh {
  constructor(e) {
    this.type = 4, e ? (this.affectsMinimap = e.affectsMinimap, this.affectsOverviewRuler = e.affectsOverviewRuler, this.affectsGlyphMargin = e.affectsGlyphMargin, this.affectsLineNumber = e.affectsLineNumber) : (this.affectsMinimap = !0, this.affectsOverviewRuler = !0, this.affectsGlyphMargin = !0, this.affectsLineNumber = !0);
  }
}
class DC {
  constructor() {
    this.type = 5;
  }
}
class fX {
  constructor(e) {
    this.type = 6, this.isFocused = e;
  }
}
class pX {
  constructor() {
    this.type = 7;
  }
}
class kC {
  constructor() {
    this.type = 8;
  }
}
class O2 {
  constructor(e, t) {
    this.fromLineNumber = e, this.count = t, this.type = 9;
  }
}
class pI {
  constructor(e, t) {
    this.type = 10, this.fromLineNumber = e, this.toLineNumber = t;
  }
}
class mI {
  constructor(e, t) {
    this.type = 11, this.fromLineNumber = e, this.toLineNumber = t;
  }
}
class g_ {
  constructor(e, t, i, n, s, o, a) {
    this.source = e, this.minimalReveal = t, this.range = i, this.selections = n, this.verticalType = s, this.revealHorizontal = o, this.scrollType = a, this.type = 12;
  }
}
class mX {
  constructor(e) {
    this.type = 13, this.scrollWidth = e.scrollWidth, this.scrollLeft = e.scrollLeft, this.scrollHeight = e.scrollHeight, this.scrollTop = e.scrollTop, this.scrollWidthChanged = e.scrollWidthChanged, this.scrollLeftChanged = e.scrollLeftChanged, this.scrollHeightChanged = e.scrollHeightChanged, this.scrollTopChanged = e.scrollTopChanged;
  }
}
class _X {
  constructor(e) {
    this.theme = e, this.type = 14;
  }
}
class vX {
  constructor(e) {
    this.type = 15, this.ranges = e;
  }
}
class bX {
  constructor() {
    this.type = 16;
  }
}
let CX = class {
  constructor() {
    this.type = 17;
  }
};
class wX extends P {
  constructor() {
    super(), this._onEvent = this._register(new R()), this.onEvent = this._onEvent.event, this._eventHandlers = [], this._viewEventQueue = null, this._isConsumingViewEventQueue = !1, this._collector = null, this._collectorCnt = 0, this._outgoingEvents = [];
  }
  emitOutgoingEvent(e) {
    this._addOutgoingEvent(e), this._emitOutgoingEvents();
  }
  _addOutgoingEvent(e) {
    for (let t = 0, i = this._outgoingEvents.length; t < i; t++) {
      const n = this._outgoingEvents[t].kind === e.kind ? this._outgoingEvents[t].attemptToMerge(e) : null;
      if (n) {
        this._outgoingEvents[t] = n;
        return;
      }
    }
    this._outgoingEvents.push(e);
  }
  _emitOutgoingEvents() {
    for (; this._outgoingEvents.length > 0; ) {
      if (this._collector || this._isConsumingViewEventQueue)
        return;
      const e = this._outgoingEvents.shift();
      e.isNoOp() || this._onEvent.fire(e);
    }
  }
  addViewEventHandler(e) {
    for (let t = 0, i = this._eventHandlers.length; t < i; t++)
      this._eventHandlers[t] === e && console.warn("Detected duplicate listener in ViewEventDispatcher", e);
    this._eventHandlers.push(e);
  }
  removeViewEventHandler(e) {
    for (let t = 0; t < this._eventHandlers.length; t++)
      if (this._eventHandlers[t] === e) {
        this._eventHandlers.splice(t, 1);
        break;
      }
  }
  beginEmitViewEvents() {
    return this._collectorCnt++, this._collectorCnt === 1 && (this._collector = new SX()), this._collector;
  }
  endEmitViewEvents() {
    if (this._collectorCnt--, this._collectorCnt === 0) {
      const e = this._collector.outgoingEvents, t = this._collector.viewEvents;
      this._collector = null;
      for (const i of e)
        this._addOutgoingEvent(i);
      t.length > 0 && this._emitMany(t);
    }
    this._emitOutgoingEvents();
  }
  emitSingleViewEvent(e) {
    try {
      this.beginEmitViewEvents().emitViewEvent(e);
    } finally {
      this.endEmitViewEvents();
    }
  }
  _emitMany(e) {
    this._viewEventQueue ? this._viewEventQueue = this._viewEventQueue.concat(e) : this._viewEventQueue = e, this._isConsumingViewEventQueue || this._consumeViewEventQueue();
  }
  _consumeViewEventQueue() {
    try {
      this._isConsumingViewEventQueue = !0, this._doConsumeQueue();
    } finally {
      this._isConsumingViewEventQueue = !1;
    }
  }
  _doConsumeQueue() {
    for (; this._viewEventQueue; ) {
      const e = this._viewEventQueue;
      this._viewEventQueue = null;
      const t = this._eventHandlers.slice(0);
      for (const i of t)
        i.handleEvents(e);
    }
  }
}
class SX {
  constructor() {
    this.viewEvents = [], this.outgoingEvents = [];
  }
  emitViewEvent(e) {
    this.viewEvents.push(e);
  }
  emitOutgoingEvent(e) {
    this.outgoingEvents.push(e);
  }
}
class j1 {
  constructor(e, t, i, n) {
    this.kind = 0, this._oldContentWidth = e, this._oldContentHeight = t, this.contentWidth = i, this.contentHeight = n, this.contentWidthChanged = this._oldContentWidth !== this.contentWidth, this.contentHeightChanged = this._oldContentHeight !== this.contentHeight;
  }
  isNoOp() {
    return !this.contentWidthChanged && !this.contentHeightChanged;
  }
  attemptToMerge(e) {
    return e.kind !== this.kind ? null : new j1(this._oldContentWidth, this._oldContentHeight, e.contentWidth, e.contentHeight);
  }
}
class q1 {
  constructor(e, t) {
    this.kind = 1, this.oldHasFocus = e, this.hasFocus = t;
  }
  isNoOp() {
    return this.oldHasFocus === this.hasFocus;
  }
  attemptToMerge(e) {
    return e.kind !== this.kind ? null : new q1(this.oldHasFocus, e.hasFocus);
  }
}
class G1 {
  constructor(e, t, i, n, s, o, a, l) {
    this.kind = 2, this._oldScrollWidth = e, this._oldScrollLeft = t, this._oldScrollHeight = i, this._oldScrollTop = n, this.scrollWidth = s, this.scrollLeft = o, this.scrollHeight = a, this.scrollTop = l, this.scrollWidthChanged = this._oldScrollWidth !== this.scrollWidth, this.scrollLeftChanged = this._oldScrollLeft !== this.scrollLeft, this.scrollHeightChanged = this._oldScrollHeight !== this.scrollHeight, this.scrollTopChanged = this._oldScrollTop !== this.scrollTop;
  }
  isNoOp() {
    return !this.scrollWidthChanged && !this.scrollLeftChanged && !this.scrollHeightChanged && !this.scrollTopChanged;
  }
  attemptToMerge(e) {
    return e.kind !== this.kind ? null : new G1(this._oldScrollWidth, this._oldScrollLeft, this._oldScrollHeight, this._oldScrollTop, e.scrollWidth, e.scrollLeft, e.scrollHeight, e.scrollTop);
  }
}
class yX {
  constructor() {
    this.kind = 3;
  }
  isNoOp() {
    return !1;
  }
  attemptToMerge(e) {
    return e.kind !== this.kind ? null : this;
  }
}
class LX {
  constructor() {
    this.kind = 4;
  }
  isNoOp() {
    return !1;
  }
  attemptToMerge(e) {
    return e.kind !== this.kind ? null : this;
  }
}
class MS {
  constructor(e, t, i, n, s, o, a) {
    this.kind = 6, this.oldSelections = e, this.selections = t, this.oldModelVersionId = i, this.modelVersionId = n, this.source = s, this.reason = o, this.reachedMaxCursorCount = a;
  }
  static _selectionsAreEqual(e, t) {
    if (!e && !t)
      return !0;
    if (!e || !t)
      return !1;
    const i = e.length, n = t.length;
    if (i !== n)
      return !1;
    for (let s = 0; s < i; s++)
      if (!e[s].equalsSelection(t[s]))
        return !1;
    return !0;
  }
  isNoOp() {
    return MS._selectionsAreEqual(this.oldSelections, this.selections) && this.oldModelVersionId === this.modelVersionId;
  }
  attemptToMerge(e) {
    return e.kind !== this.kind ? null : new MS(this.oldSelections, e.selections, this.oldModelVersionId, e.modelVersionId, e.source, e.reason, this.reachedMaxCursorCount || e.reachedMaxCursorCount);
  }
}
class DX {
  constructor() {
    this.kind = 5;
  }
  isNoOp() {
    return !1;
  }
  attemptToMerge(e) {
    return e.kind !== this.kind ? null : this;
  }
}
class kX {
  constructor(e) {
    this.event = e, this.kind = 7;
  }
  isNoOp() {
    return !1;
  }
  attemptToMerge(e) {
    return null;
  }
}
class xX {
  constructor(e) {
    this.event = e, this.kind = 8;
  }
  isNoOp() {
    return !1;
  }
  attemptToMerge(e) {
    return null;
  }
}
class IX {
  constructor(e) {
    this.event = e, this.kind = 9;
  }
  isNoOp() {
    return !1;
  }
  attemptToMerge(e) {
    return null;
  }
}
class EX {
  constructor(e) {
    this.event = e, this.kind = 10;
  }
  isNoOp() {
    return !1;
  }
  attemptToMerge(e) {
    return null;
  }
}
class TX {
  constructor(e) {
    this.event = e, this.kind = 11;
  }
  isNoOp() {
    return !1;
  }
  attemptToMerge(e) {
    return null;
  }
}
class NX {
  constructor(e) {
    this.event = e, this.kind = 12;
  }
  isNoOp() {
    return !1;
  }
  attemptToMerge(e) {
    return null;
  }
}
class MX extends P {
  constructor(e, t, i, n) {
    super(), this._model = e, this._knownModelVersionId = this._model.getVersionId(), this._viewModel = t, this._coordinatesConverter = i, this.context = new aO(this._model, this._viewModel, this._coordinatesConverter, n), this._cursors = new rO(this.context), this._hasFocus = !1, this._isHandling = !1, this._compositionState = null, this._columnSelectData = null, this._autoClosedActions = [], this._prevEditOperationType = 0;
  }
  dispose() {
    this._cursors.dispose(), this._autoClosedActions = zt(this._autoClosedActions), super.dispose();
  }
  updateConfiguration(e) {
    this.context = new aO(this._model, this._viewModel, this._coordinatesConverter, e), this._cursors.updateContext(this.context);
  }
  onLineMappingChanged(e) {
    this._knownModelVersionId === this._model.getVersionId() && this.setStates(e, "viewModel", 0, this.getCursorStates());
  }
  setHasFocus(e) {
    this._hasFocus = e;
  }
  _validateAutoClosedActions() {
    if (this._autoClosedActions.length > 0) {
      const e = this._cursors.getSelections();
      for (let t = 0; t < this._autoClosedActions.length; t++) {
        const i = this._autoClosedActions[t];
        i.isValid(e) || (i.dispose(), this._autoClosedActions.splice(t, 1), t--);
      }
    }
  }
  // ------ some getters/setters
  getPrimaryCursorState() {
    return this._cursors.getPrimaryCursor();
  }
  getLastAddedCursorIndex() {
    return this._cursors.getLastAddedCursorIndex();
  }
  getCursorStates() {
    return this._cursors.getAll();
  }
  setStates(e, t, i, n) {
    let s = !1;
    const o = this.context.cursorConfig.multiCursorLimit;
    n !== null && n.length > o && (n = n.slice(0, o), s = !0);
    const a = f_.from(this._model, this);
    return this._cursors.setStates(n), this._cursors.normalize(), this._columnSelectData = null, this._validateAutoClosedActions(), this._emitStateChangedIfNecessary(e, t, i, a, s);
  }
  setCursorColumnSelectData(e) {
    this._columnSelectData = e;
  }
  revealAll(e, t, i, n, s, o) {
    const a = this._cursors.getViewPositions();
    let l = null, d = null;
    a.length > 1 ? d = this._cursors.getViewSelections() : l = L.fromPositions(a[0], a[0]), e.emitViewEvent(new g_(t, i, l, d, n, s, o));
  }
  revealPrimary(e, t, i, n, s, o) {
    const l = [this._cursors.getPrimaryCursor().viewState.selection];
    e.emitViewEvent(new g_(t, i, null, l, n, s, o));
  }
  saveState() {
    const e = [], t = this._cursors.getSelections();
    for (let i = 0, n = t.length; i < n; i++) {
      const s = t[i];
      e.push({
        inSelectionMode: !s.isEmpty(),
        selectionStart: {
          lineNumber: s.selectionStartLineNumber,
          column: s.selectionStartColumn
        },
        position: {
          lineNumber: s.positionLineNumber,
          column: s.positionColumn
        }
      });
    }
    return e;
  }
  restoreState(e, t) {
    const i = [];
    for (let n = 0, s = t.length; n < s; n++) {
      const o = t[n];
      let a = 1, l = 1;
      o.position && o.position.lineNumber && (a = o.position.lineNumber), o.position && o.position.column && (l = o.position.column);
      let d = a, c = l;
      o.selectionStart && o.selectionStart.lineNumber && (d = o.selectionStart.lineNumber), o.selectionStart && o.selectionStart.column && (c = o.selectionStart.column), i.push({
        selectionStartLineNumber: d,
        selectionStartColumn: c,
        positionLineNumber: a,
        positionColumn: l
      });
    }
    this.setStates(e, "restoreState", 0, dt.fromModelSelections(i)), this.revealAll(
      e,
      "restoreState",
      !1,
      0,
      !0,
      1
      /* editorCommon.ScrollType.Immediate */
    );
  }
  onModelContentChanged(e, t) {
    if (t instanceof g2) {
      if (this._isHandling)
        return;
      this._isHandling = !0;
      try {
        this.setStates(e, "modelChange", 0, this.getCursorStates());
      } finally {
        this._isHandling = !1;
      }
    } else {
      const i = t.rawContentChangedEvent;
      if (this._knownModelVersionId = i.versionId, this._isHandling)
        return;
      const n = i.containsEvent(
        1
        /* RawContentChangedType.Flush */
      );
      if (this._prevEditOperationType = 0, n)
        this._cursors.dispose(), this._cursors = new rO(this.context), this._validateAutoClosedActions(), this._emitStateChangedIfNecessary(e, "model", 1, null, !1);
      else if (this._hasFocus && i.resultingSelection && i.resultingSelection.length > 0) {
        const s = dt.fromModelSelections(i.resultingSelection);
        this.setStates(e, "modelChange", i.isUndoing ? 5 : i.isRedoing ? 6 : 2, s) && this.revealAll(
          e,
          "modelChange",
          !1,
          0,
          !0,
          0
          /* editorCommon.ScrollType.Smooth */
        );
      } else {
        const s = this._cursors.readSelectionFromMarkers();
        this.setStates(e, "modelChange", 2, dt.fromModelSelections(s));
      }
    }
  }
  getSelection() {
    return this._cursors.getPrimaryCursor().modelState.selection;
  }
  getTopMostViewPosition() {
    return this._cursors.getTopMostViewPosition();
  }
  getBottomMostViewPosition() {
    return this._cursors.getBottomMostViewPosition();
  }
  getCursorColumnSelectData() {
    if (this._columnSelectData)
      return this._columnSelectData;
    const e = this._cursors.getPrimaryCursor(), t = e.viewState.selectionStart.getStartPosition(), i = e.viewState.position;
    return {
      isReal: !1,
      fromViewLineNumber: t.lineNumber,
      fromViewVisualColumn: this.context.cursorConfig.visibleColumnFromColumn(this._viewModel, t),
      toViewLineNumber: i.lineNumber,
      toViewVisualColumn: this.context.cursorConfig.visibleColumnFromColumn(this._viewModel, i)
    };
  }
  getSelections() {
    return this._cursors.getSelections();
  }
  setSelections(e, t, i, n) {
    this.setStates(e, t, n, dt.fromModelSelections(i));
  }
  getPrevEditOperationType() {
    return this._prevEditOperationType;
  }
  setPrevEditOperationType(e) {
    this._prevEditOperationType = e;
  }
  // ------ auxiliary handling logic
  _pushAutoClosedAction(e, t) {
    const i = [], n = [];
    for (let a = 0, l = e.length; a < l; a++)
      i.push({
        range: e[a],
        options: {
          description: "auto-closed-character",
          inlineClassName: "auto-closed-character",
          stickiness: 1
          /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */
        }
      }), n.push({
        range: t[a],
        options: {
          description: "auto-closed-enclosing",
          stickiness: 1
          /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */
        }
      });
    const s = this._model.deltaDecorations([], i), o = this._model.deltaDecorations([], n);
    this._autoClosedActions.push(new lO(this._model, s, o));
  }
  _executeEditOperation(e) {
    if (!e)
      return;
    e.shouldPushStackElementBefore && this._model.pushStackElement();
    const t = RX.executeCommands(this._model, this._cursors.getSelections(), e.commands);
    if (t) {
      this._interpretCommandResult(t);
      const i = [], n = [];
      for (let s = 0; s < e.commands.length; s++) {
        const o = e.commands[s];
        o instanceof s2 && o.enclosingRange && o.closeCharacterRange && (i.push(o.closeCharacterRange), n.push(o.enclosingRange));
      }
      i.length > 0 && this._pushAutoClosedAction(i, n), this._prevEditOperationType = e.type;
    }
    e.shouldPushStackElementAfter && this._model.pushStackElement();
  }
  _interpretCommandResult(e) {
    (!e || e.length === 0) && (e = this._cursors.readSelectionFromMarkers()), this._columnSelectData = null, this._cursors.setSelections(e), this._cursors.normalize();
  }
  // -----------------------------------------------------------------------------------------------------------
  // ----- emitting events
  _emitStateChangedIfNecessary(e, t, i, n, s) {
    const o = f_.from(this._model, this);
    if (o.equals(n))
      return !1;
    const a = this._cursors.getSelections(), l = this._cursors.getViewSelections();
    if (e.emitViewEvent(new gX(l, a, i)), !n || n.cursorState.length !== o.cursorState.length || o.cursorState.some((d, c) => !d.modelState.equals(n.cursorState[c].modelState))) {
      const d = n ? n.cursorState.map((h) => h.modelState.selection) : null, c = n ? n.modelVersionId : 0;
      e.emitOutgoingEvent(new MS(d, a, c, o.modelVersionId, t || "keyboard", i, s));
    }
    return !0;
  }
  // -----------------------------------------------------------------------------------------------------------
  // ----- handlers beyond this point
  _findAutoClosingPairs(e) {
    if (!e.length)
      return null;
    const t = [];
    for (let i = 0, n = e.length; i < n; i++) {
      const s = e[i];
      if (!s.text || s.text.indexOf(`
`) >= 0)
        return null;
      const o = s.text.match(/([)\]}>'"`])([^)\]}>'"`]*)$/);
      if (!o)
        return null;
      const a = o[1], l = this.context.cursorConfig.autoClosingPairs.autoClosingPairsCloseSingleChar.get(a);
      if (!l || l.length !== 1)
        return null;
      const d = l[0].open, c = s.text.length - o[2].length - 1, h = s.text.lastIndexOf(d, c - 1);
      if (h === -1)
        return null;
      t.push([h, c]);
    }
    return t;
  }
  executeEdits(e, t, i, n) {
    let s = null;
    t === "snippet" && (s = this._findAutoClosingPairs(i)), s && (i[0]._isTracked = !0);
    const o = [], a = [], l = this._model.pushEditOperations(this.getSelections(), i, (d) => {
      if (s)
        for (let h = 0, u = s.length; h < u; h++) {
          const [g, f] = s[h], m = d[h], _ = m.range.startLineNumber, v = m.range.startColumn - 1 + g, b = m.range.startColumn - 1 + f;
          o.push(new L(_, b + 1, _, b + 2)), a.push(new L(_, v + 1, _, b + 2));
        }
      const c = n(d);
      return c && (this._isHandling = !0), c;
    });
    l && (this._isHandling = !1, this.setSelections(
      e,
      t,
      l,
      0
      /* CursorChangeReason.NotSet */
    )), o.length > 0 && this._pushAutoClosedAction(o, a);
  }
  _executeEdit(e, t, i, n = 0) {
    if (this.context.cursorConfig.readOnly)
      return;
    const s = f_.from(this._model, this);
    this._cursors.stopTrackingSelections(), this._isHandling = !0;
    try {
      this._cursors.ensureValidState(), e();
    } catch (o) {
      He(o);
    }
    this._isHandling = !1, this._cursors.startTrackingSelections(), this._validateAutoClosedActions(), this._emitStateChangedIfNecessary(t, i, n, s, !1) && this.revealAll(
      t,
      i,
      !1,
      0,
      !0,
      0
      /* editorCommon.ScrollType.Smooth */
    );
  }
  getAutoClosedCharacters() {
    return lO.getAllAutoClosedCharacters(this._autoClosedActions);
  }
  startComposition(e) {
    this._compositionState = new p_(this._model, this.getSelections());
  }
  endComposition(e, t) {
    const i = this._compositionState ? this._compositionState.deduceOutcome(this._model, this.getSelections()) : null;
    this._compositionState = null, this._executeEdit(() => {
      t === "keyboard" && this._executeEditOperation(ni.compositionEndWithInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, i, this.getSelections(), this.getAutoClosedCharacters()));
    }, e, t);
  }
  type(e, t, i) {
    this._executeEdit(() => {
      if (i === "keyboard") {
        const n = t.length;
        let s = 0;
        for (; s < n; ) {
          const o = GB(t, s), a = t.substr(s, o);
          this._executeEditOperation(ni.typeWithInterceptors(!!this._compositionState, this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), this.getAutoClosedCharacters(), a)), s += o;
        }
      } else
        this._executeEditOperation(ni.typeWithoutInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), t));
    }, e, i);
  }
  compositionType(e, t, i, n, s, o) {
    if (t.length === 0 && i === 0 && n === 0) {
      if (s !== 0) {
        const a = this.getSelections().map((l) => {
          const d = l.getPosition();
          return new ge(d.lineNumber, d.column + s, d.lineNumber, d.column + s);
        });
        this.setSelections(
          e,
          o,
          a,
          0
          /* CursorChangeReason.NotSet */
        );
      }
      return;
    }
    this._executeEdit(() => {
      this._executeEditOperation(ni.compositionType(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), t, i, n, s));
    }, e, o);
  }
  paste(e, t, i, n, s) {
    this._executeEdit(
      () => {
        this._executeEditOperation(ni.paste(this.context.cursorConfig, this._model, this.getSelections(), t, i, n || []));
      },
      e,
      s,
      4
      /* CursorChangeReason.Paste */
    );
  }
  cut(e, t) {
    this._executeEdit(() => {
      this._executeEditOperation(yu.cut(this.context.cursorConfig, this._model, this.getSelections()));
    }, e, t);
  }
  executeCommand(e, t, i) {
    this._executeEdit(() => {
      this._cursors.killSecondaryCursors(), this._executeEditOperation(new ps(0, [t], {
        shouldPushStackElementBefore: !1,
        shouldPushStackElementAfter: !1
      }));
    }, e, i);
  }
  executeCommands(e, t, i) {
    this._executeEdit(() => {
      this._executeEditOperation(new ps(0, t, {
        shouldPushStackElementBefore: !1,
        shouldPushStackElementAfter: !1
      }));
    }, e, i);
  }
}
class f_ {
  static from(e, t) {
    return new f_(e.getVersionId(), t.getCursorStates());
  }
  constructor(e, t) {
    this.modelVersionId = e, this.cursorState = t;
  }
  equals(e) {
    if (!e || this.modelVersionId !== e.modelVersionId || this.cursorState.length !== e.cursorState.length)
      return !1;
    for (let t = 0, i = this.cursorState.length; t < i; t++)
      if (!this.cursorState[t].equals(e.cursorState[t]))
        return !1;
    return !0;
  }
}
class lO {
  static getAllAutoClosedCharacters(e) {
    let t = [];
    for (const i of e)
      t = t.concat(i.getAutoClosedCharactersRanges());
    return t;
  }
  constructor(e, t, i) {
    this._model = e, this._autoClosedCharactersDecorations = t, this._autoClosedEnclosingDecorations = i;
  }
  dispose() {
    this._autoClosedCharactersDecorations = this._model.deltaDecorations(this._autoClosedCharactersDecorations, []), this._autoClosedEnclosingDecorations = this._model.deltaDecorations(this._autoClosedEnclosingDecorations, []);
  }
  getAutoClosedCharactersRanges() {
    const e = [];
    for (let t = 0; t < this._autoClosedCharactersDecorations.length; t++) {
      const i = this._model.getDecorationRange(this._autoClosedCharactersDecorations[t]);
      i && e.push(i);
    }
    return e;
  }
  isValid(e) {
    const t = [];
    for (let i = 0; i < this._autoClosedEnclosingDecorations.length; i++) {
      const n = this._model.getDecorationRange(this._autoClosedEnclosingDecorations[i]);
      if (n && (t.push(n), n.startLineNumber !== n.endLineNumber))
        return !1;
    }
    t.sort(L.compareRangesUsingStarts), e.sort(L.compareRangesUsingStarts);
    for (let i = 0; i < e.length; i++)
      if (i >= t.length || !t[i].strictContainsRange(e[i]))
        return !1;
    return !0;
  }
}
class RX {
  static executeCommands(e, t, i) {
    const n = {
      model: e,
      selectionsBefore: t,
      trackedRanges: [],
      trackedRangesDirection: []
    }, s = this._innerExecuteCommands(n, i);
    for (let o = 0, a = n.trackedRanges.length; o < a; o++)
      n.model._setTrackedRange(
        n.trackedRanges[o],
        null,
        0
        /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */
      );
    return s;
  }
  static _innerExecuteCommands(e, t) {
    if (this._arrayIsEmpty(t))
      return null;
    const i = this._getEditOperations(e, t);
    if (i.operations.length === 0)
      return null;
    const n = i.operations, s = this._getLoserCursorMap(n);
    if (s.hasOwnProperty("0"))
      return console.warn("Ignoring commands"), null;
    const o = [];
    for (let d = 0, c = n.length; d < c; d++)
      s.hasOwnProperty(n[d].identifier.major.toString()) || o.push(n[d]);
    i.hadTrackedEditOperation && o.length > 0 && (o[0]._isTracked = !0);
    let a = e.model.pushEditOperations(e.selectionsBefore, o, (d) => {
      const c = [];
      for (let g = 0; g < e.selectionsBefore.length; g++)
        c[g] = [];
      for (const g of d)
        g.identifier && c[g.identifier.major].push(g);
      const h = (g, f) => g.identifier.minor - f.identifier.minor, u = [];
      for (let g = 0; g < e.selectionsBefore.length; g++)
        c[g].length > 0 ? (c[g].sort(h), u[g] = t[g].computeCursorState(e.model, {
          getInverseEditOperations: () => c[g],
          getTrackedSelection: (f) => {
            const m = parseInt(f, 10), _ = e.model._getTrackedRange(e.trackedRanges[m]);
            return e.trackedRangesDirection[m] === 0 ? new ge(_.startLineNumber, _.startColumn, _.endLineNumber, _.endColumn) : new ge(_.endLineNumber, _.endColumn, _.startLineNumber, _.startColumn);
          }
        })) : u[g] = e.selectionsBefore[g];
      return u;
    });
    a || (a = e.selectionsBefore);
    const l = [];
    for (const d in s)
      s.hasOwnProperty(d) && l.push(parseInt(d, 10));
    l.sort((d, c) => c - d);
    for (const d of l)
      a.splice(d, 1);
    return a;
  }
  static _arrayIsEmpty(e) {
    for (let t = 0, i = e.length; t < i; t++)
      if (e[t])
        return !1;
    return !0;
  }
  static _getEditOperations(e, t) {
    let i = [], n = !1;
    for (let s = 0, o = t.length; s < o; s++) {
      const a = t[s];
      if (a) {
        const l = this._getEditOperationsFromCommand(e, s, a);
        i = i.concat(l.operations), n = n || l.hadTrackedEditOperation;
      }
    }
    return {
      operations: i,
      hadTrackedEditOperation: n
    };
  }
  static _getEditOperationsFromCommand(e, t, i) {
    const n = [];
    let s = 0;
    const o = (h, u, g = !1) => {
      L.isEmpty(h) && u === "" || n.push({
        identifier: {
          major: t,
          minor: s++
        },
        range: h,
        text: u,
        forceMoveMarkers: g,
        isAutoWhitespaceEdit: i.insertsAutoWhitespace
      });
    };
    let a = !1;
    const c = {
      addEditOperation: o,
      addTrackedEditOperation: (h, u, g) => {
        a = !0, o(h, u, g);
      },
      trackSelection: (h, u) => {
        const g = ge.liftSelection(h);
        let f;
        if (g.isEmpty())
          if (typeof u == "boolean")
            u ? f = 2 : f = 3;
          else {
            const v = e.model.getLineMaxColumn(g.startLineNumber);
            g.startColumn === v ? f = 2 : f = 3;
          }
        else
          f = 1;
        const m = e.trackedRanges.length, _ = e.model._setTrackedRange(null, g, f);
        return e.trackedRanges[m] = _, e.trackedRangesDirection[m] = g.getDirection(), m.toString();
      }
    };
    try {
      i.getEditOperations(e.model, c);
    } catch (h) {
      return He(h), {
        operations: [],
        hadTrackedEditOperation: !1
      };
    }
    return {
      operations: n,
      hadTrackedEditOperation: a
    };
  }
  static _getLoserCursorMap(e) {
    e = e.slice(0), e.sort((i, n) => -L.compareRangesUsingEnds(i.range, n.range));
    const t = {};
    for (let i = 1; i < e.length; i++) {
      const n = e[i - 1], s = e[i];
      if (L.getStartPosition(n.range).isBefore(L.getEndPosition(s.range))) {
        let o;
        n.identifier.major > s.identifier.major ? o = n.identifier.major : o = s.identifier.major, t[o.toString()] = !0;
        for (let a = 0; a < e.length; a++)
          e[a].identifier.major === o && (e.splice(a, 1), a < i && i--, a--);
        i > 0 && i--;
      }
    }
    return t;
  }
}
class AX {
  constructor(e, t, i) {
    this.text = e, this.startSelection = t, this.endSelection = i;
  }
}
class p_ {
  static _capture(e, t) {
    const i = [];
    for (const n of t) {
      if (n.startLineNumber !== n.endLineNumber)
        return null;
      i.push(new AX(e.getLineContent(n.startLineNumber), n.startColumn - 1, n.endColumn - 1));
    }
    return i;
  }
  constructor(e, t) {
    this._original = p_._capture(e, t);
  }
  /**
   * Returns the inserted text during this composition.
   * If the composition resulted in existing text being changed (i.e. not a pure insertion) it returns null.
   */
  deduceOutcome(e, t) {
    if (!this._original)
      return null;
    const i = p_._capture(e, t);
    if (!i || this._original.length !== i.length)
      return null;
    const n = [];
    for (let s = 0, o = this._original.length; s < o; s++)
      n.push(p_._deduceOutcome(this._original[s], i[s]));
    return n;
  }
  static _deduceOutcome(e, t) {
    const i = Math.min(e.startSelection, t.startSelection, xc(e.text, t.text)), n = Math.min(e.text.length - e.endSelection, t.text.length - t.endSelection, rS(e.text, t.text)), s = e.text.substring(i, e.text.length - n), o = t.text.substring(i, t.text.length - n);
    return new TZ(s, e.startSelection - i, e.endSelection - i, o, t.startSelection - i, t.endSelection - i);
  }
}
const dO = {
  getInitialState: () => zf,
  tokenizeEncoded: (r, e, t) => S0(0, t)
};
async function PX(r, e, t) {
  if (!t)
    return cO(e, r.languageIdCodec, dO);
  const i = await ri.getOrCreate(t);
  return cO(e, r.languageIdCodec, i || dO);
}
function OX(r, e, t, i, n, s, o) {
  let a = "<div>", l = i, d = 0, c = !0;
  for (let h = 0, u = e.getCount(); h < u; h++) {
    const g = e.getEndOffset(h);
    if (g <= i)
      continue;
    let f = "";
    for (; l < g && l < n; l++) {
      const m = r.charCodeAt(l);
      switch (m) {
        case 9: {
          let _ = s - (l + d) % s;
          for (d += _ - 1; _ > 0; )
            o && c ? (f += "&#160;", c = !1) : (f += " ", c = !0), _--;
          break;
        }
        case 60:
          f += "&lt;", c = !1;
          break;
        case 62:
          f += "&gt;", c = !1;
          break;
        case 38:
          f += "&amp;", c = !1;
          break;
        case 0:
          f += "&#00;", c = !1;
          break;
        case 65279:
        case 8232:
        case 8233:
        case 133:
          f += "", c = !1;
          break;
        case 13:
          f += "&#8203", c = !1;
          break;
        case 32:
          o && c ? (f += "&#160;", c = !1) : (f += " ", c = !0);
          break;
        default:
          f += String.fromCharCode(m), c = !1;
      }
    }
    if (a += `<span style="${e.getInlineStyle(h, t)}">${f}</span>`, g > n || l >= n)
      break;
  }
  return a += "</div>", a;
}
function cO(r, e, t) {
  let i = '<div class="monaco-tokenized-source">';
  const n = vd(r);
  let s = t.getInitialState();
  for (let o = 0, a = n.length; o < a; o++) {
    const l = n[o];
    o > 0 && (i += "<br/>");
    const d = t.tokenizeEncoded(l, !0, s);
    Ri.convertToEndOffset(d.tokens, l.length);
    const h = new Ri(d.tokens, l, e).inflate();
    let u = 0;
    for (let g = 0, f = h.getCount(); g < f; g++) {
      const m = h.getClassName(g), _ = h.getEndOffset(g);
      i += `<span class="${m}">${Ym(l.substring(u, _))}</span>`, u = _;
    }
    s = d.endState;
  }
  return i += "</div>", i;
}
class FX {
  constructor() {
    this._hasPending = !1, this._inserts = [], this._changes = [], this._removes = [];
  }
  insert(e) {
    this._hasPending = !0, this._inserts.push(e);
  }
  change(e) {
    this._hasPending = !0, this._changes.push(e);
  }
  remove(e) {
    this._hasPending = !0, this._removes.push(e);
  }
  mustCommit() {
    return this._hasPending;
  }
  commit(e) {
    if (!this._hasPending)
      return;
    const t = this._inserts, i = this._changes, n = this._removes;
    this._hasPending = !1, this._inserts = [], this._changes = [], this._removes = [], e._commitPendingChanges(t, i, n);
  }
}
class WX {
  constructor(e, t, i, n, s) {
    this.id = e, this.afterLineNumber = t, this.ordinal = i, this.height = n, this.minWidth = s, this.prefixSum = 0;
  }
}
let F2 = class _I {
  constructor(e, t, i, n) {
    this._instanceId = tH(++_I.INSTANCE_COUNT), this._pendingChanges = new FX(), this._lastWhitespaceId = 0, this._arr = [], this._prefixSumValidIndex = -1, this._minWidth = -1, this._lineCount = e, this._lineHeight = t, this._paddingTop = i, this._paddingBottom = n;
  }
  /**
   * Find the insertion index for a new value inside a sorted array of values.
   * If the value is already present in the sorted array, the insertion index will be after the already existing value.
   */
  static findInsertionIndex(e, t, i) {
    let n = 0, s = e.length;
    for (; n < s; ) {
      const o = n + s >>> 1;
      t === e[o].afterLineNumber ? i < e[o].ordinal ? s = o : n = o + 1 : t < e[o].afterLineNumber ? s = o : n = o + 1;
    }
    return n;
  }
  /**
   * Change the height of a line in pixels.
   */
  setLineHeight(e) {
    this._checkPendingChanges(), this._lineHeight = e;
  }
  /**
   * Changes the padding used to calculate vertical offsets.
   */
  setPadding(e, t) {
    this._paddingTop = e, this._paddingBottom = t;
  }
  /**
   * Set the number of lines.
   *
   * @param lineCount New number of lines.
   */
  onFlushed(e) {
    this._checkPendingChanges(), this._lineCount = e;
  }
  changeWhitespace(e) {
    let t = !1;
    try {
      e({
        insertWhitespace: (n, s, o, a) => {
          t = !0, n = n | 0, s = s | 0, o = o | 0, a = a | 0;
          const l = this._instanceId + ++this._lastWhitespaceId;
          return this._pendingChanges.insert(new WX(l, n, s, o, a)), l;
        },
        changeOneWhitespace: (n, s, o) => {
          t = !0, s = s | 0, o = o | 0, this._pendingChanges.change({ id: n, newAfterLineNumber: s, newHeight: o });
        },
        removeWhitespace: (n) => {
          t = !0, this._pendingChanges.remove({ id: n });
        }
      });
    } finally {
      this._pendingChanges.commit(this);
    }
    return t;
  }
  _commitPendingChanges(e, t, i) {
    if ((e.length > 0 || i.length > 0) && (this._minWidth = -1), e.length + t.length + i.length <= 1) {
      for (const l of e)
        this._insertWhitespace(l);
      for (const l of t)
        this._changeOneWhitespace(l.id, l.newAfterLineNumber, l.newHeight);
      for (const l of i) {
        const d = this._findWhitespaceIndex(l.id);
        d !== -1 && this._removeWhitespace(d);
      }
      return;
    }
    const n = /* @__PURE__ */ new Set();
    for (const l of i)
      n.add(l.id);
    const s = /* @__PURE__ */ new Map();
    for (const l of t)
      s.set(l.id, l);
    const o = (l) => {
      const d = [];
      for (const c of l)
        if (!n.has(c.id)) {
          if (s.has(c.id)) {
            const h = s.get(c.id);
            c.afterLineNumber = h.newAfterLineNumber, c.height = h.newHeight;
          }
          d.push(c);
        }
      return d;
    }, a = o(this._arr).concat(o(e));
    a.sort((l, d) => l.afterLineNumber === d.afterLineNumber ? l.ordinal - d.ordinal : l.afterLineNumber - d.afterLineNumber), this._arr = a, this._prefixSumValidIndex = -1;
  }
  _checkPendingChanges() {
    this._pendingChanges.mustCommit() && this._pendingChanges.commit(this);
  }
  _insertWhitespace(e) {
    const t = _I.findInsertionIndex(this._arr, e.afterLineNumber, e.ordinal);
    this._arr.splice(t, 0, e), this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, t - 1);
  }
  _findWhitespaceIndex(e) {
    const t = this._arr;
    for (let i = 0, n = t.length; i < n; i++)
      if (t[i].id === e)
        return i;
    return -1;
  }
  _changeOneWhitespace(e, t, i) {
    const n = this._findWhitespaceIndex(e);
    if (n !== -1 && (this._arr[n].height !== i && (this._arr[n].height = i, this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, n - 1)), this._arr[n].afterLineNumber !== t)) {
      const s = this._arr[n];
      this._removeWhitespace(n), s.afterLineNumber = t, this._insertWhitespace(s);
    }
  }
  _removeWhitespace(e) {
    this._arr.splice(e, 1), this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, e - 1);
  }
  /**
   * Notify the layouter that lines have been deleted (a continuous zone of lines).
   *
   * @param fromLineNumber The line number at which the deletion started, inclusive
   * @param toLineNumber The line number at which the deletion ended, inclusive
   */
  onLinesDeleted(e, t) {
    this._checkPendingChanges(), e = e | 0, t = t | 0, this._lineCount -= t - e + 1;
    for (let i = 0, n = this._arr.length; i < n; i++) {
      const s = this._arr[i].afterLineNumber;
      e <= s && s <= t ? this._arr[i].afterLineNumber = e - 1 : s > t && (this._arr[i].afterLineNumber -= t - e + 1);
    }
  }
  /**
   * Notify the layouter that lines have been inserted (a continuous zone of lines).
   *
   * @param fromLineNumber The line number at which the insertion started, inclusive
   * @param toLineNumber The line number at which the insertion ended, inclusive.
   */
  onLinesInserted(e, t) {
    this._checkPendingChanges(), e = e | 0, t = t | 0, this._lineCount += t - e + 1;
    for (let i = 0, n = this._arr.length; i < n; i++) {
      const s = this._arr[i].afterLineNumber;
      e <= s && (this._arr[i].afterLineNumber += t - e + 1);
    }
  }
  /**
   * Get the sum of all the whitespaces.
   */
  getWhitespacesTotalHeight() {
    return this._checkPendingChanges(), this._arr.length === 0 ? 0 : this.getWhitespacesAccumulatedHeight(this._arr.length - 1);
  }
  /**
   * Return the sum of the heights of the whitespaces at [0..index].
   * This includes the whitespace at `index`.
   *
   * @param index The index of the whitespace.
   * @return The sum of the heights of all whitespaces before the one at `index`, including the one at `index`.
   */
  getWhitespacesAccumulatedHeight(e) {
    this._checkPendingChanges(), e = e | 0;
    let t = Math.max(0, this._prefixSumValidIndex + 1);
    t === 0 && (this._arr[0].prefixSum = this._arr[0].height, t++);
    for (let i = t; i <= e; i++)
      this._arr[i].prefixSum = this._arr[i - 1].prefixSum + this._arr[i].height;
    return this._prefixSumValidIndex = Math.max(this._prefixSumValidIndex, e), this._arr[e].prefixSum;
  }
  /**
   * Get the sum of heights for all objects.
   *
   * @return The sum of heights for all objects.
   */
  getLinesTotalHeight() {
    this._checkPendingChanges();
    const e = this._lineHeight * this._lineCount, t = this.getWhitespacesTotalHeight();
    return e + t + this._paddingTop + this._paddingBottom;
  }
  /**
   * Returns the accumulated height of whitespaces before the given line number.
   *
   * @param lineNumber The line number
   */
  getWhitespaceAccumulatedHeightBeforeLineNumber(e) {
    this._checkPendingChanges(), e = e | 0;
    const t = this._findLastWhitespaceBeforeLineNumber(e);
    return t === -1 ? 0 : this.getWhitespacesAccumulatedHeight(t);
  }
  _findLastWhitespaceBeforeLineNumber(e) {
    e = e | 0;
    const t = this._arr;
    let i = 0, n = t.length - 1;
    for (; i <= n; ) {
      const o = (n - i | 0) / 2 | 0, a = i + o | 0;
      if (t[a].afterLineNumber < e) {
        if (a + 1 >= t.length || t[a + 1].afterLineNumber >= e)
          return a;
        i = a + 1 | 0;
      } else
        n = a - 1 | 0;
    }
    return -1;
  }
  _findFirstWhitespaceAfterLineNumber(e) {
    e = e | 0;
    const i = this._findLastWhitespaceBeforeLineNumber(e) + 1;
    return i < this._arr.length ? i : -1;
  }
  /**
   * Find the index of the first whitespace which has `afterLineNumber` >= `lineNumber`.
   * @return The index of the first whitespace with `afterLineNumber` >= `lineNumber` or -1 if no whitespace is found.
   */
  getFirstWhitespaceIndexAfterLineNumber(e) {
    return this._checkPendingChanges(), e = e | 0, this._findFirstWhitespaceAfterLineNumber(e);
  }
  /**
   * Get the vertical offset (the sum of heights for all objects above) a certain line number.
   *
   * @param lineNumber The line number
   * @return The sum of heights for all objects above `lineNumber`.
   */
  getVerticalOffsetForLineNumber(e, t = !1) {
    this._checkPendingChanges(), e = e | 0;
    let i;
    e > 1 ? i = this._lineHeight * (e - 1) : i = 0;
    const n = this.getWhitespaceAccumulatedHeightBeforeLineNumber(e - (t ? 1 : 0));
    return i + n + this._paddingTop;
  }
  /**
   * Get the vertical offset (the sum of heights for all objects above) a certain line number.
   *
   * @param lineNumber The line number
   * @return The sum of heights for all objects above `lineNumber`.
   */
  getVerticalOffsetAfterLineNumber(e, t = !1) {
    this._checkPendingChanges(), e = e | 0;
    const i = this._lineHeight * e, n = this.getWhitespaceAccumulatedHeightBeforeLineNumber(e + (t ? 1 : 0));
    return i + n + this._paddingTop;
  }
  /**
   * The maximum min width for all whitespaces.
   */
  getWhitespaceMinWidth() {
    if (this._checkPendingChanges(), this._minWidth === -1) {
      let e = 0;
      for (let t = 0, i = this._arr.length; t < i; t++)
        e = Math.max(e, this._arr[t].minWidth);
      this._minWidth = e;
    }
    return this._minWidth;
  }
  /**
   * Check if `verticalOffset` is below all lines.
   */
  isAfterLines(e) {
    this._checkPendingChanges();
    const t = this.getLinesTotalHeight();
    return e > t;
  }
  isInTopPadding(e) {
    return this._paddingTop === 0 ? !1 : (this._checkPendingChanges(), e < this._paddingTop);
  }
  isInBottomPadding(e) {
    if (this._paddingBottom === 0)
      return !1;
    this._checkPendingChanges();
    const t = this.getLinesTotalHeight();
    return e >= t - this._paddingBottom;
  }
  /**
   * Find the first line number that is at or after vertical offset `verticalOffset`.
   * i.e. if getVerticalOffsetForLine(line) is x and getVerticalOffsetForLine(line + 1) is y, then
   * getLineNumberAtOrAfterVerticalOffset(i) = line, x <= i < y.
   *
   * @param verticalOffset The vertical offset to search at.
   * @return The line number at or after vertical offset `verticalOffset`.
   */
  getLineNumberAtOrAfterVerticalOffset(e) {
    if (this._checkPendingChanges(), e = e | 0, e < 0)
      return 1;
    const t = this._lineCount | 0, i = this._lineHeight;
    let n = 1, s = t;
    for (; n < s; ) {
      const o = (n + s) / 2 | 0, a = this.getVerticalOffsetForLineNumber(o) | 0;
      if (e >= a + i)
        n = o + 1;
      else {
        if (e >= a)
          return o;
        s = o;
      }
    }
    return n > t ? t : n;
  }
  /**
   * Get all the lines and their relative vertical offsets that are positioned between `verticalOffset1` and `verticalOffset2`.
   *
   * @param verticalOffset1 The beginning of the viewport.
   * @param verticalOffset2 The end of the viewport.
   * @return A structure describing the lines positioned between `verticalOffset1` and `verticalOffset2`.
   */
  getLinesViewportData(e, t) {
    this._checkPendingChanges(), e = e | 0, t = t | 0;
    const i = this._lineHeight, n = this.getLineNumberAtOrAfterVerticalOffset(e) | 0, s = this.getVerticalOffsetForLineNumber(n) | 0;
    let o = this._lineCount | 0, a = this.getFirstWhitespaceIndexAfterLineNumber(n) | 0;
    const l = this.getWhitespacesCount() | 0;
    let d, c;
    a === -1 ? (a = l, c = o + 1, d = 0) : (c = this.getAfterLineNumberForWhitespaceIndex(a) | 0, d = this.getHeightForWhitespaceIndex(a) | 0);
    let h = s, u = h;
    const g = 5e5;
    let f = 0;
    s >= g && (f = Math.floor(s / g) * g, f = Math.floor(f / i) * i, u -= f);
    const m = [], _ = e + (t - e) / 2;
    let v = -1;
    for (let S = n; S <= o; S++) {
      if (v === -1) {
        const y = h, k = h + i;
        (y <= _ && _ < k || y > _) && (v = S);
      }
      for (h += i, m[S - n] = u, u += i; c === S; )
        u += d, h += d, a++, a >= l ? c = o + 1 : (c = this.getAfterLineNumberForWhitespaceIndex(a) | 0, d = this.getHeightForWhitespaceIndex(a) | 0);
      if (h >= t) {
        o = S;
        break;
      }
    }
    v === -1 && (v = o);
    const b = this.getVerticalOffsetForLineNumber(o) | 0;
    let C = n, w = o;
    return C < w && s < e && C++, C < w && b + i > t && w--, {
      bigNumbersDelta: f,
      startLineNumber: n,
      endLineNumber: o,
      relativeVerticalOffset: m,
      centeredLineNumber: v,
      completelyVisibleStartLineNumber: C,
      completelyVisibleEndLineNumber: w,
      lineHeight: this._lineHeight
    };
  }
  getVerticalOffsetForWhitespaceIndex(e) {
    this._checkPendingChanges(), e = e | 0;
    const t = this.getAfterLineNumberForWhitespaceIndex(e);
    let i;
    t >= 1 ? i = this._lineHeight * t : i = 0;
    let n;
    return e > 0 ? n = this.getWhitespacesAccumulatedHeight(e - 1) : n = 0, i + n + this._paddingTop;
  }
  getWhitespaceIndexAtOrAfterVerticallOffset(e) {
    this._checkPendingChanges(), e = e | 0;
    let t = 0, i = this.getWhitespacesCount() - 1;
    if (i < 0)
      return -1;
    const n = this.getVerticalOffsetForWhitespaceIndex(i), s = this.getHeightForWhitespaceIndex(i);
    if (e >= n + s)
      return -1;
    for (; t < i; ) {
      const o = Math.floor((t + i) / 2), a = this.getVerticalOffsetForWhitespaceIndex(o), l = this.getHeightForWhitespaceIndex(o);
      if (e >= a + l)
        t = o + 1;
      else {
        if (e >= a)
          return o;
        i = o;
      }
    }
    return t;
  }
  /**
   * Get exactly the whitespace that is layouted at `verticalOffset`.
   *
   * @param verticalOffset The vertical offset.
   * @return Precisely the whitespace that is layouted at `verticaloffset` or null.
   */
  getWhitespaceAtVerticalOffset(e) {
    this._checkPendingChanges(), e = e | 0;
    const t = this.getWhitespaceIndexAtOrAfterVerticallOffset(e);
    if (t < 0 || t >= this.getWhitespacesCount())
      return null;
    const i = this.getVerticalOffsetForWhitespaceIndex(t);
    if (i > e)
      return null;
    const n = this.getHeightForWhitespaceIndex(t), s = this.getIdForWhitespaceIndex(t), o = this.getAfterLineNumberForWhitespaceIndex(t);
    return {
      id: s,
      afterLineNumber: o,
      verticalOffset: i,
      height: n
    };
  }
  /**
   * Get a list of whitespaces that are positioned between `verticalOffset1` and `verticalOffset2`.
   *
   * @param verticalOffset1 The beginning of the viewport.
   * @param verticalOffset2 The end of the viewport.
   * @return An array with all the whitespaces in the viewport. If no whitespace is in viewport, the array is empty.
   */
  getWhitespaceViewportData(e, t) {
    this._checkPendingChanges(), e = e | 0, t = t | 0;
    const i = this.getWhitespaceIndexAtOrAfterVerticallOffset(e), n = this.getWhitespacesCount() - 1;
    if (i < 0)
      return [];
    const s = [];
    for (let o = i; o <= n; o++) {
      const a = this.getVerticalOffsetForWhitespaceIndex(o), l = this.getHeightForWhitespaceIndex(o);
      if (a >= t)
        break;
      s.push({
        id: this.getIdForWhitespaceIndex(o),
        afterLineNumber: this.getAfterLineNumberForWhitespaceIndex(o),
        verticalOffset: a,
        height: l
      });
    }
    return s;
  }
  /**
   * Get all whitespaces.
   */
  getWhitespaces() {
    return this._checkPendingChanges(), this._arr.slice(0);
  }
  /**
   * The number of whitespaces.
   */
  getWhitespacesCount() {
    return this._checkPendingChanges(), this._arr.length;
  }
  /**
   * Get the `id` for whitespace at index `index`.
   *
   * @param index The index of the whitespace.
   * @return `id` of whitespace at `index`.
   */
  getIdForWhitespaceIndex(e) {
    return this._checkPendingChanges(), e = e | 0, this._arr[e].id;
  }
  /**
   * Get the `afterLineNumber` for whitespace at index `index`.
   *
   * @param index The index of the whitespace.
   * @return `afterLineNumber` of whitespace at `index`.
   */
  getAfterLineNumberForWhitespaceIndex(e) {
    return this._checkPendingChanges(), e = e | 0, this._arr[e].afterLineNumber;
  }
  /**
   * Get the `height` for whitespace at index `index`.
   *
   * @param index The index of the whitespace.
   * @return `height` of whitespace at `index`.
   */
  getHeightForWhitespaceIndex(e) {
    return this._checkPendingChanges(), e = e | 0, this._arr[e].height;
  }
};
F2.INSTANCE_COUNT = 0;
const BX = 125;
class Om {
  constructor(e, t, i, n) {
    e = e | 0, t = t | 0, i = i | 0, n = n | 0, e < 0 && (e = 0), t < 0 && (t = 0), i < 0 && (i = 0), n < 0 && (n = 0), this.width = e, this.contentWidth = t, this.scrollWidth = Math.max(e, t), this.height = i, this.contentHeight = n, this.scrollHeight = Math.max(i, n);
  }
  equals(e) {
    return this.width === e.width && this.contentWidth === e.contentWidth && this.height === e.height && this.contentHeight === e.contentHeight;
  }
}
class HX extends P {
  constructor(e, t) {
    super(), this._onDidContentSizeChange = this._register(new R()), this.onDidContentSizeChange = this._onDidContentSizeChange.event, this._dimensions = new Om(0, 0, 0, 0), this._scrollable = this._register(new Mp({
      forceIntegerValues: !0,
      smoothScrollDuration: e,
      scheduleAtNextAnimationFrame: t
    })), this.onDidScroll = this._scrollable.onScroll;
  }
  getScrollable() {
    return this._scrollable;
  }
  setSmoothScrollDuration(e) {
    this._scrollable.setSmoothScrollDuration(e);
  }
  validateScrollPosition(e) {
    return this._scrollable.validateScrollPosition(e);
  }
  getScrollDimensions() {
    return this._dimensions;
  }
  setScrollDimensions(e) {
    if (this._dimensions.equals(e))
      return;
    const t = this._dimensions;
    this._dimensions = e, this._scrollable.setScrollDimensions({
      width: e.width,
      scrollWidth: e.scrollWidth,
      height: e.height,
      scrollHeight: e.scrollHeight
    }, !0);
    const i = t.contentWidth !== e.contentWidth, n = t.contentHeight !== e.contentHeight;
    (i || n) && this._onDidContentSizeChange.fire(new j1(t.contentWidth, t.contentHeight, e.contentWidth, e.contentHeight));
  }
  getFutureScrollPosition() {
    return this._scrollable.getFutureScrollPosition();
  }
  getCurrentScrollPosition() {
    return this._scrollable.getCurrentScrollPosition();
  }
  setScrollPositionNow(e) {
    this._scrollable.setScrollPositionNow(e);
  }
  setScrollPositionSmooth(e) {
    this._scrollable.setScrollPositionSmooth(e);
  }
  hasPendingScrollAnimation() {
    return this._scrollable.hasPendingScrollAnimation();
  }
}
class VX extends P {
  constructor(e, t, i) {
    super(), this._configuration = e;
    const n = this._configuration.options, s = n.get(
      145
      /* EditorOption.layoutInfo */
    ), o = n.get(
      84
      /* EditorOption.padding */
    );
    this._linesLayout = new F2(t, n.get(
      67
      /* EditorOption.lineHeight */
    ), o.top, o.bottom), this._maxLineWidth = 0, this._overlayWidgetsMinWidth = 0, this._scrollable = this._register(new HX(0, i)), this._configureSmoothScrollDuration(), this._scrollable.setScrollDimensions(new Om(s.contentWidth, 0, s.height, 0)), this.onDidScroll = this._scrollable.onDidScroll, this.onDidContentSizeChange = this._scrollable.onDidContentSizeChange, this._updateHeight();
  }
  dispose() {
    super.dispose();
  }
  getScrollable() {
    return this._scrollable.getScrollable();
  }
  onHeightMaybeChanged() {
    this._updateHeight();
  }
  _configureSmoothScrollDuration() {
    this._scrollable.setSmoothScrollDuration(this._configuration.options.get(
      114
      /* EditorOption.smoothScrolling */
    ) ? BX : 0);
  }
  // ---- begin view event handlers
  onConfigurationChanged(e) {
    const t = this._configuration.options;
    if (e.hasChanged(
      67
      /* EditorOption.lineHeight */
    ) && this._linesLayout.setLineHeight(t.get(
      67
      /* EditorOption.lineHeight */
    )), e.hasChanged(
      84
      /* EditorOption.padding */
    )) {
      const i = t.get(
        84
        /* EditorOption.padding */
      );
      this._linesLayout.setPadding(i.top, i.bottom);
    }
    if (e.hasChanged(
      145
      /* EditorOption.layoutInfo */
    )) {
      const i = t.get(
        145
        /* EditorOption.layoutInfo */
      ), n = i.contentWidth, s = i.height, o = this._scrollable.getScrollDimensions(), a = o.contentWidth;
      this._scrollable.setScrollDimensions(new Om(n, o.contentWidth, s, this._getContentHeight(n, s, a)));
    } else
      this._updateHeight();
    e.hasChanged(
      114
      /* EditorOption.smoothScrolling */
    ) && this._configureSmoothScrollDuration();
  }
  onFlushed(e) {
    this._linesLayout.onFlushed(e);
  }
  onLinesDeleted(e, t) {
    this._linesLayout.onLinesDeleted(e, t);
  }
  onLinesInserted(e, t) {
    this._linesLayout.onLinesInserted(e, t);
  }
  // ---- end view event handlers
  _getHorizontalScrollbarHeight(e, t) {
    const n = this._configuration.options.get(
      103
      /* EditorOption.scrollbar */
    );
    return n.horizontal === 2 || e >= t ? 0 : n.horizontalScrollbarSize;
  }
  _getContentHeight(e, t, i) {
    const n = this._configuration.options;
    let s = this._linesLayout.getLinesTotalHeight();
    return n.get(
      105
      /* EditorOption.scrollBeyondLastLine */
    ) ? s += Math.max(0, t - n.get(
      67
      /* EditorOption.lineHeight */
    ) - n.get(
      84
      /* EditorOption.padding */
    ).bottom) : n.get(
      103
      /* EditorOption.scrollbar */
    ).ignoreHorizontalScrollbarInContentHeight || (s += this._getHorizontalScrollbarHeight(e, i)), s;
  }
  _updateHeight() {
    const e = this._scrollable.getScrollDimensions(), t = e.width, i = e.height, n = e.contentWidth;
    this._scrollable.setScrollDimensions(new Om(t, e.contentWidth, i, this._getContentHeight(t, i, n)));
  }
  // ---- Layouting logic
  getCurrentViewport() {
    const e = this._scrollable.getScrollDimensions(), t = this._scrollable.getCurrentScrollPosition();
    return new QA(t.scrollTop, t.scrollLeft, e.width, e.height);
  }
  getFutureViewport() {
    const e = this._scrollable.getScrollDimensions(), t = this._scrollable.getFutureScrollPosition();
    return new QA(t.scrollTop, t.scrollLeft, e.width, e.height);
  }
  _computeContentWidth() {
    const e = this._configuration.options, t = this._maxLineWidth, i = e.get(
      146
      /* EditorOption.wrappingInfo */
    ), n = e.get(
      50
      /* EditorOption.fontInfo */
    ), s = e.get(
      145
      /* EditorOption.layoutInfo */
    );
    if (i.isViewportWrapping) {
      const o = e.get(
        73
        /* EditorOption.minimap */
      );
      return t > s.contentWidth + n.typicalHalfwidthCharacterWidth && o.enabled && o.side === "right" ? t + s.verticalScrollbarWidth : t;
    } else {
      const o = e.get(
        104
        /* EditorOption.scrollBeyondLastColumn */
      ) * n.typicalHalfwidthCharacterWidth, a = this._linesLayout.getWhitespaceMinWidth();
      return Math.max(t + o + s.verticalScrollbarWidth, a, this._overlayWidgetsMinWidth);
    }
  }
  setMaxLineWidth(e) {
    this._maxLineWidth = e, this._updateContentWidth();
  }
  setOverlayWidgetsMinWidth(e) {
    this._overlayWidgetsMinWidth = e, this._updateContentWidth();
  }
  _updateContentWidth() {
    const e = this._scrollable.getScrollDimensions();
    this._scrollable.setScrollDimensions(new Om(e.width, this._computeContentWidth(), e.height, e.contentHeight)), this._updateHeight();
  }
  // ---- view state
  saveState() {
    const e = this._scrollable.getFutureScrollPosition(), t = e.scrollTop, i = this._linesLayout.getLineNumberAtOrAfterVerticalOffset(t), n = this._linesLayout.getWhitespaceAccumulatedHeightBeforeLineNumber(i);
    return {
      scrollTop: t,
      scrollTopWithoutViewZones: t - n,
      scrollLeft: e.scrollLeft
    };
  }
  // ----
  changeWhitespace(e) {
    const t = this._linesLayout.changeWhitespace(e);
    return t && this.onHeightMaybeChanged(), t;
  }
  getVerticalOffsetForLineNumber(e, t = !1) {
    return this._linesLayout.getVerticalOffsetForLineNumber(e, t);
  }
  getVerticalOffsetAfterLineNumber(e, t = !1) {
    return this._linesLayout.getVerticalOffsetAfterLineNumber(e, t);
  }
  isAfterLines(e) {
    return this._linesLayout.isAfterLines(e);
  }
  isInTopPadding(e) {
    return this._linesLayout.isInTopPadding(e);
  }
  isInBottomPadding(e) {
    return this._linesLayout.isInBottomPadding(e);
  }
  getLineNumberAtVerticalOffset(e) {
    return this._linesLayout.getLineNumberAtOrAfterVerticalOffset(e);
  }
  getWhitespaceAtVerticalOffset(e) {
    return this._linesLayout.getWhitespaceAtVerticalOffset(e);
  }
  getLinesViewportData() {
    const e = this.getCurrentViewport();
    return this._linesLayout.getLinesViewportData(e.top, e.top + e.height);
  }
  getLinesViewportDataAtScrollTop(e) {
    const t = this._scrollable.getScrollDimensions();
    return e + t.height > t.scrollHeight && (e = t.scrollHeight - t.height), e < 0 && (e = 0), this._linesLayout.getLinesViewportData(e, e + t.height);
  }
  getWhitespaceViewportData() {
    const e = this.getCurrentViewport();
    return this._linesLayout.getWhitespaceViewportData(e.top, e.top + e.height);
  }
  getWhitespaces() {
    return this._linesLayout.getWhitespaces();
  }
  // ----
  getContentWidth() {
    return this._scrollable.getScrollDimensions().contentWidth;
  }
  getScrollWidth() {
    return this._scrollable.getScrollDimensions().scrollWidth;
  }
  getContentHeight() {
    return this._scrollable.getScrollDimensions().contentHeight;
  }
  getScrollHeight() {
    return this._scrollable.getScrollDimensions().scrollHeight;
  }
  getCurrentScrollLeft() {
    return this._scrollable.getCurrentScrollPosition().scrollLeft;
  }
  getCurrentScrollTop() {
    return this._scrollable.getCurrentScrollPosition().scrollTop;
  }
  validateScrollPosition(e) {
    return this._scrollable.validateScrollPosition(e);
  }
  setScrollPosition(e, t) {
    t === 1 ? this._scrollable.setScrollPositionNow(e) : this._scrollable.setScrollPositionSmooth(e);
  }
  hasPendingScrollAnimation() {
    return this._scrollable.hasPendingScrollAnimation();
  }
  deltaScrollNow(e, t) {
    const i = this._scrollable.getCurrentScrollPosition();
    this._scrollable.setScrollPositionNow({
      scrollLeft: i.scrollLeft + e,
      scrollTop: i.scrollTop + t
    });
  }
}
class zX {
  constructor(e, t, i, n, s) {
    this.editorId = e, this.model = t, this.configuration = i, this._linesCollection = n, this._coordinatesConverter = s, this._decorationsCache = /* @__PURE__ */ Object.create(null), this._cachedModelDecorationsResolver = null, this._cachedModelDecorationsResolverViewRange = null;
  }
  _clearCachedModelDecorationsResolver() {
    this._cachedModelDecorationsResolver = null, this._cachedModelDecorationsResolverViewRange = null;
  }
  dispose() {
    this._decorationsCache = /* @__PURE__ */ Object.create(null), this._clearCachedModelDecorationsResolver();
  }
  reset() {
    this._decorationsCache = /* @__PURE__ */ Object.create(null), this._clearCachedModelDecorationsResolver();
  }
  onModelDecorationsChanged() {
    this._decorationsCache = /* @__PURE__ */ Object.create(null), this._clearCachedModelDecorationsResolver();
  }
  onLineMappingChanged() {
    this._decorationsCache = /* @__PURE__ */ Object.create(null), this._clearCachedModelDecorationsResolver();
  }
  _getOrCreateViewModelDecoration(e) {
    const t = e.id;
    let i = this._decorationsCache[t];
    if (!i) {
      const n = e.range, s = e.options;
      let o;
      if (s.isWholeLine) {
        const a = this._coordinatesConverter.convertModelPositionToViewPosition(new A(n.startLineNumber, 1), 0, !1, !0), l = this._coordinatesConverter.convertModelPositionToViewPosition(
          new A(n.endLineNumber, this.model.getLineMaxColumn(n.endLineNumber)),
          1
          /* PositionAffinity.Right */
        );
        o = new L(a.lineNumber, a.column, l.lineNumber, l.column);
      } else
        o = this._coordinatesConverter.convertModelRangeToViewRange(
          n,
          1
          /* PositionAffinity.Right */
        );
      i = new wV(o, s), this._decorationsCache[t] = i;
    }
    return i;
  }
  getMinimapDecorationsInRange(e) {
    return this._getDecorationsInRange(e, !0, !1).decorations;
  }
  getDecorationsViewportData(e) {
    let t = this._cachedModelDecorationsResolver !== null;
    return t = t && e.equalsRange(this._cachedModelDecorationsResolverViewRange), t || (this._cachedModelDecorationsResolver = this._getDecorationsInRange(e, !1, !1), this._cachedModelDecorationsResolverViewRange = e), this._cachedModelDecorationsResolver;
  }
  getInlineDecorationsOnLine(e, t = !1, i = !1) {
    const n = new L(e, this._linesCollection.getViewLineMinColumn(e), e, this._linesCollection.getViewLineMaxColumn(e));
    return this._getDecorationsInRange(n, t, i).inlineDecorations[0];
  }
  _getDecorationsInRange(e, t, i) {
    const n = this._linesCollection.getDecorationsInRange(e, this.editorId, dS(this.configuration.options), t, i), s = e.startLineNumber, o = e.endLineNumber, a = [];
    let l = 0;
    const d = [];
    for (let c = s; c <= o; c++)
      d[c - s] = [];
    for (let c = 0, h = n.length; c < h; c++) {
      const u = n[c], g = u.options;
      if (!Z1(this.model, u))
        continue;
      const f = this._getOrCreateViewModelDecoration(u), m = f.range;
      if (a[l++] = f, g.inlineClassName) {
        const _ = new e_(
          m,
          g.inlineClassName,
          g.inlineClassNameAffectsLetterSpacing ? 3 : 0
          /* InlineDecorationType.Regular */
        ), v = Math.max(s, m.startLineNumber), b = Math.min(o, m.endLineNumber);
        for (let C = v; C <= b; C++)
          d[C - s].push(_);
      }
      if (g.beforeContentClassName && s <= m.startLineNumber && m.startLineNumber <= o) {
        const _ = new e_(
          new L(m.startLineNumber, m.startColumn, m.startLineNumber, m.startColumn),
          g.beforeContentClassName,
          1
          /* InlineDecorationType.Before */
        );
        d[m.startLineNumber - s].push(_);
      }
      if (g.afterContentClassName && s <= m.endLineNumber && m.endLineNumber <= o) {
        const _ = new e_(
          new L(m.endLineNumber, m.endColumn, m.endLineNumber, m.endColumn),
          g.afterContentClassName,
          2
          /* InlineDecorationType.After */
        );
        d[m.endLineNumber - s].push(_);
      }
    }
    return {
      decorations: a,
      inlineDecorations: d
    };
  }
}
function Z1(r, e) {
  return !(e.options.hideInCommentTokens && Y1(r, e) || e.options.hideInStringTokens && Q1(r, e));
}
function Y1(r, e) {
  return W2(
    r,
    e.range,
    (t) => t === 1
    /* StandardTokenType.Comment */
  );
}
function Q1(r, e) {
  return W2(
    r,
    e.range,
    (t) => t === 2
    /* StandardTokenType.String */
  );
}
function W2(r, e, t) {
  for (let i = e.startLineNumber; i <= e.endLineNumber; i++) {
    const n = r.tokenization.getLineTokens(i), s = i === e.startLineNumber, o = i === e.endLineNumber;
    let a = s ? n.findTokenIndexAtOffset(e.startColumn - 1) : 0;
    for (; a < n.getCount() && !(o && n.getStartOffset(a) > e.endColumn - 1); ) {
      if (!t(n.getStandardTokenType(a)))
        return !1;
      a++;
    }
  }
  return !0;
}
function lk(r, e) {
  return r === null ? e ? RS.INSTANCE : AS.INSTANCE : new UX(r, e);
}
class UX {
  constructor(e, t) {
    this._projectionData = e, this._isVisible = t;
  }
  isVisible() {
    return this._isVisible;
  }
  setVisible(e) {
    return this._isVisible = e, this;
  }
  getProjectionData() {
    return this._projectionData;
  }
  getViewLineCount() {
    return this._isVisible ? this._projectionData.getOutputLineCount() : 0;
  }
  getViewLineContent(e, t, i) {
    this._assertVisible();
    const n = i > 0 ? this._projectionData.breakOffsets[i - 1] : 0, s = this._projectionData.breakOffsets[i];
    let o;
    if (this._projectionData.injectionOffsets !== null) {
      const a = this._projectionData.injectionOffsets.map((d, c) => new ea(0, 0, d + 1, this._projectionData.injectionOptions[c], 0));
      o = ea.applyInjectedText(e.getLineContent(t), a).substring(n, s);
    } else
      o = e.getValueInRange({
        startLineNumber: t,
        startColumn: n + 1,
        endLineNumber: t,
        endColumn: s + 1
      });
    return i > 0 && (o = hO(this._projectionData.wrappedTextIndentLength) + o), o;
  }
  getViewLineLength(e, t, i) {
    return this._assertVisible(), this._projectionData.getLineLength(i);
  }
  getViewLineMinColumn(e, t, i) {
    return this._assertVisible(), this._projectionData.getMinOutputOffset(i) + 1;
  }
  getViewLineMaxColumn(e, t, i) {
    return this._assertVisible(), this._projectionData.getMaxOutputOffset(i) + 1;
  }
  /**
   * Try using {@link getViewLinesData} instead.
  */
  getViewLineData(e, t, i) {
    const n = new Array();
    return this.getViewLinesData(e, t, i, 1, 0, [!0], n), n[0];
  }
  getViewLinesData(e, t, i, n, s, o, a) {
    this._assertVisible();
    const l = this._projectionData, d = l.injectionOffsets, c = l.injectionOptions;
    let h = null;
    if (d) {
      h = [];
      let g = 0, f = 0;
      for (let m = 0; m < l.getOutputLineCount(); m++) {
        const _ = new Array();
        h[m] = _;
        const v = m > 0 ? l.breakOffsets[m - 1] : 0, b = l.breakOffsets[m];
        for (; f < d.length; ) {
          const C = c[f].content.length, w = d[f] + g, S = w + C;
          if (w > b)
            break;
          if (v < S) {
            const y = c[f];
            if (y.inlineClassName) {
              const k = m > 0 ? l.wrappedTextIndentLength : 0, E = k + Math.max(w - v, 0), N = k + Math.min(S - v, b - v);
              E !== N && _.push(new $q(E, N, y.inlineClassName, y.inlineClassNameAffectsLetterSpacing));
            }
          }
          if (S <= b)
            g += C, f++;
          else
            break;
        }
      }
    }
    let u;
    d ? u = e.tokenization.getLineTokens(t).withInserted(d.map((g, f) => ({
      offset: g,
      text: c[f].content,
      tokenMetadata: Ri.defaultTokenMetadata
    }))) : u = e.tokenization.getLineTokens(t);
    for (let g = i; g < i + n; g++) {
      const f = s + g - i;
      if (!o[f]) {
        a[f] = null;
        continue;
      }
      a[f] = this._getViewLineData(u, h ? h[g] : null, g);
    }
  }
  _getViewLineData(e, t, i) {
    this._assertVisible();
    const n = this._projectionData, s = i > 0 ? n.wrappedTextIndentLength : 0, o = i > 0 ? n.breakOffsets[i - 1] : 0, a = n.breakOffsets[i], l = e.sliceAndInflate(o, a, s);
    let d = l.getLineContent();
    i > 0 && (d = hO(n.wrappedTextIndentLength) + d);
    const c = this._projectionData.getMinOutputOffset(i) + 1, h = d.length + 1, u = i + 1 < this.getViewLineCount(), g = i === 0 ? 0 : n.breakOffsetsVisibleColumn[i - 1];
    return new p1(d, u, c, h, g, l, t);
  }
  getModelColumnOfViewPosition(e, t) {
    return this._assertVisible(), this._projectionData.translateToInputOffset(e, t - 1) + 1;
  }
  getViewPositionOfModelPosition(e, t, i = 2) {
    return this._assertVisible(), this._projectionData.translateToOutputPosition(t - 1, i).toPosition(e);
  }
  getViewLineNumberOfModelPosition(e, t) {
    this._assertVisible();
    const i = this._projectionData.translateToOutputPosition(t - 1);
    return e + i.outputLineIndex;
  }
  normalizePosition(e, t, i) {
    const n = t.lineNumber - e;
    return this._projectionData.normalizeOutputPosition(e, t.column - 1, i).toPosition(n);
  }
  getInjectedTextAt(e, t) {
    return this._projectionData.getInjectedText(e, t - 1);
  }
  _assertVisible() {
    if (!this._isVisible)
      throw new Error("Not supported");
  }
}
class RS {
  constructor() {
  }
  isVisible() {
    return !0;
  }
  setVisible(e) {
    return e ? this : AS.INSTANCE;
  }
  getProjectionData() {
    return null;
  }
  getViewLineCount() {
    return 1;
  }
  getViewLineContent(e, t, i) {
    return e.getLineContent(t);
  }
  getViewLineLength(e, t, i) {
    return e.getLineLength(t);
  }
  getViewLineMinColumn(e, t, i) {
    return e.getLineMinColumn(t);
  }
  getViewLineMaxColumn(e, t, i) {
    return e.getLineMaxColumn(t);
  }
  getViewLineData(e, t, i) {
    const n = e.tokenization.getLineTokens(t), s = n.getLineContent();
    return new p1(s, !1, 1, s.length + 1, 0, n.inflate(), null);
  }
  getViewLinesData(e, t, i, n, s, o, a) {
    if (!o[s]) {
      a[s] = null;
      return;
    }
    a[s] = this.getViewLineData(e, t, 0);
  }
  getModelColumnOfViewPosition(e, t) {
    return t;
  }
  getViewPositionOfModelPosition(e, t) {
    return new A(e, t);
  }
  getViewLineNumberOfModelPosition(e, t) {
    return e;
  }
  normalizePosition(e, t, i) {
    return t;
  }
  getInjectedTextAt(e, t) {
    return null;
  }
}
RS.INSTANCE = new RS();
class AS {
  constructor() {
  }
  isVisible() {
    return !1;
  }
  setVisible(e) {
    return e ? RS.INSTANCE : this;
  }
  getProjectionData() {
    return null;
  }
  getViewLineCount() {
    return 0;
  }
  getViewLineContent(e, t, i) {
    throw new Error("Not supported");
  }
  getViewLineLength(e, t, i) {
    throw new Error("Not supported");
  }
  getViewLineMinColumn(e, t, i) {
    throw new Error("Not supported");
  }
  getViewLineMaxColumn(e, t, i) {
    throw new Error("Not supported");
  }
  getViewLineData(e, t, i) {
    throw new Error("Not supported");
  }
  getViewLinesData(e, t, i, n, s, o, a) {
    throw new Error("Not supported");
  }
  getModelColumnOfViewPosition(e, t) {
    throw new Error("Not supported");
  }
  getViewPositionOfModelPosition(e, t) {
    throw new Error("Not supported");
  }
  getViewLineNumberOfModelPosition(e, t) {
    throw new Error("Not supported");
  }
  normalizePosition(e, t, i) {
    throw new Error("Not supported");
  }
  getInjectedTextAt(e, t) {
    throw new Error("Not supported");
  }
}
AS.INSTANCE = new AS();
const dk = [""];
function hO(r) {
  if (r >= dk.length)
    for (let e = 1; e <= r; e++)
      dk[e] = $X(e);
  return dk[r];
}
function $X(r) {
  return new Array(r + 1).join(" ");
}
class KX {
  constructor(e, t, i, n, s, o, a, l, d, c) {
    this._editorId = e, this.model = t, this._validModelVersionId = -1, this._domLineBreaksComputerFactory = i, this._monospaceLineBreaksComputerFactory = n, this.fontInfo = s, this.tabSize = o, this.wrappingStrategy = a, this.wrappingColumn = l, this.wrappingIndent = d, this.wordBreak = c, this._constructLines(
      /*resetHiddenAreas*/
      !0,
      null
    );
  }
  dispose() {
    this.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, []);
  }
  createCoordinatesConverter() {
    return new qX(this);
  }
  _constructLines(e, t) {
    this.modelLineProjections = [], e && (this.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, []));
    const i = this.model.getLinesContent(), n = this.model.getInjectedTextDecorations(this._editorId), s = i.length, o = this.createLineBreaksComputer(), a = new ad(ea.fromDecorations(n));
    for (let m = 0; m < s; m++) {
      const _ = a.takeWhile((v) => v.lineNumber === m + 1);
      o.addRequest(i[m], _, t ? t[m] : null);
    }
    const l = o.finalize(), d = [], c = this.hiddenAreasDecorationIds.map((m) => this.model.getDecorationRange(m)).sort(L.compareRangesUsingStarts);
    let h = 1, u = 0, g = -1, f = g + 1 < c.length ? u + 1 : s + 2;
    for (let m = 0; m < s; m++) {
      const _ = m + 1;
      _ === f && (g++, h = c[g].startLineNumber, u = c[g].endLineNumber, f = g + 1 < c.length ? u + 1 : s + 2);
      const v = _ >= h && _ <= u, b = lk(l[m], !v);
      d[m] = b.getViewLineCount(), this.modelLineProjections[m] = b;
    }
    this._validModelVersionId = this.model.getVersionId(), this.projectedModelLineLineCounts = new N5(d);
  }
  getHiddenAreas() {
    return this.hiddenAreasDecorationIds.map((e) => this.model.getDecorationRange(e));
  }
  setHiddenAreas(e) {
    const t = e.map((u) => this.model.validateRange(u)), i = jX(t), n = this.hiddenAreasDecorationIds.map((u) => this.model.getDecorationRange(u)).sort(L.compareRangesUsingStarts);
    if (i.length === n.length) {
      let u = !1;
      for (let g = 0; g < i.length; g++)
        if (!i[g].equalsRange(n[g])) {
          u = !0;
          break;
        }
      if (!u)
        return !1;
    }
    const s = i.map((u) => ({
      range: u,
      options: Fe.EMPTY
    }));
    this.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, s);
    const o = i;
    let a = 1, l = 0, d = -1, c = d + 1 < o.length ? l + 1 : this.modelLineProjections.length + 2, h = !1;
    for (let u = 0; u < this.modelLineProjections.length; u++) {
      const g = u + 1;
      g === c && (d++, a = o[d].startLineNumber, l = o[d].endLineNumber, c = d + 1 < o.length ? l + 1 : this.modelLineProjections.length + 2);
      let f = !1;
      if (g >= a && g <= l ? this.modelLineProjections[u].isVisible() && (this.modelLineProjections[u] = this.modelLineProjections[u].setVisible(!1), f = !0) : (h = !0, this.modelLineProjections[u].isVisible() || (this.modelLineProjections[u] = this.modelLineProjections[u].setVisible(!0), f = !0)), f) {
        const m = this.modelLineProjections[u].getViewLineCount();
        this.projectedModelLineLineCounts.setValue(u, m);
      }
    }
    return h || this.setHiddenAreas([]), !0;
  }
  modelPositionIsVisible(e, t) {
    return e < 1 || e > this.modelLineProjections.length ? !1 : this.modelLineProjections[e - 1].isVisible();
  }
  getModelLineViewLineCount(e) {
    return e < 1 || e > this.modelLineProjections.length ? 1 : this.modelLineProjections[e - 1].getViewLineCount();
  }
  setTabSize(e) {
    return this.tabSize === e ? !1 : (this.tabSize = e, this._constructLines(
      /*resetHiddenAreas*/
      !1,
      null
    ), !0);
  }
  setWrappingSettings(e, t, i, n, s) {
    const o = this.fontInfo.equals(e), a = this.wrappingStrategy === t, l = this.wrappingColumn === i, d = this.wrappingIndent === n, c = this.wordBreak === s;
    if (o && a && l && d && c)
      return !1;
    const h = o && a && !l && d && c;
    this.fontInfo = e, this.wrappingStrategy = t, this.wrappingColumn = i, this.wrappingIndent = n, this.wordBreak = s;
    let u = null;
    if (h) {
      u = [];
      for (let g = 0, f = this.modelLineProjections.length; g < f; g++)
        u[g] = this.modelLineProjections[g].getProjectionData();
    }
    return this._constructLines(
      /*resetHiddenAreas*/
      !1,
      u
    ), !0;
  }
  createLineBreaksComputer() {
    return (this.wrappingStrategy === "advanced" ? this._domLineBreaksComputerFactory : this._monospaceLineBreaksComputerFactory).createLineBreaksComputer(this.fontInfo, this.tabSize, this.wrappingColumn, this.wrappingIndent, this.wordBreak);
  }
  onModelFlushed() {
    this._constructLines(
      /*resetHiddenAreas*/
      !0,
      null
    );
  }
  onModelLinesDeleted(e, t, i) {
    if (!e || e <= this._validModelVersionId)
      return null;
    const n = t === 1 ? 1 : this.projectedModelLineLineCounts.getPrefixSum(t - 1) + 1, s = this.projectedModelLineLineCounts.getPrefixSum(i);
    return this.modelLineProjections.splice(t - 1, i - t + 1), this.projectedModelLineLineCounts.removeValues(t - 1, i - t + 1), new pI(n, s);
  }
  onModelLinesInserted(e, t, i, n) {
    if (!e || e <= this._validModelVersionId)
      return null;
    const s = t > 2 && !this.modelLineProjections[t - 2].isVisible(), o = t === 1 ? 1 : this.projectedModelLineLineCounts.getPrefixSum(t - 1) + 1;
    let a = 0;
    const l = [], d = [];
    for (let c = 0, h = n.length; c < h; c++) {
      const u = lk(n[c], !s);
      l.push(u);
      const g = u.getViewLineCount();
      a += g, d[c] = g;
    }
    return this.modelLineProjections = this.modelLineProjections.slice(0, t - 1).concat(l).concat(this.modelLineProjections.slice(t - 1)), this.projectedModelLineLineCounts.insertValues(t - 1, d), new mI(o, o + a - 1);
  }
  onModelLineChanged(e, t, i) {
    if (e !== null && e <= this._validModelVersionId)
      return [!1, null, null, null];
    const n = t - 1, s = this.modelLineProjections[n].getViewLineCount(), o = this.modelLineProjections[n].isVisible(), a = lk(i, o);
    this.modelLineProjections[n] = a;
    const l = this.modelLineProjections[n].getViewLineCount();
    let d = !1, c = 0, h = -1, u = 0, g = -1, f = 0, m = -1;
    s > l ? (c = this.projectedModelLineLineCounts.getPrefixSum(t - 1) + 1, h = c + l - 1, f = h + 1, m = f + (s - l) - 1, d = !0) : s < l ? (c = this.projectedModelLineLineCounts.getPrefixSum(t - 1) + 1, h = c + s - 1, u = h + 1, g = u + (l - s) - 1, d = !0) : (c = this.projectedModelLineLineCounts.getPrefixSum(t - 1) + 1, h = c + l - 1), this.projectedModelLineLineCounts.setValue(n, l);
    const _ = c <= h ? new O2(c, h - c + 1) : null, v = u <= g ? new mI(u, g) : null, b = f <= m ? new pI(f, m) : null;
    return [d, _, v, b];
  }
  acceptVersionId(e) {
    this._validModelVersionId = e, this.modelLineProjections.length === 1 && !this.modelLineProjections[0].isVisible() && this.setHiddenAreas([]);
  }
  getViewLineCount() {
    return this.projectedModelLineLineCounts.getTotalSum();
  }
  _toValidViewLineNumber(e) {
    if (e < 1)
      return 1;
    const t = this.getViewLineCount();
    return e > t ? t : e | 0;
  }
  getActiveIndentGuide(e, t, i) {
    e = this._toValidViewLineNumber(e), t = this._toValidViewLineNumber(t), i = this._toValidViewLineNumber(i);
    const n = this.convertViewPositionToModelPosition(e, this.getViewLineMinColumn(e)), s = this.convertViewPositionToModelPosition(t, this.getViewLineMinColumn(t)), o = this.convertViewPositionToModelPosition(i, this.getViewLineMinColumn(i)), a = this.model.guides.getActiveIndentGuide(n.lineNumber, s.lineNumber, o.lineNumber), l = this.convertModelPositionToViewPosition(a.startLineNumber, 1), d = this.convertModelPositionToViewPosition(a.endLineNumber, this.model.getLineMaxColumn(a.endLineNumber));
    return {
      startLineNumber: l.lineNumber,
      endLineNumber: d.lineNumber,
      indent: a.indent
    };
  }
  // #region ViewLineInfo
  getViewLineInfo(e) {
    e = this._toValidViewLineNumber(e);
    const t = this.projectedModelLineLineCounts.getIndexOf(e - 1), i = t.index, n = t.remainder;
    return new uO(i + 1, n);
  }
  getMinColumnOfViewLine(e) {
    return this.modelLineProjections[e.modelLineNumber - 1].getViewLineMinColumn(this.model, e.modelLineNumber, e.modelLineWrappedLineIdx);
  }
  getMaxColumnOfViewLine(e) {
    return this.modelLineProjections[e.modelLineNumber - 1].getViewLineMaxColumn(this.model, e.modelLineNumber, e.modelLineWrappedLineIdx);
  }
  getModelStartPositionOfViewLine(e) {
    const t = this.modelLineProjections[e.modelLineNumber - 1], i = t.getViewLineMinColumn(this.model, e.modelLineNumber, e.modelLineWrappedLineIdx), n = t.getModelColumnOfViewPosition(e.modelLineWrappedLineIdx, i);
    return new A(e.modelLineNumber, n);
  }
  getModelEndPositionOfViewLine(e) {
    const t = this.modelLineProjections[e.modelLineNumber - 1], i = t.getViewLineMaxColumn(this.model, e.modelLineNumber, e.modelLineWrappedLineIdx), n = t.getModelColumnOfViewPosition(e.modelLineWrappedLineIdx, i);
    return new A(e.modelLineNumber, n);
  }
  getViewLineInfosGroupedByModelRanges(e, t) {
    const i = this.getViewLineInfo(e), n = this.getViewLineInfo(t), s = new Array();
    let o = this.getModelStartPositionOfViewLine(i), a = new Array();
    for (let l = i.modelLineNumber; l <= n.modelLineNumber; l++) {
      const d = this.modelLineProjections[l - 1];
      if (d.isVisible()) {
        const c = l === i.modelLineNumber ? i.modelLineWrappedLineIdx : 0, h = l === n.modelLineNumber ? n.modelLineWrappedLineIdx + 1 : d.getViewLineCount();
        for (let u = c; u < h; u++)
          a.push(new uO(l, u));
      }
      if (!d.isVisible() && o) {
        const c = new A(l - 1, this.model.getLineMaxColumn(l - 1) + 1), h = L.fromPositions(o, c);
        s.push(new gO(h, a)), a = [], o = null;
      } else d.isVisible() && !o && (o = new A(l, 1));
    }
    if (o) {
      const l = L.fromPositions(o, this.getModelEndPositionOfViewLine(n));
      s.push(new gO(l, a));
    }
    return s;
  }
  // #endregion
  getViewLinesBracketGuides(e, t, i, n) {
    const s = i ? this.convertViewPositionToModelPosition(i.lineNumber, i.column) : null, o = [];
    for (const a of this.getViewLineInfosGroupedByModelRanges(e, t)) {
      const l = a.modelRange.startLineNumber, d = this.model.guides.getLinesBracketGuides(l, a.modelRange.endLineNumber, s, n);
      for (const c of a.viewLines) {
        const u = d[c.modelLineNumber - l].map((g) => {
          if (g.forWrappedLinesAfterColumn !== -1 && this.modelLineProjections[c.modelLineNumber - 1].getViewPositionOfModelPosition(0, g.forWrappedLinesAfterColumn).lineNumber >= c.modelLineWrappedLineIdx || g.forWrappedLinesBeforeOrAtColumn !== -1 && this.modelLineProjections[c.modelLineNumber - 1].getViewPositionOfModelPosition(0, g.forWrappedLinesBeforeOrAtColumn).lineNumber < c.modelLineWrappedLineIdx)
            return;
          if (!g.horizontalLine)
            return g;
          let f = -1;
          if (g.column !== -1) {
            const v = this.modelLineProjections[c.modelLineNumber - 1].getViewPositionOfModelPosition(0, g.column);
            if (v.lineNumber === c.modelLineWrappedLineIdx)
              f = v.column;
            else if (v.lineNumber < c.modelLineWrappedLineIdx)
              f = this.getMinColumnOfViewLine(c);
            else if (v.lineNumber > c.modelLineWrappedLineIdx)
              return;
          }
          const m = this.convertModelPositionToViewPosition(c.modelLineNumber, g.horizontalLine.endColumn), _ = this.modelLineProjections[c.modelLineNumber - 1].getViewPositionOfModelPosition(0, g.horizontalLine.endColumn);
          return _.lineNumber === c.modelLineWrappedLineIdx ? new Yh(g.visibleColumn, f, g.className, new s_(g.horizontalLine.top, m.column), -1, -1) : _.lineNumber < c.modelLineWrappedLineIdx || g.visibleColumn !== -1 ? void 0 : new Yh(g.visibleColumn, f, g.className, new s_(g.horizontalLine.top, this.getMaxColumnOfViewLine(c)), -1, -1);
        });
        o.push(u.filter((g) => !!g));
      }
    }
    return o;
  }
  getViewLinesIndentGuides(e, t) {
    e = this._toValidViewLineNumber(e), t = this._toValidViewLineNumber(t);
    const i = this.convertViewPositionToModelPosition(e, this.getViewLineMinColumn(e)), n = this.convertViewPositionToModelPosition(t, this.getViewLineMaxColumn(t));
    let s = [];
    const o = [], a = [], l = i.lineNumber - 1, d = n.lineNumber - 1;
    let c = null;
    for (let f = l; f <= d; f++) {
      const m = this.modelLineProjections[f];
      if (m.isVisible()) {
        const _ = m.getViewLineNumberOfModelPosition(0, f === l ? i.column : 1), v = m.getViewLineNumberOfModelPosition(0, this.model.getLineMaxColumn(f + 1)), b = v - _ + 1;
        let C = 0;
        b > 1 && m.getViewLineMinColumn(this.model, f + 1, v) === 1 && (C = _ === 0 ? 1 : 2), o.push(b), a.push(C), c === null && (c = new A(f + 1, 0));
      } else
        c !== null && (s = s.concat(this.model.guides.getLinesIndentGuides(c.lineNumber, f)), c = null);
    }
    c !== null && (s = s.concat(this.model.guides.getLinesIndentGuides(c.lineNumber, n.lineNumber)), c = null);
    const h = t - e + 1, u = new Array(h);
    let g = 0;
    for (let f = 0, m = s.length; f < m; f++) {
      let _ = s[f];
      const v = Math.min(h - g, o[f]), b = a[f];
      let C;
      b === 2 ? C = 0 : b === 1 ? C = 1 : C = v;
      for (let w = 0; w < v; w++)
        w === C && (_ = 0), u[g++] = _;
    }
    return u;
  }
  getViewLineContent(e) {
    const t = this.getViewLineInfo(e);
    return this.modelLineProjections[t.modelLineNumber - 1].getViewLineContent(this.model, t.modelLineNumber, t.modelLineWrappedLineIdx);
  }
  getViewLineLength(e) {
    const t = this.getViewLineInfo(e);
    return this.modelLineProjections[t.modelLineNumber - 1].getViewLineLength(this.model, t.modelLineNumber, t.modelLineWrappedLineIdx);
  }
  getViewLineMinColumn(e) {
    const t = this.getViewLineInfo(e);
    return this.modelLineProjections[t.modelLineNumber - 1].getViewLineMinColumn(this.model, t.modelLineNumber, t.modelLineWrappedLineIdx);
  }
  getViewLineMaxColumn(e) {
    const t = this.getViewLineInfo(e);
    return this.modelLineProjections[t.modelLineNumber - 1].getViewLineMaxColumn(this.model, t.modelLineNumber, t.modelLineWrappedLineIdx);
  }
  getViewLineData(e) {
    const t = this.getViewLineInfo(e);
    return this.modelLineProjections[t.modelLineNumber - 1].getViewLineData(this.model, t.modelLineNumber, t.modelLineWrappedLineIdx);
  }
  getViewLinesData(e, t, i) {
    e = this._toValidViewLineNumber(e), t = this._toValidViewLineNumber(t);
    const n = this.projectedModelLineLineCounts.getIndexOf(e - 1);
    let s = e;
    const o = n.index, a = n.remainder, l = [];
    for (let d = o, c = this.model.getLineCount(); d < c; d++) {
      const h = this.modelLineProjections[d];
      if (!h.isVisible())
        continue;
      const u = d === o ? a : 0;
      let g = h.getViewLineCount() - u, f = !1;
      if (s + g > t && (f = !0, g = t - s + 1), h.getViewLinesData(this.model, d + 1, u, g, s - e, i, l), s += g, f)
        break;
    }
    return l;
  }
  validateViewPosition(e, t, i) {
    e = this._toValidViewLineNumber(e);
    const n = this.projectedModelLineLineCounts.getIndexOf(e - 1), s = n.index, o = n.remainder, a = this.modelLineProjections[s], l = a.getViewLineMinColumn(this.model, s + 1, o), d = a.getViewLineMaxColumn(this.model, s + 1, o);
    t < l && (t = l), t > d && (t = d);
    const c = a.getModelColumnOfViewPosition(o, t);
    return this.model.validatePosition(new A(s + 1, c)).equals(i) ? new A(e, t) : this.convertModelPositionToViewPosition(i.lineNumber, i.column);
  }
  validateViewRange(e, t) {
    const i = this.validateViewPosition(e.startLineNumber, e.startColumn, t.getStartPosition()), n = this.validateViewPosition(e.endLineNumber, e.endColumn, t.getEndPosition());
    return new L(i.lineNumber, i.column, n.lineNumber, n.column);
  }
  convertViewPositionToModelPosition(e, t) {
    const i = this.getViewLineInfo(e), n = this.modelLineProjections[i.modelLineNumber - 1].getModelColumnOfViewPosition(i.modelLineWrappedLineIdx, t);
    return this.model.validatePosition(new A(i.modelLineNumber, n));
  }
  convertViewRangeToModelRange(e) {
    const t = this.convertViewPositionToModelPosition(e.startLineNumber, e.startColumn), i = this.convertViewPositionToModelPosition(e.endLineNumber, e.endColumn);
    return new L(t.lineNumber, t.column, i.lineNumber, i.column);
  }
  convertModelPositionToViewPosition(e, t, i = 2, n = !1, s = !1) {
    const o = this.model.validatePosition(new A(e, t)), a = o.lineNumber, l = o.column;
    let d = a - 1, c = !1;
    if (s)
      for (; d < this.modelLineProjections.length && !this.modelLineProjections[d].isVisible(); )
        d++, c = !0;
    else
      for (; d > 0 && !this.modelLineProjections[d].isVisible(); )
        d--, c = !0;
    if (d === 0 && !this.modelLineProjections[d].isVisible())
      return new A(n ? 0 : 1, 1);
    const h = 1 + this.projectedModelLineLineCounts.getPrefixSum(d);
    let u;
    return c ? s ? u = this.modelLineProjections[d].getViewPositionOfModelPosition(h, 1, i) : u = this.modelLineProjections[d].getViewPositionOfModelPosition(h, this.model.getLineMaxColumn(d + 1), i) : u = this.modelLineProjections[a - 1].getViewPositionOfModelPosition(h, l, i), u;
  }
  /**
   * @param affinity The affinity in case of an empty range. Has no effect for non-empty ranges.
  */
  convertModelRangeToViewRange(e, t = 0) {
    if (e.isEmpty()) {
      const i = this.convertModelPositionToViewPosition(e.startLineNumber, e.startColumn, t);
      return L.fromPositions(i);
    } else {
      const i = this.convertModelPositionToViewPosition(
        e.startLineNumber,
        e.startColumn,
        1
        /* PositionAffinity.Right */
      ), n = this.convertModelPositionToViewPosition(
        e.endLineNumber,
        e.endColumn,
        0
        /* PositionAffinity.Left */
      );
      return new L(i.lineNumber, i.column, n.lineNumber, n.column);
    }
  }
  getViewLineNumberOfModelPosition(e, t) {
    let i = e - 1;
    if (this.modelLineProjections[i].isVisible()) {
      const s = 1 + this.projectedModelLineLineCounts.getPrefixSum(i);
      return this.modelLineProjections[i].getViewLineNumberOfModelPosition(s, t);
    }
    for (; i > 0 && !this.modelLineProjections[i].isVisible(); )
      i--;
    if (i === 0 && !this.modelLineProjections[i].isVisible())
      return 1;
    const n = 1 + this.projectedModelLineLineCounts.getPrefixSum(i);
    return this.modelLineProjections[i].getViewLineNumberOfModelPosition(n, this.model.getLineMaxColumn(i + 1));
  }
  getDecorationsInRange(e, t, i, n, s) {
    const o = this.convertViewPositionToModelPosition(e.startLineNumber, e.startColumn), a = this.convertViewPositionToModelPosition(e.endLineNumber, e.endColumn);
    if (a.lineNumber - o.lineNumber <= e.endLineNumber - e.startLineNumber)
      return this.model.getDecorationsInRange(new L(o.lineNumber, 1, a.lineNumber, a.column), t, i, n, s);
    let l = [];
    const d = o.lineNumber - 1, c = a.lineNumber - 1;
    let h = null;
    for (let m = d; m <= c; m++)
      if (this.modelLineProjections[m].isVisible())
        h === null && (h = new A(m + 1, m === d ? o.column : 1));
      else if (h !== null) {
        const v = this.model.getLineMaxColumn(m);
        l = l.concat(this.model.getDecorationsInRange(new L(h.lineNumber, h.column, m, v), t, i, n)), h = null;
      }
    h !== null && (l = l.concat(this.model.getDecorationsInRange(new L(h.lineNumber, h.column, a.lineNumber, a.column), t, i, n)), h = null), l.sort((m, _) => {
      const v = L.compareRangesUsingStarts(m.range, _.range);
      return v === 0 ? m.id < _.id ? -1 : m.id > _.id ? 1 : 0 : v;
    });
    const u = [];
    let g = 0, f = null;
    for (const m of l) {
      const _ = m.id;
      f !== _ && (f = _, u[g++] = m);
    }
    return u;
  }
  getInjectedTextAt(e) {
    const t = this.getViewLineInfo(e.lineNumber);
    return this.modelLineProjections[t.modelLineNumber - 1].getInjectedTextAt(t.modelLineWrappedLineIdx, e.column);
  }
  normalizePosition(e, t) {
    const i = this.getViewLineInfo(e.lineNumber);
    return this.modelLineProjections[i.modelLineNumber - 1].normalizePosition(i.modelLineWrappedLineIdx, e, t);
  }
  getLineIndentColumn(e) {
    const t = this.getViewLineInfo(e);
    return t.modelLineWrappedLineIdx === 0 ? this.model.getLineIndentColumn(t.modelLineNumber) : 0;
  }
}
function jX(r) {
  if (r.length === 0)
    return [];
  const e = r.slice();
  e.sort(L.compareRangesUsingStarts);
  const t = [];
  let i = e[0].startLineNumber, n = e[0].endLineNumber;
  for (let s = 1, o = e.length; s < o; s++) {
    const a = e[s];
    a.startLineNumber > n + 1 ? (t.push(new L(i, 1, n, 1)), i = a.startLineNumber, n = a.endLineNumber) : a.endLineNumber > n && (n = a.endLineNumber);
  }
  return t.push(new L(i, 1, n, 1)), t;
}
class uO {
  constructor(e, t) {
    this.modelLineNumber = e, this.modelLineWrappedLineIdx = t;
  }
}
class gO {
  constructor(e, t) {
    this.modelRange = e, this.viewLines = t;
  }
}
class qX {
  constructor(e) {
    this._lines = e;
  }
  // View -> Model conversion and related methods
  convertViewPositionToModelPosition(e) {
    return this._lines.convertViewPositionToModelPosition(e.lineNumber, e.column);
  }
  convertViewRangeToModelRange(e) {
    return this._lines.convertViewRangeToModelRange(e);
  }
  validateViewPosition(e, t) {
    return this._lines.validateViewPosition(e.lineNumber, e.column, t);
  }
  validateViewRange(e, t) {
    return this._lines.validateViewRange(e, t);
  }
  // Model -> View conversion and related methods
  convertModelPositionToViewPosition(e, t, i, n) {
    return this._lines.convertModelPositionToViewPosition(e.lineNumber, e.column, t, i, n);
  }
  convertModelRangeToViewRange(e, t) {
    return this._lines.convertModelRangeToViewRange(e, t);
  }
  modelPositionIsVisible(e) {
    return this._lines.modelPositionIsVisible(e.lineNumber, e.column);
  }
  getModelLineViewLineCount(e) {
    return this._lines.getModelLineViewLineCount(e);
  }
  getViewLineNumberOfModelPosition(e, t) {
    return this._lines.getViewLineNumberOfModelPosition(e, t);
  }
}
class GX {
  constructor(e) {
    this.model = e;
  }
  dispose() {
  }
  createCoordinatesConverter() {
    return new ZX(this);
  }
  getHiddenAreas() {
    return [];
  }
  setHiddenAreas(e) {
    return !1;
  }
  setTabSize(e) {
    return !1;
  }
  setWrappingSettings(e, t, i, n) {
    return !1;
  }
  createLineBreaksComputer() {
    const e = [];
    return {
      addRequest: (t, i, n) => {
        e.push(null);
      },
      finalize: () => e
    };
  }
  onModelFlushed() {
  }
  onModelLinesDeleted(e, t, i) {
    return new pI(t, i);
  }
  onModelLinesInserted(e, t, i, n) {
    return new mI(t, i);
  }
  onModelLineChanged(e, t, i) {
    return [!1, new O2(t, 1), null, null];
  }
  acceptVersionId(e) {
  }
  getViewLineCount() {
    return this.model.getLineCount();
  }
  getActiveIndentGuide(e, t, i) {
    return {
      startLineNumber: e,
      endLineNumber: e,
      indent: 0
    };
  }
  getViewLinesBracketGuides(e, t, i) {
    return new Array(t - e + 1).fill([]);
  }
  getViewLinesIndentGuides(e, t) {
    const i = t - e + 1, n = new Array(i);
    for (let s = 0; s < i; s++)
      n[s] = 0;
    return n;
  }
  getViewLineContent(e) {
    return this.model.getLineContent(e);
  }
  getViewLineLength(e) {
    return this.model.getLineLength(e);
  }
  getViewLineMinColumn(e) {
    return this.model.getLineMinColumn(e);
  }
  getViewLineMaxColumn(e) {
    return this.model.getLineMaxColumn(e);
  }
  getViewLineData(e) {
    const t = this.model.tokenization.getLineTokens(e), i = t.getLineContent();
    return new p1(i, !1, 1, i.length + 1, 0, t.inflate(), null);
  }
  getViewLinesData(e, t, i) {
    const n = this.model.getLineCount();
    e = Math.min(Math.max(1, e), n), t = Math.min(Math.max(1, t), n);
    const s = [];
    for (let o = e; o <= t; o++) {
      const a = o - e;
      s[a] = i[a] ? this.getViewLineData(o) : null;
    }
    return s;
  }
  getDecorationsInRange(e, t, i, n, s) {
    return this.model.getDecorationsInRange(e, t, i, n, s);
  }
  normalizePosition(e, t) {
    return this.model.normalizePosition(e, t);
  }
  getLineIndentColumn(e) {
    return this.model.getLineIndentColumn(e);
  }
  getInjectedTextAt(e) {
    return null;
  }
}
class ZX {
  constructor(e) {
    this._lines = e;
  }
  _validPosition(e) {
    return this._lines.model.validatePosition(e);
  }
  _validRange(e) {
    return this._lines.model.validateRange(e);
  }
  // View -> Model conversion and related methods
  convertViewPositionToModelPosition(e) {
    return this._validPosition(e);
  }
  convertViewRangeToModelRange(e) {
    return this._validRange(e);
  }
  validateViewPosition(e, t) {
    return this._validPosition(t);
  }
  validateViewRange(e, t) {
    return this._validRange(t);
  }
  // Model -> View conversion and related methods
  convertModelPositionToViewPosition(e) {
    return this._validPosition(e);
  }
  convertModelRangeToViewRange(e) {
    return this._validRange(e);
  }
  modelPositionIsVisible(e) {
    const t = this._lines.model.getLineCount();
    return !(e.lineNumber < 1 || e.lineNumber > t);
  }
  getModelLineViewLineCount(e) {
    return 1;
  }
  getViewLineNumberOfModelPosition(e, t) {
    return e;
  }
}
const bh = Ec.Right;
class YX {
  constructor(e) {
    this.persist = 0, this._requiredLanes = 1, this.lanes = new Uint8Array(Math.ceil((e + 1) * bh / 8));
  }
  reset(e) {
    const t = Math.ceil((e + 1) * bh / 8);
    this.lanes.length < t ? this.lanes = new Uint8Array(t) : this.lanes.fill(0), this._requiredLanes = 1;
  }
  get requiredLanes() {
    return this._requiredLanes;
  }
  push(e, t, i) {
    i && (this.persist |= 1 << e - 1);
    for (let n = t.startLineNumber; n <= t.endLineNumber; n++) {
      const s = bh * n + (e - 1);
      this.lanes[s >>> 3] |= 1 << s % 8, this._requiredLanes = Math.max(this._requiredLanes, this.countAtLine(n));
    }
  }
  getLanesAtLine(e) {
    const t = [];
    let i = bh * e;
    for (let n = 0; n < bh; n++)
      (this.persist & 1 << n || this.lanes[i >>> 3] & 1 << i % 8) && t.push(n + 1), i++;
    return t.length ? t : [Ec.Center];
  }
  countAtLine(e) {
    let t = bh * e, i = 0;
    for (let n = 0; n < bh; n++)
      (this.persist & 1 << n || this.lanes[t >>> 3] & 1 << t % 8) && i++, t++;
    return i;
  }
}
let QX = class extends P {
  constructor(e, t, i, n, s, o, a, l, d) {
    if (super(), this.languageConfigurationService = a, this._themeService = l, this._attachedView = d, this.hiddenAreasModel = new JX(), this.previousHiddenAreas = [], this._editorId = e, this._configuration = t, this.model = i, this._eventDispatcher = new wX(), this.onEvent = this._eventDispatcher.onEvent, this.cursorConfig = new pg(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService), this._updateConfigurationViewLineCount = this._register(new xt(() => this._updateConfigurationViewLineCountNow(), 0)), this._hasFocus = !1, this._viewportStart = X1.create(this.model), this.glyphLanes = new YX(0), this.model.isTooLargeForTokenization())
      this._lines = new GX(this.model);
    else {
      const c = this._configuration.options, h = c.get(
        50
        /* EditorOption.fontInfo */
      ), u = c.get(
        139
        /* EditorOption.wrappingStrategy */
      ), g = c.get(
        146
        /* EditorOption.wrappingInfo */
      ), f = c.get(
        138
        /* EditorOption.wrappingIndent */
      ), m = c.get(
        129
        /* EditorOption.wordBreak */
      );
      this._lines = new KX(this._editorId, this.model, n, s, h, this.model.getOptions().tabSize, u, g.wrappingColumn, f, m);
    }
    this.coordinatesConverter = this._lines.createCoordinatesConverter(), this._cursor = this._register(new MX(i, this, this.coordinatesConverter, this.cursorConfig)), this.viewLayout = this._register(new VX(this._configuration, this.getLineCount(), o)), this._register(this.viewLayout.onDidScroll((c) => {
      c.scrollTopChanged && this._handleVisibleLinesChanged(), c.scrollTopChanged && this._viewportStart.invalidate(), this._eventDispatcher.emitSingleViewEvent(new mX(c)), this._eventDispatcher.emitOutgoingEvent(new G1(c.oldScrollWidth, c.oldScrollLeft, c.oldScrollHeight, c.oldScrollTop, c.scrollWidth, c.scrollLeft, c.scrollHeight, c.scrollTop));
    })), this._register(this.viewLayout.onDidContentSizeChange((c) => {
      this._eventDispatcher.emitOutgoingEvent(c);
    })), this._decorations = new zX(this._editorId, this.model, this._configuration, this._lines, this.coordinatesConverter), this._registerModelEvents(), this._register(this._configuration.onDidChangeFast((c) => {
      try {
        const h = this._eventDispatcher.beginEmitViewEvents();
        this._onConfigurationChanged(h, c);
      } finally {
        this._eventDispatcher.endEmitViewEvents();
      }
    })), this._register(bb.getInstance().onDidChange(() => {
      this._eventDispatcher.emitSingleViewEvent(new bX());
    })), this._register(this._themeService.onDidColorThemeChange((c) => {
      this._invalidateDecorationsColorCache(), this._eventDispatcher.emitSingleViewEvent(new _X(c));
    })), this._updateConfigurationViewLineCountNow();
  }
  dispose() {
    super.dispose(), this._decorations.dispose(), this._lines.dispose(), this._viewportStart.dispose(), this._eventDispatcher.dispose();
  }
  createLineBreaksComputer() {
    return this._lines.createLineBreaksComputer();
  }
  addViewEventHandler(e) {
    this._eventDispatcher.addViewEventHandler(e);
  }
  removeViewEventHandler(e) {
    this._eventDispatcher.removeViewEventHandler(e);
  }
  _updateConfigurationViewLineCountNow() {
    this._configuration.setViewLineCount(this._lines.getViewLineCount());
  }
  getModelVisibleRanges() {
    const e = this.viewLayout.getLinesViewportData(), t = new L(e.startLineNumber, this.getLineMinColumn(e.startLineNumber), e.endLineNumber, this.getLineMaxColumn(e.endLineNumber));
    return this._toModelVisibleRanges(t);
  }
  visibleLinesStabilized() {
    const e = this.getModelVisibleRanges();
    this._attachedView.setVisibleLines(e, !0);
  }
  _handleVisibleLinesChanged() {
    const e = this.getModelVisibleRanges();
    this._attachedView.setVisibleLines(e, !1);
  }
  setHasFocus(e) {
    this._hasFocus = e, this._cursor.setHasFocus(e), this._eventDispatcher.emitSingleViewEvent(new fX(e)), this._eventDispatcher.emitOutgoingEvent(new q1(!e, e));
  }
  onCompositionStart() {
    this._eventDispatcher.emitSingleViewEvent(new cX());
  }
  onCompositionEnd() {
    this._eventDispatcher.emitSingleViewEvent(new hX());
  }
  _captureStableViewport() {
    if (this._viewportStart.isValid && this.viewLayout.getCurrentScrollTop() > 0) {
      const e = new A(this._viewportStart.viewLineNumber, this.getLineMinColumn(this._viewportStart.viewLineNumber)), t = this.coordinatesConverter.convertViewPositionToModelPosition(e);
      return new pO(t, this._viewportStart.startLineDelta);
    }
    return new pO(null, 0);
  }
  _onConfigurationChanged(e, t) {
    const i = this._captureStableViewport(), n = this._configuration.options, s = n.get(
      50
      /* EditorOption.fontInfo */
    ), o = n.get(
      139
      /* EditorOption.wrappingStrategy */
    ), a = n.get(
      146
      /* EditorOption.wrappingInfo */
    ), l = n.get(
      138
      /* EditorOption.wrappingIndent */
    ), d = n.get(
      129
      /* EditorOption.wordBreak */
    );
    this._lines.setWrappingSettings(s, o, a.wrappingColumn, l, d) && (e.emitViewEvent(new DC()), e.emitViewEvent(new kC()), e.emitViewEvent(new vh(null)), this._cursor.onLineMappingChanged(e), this._decorations.onLineMappingChanged(), this.viewLayout.onFlushed(this.getLineCount()), this._updateConfigurationViewLineCount.schedule()), t.hasChanged(
      91
      /* EditorOption.readOnly */
    ) && (this._decorations.reset(), e.emitViewEvent(new vh(null))), t.hasChanged(
      98
      /* EditorOption.renderValidationDecorations */
    ) && (this._decorations.reset(), e.emitViewEvent(new vh(null))), e.emitViewEvent(new uX(t)), this.viewLayout.onConfigurationChanged(t), i.recoverViewportStart(this.coordinatesConverter, this.viewLayout), pg.shouldRecreate(t) && (this.cursorConfig = new pg(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService), this._cursor.updateConfiguration(this.cursorConfig));
  }
  _registerModelEvents() {
    this._register(this.model.onDidChangeContentOrInjectedText((e) => {
      try {
        const i = this._eventDispatcher.beginEmitViewEvents();
        let n = !1, s = !1;
        const o = e instanceof du ? e.rawContentChangedEvent.changes : e.changes, a = e instanceof du ? e.rawContentChangedEvent.versionId : null, l = this._lines.createLineBreaksComputer();
        for (const h of o)
          switch (h.changeType) {
            case 4: {
              for (let u = 0; u < h.detail.length; u++) {
                const g = h.detail[u];
                let f = h.injectedTexts[u];
                f && (f = f.filter((m) => !m.ownerId || m.ownerId === this._editorId)), l.addRequest(g, f, null);
              }
              break;
            }
            case 2: {
              let u = null;
              h.injectedText && (u = h.injectedText.filter((g) => !g.ownerId || g.ownerId === this._editorId)), l.addRequest(h.detail, u, null);
              break;
            }
          }
        const d = l.finalize(), c = new ad(d);
        for (const h of o)
          switch (h.changeType) {
            case 1: {
              this._lines.onModelFlushed(), i.emitViewEvent(new DC()), this._decorations.reset(), this.viewLayout.onFlushed(this.getLineCount()), n = !0;
              break;
            }
            case 3: {
              const u = this._lines.onModelLinesDeleted(a, h.fromLineNumber, h.toLineNumber);
              u !== null && (i.emitViewEvent(u), this.viewLayout.onLinesDeleted(u.fromLineNumber, u.toLineNumber)), n = !0;
              break;
            }
            case 4: {
              const u = c.takeCount(h.detail.length), g = this._lines.onModelLinesInserted(a, h.fromLineNumber, h.toLineNumber, u);
              g !== null && (i.emitViewEvent(g), this.viewLayout.onLinesInserted(g.fromLineNumber, g.toLineNumber)), n = !0;
              break;
            }
            case 2: {
              const u = c.dequeue(), [g, f, m, _] = this._lines.onModelLineChanged(a, h.lineNumber, u);
              s = g, f && i.emitViewEvent(f), m && (i.emitViewEvent(m), this.viewLayout.onLinesInserted(m.fromLineNumber, m.toLineNumber)), _ && (i.emitViewEvent(_), this.viewLayout.onLinesDeleted(_.fromLineNumber, _.toLineNumber));
              break;
            }
            case 5:
              break;
          }
        a !== null && this._lines.acceptVersionId(a), this.viewLayout.onHeightMaybeChanged(), !n && s && (i.emitViewEvent(new kC()), i.emitViewEvent(new vh(null)), this._cursor.onLineMappingChanged(i), this._decorations.onLineMappingChanged());
      } finally {
        this._eventDispatcher.endEmitViewEvents();
      }
      const t = this._viewportStart.isValid;
      if (this._viewportStart.invalidate(), this._configuration.setModelLineCount(this.model.getLineCount()), this._updateConfigurationViewLineCountNow(), !this._hasFocus && this.model.getAttachedEditorCount() >= 2 && t) {
        const i = this.model._getTrackedRange(this._viewportStart.modelTrackedRange);
        if (i) {
          const n = this.coordinatesConverter.convertModelPositionToViewPosition(i.getStartPosition()), s = this.viewLayout.getVerticalOffsetForLineNumber(n.lineNumber);
          this.viewLayout.setScrollPosition(
            { scrollTop: s + this._viewportStart.startLineDelta },
            1
            /* ScrollType.Immediate */
          );
        }
      }
      try {
        const i = this._eventDispatcher.beginEmitViewEvents();
        e instanceof du && i.emitOutgoingEvent(new EX(e.contentChangedEvent)), this._cursor.onModelContentChanged(i, e);
      } finally {
        this._eventDispatcher.endEmitViewEvents();
      }
      this._handleVisibleLinesChanged();
    })), this._register(this.model.onDidChangeTokens((e) => {
      const t = [];
      for (let i = 0, n = e.ranges.length; i < n; i++) {
        const s = e.ranges[i], o = this.coordinatesConverter.convertModelPositionToViewPosition(new A(s.fromLineNumber, 1)).lineNumber, a = this.coordinatesConverter.convertModelPositionToViewPosition(new A(s.toLineNumber, this.model.getLineMaxColumn(s.toLineNumber))).lineNumber;
        t[i] = {
          fromLineNumber: o,
          toLineNumber: a
        };
      }
      this._eventDispatcher.emitSingleViewEvent(new vX(t)), this._eventDispatcher.emitOutgoingEvent(new NX(e));
    })), this._register(this.model.onDidChangeLanguageConfiguration((e) => {
      this._eventDispatcher.emitSingleViewEvent(new pX()), this.cursorConfig = new pg(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService), this._cursor.updateConfiguration(this.cursorConfig), this._eventDispatcher.emitOutgoingEvent(new IX(e));
    })), this._register(this.model.onDidChangeLanguage((e) => {
      this.cursorConfig = new pg(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService), this._cursor.updateConfiguration(this.cursorConfig), this._eventDispatcher.emitOutgoingEvent(new xX(e));
    })), this._register(this.model.onDidChangeOptions((e) => {
      if (this._lines.setTabSize(this.model.getOptions().tabSize)) {
        try {
          const t = this._eventDispatcher.beginEmitViewEvents();
          t.emitViewEvent(new DC()), t.emitViewEvent(new kC()), t.emitViewEvent(new vh(null)), this._cursor.onLineMappingChanged(t), this._decorations.onLineMappingChanged(), this.viewLayout.onFlushed(this.getLineCount());
        } finally {
          this._eventDispatcher.endEmitViewEvents();
        }
        this._updateConfigurationViewLineCount.schedule();
      }
      this.cursorConfig = new pg(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService), this._cursor.updateConfiguration(this.cursorConfig), this._eventDispatcher.emitOutgoingEvent(new TX(e));
    })), this._register(this.model.onDidChangeDecorations((e) => {
      this._decorations.onModelDecorationsChanged(), this._eventDispatcher.emitSingleViewEvent(new vh(e)), this._eventDispatcher.emitOutgoingEvent(new kX(e));
    }));
  }
  setHiddenAreas(e, t) {
    var i;
    this.hiddenAreasModel.setHiddenAreas(t, e);
    const n = this.hiddenAreasModel.getMergedRanges();
    if (n === this.previousHiddenAreas)
      return;
    this.previousHiddenAreas = n;
    const s = this._captureStableViewport();
    let o = !1;
    try {
      const a = this._eventDispatcher.beginEmitViewEvents();
      o = this._lines.setHiddenAreas(n), o && (a.emitViewEvent(new DC()), a.emitViewEvent(new kC()), a.emitViewEvent(new vh(null)), this._cursor.onLineMappingChanged(a), this._decorations.onLineMappingChanged(), this.viewLayout.onFlushed(this.getLineCount()), this.viewLayout.onHeightMaybeChanged());
      const l = (i = s.viewportStartModelPosition) === null || i === void 0 ? void 0 : i.lineNumber;
      l && n.some((c) => c.startLineNumber <= l && l <= c.endLineNumber) || s.recoverViewportStart(this.coordinatesConverter, this.viewLayout);
    } finally {
      this._eventDispatcher.endEmitViewEvents();
    }
    this._updateConfigurationViewLineCount.schedule(), o && this._eventDispatcher.emitOutgoingEvent(new LX());
  }
  getVisibleRangesPlusViewportAboveBelow() {
    const e = this._configuration.options.get(
      145
      /* EditorOption.layoutInfo */
    ), t = this._configuration.options.get(
      67
      /* EditorOption.lineHeight */
    ), i = Math.max(20, Math.round(e.height / t)), n = this.viewLayout.getLinesViewportData(), s = Math.max(1, n.completelyVisibleStartLineNumber - i), o = Math.min(this.getLineCount(), n.completelyVisibleEndLineNumber + i);
    return this._toModelVisibleRanges(new L(s, this.getLineMinColumn(s), o, this.getLineMaxColumn(o)));
  }
  getVisibleRanges() {
    const e = this.getCompletelyVisibleViewRange();
    return this._toModelVisibleRanges(e);
  }
  getHiddenAreas() {
    return this._lines.getHiddenAreas();
  }
  _toModelVisibleRanges(e) {
    const t = this.coordinatesConverter.convertViewRangeToModelRange(e), i = this._lines.getHiddenAreas();
    if (i.length === 0)
      return [t];
    const n = [];
    let s = 0, o = t.startLineNumber, a = t.startColumn;
    const l = t.endLineNumber, d = t.endColumn;
    for (let c = 0, h = i.length; c < h; c++) {
      const u = i[c].startLineNumber, g = i[c].endLineNumber;
      g < o || u > l || (o < u && (n[s++] = new L(o, a, u - 1, this.model.getLineMaxColumn(u - 1))), o = g + 1, a = 1);
    }
    return (o < l || o === l && a < d) && (n[s++] = new L(o, a, l, d)), n;
  }
  getCompletelyVisibleViewRange() {
    const e = this.viewLayout.getLinesViewportData(), t = e.completelyVisibleStartLineNumber, i = e.completelyVisibleEndLineNumber;
    return new L(t, this.getLineMinColumn(t), i, this.getLineMaxColumn(i));
  }
  getCompletelyVisibleViewRangeAtScrollTop(e) {
    const t = this.viewLayout.getLinesViewportDataAtScrollTop(e), i = t.completelyVisibleStartLineNumber, n = t.completelyVisibleEndLineNumber;
    return new L(i, this.getLineMinColumn(i), n, this.getLineMaxColumn(n));
  }
  saveState() {
    const e = this.viewLayout.saveState(), t = e.scrollTop, i = this.viewLayout.getLineNumberAtVerticalOffset(t), n = this.coordinatesConverter.convertViewPositionToModelPosition(new A(i, this.getLineMinColumn(i))), s = this.viewLayout.getVerticalOffsetForLineNumber(i) - t;
    return {
      scrollLeft: e.scrollLeft,
      firstPosition: n,
      firstPositionDeltaTop: s
    };
  }
  reduceRestoreState(e) {
    if (typeof e.firstPosition > "u")
      return this._reduceRestoreStateCompatibility(e);
    const t = this.model.validatePosition(e.firstPosition), i = this.coordinatesConverter.convertModelPositionToViewPosition(t), n = this.viewLayout.getVerticalOffsetForLineNumber(i.lineNumber) - e.firstPositionDeltaTop;
    return {
      scrollLeft: e.scrollLeft,
      scrollTop: n
    };
  }
  _reduceRestoreStateCompatibility(e) {
    return {
      scrollLeft: e.scrollLeft,
      scrollTop: e.scrollTopWithoutViewZones
    };
  }
  getTabSize() {
    return this.model.getOptions().tabSize;
  }
  getLineCount() {
    return this._lines.getViewLineCount();
  }
  /**
   * Gives a hint that a lot of requests are about to come in for these line numbers.
   */
  setViewport(e, t, i) {
    this._viewportStart.update(this, e);
  }
  getActiveIndentGuide(e, t, i) {
    return this._lines.getActiveIndentGuide(e, t, i);
  }
  getLinesIndentGuides(e, t) {
    return this._lines.getViewLinesIndentGuides(e, t);
  }
  getBracketGuidesInRangeByLine(e, t, i, n) {
    return this._lines.getViewLinesBracketGuides(e, t, i, n);
  }
  getLineContent(e) {
    return this._lines.getViewLineContent(e);
  }
  getLineLength(e) {
    return this._lines.getViewLineLength(e);
  }
  getLineMinColumn(e) {
    return this._lines.getViewLineMinColumn(e);
  }
  getLineMaxColumn(e) {
    return this._lines.getViewLineMaxColumn(e);
  }
  getLineFirstNonWhitespaceColumn(e) {
    const t = ns(this.getLineContent(e));
    return t === -1 ? 0 : t + 1;
  }
  getLineLastNonWhitespaceColumn(e) {
    const t = ja(this.getLineContent(e));
    return t === -1 ? 0 : t + 2;
  }
  getMinimapDecorationsInRange(e) {
    return this._decorations.getMinimapDecorationsInRange(e);
  }
  getDecorationsInViewport(e) {
    return this._decorations.getDecorationsViewportData(e).decorations;
  }
  getInjectedTextAt(e) {
    return this._lines.getInjectedTextAt(e);
  }
  getViewportViewLineRenderingData(e, t) {
    const n = this._decorations.getDecorationsViewportData(e).inlineDecorations[t - e.startLineNumber];
    return this._getViewLineRenderingData(t, n);
  }
  getViewLineRenderingData(e) {
    const t = this._decorations.getInlineDecorationsOnLine(e);
    return this._getViewLineRenderingData(e, t);
  }
  _getViewLineRenderingData(e, t) {
    const i = this.model.mightContainRTL(), n = this.model.mightContainNonBasicASCII(), s = this.getTabSize(), o = this._lines.getViewLineData(e);
    return o.inlineDecorations && (t = [
      ...t,
      ...o.inlineDecorations.map((a) => a.toInlineDecoration(e))
    ]), new po(o.minColumn, o.maxColumn, o.content, o.continuesWithWrappedLine, i, n, o.tokens, t, s, o.startVisibleColumn);
  }
  getViewLineData(e) {
    return this._lines.getViewLineData(e);
  }
  getMinimapLinesRenderingData(e, t, i) {
    const n = this._lines.getViewLinesData(e, t, i);
    return new Uq(this.getTabSize(), n);
  }
  getAllOverviewRulerDecorations(e) {
    const t = this.model.getOverviewRulerDecorations(this._editorId, dS(this._configuration.options)), i = new XX();
    for (const n of t) {
      const s = n.options, o = s.overviewRuler;
      if (!o)
        continue;
      const a = o.position;
      if (a === 0)
        continue;
      const l = o.getColor(e.value), d = this.coordinatesConverter.getViewLineNumberOfModelPosition(n.range.startLineNumber, n.range.startColumn), c = this.coordinatesConverter.getViewLineNumberOfModelPosition(n.range.endLineNumber, n.range.endColumn);
      i.accept(l, s.zIndex, d, c, a);
    }
    return i.asArray;
  }
  _invalidateDecorationsColorCache() {
    const e = this.model.getOverviewRulerDecorations();
    for (const t of e) {
      const i = t.options.overviewRuler;
      i == null || i.invalidateCachedColor();
      const n = t.options.minimap;
      n == null || n.invalidateCachedColor();
    }
  }
  getValueInRange(e, t) {
    const i = this.coordinatesConverter.convertViewRangeToModelRange(e);
    return this.model.getValueInRange(i, t);
  }
  getValueLengthInRange(e, t) {
    const i = this.coordinatesConverter.convertViewRangeToModelRange(e);
    return this.model.getValueLengthInRange(i, t);
  }
  modifyPosition(e, t) {
    const i = this.coordinatesConverter.convertViewPositionToModelPosition(e), n = this.model.modifyPosition(i, t);
    return this.coordinatesConverter.convertModelPositionToViewPosition(n);
  }
  deduceModelPositionRelativeToViewPosition(e, t, i) {
    const n = this.coordinatesConverter.convertViewPositionToModelPosition(e);
    this.model.getEOL().length === 2 && (t < 0 ? t -= i : t += i);
    const o = this.model.getOffsetAt(n) + t;
    return this.model.getPositionAt(o);
  }
  getPlainTextToCopy(e, t, i) {
    const n = i ? `\r
` : this.model.getEOL();
    e = e.slice(0), e.sort(L.compareRangesUsingStarts);
    let s = !1, o = !1;
    for (const l of e)
      l.isEmpty() ? s = !0 : o = !0;
    if (!o) {
      if (!t)
        return "";
      const l = e.map((c) => c.startLineNumber);
      let d = "";
      for (let c = 0; c < l.length; c++)
        c > 0 && l[c - 1] === l[c] || (d += this.model.getLineContent(l[c]) + n);
      return d;
    }
    if (s && t) {
      const l = [];
      let d = 0;
      for (const c of e) {
        const h = c.startLineNumber;
        c.isEmpty() ? h !== d && l.push(this.model.getLineContent(h)) : l.push(this.model.getValueInRange(
          c,
          i ? 2 : 0
          /* EndOfLinePreference.TextDefined */
        )), d = h;
      }
      return l.length === 1 ? l[0] : l;
    }
    const a = [];
    for (const l of e)
      l.isEmpty() || a.push(this.model.getValueInRange(
        l,
        i ? 2 : 0
        /* EndOfLinePreference.TextDefined */
      ));
    return a.length === 1 ? a[0] : a;
  }
  getRichTextToCopy(e, t) {
    const i = this.model.getLanguageId();
    if (i === go || e.length !== 1)
      return null;
    let n = e[0];
    if (n.isEmpty()) {
      if (!t)
        return null;
      const c = n.startLineNumber;
      n = new L(c, this.model.getLineMinColumn(c), c, this.model.getLineMaxColumn(c));
    }
    const s = this._configuration.options.get(
      50
      /* EditorOption.fontInfo */
    ), o = this._getColorMap(), l = /[:;\\\/<>]/.test(s.fontFamily) || s.fontFamily === Ss.fontFamily;
    let d;
    return l ? d = Ss.fontFamily : (d = s.fontFamily, d = d.replace(/"/g, "'"), /[,']/.test(d) || /[+ ]/.test(d) && (d = `'${d}'`), d = `${d}, ${Ss.fontFamily}`), {
      mode: i,
      html: `<div style="color: ${o[
        1
        /* ColorId.DefaultForeground */
      ]};background-color: ${o[
        2
        /* ColorId.DefaultBackground */
      ]};font-family: ${d};font-weight: ${s.fontWeight};font-size: ${s.fontSize}px;line-height: ${s.lineHeight}px;white-space: pre;">` + this._getHTMLToCopy(n, o) + "</div>"
    };
  }
  _getHTMLToCopy(e, t) {
    const i = e.startLineNumber, n = e.startColumn, s = e.endLineNumber, o = e.endColumn, a = this.getTabSize();
    let l = "";
    for (let d = i; d <= s; d++) {
      const c = this.model.tokenization.getLineTokens(d), h = c.getLineContent(), u = d === i ? n - 1 : 0, g = d === s ? o - 1 : h.length;
      h === "" ? l += "<br>" : l += OX(h, c.inflate(), t, u, g, a, Ks);
    }
    return l;
  }
  _getColorMap() {
    const e = ri.getColorMap(), t = ["#000000"];
    if (e)
      for (let i = 1, n = e.length; i < n; i++)
        t[i] = z.Format.CSS.formatHex(e[i]);
    return t;
  }
  //#region cursor operations
  getPrimaryCursorState() {
    return this._cursor.getPrimaryCursorState();
  }
  getLastAddedCursorIndex() {
    return this._cursor.getLastAddedCursorIndex();
  }
  getCursorStates() {
    return this._cursor.getCursorStates();
  }
  setCursorStates(e, t, i) {
    return this._withViewEventsCollector((n) => this._cursor.setStates(n, e, t, i));
  }
  getCursorColumnSelectData() {
    return this._cursor.getCursorColumnSelectData();
  }
  getCursorAutoClosedCharacters() {
    return this._cursor.getAutoClosedCharacters();
  }
  setCursorColumnSelectData(e) {
    this._cursor.setCursorColumnSelectData(e);
  }
  getPrevEditOperationType() {
    return this._cursor.getPrevEditOperationType();
  }
  setPrevEditOperationType(e) {
    this._cursor.setPrevEditOperationType(e);
  }
  getSelection() {
    return this._cursor.getSelection();
  }
  getSelections() {
    return this._cursor.getSelections();
  }
  getPosition() {
    return this._cursor.getPrimaryCursorState().modelState.position;
  }
  setSelections(e, t, i = 0) {
    this._withViewEventsCollector((n) => this._cursor.setSelections(n, e, t, i));
  }
  saveCursorState() {
    return this._cursor.saveState();
  }
  restoreCursorState(e) {
    this._withViewEventsCollector((t) => this._cursor.restoreState(t, e));
  }
  _executeCursorEdit(e) {
    if (this._cursor.context.cursorConfig.readOnly) {
      this._eventDispatcher.emitOutgoingEvent(new DX());
      return;
    }
    this._withViewEventsCollector(e);
  }
  executeEdits(e, t, i) {
    this._executeCursorEdit((n) => this._cursor.executeEdits(n, e, t, i));
  }
  startComposition() {
    this._executeCursorEdit((e) => this._cursor.startComposition(e));
  }
  endComposition(e) {
    this._executeCursorEdit((t) => this._cursor.endComposition(t, e));
  }
  type(e, t) {
    this._executeCursorEdit((i) => this._cursor.type(i, e, t));
  }
  compositionType(e, t, i, n, s) {
    this._executeCursorEdit((o) => this._cursor.compositionType(o, e, t, i, n, s));
  }
  paste(e, t, i, n) {
    this._executeCursorEdit((s) => this._cursor.paste(s, e, t, i, n));
  }
  cut(e) {
    this._executeCursorEdit((t) => this._cursor.cut(t, e));
  }
  executeCommand(e, t) {
    this._executeCursorEdit((i) => this._cursor.executeCommand(i, e, t));
  }
  executeCommands(e, t) {
    this._executeCursorEdit((i) => this._cursor.executeCommands(i, e, t));
  }
  revealAllCursors(e, t, i = !1) {
    this._withViewEventsCollector((n) => this._cursor.revealAll(
      n,
      e,
      i,
      0,
      t,
      0
      /* ScrollType.Smooth */
    ));
  }
  revealPrimaryCursor(e, t, i = !1) {
    this._withViewEventsCollector((n) => this._cursor.revealPrimary(
      n,
      e,
      i,
      0,
      t,
      0
      /* ScrollType.Smooth */
    ));
  }
  revealTopMostCursor(e) {
    const t = this._cursor.getTopMostViewPosition(), i = new L(t.lineNumber, t.column, t.lineNumber, t.column);
    this._withViewEventsCollector((n) => n.emitViewEvent(new g_(
      e,
      !1,
      i,
      null,
      0,
      !0,
      0
      /* ScrollType.Smooth */
    )));
  }
  revealBottomMostCursor(e) {
    const t = this._cursor.getBottomMostViewPosition(), i = new L(t.lineNumber, t.column, t.lineNumber, t.column);
    this._withViewEventsCollector((n) => n.emitViewEvent(new g_(
      e,
      !1,
      i,
      null,
      0,
      !0,
      0
      /* ScrollType.Smooth */
    )));
  }
  revealRange(e, t, i, n, s) {
    this._withViewEventsCollector((o) => o.emitViewEvent(new g_(e, !1, i, null, n, t, s)));
  }
  //#endregion
  //#region viewLayout
  changeWhitespace(e) {
    this.viewLayout.changeWhitespace(e) && (this._eventDispatcher.emitSingleViewEvent(new CX()), this._eventDispatcher.emitOutgoingEvent(new yX()));
  }
  //#endregion
  _withViewEventsCollector(e) {
    try {
      const t = this._eventDispatcher.beginEmitViewEvents();
      return e(t);
    } finally {
      this._eventDispatcher.endEmitViewEvents();
    }
  }
  batchEvents(e) {
    this._withViewEventsCollector(() => {
      e();
    });
  }
  normalizePosition(e, t) {
    return this._lines.normalizePosition(e, t);
  }
  /**
   * Gets the column at which indentation stops at a given line.
   * @internal
  */
  getLineIndentColumn(e) {
    return this._lines.getLineIndentColumn(e);
  }
};
class X1 {
  static create(e) {
    const t = e._setTrackedRange(
      null,
      new L(1, 1, 1, 1),
      1
      /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */
    );
    return new X1(e, 1, !1, t, 0);
  }
  get viewLineNumber() {
    return this._viewLineNumber;
  }
  get isValid() {
    return this._isValid;
  }
  get modelTrackedRange() {
    return this._modelTrackedRange;
  }
  get startLineDelta() {
    return this._startLineDelta;
  }
  constructor(e, t, i, n, s) {
    this._model = e, this._viewLineNumber = t, this._isValid = i, this._modelTrackedRange = n, this._startLineDelta = s;
  }
  dispose() {
    this._model._setTrackedRange(
      this._modelTrackedRange,
      null,
      1
      /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */
    );
  }
  update(e, t) {
    const i = e.coordinatesConverter.convertViewPositionToModelPosition(new A(t, e.getLineMinColumn(t))), n = e.model._setTrackedRange(
      this._modelTrackedRange,
      new L(i.lineNumber, i.column, i.lineNumber, i.column),
      1
      /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */
    ), s = e.viewLayout.getVerticalOffsetForLineNumber(t), o = e.viewLayout.getCurrentScrollTop();
    this._viewLineNumber = t, this._isValid = !0, this._modelTrackedRange = n, this._startLineDelta = o - s;
  }
  invalidate() {
    this._isValid = !1;
  }
}
class XX {
  constructor() {
    this._asMap = /* @__PURE__ */ Object.create(null), this.asArray = [];
  }
  accept(e, t, i, n, s) {
    const o = this._asMap[e];
    if (o) {
      const a = o.data, l = a[a.length - 3], d = a[a.length - 1];
      if (l === s && d + 1 >= i) {
        n > d && (a[a.length - 1] = n);
        return;
      }
      a.push(s, i, n);
    } else {
      const a = new W_(e, t, [s, i, n]);
      this._asMap[e] = a, this.asArray.push(a);
    }
  }
}
class JX {
  constructor() {
    this.hiddenAreas = /* @__PURE__ */ new Map(), this.shouldRecompute = !1, this.ranges = [];
  }
  setHiddenAreas(e, t) {
    const i = this.hiddenAreas.get(e);
    i && fO(i, t) || (this.hiddenAreas.set(e, t), this.shouldRecompute = !0);
  }
  /**
   * The returned array is immutable.
  */
  getMergedRanges() {
    if (!this.shouldRecompute)
      return this.ranges;
    this.shouldRecompute = !1;
    const e = Array.from(this.hiddenAreas.values()).reduce((t, i) => eJ(t, i), []);
    return fO(this.ranges, e) ? this.ranges : (this.ranges = e, this.ranges);
  }
}
function eJ(r, e) {
  const t = [];
  let i = 0, n = 0;
  for (; i < r.length && n < e.length; ) {
    const s = r[i], o = e[n];
    if (s.endLineNumber < o.startLineNumber - 1)
      t.push(r[i++]);
    else if (o.endLineNumber < s.startLineNumber - 1)
      t.push(e[n++]);
    else {
      const a = Math.min(s.startLineNumber, o.startLineNumber), l = Math.max(s.endLineNumber, o.endLineNumber);
      t.push(new L(a, 1, l, 1)), i++, n++;
    }
  }
  for (; i < r.length; )
    t.push(r[i++]);
  for (; n < e.length; )
    t.push(e[n++]);
  return t;
}
function fO(r, e) {
  if (r.length !== e.length)
    return !1;
  for (let t = 0; t < r.length; t++)
    if (!r[t].equalsRange(e[t]))
      return !1;
  return !0;
}
class pO {
  constructor(e, t) {
    this.viewportStartModelPosition = e, this.startLineDelta = t;
  }
  recoverViewportStart(e, t) {
    if (!this.viewportStartModelPosition)
      return;
    const i = e.convertModelPositionToViewPosition(this.viewportStartModelPosition), n = t.getVerticalOffsetForLineNumber(i.lineNumber);
    t.setScrollPosition(
      { scrollTop: n + this.startLineDelta },
      1
      /* ScrollType.Immediate */
    );
  }
}
class Cb {
  constructor(...e) {
    this._entries = /* @__PURE__ */ new Map();
    for (const [t, i] of e)
      this.set(t, i);
  }
  set(e, t) {
    const i = this._entries.get(e);
    return this._entries.set(e, t), i;
  }
  get(e) {
    return this._entries.get(e);
  }
}
var tv;
(function(r) {
  r[r.Ignore = 0] = "Ignore", r[r.Info = 1] = "Info", r[r.Warning = 2] = "Warning", r[r.Error = 3] = "Error";
})(tv || (tv = {}));
(function(r) {
  const e = "error", t = "warning", i = "warn", n = "info", s = "ignore";
  function o(l) {
    return l ? Wg(e, l) ? r.Error : Wg(t, l) || Wg(i, l) ? r.Warning : Wg(n, l) ? r.Info : r.Ignore : r.Ignore;
  }
  r.fromValue = o;
  function a(l) {
    switch (l) {
      case r.Error:
        return e;
      case r.Warning:
        return t;
      case r.Info:
        return n;
      default:
        return s;
    }
  }
  r.toString = a;
})(tv || (tv = {}));
const yi = tv;
var F0 = yi;
const xi = et("notificationService");
class tJ {
}
var iJ = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, vl = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, Nh;
let Qf = Nh = class extends P {
  //#endregion
  get isSimpleWidget() {
    return this._configuration.isSimpleWidget;
  }
  get contextMenuId() {
    return this._configuration.contextMenuId;
  }
  constructor(e, t, i, n, s, o, a, l, d, c, h, u) {
    var g, f;
    super(), this.languageConfigurationService = h, this._deliveryQueue = M5(), this._contributions = this._register(new AY()), this._onDidDispose = this._register(new R()), this.onDidDispose = this._onDidDispose.event, this._onDidChangeModelContent = this._register(new R({ deliveryQueue: this._deliveryQueue })), this.onDidChangeModelContent = this._onDidChangeModelContent.event, this._onDidChangeModelLanguage = this._register(new R({ deliveryQueue: this._deliveryQueue })), this.onDidChangeModelLanguage = this._onDidChangeModelLanguage.event, this._onDidChangeModelLanguageConfiguration = this._register(new R({ deliveryQueue: this._deliveryQueue })), this.onDidChangeModelLanguageConfiguration = this._onDidChangeModelLanguageConfiguration.event, this._onDidChangeModelOptions = this._register(new R({ deliveryQueue: this._deliveryQueue })), this.onDidChangeModelOptions = this._onDidChangeModelOptions.event, this._onDidChangeModelDecorations = this._register(new R({ deliveryQueue: this._deliveryQueue })), this.onDidChangeModelDecorations = this._onDidChangeModelDecorations.event, this._onDidChangeModelTokens = this._register(new R({ deliveryQueue: this._deliveryQueue })), this.onDidChangeModelTokens = this._onDidChangeModelTokens.event, this._onDidChangeConfiguration = this._register(new R({ deliveryQueue: this._deliveryQueue })), this.onDidChangeConfiguration = this._onDidChangeConfiguration.event, this._onWillChangeModel = this._register(new R({ deliveryQueue: this._deliveryQueue })), this.onWillChangeModel = this._onWillChangeModel.event, this._onDidChangeModel = this._register(new R({ deliveryQueue: this._deliveryQueue })), this.onDidChangeModel = this._onDidChangeModel.event, this._onDidChangeCursorPosition = this._register(new R({ deliveryQueue: this._deliveryQueue })), this.onDidChangeCursorPosition = this._onDidChangeCursorPosition.event, this._onDidChangeCursorSelection = this._register(new R({ deliveryQueue: this._deliveryQueue })), this.onDidChangeCursorSelection = this._onDidChangeCursorSelection.event, this._onDidAttemptReadOnlyEdit = this._register(new Wn(this._contributions, this._deliveryQueue)), this.onDidAttemptReadOnlyEdit = this._onDidAttemptReadOnlyEdit.event, this._onDidLayoutChange = this._register(new R({ deliveryQueue: this._deliveryQueue })), this.onDidLayoutChange = this._onDidLayoutChange.event, this._editorTextFocus = this._register(new mO({ deliveryQueue: this._deliveryQueue })), this.onDidFocusEditorText = this._editorTextFocus.onDidChangeToTrue, this.onDidBlurEditorText = this._editorTextFocus.onDidChangeToFalse, this._editorWidgetFocus = this._register(new mO({ deliveryQueue: this._deliveryQueue })), this.onDidFocusEditorWidget = this._editorWidgetFocus.onDidChangeToTrue, this.onDidBlurEditorWidget = this._editorWidgetFocus.onDidChangeToFalse, this._onWillType = this._register(new Wn(this._contributions, this._deliveryQueue)), this.onWillType = this._onWillType.event, this._onDidType = this._register(new Wn(this._contributions, this._deliveryQueue)), this.onDidType = this._onDidType.event, this._onDidCompositionStart = this._register(new Wn(this._contributions, this._deliveryQueue)), this.onDidCompositionStart = this._onDidCompositionStart.event, this._onDidCompositionEnd = this._register(new Wn(this._contributions, this._deliveryQueue)), this.onDidCompositionEnd = this._onDidCompositionEnd.event, this._onDidPaste = this._register(new Wn(this._contributions, this._deliveryQueue)), this.onDidPaste = this._onDidPaste.event, this._onMouseUp = this._register(new Wn(this._contributions, this._deliveryQueue)), this.onMouseUp = this._onMouseUp.event, this._onMouseDown = this._register(new Wn(this._contributions, this._deliveryQueue)), this.onMouseDown = this._onMouseDown.event, this._onMouseDrag = this._register(new Wn(this._contributions, this._deliveryQueue)), this.onMouseDrag = this._onMouseDrag.event, this._onMouseDrop = this._register(new Wn(this._contributions, this._deliveryQueue)), this.onMouseDrop = this._onMouseDrop.event, this._onMouseDropCanceled = this._register(new Wn(this._contributions, this._deliveryQueue)), this.onMouseDropCanceled = this._onMouseDropCanceled.event, this._onDropIntoEditor = this._register(new Wn(this._contributions, this._deliveryQueue)), this.onDropIntoEditor = this._onDropIntoEditor.event, this._onContextMenu = this._register(new Wn(this._contributions, this._deliveryQueue)), this.onContextMenu = this._onContextMenu.event, this._onMouseMove = this._register(new Wn(this._contributions, this._deliveryQueue)), this.onMouseMove = this._onMouseMove.event, this._onMouseLeave = this._register(new Wn(this._contributions, this._deliveryQueue)), this.onMouseLeave = this._onMouseLeave.event, this._onMouseWheel = this._register(new Wn(this._contributions, this._deliveryQueue)), this.onMouseWheel = this._onMouseWheel.event, this._onKeyUp = this._register(new Wn(this._contributions, this._deliveryQueue)), this.onKeyUp = this._onKeyUp.event, this._onKeyDown = this._register(new Wn(this._contributions, this._deliveryQueue)), this.onKeyDown = this._onKeyDown.event, this._onDidContentSizeChange = this._register(new R({ deliveryQueue: this._deliveryQueue })), this.onDidContentSizeChange = this._onDidContentSizeChange.event, this._onDidScrollChange = this._register(new R({ deliveryQueue: this._deliveryQueue })), this.onDidScrollChange = this._onDidScrollChange.event, this._onDidChangeViewZones = this._register(new R({ deliveryQueue: this._deliveryQueue })), this.onDidChangeViewZones = this._onDidChangeViewZones.event, this._onDidChangeHiddenAreas = this._register(new R({ deliveryQueue: this._deliveryQueue })), this.onDidChangeHiddenAreas = this._onDidChangeHiddenAreas.event, this._updateCounter = 0, this._onBeginUpdate = this._register(new R()), this.onBeginUpdate = this._onBeginUpdate.event, this._onEndUpdate = this._register(new R()), this.onEndUpdate = this._onEndUpdate.event, this._actions = /* @__PURE__ */ new Map(), this._bannerDomNode = null, this._dropIntoEditorDecorations = this.createDecorationsCollection(), s.willCreateCodeEditor();
    const m = { ...t };
    this._domElement = e, this._overflowWidgetsDomNode = m.overflowWidgetsDomNode, delete m.overflowWidgetsDomNode, this._id = ++nJ, this._decorationTypeKeysToIds = {}, this._decorationTypeSubtypes = {}, this._telemetryData = i.telemetryData, this._configuration = this._register(this._createConfiguration(i.isSimpleWidget || !1, (g = i.contextMenuId) !== null && g !== void 0 ? g : i.isSimpleWidget ? D.SimpleEditorContext : D.EditorContext, m, c)), this._register(this._configuration.onDidChange((b) => {
      this._onDidChangeConfiguration.fire(b);
      const C = this._configuration.options;
      if (b.hasChanged(
        145
        /* EditorOption.layoutInfo */
      )) {
        const w = C.get(
          145
          /* EditorOption.layoutInfo */
        );
        this._onDidLayoutChange.fire(w);
      }
    })), this._contextKeyService = this._register(a.createScoped(this._domElement)), this._notificationService = d, this._codeEditorService = s, this._commandService = o, this._themeService = l, this._register(new oJ(this, this._contextKeyService)), this._register(new rJ(this, this._contextKeyService, u)), this._instantiationService = this._register(n.createChild(new Cb([De, this._contextKeyService]))), this._modelData = null, this._focusTracker = new aJ(e, this._overflowWidgetsDomNode), this._register(this._focusTracker.onChange(() => {
      this._editorWidgetFocus.setValue(this._focusTracker.hasFocus());
    })), this._contentWidgets = {}, this._overlayWidgets = {}, this._glyphMarginWidgets = {};
    let _;
    Array.isArray(i.contributions) ? _ = i.contributions : _ = ff.getEditorContributions(), this._contributions.initialize(this, _, this._instantiationService);
    for (const b of ff.getEditorActions()) {
      if (this._actions.has(b.id)) {
        He(new Error(`Cannot have two actions with the same id ${b.id}`));
        continue;
      }
      const C = new f2(b.id, b.label, b.alias, b.metadata, (f = b.precondition) !== null && f !== void 0 ? f : void 0, (w) => this._instantiationService.invokeFunction((S) => Promise.resolve(b.runEditorCommand(S, this, w))), this._contextKeyService);
      this._actions.set(C.id, C);
    }
    const v = () => !this._configuration.options.get(
      91
      /* EditorOption.readOnly */
    ) && this._configuration.options.get(
      36
      /* EditorOption.dropIntoEditor */
    ).enabled;
    this._register(new s6(this._domElement, {
      onDragOver: (b) => {
        if (!v())
          return;
        const C = this.getTargetAtClientPoint(b.clientX, b.clientY);
        C != null && C.position && this.showDropIndicatorAt(C.position);
      },
      onDrop: async (b) => {
        if (!v() || (this.removeDropIndicator(), !b.dataTransfer))
          return;
        const C = this.getTargetAtClientPoint(b.clientX, b.clientY);
        C != null && C.position && this._onDropIntoEditor.fire({ position: C.position, event: b });
      },
      onDragLeave: () => {
        this.removeDropIndicator();
      },
      onDragEnd: () => {
        this.removeDropIndicator();
      }
    })), this._codeEditorService.addCodeEditor(this);
  }
  writeScreenReaderContent(e) {
    var t;
    (t = this._modelData) === null || t === void 0 || t.view.writeScreenReaderContent(e);
  }
  _createConfiguration(e, t, i, n) {
    return new Ux(e, t, i, this._domElement, n);
  }
  getId() {
    return this.getEditorType() + ":" + this._id;
  }
  getEditorType() {
    return cb.ICodeEditor;
  }
  dispose() {
    this._codeEditorService.removeCodeEditor(this), this._focusTracker.dispose(), this._actions.clear(), this._contentWidgets = {}, this._overlayWidgets = {}, this._removeDecorationTypes(), this._postDetachModelCleanup(this._detachModel()), this._onDidDispose.fire(), super.dispose();
  }
  invokeWithinContext(e) {
    return this._instantiationService.invokeFunction(e);
  }
  updateOptions(e) {
    this._configuration.updateOptions(e || {});
  }
  getOptions() {
    return this._configuration.options;
  }
  getOption(e) {
    return this._configuration.options.get(e);
  }
  getRawOptions() {
    return this._configuration.getRawOptions();
  }
  getOverflowWidgetsDomNode() {
    return this._overflowWidgetsDomNode;
  }
  getConfiguredWordAtPosition(e) {
    return this._modelData ? vt.getWordAtPosition(this._modelData.model, this._configuration.options.get(
      131
      /* EditorOption.wordSeparators */
    ), this._configuration.options.get(
      130
      /* EditorOption.wordSegmenterLocales */
    ), e) : null;
  }
  getValue(e = null) {
    if (!this._modelData)
      return "";
    const t = !!(e && e.preserveBOM);
    let i = 0;
    return e && e.lineEnding && e.lineEnding === `
` ? i = 1 : e && e.lineEnding && e.lineEnding === `\r
` && (i = 2), this._modelData.model.getValue(i, t);
  }
  setValue(e) {
    try {
      if (this._beginUpdate(), !this._modelData)
        return;
      this._modelData.model.setValue(e);
    } finally {
      this._endUpdate();
    }
  }
  getModel() {
    return this._modelData ? this._modelData.model : null;
  }
  setModel(e = null) {
    var t;
    try {
      this._beginUpdate();
      const i = e;
      if (this._modelData === null && i === null || this._modelData && this._modelData.model === i)
        return;
      const n = {
        oldModelUrl: ((t = this._modelData) === null || t === void 0 ? void 0 : t.model.uri) || null,
        newModelUrl: (i == null ? void 0 : i.uri) || null
      };
      this._onWillChangeModel.fire(n);
      const s = this.hasTextFocus(), o = this._detachModel();
      this._attachModel(i), s && this.hasModel() && this.focus(), this._removeDecorationTypes(), this._onDidChangeModel.fire(n), this._postDetachModelCleanup(o), this._contributionsDisposable = this._contributions.onAfterModelAttached();
    } finally {
      this._endUpdate();
    }
  }
  _removeDecorationTypes() {
    if (this._decorationTypeKeysToIds = {}, this._decorationTypeSubtypes) {
      for (const e in this._decorationTypeSubtypes) {
        const t = this._decorationTypeSubtypes[e];
        for (const i in t)
          this._removeDecorationType(e + "-" + i);
      }
      this._decorationTypeSubtypes = {};
    }
  }
  getVisibleRanges() {
    return this._modelData ? this._modelData.viewModel.getVisibleRanges() : [];
  }
  getVisibleRangesPlusViewportAboveBelow() {
    return this._modelData ? this._modelData.viewModel.getVisibleRangesPlusViewportAboveBelow() : [];
  }
  getWhitespaces() {
    return this._modelData ? this._modelData.viewModel.viewLayout.getWhitespaces() : [];
  }
  static _getVerticalOffsetAfterPosition(e, t, i, n) {
    const s = e.model.validatePosition({
      lineNumber: t,
      column: i
    }), o = e.viewModel.coordinatesConverter.convertModelPositionToViewPosition(s);
    return e.viewModel.viewLayout.getVerticalOffsetAfterLineNumber(o.lineNumber, n);
  }
  getTopForLineNumber(e, t = !1) {
    return this._modelData ? Nh._getVerticalOffsetForPosition(this._modelData, e, 1, t) : -1;
  }
  getTopForPosition(e, t) {
    return this._modelData ? Nh._getVerticalOffsetForPosition(this._modelData, e, t, !1) : -1;
  }
  static _getVerticalOffsetForPosition(e, t, i, n = !1) {
    const s = e.model.validatePosition({
      lineNumber: t,
      column: i
    }), o = e.viewModel.coordinatesConverter.convertModelPositionToViewPosition(s);
    return e.viewModel.viewLayout.getVerticalOffsetForLineNumber(o.lineNumber, n);
  }
  getBottomForLineNumber(e, t = !1) {
    return this._modelData ? Nh._getVerticalOffsetAfterPosition(this._modelData, e, 1, t) : -1;
  }
  setHiddenAreas(e, t) {
    var i;
    (i = this._modelData) === null || i === void 0 || i.viewModel.setHiddenAreas(e.map((n) => L.lift(n)), t);
  }
  getVisibleColumnFromPosition(e) {
    if (!this._modelData)
      return e.column;
    const t = this._modelData.model.validatePosition(e), i = this._modelData.model.getOptions().tabSize;
    return Hi.visibleColumnFromColumn(this._modelData.model.getLineContent(t.lineNumber), t.column, i) + 1;
  }
  getPosition() {
    return this._modelData ? this._modelData.viewModel.getPosition() : null;
  }
  setPosition(e, t = "api") {
    if (this._modelData) {
      if (!A.isIPosition(e))
        throw new Error("Invalid arguments");
      this._modelData.viewModel.setSelections(t, [{
        selectionStartLineNumber: e.lineNumber,
        selectionStartColumn: e.column,
        positionLineNumber: e.lineNumber,
        positionColumn: e.column
      }]);
    }
  }
  _sendRevealRange(e, t, i, n) {
    if (!this._modelData)
      return;
    if (!L.isIRange(e))
      throw new Error("Invalid arguments");
    const s = this._modelData.model.validateRange(e), o = this._modelData.viewModel.coordinatesConverter.convertModelRangeToViewRange(s);
    this._modelData.viewModel.revealRange("api", i, o, t, n);
  }
  revealLine(e, t = 0) {
    this._revealLine(e, 0, t);
  }
  revealLineInCenter(e, t = 0) {
    this._revealLine(e, 1, t);
  }
  revealLineInCenterIfOutsideViewport(e, t = 0) {
    this._revealLine(e, 2, t);
  }
  revealLineNearTop(e, t = 0) {
    this._revealLine(e, 5, t);
  }
  _revealLine(e, t, i) {
    if (typeof e != "number")
      throw new Error("Invalid arguments");
    this._sendRevealRange(new L(e, 1, e, 1), t, !1, i);
  }
  revealPosition(e, t = 0) {
    this._revealPosition(e, 0, !0, t);
  }
  revealPositionInCenter(e, t = 0) {
    this._revealPosition(e, 1, !0, t);
  }
  revealPositionInCenterIfOutsideViewport(e, t = 0) {
    this._revealPosition(e, 2, !0, t);
  }
  revealPositionNearTop(e, t = 0) {
    this._revealPosition(e, 5, !0, t);
  }
  _revealPosition(e, t, i, n) {
    if (!A.isIPosition(e))
      throw new Error("Invalid arguments");
    this._sendRevealRange(new L(e.lineNumber, e.column, e.lineNumber, e.column), t, i, n);
  }
  getSelection() {
    return this._modelData ? this._modelData.viewModel.getSelection() : null;
  }
  getSelections() {
    return this._modelData ? this._modelData.viewModel.getSelections() : null;
  }
  setSelection(e, t = "api") {
    const i = ge.isISelection(e), n = L.isIRange(e);
    if (!i && !n)
      throw new Error("Invalid arguments");
    if (i)
      this._setSelectionImpl(e, t);
    else if (n) {
      const s = {
        selectionStartLineNumber: e.startLineNumber,
        selectionStartColumn: e.startColumn,
        positionLineNumber: e.endLineNumber,
        positionColumn: e.endColumn
      };
      this._setSelectionImpl(s, t);
    }
  }
  _setSelectionImpl(e, t) {
    if (!this._modelData)
      return;
    const i = new ge(e.selectionStartLineNumber, e.selectionStartColumn, e.positionLineNumber, e.positionColumn);
    this._modelData.viewModel.setSelections(t, [i]);
  }
  revealLines(e, t, i = 0) {
    this._revealLines(e, t, 0, i);
  }
  revealLinesInCenter(e, t, i = 0) {
    this._revealLines(e, t, 1, i);
  }
  revealLinesInCenterIfOutsideViewport(e, t, i = 0) {
    this._revealLines(e, t, 2, i);
  }
  revealLinesNearTop(e, t, i = 0) {
    this._revealLines(e, t, 5, i);
  }
  _revealLines(e, t, i, n) {
    if (typeof e != "number" || typeof t != "number")
      throw new Error("Invalid arguments");
    this._sendRevealRange(new L(e, 1, t, 1), i, !1, n);
  }
  revealRange(e, t = 0, i = !1, n = !0) {
    this._revealRange(e, i ? 1 : 0, n, t);
  }
  revealRangeInCenter(e, t = 0) {
    this._revealRange(e, 1, !0, t);
  }
  revealRangeInCenterIfOutsideViewport(e, t = 0) {
    this._revealRange(e, 2, !0, t);
  }
  revealRangeNearTop(e, t = 0) {
    this._revealRange(e, 5, !0, t);
  }
  revealRangeNearTopIfOutsideViewport(e, t = 0) {
    this._revealRange(e, 6, !0, t);
  }
  revealRangeAtTop(e, t = 0) {
    this._revealRange(e, 3, !0, t);
  }
  _revealRange(e, t, i, n) {
    if (!L.isIRange(e))
      throw new Error("Invalid arguments");
    this._sendRevealRange(L.lift(e), t, i, n);
  }
  setSelections(e, t = "api", i = 0) {
    if (this._modelData) {
      if (!e || e.length === 0)
        throw new Error("Invalid arguments");
      for (let n = 0, s = e.length; n < s; n++)
        if (!ge.isISelection(e[n]))
          throw new Error("Invalid arguments");
      this._modelData.viewModel.setSelections(t, e, i);
    }
  }
  getContentWidth() {
    return this._modelData ? this._modelData.viewModel.viewLayout.getContentWidth() : -1;
  }
  getScrollWidth() {
    return this._modelData ? this._modelData.viewModel.viewLayout.getScrollWidth() : -1;
  }
  getScrollLeft() {
    return this._modelData ? this._modelData.viewModel.viewLayout.getCurrentScrollLeft() : -1;
  }
  getContentHeight() {
    return this._modelData ? this._modelData.viewModel.viewLayout.getContentHeight() : -1;
  }
  getScrollHeight() {
    return this._modelData ? this._modelData.viewModel.viewLayout.getScrollHeight() : -1;
  }
  getScrollTop() {
    return this._modelData ? this._modelData.viewModel.viewLayout.getCurrentScrollTop() : -1;
  }
  setScrollLeft(e, t = 1) {
    if (this._modelData) {
      if (typeof e != "number")
        throw new Error("Invalid arguments");
      this._modelData.viewModel.viewLayout.setScrollPosition({
        scrollLeft: e
      }, t);
    }
  }
  setScrollTop(e, t = 1) {
    if (this._modelData) {
      if (typeof e != "number")
        throw new Error("Invalid arguments");
      this._modelData.viewModel.viewLayout.setScrollPosition({
        scrollTop: e
      }, t);
    }
  }
  setScrollPosition(e, t = 1) {
    this._modelData && this._modelData.viewModel.viewLayout.setScrollPosition(e, t);
  }
  hasPendingScrollAnimation() {
    return this._modelData ? this._modelData.viewModel.viewLayout.hasPendingScrollAnimation() : !1;
  }
  saveViewState() {
    if (!this._modelData)
      return null;
    const e = this._contributions.saveViewState(), t = this._modelData.viewModel.saveCursorState(), i = this._modelData.viewModel.saveState();
    return {
      cursorState: t,
      viewState: i,
      contributionsState: e
    };
  }
  restoreViewState(e) {
    if (!this._modelData || !this._modelData.hasRealView)
      return;
    const t = e;
    if (t && t.cursorState && t.viewState) {
      const i = t.cursorState;
      Array.isArray(i) ? i.length > 0 && this._modelData.viewModel.restoreCursorState(i) : this._modelData.viewModel.restoreCursorState([i]), this._contributions.restoreViewState(t.contributionsState || {});
      const n = this._modelData.viewModel.reduceRestoreState(t.viewState);
      this._modelData.view.restoreState(n);
    }
  }
  handleInitialized() {
    var e;
    (e = this._getViewModel()) === null || e === void 0 || e.visibleLinesStabilized();
  }
  getContribution(e) {
    return this._contributions.get(e);
  }
  getActions() {
    return Array.from(this._actions.values());
  }
  getSupportedActions() {
    let e = this.getActions();
    return e = e.filter((t) => t.isSupported()), e;
  }
  getAction(e) {
    return this._actions.get(e) || null;
  }
  trigger(e, t, i) {
    i = i || {};
    try {
      switch (this._beginUpdate(), t) {
        case "compositionStart":
          this._startComposition();
          return;
        case "compositionEnd":
          this._endComposition(e);
          return;
        case "type": {
          const s = i;
          this._type(e, s.text || "");
          return;
        }
        case "replacePreviousChar": {
          const s = i;
          this._compositionType(e, s.text || "", s.replaceCharCnt || 0, 0, 0);
          return;
        }
        case "compositionType": {
          const s = i;
          this._compositionType(e, s.text || "", s.replacePrevCharCnt || 0, s.replaceNextCharCnt || 0, s.positionDelta || 0);
          return;
        }
        case "paste": {
          const s = i;
          this._paste(e, s.text || "", s.pasteOnNewLine || !1, s.multicursorText || null, s.mode || null, s.clipboardEvent);
          return;
        }
        case "cut":
          this._cut(e);
          return;
      }
      const n = this.getAction(t);
      if (n) {
        Promise.resolve(n.run(i)).then(void 0, He);
        return;
      }
      if (!this._modelData || this._triggerEditorCommand(e, t, i))
        return;
      this._triggerCommand(t, i);
    } finally {
      this._endUpdate();
    }
  }
  _triggerCommand(e, t) {
    this._commandService.executeCommand(e, t);
  }
  _startComposition() {
    this._modelData && (this._modelData.viewModel.startComposition(), this._onDidCompositionStart.fire());
  }
  _endComposition(e) {
    this._modelData && (this._modelData.viewModel.endComposition(e), this._onDidCompositionEnd.fire());
  }
  _type(e, t) {
    !this._modelData || t.length === 0 || (e === "keyboard" && this._onWillType.fire(t), this._modelData.viewModel.type(t, e), e === "keyboard" && this._onDidType.fire(t));
  }
  _compositionType(e, t, i, n, s) {
    this._modelData && this._modelData.viewModel.compositionType(t, i, n, s, e);
  }
  _paste(e, t, i, n, s, o) {
    if (!this._modelData)
      return;
    const a = this._modelData.viewModel, l = a.getSelection().getStartPosition();
    a.paste(t, i, n, e);
    const d = a.getSelection().getStartPosition();
    e === "keyboard" && this._onDidPaste.fire({
      clipboardEvent: o,
      range: new L(l.lineNumber, l.column, d.lineNumber, d.column),
      languageId: s
    });
  }
  _cut(e) {
    this._modelData && this._modelData.viewModel.cut(e);
  }
  _triggerEditorCommand(e, t, i) {
    const n = ff.getEditorCommand(t);
    return n ? (i = i || {}, i.source = e, this._instantiationService.invokeFunction((s) => {
      Promise.resolve(n.runEditorCommand(s, this, i)).then(void 0, He);
    }), !0) : !1;
  }
  _getViewModel() {
    return this._modelData ? this._modelData.viewModel : null;
  }
  pushUndoStop() {
    return !this._modelData || this._configuration.options.get(
      91
      /* EditorOption.readOnly */
    ) ? !1 : (this._modelData.model.pushStackElement(), !0);
  }
  popUndoStop() {
    return !this._modelData || this._configuration.options.get(
      91
      /* EditorOption.readOnly */
    ) ? !1 : (this._modelData.model.popStackElement(), !0);
  }
  executeEdits(e, t, i) {
    if (!this._modelData || this._configuration.options.get(
      91
      /* EditorOption.readOnly */
    ))
      return !1;
    let n;
    return i ? Array.isArray(i) ? n = () => i : n = i : n = () => null, this._modelData.viewModel.executeEdits(e, t, n), !0;
  }
  executeCommand(e, t) {
    this._modelData && this._modelData.viewModel.executeCommand(t, e);
  }
  executeCommands(e, t) {
    this._modelData && this._modelData.viewModel.executeCommands(t, e);
  }
  createDecorationsCollection(e) {
    return new lJ(this, e);
  }
  changeDecorations(e) {
    return this._modelData ? this._modelData.model.changeDecorations(e, this._id) : null;
  }
  getLineDecorations(e) {
    return this._modelData ? this._modelData.model.getLineDecorations(e, this._id, dS(this._configuration.options)) : null;
  }
  getDecorationsInRange(e) {
    return this._modelData ? this._modelData.model.getDecorationsInRange(e, this._id, dS(this._configuration.options)) : null;
  }
  /**
   * @deprecated
   */
  deltaDecorations(e, t) {
    return this._modelData ? e.length === 0 && t.length === 0 ? e : this._modelData.model.deltaDecorations(e, t, this._id) : [];
  }
  removeDecorations(e) {
    !this._modelData || e.length === 0 || this._modelData.model.changeDecorations((t) => {
      t.deltaDecorations(e, []);
    });
  }
  removeDecorationsByType(e) {
    const t = this._decorationTypeKeysToIds[e];
    t && this.changeDecorations((i) => i.deltaDecorations(t, [])), this._decorationTypeKeysToIds.hasOwnProperty(e) && delete this._decorationTypeKeysToIds[e], this._decorationTypeSubtypes.hasOwnProperty(e) && delete this._decorationTypeSubtypes[e];
  }
  getLayoutInfo() {
    return this._configuration.options.get(
      145
      /* EditorOption.layoutInfo */
    );
  }
  createOverviewRuler(e) {
    return !this._modelData || !this._modelData.hasRealView ? null : this._modelData.view.createOverviewRuler(e);
  }
  getContainerDomNode() {
    return this._domElement;
  }
  getDomNode() {
    return !this._modelData || !this._modelData.hasRealView ? null : this._modelData.view.domNode.domNode;
  }
  delegateVerticalScrollbarPointerDown(e) {
    !this._modelData || !this._modelData.hasRealView || this._modelData.view.delegateVerticalScrollbarPointerDown(e);
  }
  delegateScrollFromMouseWheelEvent(e) {
    !this._modelData || !this._modelData.hasRealView || this._modelData.view.delegateScrollFromMouseWheelEvent(e);
  }
  layout(e, t = !1) {
    this._configuration.observeContainer(e), t || this.render();
  }
  focus() {
    !this._modelData || !this._modelData.hasRealView || this._modelData.view.focus();
  }
  hasTextFocus() {
    return !this._modelData || !this._modelData.hasRealView ? !1 : this._modelData.view.isFocused();
  }
  hasWidgetFocus() {
    return this._focusTracker && this._focusTracker.hasFocus();
  }
  addContentWidget(e) {
    const t = {
      widget: e,
      position: e.getPosition()
    };
    this._contentWidgets.hasOwnProperty(e.getId()) && console.warn("Overwriting a content widget with the same id:" + e.getId()), this._contentWidgets[e.getId()] = t, this._modelData && this._modelData.hasRealView && this._modelData.view.addContentWidget(t);
  }
  layoutContentWidget(e) {
    const t = e.getId();
    if (this._contentWidgets.hasOwnProperty(t)) {
      const i = this._contentWidgets[t];
      i.position = e.getPosition(), this._modelData && this._modelData.hasRealView && this._modelData.view.layoutContentWidget(i);
    }
  }
  removeContentWidget(e) {
    const t = e.getId();
    if (this._contentWidgets.hasOwnProperty(t)) {
      const i = this._contentWidgets[t];
      delete this._contentWidgets[t], this._modelData && this._modelData.hasRealView && this._modelData.view.removeContentWidget(i);
    }
  }
  addOverlayWidget(e) {
    const t = {
      widget: e,
      position: e.getPosition()
    };
    this._overlayWidgets.hasOwnProperty(e.getId()) && console.warn("Overwriting an overlay widget with the same id."), this._overlayWidgets[e.getId()] = t, this._modelData && this._modelData.hasRealView && this._modelData.view.addOverlayWidget(t);
  }
  layoutOverlayWidget(e) {
    const t = e.getId();
    if (this._overlayWidgets.hasOwnProperty(t)) {
      const i = this._overlayWidgets[t];
      i.position = e.getPosition(), this._modelData && this._modelData.hasRealView && this._modelData.view.layoutOverlayWidget(i);
    }
  }
  removeOverlayWidget(e) {
    const t = e.getId();
    if (this._overlayWidgets.hasOwnProperty(t)) {
      const i = this._overlayWidgets[t];
      delete this._overlayWidgets[t], this._modelData && this._modelData.hasRealView && this._modelData.view.removeOverlayWidget(i);
    }
  }
  addGlyphMarginWidget(e) {
    const t = {
      widget: e,
      position: e.getPosition()
    };
    this._glyphMarginWidgets.hasOwnProperty(e.getId()) && console.warn("Overwriting a glyph margin widget with the same id."), this._glyphMarginWidgets[e.getId()] = t, this._modelData && this._modelData.hasRealView && this._modelData.view.addGlyphMarginWidget(t);
  }
  layoutGlyphMarginWidget(e) {
    const t = e.getId();
    if (this._glyphMarginWidgets.hasOwnProperty(t)) {
      const i = this._glyphMarginWidgets[t];
      i.position = e.getPosition(), this._modelData && this._modelData.hasRealView && this._modelData.view.layoutGlyphMarginWidget(i);
    }
  }
  removeGlyphMarginWidget(e) {
    const t = e.getId();
    if (this._glyphMarginWidgets.hasOwnProperty(t)) {
      const i = this._glyphMarginWidgets[t];
      delete this._glyphMarginWidgets[t], this._modelData && this._modelData.hasRealView && this._modelData.view.removeGlyphMarginWidget(i);
    }
  }
  changeViewZones(e) {
    !this._modelData || !this._modelData.hasRealView || this._modelData.view.change(e);
  }
  getTargetAtClientPoint(e, t) {
    return !this._modelData || !this._modelData.hasRealView ? null : this._modelData.view.getTargetAtClientPoint(e, t);
  }
  getScrolledVisiblePosition(e) {
    if (!this._modelData || !this._modelData.hasRealView)
      return null;
    const t = this._modelData.model.validatePosition(e), i = this._configuration.options, n = i.get(
      145
      /* EditorOption.layoutInfo */
    ), s = Nh._getVerticalOffsetForPosition(this._modelData, t.lineNumber, t.column) - this.getScrollTop(), o = this._modelData.view.getOffsetForColumn(t.lineNumber, t.column) + n.glyphMarginWidth + n.lineNumbersWidth + n.decorationsWidth - this.getScrollLeft();
    return {
      top: s,
      left: o,
      height: i.get(
        67
        /* EditorOption.lineHeight */
      )
    };
  }
  getOffsetForColumn(e, t) {
    return !this._modelData || !this._modelData.hasRealView ? -1 : this._modelData.view.getOffsetForColumn(e, t);
  }
  render(e = !1) {
    !this._modelData || !this._modelData.hasRealView || this._modelData.viewModel.batchEvents(() => {
      this._modelData.view.render(!0, e);
    });
  }
  setAriaOptions(e) {
    !this._modelData || !this._modelData.hasRealView || this._modelData.view.setAriaOptions(e);
  }
  applyFontInfo(e) {
    _n(e, this._configuration.options.get(
      50
      /* EditorOption.fontInfo */
    ));
  }
  setBanner(e, t) {
    this._bannerDomNode && this._domElement.contains(this._bannerDomNode) && this._domElement.removeChild(this._bannerDomNode), this._bannerDomNode = e, this._configuration.setReservedHeight(e ? t : 0), this._bannerDomNode && this._domElement.prepend(this._bannerDomNode);
  }
  _attachModel(e) {
    if (!e) {
      this._modelData = null;
      return;
    }
    const t = [];
    this._domElement.setAttribute("data-mode-id", e.getLanguageId()), this._configuration.setIsDominatedByLongLines(e.isDominatedByLongLines()), this._configuration.setModelLineCount(e.getLineCount());
    const i = e.onBeforeAttached(), n = new QX(this._id, this._configuration, e, A1.create(we(this._domElement)), K1.create(this._configuration.options), (a) => Us(we(this._domElement), a), this.languageConfigurationService, this._themeService, i);
    t.push(e.onWillDispose(() => this.setModel(null))), t.push(n.onEvent((a) => {
      switch (a.kind) {
        case 0:
          this._onDidContentSizeChange.fire(a);
          break;
        case 1:
          this._editorTextFocus.setValue(a.hasFocus);
          break;
        case 2:
          this._onDidScrollChange.fire(a);
          break;
        case 3:
          this._onDidChangeViewZones.fire();
          break;
        case 4:
          this._onDidChangeHiddenAreas.fire();
          break;
        case 5:
          this._onDidAttemptReadOnlyEdit.fire();
          break;
        case 6: {
          if (a.reachedMaxCursorCount) {
            const h = this.getOption(
              80
              /* EditorOption.multiCursorLimit */
            ), u = p("cursors.maximum", "The number of cursors has been limited to {0}. Consider using [find and replace](https://code.visualstudio.com/docs/editor/codebasics#_find-and-replace) for larger changes or increase the editor multi cursor limit setting.", h);
            this._notificationService.prompt(F0.Warning, u, [
              {
                label: "Find and Replace",
                run: () => {
                  this._commandService.executeCommand("editor.action.startFindReplaceAction");
                }
              },
              {
                label: p("goToSetting", "Increase Multi Cursor Limit"),
                run: () => {
                  this._commandService.executeCommand("workbench.action.openSettings2", {
                    query: "editor.multiCursorLimit"
                  });
                }
              }
            ]);
          }
          const l = [];
          for (let h = 0, u = a.selections.length; h < u; h++)
            l[h] = a.selections[h].getPosition();
          const d = {
            position: l[0],
            secondaryPositions: l.slice(1),
            reason: a.reason,
            source: a.source
          };
          this._onDidChangeCursorPosition.fire(d);
          const c = {
            selection: a.selections[0],
            secondarySelections: a.selections.slice(1),
            modelVersionId: a.modelVersionId,
            oldSelections: a.oldSelections,
            oldModelVersionId: a.oldModelVersionId,
            source: a.source,
            reason: a.reason
          };
          this._onDidChangeCursorSelection.fire(c);
          break;
        }
        case 7:
          this._onDidChangeModelDecorations.fire(a.event);
          break;
        case 8:
          this._domElement.setAttribute("data-mode-id", e.getLanguageId()), this._onDidChangeModelLanguage.fire(a.event);
          break;
        case 9:
          this._onDidChangeModelLanguageConfiguration.fire(a.event);
          break;
        case 10:
          this._onDidChangeModelContent.fire(a.event);
          break;
        case 11:
          this._onDidChangeModelOptions.fire(a.event);
          break;
        case 12:
          this._onDidChangeModelTokens.fire(a.event);
          break;
      }
    }));
    const [s, o] = this._createView(n);
    if (o) {
      this._domElement.appendChild(s.domNode.domNode);
      let a = Object.keys(this._contentWidgets);
      for (let l = 0, d = a.length; l < d; l++) {
        const c = a[l];
        s.addContentWidget(this._contentWidgets[c]);
      }
      a = Object.keys(this._overlayWidgets);
      for (let l = 0, d = a.length; l < d; l++) {
        const c = a[l];
        s.addOverlayWidget(this._overlayWidgets[c]);
      }
      a = Object.keys(this._glyphMarginWidgets);
      for (let l = 0, d = a.length; l < d; l++) {
        const c = a[l];
        s.addGlyphMarginWidget(this._glyphMarginWidgets[c]);
      }
      s.render(!1, !0), s.domNode.domNode.setAttribute("data-uri", e.uri.toString());
    }
    this._modelData = new sJ(e, n, s, o, t, i);
  }
  _createView(e) {
    let t;
    this.isSimpleWidget ? t = {
      paste: (s, o, a, l) => {
        this._paste("keyboard", s, o, a, l);
      },
      type: (s) => {
        this._type("keyboard", s);
      },
      compositionType: (s, o, a, l) => {
        this._compositionType("keyboard", s, o, a, l);
      },
      startComposition: () => {
        this._startComposition();
      },
      endComposition: () => {
        this._endComposition("keyboard");
      },
      cut: () => {
        this._cut("keyboard");
      }
    } : t = {
      paste: (s, o, a, l) => {
        const d = { text: s, pasteOnNewLine: o, multicursorText: a, mode: l };
        this._commandService.executeCommand("paste", d);
      },
      type: (s) => {
        const o = { text: s };
        this._commandService.executeCommand("type", o);
      },
      compositionType: (s, o, a, l) => {
        if (a || l) {
          const d = { text: s, replacePrevCharCnt: o, replaceNextCharCnt: a, positionDelta: l };
          this._commandService.executeCommand("compositionType", d);
        } else {
          const d = { text: s, replaceCharCnt: o };
          this._commandService.executeCommand("replacePreviousChar", d);
        }
      },
      startComposition: () => {
        this._commandService.executeCommand("compositionStart", {});
      },
      endComposition: () => {
        this._commandService.executeCommand("compositionEnd", {});
      },
      cut: () => {
        this._commandService.executeCommand("cut", {});
      }
    };
    const i = new M0(e.coordinatesConverter);
    return i.onKeyDown = (s) => this._onKeyDown.fire(s), i.onKeyUp = (s) => this._onKeyUp.fire(s), i.onContextMenu = (s) => this._onContextMenu.fire(s), i.onMouseMove = (s) => this._onMouseMove.fire(s), i.onMouseLeave = (s) => this._onMouseLeave.fire(s), i.onMouseDown = (s) => this._onMouseDown.fire(s), i.onMouseUp = (s) => this._onMouseUp.fire(s), i.onMouseDrag = (s) => this._onMouseDrag.fire(s), i.onMouseDrop = (s) => this._onMouseDrop.fire(s), i.onMouseDropCanceled = (s) => this._onMouseDropCanceled.fire(s), i.onMouseWheel = (s) => this._onMouseWheel.fire(s), [new tI(t, this._configuration, this._themeService.getColorTheme(), e, i, this._overflowWidgetsDomNode, this._instantiationService), !0];
  }
  _postDetachModelCleanup(e) {
    e == null || e.removeAllDecorationsWithOwnerId(this._id);
  }
  _detachModel() {
    var e;
    if ((e = this._contributionsDisposable) === null || e === void 0 || e.dispose(), this._contributionsDisposable = void 0, !this._modelData)
      return null;
    const t = this._modelData.model, i = this._modelData.hasRealView ? this._modelData.view.domNode.domNode : null;
    return this._modelData.dispose(), this._modelData = null, this._domElement.removeAttribute("data-mode-id"), i && this._domElement.contains(i) && this._domElement.removeChild(i), this._bannerDomNode && this._domElement.contains(this._bannerDomNode) && this._domElement.removeChild(this._bannerDomNode), t;
  }
  _removeDecorationType(e) {
    this._codeEditorService.removeDecorationType(e);
  }
  hasModel() {
    return this._modelData !== null;
  }
  showDropIndicatorAt(e) {
    const t = [{
      range: new L(e.lineNumber, e.column, e.lineNumber, e.column),
      options: Nh.dropIntoEditorDecorationOptions
    }];
    this._dropIntoEditorDecorations.set(t), this.revealPosition(
      e,
      1
      /* editorCommon.ScrollType.Immediate */
    );
  }
  removeDropIndicator() {
    this._dropIntoEditorDecorations.clear();
  }
  setContextValue(e, t) {
    this._contextKeyService.createKey(e, t);
  }
  _beginUpdate() {
    this._updateCounter++, this._updateCounter === 1 && this._onBeginUpdate.fire();
  }
  _endUpdate() {
    this._updateCounter--, this._updateCounter === 0 && this._onEndUpdate.fire();
  }
};
Qf.dropIntoEditorDecorationOptions = Fe.register({
  description: "workbench-dnd-target",
  className: "dnd-target"
});
Qf = Nh = iJ([
  vl(3, be),
  vl(4, ht),
  vl(5, $t),
  vl(6, De),
  vl(7, $i),
  vl(8, xi),
  vl(9, qs),
  vl(10, Ot),
  vl(11, he)
], Qf);
let nJ = 0, sJ = class {
  constructor(e, t, i, n, s, o) {
    this.model = e, this.viewModel = t, this.view = i, this.hasRealView = n, this.listenersToRemove = s, this.attachedView = o;
  }
  dispose() {
    zt(this.listenersToRemove), this.model.onBeforeDetached(this.attachedView), this.hasRealView && this.view.dispose(), this.viewModel.dispose();
  }
};
class mO extends P {
  constructor(e) {
    super(), this._emitterOptions = e, this._onDidChangeToTrue = this._register(new R(this._emitterOptions)), this.onDidChangeToTrue = this._onDidChangeToTrue.event, this._onDidChangeToFalse = this._register(new R(this._emitterOptions)), this.onDidChangeToFalse = this._onDidChangeToFalse.event, this._value = 0;
  }
  setValue(e) {
    const t = e ? 2 : 1;
    this._value !== t && (this._value = t, this._value === 2 ? this._onDidChangeToTrue.fire() : this._value === 1 && this._onDidChangeToFalse.fire());
  }
}
class Wn extends R {
  constructor(e, t) {
    super({ deliveryQueue: t }), this._contributions = e;
  }
  fire(e) {
    this._contributions.onBeforeInteractionEvent(), super.fire(e);
  }
}
class oJ extends P {
  constructor(e, t) {
    super(), this._editor = e, t.createKey("editorId", e.getId()), this._editorSimpleInput = x.editorSimpleInput.bindTo(t), this._editorFocus = x.focus.bindTo(t), this._textInputFocus = x.textInputFocus.bindTo(t), this._editorTextFocus = x.editorTextFocus.bindTo(t), this._tabMovesFocus = x.tabMovesFocus.bindTo(t), this._editorReadonly = x.readOnly.bindTo(t), this._inDiffEditor = x.inDiffEditor.bindTo(t), this._editorColumnSelection = x.columnSelection.bindTo(t), this._hasMultipleSelections = x.hasMultipleSelections.bindTo(t), this._hasNonEmptySelection = x.hasNonEmptySelection.bindTo(t), this._canUndo = x.canUndo.bindTo(t), this._canRedo = x.canRedo.bindTo(t), this._register(this._editor.onDidChangeConfiguration(() => this._updateFromConfig())), this._register(this._editor.onDidChangeCursorSelection(() => this._updateFromSelection())), this._register(this._editor.onDidFocusEditorWidget(() => this._updateFromFocus())), this._register(this._editor.onDidBlurEditorWidget(() => this._updateFromFocus())), this._register(this._editor.onDidFocusEditorText(() => this._updateFromFocus())), this._register(this._editor.onDidBlurEditorText(() => this._updateFromFocus())), this._register(this._editor.onDidChangeModel(() => this._updateFromModel())), this._register(this._editor.onDidChangeConfiguration(() => this._updateFromModel())), this._register(Uf.onDidChangeTabFocus((i) => this._tabMovesFocus.set(i))), this._updateFromConfig(), this._updateFromSelection(), this._updateFromFocus(), this._updateFromModel(), this._editorSimpleInput.set(this._editor.isSimpleWidget);
  }
  _updateFromConfig() {
    const e = this._editor.getOptions();
    this._tabMovesFocus.set(Uf.getTabFocusMode()), this._editorReadonly.set(e.get(
      91
      /* EditorOption.readOnly */
    )), this._inDiffEditor.set(e.get(
      61
      /* EditorOption.inDiffEditor */
    )), this._editorColumnSelection.set(e.get(
      22
      /* EditorOption.columnSelection */
    ));
  }
  _updateFromSelection() {
    const e = this._editor.getSelections();
    e ? (this._hasMultipleSelections.set(e.length > 1), this._hasNonEmptySelection.set(e.some((t) => !t.isEmpty()))) : (this._hasMultipleSelections.reset(), this._hasNonEmptySelection.reset());
  }
  _updateFromFocus() {
    this._editorFocus.set(this._editor.hasWidgetFocus() && !this._editor.isSimpleWidget), this._editorTextFocus.set(this._editor.hasTextFocus() && !this._editor.isSimpleWidget), this._textInputFocus.set(this._editor.hasTextFocus());
  }
  _updateFromModel() {
    const e = this._editor.getModel();
    this._canUndo.set(!!(e && e.canUndo())), this._canRedo.set(!!(e && e.canRedo()));
  }
}
class rJ extends P {
  constructor(e, t, i) {
    super(), this._editor = e, this._contextKeyService = t, this._languageFeaturesService = i, this._langId = x.languageId.bindTo(t), this._hasCompletionItemProvider = x.hasCompletionItemProvider.bindTo(t), this._hasCodeActionsProvider = x.hasCodeActionsProvider.bindTo(t), this._hasCodeLensProvider = x.hasCodeLensProvider.bindTo(t), this._hasDefinitionProvider = x.hasDefinitionProvider.bindTo(t), this._hasDeclarationProvider = x.hasDeclarationProvider.bindTo(t), this._hasImplementationProvider = x.hasImplementationProvider.bindTo(t), this._hasTypeDefinitionProvider = x.hasTypeDefinitionProvider.bindTo(t), this._hasHoverProvider = x.hasHoverProvider.bindTo(t), this._hasDocumentHighlightProvider = x.hasDocumentHighlightProvider.bindTo(t), this._hasDocumentSymbolProvider = x.hasDocumentSymbolProvider.bindTo(t), this._hasReferenceProvider = x.hasReferenceProvider.bindTo(t), this._hasRenameProvider = x.hasRenameProvider.bindTo(t), this._hasSignatureHelpProvider = x.hasSignatureHelpProvider.bindTo(t), this._hasInlayHintsProvider = x.hasInlayHintsProvider.bindTo(t), this._hasDocumentFormattingProvider = x.hasDocumentFormattingProvider.bindTo(t), this._hasDocumentSelectionFormattingProvider = x.hasDocumentSelectionFormattingProvider.bindTo(t), this._hasMultipleDocumentFormattingProvider = x.hasMultipleDocumentFormattingProvider.bindTo(t), this._hasMultipleDocumentSelectionFormattingProvider = x.hasMultipleDocumentSelectionFormattingProvider.bindTo(t), this._isInEmbeddedEditor = x.isInEmbeddedEditor.bindTo(t);
    const n = () => this._update();
    this._register(e.onDidChangeModel(n)), this._register(e.onDidChangeModelLanguage(n)), this._register(i.completionProvider.onDidChange(n)), this._register(i.codeActionProvider.onDidChange(n)), this._register(i.codeLensProvider.onDidChange(n)), this._register(i.definitionProvider.onDidChange(n)), this._register(i.declarationProvider.onDidChange(n)), this._register(i.implementationProvider.onDidChange(n)), this._register(i.typeDefinitionProvider.onDidChange(n)), this._register(i.hoverProvider.onDidChange(n)), this._register(i.documentHighlightProvider.onDidChange(n)), this._register(i.documentSymbolProvider.onDidChange(n)), this._register(i.referenceProvider.onDidChange(n)), this._register(i.renameProvider.onDidChange(n)), this._register(i.documentFormattingEditProvider.onDidChange(n)), this._register(i.documentRangeFormattingEditProvider.onDidChange(n)), this._register(i.signatureHelpProvider.onDidChange(n)), this._register(i.inlayHintsProvider.onDidChange(n)), n();
  }
  dispose() {
    super.dispose();
  }
  reset() {
    this._contextKeyService.bufferChangeEvents(() => {
      this._langId.reset(), this._hasCompletionItemProvider.reset(), this._hasCodeActionsProvider.reset(), this._hasCodeLensProvider.reset(), this._hasDefinitionProvider.reset(), this._hasDeclarationProvider.reset(), this._hasImplementationProvider.reset(), this._hasTypeDefinitionProvider.reset(), this._hasHoverProvider.reset(), this._hasDocumentHighlightProvider.reset(), this._hasDocumentSymbolProvider.reset(), this._hasReferenceProvider.reset(), this._hasRenameProvider.reset(), this._hasDocumentFormattingProvider.reset(), this._hasDocumentSelectionFormattingProvider.reset(), this._hasSignatureHelpProvider.reset(), this._isInEmbeddedEditor.reset();
    });
  }
  _update() {
    const e = this._editor.getModel();
    if (!e) {
      this.reset();
      return;
    }
    this._contextKeyService.bufferChangeEvents(() => {
      this._langId.set(e.getLanguageId()), this._hasCompletionItemProvider.set(this._languageFeaturesService.completionProvider.has(e)), this._hasCodeActionsProvider.set(this._languageFeaturesService.codeActionProvider.has(e)), this._hasCodeLensProvider.set(this._languageFeaturesService.codeLensProvider.has(e)), this._hasDefinitionProvider.set(this._languageFeaturesService.definitionProvider.has(e)), this._hasDeclarationProvider.set(this._languageFeaturesService.declarationProvider.has(e)), this._hasImplementationProvider.set(this._languageFeaturesService.implementationProvider.has(e)), this._hasTypeDefinitionProvider.set(this._languageFeaturesService.typeDefinitionProvider.has(e)), this._hasHoverProvider.set(this._languageFeaturesService.hoverProvider.has(e)), this._hasDocumentHighlightProvider.set(this._languageFeaturesService.documentHighlightProvider.has(e)), this._hasDocumentSymbolProvider.set(this._languageFeaturesService.documentSymbolProvider.has(e)), this._hasReferenceProvider.set(this._languageFeaturesService.referenceProvider.has(e)), this._hasRenameProvider.set(this._languageFeaturesService.renameProvider.has(e)), this._hasSignatureHelpProvider.set(this._languageFeaturesService.signatureHelpProvider.has(e)), this._hasInlayHintsProvider.set(this._languageFeaturesService.inlayHintsProvider.has(e)), this._hasDocumentFormattingProvider.set(this._languageFeaturesService.documentFormattingEditProvider.has(e) || this._languageFeaturesService.documentRangeFormattingEditProvider.has(e)), this._hasDocumentSelectionFormattingProvider.set(this._languageFeaturesService.documentRangeFormattingEditProvider.has(e)), this._hasMultipleDocumentFormattingProvider.set(this._languageFeaturesService.documentFormattingEditProvider.all(e).length + this._languageFeaturesService.documentRangeFormattingEditProvider.all(e).length > 1), this._hasMultipleDocumentSelectionFormattingProvider.set(this._languageFeaturesService.documentRangeFormattingEditProvider.all(e).length > 1), this._isInEmbeddedEditor.set(e.uri.scheme === Ne.walkThroughSnippet || e.uri.scheme === Ne.vscodeChatCodeBlock);
    });
  }
}
class aJ extends P {
  constructor(e, t) {
    super(), this._onChange = this._register(new R()), this.onChange = this._onChange.event, this._hadFocus = void 0, this._hasDomElementFocus = !1, this._domFocusTracker = this._register(Xr(e)), this._overflowWidgetsDomNodeHasFocus = !1, this._register(this._domFocusTracker.onDidFocus(() => {
      this._hasDomElementFocus = !0, this._update();
    })), this._register(this._domFocusTracker.onDidBlur(() => {
      this._hasDomElementFocus = !1, this._update();
    })), t && (this._overflowWidgetsDomNode = this._register(Xr(t)), this._register(this._overflowWidgetsDomNode.onDidFocus(() => {
      this._overflowWidgetsDomNodeHasFocus = !0, this._update();
    })), this._register(this._overflowWidgetsDomNode.onDidBlur(() => {
      this._overflowWidgetsDomNodeHasFocus = !1, this._update();
    })));
  }
  _update() {
    const e = this._hasDomElementFocus || this._overflowWidgetsDomNodeHasFocus;
    this._hadFocus !== e && (this._hadFocus = e, this._onChange.fire(void 0));
  }
  hasFocus() {
    var e;
    return (e = this._hadFocus) !== null && e !== void 0 ? e : !1;
  }
}
class lJ {
  get length() {
    return this._decorationIds.length;
  }
  constructor(e, t) {
    this._editor = e, this._decorationIds = [], this._isChangingDecorations = !1, Array.isArray(t) && t.length > 0 && this.set(t);
  }
  onDidChange(e, t, i) {
    return this._editor.onDidChangeModelDecorations((n) => {
      this._isChangingDecorations || e.call(t, n);
    }, i);
  }
  getRange(e) {
    return !this._editor.hasModel() || e >= this._decorationIds.length ? null : this._editor.getModel().getDecorationRange(this._decorationIds[e]);
  }
  getRanges() {
    if (!this._editor.hasModel())
      return [];
    const e = this._editor.getModel(), t = [];
    for (const i of this._decorationIds) {
      const n = e.getDecorationRange(i);
      n && t.push(n);
    }
    return t;
  }
  has(e) {
    return this._decorationIds.includes(e.id);
  }
  clear() {
    this._decorationIds.length !== 0 && this.set([]);
  }
  set(e) {
    try {
      this._isChangingDecorations = !0, this._editor.changeDecorations((t) => {
        this._decorationIds = t.deltaDecorations(this._decorationIds, e);
      });
    } finally {
      this._isChangingDecorations = !1;
    }
    return this._decorationIds;
  }
  append(e) {
    let t = [];
    try {
      this._isChangingDecorations = !0, this._editor.changeDecorations((i) => {
        t = i.deltaDecorations([], e), this._decorationIds = this._decorationIds.concat(t);
      });
    } finally {
      this._isChangingDecorations = !1;
    }
    return t;
  }
}
const dJ = encodeURIComponent("<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 6 3' enable-background='new 0 0 6 3' height='3' width='6'><g fill='"), cJ = encodeURIComponent("'><polygon points='5.5,0 2.5,3 1.1,3 4.1,0'/><polygon points='4,0 6,2 6,0.6 5.4,0'/><polygon points='0,2 1,3 2.4,3 0,0.6'/></g></svg>");
function ck(r) {
  return dJ + encodeURIComponent(r.toString()) + cJ;
}
const hJ = encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" height="3" width="12"><g fill="'), uJ = encodeURIComponent('"><circle cx="1" cy="1" r="1"/><circle cx="5" cy="1" r="1"/><circle cx="9" cy="1" r="1"/></g></svg>');
function gJ(r) {
  return hJ + encodeURIComponent(r.toString()) + uJ;
}
Ho((r, e) => {
  const t = r.getColor(Va);
  t && e.addRule(`.monaco-editor .squiggly-error { background: url("data:image/svg+xml,${ck(t)}") repeat-x bottom left; }`);
  const i = r.getColor(Kn);
  i && e.addRule(`.monaco-editor .squiggly-warning { background: url("data:image/svg+xml,${ck(i)}") repeat-x bottom left; }`);
  const n = r.getColor(ws);
  n && e.addRule(`.monaco-editor .squiggly-info { background: url("data:image/svg+xml,${ck(n)}") repeat-x bottom left; }`);
  const s = r.getColor(SG);
  s && e.addRule(`.monaco-editor .squiggly-hint { background: url("data:image/svg+xml,${gJ(s)}") no-repeat bottom left; }`);
  const o = r.getColor(G7);
  o && e.addRule(`.monaco-editor.showUnused .squiggly-inline-unnecessary { opacity: ${o.rgba.a}; }`);
});
var fJ = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, pJ = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
let vI = class extends P {
  constructor(e) {
    super(), this._themeService = e, this._onWillCreateCodeEditor = this._register(new R()), this._onCodeEditorAdd = this._register(new R()), this.onCodeEditorAdd = this._onCodeEditorAdd.event, this._onCodeEditorRemove = this._register(new R()), this.onCodeEditorRemove = this._onCodeEditorRemove.event, this._onWillCreateDiffEditor = this._register(new R()), this._onDiffEditorAdd = this._register(new R()), this.onDiffEditorAdd = this._onDiffEditorAdd.event, this._onDiffEditorRemove = this._register(new R()), this.onDiffEditorRemove = this._onDiffEditorRemove.event, this._decorationOptionProviders = /* @__PURE__ */ new Map(), this._codeEditorOpenHandlers = new Ps(), this._modelProperties = /* @__PURE__ */ new Map(), this._codeEditors = /* @__PURE__ */ Object.create(null), this._diffEditors = /* @__PURE__ */ Object.create(null), this._globalStyleSheet = null;
  }
  willCreateCodeEditor() {
    this._onWillCreateCodeEditor.fire();
  }
  addCodeEditor(e) {
    this._codeEditors[e.getId()] = e, this._onCodeEditorAdd.fire(e);
  }
  removeCodeEditor(e) {
    delete this._codeEditors[e.getId()] && this._onCodeEditorRemove.fire(e);
  }
  listCodeEditors() {
    return Object.keys(this._codeEditors).map((e) => this._codeEditors[e]);
  }
  willCreateDiffEditor() {
    this._onWillCreateDiffEditor.fire();
  }
  addDiffEditor(e) {
    this._diffEditors[e.getId()] = e, this._onDiffEditorAdd.fire(e);
  }
  listDiffEditors() {
    return Object.keys(this._diffEditors).map((e) => this._diffEditors[e]);
  }
  getFocusedCodeEditor() {
    let e = null;
    const t = this.listCodeEditors();
    for (const i of t) {
      if (i.hasTextFocus())
        return i;
      i.hasWidgetFocus() && (e = i);
    }
    return e;
  }
  removeDecorationType(e) {
    const t = this._decorationOptionProviders.get(e);
    t && (t.refCount--, t.refCount <= 0 && (this._decorationOptionProviders.delete(e), t.dispose(), this.listCodeEditors().forEach((i) => i.removeDecorationsByType(e))));
  }
  setModelProperty(e, t, i) {
    const n = e.toString();
    let s;
    this._modelProperties.has(n) ? s = this._modelProperties.get(n) : (s = /* @__PURE__ */ new Map(), this._modelProperties.set(n, s)), s.set(t, i);
  }
  getModelProperty(e, t) {
    const i = e.toString();
    if (this._modelProperties.has(i))
      return this._modelProperties.get(i).get(t);
  }
  async openCodeEditor(e, t, i) {
    for (const n of this._codeEditorOpenHandlers) {
      const s = await n(e, t, i);
      if (s !== null)
        return s;
    }
    return null;
  }
  registerCodeEditorOpenHandler(e) {
    const t = this._codeEditorOpenHandlers.unshift(e);
    return Se(t);
  }
};
vI = fJ([
  pJ(0, $i)
], vI);
var mJ = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, _O = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
let PS = class extends vI {
  constructor(e, t) {
    super(t), this._register(this.onCodeEditorAdd(() => this._checkContextKey())), this._register(this.onCodeEditorRemove(() => this._checkContextKey())), this._editorIsOpen = e.createKey("editorIsOpen", !1), this._activeCodeEditor = null, this._register(this.registerCodeEditorOpenHandler(async (i, n, s) => n ? this.doOpenEditor(n, i) : null));
  }
  _checkContextKey() {
    let e = !1;
    for (const t of this.listCodeEditors())
      if (!t.isSimpleWidget) {
        e = !0;
        break;
      }
    this._editorIsOpen.set(e);
  }
  setActiveCodeEditor(e) {
    this._activeCodeEditor = e;
  }
  getActiveCodeEditor() {
    return this._activeCodeEditor;
  }
  doOpenEditor(e, t) {
    if (!this.findModel(e, t.resource)) {
      if (t.resource) {
        const s = t.resource.scheme;
        if (s === Ne.http || s === Ne.https)
          return GH(t.resource.toString()), e;
      }
      return null;
    }
    const n = t.options ? t.options.selection : null;
    if (n)
      if (typeof n.endLineNumber == "number" && typeof n.endColumn == "number")
        e.setSelection(n), e.revealRangeInCenter(
          n,
          1
          /* ScrollType.Immediate */
        );
      else {
        const s = {
          lineNumber: n.startLineNumber,
          column: n.startColumn
        };
        e.setPosition(s), e.revealPositionInCenter(
          s,
          1
          /* ScrollType.Immediate */
        );
      }
    return e;
  }
  findModel(e, t) {
    const i = e.getModel();
    return i && i.uri.toString() !== t.toString() ? null : i;
  }
};
PS = mJ([
  _O(0, De),
  _O(1, $i)
], PS);
ot(
  ht,
  PS,
  0
  /* InstantiationType.Eager */
);
const ih = et("layoutService");
var B2 = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, H2 = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
let OS = class {
  get mainContainer() {
    var e, t;
    return (t = (e = qN(this._codeEditorService.listCodeEditors())) === null || e === void 0 ? void 0 : e.getContainerDomNode()) !== null && t !== void 0 ? t : Dt.document.body;
  }
  get activeContainer() {
    var e, t;
    const i = (e = this._codeEditorService.getFocusedCodeEditor()) !== null && e !== void 0 ? e : this._codeEditorService.getActiveCodeEditor();
    return (t = i == null ? void 0 : i.getContainerDomNode()) !== null && t !== void 0 ? t : this.mainContainer;
  }
  get mainContainerDimension() {
    return Rc(this.mainContainer);
  }
  get activeContainerDimension() {
    return Rc(this.activeContainer);
  }
  get containers() {
    return Yr(this._codeEditorService.listCodeEditors().map((e) => e.getContainerDomNode()));
  }
  getContainer() {
    return this.activeContainer;
  }
  whenContainerStylesLoaded() {
  }
  focus() {
    var e;
    (e = this._codeEditorService.getFocusedCodeEditor()) === null || e === void 0 || e.focus();
  }
  constructor(e) {
    this._codeEditorService = e, this.onDidLayoutMainContainer = ne.None, this.onDidLayoutActiveContainer = ne.None, this.onDidLayoutContainer = ne.None, this.onDidChangeActiveContainer = ne.None, this.onDidAddContainer = ne.None, this.mainContainerOffset = { top: 0, quickPickTop: 0 }, this.activeContainerOffset = { top: 0, quickPickTop: 0 };
  }
};
OS = B2([
  H2(0, ht)
], OS);
let bI = class extends OS {
  get mainContainer() {
    return this._container;
  }
  constructor(e, t) {
    super(t), this._container = e;
  }
};
bI = B2([
  H2(1, ht)
], bI);
ot(
  ih,
  OS,
  1
  /* InstantiationType.Delayed */
);
const wb = et("dialogService");
var _J = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, vO = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
function xC(r) {
  return r.scheme === Ne.file ? r.fsPath : r.path;
}
let V2 = 0;
class IC {
  constructor(e, t, i, n, s, o, a) {
    this.id = ++V2, this.type = 0, this.actual = e, this.label = e.label, this.confirmBeforeUndo = e.confirmBeforeUndo || !1, this.resourceLabel = t, this.strResource = i, this.resourceLabels = [this.resourceLabel], this.strResources = [this.strResource], this.groupId = n, this.groupOrder = s, this.sourceId = o, this.sourceOrder = a, this.isValid = !0;
  }
  setValid(e) {
    this.isValid = e;
  }
  toString() {
    return `[id:${this.id}] [group:${this.groupId}] [${this.isValid ? "  VALID" : "INVALID"}] ${this.actual.constructor.name} - ${this.actual}`;
  }
}
class bO {
  constructor(e, t) {
    this.resourceLabel = e, this.reason = t;
  }
}
class CO {
  constructor() {
    this.elements = /* @__PURE__ */ new Map();
  }
  createMessage() {
    const e = [], t = [];
    for (const [, n] of this.elements)
      (n.reason === 0 ? e : t).push(n.resourceLabel);
    const i = [];
    return e.length > 0 && i.push(p({ key: "externalRemoval", comment: ["{0} is a list of filenames"] }, "The following files have been closed and modified on disk: {0}.", e.join(", "))), t.length > 0 && i.push(p({ key: "noParallelUniverses", comment: ["{0} is a list of filenames"] }, "The following files have been modified in an incompatible way: {0}.", t.join(", "))), i.join(`
`);
  }
  get size() {
    return this.elements.size;
  }
  has(e) {
    return this.elements.has(e);
  }
  set(e, t) {
    this.elements.set(e, t);
  }
  delete(e) {
    return this.elements.delete(e);
  }
}
class vJ {
  constructor(e, t, i, n, s, o, a) {
    this.id = ++V2, this.type = 1, this.actual = e, this.label = e.label, this.confirmBeforeUndo = e.confirmBeforeUndo || !1, this.resourceLabels = t, this.strResources = i, this.groupId = n, this.groupOrder = s, this.sourceId = o, this.sourceOrder = a, this.removedResources = null, this.invalidatedResources = null;
  }
  canSplit() {
    return typeof this.actual.split == "function";
  }
  removeResource(e, t, i) {
    this.removedResources || (this.removedResources = new CO()), this.removedResources.has(t) || this.removedResources.set(t, new bO(e, i));
  }
  setValid(e, t, i) {
    i ? this.invalidatedResources && (this.invalidatedResources.delete(t), this.invalidatedResources.size === 0 && (this.invalidatedResources = null)) : (this.invalidatedResources || (this.invalidatedResources = new CO()), this.invalidatedResources.has(t) || this.invalidatedResources.set(t, new bO(
      e,
      0
      /* RemovedResourceReason.ExternalRemoval */
    )));
  }
  toString() {
    return `[id:${this.id}] [group:${this.groupId}] [${this.invalidatedResources ? "INVALID" : "  VALID"}] ${this.actual.constructor.name} - ${this.actual}`;
  }
}
class z2 {
  constructor(e, t) {
    this.resourceLabel = e, this.strResource = t, this._past = [], this._future = [], this.locked = !1, this.versionId = 1;
  }
  dispose() {
    for (const e of this._past)
      e.type === 1 && e.removeResource(
        this.resourceLabel,
        this.strResource,
        0
        /* RemovedResourceReason.ExternalRemoval */
      );
    for (const e of this._future)
      e.type === 1 && e.removeResource(
        this.resourceLabel,
        this.strResource,
        0
        /* RemovedResourceReason.ExternalRemoval */
      );
    this.versionId++;
  }
  toString() {
    const e = [];
    e.push(`* ${this.strResource}:`);
    for (let t = 0; t < this._past.length; t++)
      e.push(`   * [UNDO] ${this._past[t]}`);
    for (let t = this._future.length - 1; t >= 0; t--)
      e.push(`   * [REDO] ${this._future[t]}`);
    return e.join(`
`);
  }
  flushAllElements() {
    this._past = [], this._future = [], this.versionId++;
  }
  _setElementValidFlag(e, t) {
    e.type === 1 ? e.setValid(this.resourceLabel, this.strResource, t) : e.setValid(t);
  }
  setElementsValidFlag(e, t) {
    for (const i of this._past)
      t(i.actual) && this._setElementValidFlag(i, e);
    for (const i of this._future)
      t(i.actual) && this._setElementValidFlag(i, e);
  }
  pushElement(e) {
    for (const t of this._future)
      t.type === 1 && t.removeResource(
        this.resourceLabel,
        this.strResource,
        1
        /* RemovedResourceReason.NoParallelUniverses */
      );
    this._future = [], this._past.push(e), this.versionId++;
  }
  createSnapshot(e) {
    const t = [];
    for (let i = 0, n = this._past.length; i < n; i++)
      t.push(this._past[i].id);
    for (let i = this._future.length - 1; i >= 0; i--)
      t.push(this._future[i].id);
    return new R2(e, t);
  }
  restoreSnapshot(e) {
    const t = e.elements.length;
    let i = !0, n = 0, s = -1;
    for (let a = 0, l = this._past.length; a < l; a++, n++) {
      const d = this._past[a];
      i && (n >= t || d.id !== e.elements[n]) && (i = !1, s = 0), !i && d.type === 1 && d.removeResource(
        this.resourceLabel,
        this.strResource,
        0
        /* RemovedResourceReason.ExternalRemoval */
      );
    }
    let o = -1;
    for (let a = this._future.length - 1; a >= 0; a--, n++) {
      const l = this._future[a];
      i && (n >= t || l.id !== e.elements[n]) && (i = !1, o = a), !i && l.type === 1 && l.removeResource(
        this.resourceLabel,
        this.strResource,
        0
        /* RemovedResourceReason.ExternalRemoval */
      );
    }
    s !== -1 && (this._past = this._past.slice(0, s)), o !== -1 && (this._future = this._future.slice(o + 1)), this.versionId++;
  }
  getElements() {
    const e = [], t = [];
    for (const i of this._past)
      e.push(i.actual);
    for (const i of this._future)
      t.push(i.actual);
    return { past: e, future: t };
  }
  getClosestPastElement() {
    return this._past.length === 0 ? null : this._past[this._past.length - 1];
  }
  getSecondClosestPastElement() {
    return this._past.length < 2 ? null : this._past[this._past.length - 2];
  }
  getClosestFutureElement() {
    return this._future.length === 0 ? null : this._future[this._future.length - 1];
  }
  hasPastElements() {
    return this._past.length > 0;
  }
  hasFutureElements() {
    return this._future.length > 0;
  }
  splitPastWorkspaceElement(e, t) {
    for (let i = this._past.length - 1; i >= 0; i--)
      if (this._past[i] === e) {
        t.has(this.strResource) ? this._past[i] = t.get(this.strResource) : this._past.splice(i, 1);
        break;
      }
    this.versionId++;
  }
  splitFutureWorkspaceElement(e, t) {
    for (let i = this._future.length - 1; i >= 0; i--)
      if (this._future[i] === e) {
        t.has(this.strResource) ? this._future[i] = t.get(this.strResource) : this._future.splice(i, 1);
        break;
      }
    this.versionId++;
  }
  moveBackward(e) {
    this._past.pop(), this._future.push(e), this.versionId++;
  }
  moveForward(e) {
    this._future.pop(), this._past.push(e), this.versionId++;
  }
}
class hk {
  constructor(e) {
    this.editStacks = e, this._versionIds = [];
    for (let t = 0, i = this.editStacks.length; t < i; t++)
      this._versionIds[t] = this.editStacks[t].versionId;
  }
  isValid() {
    for (let e = 0, t = this.editStacks.length; e < t; e++)
      if (this._versionIds[e] !== this.editStacks[e].versionId)
        return !1;
    return !0;
  }
}
const U2 = new z2("", "");
U2.locked = !0;
let CI = class {
  constructor(e, t) {
    this._dialogService = e, this._notificationService = t, this._editStacks = /* @__PURE__ */ new Map(), this._uriComparisonKeyComputers = [];
  }
  getUriComparisonKey(e) {
    for (const t of this._uriComparisonKeyComputers)
      if (t[0] === e.scheme)
        return t[1].getComparisonKey(e);
    return e.toString();
  }
  _print(e) {
    console.log("------------------------------------"), console.log(`AFTER ${e}: `);
    const t = [];
    for (const i of this._editStacks)
      t.push(i[1].toString());
    console.log(t.join(`
`));
  }
  pushElement(e, t = Yf.None, i = Pa.None) {
    if (e.type === 0) {
      const n = xC(e.resource), s = this.getUriComparisonKey(e.resource);
      this._pushElement(new IC(e, n, s, t.id, t.nextOrder(), i.id, i.nextOrder()));
    } else {
      const n = /* @__PURE__ */ new Set(), s = [], o = [];
      for (const a of e.resources) {
        const l = xC(a), d = this.getUriComparisonKey(a);
        n.has(d) || (n.add(d), s.push(l), o.push(d));
      }
      s.length === 1 ? this._pushElement(new IC(e, s[0], o[0], t.id, t.nextOrder(), i.id, i.nextOrder())) : this._pushElement(new vJ(e, s, o, t.id, t.nextOrder(), i.id, i.nextOrder()));
    }
  }
  _pushElement(e) {
    for (let t = 0, i = e.strResources.length; t < i; t++) {
      const n = e.resourceLabels[t], s = e.strResources[t];
      let o;
      this._editStacks.has(s) ? o = this._editStacks.get(s) : (o = new z2(n, s), this._editStacks.set(s, o)), o.pushElement(e);
    }
  }
  getLastElement(e) {
    const t = this.getUriComparisonKey(e);
    if (this._editStacks.has(t)) {
      const i = this._editStacks.get(t);
      if (i.hasFutureElements())
        return null;
      const n = i.getClosestPastElement();
      return n ? n.actual : null;
    }
    return null;
  }
  _splitPastWorkspaceElement(e, t) {
    const i = e.actual.split(), n = /* @__PURE__ */ new Map();
    for (const s of i) {
      const o = xC(s.resource), a = this.getUriComparisonKey(s.resource), l = new IC(s, o, a, 0, 0, 0, 0);
      n.set(l.strResource, l);
    }
    for (const s of e.strResources) {
      if (t && t.has(s))
        continue;
      this._editStacks.get(s).splitPastWorkspaceElement(e, n);
    }
  }
  _splitFutureWorkspaceElement(e, t) {
    const i = e.actual.split(), n = /* @__PURE__ */ new Map();
    for (const s of i) {
      const o = xC(s.resource), a = this.getUriComparisonKey(s.resource), l = new IC(s, o, a, 0, 0, 0, 0);
      n.set(l.strResource, l);
    }
    for (const s of e.strResources) {
      if (t && t.has(s))
        continue;
      this._editStacks.get(s).splitFutureWorkspaceElement(e, n);
    }
  }
  removeElements(e) {
    const t = typeof e == "string" ? e : this.getUriComparisonKey(e);
    this._editStacks.has(t) && (this._editStacks.get(t).dispose(), this._editStacks.delete(t));
  }
  setElementsValidFlag(e, t, i) {
    const n = this.getUriComparisonKey(e);
    this._editStacks.has(n) && this._editStacks.get(n).setElementsValidFlag(t, i);
  }
  createSnapshot(e) {
    const t = this.getUriComparisonKey(e);
    return this._editStacks.has(t) ? this._editStacks.get(t).createSnapshot(e) : new R2(e, []);
  }
  restoreSnapshot(e) {
    const t = this.getUriComparisonKey(e.resource);
    if (this._editStacks.has(t)) {
      const i = this._editStacks.get(t);
      i.restoreSnapshot(e), !i.hasPastElements() && !i.hasFutureElements() && (i.dispose(), this._editStacks.delete(t));
    }
  }
  getElements(e) {
    const t = this.getUriComparisonKey(e);
    return this._editStacks.has(t) ? this._editStacks.get(t).getElements() : { past: [], future: [] };
  }
  _findClosestUndoElementWithSource(e) {
    if (!e)
      return [null, null];
    let t = null, i = null;
    for (const [n, s] of this._editStacks) {
      const o = s.getClosestPastElement();
      o && o.sourceId === e && (!t || o.sourceOrder > t.sourceOrder) && (t = o, i = n);
    }
    return [t, i];
  }
  canUndo(e) {
    if (e instanceof Pa) {
      const [, i] = this._findClosestUndoElementWithSource(e.id);
      return !!i;
    }
    const t = this.getUriComparisonKey(e);
    return this._editStacks.has(t) ? this._editStacks.get(t).hasPastElements() : !1;
  }
  _onError(e, t) {
    He(e);
    for (const i of t.strResources)
      this.removeElements(i);
    this._notificationService.error(e);
  }
  _acquireLocks(e) {
    for (const t of e.editStacks)
      if (t.locked)
        throw new Error("Cannot acquire edit stack lock");
    for (const t of e.editStacks)
      t.locked = !0;
    return () => {
      for (const t of e.editStacks)
        t.locked = !1;
    };
  }
  _safeInvokeWithLocks(e, t, i, n, s) {
    const o = this._acquireLocks(i);
    let a;
    try {
      a = t();
    } catch (l) {
      return o(), n.dispose(), this._onError(l, e);
    }
    return a ? a.then(() => (o(), n.dispose(), s()), (l) => (o(), n.dispose(), this._onError(l, e))) : (o(), n.dispose(), s());
  }
  async _invokeWorkspacePrepare(e) {
    if (typeof e.actual.prepareUndoRedo > "u")
      return P.None;
    const t = e.actual.prepareUndoRedo();
    return typeof t > "u" ? P.None : t;
  }
  _invokeResourcePrepare(e, t) {
    if (e.actual.type !== 1 || typeof e.actual.prepareUndoRedo > "u")
      return t(P.None);
    const i = e.actual.prepareUndoRedo();
    return i ? t0(i) ? t(i) : i.then((n) => t(n)) : t(P.None);
  }
  _getAffectedEditStacks(e) {
    const t = [];
    for (const i of e.strResources)
      t.push(this._editStacks.get(i) || U2);
    return new hk(t);
  }
  _tryToSplitAndUndo(e, t, i, n) {
    if (t.canSplit())
      return this._splitPastWorkspaceElement(t, i), this._notificationService.warn(n), new EC(this._undo(e, 0, !0));
    for (const s of t.strResources)
      this.removeElements(s);
    return this._notificationService.warn(n), new EC();
  }
  _checkWorkspaceUndo(e, t, i, n) {
    if (t.removedResources)
      return this._tryToSplitAndUndo(e, t, t.removedResources, p({ key: "cannotWorkspaceUndo", comment: ["{0} is a label for an operation. {1} is another message."] }, "Could not undo '{0}' across all files. {1}", t.label, t.removedResources.createMessage()));
    if (n && t.invalidatedResources)
      return this._tryToSplitAndUndo(e, t, t.invalidatedResources, p({ key: "cannotWorkspaceUndo", comment: ["{0} is a label for an operation. {1} is another message."] }, "Could not undo '{0}' across all files. {1}", t.label, t.invalidatedResources.createMessage()));
    const s = [];
    for (const a of i.editStacks)
      a.getClosestPastElement() !== t && s.push(a.resourceLabel);
    if (s.length > 0)
      return this._tryToSplitAndUndo(e, t, null, p({ key: "cannotWorkspaceUndoDueToChanges", comment: ["{0} is a label for an operation. {1} is a list of filenames."] }, "Could not undo '{0}' across all files because changes were made to {1}", t.label, s.join(", ")));
    const o = [];
    for (const a of i.editStacks)
      a.locked && o.push(a.resourceLabel);
    return o.length > 0 ? this._tryToSplitAndUndo(e, t, null, p({ key: "cannotWorkspaceUndoDueToInProgressUndoRedo", comment: ["{0} is a label for an operation. {1} is a list of filenames."] }, "Could not undo '{0}' across all files because there is already an undo or redo operation running on {1}", t.label, o.join(", "))) : i.isValid() ? null : this._tryToSplitAndUndo(e, t, null, p({ key: "cannotWorkspaceUndoDueToInMeantimeUndoRedo", comment: ["{0} is a label for an operation. {1} is a list of filenames."] }, "Could not undo '{0}' across all files because an undo or redo operation occurred in the meantime", t.label));
  }
  _workspaceUndo(e, t, i) {
    const n = this._getAffectedEditStacks(t), s = this._checkWorkspaceUndo(
      e,
      t,
      n,
      /*invalidated resources will be checked after the prepare call*/
      !1
    );
    return s ? s.returnValue : this._confirmAndExecuteWorkspaceUndo(e, t, n, i);
  }
  _isPartOfUndoGroup(e) {
    if (!e.groupId)
      return !1;
    for (const [, t] of this._editStacks) {
      const i = t.getClosestPastElement();
      if (i) {
        if (i === e) {
          const n = t.getSecondClosestPastElement();
          if (n && n.groupId === e.groupId)
            return !0;
        }
        if (i.groupId === e.groupId)
          return !0;
      }
    }
    return !1;
  }
  async _confirmAndExecuteWorkspaceUndo(e, t, i, n) {
    if (t.canSplit() && !this._isPartOfUndoGroup(t)) {
      let a;
      (function(c) {
        c[c.All = 0] = "All", c[c.This = 1] = "This", c[c.Cancel = 2] = "Cancel";
      })(a || (a = {}));
      const { result: l } = await this._dialogService.prompt({
        type: yi.Info,
        message: p("confirmWorkspace", "Would you like to undo '{0}' across all files?", t.label),
        buttons: [
          {
            label: p({ key: "ok", comment: ["{0} denotes a number that is > 1, && denotes a mnemonic"] }, "&&Undo in {0} Files", i.editStacks.length),
            run: () => a.All
          },
          {
            label: p({ key: "nok", comment: ["&& denotes a mnemonic"] }, "Undo this &&File"),
            run: () => a.This
          }
        ],
        cancelButton: {
          run: () => a.Cancel
        }
      });
      if (l === a.Cancel)
        return;
      if (l === a.This)
        return this._splitPastWorkspaceElement(t, null), this._undo(e, 0, !0);
      const d = this._checkWorkspaceUndo(
        e,
        t,
        i,
        /*invalidated resources will be checked after the prepare call*/
        !1
      );
      if (d)
        return d.returnValue;
      n = !0;
    }
    let s;
    try {
      s = await this._invokeWorkspacePrepare(t);
    } catch (a) {
      return this._onError(a, t);
    }
    const o = this._checkWorkspaceUndo(
      e,
      t,
      i,
      /*now also check that there are no more invalidated resources*/
      !0
    );
    if (o)
      return s.dispose(), o.returnValue;
    for (const a of i.editStacks)
      a.moveBackward(t);
    return this._safeInvokeWithLocks(t, () => t.actual.undo(), i, s, () => this._continueUndoInGroup(t.groupId, n));
  }
  _resourceUndo(e, t, i) {
    if (!t.isValid) {
      e.flushAllElements();
      return;
    }
    if (e.locked) {
      const n = p({ key: "cannotResourceUndoDueToInProgressUndoRedo", comment: ["{0} is a label for an operation."] }, "Could not undo '{0}' because there is already an undo or redo operation running.", t.label);
      this._notificationService.warn(n);
      return;
    }
    return this._invokeResourcePrepare(t, (n) => (e.moveBackward(t), this._safeInvokeWithLocks(t, () => t.actual.undo(), new hk([e]), n, () => this._continueUndoInGroup(t.groupId, i))));
  }
  _findClosestUndoElementInGroup(e) {
    if (!e)
      return [null, null];
    let t = null, i = null;
    for (const [n, s] of this._editStacks) {
      const o = s.getClosestPastElement();
      o && o.groupId === e && (!t || o.groupOrder > t.groupOrder) && (t = o, i = n);
    }
    return [t, i];
  }
  _continueUndoInGroup(e, t) {
    if (!e)
      return;
    const [, i] = this._findClosestUndoElementInGroup(e);
    if (i)
      return this._undo(i, 0, t);
  }
  undo(e) {
    if (e instanceof Pa) {
      const [, t] = this._findClosestUndoElementWithSource(e.id);
      return t ? this._undo(t, e.id, !1) : void 0;
    }
    return typeof e == "string" ? this._undo(e, 0, !1) : this._undo(this.getUriComparisonKey(e), 0, !1);
  }
  _undo(e, t = 0, i) {
    if (!this._editStacks.has(e))
      return;
    const n = this._editStacks.get(e), s = n.getClosestPastElement();
    if (!s)
      return;
    if (s.groupId) {
      const [a, l] = this._findClosestUndoElementInGroup(s.groupId);
      if (s !== a && l)
        return this._undo(l, t, i);
    }
    if ((s.sourceId !== t || s.confirmBeforeUndo) && !i)
      return this._confirmAndContinueUndo(e, t, s);
    try {
      return s.type === 1 ? this._workspaceUndo(e, s, i) : this._resourceUndo(n, s, i);
    } finally {
    }
  }
  async _confirmAndContinueUndo(e, t, i) {
    if ((await this._dialogService.confirm({
      message: p("confirmDifferentSource", "Would you like to undo '{0}'?", i.label),
      primaryButton: p({ key: "confirmDifferentSource.yes", comment: ["&& denotes a mnemonic"] }, "&&Yes"),
      cancelButton: p("confirmDifferentSource.no", "No")
    })).confirmed)
      return this._undo(e, t, !0);
  }
  _findClosestRedoElementWithSource(e) {
    if (!e)
      return [null, null];
    let t = null, i = null;
    for (const [n, s] of this._editStacks) {
      const o = s.getClosestFutureElement();
      o && o.sourceId === e && (!t || o.sourceOrder < t.sourceOrder) && (t = o, i = n);
    }
    return [t, i];
  }
  canRedo(e) {
    if (e instanceof Pa) {
      const [, i] = this._findClosestRedoElementWithSource(e.id);
      return !!i;
    }
    const t = this.getUriComparisonKey(e);
    return this._editStacks.has(t) ? this._editStacks.get(t).hasFutureElements() : !1;
  }
  _tryToSplitAndRedo(e, t, i, n) {
    if (t.canSplit())
      return this._splitFutureWorkspaceElement(t, i), this._notificationService.warn(n), new EC(this._redo(e));
    for (const s of t.strResources)
      this.removeElements(s);
    return this._notificationService.warn(n), new EC();
  }
  _checkWorkspaceRedo(e, t, i, n) {
    if (t.removedResources)
      return this._tryToSplitAndRedo(e, t, t.removedResources, p({ key: "cannotWorkspaceRedo", comment: ["{0} is a label for an operation. {1} is another message."] }, "Could not redo '{0}' across all files. {1}", t.label, t.removedResources.createMessage()));
    if (n && t.invalidatedResources)
      return this._tryToSplitAndRedo(e, t, t.invalidatedResources, p({ key: "cannotWorkspaceRedo", comment: ["{0} is a label for an operation. {1} is another message."] }, "Could not redo '{0}' across all files. {1}", t.label, t.invalidatedResources.createMessage()));
    const s = [];
    for (const a of i.editStacks)
      a.getClosestFutureElement() !== t && s.push(a.resourceLabel);
    if (s.length > 0)
      return this._tryToSplitAndRedo(e, t, null, p({ key: "cannotWorkspaceRedoDueToChanges", comment: ["{0} is a label for an operation. {1} is a list of filenames."] }, "Could not redo '{0}' across all files because changes were made to {1}", t.label, s.join(", ")));
    const o = [];
    for (const a of i.editStacks)
      a.locked && o.push(a.resourceLabel);
    return o.length > 0 ? this._tryToSplitAndRedo(e, t, null, p({ key: "cannotWorkspaceRedoDueToInProgressUndoRedo", comment: ["{0} is a label for an operation. {1} is a list of filenames."] }, "Could not redo '{0}' across all files because there is already an undo or redo operation running on {1}", t.label, o.join(", "))) : i.isValid() ? null : this._tryToSplitAndRedo(e, t, null, p({ key: "cannotWorkspaceRedoDueToInMeantimeUndoRedo", comment: ["{0} is a label for an operation. {1} is a list of filenames."] }, "Could not redo '{0}' across all files because an undo or redo operation occurred in the meantime", t.label));
  }
  _workspaceRedo(e, t) {
    const i = this._getAffectedEditStacks(t), n = this._checkWorkspaceRedo(
      e,
      t,
      i,
      /*invalidated resources will be checked after the prepare call*/
      !1
    );
    return n ? n.returnValue : this._executeWorkspaceRedo(e, t, i);
  }
  async _executeWorkspaceRedo(e, t, i) {
    let n;
    try {
      n = await this._invokeWorkspacePrepare(t);
    } catch (o) {
      return this._onError(o, t);
    }
    const s = this._checkWorkspaceRedo(
      e,
      t,
      i,
      /*now also check that there are no more invalidated resources*/
      !0
    );
    if (s)
      return n.dispose(), s.returnValue;
    for (const o of i.editStacks)
      o.moveForward(t);
    return this._safeInvokeWithLocks(t, () => t.actual.redo(), i, n, () => this._continueRedoInGroup(t.groupId));
  }
  _resourceRedo(e, t) {
    if (!t.isValid) {
      e.flushAllElements();
      return;
    }
    if (e.locked) {
      const i = p({ key: "cannotResourceRedoDueToInProgressUndoRedo", comment: ["{0} is a label for an operation."] }, "Could not redo '{0}' because there is already an undo or redo operation running.", t.label);
      this._notificationService.warn(i);
      return;
    }
    return this._invokeResourcePrepare(t, (i) => (e.moveForward(t), this._safeInvokeWithLocks(t, () => t.actual.redo(), new hk([e]), i, () => this._continueRedoInGroup(t.groupId))));
  }
  _findClosestRedoElementInGroup(e) {
    if (!e)
      return [null, null];
    let t = null, i = null;
    for (const [n, s] of this._editStacks) {
      const o = s.getClosestFutureElement();
      o && o.groupId === e && (!t || o.groupOrder < t.groupOrder) && (t = o, i = n);
    }
    return [t, i];
  }
  _continueRedoInGroup(e) {
    if (!e)
      return;
    const [, t] = this._findClosestRedoElementInGroup(e);
    if (t)
      return this._redo(t);
  }
  redo(e) {
    if (e instanceof Pa) {
      const [, t] = this._findClosestRedoElementWithSource(e.id);
      return t ? this._redo(t) : void 0;
    }
    return typeof e == "string" ? this._redo(e) : this._redo(this.getUriComparisonKey(e));
  }
  _redo(e) {
    if (!this._editStacks.has(e))
      return;
    const t = this._editStacks.get(e), i = t.getClosestFutureElement();
    if (i) {
      if (i.groupId) {
        const [n, s] = this._findClosestRedoElementInGroup(i.groupId);
        if (i !== n && s)
          return this._redo(s);
      }
      try {
        return i.type === 1 ? this._workspaceRedo(e, i) : this._resourceRedo(t, i);
      } finally {
      }
    }
  }
};
CI = _J([
  vO(0, wb),
  vO(1, xi)
], CI);
class EC {
  constructor(e) {
    this.returnValue = e;
  }
}
ot(
  O0,
  CI,
  1
  /* InstantiationType.Delayed */
);
function Yn(r, e, t) {
  return Math.min(Math.max(r, e), t);
}
class $2 {
  constructor() {
    this._n = 1, this._val = 0;
  }
  update(e) {
    return this._val = this._val + (e - this._val) / this._n, this._n += 1, this._val;
  }
  get value() {
    return this._val;
  }
}
class bJ {
  constructor(e) {
    this._n = 0, this._val = 0, this._values = [], this._index = 0, this._sum = 0, this._values = new Array(e), this._values.fill(0, 0, e);
  }
  update(e) {
    const t = this._values[this._index];
    return this._values[this._index] = e, this._index = (this._index + 1) % this._values.length, this._sum -= t, this._sum += e, this._n < this._values.length && (this._n += 1), this._val = this._sum / this._n, this._val;
  }
  get value() {
    return this._val;
  }
}
const J1 = et("environmentService");
var CJ = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, wO = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
const Vo = et("ILanguageFeatureDebounceService");
var FS;
(function(r) {
  const e = /* @__PURE__ */ new WeakMap();
  let t = 0;
  function i(n) {
    let s = e.get(n);
    return s === void 0 && (s = ++t, e.set(n, s)), s;
  }
  r.of = i;
})(FS || (FS = {}));
class wJ {
  constructor(e) {
    this._default = e;
  }
  get(e) {
    return this._default;
  }
  update(e, t) {
    return this._default;
  }
  default() {
    return this._default;
  }
}
class SJ {
  constructor(e, t, i, n, s, o) {
    this._logService = e, this._name = t, this._registry = i, this._default = n, this._min = s, this._max = o, this._cache = new Cd(50, 0.7);
  }
  _key(e) {
    return e.id + this._registry.all(e).reduce((t, i) => R5(FS.of(i), t), 0);
  }
  get(e) {
    const t = this._key(e), i = this._cache.get(t);
    return i ? Yn(i.value, this._min, this._max) : this.default();
  }
  update(e, t) {
    const i = this._key(e);
    let n = this._cache.get(i);
    n || (n = new bJ(6), this._cache.set(i, n));
    const s = Yn(n.update(t), this._min, this._max);
    return i1(e.uri, "output") || this._logService.trace(`[DEBOUNCE: ${this._name}] for ${e.uri.toString()} is ${s}ms`), s;
  }
  _overall() {
    const e = new $2();
    for (const [, t] of this._cache)
      e.update(t.value);
    return e.value;
  }
  default() {
    const e = this._overall() | 0 || this._default;
    return Yn(e, this._min, this._max);
  }
}
let wI = class {
  constructor(e, t) {
    this._logService = e, this._data = /* @__PURE__ */ new Map(), this._isDev = t.isExtensionDevelopment || !t.isBuilt;
  }
  for(e, t, i) {
    var n, s, o;
    const a = (n = i == null ? void 0 : i.min) !== null && n !== void 0 ? n : 50, l = (s = i == null ? void 0 : i.max) !== null && s !== void 0 ? s : a ** 2, d = (o = i == null ? void 0 : i.key) !== null && o !== void 0 ? o : void 0, c = `${FS.of(e)},${a}${d ? "," + d : ""}`;
    let h = this._data.get(c);
    return h || (this._isDev ? (this._logService.debug(`[DEBOUNCE: ${t}] is disabled in developed mode`), h = new wJ(a * 1.5)) : h = new SJ(
      this._logService,
      t,
      e,
      this._overallAverage() | 0 || a * 1.5,
      // default is overall default or derived from min-value
      a,
      l
    ), this._data.set(c, h)), h;
  }
  _overallAverage() {
    const e = new $2();
    for (const t of this._data.values())
      e.update(t.default());
    return e.value;
  }
};
wI = CJ([
  wO(0, Pn),
  wO(1, J1)
], wI);
ot(
  Vo,
  wI,
  1
  /* InstantiationType.Delayed */
);
class m_ {
  static create(e, t) {
    return new m_(e, new WS(t));
  }
  /**
   * (Inclusive) start line number for these tokens.
   */
  get startLineNumber() {
    return this._startLineNumber;
  }
  /**
   * (Inclusive) end line number for these tokens.
   */
  get endLineNumber() {
    return this._endLineNumber;
  }
  constructor(e, t) {
    this._startLineNumber = e, this._tokens = t, this._endLineNumber = this._startLineNumber + this._tokens.getMaxDeltaLine();
  }
  toString() {
    return this._tokens.toString(this._startLineNumber);
  }
  _updateEndLineNumber() {
    this._endLineNumber = this._startLineNumber + this._tokens.getMaxDeltaLine();
  }
  isEmpty() {
    return this._tokens.isEmpty();
  }
  getLineTokens(e) {
    return this._startLineNumber <= e && e <= this._endLineNumber ? this._tokens.getLineTokens(e - this._startLineNumber) : null;
  }
  getRange() {
    const e = this._tokens.getRange();
    return e && new L(this._startLineNumber + e.startLineNumber, e.startColumn, this._startLineNumber + e.endLineNumber, e.endColumn);
  }
  removeTokens(e) {
    const t = e.startLineNumber - this._startLineNumber, i = e.endLineNumber - this._startLineNumber;
    this._startLineNumber += this._tokens.removeTokens(t, e.startColumn - 1, i, e.endColumn - 1), this._updateEndLineNumber();
  }
  split(e) {
    const t = e.startLineNumber - this._startLineNumber, i = e.endLineNumber - this._startLineNumber, [n, s, o] = this._tokens.split(t, e.startColumn - 1, i, e.endColumn - 1);
    return [new m_(this._startLineNumber, n), new m_(this._startLineNumber + o, s)];
  }
  applyEdit(e, t) {
    const [i, n, s] = Oc(t);
    this.acceptEdit(
      e,
      i,
      n,
      s,
      t.length > 0 ? t.charCodeAt(0) : 0
      /* CharCode.Null */
    );
  }
  acceptEdit(e, t, i, n, s) {
    this._acceptDeleteRange(e), this._acceptInsertText(new A(e.startLineNumber, e.startColumn), t, i, n, s), this._updateEndLineNumber();
  }
  _acceptDeleteRange(e) {
    if (e.startLineNumber === e.endLineNumber && e.startColumn === e.endColumn)
      return;
    const t = e.startLineNumber - this._startLineNumber, i = e.endLineNumber - this._startLineNumber;
    if (i < 0) {
      const s = i - t;
      this._startLineNumber -= s;
      return;
    }
    const n = this._tokens.getMaxDeltaLine();
    if (!(t >= n + 1)) {
      if (t < 0 && i >= n + 1) {
        this._startLineNumber = 0, this._tokens.clear();
        return;
      }
      if (t < 0) {
        const s = -t;
        this._startLineNumber -= s, this._tokens.acceptDeleteRange(e.startColumn - 1, 0, 0, i, e.endColumn - 1);
      } else
        this._tokens.acceptDeleteRange(0, t, e.startColumn - 1, i, e.endColumn - 1);
    }
  }
  _acceptInsertText(e, t, i, n, s) {
    if (t === 0 && i === 0)
      return;
    const o = e.lineNumber - this._startLineNumber;
    if (o < 0) {
      this._startLineNumber += t;
      return;
    }
    const a = this._tokens.getMaxDeltaLine();
    o >= a + 1 || this._tokens.acceptInsertText(o, e.column - 1, t, i, n, s);
  }
}
class WS {
  constructor(e) {
    this._tokens = e, this._tokenCount = e.length / 4;
  }
  toString(e) {
    const t = [];
    for (let i = 0; i < this._tokenCount; i++)
      t.push(`(${this._getDeltaLine(i) + e},${this._getStartCharacter(i)}-${this._getEndCharacter(i)})`);
    return `[${t.join(",")}]`;
  }
  getMaxDeltaLine() {
    const e = this._getTokenCount();
    return e === 0 ? -1 : this._getDeltaLine(e - 1);
  }
  getRange() {
    const e = this._getTokenCount();
    if (e === 0)
      return null;
    const t = this._getStartCharacter(0), i = this._getDeltaLine(e - 1), n = this._getEndCharacter(e - 1);
    return new L(0, t + 1, i, n + 1);
  }
  _getTokenCount() {
    return this._tokenCount;
  }
  _getDeltaLine(e) {
    return this._tokens[4 * e];
  }
  _getStartCharacter(e) {
    return this._tokens[4 * e + 1];
  }
  _getEndCharacter(e) {
    return this._tokens[4 * e + 2];
  }
  isEmpty() {
    return this._getTokenCount() === 0;
  }
  getLineTokens(e) {
    let t = 0, i = this._getTokenCount() - 1;
    for (; t < i; ) {
      const n = t + Math.floor((i - t) / 2), s = this._getDeltaLine(n);
      if (s < e)
        t = n + 1;
      else if (s > e)
        i = n - 1;
      else {
        let o = n;
        for (; o > t && this._getDeltaLine(o - 1) === e; )
          o--;
        let a = n;
        for (; a < i && this._getDeltaLine(a + 1) === e; )
          a++;
        return new SO(this._tokens.subarray(4 * o, 4 * a + 4));
      }
    }
    return this._getDeltaLine(t) === e ? new SO(this._tokens.subarray(4 * t, 4 * t + 4)) : null;
  }
  clear() {
    this._tokenCount = 0;
  }
  removeTokens(e, t, i, n) {
    const s = this._tokens, o = this._tokenCount;
    let a = 0, l = !1, d = 0;
    for (let c = 0; c < o; c++) {
      const h = 4 * c, u = s[h], g = s[h + 1], f = s[h + 2], m = s[h + 3];
      if ((u > e || u === e && f >= t) && (u < i || u === i && g <= n))
        l = !0;
      else {
        if (a === 0 && (d = u), l) {
          const _ = 4 * a;
          s[_] = u - d, s[_ + 1] = g, s[_ + 2] = f, s[_ + 3] = m;
        }
        a++;
      }
    }
    return this._tokenCount = a, d;
  }
  split(e, t, i, n) {
    const s = this._tokens, o = this._tokenCount, a = [], l = [];
    let d = a, c = 0, h = 0;
    for (let u = 0; u < o; u++) {
      const g = 4 * u, f = s[g], m = s[g + 1], _ = s[g + 2], v = s[g + 3];
      if (f > e || f === e && _ >= t) {
        if (f < i || f === i && m <= n)
          continue;
        d !== l && (d = l, c = 0, h = f);
      }
      d[c++] = f - h, d[c++] = m, d[c++] = _, d[c++] = v;
    }
    return [new WS(new Uint32Array(a)), new WS(new Uint32Array(l)), h];
  }
  acceptDeleteRange(e, t, i, n, s) {
    const o = this._tokens, a = this._tokenCount, l = n - t;
    let d = 0, c = !1;
    for (let h = 0; h < a; h++) {
      const u = 4 * h;
      let g = o[u], f = o[u + 1], m = o[u + 2];
      const _ = o[u + 3];
      if (g < t || g === t && m <= i) {
        d++;
        continue;
      } else if (g === t && f < i)
        g === n && m > s ? m -= s - i : m = i;
      else if (g === t && f === i)
        if (g === n && m > s)
          m -= s - i;
        else {
          c = !0;
          continue;
        }
      else if (g < n || g === n && f < s)
        if (g === n && m > s)
          g = t, f = i, m = f + (m - s);
        else {
          c = !0;
          continue;
        }
      else if (g > n) {
        if (l === 0 && !c) {
          d = a;
          break;
        }
        g -= l;
      } else if (g === n && f >= s)
        e && g === 0 && (f += e, m += e), g -= l, f -= s - i, m -= s - i;
      else
        throw new Error("Not possible!");
      const v = 4 * d;
      o[v] = g, o[v + 1] = f, o[v + 2] = m, o[v + 3] = _, d++;
    }
    this._tokenCount = d;
  }
  acceptInsertText(e, t, i, n, s, o) {
    const a = i === 0 && n === 1 && (o >= 48 && o <= 57 || o >= 65 && o <= 90 || o >= 97 && o <= 122), l = this._tokens, d = this._tokenCount;
    for (let c = 0; c < d; c++) {
      const h = 4 * c;
      let u = l[h], g = l[h + 1], f = l[h + 2];
      if (!(u < e || u === e && f < t)) {
        if (u === e && f === t)
          if (a)
            f += 1;
          else
            continue;
        else if (u === e && g < t && t < f)
          i === 0 ? f += n : f = t;
        else {
          if (u === e && g === t && a)
            continue;
          if (u === e)
            if (u += i, i === 0)
              g += n, f += n;
            else {
              const m = f - g;
              g = s + (g - t), f = g + m;
            }
          else
            u += i;
        }
        l[h] = u, l[h + 1] = g, l[h + 2] = f;
      }
    }
  }
}
class SO {
  constructor(e) {
    this._tokens = e;
  }
  getCount() {
    return this._tokens.length / 4;
  }
  getStartCharacter(e) {
    return this._tokens[4 * e + 1];
  }
  getEndCharacter(e) {
    return this._tokens[4 * e + 2];
  }
  getMetadata(e) {
    return this._tokens[4 * e + 3];
  }
}
var yJ = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, uk = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
let SI = class {
  constructor(e, t, i, n) {
    this._legend = e, this._themeService = t, this._languageService = i, this._logService = n, this._hasWarnedOverlappingTokens = !1, this._hasWarnedInvalidLengthTokens = !1, this._hasWarnedInvalidEditStart = !1, this._hashTable = new Nl();
  }
  getMetadata(e, t, i) {
    const n = this._languageService.languageIdCodec.encodeLanguageId(i), s = this._hashTable.get(e, t, n);
    let o;
    if (s)
      o = s.metadata, this._logService.getLevel() === Sn.Trace && this._logService.trace(`SemanticTokensProviderStyling [CACHED] ${e} / ${t}: foreground ${yn.getForeground(o)}, fontStyle ${yn.getFontStyle(o).toString(2)}`);
    else {
      let a = this._legend.tokenTypes[e];
      const l = [];
      if (a) {
        let d = t;
        for (let h = 0; d > 0 && h < this._legend.tokenModifiers.length; h++)
          d & 1 && l.push(this._legend.tokenModifiers[h]), d = d >> 1;
        d > 0 && this._logService.getLevel() === Sn.Trace && (this._logService.trace(`SemanticTokensProviderStyling: unknown token modifier index: ${t.toString(2)} for legend: ${JSON.stringify(this._legend.tokenModifiers)}`), l.push("not-in-legend"));
        const c = this._themeService.getColorTheme().getTokenStyleMetadata(a, l, i);
        if (typeof c > "u")
          o = 2147483647;
        else {
          if (o = 0, typeof c.italic < "u") {
            const h = (c.italic ? 1 : 0) << 11;
            o |= h | 1;
          }
          if (typeof c.bold < "u") {
            const h = (c.bold ? 2 : 0) << 11;
            o |= h | 2;
          }
          if (typeof c.underline < "u") {
            const h = (c.underline ? 4 : 0) << 11;
            o |= h | 4;
          }
          if (typeof c.strikethrough < "u") {
            const h = (c.strikethrough ? 8 : 0) << 11;
            o |= h | 8;
          }
          if (c.foreground) {
            const h = c.foreground << 15;
            o |= h | 16;
          }
          o === 0 && (o = 2147483647);
        }
      } else
        this._logService.getLevel() === Sn.Trace && this._logService.trace(`SemanticTokensProviderStyling: unknown token type index: ${e} for legend: ${JSON.stringify(this._legend.tokenTypes)}`), o = 2147483647, a = "not-in-legend";
      this._hashTable.add(e, t, n, o), this._logService.getLevel() === Sn.Trace && this._logService.trace(`SemanticTokensProviderStyling ${e} (${a}) / ${t} (${l.join(" ")}): foreground ${yn.getForeground(o)}, fontStyle ${yn.getFontStyle(o).toString(2)}`);
    }
    return o;
  }
  warnOverlappingSemanticTokens(e, t) {
    this._hasWarnedOverlappingTokens || (this._hasWarnedOverlappingTokens = !0, this._logService.warn(`Overlapping semantic tokens detected at lineNumber ${e}, column ${t}`));
  }
  warnInvalidLengthSemanticTokens(e, t) {
    this._hasWarnedInvalidLengthTokens || (this._hasWarnedInvalidLengthTokens = !0, this._logService.warn(`Semantic token with invalid length detected at lineNumber ${e}, column ${t}`));
  }
  warnInvalidEditStart(e, t, i, n, s) {
    this._hasWarnedInvalidEditStart || (this._hasWarnedInvalidEditStart = !0, this._logService.warn(`Invalid semantic tokens edit detected (previousResultId: ${e}, resultId: ${t}) at edit #${i}: The provided start offset ${n} is outside the previous data (length ${s}).`));
  }
};
SI = yJ([
  uk(1, $i),
  uk(2, Jt),
  uk(3, Pn)
], SI);
function K2(r, e, t) {
  const i = r.data, n = r.data.length / 5 | 0, s = Math.max(
    Math.ceil(
      n / 1024
      /* SemanticColoringConstants.DesiredMaxAreas */
    ),
    400
    /* SemanticColoringConstants.DesiredTokensPerArea */
  ), o = [];
  let a = 0, l = 1, d = 0;
  for (; a < n; ) {
    const c = a;
    let h = Math.min(c + s, n);
    if (h < n) {
      let b = h;
      for (; b - 1 > c && i[5 * b] === 0; )
        b--;
      if (b - 1 === c) {
        let C = h;
        for (; C + 1 < n && i[5 * C] === 0; )
          C++;
        h = C;
      } else
        h = b;
    }
    let u = new Uint32Array((h - c) * 4), g = 0, f = 0, m = 0, _ = 0;
    for (; a < h; ) {
      const b = 5 * a, C = i[b], w = i[b + 1], S = l + C | 0, y = C === 0 ? d + w | 0 : w, k = i[b + 2], E = y + k | 0, N = i[b + 3], F = i[b + 4];
      if (E <= y)
        e.warnInvalidLengthSemanticTokens(S, y + 1);
      else if (m === S && _ > y)
        e.warnOverlappingSemanticTokens(S, y + 1);
      else {
        const V = e.getMetadata(N, F, t);
        V !== 2147483647 && (f === 0 && (f = S), u[g] = S - f, u[g + 1] = y, u[g + 2] = E, u[g + 3] = V, g += 4, m = S, _ = E);
      }
      l = S, d = y, a++;
    }
    g !== u.length && (u = u.subarray(0, g));
    const v = m_.create(f, u);
    o.push(v);
  }
  return o;
}
class LJ {
  constructor(e, t, i, n) {
    this.tokenTypeIndex = e, this.tokenModifierSet = t, this.languageId = i, this.metadata = n, this.next = null;
  }
}
class Nl {
  constructor() {
    this._elementsCount = 0, this._currentLengthIndex = 0, this._currentLength = Nl._SIZES[this._currentLengthIndex], this._growCount = Math.round(this._currentLengthIndex + 1 < Nl._SIZES.length ? 2 / 3 * this._currentLength : 0), this._elements = [], Nl._nullOutEntries(this._elements, this._currentLength);
  }
  static _nullOutEntries(e, t) {
    for (let i = 0; i < t; i++)
      e[i] = null;
  }
  _hash2(e, t) {
    return (e << 5) - e + t | 0;
  }
  _hashFunc(e, t, i) {
    return this._hash2(this._hash2(e, t), i) % this._currentLength;
  }
  get(e, t, i) {
    const n = this._hashFunc(e, t, i);
    let s = this._elements[n];
    for (; s; ) {
      if (s.tokenTypeIndex === e && s.tokenModifierSet === t && s.languageId === i)
        return s;
      s = s.next;
    }
    return null;
  }
  add(e, t, i, n) {
    if (this._elementsCount++, this._growCount !== 0 && this._elementsCount >= this._growCount) {
      const s = this._elements;
      this._currentLengthIndex++, this._currentLength = Nl._SIZES[this._currentLengthIndex], this._growCount = Math.round(this._currentLengthIndex + 1 < Nl._SIZES.length ? 2 / 3 * this._currentLength : 0), this._elements = [], Nl._nullOutEntries(this._elements, this._currentLength);
      for (const o of s) {
        let a = o;
        for (; a; ) {
          const l = a.next;
          a.next = null, this._add(a), a = l;
        }
      }
    }
    this._add(new LJ(e, t, i, n));
  }
  _add(e) {
    const t = this._hashFunc(e.tokenTypeIndex, e.tokenModifierSet, e.languageId);
    e.next = this._elements[t], this._elements[t] = e;
  }
}
Nl._SIZES = [3, 7, 13, 31, 61, 127, 251, 509, 1021, 2039, 4093, 8191, 16381, 32749, 65521, 131071, 262139, 524287, 1048573, 2097143];
const W0 = et("semanticTokensStylingService");
var DJ = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, gk = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
let yI = class extends P {
  constructor(e, t, i) {
    super(), this._themeService = e, this._logService = t, this._languageService = i, this._caches = /* @__PURE__ */ new WeakMap(), this._register(this._themeService.onDidColorThemeChange(() => {
      this._caches = /* @__PURE__ */ new WeakMap();
    }));
  }
  getStyling(e) {
    return this._caches.has(e) || this._caches.set(e, new SI(e.getLegend(), this._themeService, this._languageService, this._logService)), this._caches.get(e);
  }
};
yI = DJ([
  gk(0, $i),
  gk(1, Pn),
  gk(2, Jt)
], yI);
ot(
  W0,
  yI,
  1
  /* InstantiationType.Delayed */
);
const TC = "**", yO = "/", Fw = "[/\\\\]", Ww = "[^/\\\\]", kJ = /\//g;
function LO(r, e) {
  switch (r) {
    case 0:
      return "";
    case 1:
      return `${Ww}*?`;
    default:
      return `(?:${Fw}|${Ww}+${Fw}${e ? `|${Fw}${Ww}+` : ""})*?`;
  }
}
function DO(r, e) {
  if (!r)
    return [];
  const t = [];
  let i = !1, n = !1, s = "";
  for (const o of r) {
    switch (o) {
      case e:
        if (!i && !n) {
          t.push(s), s = "";
          continue;
        }
        break;
      case "{":
        i = !0;
        break;
      case "}":
        i = !1;
        break;
      case "[":
        n = !0;
        break;
      case "]":
        n = !1;
        break;
    }
    s += o;
  }
  return s && t.push(s), t;
}
function j2(r) {
  if (!r)
    return "";
  let e = "";
  const t = DO(r, yO);
  if (t.every((i) => i === TC))
    e = ".*";
  else {
    let i = !1;
    t.forEach((n, s) => {
      if (n === TC) {
        if (i)
          return;
        e += LO(2, s === t.length - 1);
      } else {
        let o = !1, a = "", l = !1, d = "";
        for (const c of n) {
          if (c !== "}" && o) {
            a += c;
            continue;
          }
          if (l && (c !== "]" || !d)) {
            let h;
            c === "-" ? h = c : (c === "^" || c === "!") && !d ? h = "^" : c === yO ? h = "" : h = gr(c), d += h;
            continue;
          }
          switch (c) {
            case "{":
              o = !0;
              continue;
            case "[":
              l = !0;
              continue;
            case "}": {
              const u = `(?:${DO(a, ",").map((g) => j2(g)).join("|")})`;
              e += u, o = !1, a = "";
              break;
            }
            case "]": {
              e += "[" + d + "]", l = !1, d = "";
              break;
            }
            case "?":
              e += Ww;
              continue;
            case "*":
              e += LO(1);
              continue;
            default:
              e += gr(c);
          }
        }
        s < t.length - 1 && // more segments to come after this
        (t[s + 1] !== TC || // next segment is not **, or...
        s + 2 < t.length) && (e += Fw);
      }
      i = n === TC;
    });
  }
  return e;
}
const xJ = /^\*\*\/\*\.[\w\.-]+$/, IJ = /^\*\*\/([\w\.-]+)\/?$/, EJ = /^{\*\*\/\*?[\w\.-]+\/?(,\*\*\/\*?[\w\.-]+\/?)*}$/, TJ = /^{\*\*\/\*?[\w\.-]+(\/(\*\*)?)?(,\*\*\/\*?[\w\.-]+(\/(\*\*)?)?)*}$/, NJ = /^\*\*((\/[\w\.-]+)+)\/?$/, MJ = /^([\w\.-]+(\/[\w\.-]+)*)\/?$/, kO = new Cd(1e4), xO = function() {
  return !1;
}, Ga = function() {
  return null;
};
function eM(r, e) {
  if (!r)
    return Ga;
  let t;
  typeof r != "string" ? t = r.pattern : t = r, t = t.trim();
  const i = `${t}_${!!e.trimForExclusions}`;
  let n = kO.get(i);
  if (n)
    return IO(n, r);
  let s;
  return xJ.test(t) ? n = RJ(t.substr(4), t) : (s = IJ.exec(fk(t, e))) ? n = AJ(s[1], t) : (e.trimForExclusions ? TJ : EJ).test(t) ? n = PJ(t, e) : (s = NJ.exec(fk(t, e))) ? n = EO(s[1].substr(1), t, !0) : (s = MJ.exec(fk(t, e))) ? n = EO(s[1], t, !1) : n = OJ(t), kO.set(i, n), IO(n, r);
}
function IO(r, e) {
  if (typeof e == "string")
    return r;
  const t = function(i, n) {
    return aI(i, e.base, !os) ? r(i0(i.substr(e.base.length), $r), n) : null;
  };
  return t.allBasenames = r.allBasenames, t.allPaths = r.allPaths, t.basenames = r.basenames, t.patterns = r.patterns, t;
}
function fk(r, e) {
  return e.trimForExclusions && r.endsWith("/**") ? r.substr(0, r.length - 2) : r;
}
function RJ(r, e) {
  return function(t, i) {
    return typeof t == "string" && t.endsWith(r) ? e : null;
  };
}
function AJ(r, e) {
  const t = `/${r}`, i = `\\${r}`, n = function(o, a) {
    return typeof o != "string" ? null : a ? a === r ? e : null : o === r || o.endsWith(t) || o.endsWith(i) ? e : null;
  }, s = [r];
  return n.basenames = s, n.patterns = [e], n.allBasenames = s, n;
}
function PJ(r, e) {
  const t = G2(r.slice(1, -1).split(",").map((a) => eM(a, e)).filter((a) => a !== Ga), r), i = t.length;
  if (!i)
    return Ga;
  if (i === 1)
    return t[0];
  const n = function(a, l) {
    for (let d = 0, c = t.length; d < c; d++)
      if (t[d](a, l))
        return r;
    return null;
  }, s = t.find((a) => !!a.allBasenames);
  s && (n.allBasenames = s.allBasenames);
  const o = t.reduce((a, l) => l.allPaths ? a.concat(l.allPaths) : a, []);
  return o.length && (n.allPaths = o), n;
}
function EO(r, e, t) {
  const i = $r === ir.sep, n = i ? r : r.replace(kJ, $r), s = $r + n, o = ir.sep + r;
  let a;
  return t ? a = function(l, d) {
    return typeof l == "string" && (l === n || l.endsWith(s) || !i && (l === r || l.endsWith(o))) ? e : null;
  } : a = function(l, d) {
    return typeof l == "string" && (l === n || !i && l === r) ? e : null;
  }, a.allPaths = [(t ? "*/" : "./") + r], a;
}
function OJ(r) {
  try {
    const e = new RegExp(`^${j2(r)}$`);
    return function(t) {
      return e.lastIndex = 0, typeof t == "string" && e.test(t) ? r : null;
    };
  } catch {
    return Ga;
  }
}
function FJ(r, e, t) {
  return !r || typeof e != "string" ? !1 : q2(r)(e, void 0, t);
}
function q2(r, e = {}) {
  if (!r)
    return xO;
  if (typeof r == "string" || WJ(r)) {
    const t = eM(r, e);
    if (t === Ga)
      return xO;
    const i = function(n, s) {
      return !!t(n, s);
    };
    return t.allBasenames && (i.allBasenames = t.allBasenames), t.allPaths && (i.allPaths = t.allPaths), i;
  }
  return BJ(r, e);
}
function WJ(r) {
  const e = r;
  return e ? typeof e.base == "string" && typeof e.pattern == "string" : !1;
}
function BJ(r, e) {
  const t = G2(Object.getOwnPropertyNames(r).map((a) => HJ(a, r[a], e)).filter((a) => a !== Ga)), i = t.length;
  if (!i)
    return Ga;
  if (!t.some((a) => !!a.requiresSiblings)) {
    if (i === 1)
      return t[0];
    const a = function(c, h) {
      let u;
      for (let g = 0, f = t.length; g < f; g++) {
        const m = t[g](c, h);
        if (typeof m == "string")
          return m;
        Lx(m) && (u || (u = []), u.push(m));
      }
      return u ? (async () => {
        for (const g of u) {
          const f = await g;
          if (typeof f == "string")
            return f;
        }
        return null;
      })() : null;
    }, l = t.find((c) => !!c.allBasenames);
    l && (a.allBasenames = l.allBasenames);
    const d = t.reduce((c, h) => h.allPaths ? c.concat(h.allPaths) : c, []);
    return d.length && (a.allPaths = d), a;
  }
  const n = function(a, l, d) {
    let c, h;
    for (let u = 0, g = t.length; u < g; u++) {
      const f = t[u];
      f.requiresSiblings && d && (l || (l = fc(a)), c || (c = l.substr(0, l.length - A5(a).length)));
      const m = f(a, l, c, d);
      if (typeof m == "string")
        return m;
      Lx(m) && (h || (h = []), h.push(m));
    }
    return h ? (async () => {
      for (const u of h) {
        const g = await u;
        if (typeof g == "string")
          return g;
      }
      return null;
    })() : null;
  }, s = t.find((a) => !!a.allBasenames);
  s && (n.allBasenames = s.allBasenames);
  const o = t.reduce((a, l) => l.allPaths ? a.concat(l.allPaths) : a, []);
  return o.length && (n.allPaths = o), n;
}
function HJ(r, e, t) {
  if (e === !1)
    return Ga;
  const i = eM(r, t);
  if (i === Ga)
    return Ga;
  if (typeof e == "boolean")
    return i;
  if (e) {
    const n = e.when;
    if (typeof n == "string") {
      const s = (o, a, l, d) => {
        if (!d || !i(o, a))
          return null;
        const c = n.replace("$(basename)", () => l), h = d(c);
        return Lx(h) ? h.then((u) => u ? r : null) : h ? r : null;
      };
      return s.requiresSiblings = !0, s;
    }
  }
  return i;
}
function G2(r, e) {
  const t = r.filter((a) => !!a.basenames);
  if (t.length < 2)
    return r;
  const i = t.reduce((a, l) => {
    const d = l.basenames;
    return d ? a.concat(d) : a;
  }, []);
  let n;
  if (e) {
    n = [];
    for (let a = 0, l = i.length; a < l; a++)
      n.push(e);
  } else
    n = t.reduce((a, l) => {
      const d = l.patterns;
      return d ? a.concat(d) : a;
    }, []);
  const s = function(a, l) {
    if (typeof a != "string")
      return null;
    if (!l) {
      let c;
      for (c = a.length; c > 0; c--) {
        const h = a.charCodeAt(c - 1);
        if (h === 47 || h === 92)
          break;
      }
      l = a.substr(c);
    }
    const d = i.indexOf(l);
    return d !== -1 ? n[d] : null;
  };
  s.basenames = i, s.patterns = n, s.allBasenames = i;
  const o = r.filter((a) => !a.basenames);
  return o.push(s), o;
}
function tM(r, e, t, i, n, s) {
  if (Array.isArray(r)) {
    let o = 0;
    for (const a of r) {
      const l = tM(a, e, t, i, n, s);
      if (l === 10)
        return l;
      l > o && (o = l);
    }
    return o;
  } else {
    if (typeof r == "string")
      return i ? r === "*" ? 5 : r === t ? 10 : 0 : 0;
    if (r) {
      const { language: o, pattern: a, scheme: l, hasAccessToAllModels: d, notebookType: c } = r;
      if (!i && !d)
        return 0;
      c && n && (e = n);
      let h = 0;
      if (l)
        if (l === e.scheme)
          h = 10;
        else if (l === "*")
          h = 5;
        else
          return 0;
      if (o)
        if (o === t)
          h = 10;
        else if (o === "*")
          h = Math.max(h, 5);
        else
          return 0;
      if (c)
        if (c === s)
          h = 10;
        else if (c === "*" && s !== void 0)
          h = Math.max(h, 5);
        else
          return 0;
      if (a) {
        let u;
        if (typeof a == "string" ? u = a : u = { ...a, base: XB(a.base) }, u === e.fsPath || FJ(u, e.fsPath))
          h = 10;
        else
          return 0;
      }
      return h;
    } else
      return 0;
  }
}
function Z2(r) {
  return typeof r == "string" ? !1 : Array.isArray(r) ? r.every(Z2) : !!r.exclusive;
}
class TO {
  constructor(e, t, i, n) {
    this.uri = e, this.languageId = t, this.notebookUri = i, this.notebookType = n;
  }
  equals(e) {
    var t, i;
    return this.notebookType === e.notebookType && this.languageId === e.languageId && this.uri.toString() === e.uri.toString() && ((t = this.notebookUri) === null || t === void 0 ? void 0 : t.toString()) === ((i = e.notebookUri) === null || i === void 0 ? void 0 : i.toString());
  }
}
class ei {
  constructor(e) {
    this._notebookInfoResolver = e, this._clock = 0, this._entries = [], this._onDidChange = new R(), this.onDidChange = this._onDidChange.event;
  }
  register(e, t) {
    let i = {
      selector: e,
      provider: t,
      _score: -1,
      _time: this._clock++
    };
    return this._entries.push(i), this._lastCandidate = void 0, this._onDidChange.fire(this._entries.length), Se(() => {
      if (i) {
        const n = this._entries.indexOf(i);
        n >= 0 && (this._entries.splice(n, 1), this._lastCandidate = void 0, this._onDidChange.fire(this._entries.length), i = void 0);
      }
    });
  }
  has(e) {
    return this.all(e).length > 0;
  }
  all(e) {
    if (!e)
      return [];
    this._updateScores(e);
    const t = [];
    for (const i of this._entries)
      i._score > 0 && t.push(i.provider);
    return t;
  }
  ordered(e) {
    const t = [];
    return this._orderedForEach(e, (i) => t.push(i.provider)), t;
  }
  orderedGroups(e) {
    const t = [];
    let i, n;
    return this._orderedForEach(e, (s) => {
      i && n === s._score ? i.push(s.provider) : (n = s._score, i = [s.provider], t.push(i));
    }), t;
  }
  _orderedForEach(e, t) {
    this._updateScores(e);
    for (const i of this._entries)
      i._score > 0 && t(i);
  }
  _updateScores(e) {
    var t, i;
    const n = (t = this._notebookInfoResolver) === null || t === void 0 ? void 0 : t.call(this, e.uri), s = n ? new TO(e.uri, e.getLanguageId(), n.uri, n.type) : new TO(e.uri, e.getLanguageId(), void 0, void 0);
    if (!(!((i = this._lastCandidate) === null || i === void 0) && i.equals(s))) {
      this._lastCandidate = s;
      for (const o of this._entries)
        if (o._score = tM(o.selector, s.uri, s.languageId, nH(e), s.notebookUri, s.notebookType), Z2(o.selector) && o._score > 0) {
          for (const a of this._entries)
            a._score = 0;
          o._score = 1e3;
          break;
        }
      this._entries.sort(ei._compareByScoreAndTime);
    }
  }
  static _compareByScoreAndTime(e, t) {
    return e._score < t._score ? 1 : e._score > t._score ? -1 : Fm(e.selector) && !Fm(t.selector) ? 1 : !Fm(e.selector) && Fm(t.selector) ? -1 : e._time < t._time ? 1 : e._time > t._time ? -1 : 0;
  }
}
function Fm(r) {
  return typeof r == "string" ? !1 : Array.isArray(r) ? r.some(Fm) : !!r.isBuiltin;
}
class VJ {
  constructor() {
    this.referenceProvider = new ei(this._score.bind(this)), this.renameProvider = new ei(this._score.bind(this)), this.newSymbolNamesProvider = new ei(this._score.bind(this)), this.codeActionProvider = new ei(this._score.bind(this)), this.definitionProvider = new ei(this._score.bind(this)), this.typeDefinitionProvider = new ei(this._score.bind(this)), this.declarationProvider = new ei(this._score.bind(this)), this.implementationProvider = new ei(this._score.bind(this)), this.documentSymbolProvider = new ei(this._score.bind(this)), this.inlayHintsProvider = new ei(this._score.bind(this)), this.colorProvider = new ei(this._score.bind(this)), this.codeLensProvider = new ei(this._score.bind(this)), this.documentFormattingEditProvider = new ei(this._score.bind(this)), this.documentRangeFormattingEditProvider = new ei(this._score.bind(this)), this.onTypeFormattingEditProvider = new ei(this._score.bind(this)), this.signatureHelpProvider = new ei(this._score.bind(this)), this.hoverProvider = new ei(this._score.bind(this)), this.documentHighlightProvider = new ei(this._score.bind(this)), this.multiDocumentHighlightProvider = new ei(this._score.bind(this)), this.selectionRangeProvider = new ei(this._score.bind(this)), this.foldingRangeProvider = new ei(this._score.bind(this)), this.linkProvider = new ei(this._score.bind(this)), this.inlineCompletionsProvider = new ei(this._score.bind(this)), this.inlineEditProvider = new ei(this._score.bind(this)), this.completionProvider = new ei(this._score.bind(this)), this.linkedEditingRangeProvider = new ei(this._score.bind(this)), this.documentRangeSemanticTokensProvider = new ei(this._score.bind(this)), this.documentSemanticTokensProvider = new ei(this._score.bind(this)), this.documentDropEditProvider = new ei(this._score.bind(this)), this.documentPasteEditProvider = new ei(this._score.bind(this));
  }
  _score(e) {
    var t;
    return (t = this._notebookTypeResolver) === null || t === void 0 ? void 0 : t.call(this, e);
  }
}
ot(
  he,
  VJ,
  1
  /* InstantiationType.Delayed */
);
var zJ = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, NO = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
const gl = et("hoverService");
let Xf = class extends P {
  get delay() {
    return this.isInstantlyHovering() ? 0 : this._delay;
  }
  constructor(e, t, i = {}, n, s) {
    super(), this.placement = e, this.instantHover = t, this.overrideOptions = i, this.configurationService = n, this.hoverService = s, this.lastHoverHideTime = 0, this.timeLimit = 200, this.hoverDisposables = this._register(new q()), this._delay = this.configurationService.getValue("workbench.hover.delay"), this._register(this.configurationService.onDidChangeConfiguration((o) => {
      o.affectsConfiguration("workbench.hover.delay") && (this._delay = this.configurationService.getValue("workbench.hover.delay"));
    }));
  }
  showHover(e, t) {
    const i = typeof this.overrideOptions == "function" ? this.overrideOptions(e, t) : this.overrideOptions;
    this.hoverDisposables.clear();
    const n = ln(e.target) ? [e.target] : e.target.targetElements;
    for (const o of n)
      this.hoverDisposables.add(pi(o, "keydown", (a) => {
        a.equals(
          9
          /* KeyCode.Escape */
        ) && this.hoverService.hideHover();
      }));
    const s = ln(e.content) ? void 0 : e.content.toString();
    return this.hoverService.showHover({
      ...e,
      ...i,
      persistence: {
        hideOnKeyDown: !0,
        ...i.persistence
      },
      id: s,
      appearance: {
        ...e.appearance,
        compact: !0,
        skipFadeInAnimation: this.isInstantlyHovering(),
        ...i.appearance
      }
    }, t);
  }
  isInstantlyHovering() {
    return this.instantHover && Date.now() - this.lastHoverHideTime < this.timeLimit;
  }
  onDidHideHover() {
    this.hoverDisposables.clear(), this.instantHover && (this.lastHoverHideTime = Date.now());
  }
};
Xf = zJ([
  NO(3, Ge),
  NO(4, gl)
], Xf);
const Sd = et("contextViewService"), Zs = et("contextMenuService"), NC = X;
let iM = class extends P {
  constructor() {
    super(), this.containerDomNode = document.createElement("div"), this.containerDomNode.className = "monaco-hover", this.containerDomNode.tabIndex = 0, this.containerDomNode.setAttribute("role", "tooltip"), this.contentsDomNode = document.createElement("div"), this.contentsDomNode.className = "monaco-hover-content", this.scrollbar = this._register(new pb(this.contentsDomNode, {
      consumeMouseWheelIfScrollbarIsNeeded: !0
    })), this.containerDomNode.appendChild(this.scrollbar.getDomNode());
  }
  onContentsChanged() {
    this.scrollbar.scanDomNode();
  }
};
class B0 extends P {
  static render(e, t, i) {
    return new B0(e, t, i);
  }
  constructor(e, t, i) {
    super(), this.actionContainer = G(e, NC("div.action-container")), this.actionContainer.setAttribute("tabindex", "0"), this.action = G(this.actionContainer, NC("a.action")), this.action.setAttribute("role", "button"), t.iconClass && G(this.action, NC(`span.icon.${t.iconClass}`));
    const n = G(this.action, NC("span"));
    n.textContent = i ? `${t.label} (${i})` : t.label, this._store.add(new Q2(this.actionContainer, t.run)), this._store.add(new X2(this.actionContainer, t.run, [
      3,
      10
      /* KeyCode.Space */
    ])), this.setEnabled(!0);
  }
  setEnabled(e) {
    e ? (this.actionContainer.classList.remove("disabled"), this.actionContainer.removeAttribute("aria-disabled")) : (this.actionContainer.classList.add("disabled"), this.actionContainer.setAttribute("aria-disabled", "true"));
  }
}
function Y2(r, e) {
  return r && e ? p("acessibleViewHint", "Inspect this in the accessible view with {0}.", e) : r ? p("acessibleViewHintNoKbOpen", "Inspect this in the accessible view via the command Open Accessible View which is currently not triggerable via keybinding.") : "";
}
class Q2 extends P {
  constructor(e, t) {
    super(), this._register(W(e, Q.CLICK, (i) => {
      i.stopPropagation(), i.preventDefault(), t(e);
    }));
  }
}
class X2 extends P {
  constructor(e, t, i) {
    super(), this._register(W(e, Q.KEY_DOWN, (n) => {
      const s = new Mt(n);
      i.some((o) => s.equals(o)) && (n.stopPropagation(), n.preventDefault(), t(e));
    }));
  }
}
const Ys = et("openerService");
function UJ(r) {
  let e;
  const t = /^L?(\d+)(?:,(\d+))?(-L?(\d+)(?:,(\d+))?)?/.exec(r.fragment);
  return t && (e = {
    startLineNumber: parseInt(t[1]),
    startColumn: t[2] ? parseInt(t[2]) : 1,
    endLineNumber: t[4] ? parseInt(t[4]) : void 0,
    endColumn: t[4] ? t[5] ? parseInt(t[5]) : 1 : void 0
  }, r = r.with({ fragment: "" })), { selection: e, uri: r };
}
function $J(r, e = {}) {
  const t = nM(e);
  return t.textContent = r, t;
}
function KJ(r, e = {}) {
  const t = nM(e);
  return J2(t, qJ(r, !!e.renderCodeSegments), e.actionHandler, e.renderCodeSegments), t;
}
function nM(r) {
  const e = r.inline ? "span" : "div", t = document.createElement(e);
  return r.className && (t.className = r.className), t;
}
class jJ {
  constructor(e) {
    this.source = e, this.index = 0;
  }
  eos() {
    return this.index >= this.source.length;
  }
  next() {
    const e = this.peek();
    return this.advance(), e;
  }
  peek() {
    return this.source[this.index];
  }
  advance() {
    this.index++;
  }
}
function J2(r, e, t, i) {
  let n;
  if (e.type === 2)
    n = document.createTextNode(e.content || "");
  else if (e.type === 3)
    n = document.createElement("b");
  else if (e.type === 4)
    n = document.createElement("i");
  else if (e.type === 7 && i)
    n = document.createElement("code");
  else if (e.type === 5 && t) {
    const s = document.createElement("a");
    t.disposables.add(pi(s, "click", (o) => {
      t.callback(String(e.index), o);
    })), n = s;
  } else e.type === 8 ? n = document.createElement("br") : e.type === 1 && (n = r);
  n && r !== n && r.appendChild(n), n && Array.isArray(e.children) && e.children.forEach((s) => {
    J2(n, s, t, i);
  });
}
function qJ(r, e) {
  const t = {
    type: 1,
    children: []
  };
  let i = 0, n = t;
  const s = [], o = new jJ(r);
  for (; !o.eos(); ) {
    let a = o.next();
    const l = a === "\\" && LI(o.peek(), e) !== 0;
    if (l && (a = o.next()), !l && GJ(a, e) && a === o.peek()) {
      o.advance(), n.type === 2 && (n = s.pop());
      const d = LI(a, e);
      if (n.type === d || n.type === 5 && d === 6)
        n = s.pop();
      else {
        const c = {
          type: d,
          children: []
        };
        d === 5 && (c.index = i, i++), n.children.push(c), s.push(n), n = c;
      }
    } else if (a === `
`)
      n.type === 2 && (n = s.pop()), n.children.push({
        type: 8
        /* FormatType.NewLine */
      });
    else if (n.type !== 2) {
      const d = {
        type: 2,
        content: a
      };
      n.children.push(d), s.push(n), n = d;
    } else
      n.content += a;
  }
  return n.type === 2 && (n = s.pop()), t;
}
function GJ(r, e) {
  return LI(r, e) !== 0;
}
function LI(r, e) {
  switch (r) {
    case "*":
      return 3;
    case "_":
      return 4;
    case "[":
      return 5;
    case "]":
      return 6;
    case "`":
      return e ? 7 : 0;
    default:
      return 0;
  }
}
const ZJ = new RegExp(`(\\\\)?\\$\\((${Le.iconNameExpression}(?:${Le.iconModifierExpression})?)\\)`, "g");
function _c(r) {
  const e = new Array();
  let t, i = 0, n = 0;
  for (; (t = ZJ.exec(r)) !== null; ) {
    n = t.index || 0, i < n && e.push(r.substring(i, n)), i = (t.index || 0) + t[0].length;
    const [, s, o] = t;
    e.push(s ? `$(${o})` : Lu({ id: o }));
  }
  return i < r.length && e.push(r.substring(i)), e;
}
function Lu(r) {
  const e = X("span");
  return e.classList.add(...Le.asClassNameArray(r)), e;
}
function YJ(r) {
  const e = QJ(r);
  if (e && e.length > 0)
    return new Uint32Array(e);
}
let eo = 0;
const Zd = new Uint32Array(10);
function QJ(r) {
  if (eo = 0, fa(
    r,
    pk,
    4352
    /* HangulRangeStartCode.InitialConsonant */
  ), eo > 0 || (fa(
    r,
    mk,
    4449
    /* HangulRangeStartCode.Vowel */
  ), eo > 0) || (fa(
    r,
    _k,
    4520
    /* HangulRangeStartCode.FinalConsonant */
  ), eo > 0) || (fa(
    r,
    Ch,
    12593
    /* HangulRangeStartCode.CompatibilityJamo */
  ), eo))
    return Zd.subarray(0, eo);
  if (r >= 44032 && r <= 55203) {
    const e = r - 44032, t = e % 588, i = Math.floor(e / 588), n = Math.floor(t / 28), s = t % 28 - 1;
    if (i < pk.length ? fa(i, pk, 0) : 4352 + i - 12593 < Ch.length && fa(
      4352 + i,
      Ch,
      12593
      /* HangulRangeStartCode.CompatibilityJamo */
    ), n < mk.length ? fa(n, mk, 0) : 4449 + n - 12593 < Ch.length && fa(
      4449 + n - 12593,
      Ch,
      12593
      /* HangulRangeStartCode.CompatibilityJamo */
    ), s >= 0 && (s < _k.length ? fa(s, _k, 0) : 4520 + s - 12593 < Ch.length && fa(
      4520 + s - 12593,
      Ch,
      12593
      /* HangulRangeStartCode.CompatibilityJamo */
    )), eo > 0)
      return Zd.subarray(0, eo);
  }
}
function fa(r, e, t) {
  r >= t && r < t + e.length && XJ(e[r - t]);
}
function XJ(r) {
  r !== 0 && (Zd[eo++] = r & 255, r >> 8 && (Zd[eo++] = r >> 8 & 255), r >> 16 && (Zd[eo++] = r >> 16 & 255));
}
const pk = new Uint8Array([
  114,
  // 
  82,
  // 
  115,
  // 
  101,
  // 
  69,
  // 
  102,
  // 
  97,
  // 
  113,
  // 
  81,
  // 
  116,
  // 
  84,
  // 
  100,
  // 
  119,
  // 
  87,
  // 
  99,
  // 
  122,
  // 
  120,
  // 
  118,
  // 
  103
  // 
]), mk = new Uint16Array([
  107,
  //  -> 
  111,
  //  -> 
  105,
  //  -> 
  79,
  //  -> 
  106,
  //  -> 
  112,
  //  -> 
  117,
  //  -> 
  80,
  //  -> 
  104,
  //  -> 
  27496,
  //  -> 
  28520,
  //  -> 
  27752,
  //  -> 
  121,
  //  -> 
  110,
  //  -> 
  27246,
  //  -> 
  28782,
  //  -> 
  27758,
  //  -> 
  98,
  //  -> 
  109,
  //  -> 
  27757,
  //  -> 
  108
  //  -> 
]), _k = new Uint16Array([
  114,
  // 
  82,
  // 
  29810,
  // 
  115,
  // 
  30579,
  // 
  26483,
  // 
  101,
  // 
  102,
  // 
  29286,
  // 
  24934,
  // 
  29030,
  // 
  29798,
  // 
  30822,
  // 
  30310,
  // 
  26470,
  // 
  97,
  // 
  113,
  // 
  29809,
  // 
  116,
  // 
  84,
  // 
  100,
  // 
  119,
  // 
  99,
  // 
  122,
  // 
  120,
  // 
  118,
  // 
  103
  // 
]), Ch = new Uint16Array([
  114,
  // 
  82,
  // 
  29810,
  // 
  115,
  // 
  30579,
  // 
  26483,
  // 
  101,
  // 
  69,
  // 
  102,
  // 
  29286,
  // 
  24934,
  // 
  29030,
  // 
  29798,
  // 
  30822,
  // 
  30310,
  // 
  26470,
  // 
  97,
  // 
  113,
  // 
  81,
  // 
  29809,
  // 
  116,
  // 
  84,
  // 
  100,
  // 
  119,
  // 
  87,
  // 
  99,
  // 
  122,
  // 
  120,
  // 
  118,
  // 
  103,
  // 
  107,
  // 
  111,
  // 
  105,
  // 
  79,
  // 
  106,
  // 
  112,
  // 
  117,
  // 
  80,
  // 
  104,
  // 
  27496,
  // 
  28520,
  // 
  27752,
  // 
  121,
  // 
  110,
  // 
  27246,
  // 
  28782,
  // 
  27758,
  // 
  98,
  // 
  109,
  // 
  27757,
  // 
  108
  // 
  // HF: Hangul Filler (everything after this is archaic)
  // 
  // 
  // 
  // 
  // 
  // 
  // 
  // 
  // 
  // 
  // 
  // 
  // 
  // 
  // 
  // 
  // 
  // 
  // 
  // 
  // 
  // 
  // 
  // 
  // 
  // 
  // 
  // 
  // 
  // 
  // 
  // 
  // 
  // 
  // 
  // 
  // 
  // 
  // 
  // 
  // 
]);
function sM(...r) {
  return function(e, t) {
    for (let i = 0, n = r.length; i < n; i++) {
      const s = r[i](e, t);
      if (s)
        return s;
    }
    return null;
  };
}
ez.bind(void 0, !1);
const iv = ez.bind(void 0, !0);
function ez(r, e, t) {
  if (!t || t.length < e.length)
    return null;
  let i;
  return r ? i = BN(t, e) : i = t.indexOf(e) === 0, i ? e.length > 0 ? [{ start: 0, end: e.length }] : [] : null;
}
function tz(r, e) {
  const t = e.toLowerCase().indexOf(r.toLowerCase());
  return t === -1 ? null : [{ start: t, end: t + r.length }];
}
function iz(r, e) {
  return DI(r.toLowerCase(), e.toLowerCase(), 0, 0);
}
function DI(r, e, t, i) {
  if (t === r.length)
    return [];
  if (i === e.length)
    return null;
  if (r[t] === e[i]) {
    let n = null;
    return (n = DI(r, e, t + 1, i + 1)) ? aM({ start: i, end: i + 1 }, n) : null;
  }
  return DI(r, e, t, i + 1);
}
function oM(r) {
  return 97 <= r && r <= 122;
}
function H0(r) {
  return 65 <= r && r <= 90;
}
function rM(r) {
  return 48 <= r && r <= 57;
}
function nz(r) {
  return r === 32 || r === 9 || r === 10 || r === 13;
}
const sz = /* @__PURE__ */ new Set();
"()[]{}<>`'\"-/;:,.?!".split("").forEach((r) => sz.add(r.charCodeAt(0)));
function BS(r) {
  return nz(r) || sz.has(r);
}
function MO(r, e) {
  return r === e || BS(r) && BS(e);
}
const vk = /* @__PURE__ */ new Map();
function RO(r) {
  if (vk.has(r))
    return vk.get(r);
  let e;
  const t = YJ(r);
  return t && (e = t), vk.set(r, e), e;
}
function oz(r) {
  return oM(r) || H0(r) || rM(r);
}
function aM(r, e) {
  return e.length === 0 ? e = [r] : r.end === e[0].start ? e[0].start = r.start : e.unshift(r), e;
}
function rz(r, e) {
  for (let t = e; t < r.length; t++) {
    const i = r.charCodeAt(t);
    if (H0(i) || rM(i) || t > 0 && !oz(r.charCodeAt(t - 1)))
      return t;
  }
  return r.length;
}
function kI(r, e, t, i) {
  if (t === r.length)
    return [];
  if (i === e.length)
    return null;
  if (r[t] !== e[i].toLowerCase())
    return null;
  {
    let n = null, s = i + 1;
    for (n = kI(r, e, t + 1, i + 1); !n && (s = rz(e, s)) < e.length; )
      n = kI(r, e, t + 1, s), s++;
    return n === null ? null : aM({ start: i, end: i + 1 }, n);
  }
}
function JJ(r) {
  let e = 0, t = 0, i = 0, n = 0, s = 0;
  for (let c = 0; c < r.length; c++)
    s = r.charCodeAt(c), H0(s) && e++, oM(s) && t++, oz(s) && i++, rM(s) && n++;
  const o = e / r.length, a = t / r.length, l = i / r.length, d = n / r.length;
  return { upperPercent: o, lowerPercent: a, alphaPercent: l, numericPercent: d };
}
function eee(r) {
  const { upperPercent: e, lowerPercent: t } = r;
  return t === 0 && e > 0.6;
}
function tee(r) {
  const { upperPercent: e, lowerPercent: t, alphaPercent: i, numericPercent: n } = r;
  return t > 0.2 && e < 0.8 && i > 0.6 && n < 0.2;
}
function iee(r) {
  let e = 0, t = 0, i = 0, n = 0;
  for (let s = 0; s < r.length; s++)
    i = r.charCodeAt(s), H0(i) && e++, oM(i) && t++, nz(i) && n++;
  return (e === 0 || t === 0) && n === 0 ? r.length <= 30 : e <= 5;
}
function az(r, e) {
  if (!e || (e = e.trim(), e.length === 0) || !iee(r))
    return null;
  e.length > 60 && (e = e.substring(0, 60));
  const t = JJ(e);
  if (!tee(t)) {
    if (!eee(t))
      return null;
    e = e.toLowerCase();
  }
  let i = null, n = 0;
  for (r = r.toLowerCase(); n < e.length && (i = kI(r, e, 0, n)) === null; )
    n = rz(e, n + 1);
  return i;
}
function nee(r, e, t = !1) {
  if (!e || e.length === 0)
    return null;
  let i = null, n = 0;
  for (r = r.toLowerCase(), e = e.toLowerCase(); n < e.length && (i = xI(r, e, 0, n, t), i === null); )
    n = lz(e, n + 1);
  return i;
}
function xI(r, e, t, i, n) {
  let s = 0;
  if (t === r.length)
    return [];
  if (i === e.length)
    return null;
  if (!MO(r.charCodeAt(t), e.charCodeAt(i))) {
    const l = RO(r.charCodeAt(t));
    if (!l)
      return null;
    for (let d = 0; d < l.length; d++)
      if (!MO(l[d], e.charCodeAt(i + d)))
        return null;
    s += l.length - 1;
  }
  let o = null, a = i + s + 1;
  if (o = xI(r, e, t + 1, a, n), !n)
    for (; !o && (a = lz(e, a)) < e.length; )
      o = xI(r, e, t + 1, a, n), a++;
  if (!o)
    return null;
  if (r.charCodeAt(t) !== e.charCodeAt(i)) {
    const l = RO(r.charCodeAt(t));
    if (!l)
      return o;
    for (let d = 0; d < l.length; d++)
      if (l[d] !== e.charCodeAt(i + d))
        return o;
  }
  return aM({ start: i, end: i + s + 1 }, o);
}
function lz(r, e) {
  for (let t = e; t < r.length; t++)
    if (BS(r.charCodeAt(t)) || t > 0 && BS(r.charCodeAt(t - 1)))
      return t;
  return r.length;
}
const see = sM(iv, az, tz), oee = sM(iv, az, iz), AO = new Cd(1e4);
function PO(r, e, t = !1) {
  if (typeof r != "string" || typeof e != "string")
    return null;
  let i = AO.get(r);
  i || (i = new RegExp(P5(r), "i"), AO.set(r, i));
  const n = i.exec(e);
  return n ? [{ start: n.index, end: n.index + n[0].length }] : t ? oee(r, e) : see(r, e);
}
function ree(r, e) {
  const t = Du(r, r.toLowerCase(), 0, e, e.toLowerCase(), 0, { firstMatchCanBeWeak: !0, boostFullMatch: !0 });
  return t ? Sb(t) : null;
}
function aee(r, e, t, i, n, s) {
  const o = Math.min(13, r.length);
  for (; t < o; t++) {
    const a = Du(r, e, t, i, n, s, { firstMatchCanBeWeak: !0, boostFullMatch: !0 });
    if (a)
      return a;
  }
  return [0, s];
}
function Sb(r) {
  if (typeof r > "u")
    return [];
  const e = [], t = r[1];
  for (let i = r.length - 1; i > 1; i--) {
    const n = r[i] + t, s = e[e.length - 1];
    s && s.end === n ? s.end = n + 1 : e.push({ start: n, end: n + 1 });
  }
  return e;
}
const rc = 128;
function lM() {
  const r = [], e = [];
  for (let t = 0; t <= rc; t++)
    e[t] = 0;
  for (let t = 0; t <= rc; t++)
    r.push(e.slice(0));
  return r;
}
function dz(r) {
  const e = [];
  for (let t = 0; t <= r; t++)
    e[t] = 0;
  return e;
}
const cz = dz(2 * rc), II = dz(2 * rc), bl = lM(), wh = lM(), MC = lM();
function RC(r, e) {
  if (e < 0 || e >= r.length)
    return !1;
  const t = r.codePointAt(e);
  switch (t) {
    case 95:
    case 45:
    case 46:
    case 32:
    case 47:
    case 92:
    case 39:
    case 34:
    case 58:
    case 36:
    case 60:
    case 62:
    case 40:
    case 41:
    case 91:
    case 93:
    case 123:
    case 125:
      return !0;
    case void 0:
      return !1;
    default:
      return !!jB(t);
  }
}
function OO(r, e) {
  if (e < 0 || e >= r.length)
    return !1;
  switch (r.charCodeAt(e)) {
    case 32:
    case 9:
      return !0;
    default:
      return !1;
  }
}
function Bw(r, e, t) {
  return e[r] !== t[r];
}
function lee(r, e, t, i, n, s, o = !1) {
  for (; e < t && n < s; )
    r[e] === i[n] && (o && (cz[e] = n), e += 1), n += 1;
  return e === t;
}
var qr;
(function(r) {
  r.Default = [-100, 0];
  function e(t) {
    return !t || t.length === 2 && t[0] === -100 && t[1] === 0;
  }
  r.isDefault = e;
})(qr || (qr = {}));
class V0 {
  constructor(e, t) {
    this.firstMatchCanBeWeak = e, this.boostFullMatch = t;
  }
}
V0.default = { boostFullMatch: !0, firstMatchCanBeWeak: !1 };
function Du(r, e, t, i, n, s, o = V0.default) {
  const a = r.length > rc ? rc : r.length, l = i.length > rc ? rc : i.length;
  if (t >= a || s >= l || a - t > l - s || !lee(e, t, a, n, s, l, !0))
    return;
  dee(a, l, t, s, e, n);
  let d = 1, c = 1, h = t, u = s;
  const g = [!1];
  for (d = 1, h = t; h < a; d++, h++) {
    const b = cz[h], C = II[h], w = h + 1 < a ? II[h + 1] : l;
    for (c = b - s + 1, u = b; u < w; c++, u++) {
      let S = Number.MIN_SAFE_INTEGER, y = !1;
      u <= C && (S = cee(r, e, h, t, i, n, u, l, s, bl[d - 1][c - 1] === 0, g));
      let k = 0;
      S !== Number.MAX_SAFE_INTEGER && (y = !0, k = S + wh[d - 1][c - 1]);
      const E = u > b, N = E ? wh[d][c - 1] + (bl[d][c - 1] > 0 ? -5 : 0) : 0, F = u > b + 1 && bl[d][c - 1] > 0, V = F ? wh[d][c - 2] + (bl[d][c - 2] > 0 ? -5 : 0) : 0;
      if (F && (!E || V >= N) && (!y || V >= k))
        wh[d][c] = V, MC[d][c] = 3, bl[d][c] = 0;
      else if (E && (!y || N >= k))
        wh[d][c] = N, MC[d][c] = 2, bl[d][c] = 0;
      else if (y)
        wh[d][c] = k, MC[d][c] = 1, bl[d][c] = bl[d - 1][c - 1] + 1;
      else
        throw new Error("not possible");
    }
  }
  if (!g[0] && !o.firstMatchCanBeWeak)
    return;
  d--, c--;
  const f = [wh[d][c], s];
  let m = 0, _ = 0;
  for (; d >= 1; ) {
    let b = c;
    do {
      const C = MC[d][b];
      if (C === 3)
        b = b - 2;
      else if (C === 2)
        b = b - 1;
      else
        break;
    } while (b >= 1);
    m > 1 && e[t + d - 1] === n[s + c - 1] && !Bw(b + s - 1, i, n) && m + 1 > bl[d][b] && (b = c), b === c ? m++ : m = 1, _ || (_ = b), d--, c = b - 1, f.push(c);
  }
  l - s === a && o.boostFullMatch && (f[0] += 2);
  const v = _ - a;
  return f[0] -= v, f;
}
function dee(r, e, t, i, n, s) {
  let o = r - 1, a = e - 1;
  for (; o >= t && a >= i; )
    n[o] === s[a] && (II[o] = a, o--), a--;
}
function cee(r, e, t, i, n, s, o, a, l, d, c) {
  if (e[t] !== s[o])
    return Number.MIN_SAFE_INTEGER;
  let h = 1, u = !1;
  return o === t - i ? h = r[t] === n[o] ? 7 : 5 : Bw(o, n, s) && (o === 0 || !Bw(o - 1, n, s)) ? (h = r[t] === n[o] ? 7 : 5, u = !0) : RC(s, o) && (o === 0 || !RC(s, o - 1)) ? h = 5 : (RC(s, o - 1) || OO(s, o - 1)) && (h = 5, u = !0), h > 1 && t === i && (c[0] = !0), u || (u = Bw(o, n, s) || RC(s, o - 1) || OO(s, o - 1)), t === i ? o > l && (h -= u ? 3 : 5) : d ? h += u ? 2 : 0 : h += u ? 0 : 1, o + 1 === a && (h -= u ? 3 : 5), h;
}
function hee(r, e, t, i, n, s, o) {
  return uee(r, e, t, i, n, s, !0, o);
}
function uee(r, e, t, i, n, s, o, a) {
  let l = Du(r, e, t, i, n, s, a);
  if (l && !o)
    return l;
  if (r.length >= 3) {
    const d = Math.min(7, r.length - 1);
    for (let c = t + 1; c < d; c++) {
      const h = gee(r, c);
      if (h) {
        const u = Du(h, h.toLowerCase(), t, i, n, s, a);
        u && (u[0] -= 3, (!l || u[0] > l[0]) && (l = u));
      }
    }
  }
  return l;
}
function gee(r, e) {
  if (e + 1 >= r.length)
    return;
  const t = r[e], i = r[e + 1];
  if (t !== i)
    return r.slice(0, e) + i + t + r.slice(e + 2);
}
const fee = "$(", dM = new RegExp(`\\$\\(${Le.iconNameExpression}(?:${Le.iconModifierExpression})?\\)`, "g"), pee = new RegExp(`(\\\\)?${dM.source}`, "g");
function mee(r) {
  return r.replace(pee, (e, t) => t ? e : `\\${e}`);
}
const _ee = new RegExp(`\\\\${dM.source}`, "g");
function vee(r) {
  return r.replace(_ee, (e) => `\\${e}`);
}
const bee = new RegExp(`(\\s)?(\\\\)?${dM.source}(\\s)?`, "g");
function cM(r) {
  return r.indexOf(fee) === -1 ? r : r.replace(bee, (e, t, i, n) => i ? e : t || n || "");
}
function Cee(r) {
  return r ? r.replace(/\$\((.*?)\)/g, (e, t) => ` ${t} `).trim() : "";
}
const bk = new RegExp(`\\$\\(${Le.iconNameCharacter}+\\)`, "g");
function Wm(r) {
  bk.lastIndex = 0;
  let e = "";
  const t = [];
  let i = 0;
  for (; ; ) {
    const n = bk.lastIndex, s = bk.exec(r), o = r.substring(n, s == null ? void 0 : s.index);
    if (o.length > 0) {
      e += o;
      for (let a = 0; a < o.length; a++)
        t.push(i);
    }
    if (!s)
      break;
    i += s[0].length;
  }
  return { text: e, iconOffsets: t };
}
function Ck(r, e, t = !1) {
  const { text: i, iconOffsets: n } = e;
  if (!n || n.length === 0)
    return PO(r, i, t);
  const s = i0(i, " "), o = i.length - s.length, a = PO(r, s, t);
  if (a)
    for (const l of a) {
      const d = n[l.start + o] + o;
      l.start += d, l.end += d;
    }
  return a;
}
class Nn {
  constructor(e = "", t = !1) {
    var i, n, s;
    if (this.value = e, typeof this.value != "string")
      throw Ro("value");
    typeof t == "boolean" ? (this.isTrusted = t, this.supportThemeIcons = !1, this.supportHtml = !1) : (this.isTrusted = (i = t.isTrusted) !== null && i !== void 0 ? i : void 0, this.supportThemeIcons = (n = t.supportThemeIcons) !== null && n !== void 0 ? n : !1, this.supportHtml = (s = t.supportHtml) !== null && s !== void 0 ? s : !1);
  }
  appendText(e, t = 0) {
    return this.value += See(this.supportThemeIcons ? mee(e) : e).replace(/([ \t]+)/g, (i, n) => "&nbsp;".repeat(n.length)).replace(/\>/gm, "\\>").replace(/\n/g, t === 1 ? `\\
` : `

`), this;
  }
  appendMarkdown(e) {
    return this.value += e, this;
  }
  appendCodeblock(e, t) {
    return this.value += `
${yee(t, e)}
`, this;
  }
  appendLink(e, t, i) {
    return this.value += "[", this.value += this._escape(t, "]"), this.value += "](", this.value += this._escape(String(e), ")"), i && (this.value += ` "${this._escape(this._escape(i, '"'), ")")}"`), this.value += ")", this;
  }
  _escape(e, t) {
    const i = new RegExp(gr(t), "g");
    return e.replace(i, (n, s) => e.charAt(s - 1) !== "\\" ? `\\${n}` : n);
  }
}
function Jf(r) {
  return Gr(r) ? !r.value : Array.isArray(r) ? r.every(Jf) : !0;
}
function Gr(r) {
  return r instanceof Nn ? !0 : r && typeof r == "object" ? typeof r.value == "string" && (typeof r.isTrusted == "boolean" || typeof r.isTrusted == "object" || r.isTrusted === void 0) && (typeof r.supportThemeIcons == "boolean" || r.supportThemeIcons === void 0) : !1;
}
function wee(r, e) {
  return r === e ? !0 : !r || !e ? !1 : r.value === e.value && r.isTrusted === e.isTrusted && r.supportThemeIcons === e.supportThemeIcons && r.supportHtml === e.supportHtml && (r.baseUri === e.baseUri || !!r.baseUri && !!e.baseUri && B1(Ee.from(r.baseUri), Ee.from(e.baseUri)));
}
function See(r) {
  return r.replace(/[\\`*_{}[\]()#+\-!~]/g, "\\$&");
}
function yee(r, e) {
  var t, i;
  const n = (i = (t = r.match(/^`+/gm)) === null || t === void 0 ? void 0 : t.reduce((o, a) => o.length > a.length ? o : a).length) !== null && i !== void 0 ? i : 0, s = n >= 3 ? n + 1 : 3;
  return [
    `${"`".repeat(s)}${e}`,
    r,
    `${"`".repeat(s)}`
  ].join(`
`);
}
function AC(r) {
  return r.replace(/"/g, "&quot;");
}
function wk(r) {
  return r && r.replace(/\\([\\`*_{}[\]()#+\-.!~])/g, "$1");
}
function Lee(r) {
  const e = [], t = r.split("|").map((n) => n.trim());
  r = t[0];
  const i = t[1];
  if (i) {
    const n = /height=(\d+)/.exec(i), s = /width=(\d+)/.exec(i), o = n ? n[1] : "", a = s ? s[1] : "", l = isFinite(parseInt(a)), d = isFinite(parseInt(o));
    l && e.push(`width="${a}"`), d && e.push(`height="${o}"`);
  }
  return { href: r, dimensions: e };
}
class hM {
  constructor(e) {
    this._prefix = e, this._lastId = 0;
  }
  nextId() {
    return this._prefix + ++this._lastId;
  }
}
const EI = new hM("id#");
let hs = {};
(function() {
  function r(e, t) {
    t(hs);
  }
  r.amd = !0, function(e, t) {
    typeof r == "function" && r.amd ? r(["exports"], t) : typeof exports == "object" && typeof module < "u" ? t(exports) : (e = typeof globalThis < "u" ? globalThis : e || self, t(e.marked = {}));
  }(this, function(e) {
    function t(te, j) {
      for (var $ = 0; $ < j.length; $++) {
        var T = j[$];
        T.enumerable = T.enumerable || !1, T.configurable = !0, "value" in T && (T.writable = !0), Object.defineProperty(te, T.key, T);
      }
    }
    function i(te, j, $) {
      return $ && t(te, $), Object.defineProperty(te, "prototype", {
        writable: !1
      }), te;
    }
    function n(te, j) {
      if (te) {
        if (typeof te == "string") return s(te, j);
        var $ = Object.prototype.toString.call(te).slice(8, -1);
        if ($ === "Object" && te.constructor && ($ = te.constructor.name), $ === "Map" || $ === "Set") return Array.from(te);
        if ($ === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test($)) return s(te, j);
      }
    }
    function s(te, j) {
      (j == null || j > te.length) && (j = te.length);
      for (var $ = 0, T = new Array(j); $ < j; $++) T[$] = te[$];
      return T;
    }
    function o(te, j) {
      var $ = typeof Symbol < "u" && te[Symbol.iterator] || te["@@iterator"];
      if ($) return ($ = $.call(te)).next.bind($);
      if (Array.isArray(te) || ($ = n(te)) || j) {
        $ && (te = $);
        var T = 0;
        return function() {
          return T >= te.length ? {
            done: !0
          } : {
            done: !1,
            value: te[T++]
          };
        };
      }
      throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    function a() {
      return {
        async: !1,
        baseUrl: null,
        breaks: !1,
        extensions: null,
        gfm: !0,
        headerIds: !0,
        headerPrefix: "",
        highlight: null,
        langPrefix: "language-",
        mangle: !0,
        pedantic: !1,
        renderer: null,
        sanitize: !1,
        sanitizer: null,
        silent: !1,
        smartLists: !1,
        smartypants: !1,
        tokenizer: null,
        walkTokens: null,
        xhtml: !1
      };
    }
    e.defaults = a();
    function l(te) {
      e.defaults = te;
    }
    var d = /[&<>"']/, c = /[&<>"']/g, h = /[<>"']|&(?!#?\w+;)/, u = /[<>"']|&(?!#?\w+;)/g, g = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    }, f = function(j) {
      return g[j];
    };
    function m(te, j) {
      if (j) {
        if (d.test(te))
          return te.replace(c, f);
      } else if (h.test(te))
        return te.replace(u, f);
      return te;
    }
    var _ = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;
    function v(te) {
      return te.replace(_, function(j, $) {
        return $ = $.toLowerCase(), $ === "colon" ? ":" : $.charAt(0) === "#" ? $.charAt(1) === "x" ? String.fromCharCode(parseInt($.substring(2), 16)) : String.fromCharCode(+$.substring(1)) : "";
      });
    }
    var b = /(^|[^\[])\^/g;
    function C(te, j) {
      te = typeof te == "string" ? te : te.source, j = j || "";
      var $ = {
        replace: function(M, B) {
          return B = B.source || B, B = B.replace(b, "$1"), te = te.replace(M, B), $;
        },
        getRegex: function() {
          return new RegExp(te, j);
        }
      };
      return $;
    }
    var w = /[^\w:]/g, S = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;
    function y(te, j, $) {
      if (te) {
        var T;
        try {
          T = decodeURIComponent(v($)).replace(w, "").toLowerCase();
        } catch {
          return null;
        }
        if (T.indexOf("javascript:") === 0 || T.indexOf("vbscript:") === 0 || T.indexOf("data:") === 0)
          return null;
      }
      j && !S.test($) && ($ = V(j, $));
      try {
        $ = encodeURI($).replace(/%25/g, "%");
      } catch {
        return null;
      }
      return $;
    }
    var k = {}, E = /^[^:]+:\/*[^/]*$/, N = /^([^:]+:)[\s\S]*$/, F = /^([^:]+:\/*[^/]*)[\s\S]*$/;
    function V(te, j) {
      k[" " + te] || (E.test(te) ? k[" " + te] = te + "/" : k[" " + te] = ue(te, "/", !0)), te = k[" " + te];
      var $ = te.indexOf(":") === -1;
      return j.substring(0, 2) === "//" ? $ ? j : te.replace(N, "$1") + j : j.charAt(0) === "/" ? $ ? j : te.replace(F, "$1") + j : te + j;
    }
    var Z = {
      exec: function() {
      }
    };
    function H(te) {
      for (var j = 1, $, T; j < arguments.length; j++) {
        $ = arguments[j];
        for (T in $)
          Object.prototype.hasOwnProperty.call($, T) && (te[T] = $[T]);
      }
      return te;
    }
    function re(te, j) {
      var $ = te.replace(/\|/g, function(B, O, ee) {
        for (var de = !1, ye = O; --ye >= 0 && ee[ye] === "\\"; )
          de = !de;
        return de ? "|" : " |";
      }), T = $.split(/ \|/), M = 0;
      if (T[0].trim() || T.shift(), T.length > 0 && !T[T.length - 1].trim() && T.pop(), T.length > j)
        T.splice(j);
      else
        for (; T.length < j; )
          T.push("");
      for (; M < T.length; M++)
        T[M] = T[M].trim().replace(/\\\|/g, "|");
      return T;
    }
    function ue(te, j, $) {
      var T = te.length;
      if (T === 0)
        return "";
      for (var M = 0; M < T; ) {
        var B = te.charAt(T - M - 1);
        if (B === j && !$)
          M++;
        else if (B !== j && $)
          M++;
        else
          break;
      }
      return te.slice(0, T - M);
    }
    function Ve(te, j) {
      if (te.indexOf(j[1]) === -1)
        return -1;
      for (var $ = te.length, T = 0, M = 0; M < $; M++)
        if (te[M] === "\\")
          M++;
        else if (te[M] === j[0])
          T++;
        else if (te[M] === j[1] && (T--, T < 0))
          return M;
      return -1;
    }
    function Ye(te) {
      te && te.sanitize && !te.silent && console.warn("marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options");
    }
    function ze(te, j) {
      if (j < 1)
        return "";
      for (var $ = ""; j > 1; )
        j & 1 && ($ += te), j >>= 1, te += te;
      return $ + te;
    }
    function pe(te, j, $, T) {
      var M = j.href, B = j.title ? m(j.title) : null, O = te[1].replace(/\\([\[\]])/g, "$1");
      if (te[0].charAt(0) !== "!") {
        T.state.inLink = !0;
        var ee = {
          type: "link",
          raw: $,
          href: M,
          title: B,
          text: O,
          tokens: T.inlineTokens(O)
        };
        return T.state.inLink = !1, ee;
      }
      return {
        type: "image",
        raw: $,
        href: M,
        title: B,
        text: m(O)
      };
    }
    function $e(te, j) {
      var $ = te.match(/^(\s+)(?:```)/);
      if ($ === null)
        return j;
      var T = $[1];
      return j.split(`
`).map(function(M) {
        var B = M.match(/^\s+/);
        if (B === null)
          return M;
        var O = B[0];
        return O.length >= T.length ? M.slice(T.length) : M;
      }).join(`
`);
    }
    var Be = /* @__PURE__ */ function() {
      function te($) {
        this.options = $ || e.defaults;
      }
      var j = te.prototype;
      return j.space = function(T) {
        var M = this.rules.block.newline.exec(T);
        if (M && M[0].length > 0)
          return {
            type: "space",
            raw: M[0]
          };
      }, j.code = function(T) {
        var M = this.rules.block.code.exec(T);
        if (M) {
          var B = M[0].replace(/^ {1,4}/gm, "");
          return {
            type: "code",
            raw: M[0],
            codeBlockStyle: "indented",
            text: this.options.pedantic ? B : ue(B, `
`)
          };
        }
      }, j.fences = function(T) {
        var M = this.rules.block.fences.exec(T);
        if (M) {
          var B = M[0], O = $e(B, M[3] || "");
          return {
            type: "code",
            raw: B,
            lang: M[2] ? M[2].trim() : M[2],
            text: O
          };
        }
      }, j.heading = function(T) {
        var M = this.rules.block.heading.exec(T);
        if (M) {
          var B = M[2].trim();
          if (/#$/.test(B)) {
            var O = ue(B, "#");
            (this.options.pedantic || !O || / $/.test(O)) && (B = O.trim());
          }
          return {
            type: "heading",
            raw: M[0],
            depth: M[1].length,
            text: B,
            tokens: this.lexer.inline(B)
          };
        }
      }, j.hr = function(T) {
        var M = this.rules.block.hr.exec(T);
        if (M)
          return {
            type: "hr",
            raw: M[0]
          };
      }, j.blockquote = function(T) {
        var M = this.rules.block.blockquote.exec(T);
        if (M) {
          var B = M[0].replace(/^ *>[ \t]?/gm, "");
          return {
            type: "blockquote",
            raw: M[0],
            tokens: this.lexer.blockTokens(B, []),
            text: B
          };
        }
      }, j.list = function(T) {
        var M = this.rules.block.list.exec(T);
        if (M) {
          var B, O, ee, de, ye, Ie, Ze, Ke, Ft, It, Oe, vi, bi = M[1].trim(), Go = bi.length > 1, St = {
            type: "list",
            raw: "",
            ordered: Go,
            start: Go ? +bi.slice(0, -1) : "",
            loose: !1,
            items: []
          };
          bi = Go ? "\\d{1,9}\\" + bi.slice(-1) : "\\" + bi, this.options.pedantic && (bi = Go ? bi : "[*+-]");
          for (var Wi = new RegExp("^( {0,3}" + bi + ")((?:[	 ][^\\n]*)?(?:\\n|$))"); T && (vi = !1, !(!(M = Wi.exec(T)) || this.rules.block.hr.test(T))); ) {
            if (B = M[0], T = T.substring(B.length), Ke = M[2].split(`
`, 1)[0], Ft = T.split(`
`, 1)[0], this.options.pedantic ? (de = 2, Oe = Ke.trimLeft()) : (de = M[2].search(/[^ ]/), de = de > 4 ? 1 : de, Oe = Ke.slice(de), de += M[1].length), Ie = !1, !Ke && /^ *$/.test(Ft) && (B += Ft + `
`, T = T.substring(Ft.length + 1), vi = !0), !vi)
              for (var uh = new RegExp("^ {0," + Math.min(3, de - 1) + "}(?:[*+-]|\\d{1,9}[.)])((?: [^\\n]*)?(?:\\n|$))"), gh = new RegExp("^ {0," + Math.min(3, de - 1) + "}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)"), wr = new RegExp("^ {0," + Math.min(3, de - 1) + "}(?:```|~~~)"), Ed = new RegExp("^ {0," + Math.min(3, de - 1) + "}#"); T && (It = T.split(`
`, 1)[0], Ke = It, this.options.pedantic && (Ke = Ke.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ")), !(wr.test(Ke) || Ed.test(Ke) || uh.test(Ke) || gh.test(T))); ) {
                if (Ke.search(/[^ ]/) >= de || !Ke.trim())
                  Oe += `
` + Ke.slice(de);
                else if (!Ie)
                  Oe += `
` + Ke;
                else
                  break;
                !Ie && !Ke.trim() && (Ie = !0), B += It + `
`, T = T.substring(It.length + 1);
              }
            St.loose || (Ze ? St.loose = !0 : /\n *\n *$/.test(B) && (Ze = !0)), this.options.gfm && (O = /^\[[ xX]\] /.exec(Oe), O && (ee = O[0] !== "[ ] ", Oe = Oe.replace(/^\[[ xX]\] +/, ""))), St.items.push({
              type: "list_item",
              raw: B,
              task: !!O,
              checked: ee,
              loose: !1,
              text: Oe
            }), St.raw += B;
          }
          St.items[St.items.length - 1].raw = B.trimRight(), St.items[St.items.length - 1].text = Oe.trimRight(), St.raw = St.raw.trimRight();
          var fh = St.items.length;
          for (ye = 0; ye < fh; ye++) {
            this.lexer.state.top = !1, St.items[ye].tokens = this.lexer.blockTokens(St.items[ye].text, []);
            var ph = St.items[ye].tokens.filter(function(mh) {
              return mh.type === "space";
            }), gg = ph.every(function(mh) {
              for (var mD = mh.raw.split(""), ha = 0, Gp = o(mD), Zp; !(Zp = Gp()).done; ) {
                var Qb = Zp.value;
                if (Qb === `
` && (ha += 1), ha > 1)
                  return !0;
              }
              return !1;
            });
            !St.loose && ph.length && gg && (St.loose = !0, St.items[ye].loose = !0);
          }
          return St;
        }
      }, j.html = function(T) {
        var M = this.rules.block.html.exec(T);
        if (M) {
          var B = {
            type: "html",
            raw: M[0],
            pre: !this.options.sanitizer && (M[1] === "pre" || M[1] === "script" || M[1] === "style"),
            text: M[0]
          };
          if (this.options.sanitize) {
            var O = this.options.sanitizer ? this.options.sanitizer(M[0]) : m(M[0]);
            B.type = "paragraph", B.text = O, B.tokens = this.lexer.inline(O);
          }
          return B;
        }
      }, j.def = function(T) {
        var M = this.rules.block.def.exec(T);
        if (M) {
          M[3] && (M[3] = M[3].substring(1, M[3].length - 1));
          var B = M[1].toLowerCase().replace(/\s+/g, " ");
          return {
            type: "def",
            tag: B,
            raw: M[0],
            href: M[2],
            title: M[3]
          };
        }
      }, j.table = function(T) {
        var M = this.rules.block.table.exec(T);
        if (M) {
          var B = {
            type: "table",
            header: re(M[1]).map(function(Ze) {
              return {
                text: Ze
              };
            }),
            align: M[2].replace(/^ *|\| *$/g, "").split(/ *\| */),
            rows: M[3] && M[3].trim() ? M[3].replace(/\n[ \t]*$/, "").split(`
`) : []
          };
          if (B.header.length === B.align.length) {
            B.raw = M[0];
            var O = B.align.length, ee, de, ye, Ie;
            for (ee = 0; ee < O; ee++)
              /^ *-+: *$/.test(B.align[ee]) ? B.align[ee] = "right" : /^ *:-+: *$/.test(B.align[ee]) ? B.align[ee] = "center" : /^ *:-+ *$/.test(B.align[ee]) ? B.align[ee] = "left" : B.align[ee] = null;
            for (O = B.rows.length, ee = 0; ee < O; ee++)
              B.rows[ee] = re(B.rows[ee], B.header.length).map(function(Ze) {
                return {
                  text: Ze
                };
              });
            for (O = B.header.length, de = 0; de < O; de++)
              B.header[de].tokens = this.lexer.inline(B.header[de].text);
            for (O = B.rows.length, de = 0; de < O; de++)
              for (Ie = B.rows[de], ye = 0; ye < Ie.length; ye++)
                Ie[ye].tokens = this.lexer.inline(Ie[ye].text);
            return B;
          }
        }
      }, j.lheading = function(T) {
        var M = this.rules.block.lheading.exec(T);
        if (M)
          return {
            type: "heading",
            raw: M[0],
            depth: M[2].charAt(0) === "=" ? 1 : 2,
            text: M[1],
            tokens: this.lexer.inline(M[1])
          };
      }, j.paragraph = function(T) {
        var M = this.rules.block.paragraph.exec(T);
        if (M) {
          var B = M[1].charAt(M[1].length - 1) === `
` ? M[1].slice(0, -1) : M[1];
          return {
            type: "paragraph",
            raw: M[0],
            text: B,
            tokens: this.lexer.inline(B)
          };
        }
      }, j.text = function(T) {
        var M = this.rules.block.text.exec(T);
        if (M)
          return {
            type: "text",
            raw: M[0],
            text: M[0],
            tokens: this.lexer.inline(M[0])
          };
      }, j.escape = function(T) {
        var M = this.rules.inline.escape.exec(T);
        if (M)
          return {
            type: "escape",
            raw: M[0],
            text: m(M[1])
          };
      }, j.tag = function(T) {
        var M = this.rules.inline.tag.exec(T);
        if (M)
          return !this.lexer.state.inLink && /^<a /i.test(M[0]) ? this.lexer.state.inLink = !0 : this.lexer.state.inLink && /^<\/a>/i.test(M[0]) && (this.lexer.state.inLink = !1), !this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(M[0]) ? this.lexer.state.inRawBlock = !0 : this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(M[0]) && (this.lexer.state.inRawBlock = !1), {
            type: this.options.sanitize ? "text" : "html",
            raw: M[0],
            inLink: this.lexer.state.inLink,
            inRawBlock: this.lexer.state.inRawBlock,
            text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(M[0]) : m(M[0]) : M[0]
          };
      }, j.link = function(T) {
        var M = this.rules.inline.link.exec(T);
        if (M) {
          var B = M[2].trim();
          if (!this.options.pedantic && /^</.test(B)) {
            if (!/>$/.test(B))
              return;
            var O = ue(B.slice(0, -1), "\\");
            if ((B.length - O.length) % 2 === 0)
              return;
          } else {
            var ee = Ve(M[2], "()");
            if (ee > -1) {
              var de = M[0].indexOf("!") === 0 ? 5 : 4, ye = de + M[1].length + ee;
              M[2] = M[2].substring(0, ee), M[0] = M[0].substring(0, ye).trim(), M[3] = "";
            }
          }
          var Ie = M[2], Ze = "";
          if (this.options.pedantic) {
            var Ke = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(Ie);
            Ke && (Ie = Ke[1], Ze = Ke[3]);
          } else
            Ze = M[3] ? M[3].slice(1, -1) : "";
          return Ie = Ie.trim(), /^</.test(Ie) && (this.options.pedantic && !/>$/.test(B) ? Ie = Ie.slice(1) : Ie = Ie.slice(1, -1)), pe(M, {
            href: Ie && Ie.replace(this.rules.inline._escapes, "$1"),
            title: Ze && Ze.replace(this.rules.inline._escapes, "$1")
          }, M[0], this.lexer);
        }
      }, j.reflink = function(T, M) {
        var B;
        if ((B = this.rules.inline.reflink.exec(T)) || (B = this.rules.inline.nolink.exec(T))) {
          var O = (B[2] || B[1]).replace(/\s+/g, " ");
          if (O = M[O.toLowerCase()], !O || !O.href) {
            var ee = B[0].charAt(0);
            return {
              type: "text",
              raw: ee,
              text: ee
            };
          }
          return pe(B, O, B[0], this.lexer);
        }
      }, j.emStrong = function(T, M, B) {
        B === void 0 && (B = "");
        var O = this.rules.inline.emStrong.lDelim.exec(T);
        if (O && !(O[3] && B.match(/(?:[0-9A-Za-z\xAA\xB2\xB3\xB5\xB9\xBA\xBC-\xBE\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u0660-\u0669\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07C0-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0966-\u096F\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09E6-\u09F1\u09F4-\u09F9\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A66-\u0A6F\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AE6-\u0AEF\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B66-\u0B6F\u0B71-\u0B77\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0BE6-\u0BF2\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C66-\u0C6F\u0C78-\u0C7E\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CE6-\u0CEF\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D58-\u0D61\u0D66-\u0D78\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DE6-\u0DEF\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F20-\u0F33\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F-\u1049\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u1090-\u1099\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1369-\u137C\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A16\u1A20-\u1A54\u1A80-\u1A89\u1A90-\u1A99\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B50-\u1B59\u1B83-\u1BA0\u1BAE-\u1BE5\u1C00-\u1C23\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2070\u2071\u2074-\u2079\u207F-\u2089\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2150-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2CFD\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u3192-\u3195\u31A0-\u31BF\u31F0-\u31FF\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA830-\uA835\uA840-\uA873\uA882-\uA8B3\uA8D0-\uA8D9\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA900-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF-\uA9D9\uA9E0-\uA9E4\uA9E6-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA50-\uAA59\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD07-\uDD33\uDD40-\uDD78\uDD8A\uDD8B\uDE80-\uDE9C\uDEA0-\uDED0\uDEE1-\uDEFB\uDF00-\uDF23\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC58-\uDC76\uDC79-\uDC9E\uDCA7-\uDCAF\uDCE0-\uDCF2\uDCF4\uDCF5\uDCFB-\uDD1B\uDD20-\uDD39\uDD80-\uDDB7\uDDBC-\uDDCF\uDDD2-\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE40-\uDE48\uDE60-\uDE7E\uDE80-\uDE9F\uDEC0-\uDEC7\uDEC9-\uDEE4\uDEEB-\uDEEF\uDF00-\uDF35\uDF40-\uDF55\uDF58-\uDF72\uDF78-\uDF91\uDFA9-\uDFAF]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDCFA-\uDD23\uDD30-\uDD39\uDE60-\uDE7E\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF27\uDF30-\uDF45\uDF51-\uDF54\uDF70-\uDF81\uDFB0-\uDFCB\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC52-\uDC6F\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD03-\uDD26\uDD36-\uDD3F\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDD0-\uDDDA\uDDDC\uDDE1-\uDDF4\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDEF0-\uDEF9\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC50-\uDC59\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE50-\uDE59\uDE80-\uDEAA\uDEB8\uDEC0-\uDEC9\uDF00-\uDF1A\uDF30-\uDF3B\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCF2\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDD50-\uDD59\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC50-\uDC6C\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD50-\uDD59\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDDA0-\uDDA9\uDEE0-\uDEF2\uDFB0\uDFC0-\uDFD4]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDE70-\uDEBE\uDEC0-\uDEC9\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF50-\uDF59\uDF5B-\uDF61\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE96\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD834[\uDEE0-\uDEF3\uDF60-\uDF78]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD837[\uDF00-\uDF1E]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD40-\uDD49\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB\uDEF0-\uDEF9]|\uD839[\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDCC7-\uDCCF\uDD00-\uDD43\uDD4B\uDD50-\uDD59]|\uD83B[\uDC71-\uDCAB\uDCAD-\uDCAF\uDCB1-\uDCB4\uDD01-\uDD2D\uDD2F-\uDD3D\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD83C[\uDD00-\uDD0C]|\uD83E[\uDFF0-\uDFF9]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF38\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A])/))) {
          var ee = O[1] || O[2] || "";
          if (!ee || ee && (B === "" || this.rules.inline.punctuation.exec(B))) {
            var de = O[0].length - 1, ye, Ie, Ze = de, Ke = 0, Ft = O[0][0] === "*" ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;
            for (Ft.lastIndex = 0, M = M.slice(-1 * T.length + de); (O = Ft.exec(M)) != null; )
              if (ye = O[1] || O[2] || O[3] || O[4] || O[5] || O[6], !!ye) {
                if (Ie = ye.length, O[3] || O[4]) {
                  Ze += Ie;
                  continue;
                } else if ((O[5] || O[6]) && de % 3 && !((de + Ie) % 3)) {
                  Ke += Ie;
                  continue;
                }
                if (Ze -= Ie, !(Ze > 0)) {
                  if (Ie = Math.min(Ie, Ie + Ze + Ke), Math.min(de, Ie) % 2) {
                    var It = T.slice(1, de + O.index + Ie);
                    return {
                      type: "em",
                      raw: T.slice(0, de + O.index + Ie + 1),
                      text: It,
                      tokens: this.lexer.inlineTokens(It)
                    };
                  }
                  var Oe = T.slice(2, de + O.index + Ie - 1);
                  return {
                    type: "strong",
                    raw: T.slice(0, de + O.index + Ie + 1),
                    text: Oe,
                    tokens: this.lexer.inlineTokens(Oe)
                  };
                }
              }
          }
        }
      }, j.codespan = function(T) {
        var M = this.rules.inline.code.exec(T);
        if (M) {
          var B = M[2].replace(/\n/g, " "), O = /[^ ]/.test(B), ee = /^ /.test(B) && / $/.test(B);
          return O && ee && (B = B.substring(1, B.length - 1)), B = m(B, !0), {
            type: "codespan",
            raw: M[0],
            text: B
          };
        }
      }, j.br = function(T) {
        var M = this.rules.inline.br.exec(T);
        if (M)
          return {
            type: "br",
            raw: M[0]
          };
      }, j.del = function(T) {
        var M = this.rules.inline.del.exec(T);
        if (M)
          return {
            type: "del",
            raw: M[0],
            text: M[2],
            tokens: this.lexer.inlineTokens(M[2])
          };
      }, j.autolink = function(T, M) {
        var B = this.rules.inline.autolink.exec(T);
        if (B) {
          var O, ee;
          return B[2] === "@" ? (O = m(this.options.mangle ? M(B[1]) : B[1]), ee = "mailto:" + O) : (O = m(B[1]), ee = O), {
            type: "link",
            raw: B[0],
            text: O,
            href: ee,
            tokens: [{
              type: "text",
              raw: O,
              text: O
            }]
          };
        }
      }, j.url = function(T, M) {
        var B;
        if (B = this.rules.inline.url.exec(T)) {
          var O, ee;
          if (B[2] === "@")
            O = m(this.options.mangle ? M(B[0]) : B[0]), ee = "mailto:" + O;
          else {
            var de;
            do
              de = B[0], B[0] = this.rules.inline._backpedal.exec(B[0])[0];
            while (de !== B[0]);
            O = m(B[0]), B[1] === "www." ? ee = "http://" + O : ee = O;
          }
          return {
            type: "link",
            raw: B[0],
            text: O,
            href: ee,
            tokens: [{
              type: "text",
              raw: O,
              text: O
            }]
          };
        }
      }, j.inlineText = function(T, M) {
        var B = this.rules.inline.text.exec(T);
        if (B) {
          var O;
          return this.lexer.state.inRawBlock ? O = this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(B[0]) : m(B[0]) : B[0] : O = m(this.options.smartypants ? M(B[0]) : B[0]), {
            type: "text",
            raw: B[0],
            text: O
          };
        }
      }, te;
    }(), Te = {
      newline: /^(?: *(?:\n|$))+/,
      code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
      fences: /^ {0,3}(`{3,}(?=[^`\n]*\n)|~{3,})([^\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?=\n|$)|$)/,
      hr: /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/,
      heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
      blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
      list: /^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/,
      html: "^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))",
      def: /^ {0,3}\[(label)\]: *(?:\n *)?<?([^\s>]+)>?(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/,
      table: Z,
      lheading: /^([^\n]+)\n {0,3}(=+|-+) *(?:\n+|$)/,
      // regex template, placeholders will be replaced according to different paragraph
      // interruption rules of commonmark and the original markdown spec:
      _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,
      text: /^[^\n]+/
    };
    Te._label = /(?!\s*\])(?:\\.|[^\[\]\\])+/, Te._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/, Te.def = C(Te.def).replace("label", Te._label).replace("title", Te._title).getRegex(), Te.bullet = /(?:[*+-]|\d{1,9}[.)])/, Te.listItemStart = C(/^( *)(bull) */).replace("bull", Te.bullet).getRegex(), Te.list = C(Te.list).replace(/bull/g, Te.bullet).replace("hr", "\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))").replace("def", "\\n+(?=" + Te.def.source + ")").getRegex(), Te._tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul", Te._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/, Te.html = C(Te.html, "i").replace("comment", Te._comment).replace("tag", Te._tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex(), Te.paragraph = C(Te._paragraph).replace("hr", Te.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", Te._tag).getRegex(), Te.blockquote = C(Te.blockquote).replace("paragraph", Te.paragraph).getRegex(), Te.normal = H({}, Te), Te.gfm = H({}, Te.normal, {
      table: "^ *([^\\n ].*\\|.*)\\n {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)(?:\\| *)?(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)"
      // Cells
    }), Te.gfm.table = C(Te.gfm.table).replace("hr", Te.hr).replace("heading", " {0,3}#{1,6} ").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", Te._tag).getRegex(), Te.gfm.paragraph = C(Te._paragraph).replace("hr", Te.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("table", Te.gfm.table).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", Te._tag).getRegex(), Te.pedantic = H({}, Te.normal, {
      html: C(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", Te._comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
      def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
      heading: /^(#{1,6})(.*)(?:\n+|$)/,
      fences: Z,
      // fences not supported
      paragraph: C(Te.normal._paragraph).replace("hr", Te.hr).replace("heading", ` *#{1,6} *[^
]`).replace("lheading", Te.lheading).replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").getRegex()
    });
    var ce = {
      escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
      autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
      url: Z,
      tag: "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",
      // CDATA section
      link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
      reflink: /^!?\[(label)\]\[(ref)\]/,
      nolink: /^!?\[(ref)\](?:\[\])?/,
      reflinkSearch: "reflink|nolink(?!\\()",
      emStrong: {
        lDelim: /^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/,
        //        (1) and (2) can only be a Right Delimiter. (3) and (4) can only be Left.  (5) and (6) can be either Left or Right.
        //          () Skip orphan inside strong  () Consume to delim (1) #***                (2) a***#, a***                   (3) #***a, ***a                 (4) ***#              (5) #***#                 (6) a***a
        rDelimAst: /^[^_*]*?\_\_[^_*]*?\*[^_*]*?(?=\_\_)|[^*]+(?=[^*])|[punct_](\*+)(?=[\s]|$)|[^punct*_\s](\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|[^punct*_\s](\*+)(?=[^punct*_\s])/,
        rDelimUnd: /^[^_*]*?\*\*[^_*]*?\_[^_*]*?(?=\*\*)|[^_]+(?=[^_])|[punct*](\_+)(?=[\s]|$)|[^punct*_\s](\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/
        // ^- Not allowed for _
      },
      code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
      br: /^( {2,}|\\)\n(?!\s*$)/,
      del: Z,
      text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
      punctuation: /^([\spunctuation])/
    };
    ce._punctuation = "!\"#$%&'()+\\-.,/:;<=>?@\\[\\]`^{|}~", ce.punctuation = C(ce.punctuation).replace(/punctuation/g, ce._punctuation).getRegex(), ce.blockSkip = /\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g, ce.escapedEmSt = /\\\*|\\_/g, ce._comment = C(Te._comment).replace("(?:-->|$)", "-->").getRegex(), ce.emStrong.lDelim = C(ce.emStrong.lDelim).replace(/punct/g, ce._punctuation).getRegex(), ce.emStrong.rDelimAst = C(ce.emStrong.rDelimAst, "g").replace(/punct/g, ce._punctuation).getRegex(), ce.emStrong.rDelimUnd = C(ce.emStrong.rDelimUnd, "g").replace(/punct/g, ce._punctuation).getRegex(), ce._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g, ce._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/, ce._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/, ce.autolink = C(ce.autolink).replace("scheme", ce._scheme).replace("email", ce._email).getRegex(), ce._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/, ce.tag = C(ce.tag).replace("comment", ce._comment).replace("attribute", ce._attribute).getRegex(), ce._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/, ce._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/, ce._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/, ce.link = C(ce.link).replace("label", ce._label).replace("href", ce._href).replace("title", ce._title).getRegex(), ce.reflink = C(ce.reflink).replace("label", ce._label).replace("ref", Te._label).getRegex(), ce.nolink = C(ce.nolink).replace("ref", Te._label).getRegex(), ce.reflinkSearch = C(ce.reflinkSearch, "g").replace("reflink", ce.reflink).replace("nolink", ce.nolink).getRegex(), ce.normal = H({}, ce), ce.pedantic = H({}, ce.normal, {
      strong: {
        start: /^__|\*\*/,
        middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
        endAst: /\*\*(?!\*)/g,
        endUnd: /__(?!_)/g
      },
      em: {
        start: /^_|\*/,
        middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
        endAst: /\*(?!\*)/g,
        endUnd: /_(?!_)/g
      },
      link: C(/^!?\[(label)\]\((.*?)\)/).replace("label", ce._label).getRegex(),
      reflink: C(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", ce._label).getRegex()
    }), ce.gfm = H({}, ce.normal, {
      escape: C(ce.escape).replace("])", "~|])").getRegex(),
      _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
      url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
      _backpedal: /(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,
      del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
      text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
    }), ce.gfm.url = C(ce.gfm.url, "i").replace("email", ce.gfm._extended_email).getRegex(), ce.breaks = H({}, ce.gfm, {
      br: C(ce.br).replace("{2,}", "*").getRegex(),
      text: C(ce.gfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
    });
    function Fi(te) {
      return te.replace(/---/g, "").replace(/--/g, "").replace(/(^|[-\u2014/(\[{"\s])'/g, "$1").replace(/'/g, "").replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1").replace(/"/g, "").replace(/\.{3}/g, "");
    }
    function Is(te) {
      var j = "", $, T, M = te.length;
      for ($ = 0; $ < M; $++)
        T = te.charCodeAt($), Math.random() > 0.5 && (T = "x" + T.toString(16)), j += "&#" + T + ";";
      return j;
    }
    var Qi = /* @__PURE__ */ function() {
      function te($) {
        this.tokens = [], this.tokens.links = /* @__PURE__ */ Object.create(null), this.options = $ || e.defaults, this.options.tokenizer = this.options.tokenizer || new Be(), this.tokenizer = this.options.tokenizer, this.tokenizer.options = this.options, this.tokenizer.lexer = this, this.inlineQueue = [], this.state = {
          inLink: !1,
          inRawBlock: !1,
          top: !0
        };
        var T = {
          block: Te.normal,
          inline: ce.normal
        };
        this.options.pedantic ? (T.block = Te.pedantic, T.inline = ce.pedantic) : this.options.gfm && (T.block = Te.gfm, this.options.breaks ? T.inline = ce.breaks : T.inline = ce.gfm), this.tokenizer.rules = T;
      }
      te.lex = function(T, M) {
        var B = new te(M);
        return B.lex(T);
      }, te.lexInline = function(T, M) {
        var B = new te(M);
        return B.inlineTokens(T);
      };
      var j = te.prototype;
      return j.lex = function(T) {
        T = T.replace(/\r\n|\r/g, `
`), this.blockTokens(T, this.tokens);
        for (var M; M = this.inlineQueue.shift(); )
          this.inlineTokens(M.src, M.tokens);
        return this.tokens;
      }, j.blockTokens = function(T, M) {
        var B = this;
        M === void 0 && (M = []), this.options.pedantic ? T = T.replace(/\t/g, "    ").replace(/^ +$/gm, "") : T = T.replace(/^( *)(\t+)/gm, function(Ze, Ke, Ft) {
          return Ke + "    ".repeat(Ft.length);
        });
        for (var O, ee, de, ye; T; )
          if (!(this.options.extensions && this.options.extensions.block && this.options.extensions.block.some(function(Ze) {
            return (O = Ze.call({
              lexer: B
            }, T, M)) ? (T = T.substring(O.raw.length), M.push(O), !0) : !1;
          }))) {
            if (O = this.tokenizer.space(T)) {
              T = T.substring(O.raw.length), O.raw.length === 1 && M.length > 0 ? M[M.length - 1].raw += `
` : M.push(O);
              continue;
            }
            if (O = this.tokenizer.code(T)) {
              T = T.substring(O.raw.length), ee = M[M.length - 1], ee && (ee.type === "paragraph" || ee.type === "text") ? (ee.raw += `
` + O.raw, ee.text += `
` + O.text, this.inlineQueue[this.inlineQueue.length - 1].src = ee.text) : M.push(O);
              continue;
            }
            if (O = this.tokenizer.fences(T)) {
              T = T.substring(O.raw.length), M.push(O);
              continue;
            }
            if (O = this.tokenizer.heading(T)) {
              T = T.substring(O.raw.length), M.push(O);
              continue;
            }
            if (O = this.tokenizer.hr(T)) {
              T = T.substring(O.raw.length), M.push(O);
              continue;
            }
            if (O = this.tokenizer.blockquote(T)) {
              T = T.substring(O.raw.length), M.push(O);
              continue;
            }
            if (O = this.tokenizer.list(T)) {
              T = T.substring(O.raw.length), M.push(O);
              continue;
            }
            if (O = this.tokenizer.html(T)) {
              T = T.substring(O.raw.length), M.push(O);
              continue;
            }
            if (O = this.tokenizer.def(T)) {
              T = T.substring(O.raw.length), ee = M[M.length - 1], ee && (ee.type === "paragraph" || ee.type === "text") ? (ee.raw += `
` + O.raw, ee.text += `
` + O.raw, this.inlineQueue[this.inlineQueue.length - 1].src = ee.text) : this.tokens.links[O.tag] || (this.tokens.links[O.tag] = {
                href: O.href,
                title: O.title
              });
              continue;
            }
            if (O = this.tokenizer.table(T)) {
              T = T.substring(O.raw.length), M.push(O);
              continue;
            }
            if (O = this.tokenizer.lheading(T)) {
              T = T.substring(O.raw.length), M.push(O);
              continue;
            }
            if (de = T, this.options.extensions && this.options.extensions.startBlock && function() {
              var Ze = 1 / 0, Ke = T.slice(1), Ft = void 0;
              B.options.extensions.startBlock.forEach(function(It) {
                Ft = It.call({
                  lexer: this
                }, Ke), typeof Ft == "number" && Ft >= 0 && (Ze = Math.min(Ze, Ft));
              }), Ze < 1 / 0 && Ze >= 0 && (de = T.substring(0, Ze + 1));
            }(), this.state.top && (O = this.tokenizer.paragraph(de))) {
              ee = M[M.length - 1], ye && ee.type === "paragraph" ? (ee.raw += `
` + O.raw, ee.text += `
` + O.text, this.inlineQueue.pop(), this.inlineQueue[this.inlineQueue.length - 1].src = ee.text) : M.push(O), ye = de.length !== T.length, T = T.substring(O.raw.length);
              continue;
            }
            if (O = this.tokenizer.text(T)) {
              T = T.substring(O.raw.length), ee = M[M.length - 1], ee && ee.type === "text" ? (ee.raw += `
` + O.raw, ee.text += `
` + O.text, this.inlineQueue.pop(), this.inlineQueue[this.inlineQueue.length - 1].src = ee.text) : M.push(O);
              continue;
            }
            if (T) {
              var Ie = "Infinite loop on byte: " + T.charCodeAt(0);
              if (this.options.silent) {
                console.error(Ie);
                break;
              } else
                throw new Error(Ie);
            }
          }
        return this.state.top = !0, M;
      }, j.inline = function(T, M) {
        return M === void 0 && (M = []), this.inlineQueue.push({
          src: T,
          tokens: M
        }), M;
      }, j.inlineTokens = function(T, M) {
        var B = this;
        M === void 0 && (M = []);
        var O, ee, de, ye = T, Ie, Ze, Ke;
        if (this.tokens.links) {
          var Ft = Object.keys(this.tokens.links);
          if (Ft.length > 0)
            for (; (Ie = this.tokenizer.rules.inline.reflinkSearch.exec(ye)) != null; )
              Ft.includes(Ie[0].slice(Ie[0].lastIndexOf("[") + 1, -1)) && (ye = ye.slice(0, Ie.index) + "[" + ze("a", Ie[0].length - 2) + "]" + ye.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex));
        }
        for (; (Ie = this.tokenizer.rules.inline.blockSkip.exec(ye)) != null; )
          ye = ye.slice(0, Ie.index) + "[" + ze("a", Ie[0].length - 2) + "]" + ye.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
        for (; (Ie = this.tokenizer.rules.inline.escapedEmSt.exec(ye)) != null; )
          ye = ye.slice(0, Ie.index) + "++" + ye.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex);
        for (; T; )
          if (Ze || (Ke = ""), Ze = !1, !(this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some(function(Oe) {
            return (O = Oe.call({
              lexer: B
            }, T, M)) ? (T = T.substring(O.raw.length), M.push(O), !0) : !1;
          }))) {
            if (O = this.tokenizer.escape(T)) {
              T = T.substring(O.raw.length), M.push(O);
              continue;
            }
            if (O = this.tokenizer.tag(T)) {
              T = T.substring(O.raw.length), ee = M[M.length - 1], ee && O.type === "text" && ee.type === "text" ? (ee.raw += O.raw, ee.text += O.text) : M.push(O);
              continue;
            }
            if (O = this.tokenizer.link(T)) {
              T = T.substring(O.raw.length), M.push(O);
              continue;
            }
            if (O = this.tokenizer.reflink(T, this.tokens.links)) {
              T = T.substring(O.raw.length), ee = M[M.length - 1], ee && O.type === "text" && ee.type === "text" ? (ee.raw += O.raw, ee.text += O.text) : M.push(O);
              continue;
            }
            if (O = this.tokenizer.emStrong(T, ye, Ke)) {
              T = T.substring(O.raw.length), M.push(O);
              continue;
            }
            if (O = this.tokenizer.codespan(T)) {
              T = T.substring(O.raw.length), M.push(O);
              continue;
            }
            if (O = this.tokenizer.br(T)) {
              T = T.substring(O.raw.length), M.push(O);
              continue;
            }
            if (O = this.tokenizer.del(T)) {
              T = T.substring(O.raw.length), M.push(O);
              continue;
            }
            if (O = this.tokenizer.autolink(T, Is)) {
              T = T.substring(O.raw.length), M.push(O);
              continue;
            }
            if (!this.state.inLink && (O = this.tokenizer.url(T, Is))) {
              T = T.substring(O.raw.length), M.push(O);
              continue;
            }
            if (de = T, this.options.extensions && this.options.extensions.startInline && function() {
              var Oe = 1 / 0, vi = T.slice(1), bi = void 0;
              B.options.extensions.startInline.forEach(function(Go) {
                bi = Go.call({
                  lexer: this
                }, vi), typeof bi == "number" && bi >= 0 && (Oe = Math.min(Oe, bi));
              }), Oe < 1 / 0 && Oe >= 0 && (de = T.substring(0, Oe + 1));
            }(), O = this.tokenizer.inlineText(de, Fi)) {
              T = T.substring(O.raw.length), O.raw.slice(-1) !== "_" && (Ke = O.raw.slice(-1)), Ze = !0, ee = M[M.length - 1], ee && ee.type === "text" ? (ee.raw += O.raw, ee.text += O.text) : M.push(O);
              continue;
            }
            if (T) {
              var It = "Infinite loop on byte: " + T.charCodeAt(0);
              if (this.options.silent) {
                console.error(It);
                break;
              } else
                throw new Error(It);
            }
          }
        return M;
      }, i(te, null, [{
        key: "rules",
        get: function() {
          return {
            block: Te,
            inline: ce
          };
        }
      }]), te;
    }(), Ct = /* @__PURE__ */ function() {
      function te($) {
        this.options = $ || e.defaults;
      }
      var j = te.prototype;
      return j.code = function(T, M, B) {
        var O = (M || "").match(/\S*/)[0];
        if (this.options.highlight) {
          var ee = this.options.highlight(T, O);
          ee != null && ee !== T && (B = !0, T = ee);
        }
        return T = T.replace(/\n$/, "") + `
`, O ? '<pre><code class="' + this.options.langPrefix + m(O, !0) + '">' + (B ? T : m(T, !0)) + `</code></pre>
` : "<pre><code>" + (B ? T : m(T, !0)) + `</code></pre>
`;
      }, j.blockquote = function(T) {
        return `<blockquote>
` + T + `</blockquote>
`;
      }, j.html = function(T) {
        return T;
      }, j.heading = function(T, M, B, O) {
        if (this.options.headerIds) {
          var ee = this.options.headerPrefix + O.slug(B);
          return "<h" + M + ' id="' + ee + '">' + T + "</h" + M + `>
`;
        }
        return "<h" + M + ">" + T + "</h" + M + `>
`;
      }, j.hr = function() {
        return this.options.xhtml ? `<hr/>
` : `<hr>
`;
      }, j.list = function(T, M, B) {
        var O = M ? "ol" : "ul", ee = M && B !== 1 ? ' start="' + B + '"' : "";
        return "<" + O + ee + `>
` + T + "</" + O + `>
`;
      }, j.listitem = function(T) {
        return "<li>" + T + `</li>
`;
      }, j.checkbox = function(T) {
        return "<input " + (T ? 'checked="" ' : "") + 'disabled="" type="checkbox"' + (this.options.xhtml ? " /" : "") + "> ";
      }, j.paragraph = function(T) {
        return "<p>" + T + `</p>
`;
      }, j.table = function(T, M) {
        return M && (M = "<tbody>" + M + "</tbody>"), `<table>
<thead>
` + T + `</thead>
` + M + `</table>
`;
      }, j.tablerow = function(T) {
        return `<tr>
` + T + `</tr>
`;
      }, j.tablecell = function(T, M) {
        var B = M.header ? "th" : "td", O = M.align ? "<" + B + ' align="' + M.align + '">' : "<" + B + ">";
        return O + T + ("</" + B + `>
`);
      }, j.strong = function(T) {
        return "<strong>" + T + "</strong>";
      }, j.em = function(T) {
        return "<em>" + T + "</em>";
      }, j.codespan = function(T) {
        return "<code>" + T + "</code>";
      }, j.br = function() {
        return this.options.xhtml ? "<br/>" : "<br>";
      }, j.del = function(T) {
        return "<del>" + T + "</del>";
      }, j.link = function(T, M, B) {
        if (T = y(this.options.sanitize, this.options.baseUrl, T), T === null)
          return B;
        var O = '<a href="' + m(T) + '"';
        return M && (O += ' title="' + M + '"'), O += ">" + B + "</a>", O;
      }, j.image = function(T, M, B) {
        if (T = y(this.options.sanitize, this.options.baseUrl, T), T === null)
          return B;
        var O = '<img src="' + T + '" alt="' + B + '"';
        return M && (O += ' title="' + M + '"'), O += this.options.xhtml ? "/>" : ">", O;
      }, j.text = function(T) {
        return T;
      }, te;
    }(), Ki = /* @__PURE__ */ function() {
      function te() {
      }
      var j = te.prototype;
      return j.strong = function(T) {
        return T;
      }, j.em = function(T) {
        return T;
      }, j.codespan = function(T) {
        return T;
      }, j.del = function(T) {
        return T;
      }, j.html = function(T) {
        return T;
      }, j.text = function(T) {
        return T;
      }, j.link = function(T, M, B) {
        return "" + B;
      }, j.image = function(T, M, B) {
        return "" + B;
      }, j.br = function() {
        return "";
      }, te;
    }(), Gn = /* @__PURE__ */ function() {
      function te() {
        this.seen = {};
      }
      var j = te.prototype;
      return j.serialize = function(T) {
        return T.toLowerCase().trim().replace(/<[!\/a-z].*?>/ig, "").replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, "").replace(/\s/g, "-");
      }, j.getNextSafeSlug = function(T, M) {
        var B = T, O = 0;
        if (this.seen.hasOwnProperty(B)) {
          O = this.seen[T];
          do
            O++, B = T + "-" + O;
          while (this.seen.hasOwnProperty(B));
        }
        return M || (this.seen[T] = O, this.seen[B] = 0), B;
      }, j.slug = function(T, M) {
        M === void 0 && (M = {});
        var B = this.serialize(T);
        return this.getNextSafeSlug(B, M.dryrun);
      }, te;
    }(), dn = /* @__PURE__ */ function() {
      function te($) {
        this.options = $ || e.defaults, this.options.renderer = this.options.renderer || new Ct(), this.renderer = this.options.renderer, this.renderer.options = this.options, this.textRenderer = new Ki(), this.slugger = new Gn();
      }
      te.parse = function(T, M) {
        var B = new te(M);
        return B.parse(T);
      }, te.parseInline = function(T, M) {
        var B = new te(M);
        return B.parseInline(T);
      };
      var j = te.prototype;
      return j.parse = function(T, M) {
        M === void 0 && (M = !0);
        var B = "", O, ee, de, ye, Ie, Ze, Ke, Ft, It, Oe, vi, bi, Go, St, Wi, uh, gh, wr, Ed, fh = T.length;
        for (O = 0; O < fh; O++) {
          if (Oe = T[O], this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[Oe.type] && (Ed = this.options.extensions.renderers[Oe.type].call({
            parser: this
          }, Oe), Ed !== !1 || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(Oe.type))) {
            B += Ed || "";
            continue;
          }
          switch (Oe.type) {
            case "space":
              continue;
            case "hr": {
              B += this.renderer.hr();
              continue;
            }
            case "heading": {
              B += this.renderer.heading(this.parseInline(Oe.tokens), Oe.depth, v(this.parseInline(Oe.tokens, this.textRenderer)), this.slugger);
              continue;
            }
            case "code": {
              B += this.renderer.code(Oe.text, Oe.lang, Oe.escaped);
              continue;
            }
            case "table": {
              for (Ft = "", Ke = "", ye = Oe.header.length, ee = 0; ee < ye; ee++)
                Ke += this.renderer.tablecell(this.parseInline(Oe.header[ee].tokens), {
                  header: !0,
                  align: Oe.align[ee]
                });
              for (Ft += this.renderer.tablerow(Ke), It = "", ye = Oe.rows.length, ee = 0; ee < ye; ee++) {
                for (Ze = Oe.rows[ee], Ke = "", Ie = Ze.length, de = 0; de < Ie; de++)
                  Ke += this.renderer.tablecell(this.parseInline(Ze[de].tokens), {
                    header: !1,
                    align: Oe.align[de]
                  });
                It += this.renderer.tablerow(Ke);
              }
              B += this.renderer.table(Ft, It);
              continue;
            }
            case "blockquote": {
              It = this.parse(Oe.tokens), B += this.renderer.blockquote(It);
              continue;
            }
            case "list": {
              for (vi = Oe.ordered, bi = Oe.start, Go = Oe.loose, ye = Oe.items.length, It = "", ee = 0; ee < ye; ee++)
                Wi = Oe.items[ee], uh = Wi.checked, gh = Wi.task, St = "", Wi.task && (wr = this.renderer.checkbox(uh), Go ? Wi.tokens.length > 0 && Wi.tokens[0].type === "paragraph" ? (Wi.tokens[0].text = wr + " " + Wi.tokens[0].text, Wi.tokens[0].tokens && Wi.tokens[0].tokens.length > 0 && Wi.tokens[0].tokens[0].type === "text" && (Wi.tokens[0].tokens[0].text = wr + " " + Wi.tokens[0].tokens[0].text)) : Wi.tokens.unshift({
                  type: "text",
                  text: wr
                }) : St += wr), St += this.parse(Wi.tokens, Go), It += this.renderer.listitem(St, gh, uh);
              B += this.renderer.list(It, vi, bi);
              continue;
            }
            case "html": {
              B += this.renderer.html(Oe.text);
              continue;
            }
            case "paragraph": {
              B += this.renderer.paragraph(this.parseInline(Oe.tokens));
              continue;
            }
            case "text": {
              for (It = Oe.tokens ? this.parseInline(Oe.tokens) : Oe.text; O + 1 < fh && T[O + 1].type === "text"; )
                Oe = T[++O], It += `
` + (Oe.tokens ? this.parseInline(Oe.tokens) : Oe.text);
              B += M ? this.renderer.paragraph(It) : It;
              continue;
            }
            default: {
              var ph = 'Token with "' + Oe.type + '" type was not found.';
              if (this.options.silent) {
                console.error(ph);
                return;
              } else
                throw new Error(ph);
            }
          }
        }
        return B;
      }, j.parseInline = function(T, M) {
        M = M || this.renderer;
        var B = "", O, ee, de, ye = T.length;
        for (O = 0; O < ye; O++) {
          if (ee = T[O], this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[ee.type] && (de = this.options.extensions.renderers[ee.type].call({
            parser: this
          }, ee), de !== !1 || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(ee.type))) {
            B += de || "";
            continue;
          }
          switch (ee.type) {
            case "escape": {
              B += M.text(ee.text);
              break;
            }
            case "html": {
              B += M.html(ee.text);
              break;
            }
            case "link": {
              B += M.link(ee.href, ee.title, this.parseInline(ee.tokens, M));
              break;
            }
            case "image": {
              B += M.image(ee.href, ee.title, ee.text);
              break;
            }
            case "strong": {
              B += M.strong(this.parseInline(ee.tokens, M));
              break;
            }
            case "em": {
              B += M.em(this.parseInline(ee.tokens, M));
              break;
            }
            case "codespan": {
              B += M.codespan(ee.text);
              break;
            }
            case "br": {
              B += M.br();
              break;
            }
            case "del": {
              B += M.del(this.parseInline(ee.tokens, M));
              break;
            }
            case "text": {
              B += M.text(ee.text);
              break;
            }
            default: {
              var Ie = 'Token with "' + ee.type + '" type was not found.';
              if (this.options.silent) {
                console.error(Ie);
                return;
              } else
                throw new Error(Ie);
            }
          }
        }
        return B;
      }, te;
    }();
    function Ue(te, j, $) {
      if (typeof te > "u" || te === null)
        throw new Error("marked(): input parameter is undefined or null");
      if (typeof te != "string")
        throw new Error("marked(): input parameter is of type " + Object.prototype.toString.call(te) + ", string expected");
      if (typeof j == "function" && ($ = j, j = null), j = H({}, Ue.defaults, j || {}), Ye(j), $) {
        var T = j.highlight, M;
        try {
          M = Qi.lex(te, j);
        } catch (ye) {
          return $(ye);
        }
        var B = function(Ie) {
          var Ze;
          if (!Ie)
            try {
              j.walkTokens && Ue.walkTokens(M, j.walkTokens), Ze = dn.parse(M, j);
            } catch (Ke) {
              Ie = Ke;
            }
          return j.highlight = T, Ie ? $(Ie) : $(null, Ze);
        };
        if (!T || T.length < 3 || (delete j.highlight, !M.length)) return B();
        var O = 0;
        Ue.walkTokens(M, function(ye) {
          ye.type === "code" && (O++, setTimeout(function() {
            T(ye.text, ye.lang, function(Ie, Ze) {
              if (Ie)
                return B(Ie);
              Ze != null && Ze !== ye.text && (ye.text = Ze, ye.escaped = !0), O--, O === 0 && B();
            });
          }, 0));
        }), O === 0 && B();
        return;
      }
      function ee(ye) {
        if (ye.message += `
Please report this to https://github.com/markedjs/marked.`, j.silent)
          return "<p>An error occurred:</p><pre>" + m(ye.message + "", !0) + "</pre>";
        throw ye;
      }
      try {
        var de = Qi.lex(te, j);
        if (j.walkTokens) {
          if (j.async)
            return Promise.all(Ue.walkTokens(de, j.walkTokens)).then(function() {
              return dn.parse(de, j);
            }).catch(ee);
          Ue.walkTokens(de, j.walkTokens);
        }
        return dn.parse(de, j);
      } catch (ye) {
        ee(ye);
      }
    }
    Ue.options = Ue.setOptions = function(te) {
      return H(Ue.defaults, te), l(Ue.defaults), Ue;
    }, Ue.getDefaults = a, Ue.defaults = e.defaults, Ue.use = function() {
      for (var te = arguments.length, j = new Array(te), $ = 0; $ < te; $++)
        j[$] = arguments[$];
      var T = H.apply(void 0, [{}].concat(j)), M = Ue.defaults.extensions || {
        renderers: {},
        childTokens: {}
      }, B;
      j.forEach(function(O) {
        if (O.extensions && (B = !0, O.extensions.forEach(function(de) {
          if (!de.name)
            throw new Error("extension name required");
          if (de.renderer) {
            var ye = M.renderers ? M.renderers[de.name] : null;
            ye ? M.renderers[de.name] = function() {
              for (var Ie = arguments.length, Ze = new Array(Ie), Ke = 0; Ke < Ie; Ke++)
                Ze[Ke] = arguments[Ke];
              var Ft = de.renderer.apply(this, Ze);
              return Ft === !1 && (Ft = ye.apply(this, Ze)), Ft;
            } : M.renderers[de.name] = de.renderer;
          }
          if (de.tokenizer) {
            if (!de.level || de.level !== "block" && de.level !== "inline")
              throw new Error("extension level must be 'block' or 'inline'");
            M[de.level] ? M[de.level].unshift(de.tokenizer) : M[de.level] = [de.tokenizer], de.start && (de.level === "block" ? M.startBlock ? M.startBlock.push(de.start) : M.startBlock = [de.start] : de.level === "inline" && (M.startInline ? M.startInline.push(de.start) : M.startInline = [de.start]));
          }
          de.childTokens && (M.childTokens[de.name] = de.childTokens);
        })), O.renderer && function() {
          var de = Ue.defaults.renderer || new Ct(), ye = function(Ke) {
            var Ft = de[Ke];
            de[Ke] = function() {
              for (var It = arguments.length, Oe = new Array(It), vi = 0; vi < It; vi++)
                Oe[vi] = arguments[vi];
              var bi = O.renderer[Ke].apply(de, Oe);
              return bi === !1 && (bi = Ft.apply(de, Oe)), bi;
            };
          };
          for (var Ie in O.renderer)
            ye(Ie);
          T.renderer = de;
        }(), O.tokenizer && function() {
          var de = Ue.defaults.tokenizer || new Be(), ye = function(Ke) {
            var Ft = de[Ke];
            de[Ke] = function() {
              for (var It = arguments.length, Oe = new Array(It), vi = 0; vi < It; vi++)
                Oe[vi] = arguments[vi];
              var bi = O.tokenizer[Ke].apply(de, Oe);
              return bi === !1 && (bi = Ft.apply(de, Oe)), bi;
            };
          };
          for (var Ie in O.tokenizer)
            ye(Ie);
          T.tokenizer = de;
        }(), O.walkTokens) {
          var ee = Ue.defaults.walkTokens;
          T.walkTokens = function(de) {
            var ye = [];
            return ye.push(O.walkTokens.call(this, de)), ee && (ye = ye.concat(ee.call(this, de))), ye;
          };
        }
        B && (T.extensions = M), Ue.setOptions(T);
      });
    }, Ue.walkTokens = function(te, j) {
      for (var $ = [], T = function() {
        var ee = B.value;
        switch ($ = $.concat(j.call(Ue, ee)), ee.type) {
          case "table": {
            for (var de = o(ee.header), ye; !(ye = de()).done; ) {
              var Ie = ye.value;
              $ = $.concat(Ue.walkTokens(Ie.tokens, j));
            }
            for (var Ze = o(ee.rows), Ke; !(Ke = Ze()).done; )
              for (var Ft = Ke.value, It = o(Ft), Oe; !(Oe = It()).done; ) {
                var vi = Oe.value;
                $ = $.concat(Ue.walkTokens(vi.tokens, j));
              }
            break;
          }
          case "list": {
            $ = $.concat(Ue.walkTokens(ee.items, j));
            break;
          }
          default:
            Ue.defaults.extensions && Ue.defaults.extensions.childTokens && Ue.defaults.extensions.childTokens[ee.type] ? Ue.defaults.extensions.childTokens[ee.type].forEach(function(bi) {
              $ = $.concat(Ue.walkTokens(ee[bi], j));
            }) : ee.tokens && ($ = $.concat(Ue.walkTokens(ee.tokens, j)));
        }
      }, M = o(te), B; !(B = M()).done; )
        T();
      return $;
    }, Ue.parseInline = function(te, j) {
      if (typeof te > "u" || te === null)
        throw new Error("marked.parseInline(): input parameter is undefined or null");
      if (typeof te != "string")
        throw new Error("marked.parseInline(): input parameter is of type " + Object.prototype.toString.call(te) + ", string expected");
      j = H({}, Ue.defaults, j || {}), Ye(j);
      try {
        var $ = Qi.lexInline(te, j);
        return j.walkTokens && Ue.walkTokens($, j.walkTokens), dn.parseInline($, j);
      } catch (T) {
        if (T.message += `
Please report this to https://github.com/markedjs/marked.`, j.silent)
          return "<p>An error occurred:</p><pre>" + m(T.message + "", !0) + "</pre>";
        throw T;
      }
    }, Ue.Parser = dn, Ue.parser = dn.parse, Ue.Renderer = Ct, Ue.TextRenderer = Ki, Ue.Lexer = Qi, Ue.lexer = Qi.lex, Ue.Tokenizer = Be, Ue.Slugger = Gn, Ue.parse = Ue;
    var jo = Ue.options, qo = Ue.setOptions, Qs = Ue.use, pl = Ue.walkTokens, Xi = Ue.parseInline, Cr = Ue, Yb = dn.parse, pD = Qi.lex;
    e.Lexer = Qi, e.Parser = dn, e.Renderer = Ct, e.Slugger = Gn, e.TextRenderer = Ki, e.Tokenizer = Be, e.getDefaults = a, e.lexer = pD, e.marked = Ue, e.options = jo, e.parse = Cr, e.parseInline = Xi, e.parser = Yb, e.setOptions = qo, e.use = Qs, e.walkTokens = pl, Object.defineProperty(e, "__esModule", { value: !0 });
  });
})();
hs.Lexer || exports.Lexer;
hs.Parser || exports.Parser;
hs.Renderer || exports.Renderer;
hs.Slugger || exports.Slugger;
hs.TextRenderer || exports.TextRenderer;
hs.Tokenizer || exports.Tokenizer;
hs.getDefaults || exports.getDefaults;
hs.lexer || exports.lexer;
var Fr = hs.marked || exports.marked;
hs.options || exports.options;
hs.parse || exports.parse;
hs.parseInline || exports.parseInline;
hs.parser || exports.parser;
hs.setOptions || exports.setOptions;
hs.use || exports.use;
hs.walkTokens || exports.walkTokens;
function Dee(r) {
  return JSON.stringify(r, kee);
}
function TI(r) {
  let e = JSON.parse(r);
  return e = NI(e), e;
}
function kee(r, e) {
  return e instanceof RegExp ? {
    $mid: 2,
    source: e.source,
    flags: e.flags
  } : e;
}
function NI(r, e = 0) {
  if (!r || e > 200)
    return r;
  if (typeof r == "object") {
    switch (r.$mid) {
      case 1:
        return Ee.revive(r);
      case 2:
        return new RegExp(r.source, r.flags);
      case 17:
        return new Date(r.source);
    }
    if (r instanceof b0 || r instanceof Uint8Array)
      return r;
    if (Array.isArray(r))
      for (let t = 0; t < r.length; ++t)
        r[t] = NI(r[t], e + 1);
    else
      for (const t in r)
        Object.hasOwnProperty.call(r, t) && (r[t] = NI(r[t], e + 1));
  }
  return r;
}
const Sk = Object.freeze({
  image: (r, e, t) => {
    let i = [], n = [];
    return r && ({ href: r, dimensions: i } = Lee(r), n.push(`src="${AC(r)}"`)), t && n.push(`alt="${AC(t)}"`), e && n.push(`title="${AC(e)}"`), i.length && (n = n.concat(i)), "<img " + n.join(" ") + ">";
  },
  paragraph: (r) => `<p>${r}</p>`,
  link: (r, e, t) => typeof r != "string" ? "" : (r === t && (t = wk(t)), e = typeof e == "string" ? AC(wk(e)) : "", r = wk(r), r = r.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;"), `<a href="${r}" title="${e || r}" draggable="false">${t}</a>`)
});
function z0(r, e = {}, t = {}) {
  var i, n;
  const s = new q();
  let o = !1;
  const a = nM(e), l = function(v) {
    let b;
    try {
      b = TI(decodeURIComponent(v));
    } catch {
    }
    return b ? (b = sH(b, (C) => {
      if (r.uris && r.uris[C])
        return Ee.revive(r.uris[C]);
    }), encodeURIComponent(JSON.stringify(b))) : v;
  }, d = function(v, b) {
    const C = r.uris && r.uris[v];
    let w = Ee.revive(C);
    return b ? v.startsWith(Ne.data + ":") ? v : (w || (w = Ee.parse(v)), FH.uriToBrowserUri(w).toString(!0)) : !w || Ee.parse(v).toString() === w.toString() ? v : (w.query && (w = w.with({ query: l(w.query) })), w.toString());
  }, c = new Fr.Renderer();
  c.image = Sk.image, c.link = Sk.link, c.paragraph = Sk.paragraph;
  const h = [], u = [];
  if (e.codeBlockRendererSync ? c.code = (v, b) => {
    const C = EI.nextId(), w = e.codeBlockRendererSync(FO(b), v);
    return u.push([C, w]), `<div class="code" data-code="${C}">${Ym(v)}</div>`;
  } : e.codeBlockRenderer && (c.code = (v, b) => {
    const C = EI.nextId(), w = e.codeBlockRenderer(FO(b), v);
    return h.push(w.then((S) => [C, S])), `<div class="code" data-code="${C}">${Ym(v)}</div>`;
  }), e.actionHandler) {
    const v = function(w) {
      let S = w.target;
      if (!(S.tagName !== "A" && (S = S.parentElement, !S || S.tagName !== "A")))
        try {
          let y = S.dataset.href;
          y && (r.baseUri && (y = yk(Ee.from(r.baseUri), y)), e.actionHandler.callback(y, w));
        } catch (y) {
          He(y);
        } finally {
          w.preventDefault();
        }
    }, b = e.actionHandler.disposables.add(new tt(a, "click")), C = e.actionHandler.disposables.add(new tt(a, "auxclick"));
    e.actionHandler.disposables.add(ne.any(b.event, C.event)((w) => {
      const S = new rr(we(a), w);
      !S.leftButton && !S.middleButton || v(S);
    })), e.actionHandler.disposables.add(W(a, "keydown", (w) => {
      const S = new Mt(w);
      !S.equals(
        10
        /* KeyCode.Space */
      ) && !S.equals(
        3
        /* KeyCode.Enter */
      ) || v(S);
    }));
  }
  r.supportHtml || (t.sanitizer = (v) => {
    var b;
    return !((b = e.sanitizerOptions) === null || b === void 0) && b.replaceWithPlaintext ? Ym(v) : (r.isTrusted ? v.match(/^(<span[^>]+>)|(<\/\s*span>)$/) : void 0) ? v : "";
  }, t.sanitize = !0, t.silent = !0), t.renderer = c;
  let g = (i = r.value) !== null && i !== void 0 ? i : "";
  g.length > 1e5 && (g = `${g.substr(0, 1e5)}`), r.supportThemeIcons && (g = vee(g));
  let f;
  if (e.fillInIncompleteTokens) {
    const v = {
      ...Fr.defaults,
      ...t
    }, b = Fr.lexer(g, v), C = Bee(b);
    f = Fr.parser(C, v);
  } else
    f = Fr.parse(g, t);
  r.supportThemeIcons && (f = _c(f).map((b) => typeof b == "string" ? b : b.outerHTML).join(""));
  const _ = new DOMParser().parseFromString(MI({ isTrusted: r.isTrusted, ...e.sanitizerOptions }, f), "text/html");
  if (_.body.querySelectorAll("img, audio, video, source").forEach((v) => {
    const b = v.getAttribute("src");
    if (b) {
      let C = b;
      try {
        r.baseUri && (C = yk(Ee.from(r.baseUri), C));
      } catch {
      }
      if (v.setAttribute("src", d(C, !0)), e.remoteImageIsAllowed) {
        const w = Ee.parse(C);
        w.scheme !== Ne.file && w.scheme !== Ne.data && !e.remoteImageIsAllowed(w) && v.replaceWith(X("", void 0, v.outerHTML));
      }
    }
  }), _.body.querySelectorAll("a").forEach((v) => {
    const b = v.getAttribute("href");
    if (v.setAttribute("href", ""), !b || /^data:|javascript:/i.test(b) || /^command:/i.test(b) && !r.isTrusted || /^command:(\/\/\/)?_workbench\.downloadResource/i.test(b))
      v.replaceWith(...v.childNodes);
    else {
      let C = d(b, !1);
      r.baseUri && (C = yk(Ee.from(r.baseUri), b)), v.dataset.href = C;
    }
  }), a.innerHTML = MI({ isTrusted: r.isTrusted, ...e.sanitizerOptions }, _.body.innerHTML), h.length > 0)
    Promise.all(h).then((v) => {
      var b, C;
      if (o)
        return;
      const w = new Map(v), S = a.querySelectorAll("div[data-code]");
      for (const y of S) {
        const k = w.get((b = y.dataset.code) !== null && b !== void 0 ? b : "");
        k && mn(y, k);
      }
      (C = e.asyncRenderCallback) === null || C === void 0 || C.call(e);
    });
  else if (u.length > 0) {
    const v = new Map(u), b = a.querySelectorAll("div[data-code]");
    for (const C of b) {
      const w = v.get((n = C.dataset.code) !== null && n !== void 0 ? n : "");
      w && mn(C, w);
    }
  }
  if (e.asyncRenderCallback)
    for (const v of a.getElementsByTagName("img")) {
      const b = s.add(W(v, "load", () => {
        b.dispose(), e.asyncRenderCallback();
      }));
    }
  return {
    element: a,
    dispose: () => {
      o = !0, s.dispose();
    }
  };
}
function FO(r) {
  if (!r)
    return "";
  const e = r.split(/[\s+|:|,|\{|\?]/, 1);
  return e.length ? e[0] : r;
}
function yk(r, e) {
  return /^\w[\w\d+.-]*:/.test(e) ? e : r.path.endsWith("/") ? UP(r, e).toString() : UP(P0(r), e).toString();
}
const xee = ["area", "base", "br", "col", "command", "embed", "hr", "img", "input", "keygen", "link", "meta", "param", "source", "track", "wbr"];
function MI(r, e) {
  const { config: t, allowedSchemes: i } = Eee(r), n = new q();
  n.add(WO("uponSanitizeAttribute", (s, o) => {
    var a;
    if (o.attrName === "style" || o.attrName === "class") {
      if (s.tagName === "SPAN") {
        if (o.attrName === "style") {
          o.keepAttr = /^(color\:(#[0-9a-fA-F]+|var\(--vscode(-[a-zA-Z]+)+\));)?(background-color\:(#[0-9a-fA-F]+|var\(--vscode(-[a-zA-Z]+)+\));)?$/.test(o.attrValue);
          return;
        } else if (o.attrName === "class") {
          o.keepAttr = /^codicon codicon-[a-z\-]+( codicon-modifier-[a-z\-]+)?$/.test(o.attrValue);
          return;
        }
      }
      o.keepAttr = !1;
      return;
    } else if (s.tagName === "INPUT" && ((a = s.attributes.getNamedItem("type")) === null || a === void 0 ? void 0 : a.value) === "checkbox") {
      if (o.attrName === "type" && o.attrValue === "checkbox" || o.attrName === "disabled" || o.attrName === "checked") {
        o.keepAttr = !0;
        return;
      }
      o.keepAttr = !1;
    }
  })), n.add(WO("uponSanitizeElement", (s, o) => {
    var a, l;
    if (o.tagName === "input" && (((a = s.attributes.getNamedItem("type")) === null || a === void 0 ? void 0 : a.value) === "checkbox" ? s.setAttribute("disabled", "") : r.replaceWithPlaintext || (l = s.parentElement) === null || l === void 0 || l.removeChild(s)), r.replaceWithPlaintext && !o.allowedTags[o.tagName] && o.tagName !== "body" && s.parentElement) {
      let d, c;
      if (o.tagName === "#comment")
        d = `<!--${s.textContent}-->`;
      else {
        const f = xee.includes(o.tagName), m = s.attributes.length ? " " + Array.from(s.attributes).map((_) => `${_.name}="${_.value}"`).join(" ") : "";
        d = `<${o.tagName}${m}>`, f || (c = `</${o.tagName}>`);
      }
      const h = document.createDocumentFragment(), u = s.parentElement.ownerDocument.createTextNode(d);
      h.appendChild(u);
      const g = c ? s.parentElement.ownerDocument.createTextNode(c) : void 0;
      for (; s.firstChild; )
        h.appendChild(s.firstChild);
      g && h.appendChild(g), s.parentElement.replaceChild(h, s);
    }
  })), n.add(i6(i));
  try {
    return RH(e, { ...t, RETURN_TRUSTED_TYPE: !0 });
  } finally {
    n.dispose();
  }
}
const Iee = [
  "align",
  "autoplay",
  "alt",
  "checked",
  "class",
  "controls",
  "data-code",
  "data-href",
  "disabled",
  "draggable",
  "height",
  "href",
  "loop",
  "muted",
  "playsinline",
  "poster",
  "src",
  "style",
  "target",
  "title",
  "type",
  "width",
  "start"
];
function Eee(r) {
  var e;
  const t = [
    Ne.http,
    Ne.https,
    Ne.mailto,
    Ne.data,
    Ne.file,
    Ne.vscodeFileResource,
    Ne.vscodeRemote,
    Ne.vscodeRemoteResource
  ];
  return r.isTrusted && t.push(Ne.command), {
    config: {
      // allowedTags should included everything that markdown renders to.
      // Since we have our own sanitize function for marked, it's possible we missed some tag so let dompurify make sure.
      // HTML tags that can result from markdown are from reading https://spec.commonmark.org/0.29/
      // HTML table tags that can result from markdown are from https://github.github.com/gfm/#tables-extension-
      ALLOWED_TAGS: (e = r.allowedTags) !== null && e !== void 0 ? e : [...n6],
      ALLOWED_ATTR: Iee,
      ALLOW_UNKNOWN_PROTOCOLS: !0
    },
    allowedSchemes: t
  };
}
function Tee(r) {
  return typeof r == "string" ? r : Nee(r);
}
function Nee(r, e) {
  var t;
  let i = (t = r.value) !== null && t !== void 0 ? t : "";
  i.length > 1e5 && (i = `${i.substr(0, 1e5)}`);
  const n = Fr.parse(i, { renderer: Aee.value }).replace(/&(#\d+|[a-zA-Z]+);/g, (s) => {
    var o;
    return (o = Mee.get(s)) !== null && o !== void 0 ? o : s;
  });
  return MI({ isTrusted: !1 }, n).toString();
}
const Mee = /* @__PURE__ */ new Map([
  ["&quot;", '"'],
  ["&nbsp;", " "],
  ["&amp;", "&"],
  ["&#39;", "'"],
  ["&lt;", "<"],
  ["&gt;", ">"]
]);
function Ree() {
  const r = new Fr.Renderer();
  return r.code = (e) => e, r.blockquote = (e) => e, r.html = (e) => "", r.heading = (e, t, i) => e + `
`, r.hr = () => "", r.list = (e, t) => e, r.listitem = (e) => e + `
`, r.paragraph = (e) => e + `
`, r.table = (e, t) => e + t + `
`, r.tablerow = (e) => e, r.tablecell = (e, t) => e + " ", r.strong = (e) => e, r.em = (e) => e, r.codespan = (e) => e, r.br = () => `
`, r.del = (e) => e, r.image = (e, t, i) => "", r.text = (e) => e, r.link = (e, t, i) => i, r;
}
const Aee = new bd((r) => Ree());
function nv(r) {
  let e = "";
  return r.forEach((t) => {
    e += t.raw;
  }), e;
}
function hz(r) {
  var e, t;
  if (r.tokens)
    for (let i = r.tokens.length - 1; i >= 0; i--) {
      const n = r.tokens[i];
      if (n.type === "text") {
        const s = n.raw.split(`
`), o = s[s.length - 1];
        if (o.includes("`"))
          return zee(r);
        if (o.includes("**"))
          return Gee(r);
        if (o.match(/\*\w/))
          return Uee(r);
        if (o.match(/(^|\s)__\w/))
          return Zee(r);
        if (o.match(/(^|\s)_\w/))
          return $ee(r);
        if (
          // Text with start of link target
          Pee(o) || // This token doesn't have the link text, eg if it contains other markdown constructs that are in other subtokens.
          // But some preceding token does have an unbalanced [ at least
          Oee(o) && r.tokens.slice(0, i).some((a) => a.type === "text" && a.raw.match(/\[[^\]]*$/))
        ) {
          const a = r.tokens.slice(i + 1);
          return (
            // If the link was parsed as a link, then look for a link token and a text token with a quote
            ((e = a[0]) === null || e === void 0 ? void 0 : e.type) === "link" && ((t = a[1]) === null || t === void 0 ? void 0 : t.type) === "text" && a[1].raw.match(/^ *"[^"]*$/) || // And if the link was not parsed as a link (eg command link), just look for a single quote in this token
            o.match(/^[^"]* +"[^"]*$/) ? jee(r) : Kee(r)
          );
        } else if (o.match(/(^|\s)\[\w*/))
          return qee(r);
      }
    }
}
function Pee(r) {
  return !!r.match(/(^|\s)\[.*\]\(\w*/);
}
function Oee(r) {
  return !!r.match(/^[^\[]*\]\([^\)]*$/);
}
function Fee(r) {
  var e;
  const t = r.items[r.items.length - 1], i = t.tokens ? t.tokens[t.tokens.length - 1] : void 0;
  let n;
  if ((i == null ? void 0 : i.type) === "text" && !("inRawBlock" in t) && (n = hz(i)), !n || n.type !== "paragraph")
    return;
  const s = nv(r.items.slice(0, -1)), o = (e = t.raw.match(/^(\s*(-|\d+\.) +)/)) === null || e === void 0 ? void 0 : e[0];
  if (!o)
    return;
  const a = o + nv(t.tokens.slice(0, -1)) + n.raw, l = Fr.lexer(s + a)[0];
  if (l.type === "list")
    return l;
}
const Wee = 3;
function Bee(r) {
  for (let e = 0; e < Wee; e++) {
    const t = Hee(r);
    if (t)
      r = t;
    else
      break;
  }
  return r;
}
function Hee(r) {
  let e, t;
  for (e = 0; e < r.length; e++) {
    const i = r[e];
    let n;
    if (i.type === "paragraph" && (n = i.raw.match(/(\n|^)(````*)/))) {
      const s = n[2];
      t = Vee(r.slice(e), s);
      break;
    }
    if (i.type === "paragraph" && i.raw.match(/(\n|^)\|/)) {
      t = Yee(r.slice(e));
      break;
    }
    if (e === r.length - 1 && i.type === "list") {
      const s = Fee(i);
      if (s) {
        t = [s];
        break;
      }
    }
    if (e === r.length - 1 && i.type === "paragraph") {
      const s = hz(i);
      if (s) {
        t = [s];
        break;
      }
    }
  }
  if (t) {
    const i = [
      ...r.slice(0, e),
      ...t
    ];
    return i.links = r.links, i;
  }
  return null;
}
function Vee(r, e) {
  const t = nv(r);
  return Fr.lexer(t + `
${e}`);
}
function zee(r) {
  return nh(r, "`");
}
function Uee(r) {
  return nh(r, "*");
}
function $ee(r) {
  return nh(r, "_");
}
function Kee(r) {
  return nh(r, ")");
}
function jee(r) {
  return nh(r, '")');
}
function qee(r) {
  return nh(r, "](https://microsoft.com)");
}
function Gee(r) {
  return nh(r, "**");
}
function Zee(r) {
  return nh(r, "__");
}
function nh(r, e) {
  const t = nv(Array.isArray(r) ? r : [r]);
  return Fr.lexer(t + e)[0];
}
function Yee(r) {
  const e = nv(r), t = e.split(`
`);
  let i, n = !1;
  for (let s = 0; s < t.length; s++) {
    const o = t[s].trim();
    if (typeof i > "u" && o.match(/^\s*\|/)) {
      const a = o.match(/(\|[^\|]+)(?=\||$)/g);
      a && (i = a.length);
    } else if (typeof i == "number")
      if (o.match(/^\s*\|/)) {
        if (s !== t.length - 1)
          return;
        n = !0;
      } else
        return;
  }
  if (typeof i == "number" && i > 0) {
    const s = n ? t.slice(0, -1).join(`
`) : e, o = !!s.match(/\|\s*$/), a = s + (o ? "" : "|") + `
|${" --- |".repeat(i)}`;
    return Fr.lexer(a);
  }
}
function WO(r, e) {
  return AH(r, e), Se(() => PH(r));
}
var Qee = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, BO = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, RI;
let nl = RI = class {
  constructor(e, t, i) {
    this._options = e, this._languageService = t, this._openerService = i, this._onDidRenderAsync = new R(), this.onDidRenderAsync = this._onDidRenderAsync.event;
  }
  dispose() {
    this._onDidRenderAsync.dispose();
  }
  render(e, t, i) {
    if (!e)
      return { element: document.createElement("span"), dispose: () => {
      } };
    const n = new q(), s = n.add(z0(e, { ...this._getRenderOptions(e, n), ...t }, i));
    return s.element.classList.add("rendered-markdown"), {
      element: s.element,
      dispose: () => n.dispose()
    };
  }
  _getRenderOptions(e, t) {
    return {
      codeBlockRenderer: async (i, n) => {
        var s, o, a;
        let l;
        i ? l = this._languageService.getLanguageIdByLanguageName(i) : this._options.editor && (l = (s = this._options.editor.getModel()) === null || s === void 0 ? void 0 : s.getLanguageId()), l || (l = go);
        const d = await PX(this._languageService, n, l), c = document.createElement("span");
        if (c.innerHTML = (a = (o = RI._ttpTokenizer) === null || o === void 0 ? void 0 : o.createHTML(d)) !== null && a !== void 0 ? a : d, this._options.editor) {
          const h = this._options.editor.getOption(
            50
            /* EditorOption.fontInfo */
          );
          _n(c, h);
        } else this._options.codeBlockFontFamily && (c.style.fontFamily = this._options.codeBlockFontFamily);
        return this._options.codeBlockFontSize !== void 0 && (c.style.fontSize = this._options.codeBlockFontSize), c;
      },
      asyncRenderCallback: () => this._onDidRenderAsync.fire(),
      actionHandler: {
        callback: (i) => uM(this._openerService, i, e.isTrusted),
        disposables: t
      }
    };
  }
};
nl._ttpTokenizer = wd("tokenizeToString", {
  createHTML(r) {
    return r;
  }
});
nl = RI = Qee([
  BO(1, Jt),
  BO(2, Ys)
], nl);
async function uM(r, e, t) {
  try {
    return await r.open(e, {
      fromUserGesture: !0,
      allowContributedOpeners: !0,
      allowCommands: Xee(t)
    });
  } catch (i) {
    return He(i), !1;
  }
}
function Xee(r) {
  return r === !0 ? !0 : r && Array.isArray(r.enabledCommands) ? r.enabledCommands : !1;
}
var Jee = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, rm = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
const pa = X;
let AI = class extends bo {
  get _targetWindow() {
    return we(this._target.targetElements[0]);
  }
  get _targetDocumentElement() {
    return we(this._target.targetElements[0]).document.documentElement;
  }
  get isDisposed() {
    return this._isDisposed;
  }
  get isMouseIn() {
    return this._lockMouseTracker.isMouseIn;
  }
  get domNode() {
    return this._hover.containerDomNode;
  }
  get onDispose() {
    return this._onDispose.event;
  }
  get onRequestLayout() {
    return this._onRequestLayout.event;
  }
  get anchor() {
    return this._hoverPosition === 2 ? 0 : 1;
  }
  get x() {
    return this._x;
  }
  get y() {
    return this._y;
  }
  /**
   * Whether the hover is "locked" by holding the alt/option key. When locked, the hover will not
   * hide and can be hovered regardless of whether the `hideOnHover` hover option is set.
   */
  get isLocked() {
    return this._isLocked;
  }
  set isLocked(e) {
    this._isLocked !== e && (this._isLocked = e, this._hoverContainer.classList.toggle("locked", this._isLocked));
  }
  constructor(e, t, i, n, s, o) {
    var a, l, d, c, h, u, g, f;
    super(), this._keybindingService = t, this._configurationService = i, this._openerService = n, this._instantiationService = s, this._accessibilityService = o, this._messageListeners = new q(), this._isDisposed = !1, this._forcePosition = !1, this._x = 0, this._y = 0, this._isLocked = !1, this._enableFocusTraps = !1, this._addedFocusTrap = !1, this._onDispose = this._register(new R()), this._onRequestLayout = this._register(new R()), this._linkHandler = e.linkHandler || ((w) => uM(this._openerService, w, Gr(e.content) ? e.content.isTrusted : void 0)), this._target = "targetElements" in e.target ? e.target : new ete(e.target), this._hoverPointer = !((a = e.appearance) === null || a === void 0) && a.showPointer ? pa("div.workbench-hover-pointer") : void 0, this._hover = this._register(new iM()), this._hover.containerDomNode.classList.add("workbench-hover", "fadeIn"), !((l = e.appearance) === null || l === void 0) && l.compact && this._hover.containerDomNode.classList.add("workbench-hover", "compact"), !((d = e.appearance) === null || d === void 0) && d.skipFadeInAnimation && this._hover.containerDomNode.classList.add("skip-fade-in"), e.additionalClasses && this._hover.containerDomNode.classList.add(...e.additionalClasses), !((c = e.position) === null || c === void 0) && c.forcePosition && (this._forcePosition = !0), e.trapFocus && (this._enableFocusTraps = !0), this._hoverPosition = (u = (h = e.position) === null || h === void 0 ? void 0 : h.hoverPosition) !== null && u !== void 0 ? u : 3, this.onmousedown(this._hover.containerDomNode, (w) => w.stopPropagation()), this.onkeydown(this._hover.containerDomNode, (w) => {
      w.equals(
        9
        /* KeyCode.Escape */
      ) && this.dispose();
    }), this._register(W(this._targetWindow, "blur", () => this.dispose()));
    const m = pa("div.hover-row.markdown-hover"), _ = pa("div.hover-contents");
    if (typeof e.content == "string")
      _.textContent = e.content, _.style.whiteSpace = "pre-wrap";
    else if (ln(e.content))
      _.appendChild(e.content), _.classList.add("html-hover-contents");
    else {
      const w = e.content, S = this._instantiationService.createInstance(nl, { codeBlockFontFamily: this._configurationService.getValue("editor").fontFamily || Ss.fontFamily }), { element: y } = S.render(w, {
        actionHandler: {
          callback: (k) => this._linkHandler(k),
          disposables: this._messageListeners
        },
        asyncRenderCallback: () => {
          _.classList.add("code-hover-contents"), this.layout(), this._onRequestLayout.fire();
        }
      });
      _.appendChild(y);
    }
    if (m.appendChild(_), this._hover.contentsDomNode.appendChild(m), e.actions && e.actions.length > 0) {
      const w = pa("div.hover-row.status-bar"), S = pa("div.actions");
      e.actions.forEach((y) => {
        const k = this._keybindingService.lookupKeybinding(y.commandId), E = k ? k.getLabel() : null;
        B0.render(S, {
          label: y.label,
          commandId: y.commandId,
          run: (N) => {
            y.run(N), this.dispose();
          },
          iconClass: y.iconClass
        }, E);
      }), w.appendChild(S), this._hover.containerDomNode.appendChild(w);
    }
    this._hoverContainer = pa("div.workbench-hover-container"), this._hoverPointer && this._hoverContainer.appendChild(this._hoverPointer), this._hoverContainer.appendChild(this._hover.containerDomNode);
    let v;
    if (e.actions && e.actions.length > 0 ? v = !1 : ((g = e.persistence) === null || g === void 0 ? void 0 : g.hideOnHover) === void 0 ? v = typeof e.content == "string" || Gr(e.content) && !e.content.value.includes("](") && !e.content.value.includes("</a>") : v = e.persistence.hideOnHover, v && (!((f = e.appearance) === null || f === void 0) && f.showHoverHint)) {
      const w = pa("div.hover-row.status-bar"), S = pa("div.info");
      S.textContent = p("hoverhint", "Hold {0} key to mouse over", Je ? "Option" : "Alt"), w.appendChild(S), this._hover.containerDomNode.appendChild(w);
    }
    const b = [...this._target.targetElements];
    v || b.push(this._hoverContainer);
    const C = this._register(new HO(b));
    if (this._register(C.onMouseOut(() => {
      this._isLocked || this.dispose();
    })), v) {
      const w = [...this._target.targetElements, this._hoverContainer];
      this._lockMouseTracker = this._register(new HO(w)), this._register(this._lockMouseTracker.onMouseOut(() => {
        this._isLocked || this.dispose();
      }));
    } else
      this._lockMouseTracker = C;
  }
  addFocusTrap() {
    if (!this._enableFocusTraps || this._addedFocusTrap)
      return;
    this._addedFocusTrap = !0;
    const e = this._hover.containerDomNode, t = this.findLastFocusableChild(this._hover.containerDomNode);
    if (t) {
      const i = r1(this._hoverContainer, pa("div")), n = G(this._hoverContainer, pa("div"));
      i.tabIndex = 0, n.tabIndex = 0, this._register(W(n, "focus", (s) => {
        e.focus(), s.preventDefault();
      })), this._register(W(i, "focus", (s) => {
        t.focus(), s.preventDefault();
      }));
    }
  }
  findLastFocusableChild(e) {
    if (e.hasChildNodes())
      for (let t = 0; t < e.childNodes.length; t++) {
        const i = e.childNodes.item(e.childNodes.length - t - 1);
        if (i.nodeType === i.ELEMENT_NODE) {
          const s = i;
          if (typeof s.tabIndex == "number" && s.tabIndex >= 0)
            return s;
        }
        const n = this.findLastFocusableChild(i);
        if (n)
          return n;
      }
  }
  render(e) {
    var t;
    e.appendChild(this._hoverContainer);
    const n = this._hoverContainer.contains(this._hoverContainer.ownerDocument.activeElement) && Y2(this._configurationService.getValue("accessibility.verbosity.hover") === !0 && this._accessibilityService.isScreenReaderOptimized(), (t = this._keybindingService.lookupKeybinding("editor.action.accessibleView")) === null || t === void 0 ? void 0 : t.getAriaLabel());
    n && el(n), this.layout(), this.addFocusTrap();
  }
  layout() {
    this._hover.containerDomNode.classList.remove("right-aligned"), this._hover.contentsDomNode.style.maxHeight = "";
    const e = (c) => {
      const h = VH(c), u = c.getBoundingClientRect();
      return {
        top: u.top * h,
        bottom: u.bottom * h,
        right: u.right * h,
        left: u.left * h
      };
    }, t = this._target.targetElements.map((c) => e(c)), { top: i, right: n, bottom: s, left: o } = t[0], a = n - o, l = s - i, d = {
      top: i,
      right: n,
      bottom: s,
      left: o,
      width: a,
      height: l,
      center: {
        x: o + a / 2,
        y: i + l / 2
      }
    };
    if (this.adjustHorizontalHoverPosition(d), this.adjustVerticalHoverPosition(d), this.adjustHoverMaxHeight(d), this._hoverContainer.style.padding = "", this._hoverContainer.style.margin = "", this._hoverPointer) {
      switch (this._hoverPosition) {
        case 1:
          d.left += 3, d.right += 3, this._hoverContainer.style.paddingLeft = "3px", this._hoverContainer.style.marginLeft = "-3px";
          break;
        case 0:
          d.left -= 3, d.right -= 3, this._hoverContainer.style.paddingRight = "3px", this._hoverContainer.style.marginRight = "-3px";
          break;
        case 2:
          d.top += 3, d.bottom += 3, this._hoverContainer.style.paddingTop = "3px", this._hoverContainer.style.marginTop = "-3px";
          break;
        case 3:
          d.top -= 3, d.bottom -= 3, this._hoverContainer.style.paddingBottom = "3px", this._hoverContainer.style.marginBottom = "-3px";
          break;
      }
      d.center.x = d.left + a / 2, d.center.y = d.top + l / 2;
    }
    this.computeXCordinate(d), this.computeYCordinate(d), this._hoverPointer && (this._hoverPointer.classList.remove("top"), this._hoverPointer.classList.remove("left"), this._hoverPointer.classList.remove("right"), this._hoverPointer.classList.remove("bottom"), this.setHoverPointerPosition(d)), this._hover.onContentsChanged();
  }
  computeXCordinate(e) {
    const t = this._hover.containerDomNode.clientWidth + 2;
    this._target.x !== void 0 ? this._x = this._target.x : this._hoverPosition === 1 ? this._x = e.right : this._hoverPosition === 0 ? this._x = e.left - t : (this._hoverPointer ? this._x = e.center.x - this._hover.containerDomNode.clientWidth / 2 : this._x = e.left, this._x + t >= this._targetDocumentElement.clientWidth && (this._hover.containerDomNode.classList.add("right-aligned"), this._x = Math.max(this._targetDocumentElement.clientWidth - t - 2, this._targetDocumentElement.clientLeft))), this._x < this._targetDocumentElement.clientLeft && (this._x = e.left + 2);
  }
  computeYCordinate(e) {
    this._target.y !== void 0 ? this._y = this._target.y : this._hoverPosition === 3 ? this._y = e.top : this._hoverPosition === 2 ? this._y = e.bottom - 2 : this._hoverPointer ? this._y = e.center.y + this._hover.containerDomNode.clientHeight / 2 : this._y = e.bottom, this._y > this._targetWindow.innerHeight && (this._y = e.bottom);
  }
  adjustHorizontalHoverPosition(e) {
    if (this._target.x !== void 0)
      return;
    const t = this._hoverPointer ? 3 : 0;
    if (this._forcePosition) {
      const i = t + 2;
      this._hoverPosition === 1 ? this._hover.containerDomNode.style.maxWidth = `${this._targetDocumentElement.clientWidth - e.right - i}px` : this._hoverPosition === 0 && (this._hover.containerDomNode.style.maxWidth = `${e.left - i}px`);
      return;
    }
    this._hoverPosition === 1 ? this._targetDocumentElement.clientWidth - e.right < this._hover.containerDomNode.clientWidth + t && (e.left >= this._hover.containerDomNode.clientWidth + t ? this._hoverPosition = 0 : this._hoverPosition = 2) : this._hoverPosition === 0 && (e.left < this._hover.containerDomNode.clientWidth + t && (this._targetDocumentElement.clientWidth - e.right >= this._hover.containerDomNode.clientWidth + t ? this._hoverPosition = 1 : this._hoverPosition = 2), e.left - this._hover.containerDomNode.clientWidth - t <= this._targetDocumentElement.clientLeft && (this._hoverPosition = 1));
  }
  adjustVerticalHoverPosition(e) {
    if (this._target.y !== void 0 || this._forcePosition)
      return;
    const t = this._hoverPointer ? 3 : 0;
    this._hoverPosition === 3 ? e.top - this._hover.containerDomNode.clientHeight - t < 0 && (this._hoverPosition = 2) : this._hoverPosition === 2 && e.bottom + this._hover.containerDomNode.clientHeight + t > this._targetWindow.innerHeight && (this._hoverPosition = 3);
  }
  adjustHoverMaxHeight(e) {
    let t = this._targetWindow.innerHeight / 2;
    if (this._forcePosition) {
      const i = (this._hoverPointer ? 3 : 0) + 2;
      this._hoverPosition === 3 ? t = Math.min(t, e.top - i) : this._hoverPosition === 2 && (t = Math.min(t, this._targetWindow.innerHeight - e.bottom - i));
    }
    if (this._hover.containerDomNode.style.maxHeight = `${t}px`, this._hover.contentsDomNode.clientHeight < this._hover.contentsDomNode.scrollHeight) {
      const i = `${this._hover.scrollbar.options.verticalScrollbarSize}px`;
      this._hover.contentsDomNode.style.paddingRight !== i && (this._hover.contentsDomNode.style.paddingRight = i);
    }
  }
  setHoverPointerPosition(e) {
    if (this._hoverPointer)
      switch (this._hoverPosition) {
        case 0:
        case 1: {
          this._hoverPointer.classList.add(this._hoverPosition === 0 ? "right" : "left");
          const t = this._hover.containerDomNode.clientHeight;
          t > e.height ? this._hoverPointer.style.top = `${e.center.y - (this._y - t) - 3}px` : this._hoverPointer.style.top = `${Math.round(t / 2) - 3}px`;
          break;
        }
        case 3:
        case 2: {
          this._hoverPointer.classList.add(this._hoverPosition === 3 ? "bottom" : "top");
          const t = this._hover.containerDomNode.clientWidth;
          let i = Math.round(t / 2) - 3;
          const n = this._x + i;
          (n < e.left || n > e.right) && (i = e.center.x - this._x - 3), this._hoverPointer.style.left = `${i}px`;
          break;
        }
      }
  }
  focus() {
    this._hover.containerDomNode.focus();
  }
  dispose() {
    this._isDisposed || (this._onDispose.fire(), this._hoverContainer.remove(), this._messageListeners.dispose(), this._target.dispose(), super.dispose()), this._isDisposed = !0;
  }
};
AI = Jee([
  rm(1, _t),
  rm(2, Ge),
  rm(3, Ys),
  rm(4, be),
  rm(5, qs)
], AI);
class HO extends bo {
  get onMouseOut() {
    return this._onMouseOut.event;
  }
  get isMouseIn() {
    return this._isMouseIn;
  }
  constructor(e) {
    super(), this._elements = e, this._isMouseIn = !0, this._onMouseOut = this._register(new R()), this._elements.forEach((t) => this.onmouseover(t, () => this._onTargetMouseOver(t))), this._elements.forEach((t) => this.onmouseleave(t, () => this._onTargetMouseLeave(t)));
  }
  _onTargetMouseOver(e) {
    this._isMouseIn = !0, this._clearEvaluateMouseStateTimeout(e);
  }
  _onTargetMouseLeave(e) {
    this._isMouseIn = !1, this._evaluateMouseState(e);
  }
  _evaluateMouseState(e) {
    this._clearEvaluateMouseStateTimeout(e), this._mouseTimeout = we(e).setTimeout(() => this._fireIfMouseOutside(), 0);
  }
  _clearEvaluateMouseStateTimeout(e) {
    this._mouseTimeout && (we(e).clearTimeout(this._mouseTimeout), this._mouseTimeout = void 0);
  }
  _fireIfMouseOutside() {
    this._isMouseIn || this._onMouseOut.fire();
  }
}
class ete {
  constructor(e) {
    this._element = e, this.targetElements = [this._element];
  }
  dispose() {
  }
}
var In;
(function(r) {
  function e(s, o) {
    if (s.start >= o.end || o.start >= s.end)
      return { start: 0, end: 0 };
    const a = Math.max(s.start, o.start), l = Math.min(s.end, o.end);
    return l - a <= 0 ? { start: 0, end: 0 } : { start: a, end: l };
  }
  r.intersect = e;
  function t(s) {
    return s.end - s.start <= 0;
  }
  r.isEmpty = t;
  function i(s, o) {
    return !t(e(s, o));
  }
  r.intersects = i;
  function n(s, o) {
    const a = [], l = { start: s.start, end: Math.min(o.start, s.end) }, d = { start: Math.max(o.end, s.start), end: s.end };
    return t(l) || a.push(l), t(d) || a.push(d), a;
  }
  r.relativeComplement = n;
})(In || (In = {}));
function tte(r) {
  const e = r;
  return !!e && typeof e.x == "number" && typeof e.y == "number";
}
var ac;
(function(r) {
  r[r.AVOID = 0] = "AVOID", r[r.ALIGN = 1] = "ALIGN";
})(ac || (ac = {}));
function ef(r, e, t) {
  const i = t.mode === ac.ALIGN ? t.offset : t.offset + t.size, n = t.mode === ac.ALIGN ? t.offset + t.size : t.offset;
  return t.position === 0 ? e <= r - i ? i : e <= n ? n - e : Math.max(r - e, 0) : e <= n ? n - e : e <= r - i ? i : 0;
}
class ep extends P {
  constructor(e, t) {
    super(), this.container = null, this.useFixedPosition = !1, this.useShadowDOM = !1, this.delegate = null, this.toDisposeOnClean = P.None, this.toDisposeOnSetContainer = P.None, this.shadowRoot = null, this.shadowRootHostElement = null, this.view = X(".context-view"), Xn(this.view), this.setContainer(e, t), this._register(Se(() => this.setContainer(
      null,
      1
      /* ContextViewDOMPosition.ABSOLUTE */
    )));
  }
  setContainer(e, t) {
    var i;
    this.useFixedPosition = t !== 1;
    const n = this.useShadowDOM;
    if (this.useShadowDOM = t === 3, !(e === this.container && n === this.useShadowDOM) && (this.container && (this.toDisposeOnSetContainer.dispose(), this.shadowRoot ? (this.shadowRoot.removeChild(this.view), this.shadowRoot = null, (i = this.shadowRootHostElement) === null || i === void 0 || i.remove(), this.shadowRootHostElement = null) : this.container.removeChild(this.view), this.container = null), e)) {
      if (this.container = e, this.useShadowDOM) {
        this.shadowRootHostElement = X(".shadow-root-host"), this.container.appendChild(this.shadowRootHostElement), this.shadowRoot = this.shadowRootHostElement.attachShadow({ mode: "open" });
        const o = document.createElement("style");
        o.textContent = ite, this.shadowRoot.appendChild(o), this.shadowRoot.appendChild(this.view), this.shadowRoot.appendChild(X("slot"));
      } else
        this.container.appendChild(this.view);
      const s = new q();
      ep.BUBBLE_UP_EVENTS.forEach((o) => {
        s.add(pi(this.container, o, (a) => {
          this.onDOMEvent(a, !1);
        }));
      }), ep.BUBBLE_DOWN_EVENTS.forEach((o) => {
        s.add(pi(this.container, o, (a) => {
          this.onDOMEvent(a, !0);
        }, !0));
      }), this.toDisposeOnSetContainer = s;
    }
  }
  show(e) {
    var t, i, n;
    this.isVisible() && this.hide(), pn(this.view), this.view.className = "context-view monaco-component", this.view.style.top = "0px", this.view.style.left = "0px", this.view.style.zIndex = `${2575 + ((t = e.layer) !== null && t !== void 0 ? t : 0)}`, this.view.style.position = this.useFixedPosition ? "fixed" : "absolute", As(this.view), this.toDisposeOnClean = e.render(this.view) || P.None, this.delegate = e, this.doLayout(), (n = (i = this.delegate).focus) === null || n === void 0 || n.call(i);
  }
  getViewElement() {
    return this.view;
  }
  layout() {
    var e, t;
    if (this.isVisible()) {
      if (this.delegate.canRelayout === !1 && !(Zr && JN.pointerEvents)) {
        this.hide();
        return;
      }
      (t = (e = this.delegate) === null || e === void 0 ? void 0 : e.layout) === null || t === void 0 || t.call(e), this.doLayout();
    }
  }
  doLayout() {
    if (!this.isVisible())
      return;
    const e = this.delegate.getAnchor();
    let t;
    if (ln(e)) {
      const u = Ei(e), g = VH(e);
      t = {
        top: u.top * g,
        left: u.left * g,
        width: u.width * g,
        height: u.height * g
      };
    } else tte(e) ? t = {
      top: e.y,
      left: e.x,
      width: e.width || 1,
      height: e.height || 2
    } : t = {
      top: e.posy,
      left: e.posx,
      // We are about to position the context view where the mouse
      // cursor is. To prevent the view being exactly under the mouse
      // when showing and thus potentially triggering an action within,
      // we treat the mouse location like a small sized block element.
      width: 2,
      height: 2
    };
    const i = Ms(this.view), n = Bl(this.view), s = this.delegate.anchorPosition || 0, o = this.delegate.anchorAlignment || 0, a = this.delegate.anchorAxisAlignment || 0;
    let l, d;
    const c = kw();
    if (a === 0) {
      const u = {
        offset: t.top - c.pageYOffset,
        size: t.height,
        position: s === 0 ? 0 : 1
        /* LayoutAnchorPosition.After */
      }, g = { offset: t.left, size: t.width, position: o === 0 ? 0 : 1, mode: ac.ALIGN };
      l = ef(c.innerHeight, n, u) + c.pageYOffset, In.intersects({ start: l, end: l + n }, { start: u.offset, end: u.offset + u.size }) && (g.mode = ac.AVOID), d = ef(c.innerWidth, i, g);
    } else {
      const u = {
        offset: t.left,
        size: t.width,
        position: o === 0 ? 0 : 1
        /* LayoutAnchorPosition.After */
      }, g = { offset: t.top, size: t.height, position: s === 0 ? 0 : 1, mode: ac.ALIGN };
      d = ef(c.innerWidth, i, u), In.intersects({ start: d, end: d + i }, { start: u.offset, end: u.offset + u.size }) && (g.mode = ac.AVOID), l = ef(c.innerHeight, n, g) + c.pageYOffset;
    }
    this.view.classList.remove("top", "bottom", "left", "right"), this.view.classList.add(s === 0 ? "bottom" : "top"), this.view.classList.add(o === 0 ? "left" : "right"), this.view.classList.toggle("fixed", this.useFixedPosition);
    const h = Ei(this.container);
    this.view.style.top = `${l - (this.useFixedPosition ? Ei(this.view).top : h.top)}px`, this.view.style.left = `${d - (this.useFixedPosition ? Ei(this.view).left : h.left)}px`, this.view.style.width = "initial";
  }
  hide(e) {
    const t = this.delegate;
    this.delegate = null, t != null && t.onHide && t.onHide(e), this.toDisposeOnClean.dispose(), Xn(this.view);
  }
  isVisible() {
    return !!this.delegate;
  }
  onDOMEvent(e, t) {
    this.delegate && (this.delegate.onDOMEvent ? this.delegate.onDOMEvent(e, we(e).document.activeElement) : t && !qi(e.target, this.container) && this.hide());
  }
  dispose() {
    this.hide(), super.dispose();
  }
}
ep.BUBBLE_UP_EVENTS = ["click", "keydown", "focus", "blur"];
ep.BUBBLE_DOWN_EVENTS = ["click"];
const ite = (
  /* css */
  `
	:host {
		all: initial; /* 1st rule so subsequent properties are reset. */
	}

	.codicon[class*='codicon-'] {
		font: normal normal normal 16px/1 codicon;
		display: inline-block;
		text-decoration: none;
		text-rendering: auto;
		text-align: center;
		-webkit-font-smoothing: antialiased;
		-moz-osx-font-smoothing: grayscale;
		user-select: none;
		-webkit-user-select: none;
		-ms-user-select: none;
	}

	:host {
		font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "HelveticaNeue-Light", system-ui, "Ubuntu", "Droid Sans", sans-serif;
	}

	:host-context(.mac) { font-family: -apple-system, BlinkMacSystemFont, sans-serif; }
	:host-context(.mac:lang(zh-Hans)) { font-family: -apple-system, BlinkMacSystemFont, "PingFang SC", "Hiragino Sans GB", sans-serif; }
	:host-context(.mac:lang(zh-Hant)) { font-family: -apple-system, BlinkMacSystemFont, "PingFang TC", sans-serif; }
	:host-context(.mac:lang(ja)) { font-family: -apple-system, BlinkMacSystemFont, "Hiragino Kaku Gothic Pro", sans-serif; }
	:host-context(.mac:lang(ko)) { font-family: -apple-system, BlinkMacSystemFont, "Nanum Gothic", "Apple SD Gothic Neo", "AppleGothic", sans-serif; }

	:host-context(.windows) { font-family: "Segoe WPC", "Segoe UI", sans-serif; }
	:host-context(.windows:lang(zh-Hans)) { font-family: "Segoe WPC", "Segoe UI", "Microsoft YaHei", sans-serif; }
	:host-context(.windows:lang(zh-Hant)) { font-family: "Segoe WPC", "Segoe UI", "Microsoft Jhenghei", sans-serif; }
	:host-context(.windows:lang(ja)) { font-family: "Segoe WPC", "Segoe UI", "Yu Gothic UI", "Meiryo UI", sans-serif; }
	:host-context(.windows:lang(ko)) { font-family: "Segoe WPC", "Segoe UI", "Malgun Gothic", "Dotom", sans-serif; }

	:host-context(.linux) { font-family: system-ui, "Ubuntu", "Droid Sans", sans-serif; }
	:host-context(.linux:lang(zh-Hans)) { font-family: system-ui, "Ubuntu", "Droid Sans", "Source Han Sans SC", "Source Han Sans CN", "Source Han Sans", sans-serif; }
	:host-context(.linux:lang(zh-Hant)) { font-family: system-ui, "Ubuntu", "Droid Sans", "Source Han Sans TC", "Source Han Sans TW", "Source Han Sans", sans-serif; }
	:host-context(.linux:lang(ja)) { font-family: system-ui, "Ubuntu", "Droid Sans", "Source Han Sans J", "Source Han Sans JP", "Source Han Sans", sans-serif; }
	:host-context(.linux:lang(ko)) { font-family: system-ui, "Ubuntu", "Droid Sans", "Source Han Sans K", "Source Han Sans JR", "Source Han Sans", "UnDotum", "FBaekmuk Gulim", sans-serif; }
`
);
var nte = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, ste = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
let HS = class extends P {
  constructor(e) {
    super(), this.layoutService = e, this.contextView = this._register(new ep(
      this.layoutService.mainContainer,
      1
      /* ContextViewDOMPosition.ABSOLUTE */
    )), this.layout(), this._register(e.onDidLayoutContainer(() => this.layout()));
  }
  // ContextView
  showContextView(e, t, i) {
    let n;
    t ? t === this.layoutService.getContainer(we(t)) ? n = 1 : i ? n = 3 : n = 2 : n = 1, this.contextView.setContainer(t ?? this.layoutService.activeContainer, n), this.contextView.show(e);
    const s = {
      close: () => {
        this.openContextView === s && this.hideContextView();
      }
    };
    return this.openContextView = s, s;
  }
  layout() {
    this.contextView.layout();
  }
  hideContextView(e) {
    this.contextView.hide(e), this.openContextView = void 0;
  }
};
HS = nte([
  ste(0, ih)
], HS);
class ote extends HS {
  getContextViewElement() {
    return this.contextView.getViewElement();
  }
}
class rte {
  constructor(e, t, i) {
    this.hoverDelegate = e, this.target = t, this.fadeInAnimation = i;
  }
  async update(e, t, i) {
    var n;
    if (this._cancellationTokenSource && (this._cancellationTokenSource.dispose(!0), this._cancellationTokenSource = void 0), this.isDisposed)
      return;
    let s;
    if (e === void 0 || Ws(e) || ln(e))
      s = e;
    else if (!aS(e.markdown))
      s = (n = e.markdown) !== null && n !== void 0 ? n : e.markdownNotSupportedFallback;
    else {
      this._hoverWidget || this.show(p("iconLabel.loading", "Loading..."), t, i), this._cancellationTokenSource = new mi();
      const o = this._cancellationTokenSource.token;
      if (s = await e.markdown(o), s === void 0 && (s = e.markdownNotSupportedFallback), this.isDisposed || o.isCancellationRequested)
        return;
    }
    this.show(s, t, i);
  }
  show(e, t, i) {
    const n = this._hoverWidget;
    if (this.hasContent(e)) {
      const s = {
        content: e,
        target: this.target,
        appearance: {
          showPointer: this.hoverDelegate.placement === "element",
          skipFadeInAnimation: !this.fadeInAnimation || !!n
          // do not fade in if the hover is already showing
        },
        position: {
          hoverPosition: 2
        },
        ...i
      };
      this._hoverWidget = this.hoverDelegate.showHover(s, t);
    }
    n == null || n.dispose();
  }
  hasContent(e) {
    return e ? Gr(e) ? !!e.value : !0 : !1;
  }
  get isDisposed() {
    var e;
    return (e = this._hoverWidget) === null || e === void 0 ? void 0 : e.isDisposed;
  }
  dispose() {
    var e, t;
    (e = this._hoverWidget) === null || e === void 0 || e.dispose(), (t = this._cancellationTokenSource) === null || t === void 0 || t.dispose(!0), this._cancellationTokenSource = void 0;
  }
}
var ate = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, am = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
let PI = class extends P {
  constructor(e, t, i, n, s) {
    super(), this._instantiationService = e, this._keybindingService = i, this._layoutService = n, this._accessibilityService = s, this._existingHovers = /* @__PURE__ */ new Map(), t.onDidShowContextMenu(() => this.hideHover()), this._contextViewHandler = this._register(new HS(this._layoutService));
  }
  showHover(e, t, i) {
    var n, s, o, a;
    if (VO(this._currentHoverOptions) === VO(e) || this._currentHover && (!((s = (n = this._currentHoverOptions) === null || n === void 0 ? void 0 : n.persistence) === null || s === void 0) && s.sticky))
      return;
    this._currentHoverOptions = e, this._lastHoverOptions = e;
    const l = e.trapFocus || this._accessibilityService.isScreenReaderOptimized(), d = Ln();
    i || (l && d ? d.classList.contains("monaco-hover") || (this._lastFocusedElementBeforeOpen = d) : this._lastFocusedElementBeforeOpen = void 0);
    const c = new q(), h = this._instantiationService.createInstance(AI, e);
    if (!((o = e.persistence) === null || o === void 0) && o.sticky && (h.isLocked = !0), h.onDispose(() => {
      var u, g;
      ((u = this._currentHover) === null || u === void 0 ? void 0 : u.domNode) && UH(this._currentHover.domNode) && ((g = this._lastFocusedElementBeforeOpen) === null || g === void 0 || g.focus()), this._currentHoverOptions === e && (this._currentHoverOptions = void 0), c.dispose();
    }, void 0, c), !e.container) {
      const u = ln(e.target) ? e.target : e.target.targetElements[0];
      e.container = this._layoutService.getContainer(we(u));
    }
    if (this._contextViewHandler.showContextView(new lte(h, t), e.container), h.onRequestLayout(() => this._contextViewHandler.layout(), void 0, c), !((a = e.persistence) === null || a === void 0) && a.sticky)
      c.add(W(we(e.container).document, Q.MOUSE_DOWN, (u) => {
        qi(u.target, h.domNode) || this.doHideHover();
      }));
    else {
      if ("targetElements" in e.target)
        for (const g of e.target.targetElements)
          c.add(W(g, Q.CLICK, () => this.hideHover()));
      else
        c.add(W(e.target, Q.CLICK, () => this.hideHover()));
      const u = Ln();
      if (u) {
        const g = we(u).document;
        c.add(W(u, Q.KEY_DOWN, (f) => {
          var m;
          return this._keyDown(f, h, !!(!((m = e.persistence) === null || m === void 0) && m.hideOnKeyDown));
        })), c.add(W(g, Q.KEY_DOWN, (f) => {
          var m;
          return this._keyDown(f, h, !!(!((m = e.persistence) === null || m === void 0) && m.hideOnKeyDown));
        })), c.add(W(u, Q.KEY_UP, (f) => this._keyUp(f, h))), c.add(W(g, Q.KEY_UP, (f) => this._keyUp(f, h)));
      }
    }
    if ("IntersectionObserver" in Dt) {
      const u = new IntersectionObserver((f) => this._intersectionChange(f, h), { threshold: 0 }), g = "targetElements" in e.target ? e.target.targetElements[0] : e.target;
      u.observe(g), c.add(Se(() => u.disconnect()));
    }
    return this._currentHover = h, h;
  }
  hideHover() {
    var e;
    !((e = this._currentHover) === null || e === void 0) && e.isLocked || !this._currentHoverOptions || this.doHideHover();
  }
  doHideHover() {
    this._currentHover = void 0, this._currentHoverOptions = void 0, this._contextViewHandler.hideContextView();
  }
  _intersectionChange(e, t) {
    e[e.length - 1].isIntersecting || t.dispose();
  }
  showAndFocusLastHover() {
    this._lastHoverOptions && this.showHover(this._lastHoverOptions, !0, !0);
  }
  _keyDown(e, t, i) {
    var n, s;
    if (e.key === "Alt") {
      t.isLocked = !0;
      return;
    }
    const o = new Mt(e);
    this._keybindingService.resolveKeyboardEvent(o).getSingleModifierDispatchChords().some((l) => !!l) || this._keybindingService.softDispatch(o, o.target).kind !== 0 || i && (!(!((n = this._currentHoverOptions) === null || n === void 0) && n.trapFocus) || e.key !== "Tab") && (this.hideHover(), (s = this._lastFocusedElementBeforeOpen) === null || s === void 0 || s.focus());
  }
  _keyUp(e, t) {
    var i;
    e.key === "Alt" && (t.isLocked = !1, t.isMouseIn || (this.hideHover(), (i = this._lastFocusedElementBeforeOpen) === null || i === void 0 || i.focus()));
  }
  // TODO: Investigate performance of this function. There seems to be a lot of content created
  //       and thrown away on start up
  setupUpdatableHover(e, t, i, n) {
    t.setAttribute("custom-hover", "true"), t.title !== "" && (console.warn("HTML element already has a title attribute, which will conflict with the custom hover. Please remove the title attribute."), console.trace("Stack trace:", t.title), t.title = "");
    let s, o;
    const a = (C, w) => {
      var S;
      const y = o !== void 0;
      C && (o == null || o.dispose(), o = void 0), w && (s == null || s.dispose(), s = void 0), y && ((S = e.onDidHideHover) === null || S === void 0 || S.call(e), o = void 0);
    }, l = (C, w, S, y) => new vr(async () => {
      (!o || o.isDisposed) && (o = new rte(e, S || t, C > 0), await o.update(typeof i == "function" ? i() : i, w, { ...n, trapFocus: y }));
    }, C);
    let d = !1;
    const c = W(t, Q.MOUSE_DOWN, () => {
      d = !0, a(!0, !0);
    }, !0), h = W(t, Q.MOUSE_UP, () => {
      d = !1;
    }, !0), u = W(t, Q.MOUSE_LEAVE, (C) => {
      d = !1, a(!1, C.fromElement === t);
    }, !0), g = (C) => {
      if (s)
        return;
      const w = new q(), S = {
        targetElements: [t],
        dispose: () => {
        }
      };
      if (e.placement === void 0 || e.placement === "mouse") {
        const y = (k) => {
          S.x = k.x + 10, ln(k.target) && zO(k.target, t) !== t && a(!0, !0);
        };
        w.add(W(t, Q.MOUSE_MOVE, y, !0));
      }
      s = w, !(ln(C.target) && zO(C.target, t) !== t) && w.add(l(e.delay, !1, S));
    }, f = W(t, Q.MOUSE_OVER, g, !0), m = () => {
      if (d || s)
        return;
      const C = {
        targetElements: [t],
        dispose: () => {
        }
      }, w = new q(), S = () => a(!0, !0);
      w.add(W(t, Q.BLUR, S, !0)), w.add(l(e.delay, !1, C)), s = w;
    };
    let _;
    const v = t.tagName.toLowerCase();
    v !== "input" && v !== "textarea" && (_ = W(t, Q.FOCUS, m, !0));
    const b = {
      show: (C) => {
        a(!1, !0), l(0, C, void 0, C);
      },
      hide: () => {
        a(!0, !0);
      },
      update: async (C, w) => {
        i = C, await (o == null ? void 0 : o.update(i, void 0, w));
      },
      dispose: () => {
        this._existingHovers.delete(t), f.dispose(), u.dispose(), c.dispose(), h.dispose(), _ == null || _.dispose(), a(!0, !0);
      }
    };
    return this._existingHovers.set(t, b), b;
  }
  triggerUpdatableHover(e) {
    const t = this._existingHovers.get(e);
    t && t.show(!0);
  }
  dispose() {
    this._existingHovers.forEach((e) => e.dispose()), super.dispose();
  }
};
PI = ate([
  am(0, be),
  am(1, Zs),
  am(2, _t),
  am(3, ih),
  am(4, qs)
], PI);
function VO(r) {
  var e;
  if (r !== void 0)
    return (e = r == null ? void 0 : r.id) !== null && e !== void 0 ? e : r;
}
class lte {
  get anchorPosition() {
    return this._hover.anchor;
  }
  constructor(e, t = !1) {
    this._hover = e, this._focus = t, this.layer = 1;
  }
  render(e) {
    return this._hover.render(e), this._focus && this._hover.focus(), this._hover;
  }
  getAnchor() {
    return {
      x: this._hover.x,
      y: this._hover.y
    };
  }
  layout() {
    this._hover.layout();
  }
}
function zO(r, e) {
  for (e = e ?? we(r).document.body; !r.hasAttribute("custom-hover") && r !== e; )
    r = r.parentElement;
  return r;
}
ot(
  gl,
  PI,
  1
  /* InstantiationType.Delayed */
);
Ho((r, e) => {
  const t = r.getColor(EV);
  t && (e.addRule(`.monaco-workbench .workbench-hover .hover-row:not(:first-child):not(:empty) { border-top: 1px solid ${t.transparent(0.5)}; }`), e.addRule(`.monaco-workbench .workbench-hover hr { border-top: 1px solid ${t.transparent(0.5)}; }`));
});
const yb = et("IWorkspaceEditService");
class gM {
  constructor(e) {
    this.metadata = e;
  }
  static convert(e) {
    return e.edits.map((t) => {
      if (vc.is(t))
        return vc.lift(t);
      if (kf.is(t))
        return kf.lift(t);
      throw new Error("Unsupported edit");
    });
  }
}
class vc extends gM {
  static is(e) {
    return e instanceof vc ? !0 : ur(e) && Ee.isUri(e.resource) && ur(e.textEdit);
  }
  static lift(e) {
    return e instanceof vc ? e : new vc(e.resource, e.textEdit, e.versionId, e.metadata);
  }
  constructor(e, t, i = void 0, n) {
    super(n), this.resource = e, this.textEdit = t, this.versionId = i;
  }
}
class kf extends gM {
  static is(e) {
    return e instanceof kf ? !0 : ur(e) && (!!e.newResource || !!e.oldResource);
  }
  static lift(e) {
    return e instanceof kf ? e : new kf(e.oldResource, e.newResource, e.options, e.metadata);
  }
  constructor(e, t, i = {}, n) {
    super(n), this.oldResource = e, this.newResource = t, this.options = i;
  }
}
const xn = {
  enableSplitViewResizing: !0,
  splitViewDefaultRatio: 0.5,
  renderSideBySide: !0,
  renderMarginRevertIcon: !0,
  renderGutterMenu: !0,
  maxComputationTime: 5e3,
  maxFileSize: 50,
  ignoreTrimWhitespace: !0,
  renderIndicators: !0,
  originalEditable: !1,
  diffCodeLens: !1,
  renderOverviewRuler: !0,
  diffWordWrap: "inherit",
  diffAlgorithm: "advanced",
  accessibilityVerbose: !1,
  experimental: {
    showMoves: !1,
    showEmptyDecorations: !0
  },
  hideUnchangedRegions: {
    enabled: !1,
    contextLineCount: 3,
    minimumLineCount: 3,
    revealLineCount: 20
  },
  isInEmbeddedEditor: !1,
  onlyShowAccessibleDiffViewer: !1,
  renderSideBySideInlineBreakpoint: 900,
  useInlineViewWhenSpaceIsLimited: !0
}, U0 = Object.freeze({
  id: "editor",
  order: 5,
  type: "object",
  title: p("editorConfigurationTitle", "Editor"),
  scope: 5
}), VS = {
  ...U0,
  properties: {
    "editor.tabSize": {
      type: "number",
      default: Tn.tabSize,
      minimum: 1,
      markdownDescription: p("tabSize", "The number of spaces a tab is equal to. This setting is overridden based on the file contents when {0} is on.", "`#editor.detectIndentation#`")
    },
    "editor.indentSize": {
      anyOf: [
        {
          type: "string",
          enum: ["tabSize"]
        },
        {
          type: "number",
          minimum: 1
        }
      ],
      default: "tabSize",
      markdownDescription: p("indentSize", 'The number of spaces used for indentation or `"tabSize"` to use the value from `#editor.tabSize#`. This setting is overridden based on the file contents when `#editor.detectIndentation#` is on.')
    },
    "editor.insertSpaces": {
      type: "boolean",
      default: Tn.insertSpaces,
      markdownDescription: p("insertSpaces", "Insert spaces when pressing `Tab`. This setting is overridden based on the file contents when {0} is on.", "`#editor.detectIndentation#`")
    },
    "editor.detectIndentation": {
      type: "boolean",
      default: Tn.detectIndentation,
      markdownDescription: p("detectIndentation", "Controls whether {0} and {1} will be automatically detected when a file is opened based on the file contents.", "`#editor.tabSize#`", "`#editor.insertSpaces#`")
    },
    "editor.trimAutoWhitespace": {
      type: "boolean",
      default: Tn.trimAutoWhitespace,
      description: p("trimAutoWhitespace", "Remove trailing auto inserted whitespace.")
    },
    "editor.largeFileOptimizations": {
      type: "boolean",
      default: Tn.largeFileOptimizations,
      description: p("largeFileOptimizations", "Special handling for large files to disable certain memory intensive features.")
    },
    "editor.wordBasedSuggestions": {
      enum: ["off", "currentDocument", "matchingDocuments", "allDocuments"],
      default: "matchingDocuments",
      enumDescriptions: [
        p("wordBasedSuggestions.off", "Turn off Word Based Suggestions."),
        p("wordBasedSuggestions.currentDocument", "Only suggest words from the active document."),
        p("wordBasedSuggestions.matchingDocuments", "Suggest words from all open documents of the same language."),
        p("wordBasedSuggestions.allDocuments", "Suggest words from all open documents.")
      ],
      description: p("wordBasedSuggestions", "Controls whether completions should be computed based on words in the document and from which documents they are computed.")
    },
    "editor.semanticHighlighting.enabled": {
      enum: [!0, !1, "configuredByTheme"],
      enumDescriptions: [
        p("semanticHighlighting.true", "Semantic highlighting enabled for all color themes."),
        p("semanticHighlighting.false", "Semantic highlighting disabled for all color themes."),
        p("semanticHighlighting.configuredByTheme", "Semantic highlighting is configured by the current color theme's `semanticHighlighting` setting.")
      ],
      default: "configuredByTheme",
      description: p("semanticHighlighting.enabled", "Controls whether the semanticHighlighting is shown for the languages that support it.")
    },
    "editor.stablePeek": {
      type: "boolean",
      default: !1,
      markdownDescription: p("stablePeek", "Keep peek editors open even when double-clicking their content or when hitting `Escape`.")
    },
    "editor.maxTokenizationLineLength": {
      type: "integer",
      default: 2e4,
      description: p("maxTokenizationLineLength", "Lines above this length will not be tokenized for performance reasons")
    },
    "editor.experimental.asyncTokenization": {
      type: "boolean",
      default: !1,
      description: p("editor.experimental.asyncTokenization", "Controls whether the tokenization should happen asynchronously on a web worker."),
      tags: ["experimental"]
    },
    "editor.experimental.asyncTokenizationLogging": {
      type: "boolean",
      default: !1,
      description: p("editor.experimental.asyncTokenizationLogging", "Controls whether async tokenization should be logged. For debugging only.")
    },
    "editor.experimental.asyncTokenizationVerification": {
      type: "boolean",
      default: !1,
      description: p("editor.experimental.asyncTokenizationVerification", "Controls whether async tokenization should be verified against legacy background tokenization. Might slow down tokenization. For debugging only."),
      tags: ["experimental"]
    },
    "editor.language.brackets": {
      type: ["array", "null"],
      default: null,
      // We want to distinguish the empty array from not configured.
      description: p("schema.brackets", "Defines the bracket symbols that increase or decrease the indentation."),
      items: {
        type: "array",
        items: [
          {
            type: "string",
            description: p("schema.openBracket", "The opening bracket character or string sequence.")
          },
          {
            type: "string",
            description: p("schema.closeBracket", "The closing bracket character or string sequence.")
          }
        ]
      }
    },
    "editor.language.colorizedBracketPairs": {
      type: ["array", "null"],
      default: null,
      // We want to distinguish the empty array from not configured.
      description: p("schema.colorizedBracketPairs", "Defines the bracket pairs that are colorized by their nesting level if bracket pair colorization is enabled."),
      items: {
        type: "array",
        items: [
          {
            type: "string",
            description: p("schema.openBracket", "The opening bracket character or string sequence.")
          },
          {
            type: "string",
            description: p("schema.closeBracket", "The closing bracket character or string sequence.")
          }
        ]
      }
    },
    "diffEditor.maxComputationTime": {
      type: "number",
      default: xn.maxComputationTime,
      description: p("maxComputationTime", "Timeout in milliseconds after which diff computation is cancelled. Use 0 for no timeout.")
    },
    "diffEditor.maxFileSize": {
      type: "number",
      default: xn.maxFileSize,
      description: p("maxFileSize", "Maximum file size in MB for which to compute diffs. Use 0 for no limit.")
    },
    "diffEditor.renderSideBySide": {
      type: "boolean",
      default: xn.renderSideBySide,
      description: p("sideBySide", "Controls whether the diff editor shows the diff side by side or inline.")
    },
    "diffEditor.renderSideBySideInlineBreakpoint": {
      type: "number",
      default: xn.renderSideBySideInlineBreakpoint,
      description: p("renderSideBySideInlineBreakpoint", "If the diff editor width is smaller than this value, the inline view is used.")
    },
    "diffEditor.useInlineViewWhenSpaceIsLimited": {
      type: "boolean",
      default: xn.useInlineViewWhenSpaceIsLimited,
      description: p("useInlineViewWhenSpaceIsLimited", "If enabled and the editor width is too small, the inline view is used.")
    },
    "diffEditor.renderMarginRevertIcon": {
      type: "boolean",
      default: xn.renderMarginRevertIcon,
      description: p("renderMarginRevertIcon", "When enabled, the diff editor shows arrows in its glyph margin to revert changes.")
    },
    "diffEditor.renderGutterMenu": {
      type: "boolean",
      default: xn.renderGutterMenu,
      description: p("renderGutterMenu", "When enabled, the diff editor shows a special gutter for revert and stage actions.")
    },
    "diffEditor.ignoreTrimWhitespace": {
      type: "boolean",
      default: xn.ignoreTrimWhitespace,
      description: p("ignoreTrimWhitespace", "When enabled, the diff editor ignores changes in leading or trailing whitespace.")
    },
    "diffEditor.renderIndicators": {
      type: "boolean",
      default: xn.renderIndicators,
      description: p("renderIndicators", "Controls whether the diff editor shows +/- indicators for added/removed changes.")
    },
    "diffEditor.codeLens": {
      type: "boolean",
      default: xn.diffCodeLens,
      description: p("codeLens", "Controls whether the editor shows CodeLens.")
    },
    "diffEditor.wordWrap": {
      type: "string",
      enum: ["off", "on", "inherit"],
      default: xn.diffWordWrap,
      markdownEnumDescriptions: [
        p("wordWrap.off", "Lines will never wrap."),
        p("wordWrap.on", "Lines will wrap at the viewport width."),
        p("wordWrap.inherit", "Lines will wrap according to the {0} setting.", "`#editor.wordWrap#`")
      ]
    },
    "diffEditor.diffAlgorithm": {
      type: "string",
      enum: ["legacy", "advanced"],
      default: xn.diffAlgorithm,
      markdownEnumDescriptions: [
        p("diffAlgorithm.legacy", "Uses the legacy diffing algorithm."),
        p("diffAlgorithm.advanced", "Uses the advanced diffing algorithm.")
      ],
      tags: ["experimental"]
    },
    "diffEditor.hideUnchangedRegions.enabled": {
      type: "boolean",
      default: xn.hideUnchangedRegions.enabled,
      markdownDescription: p("hideUnchangedRegions.enabled", "Controls whether the diff editor shows unchanged regions.")
    },
    "diffEditor.hideUnchangedRegions.revealLineCount": {
      type: "integer",
      default: xn.hideUnchangedRegions.revealLineCount,
      markdownDescription: p("hideUnchangedRegions.revealLineCount", "Controls how many lines are used for unchanged regions."),
      minimum: 1
    },
    "diffEditor.hideUnchangedRegions.minimumLineCount": {
      type: "integer",
      default: xn.hideUnchangedRegions.minimumLineCount,
      markdownDescription: p("hideUnchangedRegions.minimumLineCount", "Controls how many lines are used as a minimum for unchanged regions."),
      minimum: 1
    },
    "diffEditor.hideUnchangedRegions.contextLineCount": {
      type: "integer",
      default: xn.hideUnchangedRegions.contextLineCount,
      markdownDescription: p("hideUnchangedRegions.contextLineCount", "Controls how many lines are used as context when comparing unchanged regions."),
      minimum: 1
    },
    "diffEditor.experimental.showMoves": {
      type: "boolean",
      default: xn.experimental.showMoves,
      markdownDescription: p("showMoves", "Controls whether the diff editor should show detected code moves.")
    },
    "diffEditor.experimental.showEmptyDecorations": {
      type: "boolean",
      default: xn.experimental.showEmptyDecorations,
      description: p("showEmptyDecorations", "Controls whether the diff editor shows empty decorations to see where characters got inserted or deleted.")
    }
  }
};
function dte(r) {
  return typeof r.type < "u" || typeof r.anyOf < "u";
}
for (const r of Hg) {
  const e = r.schema;
  if (typeof e < "u")
    if (dte(e))
      VS.properties[`editor.${r.name}`] = e;
    else
      for (const t in e)
        Object.hasOwnProperty.call(e, t) && (VS.properties[t] = e[t]);
}
let PC = null;
function uz() {
  return PC === null && (PC = /* @__PURE__ */ Object.create(null), Object.keys(VS.properties).forEach((r) => {
    PC[r] = !0;
  })), PC;
}
function cte(r) {
  return uz()[`editor.${r}`] || !1;
}
function hte(r) {
  return uz()[`diffEditor.${r}`] || !1;
}
const ute = si.as(aa.Configuration);
ute.registerConfiguration(VS);
class ti {
  static insert(e, t) {
    return {
      range: new L(e.lineNumber, e.column, e.lineNumber, e.column),
      text: t,
      forceMoveMarkers: !0
    };
  }
  static delete(e) {
    return {
      range: e,
      text: null
    };
  }
  static replace(e, t) {
    return {
      range: e,
      text: t
    };
  }
  static replaceMove(e, t) {
    return {
      range: e,
      text: t,
      forceMoveMarkers: !0
    };
  }
}
function OC(r) {
  return Object.isFrozen(r) ? r : O5(r);
}
class fn {
  static createEmptyModel(e) {
    return new fn({}, [], [], void 0, e);
  }
  constructor(e, t, i, n, s) {
    this._contents = e, this._keys = t, this._overrides = i, this.raw = n, this.logService = s, this.overrideConfigurations = /* @__PURE__ */ new Map();
  }
  get rawConfiguration() {
    var e;
    if (!this._rawConfiguration)
      if (!((e = this.raw) === null || e === void 0) && e.length) {
        const t = this.raw.map((i) => {
          if (i instanceof fn)
            return i;
          const n = new gte("", this.logService);
          return n.parseRaw(i), n.configurationModel;
        });
        this._rawConfiguration = t.reduce((i, n) => n === i ? n : i.merge(n), t[0]);
      } else
        this._rawConfiguration = this;
    return this._rawConfiguration;
  }
  get contents() {
    return this._contents;
  }
  get overrides() {
    return this._overrides;
  }
  get keys() {
    return this._keys;
  }
  isEmpty() {
    return this._keys.length === 0 && Object.keys(this._contents).length === 0 && this._overrides.length === 0;
  }
  getValue(e) {
    return e ? WA(this.contents, e) : this.contents;
  }
  inspect(e, t) {
    const i = this;
    return {
      get value() {
        return OC(i.rawConfiguration.getValue(e));
      },
      get override() {
        return t ? OC(i.rawConfiguration.getOverrideValue(e, t)) : void 0;
      },
      get merged() {
        return OC(t ? i.rawConfiguration.override(t).getValue(e) : i.rawConfiguration.getValue(e));
      },
      get overrides() {
        const n = [];
        for (const { contents: s, identifiers: o, keys: a } of i.rawConfiguration.overrides) {
          const l = new fn(s, a, [], void 0, i.logService).getValue(e);
          l !== void 0 && n.push({ identifiers: o, value: l });
        }
        return n.length ? OC(n) : void 0;
      }
    };
  }
  getOverrideValue(e, t) {
    const i = this.getContentsForOverrideIdentifer(t);
    return i ? e ? WA(i, e) : i : void 0;
  }
  override(e) {
    let t = this.overrideConfigurations.get(e);
    return t || (t = this.createOverrideConfigurationModel(e), this.overrideConfigurations.set(e, t)), t;
  }
  merge(...e) {
    var t, i;
    const n = Hd(this.contents), s = Hd(this.overrides), o = [...this.keys], a = !((t = this.raw) === null || t === void 0) && t.length ? [...this.raw] : [this];
    for (const l of e)
      if (a.push(...!((i = l.raw) === null || i === void 0) && i.length ? l.raw : [l]), !l.isEmpty()) {
        this.mergeContents(n, l.contents);
        for (const d of l.overrides) {
          const [c] = s.filter((h) => ci(h.identifiers, d.identifiers));
          c ? (this.mergeContents(c.contents, d.contents), c.keys.push(...d.keys), c.keys = rd(c.keys)) : s.push(Hd(d));
        }
        for (const d of l.keys)
          o.indexOf(d) === -1 && o.push(d);
      }
    return new fn(n, o, s, a.every((l) => l instanceof fn) ? void 0 : a, this.logService);
  }
  createOverrideConfigurationModel(e) {
    const t = this.getContentsForOverrideIdentifer(e);
    if (!t || typeof t != "object" || !Object.keys(t).length)
      return this;
    const i = {};
    for (const n of rd([...Object.keys(this.contents), ...Object.keys(t)])) {
      let s = this.contents[n];
      const o = t[n];
      o && (typeof s == "object" && typeof o == "object" ? (s = Hd(s), this.mergeContents(s, o)) : s = o), i[n] = s;
    }
    return new fn(i, this.keys, this.overrides, void 0, this.logService);
  }
  mergeContents(e, t) {
    for (const i of Object.keys(t)) {
      if (i in e && ur(e[i]) && ur(t[i])) {
        this.mergeContents(e[i], t[i]);
        continue;
      }
      e[i] = Hd(t[i]);
    }
  }
  getContentsForOverrideIdentifer(e) {
    let t = null, i = null;
    const n = (s) => {
      s && (i ? this.mergeContents(i, s) : i = Hd(s));
    };
    for (const s of this.overrides)
      s.identifiers.length === 1 && s.identifiers[0] === e ? t = s.contents : s.identifiers.includes(e) && n(s.contents);
    return n(t), i;
  }
  toJSON() {
    return {
      contents: this.contents,
      overrides: this.overrides,
      keys: this.keys
    };
  }
  // Update methods
  addValue(e, t) {
    this.updateValue(e, t, !0);
  }
  setValue(e, t) {
    this.updateValue(e, t, !1);
  }
  removeValue(e) {
    const t = this.keys.indexOf(e);
    t !== -1 && (this.keys.splice(t, 1), sq(this.contents, e), Ac.test(e) && this.overrides.splice(this.overrides.findIndex((i) => ci(i.identifiers, mS(e))), 1));
  }
  updateValue(e, t, i) {
    cV(this.contents, e, t, (n) => this.logService.error(n)), i = i || this.keys.indexOf(e) === -1, i && this.keys.push(e), Ac.test(e) && this.overrides.push({
      identifiers: mS(e),
      keys: Object.keys(this.contents[e]),
      contents: Px(this.contents[e], (n) => this.logService.error(n))
    });
  }
}
class gte {
  constructor(e, t) {
    this._name = e, this.logService = t, this._raw = null, this._configurationModel = null, this._restrictedConfigurations = [];
  }
  get configurationModel() {
    return this._configurationModel || fn.createEmptyModel(this.logService);
  }
  parseRaw(e, t) {
    this._raw = e;
    const { contents: i, keys: n, overrides: s, restricted: o, hasExcludedProperties: a } = this.doParseRaw(e, t);
    this._configurationModel = new fn(i, n, s, a ? [e] : void 0, this.logService), this._restrictedConfigurations = o || [];
  }
  doParseRaw(e, t) {
    const i = si.as(aa.Configuration).getConfigurationProperties(), n = this.filter(e, i, !0, t);
    e = n.raw;
    const s = Px(e, (l) => this.logService.error(`Conflict in settings file ${this._name}: ${l}`)), o = Object.keys(e), a = this.toOverrides(e, (l) => this.logService.error(`Conflict in settings file ${this._name}: ${l}`));
    return { contents: s, keys: o, overrides: a, restricted: n.restricted, hasExcludedProperties: n.hasExcludedProperties };
  }
  filter(e, t, i, n) {
    var s, o, a;
    let l = !1;
    if (!(n != null && n.scopes) && !(n != null && n.skipRestricted) && !(!((s = n == null ? void 0 : n.exclude) === null || s === void 0) && s.length))
      return { raw: e, restricted: [], hasExcludedProperties: l };
    const d = {}, c = [];
    for (const h in e)
      if (Ac.test(h) && i) {
        const u = this.filter(e[h], t, !1, n);
        d[h] = u.raw, l = l || u.hasExcludedProperties, c.push(...u.restricted);
      } else {
        const u = t[h], g = u ? typeof u.scope < "u" ? u.scope : 3 : void 0;
        u != null && u.restricted && c.push(h), !(!((o = n.exclude) === null || o === void 0) && o.includes(h)) && (!((a = n.include) === null || a === void 0) && a.includes(h) || (g === void 0 || n.scopes === void 0 || n.scopes.includes(g)) && !(n.skipRestricted && (u != null && u.restricted))) ? d[h] = e[h] : l = !0;
      }
    return { raw: d, restricted: c, hasExcludedProperties: l };
  }
  toOverrides(e, t) {
    const i = [];
    for (const n of Object.keys(e))
      if (Ac.test(n)) {
        const s = {};
        for (const o in e[n])
          s[o] = e[n][o];
        i.push({
          identifiers: mS(n),
          keys: Object.keys(s),
          contents: Px(s, t)
        });
      }
    return i;
  }
}
class fte {
  constructor(e, t, i, n, s, o, a, l, d, c, h, u, g) {
    this.key = e, this.overrides = t, this._value = i, this.overrideIdentifiers = n, this.defaultConfiguration = s, this.policyConfiguration = o, this.applicationConfiguration = a, this.userConfiguration = l, this.localUserConfiguration = d, this.remoteUserConfiguration = c, this.workspaceConfiguration = h, this.folderConfigurationModel = u, this.memoryConfigurationModel = g;
  }
  toInspectValue(e) {
    return (e == null ? void 0 : e.value) !== void 0 || (e == null ? void 0 : e.override) !== void 0 || (e == null ? void 0 : e.overrides) !== void 0 ? e : void 0;
  }
  get userInspectValue() {
    return this._userInspectValue || (this._userInspectValue = this.userConfiguration.inspect(this.key, this.overrides.overrideIdentifier)), this._userInspectValue;
  }
  get user() {
    return this.toInspectValue(this.userInspectValue);
  }
}
class $0 {
  constructor(e, t, i, n, s, o, a, l, d, c) {
    this._defaultConfiguration = e, this._policyConfiguration = t, this._applicationConfiguration = i, this._localUserConfiguration = n, this._remoteUserConfiguration = s, this._workspaceConfiguration = o, this._folderConfigurations = a, this._memoryConfiguration = l, this._memoryConfigurationByResource = d, this.logService = c, this._workspaceConsolidatedConfiguration = null, this._foldersConsolidatedConfigurations = new an(), this._userConfiguration = null;
  }
  getValue(e, t, i) {
    return this.getConsolidatedConfigurationModel(e, t, i).getValue(e);
  }
  updateValue(e, t, i = {}) {
    let n;
    i.resource ? (n = this._memoryConfigurationByResource.get(i.resource), n || (n = fn.createEmptyModel(this.logService), this._memoryConfigurationByResource.set(i.resource, n))) : n = this._memoryConfiguration, t === void 0 ? n.removeValue(e) : n.setValue(e, t), i.resource || (this._workspaceConsolidatedConfiguration = null);
  }
  inspect(e, t, i) {
    const n = this.getConsolidatedConfigurationModel(e, t, i), s = this.getFolderConfigurationModelForResource(t.resource, i), o = t.resource ? this._memoryConfigurationByResource.get(t.resource) || this._memoryConfiguration : this._memoryConfiguration, a = /* @__PURE__ */ new Set();
    for (const l of n.overrides)
      for (const d of l.identifiers)
        n.getOverrideValue(e, d) !== void 0 && a.add(d);
    return new fte(e, t, n.getValue(e), a.size ? [...a] : void 0, this._defaultConfiguration, this._policyConfiguration.isEmpty() ? void 0 : this._policyConfiguration, this.applicationConfiguration.isEmpty() ? void 0 : this.applicationConfiguration, this.userConfiguration, this.localUserConfiguration, this.remoteUserConfiguration, i ? this._workspaceConfiguration : void 0, s || void 0, o);
  }
  get applicationConfiguration() {
    return this._applicationConfiguration;
  }
  get userConfiguration() {
    return this._userConfiguration || (this._userConfiguration = this._remoteUserConfiguration.isEmpty() ? this._localUserConfiguration : this._localUserConfiguration.merge(this._remoteUserConfiguration)), this._userConfiguration;
  }
  get localUserConfiguration() {
    return this._localUserConfiguration;
  }
  get remoteUserConfiguration() {
    return this._remoteUserConfiguration;
  }
  getConsolidatedConfigurationModel(e, t, i) {
    let n = this.getConsolidatedConfigurationModelForResource(t, i);
    return t.overrideIdentifier && (n = n.override(t.overrideIdentifier)), !this._policyConfiguration.isEmpty() && this._policyConfiguration.getValue(e) !== void 0 && (n = n.merge(this._policyConfiguration)), n;
  }
  getConsolidatedConfigurationModelForResource({ resource: e }, t) {
    let i = this.getWorkspaceConsolidatedConfiguration();
    if (t && e) {
      const n = t.getFolder(e);
      n && (i = this.getFolderConsolidatedConfiguration(n.uri) || i);
      const s = this._memoryConfigurationByResource.get(e);
      s && (i = i.merge(s));
    }
    return i;
  }
  getWorkspaceConsolidatedConfiguration() {
    return this._workspaceConsolidatedConfiguration || (this._workspaceConsolidatedConfiguration = this._defaultConfiguration.merge(this.applicationConfiguration, this.userConfiguration, this._workspaceConfiguration, this._memoryConfiguration)), this._workspaceConsolidatedConfiguration;
  }
  getFolderConsolidatedConfiguration(e) {
    let t = this._foldersConsolidatedConfigurations.get(e);
    if (!t) {
      const i = this.getWorkspaceConsolidatedConfiguration(), n = this._folderConfigurations.get(e);
      n ? (t = i.merge(n), this._foldersConsolidatedConfigurations.set(e, t)) : t = i;
    }
    return t;
  }
  getFolderConfigurationModelForResource(e, t) {
    if (t && e) {
      const i = t.getFolder(e);
      if (i)
        return this._folderConfigurations.get(i.uri);
    }
  }
  toData() {
    return {
      defaults: {
        contents: this._defaultConfiguration.contents,
        overrides: this._defaultConfiguration.overrides,
        keys: this._defaultConfiguration.keys
      },
      policy: {
        contents: this._policyConfiguration.contents,
        overrides: this._policyConfiguration.overrides,
        keys: this._policyConfiguration.keys
      },
      application: {
        contents: this.applicationConfiguration.contents,
        overrides: this.applicationConfiguration.overrides,
        keys: this.applicationConfiguration.keys
      },
      user: {
        contents: this.userConfiguration.contents,
        overrides: this.userConfiguration.overrides,
        keys: this.userConfiguration.keys
      },
      workspace: {
        contents: this._workspaceConfiguration.contents,
        overrides: this._workspaceConfiguration.overrides,
        keys: this._workspaceConfiguration.keys
      },
      folders: [...this._folderConfigurations.keys()].reduce((e, t) => {
        const { contents: i, overrides: n, keys: s } = this._folderConfigurations.get(t);
        return e.push([t, { contents: i, overrides: n, keys: s }]), e;
      }, [])
    };
  }
  static parse(e, t) {
    const i = this.parseConfigurationModel(e.defaults, t), n = this.parseConfigurationModel(e.policy, t), s = this.parseConfigurationModel(e.application, t), o = this.parseConfigurationModel(e.user, t), a = this.parseConfigurationModel(e.workspace, t), l = e.folders.reduce((d, c) => (d.set(Ee.revive(c[0]), this.parseConfigurationModel(c[1], t)), d), new an());
    return new $0(i, n, s, o, fn.createEmptyModel(t), a, l, fn.createEmptyModel(t), new an(), t);
  }
  static parseConfigurationModel(e, t) {
    return new fn(e.contents, e.keys, e.overrides, void 0, t);
  }
}
class pte {
  constructor(e, t, i, n, s) {
    this.change = e, this.previous = t, this.currentConfiguraiton = i, this.currentWorkspace = n, this.logService = s, this._marker = `
`, this._markerCode1 = this._marker.charCodeAt(0), this._markerCode2 = 46, this.affectedKeys = /* @__PURE__ */ new Set(), this._previousConfiguration = void 0;
    for (const o of e.keys)
      this.affectedKeys.add(o);
    for (const [, o] of e.overrides)
      for (const a of o)
        this.affectedKeys.add(a);
    this._affectsConfigStr = this._marker;
    for (const o of this.affectedKeys)
      this._affectsConfigStr += o + this._marker;
  }
  get previousConfiguration() {
    return !this._previousConfiguration && this.previous && (this._previousConfiguration = $0.parse(this.previous.data, this.logService)), this._previousConfiguration;
  }
  affectsConfiguration(e, t) {
    var i;
    const n = this._marker + e, s = this._affectsConfigStr.indexOf(n);
    if (s < 0)
      return !1;
    const o = s + n.length;
    if (o >= this._affectsConfigStr.length)
      return !1;
    const a = this._affectsConfigStr.charCodeAt(o);
    if (a !== this._markerCode1 && a !== this._markerCode2)
      return !1;
    if (t) {
      const l = this.previousConfiguration ? this.previousConfiguration.getValue(e, t, (i = this.previous) === null || i === void 0 ? void 0 : i.workspace) : void 0, d = this.currentConfiguraiton.getValue(e, t, this.currentWorkspace);
      return !Xa(l, d);
    }
    return !0;
  }
}
const zS = {
  kind: 0
  /* ResultKind.NoMatchingKb */
}, mte = {
  kind: 1
  /* ResultKind.MoreChordsNeeded */
};
function _te(r, e, t) {
  return { kind: 2, commandId: r, commandArgs: e, isBubble: t };
}
class __ {
  constructor(e, t, i) {
    var n;
    this._log = i, this._defaultKeybindings = e, this._defaultBoundCommands = /* @__PURE__ */ new Map();
    for (const s of e) {
      const o = s.command;
      o && o.charAt(0) !== "-" && this._defaultBoundCommands.set(o, !0);
    }
    this._map = /* @__PURE__ */ new Map(), this._lookupMap = /* @__PURE__ */ new Map(), this._keybindings = __.handleRemovals([].concat(e).concat(t));
    for (let s = 0, o = this._keybindings.length; s < o; s++) {
      const a = this._keybindings[s];
      if (a.chords.length === 0)
        continue;
      const l = (n = a.when) === null || n === void 0 ? void 0 : n.substituteConstants();
      l && l.type === 0 || this._addKeyPress(a.chords[0], a);
    }
  }
  static _isTargetedForRemoval(e, t, i) {
    if (t) {
      for (let n = 0; n < t.length; n++)
        if (t[n] !== e.chords[n])
          return !1;
    }
    return !(i && i.type !== 1 && (!e.when || !x6(i, e.when)));
  }
  /**
   * Looks for rules containing "-commandId" and removes them.
   */
  static handleRemovals(e) {
    const t = /* @__PURE__ */ new Map();
    for (let n = 0, s = e.length; n < s; n++) {
      const o = e[n];
      if (o.command && o.command.charAt(0) === "-") {
        const a = o.command.substring(1);
        t.has(a) ? t.get(a).push(o) : t.set(a, [o]);
      }
    }
    if (t.size === 0)
      return e;
    const i = [];
    for (let n = 0, s = e.length; n < s; n++) {
      const o = e[n];
      if (!o.command || o.command.length === 0) {
        i.push(o);
        continue;
      }
      if (o.command.charAt(0) === "-")
        continue;
      const a = t.get(o.command);
      if (!a || !o.isDefault) {
        i.push(o);
        continue;
      }
      let l = !1;
      for (const d of a) {
        const c = d.when;
        if (this._isTargetedForRemoval(o, d.chords, c)) {
          l = !0;
          break;
        }
      }
      if (!l) {
        i.push(o);
        continue;
      }
    }
    return i;
  }
  _addKeyPress(e, t) {
    const i = this._map.get(e);
    if (typeof i > "u") {
      this._map.set(e, [t]), this._addToLookupMap(t);
      return;
    }
    for (let n = i.length - 1; n >= 0; n--) {
      const s = i[n];
      if (s.command === t.command)
        continue;
      let o = !0;
      for (let a = 1; a < s.chords.length && a < t.chords.length; a++)
        if (s.chords[a] !== t.chords[a]) {
          o = !1;
          break;
        }
      o && __.whenIsEntirelyIncluded(s.when, t.when) && this._removeFromLookupMap(s);
    }
    i.push(t), this._addToLookupMap(t);
  }
  _addToLookupMap(e) {
    if (!e.command)
      return;
    let t = this._lookupMap.get(e.command);
    typeof t > "u" ? (t = [e], this._lookupMap.set(e.command, t)) : t.push(e);
  }
  _removeFromLookupMap(e) {
    if (!e.command)
      return;
    const t = this._lookupMap.get(e.command);
    if (!(typeof t > "u")) {
      for (let i = 0, n = t.length; i < n; i++)
        if (t[i] === e) {
          t.splice(i, 1);
          return;
        }
    }
  }
  /**
   * Returns true if it is provable `a` implies `b`.
   */
  static whenIsEntirelyIncluded(e, t) {
    return !t || t.type === 1 ? !0 : !e || e.type === 1 ? !1 : Ax(e, t);
  }
  getKeybindings() {
    return this._keybindings;
  }
  lookupPrimaryKeybinding(e, t) {
    const i = this._lookupMap.get(e);
    if (typeof i > "u" || i.length === 0)
      return null;
    if (i.length === 1)
      return i[0];
    for (let n = i.length - 1; n >= 0; n--) {
      const s = i[n];
      if (t.contextMatchesRules(s.when))
        return s;
    }
    return i[i.length - 1];
  }
  /**
   * Looks up a keybinding trigged as a result of pressing a sequence of chords - `[...currentChords, keypress]`
   *
   * Example: resolving 3 chords pressed sequentially - `cmd+k cmd+p cmd+i`:
   * 	`currentChords = [ 'cmd+k' , 'cmd+p' ]` and `keypress = `cmd+i` - last pressed chord
   */
  resolve(e, t, i) {
    const n = [...t, i];
    this._log(`| Resolving ${n}`);
    const s = this._map.get(n[0]);
    if (s === void 0)
      return this._log("\\ No keybinding entries."), zS;
    let o = null;
    if (n.length < 2)
      o = s;
    else {
      o = [];
      for (let l = 0, d = s.length; l < d; l++) {
        const c = s[l];
        if (n.length > c.chords.length)
          continue;
        let h = !0;
        for (let u = 1; u < n.length; u++)
          if (c.chords[u] !== n[u]) {
            h = !1;
            break;
          }
        h && o.push(c);
      }
    }
    const a = this._findCommand(e, o);
    return a ? n.length < a.chords.length ? (this._log(`\\ From ${o.length} keybinding entries, awaiting ${a.chords.length - n.length} more chord(s), when: ${UO(a.when)}, source: ${$O(a)}.`), mte) : (this._log(`\\ From ${o.length} keybinding entries, matched ${a.command}, when: ${UO(a.when)}, source: ${$O(a)}.`), _te(a.command, a.commandArgs, a.bubble)) : (this._log(`\\ From ${o.length} keybinding entries, no when clauses matched the context.`), zS);
  }
  _findCommand(e, t) {
    for (let i = t.length - 1; i >= 0; i--) {
      const n = t[i];
      if (__._contextMatchesRules(e, n.when))
        return n;
    }
    return null;
  }
  static _contextMatchesRules(e, t) {
    return t ? t.evaluate(e) : !0;
  }
}
function UO(r) {
  return r ? `${r.serialize()}` : "no when condition";
}
function $O(r) {
  return r.extensionId ? r.isBuiltinExtension ? `built-in extension ${r.extensionId}` : `user extension ${r.extensionId}` : r.isDefault ? "built-in" : "user";
}
const vte = /^(cursor|delete|undo|redo|tab|editor\.action\.clipboard)/;
class bte extends P {
  get onDidUpdateKeybindings() {
    return this._onDidUpdateKeybindings ? this._onDidUpdateKeybindings.event : ne.None;
  }
  get inChordMode() {
    return this._currentChords.length > 0;
  }
  constructor(e, t, i, n, s) {
    super(), this._contextKeyService = e, this._commandService = t, this._telemetryService = i, this._notificationService = n, this._logService = s, this._onDidUpdateKeybindings = this._register(new R()), this._currentChords = [], this._currentChordChecker = new t1(), this._currentChordStatusMessage = null, this._ignoreSingleModifiers = tf.EMPTY, this._currentSingleModifier = null, this._currentSingleModifierClearTimeout = new vr(), this._currentlyDispatchingCommandId = null, this._logging = !1;
  }
  dispose() {
    super.dispose();
  }
  _log(e) {
    this._logging && this._logService.info(`[KeybindingService]: ${e}`);
  }
  getKeybindings() {
    return this._getResolver().getKeybindings();
  }
  lookupKeybinding(e, t) {
    const i = this._getResolver().lookupPrimaryKeybinding(e, t || this._contextKeyService);
    if (i)
      return i.resolvedKeybinding;
  }
  dispatchEvent(e, t) {
    return this._dispatch(e, t);
  }
  // TODO@ulugbekna: update namings to align with `_doDispatch`
  // TODO@ulugbekna: this fn doesn't seem to take into account single-modifier keybindings, eg `shift shift`
  softDispatch(e, t) {
    this._log("/ Soft dispatching keyboard event");
    const i = this.resolveKeyboardEvent(e);
    if (i.hasMultipleChords())
      return console.warn("keyboard event should not be mapped to multiple chords"), zS;
    const [n] = i.getDispatchChords();
    if (n === null)
      return this._log("\\ Keyboard event cannot be dispatched"), zS;
    const s = this._contextKeyService.getContext(t), o = this._currentChords.map(({ keypress: a }) => a);
    return this._getResolver().resolve(s, o, n);
  }
  _scheduleLeaveChordMode() {
    const e = Date.now();
    this._currentChordChecker.cancelAndSet(() => {
      if (!this._documentHasFocus()) {
        this._leaveChordMode();
        return;
      }
      Date.now() - e > 5e3 && this._leaveChordMode();
    }, 500);
  }
  _expectAnotherChord(e, t) {
    switch (this._currentChords.push({ keypress: e, label: t }), this._currentChords.length) {
      case 0:
        throw HN("impossible");
      case 1:
        this._currentChordStatusMessage = this._notificationService.status(p("first.chord", "({0}) was pressed. Waiting for second key of chord...", t));
        break;
      default: {
        const i = this._currentChords.map(({ label: n }) => n).join(", ");
        this._currentChordStatusMessage = this._notificationService.status(p("next.chord", "({0}) was pressed. Waiting for next key of chord...", i));
      }
    }
    this._scheduleLeaveChordMode(), i_.enabled && i_.disable();
  }
  _leaveChordMode() {
    this._currentChordStatusMessage && (this._currentChordStatusMessage.dispose(), this._currentChordStatusMessage = null), this._currentChordChecker.cancel(), this._currentChords = [], i_.enable();
  }
  _dispatch(e, t) {
    return this._doDispatch(
      this.resolveKeyboardEvent(e),
      t,
      /*isSingleModiferChord*/
      !1
    );
  }
  _singleModifierDispatch(e, t) {
    const i = this.resolveKeyboardEvent(e), [n] = i.getSingleModifierDispatchChords();
    if (n)
      return this._ignoreSingleModifiers.has(n) ? (this._log(`+ Ignoring single modifier ${n} due to it being pressed together with other keys.`), this._ignoreSingleModifiers = tf.EMPTY, this._currentSingleModifierClearTimeout.cancel(), this._currentSingleModifier = null, !1) : (this._ignoreSingleModifiers = tf.EMPTY, this._currentSingleModifier === null ? (this._log(`+ Storing single modifier for possible chord ${n}.`), this._currentSingleModifier = n, this._currentSingleModifierClearTimeout.cancelAndSet(() => {
        this._log("+ Clearing single modifier due to 300ms elapsed."), this._currentSingleModifier = null;
      }, 300), !1) : n === this._currentSingleModifier ? (this._log(`/ Dispatching single modifier chord ${n} ${n}`), this._currentSingleModifierClearTimeout.cancel(), this._currentSingleModifier = null, this._doDispatch(
        i,
        t,
        /*isSingleModiferChord*/
        !0
      )) : (this._log(`+ Clearing single modifier due to modifier mismatch: ${this._currentSingleModifier} ${n}`), this._currentSingleModifierClearTimeout.cancel(), this._currentSingleModifier = null, !1));
    const [s] = i.getChords();
    return this._ignoreSingleModifiers = new tf(s), this._currentSingleModifier !== null && this._log("+ Clearing single modifier due to other key up."), this._currentSingleModifierClearTimeout.cancel(), this._currentSingleModifier = null, !1;
  }
  _doDispatch(e, t, i = !1) {
    var n;
    let s = !1;
    if (e.hasMultipleChords())
      return console.warn("Unexpected keyboard event mapped to multiple chords"), !1;
    let o = null, a = null;
    if (i) {
      const [h] = e.getSingleModifierDispatchChords();
      o = h, a = h ? [h] : [];
    } else
      [o] = e.getDispatchChords(), a = this._currentChords.map(({ keypress: h }) => h);
    if (o === null)
      return this._log("\\ Keyboard event cannot be dispatched in keydown phase."), s;
    const l = this._contextKeyService.getContext(t), d = e.getLabel(), c = this._getResolver().resolve(l, a, o);
    switch (c.kind) {
      case 0: {
        if (this._logService.trace("KeybindingService#dispatch", d, "[ No matching keybinding ]"), this.inChordMode) {
          const h = this._currentChords.map(({ label: u }) => u).join(", ");
          this._log(`+ Leaving multi-chord mode: Nothing bound to "${h}, ${d}".`), this._notificationService.status(p("missing.chord", "The key combination ({0}, {1}) is not a command.", h, d), {
            hideAfter: 10 * 1e3
            /* 10s */
          }), this._leaveChordMode(), s = !0;
        }
        return s;
      }
      case 1:
        return this._logService.trace("KeybindingService#dispatch", d, "[ Several keybindings match - more chords needed ]"), s = !0, this._expectAnotherChord(o, d), this._log(this._currentChords.length === 1 ? "+ Entering multi-chord mode..." : "+ Continuing multi-chord mode..."), s;
      case 2: {
        if (this._logService.trace("KeybindingService#dispatch", d, `[ Will dispatch command ${c.commandId} ]`), c.commandId === null || c.commandId === "") {
          if (this.inChordMode) {
            const h = this._currentChords.map(({ label: u }) => u).join(", ");
            this._log(`+ Leaving chord mode: Nothing bound to "${h}, ${d}".`), this._notificationService.status(p("missing.chord", "The key combination ({0}, {1}) is not a command.", h, d), {
              hideAfter: 10 * 1e3
              /* 10s */
            }), this._leaveChordMode(), s = !0;
          }
        } else {
          this.inChordMode && this._leaveChordMode(), c.isBubble || (s = !0), this._log(`+ Invoking command ${c.commandId}.`), this._currentlyDispatchingCommandId = c.commandId;
          try {
            typeof c.commandArgs > "u" ? this._commandService.executeCommand(c.commandId).then(void 0, (h) => this._notificationService.warn(h)) : this._commandService.executeCommand(c.commandId, c.commandArgs).then(void 0, (h) => this._notificationService.warn(h));
          } finally {
            this._currentlyDispatchingCommandId = null;
          }
          vte.test(c.commandId) || this._telemetryService.publicLog2("workbenchActionExecuted", { id: c.commandId, from: "keybinding", detail: (n = e.getUserSettingsLabel()) !== null && n !== void 0 ? n : void 0 });
        }
        return s;
      }
    }
  }
  mightProducePrintableCharacter(e) {
    return e.ctrlKey || e.metaKey ? !1 : e.keyCode >= 31 && e.keyCode <= 56 || e.keyCode >= 21 && e.keyCode <= 30;
  }
}
class tf {
  constructor(e) {
    this._ctrlKey = e ? e.ctrlKey : !1, this._shiftKey = e ? e.shiftKey : !1, this._altKey = e ? e.altKey : !1, this._metaKey = e ? e.metaKey : !1;
  }
  has(e) {
    switch (e) {
      case "ctrl":
        return this._ctrlKey;
      case "shift":
        return this._shiftKey;
      case "alt":
        return this._altKey;
      case "meta":
        return this._metaKey;
    }
  }
}
tf.EMPTY = new tf(null);
class KO {
  constructor(e, t, i, n, s, o, a) {
    this._resolvedKeybindingItemBrand = void 0, this.resolvedKeybinding = e, this.chords = e ? OI(e.getDispatchChords()) : [], e && this.chords.length === 0 && (this.chords = OI(e.getSingleModifierDispatchChords())), this.bubble = t ? t.charCodeAt(0) === 94 : !1, this.command = this.bubble ? t.substr(1) : t, this.commandArgs = i, this.when = n, this.isDefault = s, this.extensionId = o, this.isBuiltinExtension = a;
  }
}
function OI(r) {
  const e = [];
  for (let t = 0, i = r.length; t < i; t++) {
    const n = r[t];
    if (!n)
      return [];
    e.push(n);
  }
  return e;
}
class K0 {
  constructor(e, t, i = t) {
    this.modifierLabels = [null], this.modifierLabels[
      2
      /* OperatingSystem.Macintosh */
    ] = e, this.modifierLabels[
      1
      /* OperatingSystem.Windows */
    ] = t, this.modifierLabels[
      3
      /* OperatingSystem.Linux */
    ] = i;
  }
  toLabel(e, t, i) {
    if (t.length === 0)
      return null;
    const n = [];
    for (let s = 0, o = t.length; s < o; s++) {
      const a = t[s], l = i(a);
      if (l === null)
        return null;
      n[s] = yte(a, l, this.modifierLabels[e]);
    }
    return n.join(" ");
  }
}
const fM = new K0({
  ctrlKey: "",
  shiftKey: "",
  altKey: "",
  metaKey: "",
  separator: ""
}, {
  ctrlKey: p({ key: "ctrlKey", comment: ["This is the short form for the Control key on the keyboard"] }, "Ctrl"),
  shiftKey: p({ key: "shiftKey", comment: ["This is the short form for the Shift key on the keyboard"] }, "Shift"),
  altKey: p({ key: "altKey", comment: ["This is the short form for the Alt key on the keyboard"] }, "Alt"),
  metaKey: p({ key: "windowsKey", comment: ["This is the short form for the Windows key on the keyboard"] }, "Windows"),
  separator: "+"
}, {
  ctrlKey: p({ key: "ctrlKey", comment: ["This is the short form for the Control key on the keyboard"] }, "Ctrl"),
  shiftKey: p({ key: "shiftKey", comment: ["This is the short form for the Shift key on the keyboard"] }, "Shift"),
  altKey: p({ key: "altKey", comment: ["This is the short form for the Alt key on the keyboard"] }, "Alt"),
  metaKey: p({ key: "superKey", comment: ["This is the short form for the Super key on the keyboard"] }, "Super"),
  separator: "+"
}), Cte = new K0({
  ctrlKey: p({ key: "ctrlKey.long", comment: ["This is the long form for the Control key on the keyboard"] }, "Control"),
  shiftKey: p({ key: "shiftKey.long", comment: ["This is the long form for the Shift key on the keyboard"] }, "Shift"),
  altKey: p({ key: "optKey.long", comment: ["This is the long form for the Alt/Option key on the keyboard"] }, "Option"),
  metaKey: p({ key: "cmdKey.long", comment: ["This is the long form for the Command key on the keyboard"] }, "Command"),
  separator: "+"
}, {
  ctrlKey: p({ key: "ctrlKey.long", comment: ["This is the long form for the Control key on the keyboard"] }, "Control"),
  shiftKey: p({ key: "shiftKey.long", comment: ["This is the long form for the Shift key on the keyboard"] }, "Shift"),
  altKey: p({ key: "altKey.long", comment: ["This is the long form for the Alt key on the keyboard"] }, "Alt"),
  metaKey: p({ key: "windowsKey.long", comment: ["This is the long form for the Windows key on the keyboard"] }, "Windows"),
  separator: "+"
}, {
  ctrlKey: p({ key: "ctrlKey.long", comment: ["This is the long form for the Control key on the keyboard"] }, "Control"),
  shiftKey: p({ key: "shiftKey.long", comment: ["This is the long form for the Shift key on the keyboard"] }, "Shift"),
  altKey: p({ key: "altKey.long", comment: ["This is the long form for the Alt key on the keyboard"] }, "Alt"),
  metaKey: p({ key: "superKey.long", comment: ["This is the long form for the Super key on the keyboard"] }, "Super"),
  separator: "+"
}), wte = new K0({
  ctrlKey: "Ctrl",
  shiftKey: "Shift",
  altKey: "Alt",
  metaKey: "Cmd",
  separator: "+"
}, {
  ctrlKey: "Ctrl",
  shiftKey: "Shift",
  altKey: "Alt",
  metaKey: "Super",
  separator: "+"
}), Ste = new K0({
  ctrlKey: "ctrl",
  shiftKey: "shift",
  altKey: "alt",
  metaKey: "cmd",
  separator: "+"
}, {
  ctrlKey: "ctrl",
  shiftKey: "shift",
  altKey: "alt",
  metaKey: "win",
  separator: "+"
}, {
  ctrlKey: "ctrl",
  shiftKey: "shift",
  altKey: "alt",
  metaKey: "meta",
  separator: "+"
});
function yte(r, e, t) {
  if (e === null)
    return "";
  const i = [];
  return r.ctrlKey && i.push(t.ctrlKey), r.shiftKey && i.push(t.shiftKey), r.altKey && i.push(t.altKey), r.metaKey && i.push(t.metaKey), e !== "" && i.push(e), i.join(t.separator);
}
class Lte extends Xj {
  constructor(e, t) {
    if (super(), t.length === 0)
      throw Ro("chords");
    this._os = e, this._chords = t;
  }
  getLabel() {
    return fM.toLabel(this._os, this._chords, (e) => this._getLabel(e));
  }
  getAriaLabel() {
    return Cte.toLabel(this._os, this._chords, (e) => this._getAriaLabel(e));
  }
  getElectronAccelerator() {
    return this._chords.length > 1 || this._chords[0].isDuplicateModifierCase() ? null : wte.toLabel(this._os, this._chords, (e) => this._getElectronAccelerator(e));
  }
  getUserSettingsLabel() {
    return Ste.toLabel(this._os, this._chords, (e) => this._getUserSettingsLabel(e));
  }
  hasMultipleChords() {
    return this._chords.length > 1;
  }
  getChords() {
    return this._chords.map((e) => this._getChord(e));
  }
  _getChord(e) {
    return new Qj(e.ctrlKey, e.shiftKey, e.altKey, e.metaKey, this._getLabel(e), this._getAriaLabel(e));
  }
  getDispatchChords() {
    return this._chords.map((e) => this._getChordDispatch(e));
  }
  getSingleModifierDispatchChords() {
    return this._chords.map((e) => this._getSingleModifierChordDispatch(e));
  }
}
class sv extends Lte {
  constructor(e, t) {
    super(t, e);
  }
  _keyCodeToUILabel(e) {
    if (this._os === 2)
      switch (e) {
        case 15:
          return "";
        case 16:
          return "";
        case 17:
          return "";
        case 18:
          return "";
      }
    return Ph.toString(e);
  }
  _getLabel(e) {
    return e.isDuplicateModifierCase() ? "" : this._keyCodeToUILabel(e.keyCode);
  }
  _getAriaLabel(e) {
    return e.isDuplicateModifierCase() ? "" : Ph.toString(e.keyCode);
  }
  _getElectronAccelerator(e) {
    return Ph.toElectronAccelerator(e.keyCode);
  }
  _getUserSettingsLabel(e) {
    if (e.isDuplicateModifierCase())
      return "";
    const t = Ph.toUserSettingsUS(e.keyCode);
    return t && t.toLowerCase();
  }
  _getChordDispatch(e) {
    return sv.getDispatchStr(e);
  }
  static getDispatchStr(e) {
    if (e.isModifierKey())
      return null;
    let t = "";
    return e.ctrlKey && (t += "ctrl+"), e.shiftKey && (t += "shift+"), e.altKey && (t += "alt+"), e.metaKey && (t += "meta+"), t += Ph.toString(e.keyCode), t;
  }
  _getSingleModifierChordDispatch(e) {
    return e.keyCode === 5 && !e.shiftKey && !e.altKey && !e.metaKey ? "ctrl" : e.keyCode === 4 && !e.ctrlKey && !e.altKey && !e.metaKey ? "shift" : e.keyCode === 6 && !e.ctrlKey && !e.shiftKey && !e.metaKey ? "alt" : e.keyCode === 57 && !e.ctrlKey && !e.shiftKey && !e.altKey ? "meta" : null;
  }
  /**
   * *NOTE*: Check return value for `KeyCode.Unknown`.
   */
  static _scanCodeToKeyCode(e) {
    const t = F5[e];
    if (t !== -1)
      return t;
    switch (e) {
      case 10:
        return 31;
      case 11:
        return 32;
      case 12:
        return 33;
      case 13:
        return 34;
      case 14:
        return 35;
      case 15:
        return 36;
      case 16:
        return 37;
      case 17:
        return 38;
      case 18:
        return 39;
      case 19:
        return 40;
      case 20:
        return 41;
      case 21:
        return 42;
      case 22:
        return 43;
      case 23:
        return 44;
      case 24:
        return 45;
      case 25:
        return 46;
      case 26:
        return 47;
      case 27:
        return 48;
      case 28:
        return 49;
      case 29:
        return 50;
      case 30:
        return 51;
      case 31:
        return 52;
      case 32:
        return 53;
      case 33:
        return 54;
      case 34:
        return 55;
      case 35:
        return 56;
      case 36:
        return 22;
      case 37:
        return 23;
      case 38:
        return 24;
      case 39:
        return 25;
      case 40:
        return 26;
      case 41:
        return 27;
      case 42:
        return 28;
      case 43:
        return 29;
      case 44:
        return 30;
      case 45:
        return 21;
      case 51:
        return 88;
      case 52:
        return 86;
      case 53:
        return 92;
      case 54:
        return 94;
      case 55:
        return 93;
      case 56:
        return 0;
      case 57:
        return 85;
      case 58:
        return 95;
      case 59:
        return 91;
      case 60:
        return 87;
      case 61:
        return 89;
      case 62:
        return 90;
      case 106:
        return 97;
    }
    return 0;
  }
  static _toKeyCodeChord(e) {
    if (!e)
      return null;
    if (e instanceof dd)
      return e;
    const t = this._scanCodeToKeyCode(e.scanCode);
    return t === 0 ? null : new dd(e.ctrlKey, e.shiftKey, e.altKey, e.metaKey, t);
  }
  static resolveKeybinding(e, t) {
    const i = OI(e.chords.map((n) => this._toKeyCodeChord(n)));
    return i.length > 0 ? [new sv(i, t)] : [];
  }
}
const tp = et("labelService"), gz = et("progressService");
class id {
  constructor(e) {
    this.callback = e;
  }
  report(e) {
    this._value = e, this.callback(this._value);
  }
}
id.None = Object.freeze({ report() {
} });
const sh = et("editorProgressService");
class Dte {
  constructor() {
    this._value = "", this._pos = 0;
  }
  reset(e) {
    return this._value = e, this._pos = 0, this;
  }
  next() {
    return this._pos += 1, this;
  }
  hasNext() {
    return this._pos < this._value.length - 1;
  }
  cmp(e) {
    const t = e.charCodeAt(0), i = this._value.charCodeAt(this._pos);
    return t - i;
  }
  value() {
    return this._value[this._pos];
  }
}
class kte {
  constructor(e = !0) {
    this._caseSensitive = e;
  }
  reset(e) {
    return this._value = e, this._from = 0, this._to = 0, this.next();
  }
  hasNext() {
    return this._to < this._value.length;
  }
  next() {
    this._from = this._to;
    let e = !0;
    for (; this._to < this._value.length; this._to++)
      if (this._value.charCodeAt(this._to) === 46)
        if (e)
          this._from++;
        else
          break;
      else
        e = !1;
    return this;
  }
  cmp(e) {
    return this._caseSensitive ? oH(e, this._value, 0, e.length, this._from, this._to) : rH(e, this._value, 0, e.length, this._from, this._to);
  }
  value() {
    return this._value.substring(this._from, this._to);
  }
}
class xte {
  constructor(e = !0, t = !0) {
    this._splitOnBackslash = e, this._caseSensitive = t;
  }
  reset(e) {
    this._from = 0, this._to = 0, this._value = e, this._valueLen = e.length;
    for (let t = e.length - 1; t >= 0; t--, this._valueLen--) {
      const i = this._value.charCodeAt(t);
      if (!(i === 47 || this._splitOnBackslash && i === 92))
        break;
    }
    return this.next();
  }
  hasNext() {
    return this._to < this._valueLen;
  }
  next() {
    this._from = this._to;
    let e = !0;
    for (; this._to < this._valueLen; this._to++) {
      const t = this._value.charCodeAt(this._to);
      if (t === 47 || this._splitOnBackslash && t === 92)
        if (e)
          this._from++;
        else
          break;
      else
        e = !1;
    }
    return this;
  }
  cmp(e) {
    return this._caseSensitive ? oH(e, this._value, 0, e.length, this._from, this._to) : rH(e, this._value, 0, e.length, this._from, this._to);
  }
  value() {
    return this._value.substring(this._from, this._to);
  }
}
class Ite {
  constructor(e, t) {
    this._ignorePathCasing = e, this._ignoreQueryAndFragment = t, this._states = [], this._stateIdx = 0;
  }
  reset(e) {
    return this._value = e, this._states = [], this._value.scheme && this._states.push(
      1
      /* UriIteratorState.Scheme */
    ), this._value.authority && this._states.push(
      2
      /* UriIteratorState.Authority */
    ), this._value.path && (this._pathIterator = new xte(!1, !this._ignorePathCasing(e)), this._pathIterator.reset(e.path), this._pathIterator.value() && this._states.push(
      3
      /* UriIteratorState.Path */
    )), this._ignoreQueryAndFragment(e) || (this._value.query && this._states.push(
      4
      /* UriIteratorState.Query */
    ), this._value.fragment && this._states.push(
      5
      /* UriIteratorState.Fragment */
    )), this._stateIdx = 0, this;
  }
  next() {
    return this._states[this._stateIdx] === 3 && this._pathIterator.hasNext() ? this._pathIterator.next() : this._stateIdx += 1, this;
  }
  hasNext() {
    return this._states[this._stateIdx] === 3 && this._pathIterator.hasNext() || this._stateIdx < this._states.length - 1;
  }
  cmp(e) {
    if (this._states[this._stateIdx] === 1)
      return vx(e, this._value.scheme);
    if (this._states[this._stateIdx] === 2)
      return vx(e, this._value.authority);
    if (this._states[this._stateIdx] === 3)
      return this._pathIterator.cmp(e);
    if (this._states[this._stateIdx] === 4)
      return M_(e, this._value.query);
    if (this._states[this._stateIdx] === 5)
      return M_(e, this._value.fragment);
    throw new Error();
  }
  value() {
    if (this._states[this._stateIdx] === 1)
      return this._value.scheme;
    if (this._states[this._stateIdx] === 2)
      return this._value.authority;
    if (this._states[this._stateIdx] === 3)
      return this._pathIterator.value();
    if (this._states[this._stateIdx] === 4)
      return this._value.query;
    if (this._states[this._stateIdx] === 5)
      return this._value.fragment;
    throw new Error();
  }
}
class FC {
  constructor() {
    this.height = 1;
  }
  rotateLeft() {
    const e = this.right;
    return this.right = e.left, e.left = this, this.updateHeight(), e.updateHeight(), e;
  }
  rotateRight() {
    const e = this.left;
    return this.left = e.right, e.right = this, this.updateHeight(), e.updateHeight(), e;
  }
  updateHeight() {
    this.height = 1 + Math.max(this.heightLeft, this.heightRight);
  }
  balanceFactor() {
    return this.heightRight - this.heightLeft;
  }
  get heightLeft() {
    var e, t;
    return (t = (e = this.left) === null || e === void 0 ? void 0 : e.height) !== null && t !== void 0 ? t : 0;
  }
  get heightRight() {
    var e, t;
    return (t = (e = this.right) === null || e === void 0 ? void 0 : e.height) !== null && t !== void 0 ? t : 0;
  }
}
class xf {
  static forUris(e = () => !1, t = () => !1) {
    return new xf(new Ite(e, t));
  }
  static forStrings() {
    return new xf(new Dte());
  }
  static forConfigKeys() {
    return new xf(new kte());
  }
  constructor(e) {
    this._iter = e;
  }
  clear() {
    this._root = void 0;
  }
  set(e, t) {
    const i = this._iter.reset(e);
    let n;
    this._root || (this._root = new FC(), this._root.segment = i.value());
    const s = [];
    for (n = this._root; ; ) {
      const a = i.cmp(n.segment);
      if (a > 0)
        n.left || (n.left = new FC(), n.left.segment = i.value()), s.push([-1, n]), n = n.left;
      else if (a < 0)
        n.right || (n.right = new FC(), n.right.segment = i.value()), s.push([1, n]), n = n.right;
      else if (i.hasNext())
        i.next(), n.mid || (n.mid = new FC(), n.mid.segment = i.value()), s.push([0, n]), n = n.mid;
      else
        break;
    }
    const o = n.value;
    n.value = t, n.key = e;
    for (let a = s.length - 1; a >= 0; a--) {
      const l = s[a][1];
      l.updateHeight();
      const d = l.balanceFactor();
      if (d < -1 || d > 1) {
        const c = s[a][0], h = s[a + 1][0];
        if (c === 1 && h === 1)
          s[a][1] = l.rotateLeft();
        else if (c === -1 && h === -1)
          s[a][1] = l.rotateRight();
        else if (c === 1 && h === -1)
          l.right = s[a + 1][1] = s[a + 1][1].rotateRight(), s[a][1] = l.rotateLeft();
        else if (c === -1 && h === 1)
          l.left = s[a + 1][1] = s[a + 1][1].rotateLeft(), s[a][1] = l.rotateRight();
        else
          throw new Error();
        if (a > 0)
          switch (s[a - 1][0]) {
            case -1:
              s[a - 1][1].left = s[a][1];
              break;
            case 1:
              s[a - 1][1].right = s[a][1];
              break;
            case 0:
              s[a - 1][1].mid = s[a][1];
              break;
          }
        else
          this._root = s[0][1];
      }
    }
    return o;
  }
  get(e) {
    var t;
    return (t = this._getNode(e)) === null || t === void 0 ? void 0 : t.value;
  }
  _getNode(e) {
    const t = this._iter.reset(e);
    let i = this._root;
    for (; i; ) {
      const n = t.cmp(i.segment);
      if (n > 0)
        i = i.left;
      else if (n < 0)
        i = i.right;
      else if (t.hasNext())
        t.next(), i = i.mid;
      else
        break;
    }
    return i;
  }
  has(e) {
    const t = this._getNode(e);
    return !((t == null ? void 0 : t.value) === void 0 && (t == null ? void 0 : t.mid) === void 0);
  }
  delete(e) {
    return this._delete(e, !1);
  }
  deleteSuperstr(e) {
    return this._delete(e, !0);
  }
  _delete(e, t) {
    var i;
    const n = this._iter.reset(e), s = [];
    let o = this._root;
    for (; o; ) {
      const a = n.cmp(o.segment);
      if (a > 0)
        s.push([-1, o]), o = o.left;
      else if (a < 0)
        s.push([1, o]), o = o.right;
      else if (n.hasNext())
        n.next(), s.push([0, o]), o = o.mid;
      else
        break;
    }
    if (o) {
      if (t ? (o.left = void 0, o.mid = void 0, o.right = void 0, o.height = 1) : (o.key = void 0, o.value = void 0), !o.mid && !o.value)
        if (o.left && o.right) {
          const a = this._min(o.right);
          if (a.key) {
            const { key: l, value: d, segment: c } = a;
            this._delete(a.key, !1), o.key = l, o.value = d, o.segment = c;
          }
        } else {
          const a = (i = o.left) !== null && i !== void 0 ? i : o.right;
          if (s.length > 0) {
            const [l, d] = s[s.length - 1];
            switch (l) {
              case -1:
                d.left = a;
                break;
              case 0:
                d.mid = a;
                break;
              case 1:
                d.right = a;
                break;
            }
          } else
            this._root = a;
        }
      for (let a = s.length - 1; a >= 0; a--) {
        const l = s[a][1];
        l.updateHeight();
        const d = l.balanceFactor();
        if (d > 1 ? (l.right.balanceFactor() >= 0 || (l.right = l.right.rotateRight()), s[a][1] = l.rotateLeft()) : d < -1 && (l.left.balanceFactor() <= 0 || (l.left = l.left.rotateLeft()), s[a][1] = l.rotateRight()), a > 0)
          switch (s[a - 1][0]) {
            case -1:
              s[a - 1][1].left = s[a][1];
              break;
            case 1:
              s[a - 1][1].right = s[a][1];
              break;
            case 0:
              s[a - 1][1].mid = s[a][1];
              break;
          }
        else
          this._root = s[0][1];
      }
    }
  }
  _min(e) {
    for (; e.left; )
      e = e.left;
    return e;
  }
  findSubstr(e) {
    const t = this._iter.reset(e);
    let i = this._root, n;
    for (; i; ) {
      const s = t.cmp(i.segment);
      if (s > 0)
        i = i.left;
      else if (s < 0)
        i = i.right;
      else if (t.hasNext())
        t.next(), n = i.value || n, i = i.mid;
      else
        break;
    }
    return i && i.value || n;
  }
  findSuperstr(e) {
    return this._findSuperstrOrElement(e, !1);
  }
  _findSuperstrOrElement(e, t) {
    const i = this._iter.reset(e);
    let n = this._root;
    for (; n; ) {
      const s = i.cmp(n.segment);
      if (s > 0)
        n = n.left;
      else if (s < 0)
        n = n.right;
      else if (i.hasNext())
        i.next(), n = n.mid;
      else
        return n.mid ? this._entries(n.mid) : t ? n.value : void 0;
    }
  }
  forEach(e) {
    for (const [t, i] of this)
      e(i, t);
  }
  *[Symbol.iterator]() {
    yield* this._entries(this._root);
  }
  _entries(e) {
    const t = [];
    return this._dfsEntries(e, t), t[Symbol.iterator]();
  }
  _dfsEntries(e, t) {
    e && (e.left && this._dfsEntries(e.left, t), e.value && t.push([e.key, e.value]), e.mid && this._dfsEntries(e.mid, t), e.right && this._dfsEntries(e.right, t));
  }
}
const ku = et("contextService");
function FI(r) {
  const e = r;
  return typeof (e == null ? void 0 : e.id) == "string" && Ee.isUri(e.uri);
}
function Ete(r) {
  const e = r;
  return typeof (e == null ? void 0 : e.id) == "string" && !FI(r) && !Mte(r);
}
const Tte = { id: "empty-window" };
function Nte(r, e) {
  if (typeof r == "string" || typeof r > "u")
    return typeof r == "string" ? {
      id: fc(r)
    } : Tte;
  const t = r;
  return t.configuration ? {
    id: t.id,
    configPath: t.configuration
  } : t.folders.length === 1 ? {
    id: t.id,
    uri: t.folders[0].uri
  } : {
    id: t.id
  };
}
function Mte(r) {
  const e = r;
  return typeof (e == null ? void 0 : e.id) == "string" && Ee.isUri(e.configPath);
}
class Rte {
  constructor(e, t) {
    this.raw = t, this.uri = e.uri, this.index = e.index, this.name = e.name;
  }
  toJSON() {
    return { uri: this.uri, name: this.name, index: this.index };
  }
}
const WI = "code-workspace";
p("codeWorkspace", "Code Workspace");
const fz = "4064f6ec-cb38-4ad0-af64-ee6467e63c82";
function Ate(r) {
  return r.id === fz;
}
var BI;
(function(r) {
  r.inspectTokensAction = p("inspectTokens", "Developer: Inspect Tokens");
})(BI || (BI = {}));
var US;
(function(r) {
  r.gotoLineActionLabel = p("gotoLineActionLabel", "Go to Line/Column...");
})(US || (US = {}));
var HI;
(function(r) {
  r.helpQuickAccessActionLabel = p("helpQuickAccess", "Show all Quick Access Providers");
})(HI || (HI = {}));
var $S;
(function(r) {
  r.quickCommandActionLabel = p("quickCommandActionLabel", "Command Palette"), r.quickCommandHelp = p("quickCommandActionHelp", "Show And Run Commands");
})($S || ($S = {}));
var ov;
(function(r) {
  r.quickOutlineActionLabel = p("quickOutlineActionLabel", "Go to Symbol..."), r.quickOutlineByCategoryActionLabel = p("quickOutlineByCategoryActionLabel", "Go to Symbol by Category...");
})(ov || (ov = {}));
var KS;
(function(r) {
  r.editorViewAccessibleLabel = p("editorViewAccessibleLabel", "Editor content"), r.accessibilityHelpMessage = p("accessibilityHelpMessage", "Press Alt+F1 for Accessibility Options.");
})(KS || (KS = {}));
var VI;
(function(r) {
  r.toggleHighContrast = p("toggleHighContrast", "Toggle High Contrast Theme");
})(VI || (VI = {}));
var zI;
(function(r) {
  r.bulkEditServiceSummary = p("bulkEditServiceSummary", "Made {0} edits in {1} files");
})(zI || (zI = {}));
const pz = et("workspaceTrustManagementService");
let ip = [], pM = [], mz = [];
function WC(r, e = !1) {
  Pte(r, !1, e);
}
function Pte(r, e, t) {
  const i = Ote(r, e);
  ip.push(i), i.userConfigured ? mz.push(i) : pM.push(i), t && !i.userConfigured && ip.forEach((n) => {
    n.mime === i.mime || n.userConfigured || (i.extension && n.extension === i.extension && console.warn(`Overwriting extension <<${i.extension}>> to now point to mime <<${i.mime}>>`), i.filename && n.filename === i.filename && console.warn(`Overwriting filename <<${i.filename}>> to now point to mime <<${i.mime}>>`), i.filepattern && n.filepattern === i.filepattern && console.warn(`Overwriting filepattern <<${i.filepattern}>> to now point to mime <<${i.mime}>>`), i.firstline && n.firstline === i.firstline && console.warn(`Overwriting firstline <<${i.firstline}>> to now point to mime <<${i.mime}>>`));
  });
}
function Ote(r, e) {
  return {
    id: r.id,
    mime: r.mime,
    filename: r.filename,
    extension: r.extension,
    filepattern: r.filepattern,
    firstline: r.firstline,
    userConfigured: e,
    filenameLowercase: r.filename ? r.filename.toLowerCase() : void 0,
    extensionLowercase: r.extension ? r.extension.toLowerCase() : void 0,
    filepatternLowercase: r.filepattern ? q2(r.filepattern.toLowerCase()) : void 0,
    filepatternOnPath: r.filepattern ? r.filepattern.indexOf(ir.sep) >= 0 : !1
  };
}
function Fte() {
  ip = ip.filter((r) => r.userConfigured), pM = [];
}
function Wte(r, e) {
  return Bte(r, e).map((t) => t.id);
}
function Bte(r, e) {
  let t;
  if (r)
    switch (r.scheme) {
      case Ne.file:
        t = r.fsPath;
        break;
      case Ne.data: {
        t = Fc.parseMetaData(r).get(Fc.META_DATA_LABEL);
        break;
      }
      case Ne.vscodeNotebookCell:
        t = void 0;
        break;
      default:
        t = r.path;
    }
  if (!t)
    return [{ id: "unknown", mime: fi.unknown }];
  t = t.toLowerCase();
  const i = fc(t), n = jO(t, i, mz);
  if (n)
    return [n, { id: go, mime: fi.text }];
  const s = jO(t, i, pM);
  if (s)
    return [s, { id: go, mime: fi.text }];
  if (e) {
    const o = Hte(e);
    if (o)
      return [o, { id: go, mime: fi.text }];
  }
  return [{ id: "unknown", mime: fi.unknown }];
}
function jO(r, e, t) {
  var i;
  let n, s, o;
  for (let a = t.length - 1; a >= 0; a--) {
    const l = t[a];
    if (e === l.filenameLowercase) {
      n = l;
      break;
    }
    if (l.filepattern && (!s || l.filepattern.length > s.filepattern.length)) {
      const d = l.filepatternOnPath ? r : e;
      !((i = l.filepatternLowercase) === null || i === void 0) && i.call(l, d) && (s = l);
    }
    l.extension && (!o || l.extension.length > o.extension.length) && e.endsWith(l.extensionLowercase) && (o = l);
  }
  if (n)
    return n;
  if (s)
    return s;
  if (o)
    return o;
}
function Hte(r) {
  if (UN(r) && (r = r.substr(1)), r.length > 0)
    for (let e = ip.length - 1; e >= 0; e--) {
      const t = ip[e];
      if (!t.firstline)
        continue;
      const i = r.match(t.firstline);
      if (i && i.length > 0)
        return t;
    }
}
const BC = Object.prototype.hasOwnProperty, qO = "vs.editor.nullLanguage";
class Vte {
  constructor() {
    this._languageIdToLanguage = [], this._languageToLanguageId = /* @__PURE__ */ new Map(), this._register(
      qO,
      0
      /* LanguageId.Null */
    ), this._register(
      go,
      1
      /* LanguageId.PlainText */
    ), this._nextLanguageId = 2;
  }
  _register(e, t) {
    this._languageIdToLanguage[t] = e, this._languageToLanguageId.set(e, t);
  }
  register(e) {
    if (this._languageToLanguageId.has(e))
      return;
    const t = this._nextLanguageId++;
    this._register(e, t);
  }
  encodeLanguageId(e) {
    return this._languageToLanguageId.get(e) || 0;
  }
  decodeLanguageId(e) {
    return this._languageIdToLanguage[e] || qO;
  }
}
class rv extends P {
  constructor(e = !0, t = !1) {
    super(), this._onDidChange = this._register(new R()), this.onDidChange = this._onDidChange.event, rv.instanceCount++, this._warnOnOverwrite = t, this.languageIdCodec = new Vte(), this._dynamicLanguages = [], this._languages = {}, this._mimeTypesMap = {}, this._nameMap = {}, this._lowercaseNameMap = {}, e && (this._initializeFromRegistry(), this._register(Vf.onDidChangeLanguages((i) => {
      this._initializeFromRegistry();
    })));
  }
  dispose() {
    rv.instanceCount--, super.dispose();
  }
  _initializeFromRegistry() {
    this._languages = {}, this._mimeTypesMap = {}, this._nameMap = {}, this._lowercaseNameMap = {}, Fte();
    const e = [].concat(Vf.getLanguages()).concat(this._dynamicLanguages);
    this._registerLanguages(e);
  }
  _registerLanguages(e) {
    for (const t of e)
      this._registerLanguage(t);
    this._mimeTypesMap = {}, this._nameMap = {}, this._lowercaseNameMap = {}, Object.keys(this._languages).forEach((t) => {
      const i = this._languages[t];
      i.name && (this._nameMap[i.name] = i.identifier), i.aliases.forEach((n) => {
        this._lowercaseNameMap[n.toLowerCase()] = i.identifier;
      }), i.mimetypes.forEach((n) => {
        this._mimeTypesMap[n] = i.identifier;
      });
    }), si.as(aa.Configuration).registerOverrideIdentifiers(this.getRegisteredLanguageIds()), this._onDidChange.fire();
  }
  _registerLanguage(e) {
    const t = e.id;
    let i;
    BC.call(this._languages, t) ? i = this._languages[t] : (this.languageIdCodec.register(t), i = {
      identifier: t,
      name: null,
      mimetypes: [],
      aliases: [],
      extensions: [],
      filenames: [],
      configurationFiles: [],
      icons: []
    }, this._languages[t] = i), this._mergeLanguage(i, e);
  }
  _mergeLanguage(e, t) {
    const i = t.id;
    let n = null;
    if (Array.isArray(t.mimetypes) && t.mimetypes.length > 0 && (e.mimetypes.push(...t.mimetypes), n = t.mimetypes[0]), n || (n = `text/x-${i}`, e.mimetypes.push(n)), Array.isArray(t.extensions)) {
      t.configuration ? e.extensions = t.extensions.concat(e.extensions) : e.extensions = e.extensions.concat(t.extensions);
      for (const a of t.extensions)
        WC({ id: i, mime: n, extension: a }, this._warnOnOverwrite);
    }
    if (Array.isArray(t.filenames))
      for (const a of t.filenames)
        WC({ id: i, mime: n, filename: a }, this._warnOnOverwrite), e.filenames.push(a);
    if (Array.isArray(t.filenamePatterns))
      for (const a of t.filenamePatterns)
        WC({ id: i, mime: n, filepattern: a }, this._warnOnOverwrite);
    if (typeof t.firstLine == "string" && t.firstLine.length > 0) {
      let a = t.firstLine;
      a.charAt(0) !== "^" && (a = "^" + a);
      try {
        const l = new RegExp(a);
        W5(l) || WC({ id: i, mime: n, firstline: l }, this._warnOnOverwrite);
      } catch (l) {
        console.warn(`[${t.id}]: Invalid regular expression \`${a}\`: `, l);
      }
    }
    e.aliases.push(i);
    let s = null;
    if (typeof t.aliases < "u" && Array.isArray(t.aliases) && (t.aliases.length === 0 ? s = [null] : s = t.aliases), s !== null)
      for (const a of s)
        !a || a.length === 0 || e.aliases.push(a);
    const o = s !== null && s.length > 0;
    if (!(o && s[0] === null)) {
      const a = (o ? s[0] : null) || i;
      (o || !e.name) && (e.name = a);
    }
    t.configuration && e.configurationFiles.push(t.configuration), t.icon && e.icons.push(t.icon);
  }
  isRegisteredLanguageId(e) {
    return e ? BC.call(this._languages, e) : !1;
  }
  getRegisteredLanguageIds() {
    return Object.keys(this._languages);
  }
  getLanguageIdByLanguageName(e) {
    const t = e.toLowerCase();
    return BC.call(this._lowercaseNameMap, t) ? this._lowercaseNameMap[t] : null;
  }
  getLanguageIdByMimeType(e) {
    return e && BC.call(this._mimeTypesMap, e) ? this._mimeTypesMap[e] : null;
  }
  guessLanguageIdByFilepathOrFirstLine(e, t) {
    return !e && !t ? [] : Wte(e, t);
  }
}
rv.instanceCount = 0;
class av extends P {
  constructor(e = !1) {
    super(), this._onDidRequestBasicLanguageFeatures = this._register(new R()), this.onDidRequestBasicLanguageFeatures = this._onDidRequestBasicLanguageFeatures.event, this._onDidRequestRichLanguageFeatures = this._register(new R()), this.onDidRequestRichLanguageFeatures = this._onDidRequestRichLanguageFeatures.event, this._onDidChange = this._register(new R({
      leakWarningThreshold: 200
      /* https://github.com/microsoft/vscode/issues/119968 */
    })), this.onDidChange = this._onDidChange.event, this._requestedBasicLanguages = /* @__PURE__ */ new Set(), this._requestedRichLanguages = /* @__PURE__ */ new Set(), av.instanceCount++, this._registry = this._register(new rv(!0, e)), this.languageIdCodec = this._registry.languageIdCodec, this._register(this._registry.onDidChange(() => this._onDidChange.fire()));
  }
  dispose() {
    av.instanceCount--, super.dispose();
  }
  isRegisteredLanguageId(e) {
    return this._registry.isRegisteredLanguageId(e);
  }
  getLanguageIdByLanguageName(e) {
    return this._registry.getLanguageIdByLanguageName(e);
  }
  getLanguageIdByMimeType(e) {
    return this._registry.getLanguageIdByMimeType(e);
  }
  guessLanguageIdByFilepathOrFirstLine(e, t) {
    const i = this._registry.guessLanguageIdByFilepathOrFirstLine(e, t);
    return qN(i, null);
  }
  createById(e) {
    return new GO(this.onDidChange, () => this._createAndGetLanguageIdentifier(e));
  }
  createByFilepathOrFirstLine(e, t) {
    return new GO(this.onDidChange, () => {
      const i = this.guessLanguageIdByFilepathOrFirstLine(e, t);
      return this._createAndGetLanguageIdentifier(i);
    });
  }
  _createAndGetLanguageIdentifier(e) {
    return (!e || !this.isRegisteredLanguageId(e)) && (e = go), e;
  }
  requestBasicLanguageFeatures(e) {
    this._requestedBasicLanguages.has(e) || (this._requestedBasicLanguages.add(e), this._onDidRequestBasicLanguageFeatures.fire(e));
  }
  requestRichLanguageFeatures(e) {
    this._requestedRichLanguages.has(e) || (this._requestedRichLanguages.add(e), this.requestBasicLanguageFeatures(e), ri.getOrCreate(e), this._onDidRequestRichLanguageFeatures.fire(e));
  }
}
av.instanceCount = 0;
class GO {
  constructor(e, t) {
    this._onDidChangeLanguages = e, this._selector = t, this._listener = null, this._emitter = null, this.languageId = this._selector();
  }
  _dispose() {
    this._listener && (this._listener.dispose(), this._listener = null), this._emitter && (this._emitter.dispose(), this._emitter = null);
  }
  get onDidChange() {
    return this._listener || (this._listener = this._onDidChangeLanguages(() => this._evaluate())), this._emitter || (this._emitter = new R({
      onDidRemoveLastListener: () => {
        this._dispose();
      }
    })), this._emitter.event;
  }
  _evaluate() {
    var e;
    const t = this._selector();
    t !== this.languageId && (this.languageId = t, (e = this._emitter) === null || e === void 0 || e.fire(this.languageId));
  }
}
const lv = {
  /**
   * Application specific resource transfer type
   */
  RESOURCES: "ResourceURLs",
  /**
   * Browser specific transfer type to download
   */
  DOWNLOAD_URL: "DownloadURL",
  /**
   * Browser specific transfer type for files
   */
  FILES: "Files",
  /**
   * Typically transfer type for copy/paste transfers.
   */
  TEXT: fi.text,
  /**
   * Internal type used to pass around text/uri-list data.
   *
   * This is needed to work around https://bugs.chromium.org/p/chromium/issues/detail?id=239745.
   */
  INTERNAL_URI_LIST: "application/vnd.code.uri-list"
}, zte = () => ({
  get delay() {
    return -1;
  },
  dispose: () => {
  },
  showHover: () => {
  }
});
let j0 = zte;
const Ute = new bd(() => j0("mouse", !1)), $te = new bd(() => j0("element", !1));
function Kte(r) {
  j0 = r;
}
function us(r) {
  return r === "element" ? $te.value : Ute.value;
}
function np() {
  return j0("element", !0);
}
let _z = {
  showHover: () => {
  },
  hideHover: () => {
  },
  showAndFocusLastHover: () => {
  },
  setupUpdatableHover: () => null,
  triggerUpdatableHover: () => {
  }
};
function jte(r) {
  _z = r;
}
function da() {
  return _z;
}
class qte {
  constructor(e) {
    this.spliceables = e;
  }
  splice(e, t, i) {
    this.spliceables.forEach((n) => n.splice(e, t, i));
  }
}
class Sh extends Error {
  constructor(e, t) {
    super(`ListError [${e}] ${t}`);
  }
}
function ZO(r, e) {
  const t = [];
  for (const i of e) {
    if (r.start >= i.range.end)
      continue;
    if (r.end < i.range.start)
      break;
    const n = In.intersect(r, i.range);
    In.isEmpty(n) || t.push({
      range: n,
      size: i.size
    });
  }
  return t;
}
function UI({ start: r, end: e }, t) {
  return { start: r + t, end: e + t };
}
function Gte(r) {
  const e = [];
  let t = null;
  for (const i of r) {
    const n = i.range.start, s = i.range.end, o = i.size;
    if (t && o === t.size) {
      t.range.end = s;
      continue;
    }
    t = { range: { start: n, end: s }, size: o }, e.push(t);
  }
  return e;
}
function Zte(...r) {
  return Gte(r.reduce((e, t) => e.concat(t), []));
}
class Yte {
  get paddingTop() {
    return this._paddingTop;
  }
  set paddingTop(e) {
    this._size = this._size + e - this._paddingTop, this._paddingTop = e;
  }
  constructor(e) {
    this.groups = [], this._size = 0, this._paddingTop = 0, this._paddingTop = e ?? 0, this._size = this._paddingTop;
  }
  splice(e, t, i = []) {
    const n = i.length - t, s = ZO({ start: 0, end: e }, this.groups), o = ZO({ start: e + t, end: Number.POSITIVE_INFINITY }, this.groups).map((l) => ({ range: UI(l.range, n), size: l.size })), a = i.map((l, d) => ({
      range: { start: e + d, end: e + d + 1 },
      size: l.size
    }));
    this.groups = Zte(s, a, o), this._size = this._paddingTop + this.groups.reduce((l, d) => l + d.size * (d.range.end - d.range.start), 0);
  }
  /**
   * Returns the number of items in the range map.
   */
  get count() {
    const e = this.groups.length;
    return e ? this.groups[e - 1].range.end : 0;
  }
  /**
   * Returns the sum of the sizes of all items in the range map.
   */
  get size() {
    return this._size;
  }
  /**
   * Returns the index of the item at the given position.
   */
  indexAt(e) {
    if (e < 0)
      return -1;
    if (e < this._paddingTop)
      return 0;
    let t = 0, i = this._paddingTop;
    for (const n of this.groups) {
      const s = n.range.end - n.range.start, o = i + s * n.size;
      if (e < o)
        return t + Math.floor((e - i) / n.size);
      t += s, i = o;
    }
    return t;
  }
  /**
   * Returns the index of the item right after the item at the
   * index of the given position.
   */
  indexAfter(e) {
    return Math.min(this.indexAt(e) + 1, this.count);
  }
  /**
   * Returns the start position of the item at the given index.
   */
  positionAt(e) {
    if (e < 0)
      return -1;
    let t = 0, i = 0;
    for (const n of this.groups) {
      const s = n.range.end - n.range.start, o = i + s;
      if (e < o)
        return this._paddingTop + t + (e - i) * n.size;
      t += s * n.size, i = o;
    }
    return -1;
  }
}
function Qte(r) {
  var e;
  try {
    (e = r.parentElement) === null || e === void 0 || e.removeChild(r);
  } catch {
  }
}
class Xte {
  constructor(e) {
    this.renderers = e, this.cache = /* @__PURE__ */ new Map(), this.transactionNodesPendingRemoval = /* @__PURE__ */ new Set(), this.inTransaction = !1;
  }
  /**
   * Returns a row either by creating a new one or reusing
   * a previously released row which shares the same templateId.
   *
   * @returns A row and `isReusingConnectedDomNode` if the row's node is already in the dom in a stale position.
   */
  alloc(e) {
    let t = this.getTemplateCache(e).pop(), i = !1;
    if (t)
      i = this.transactionNodesPendingRemoval.has(t.domNode), i && this.transactionNodesPendingRemoval.delete(t.domNode);
    else {
      const n = X(".monaco-list-row"), o = this.getRenderer(e).renderTemplate(n);
      t = { domNode: n, templateId: e, templateData: o };
    }
    return { row: t, isReusingConnectedDomNode: i };
  }
  /**
   * Releases the row for eventual reuse.
   */
  release(e) {
    e && this.releaseRow(e);
  }
  /**
   * Begin a set of changes that use the cache. This lets us skip work when a row is removed and then inserted again.
   */
  transact(e) {
    if (this.inTransaction)
      throw new Error("Already in transaction");
    this.inTransaction = !0;
    try {
      e();
    } finally {
      for (const t of this.transactionNodesPendingRemoval)
        this.doRemoveNode(t);
      this.transactionNodesPendingRemoval.clear(), this.inTransaction = !1;
    }
  }
  releaseRow(e) {
    const { domNode: t, templateId: i } = e;
    t && (this.inTransaction ? this.transactionNodesPendingRemoval.add(t) : this.doRemoveNode(t)), this.getTemplateCache(i).push(e);
  }
  doRemoveNode(e) {
    e.classList.remove("scrolling"), Qte(e);
  }
  getTemplateCache(e) {
    let t = this.cache.get(e);
    return t || (t = [], this.cache.set(e, t)), t;
  }
  dispose() {
    this.cache.forEach((e, t) => {
      for (const i of e)
        this.getRenderer(t).disposeTemplate(i.templateData), i.templateData = null;
    }), this.cache.clear(), this.transactionNodesPendingRemoval.clear();
  }
  getRenderer(e) {
    const t = this.renderers.get(e);
    if (!t)
      throw new Error(`No renderer found for ${e}`);
    return t;
  }
}
var yd = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
};
const yh = {
  CurrentDragAndDropData: void 0
}, ma = {
  useShadows: !0,
  verticalScrollMode: 1,
  setRowLineHeight: !0,
  setRowHeight: !0,
  supportDynamicHeights: !1,
  dnd: {
    getDragElements(r) {
      return [r];
    },
    getDragURI() {
      return null;
    },
    onDragStart() {
    },
    onDragOver() {
      return !1;
    },
    drop() {
    },
    dispose() {
    }
  },
  horizontalScrolling: !1,
  transformOptimization: !0,
  alwaysConsumeMouseWheel: !0
};
class Lb {
  constructor(e) {
    this.elements = e;
  }
  update() {
  }
  getData() {
    return this.elements;
  }
}
class Jte {
  constructor(e) {
    this.elements = e;
  }
  update() {
  }
  getData() {
    return this.elements;
  }
}
class eie {
  constructor() {
    this.types = [], this.files = [];
  }
  update(e) {
    if (e.types && this.types.splice(0, this.types.length, ...e.types), e.files) {
      this.files.splice(0, this.files.length);
      for (let t = 0; t < e.files.length; t++) {
        const i = e.files.item(t);
        i && (i.size || i.type) && this.files.push(i);
      }
    }
  }
  getData() {
    return {
      types: this.types,
      files: this.files
    };
  }
}
function tie(r, e) {
  return Array.isArray(r) && Array.isArray(e) ? ci(r, e) : r === e;
}
class iie {
  constructor(e) {
    e != null && e.getSetSize ? this.getSetSize = e.getSetSize.bind(e) : this.getSetSize = (t, i, n) => n, e != null && e.getPosInSet ? this.getPosInSet = e.getPosInSet.bind(e) : this.getPosInSet = (t, i) => i + 1, e != null && e.getRole ? this.getRole = e.getRole.bind(e) : this.getRole = (t) => "listitem", e != null && e.isChecked ? this.isChecked = e.isChecked.bind(e) : this.isChecked = (t) => {
    };
  }
}
class zo {
  get contentHeight() {
    return this.rangeMap.size;
  }
  get onDidScroll() {
    return this.scrollableElement.onScroll;
  }
  get scrollableElementDomNode() {
    return this.scrollableElement.getDomNode();
  }
  get horizontalScrolling() {
    return this._horizontalScrolling;
  }
  set horizontalScrolling(e) {
    if (e !== this._horizontalScrolling) {
      if (e && this.supportDynamicHeights)
        throw new Error("Horizontal scrolling and dynamic heights not supported simultaneously");
      if (this._horizontalScrolling = e, this.domNode.classList.toggle("horizontal-scrolling", this._horizontalScrolling), this._horizontalScrolling) {
        for (const t of this.items)
          this.measureItemWidth(t);
        this.updateScrollWidth(), this.scrollableElement.setScrollDimensions({ width: ED(this.domNode) }), this.rowsContainer.style.width = `${Math.max(this.scrollWidth || 0, this.renderWidth)}px`;
      } else
        this.scrollableElementWidthDelayer.cancel(), this.scrollableElement.setScrollDimensions({ width: this.renderWidth, scrollWidth: this.renderWidth }), this.rowsContainer.style.width = "";
    }
  }
  constructor(e, t, i, n = ma) {
    var s, o, a, l, d, c, h, u, g, f, m, _, v;
    if (this.virtualDelegate = t, this.domId = `list_id_${++zo.InstanceCount}`, this.renderers = /* @__PURE__ */ new Map(), this.renderWidth = 0, this._scrollHeight = 0, this.scrollableElementUpdateDisposable = null, this.scrollableElementWidthDelayer = new pr(50), this.splicing = !1, this.dragOverAnimationStopDisposable = P.None, this.dragOverMouseY = 0, this.canDrop = !1, this.currentDragFeedbackDisposable = P.None, this.onDragLeaveTimeout = P.None, this.disposables = new q(), this._onDidChangeContentHeight = new R(), this._onDidChangeContentWidth = new R(), this.onDidChangeContentHeight = ne.latch(this._onDidChangeContentHeight.event, void 0, this.disposables), this._horizontalScrolling = !1, n.horizontalScrolling && n.supportDynamicHeights)
      throw new Error("Horizontal scrolling and dynamic heights not supported simultaneously");
    this.items = [], this.itemId = 0, this.rangeMap = this.createRangeMap((s = n.paddingTop) !== null && s !== void 0 ? s : 0);
    for (const C of i)
      this.renderers.set(C.templateId, C);
    this.cache = this.disposables.add(new Xte(this.renderers)), this.lastRenderTop = 0, this.lastRenderHeight = 0, this.domNode = document.createElement("div"), this.domNode.className = "monaco-list", this.domNode.classList.add(this.domId), this.domNode.tabIndex = 0, this.domNode.classList.toggle("mouse-support", typeof n.mouseSupport == "boolean" ? n.mouseSupport : !0), this._horizontalScrolling = (o = n.horizontalScrolling) !== null && o !== void 0 ? o : ma.horizontalScrolling, this.domNode.classList.toggle("horizontal-scrolling", this._horizontalScrolling), this.paddingBottom = typeof n.paddingBottom > "u" ? 0 : n.paddingBottom, this.accessibilityProvider = new iie(n.accessibilityProvider), this.rowsContainer = document.createElement("div"), this.rowsContainer.className = "monaco-list-rows", ((a = n.transformOptimization) !== null && a !== void 0 ? a : ma.transformOptimization) && (this.rowsContainer.style.transform = "translate3d(0px, 0px, 0px)", this.rowsContainer.style.overflow = "hidden", this.rowsContainer.style.contain = "strict"), this.disposables.add(At.addTarget(this.rowsContainer)), this.scrollable = this.disposables.add(new Mp({
      forceIntegerValues: !0,
      smoothScrollDuration: (l = n.smoothScrolling) !== null && l !== void 0 && l ? 125 : 0,
      scheduleAtNextAnimationFrame: (C) => Us(we(this.domNode), C)
    })), this.scrollableElement = this.disposables.add(new I0(this.rowsContainer, {
      alwaysConsumeMouseWheel: (d = n.alwaysConsumeMouseWheel) !== null && d !== void 0 ? d : ma.alwaysConsumeMouseWheel,
      horizontal: 1,
      vertical: (c = n.verticalScrollMode) !== null && c !== void 0 ? c : ma.verticalScrollMode,
      useShadows: (h = n.useShadows) !== null && h !== void 0 ? h : ma.useShadows,
      mouseWheelScrollSensitivity: n.mouseWheelScrollSensitivity,
      fastScrollSensitivity: n.fastScrollSensitivity,
      scrollByPage: n.scrollByPage
    }, this.scrollable)), this.domNode.appendChild(this.scrollableElement.getDomNode()), e.appendChild(this.domNode), this.scrollableElement.onScroll(this.onScroll, this, this.disposables), this.disposables.add(W(this.rowsContainer, Pt.Change, (C) => this.onTouchChange(C))), this.disposables.add(W(this.scrollableElement.getDomNode(), "scroll", (C) => C.target.scrollTop = 0)), this.disposables.add(W(this.domNode, "dragover", (C) => this.onDragOver(this.toDragEvent(C)))), this.disposables.add(W(this.domNode, "drop", (C) => this.onDrop(this.toDragEvent(C)))), this.disposables.add(W(this.domNode, "dragleave", (C) => this.onDragLeave(this.toDragEvent(C)))), this.disposables.add(W(this.domNode, "dragend", (C) => this.onDragEnd(C))), this.setRowLineHeight = (u = n.setRowLineHeight) !== null && u !== void 0 ? u : ma.setRowLineHeight, this.setRowHeight = (g = n.setRowHeight) !== null && g !== void 0 ? g : ma.setRowHeight, this.supportDynamicHeights = (f = n.supportDynamicHeights) !== null && f !== void 0 ? f : ma.supportDynamicHeights, this.dnd = (m = n.dnd) !== null && m !== void 0 ? m : this.disposables.add(ma.dnd), this.layout((_ = n.initialSize) === null || _ === void 0 ? void 0 : _.height, (v = n.initialSize) === null || v === void 0 ? void 0 : v.width);
  }
  updateOptions(e) {
    e.paddingBottom !== void 0 && (this.paddingBottom = e.paddingBottom, this.scrollableElement.setScrollDimensions({ scrollHeight: this.scrollHeight })), e.smoothScrolling !== void 0 && this.scrollable.setSmoothScrollDuration(e.smoothScrolling ? 125 : 0), e.horizontalScrolling !== void 0 && (this.horizontalScrolling = e.horizontalScrolling);
    let t;
    if (e.scrollByPage !== void 0 && (t = { ...t ?? {}, scrollByPage: e.scrollByPage }), e.mouseWheelScrollSensitivity !== void 0 && (t = { ...t ?? {}, mouseWheelScrollSensitivity: e.mouseWheelScrollSensitivity }), e.fastScrollSensitivity !== void 0 && (t = { ...t ?? {}, fastScrollSensitivity: e.fastScrollSensitivity }), t && this.scrollableElement.updateOptions(t), e.paddingTop !== void 0 && e.paddingTop !== this.rangeMap.paddingTop) {
      const i = this.getRenderRange(this.lastRenderTop, this.lastRenderHeight), n = e.paddingTop - this.rangeMap.paddingTop;
      this.rangeMap.paddingTop = e.paddingTop, this.render(i, Math.max(0, this.lastRenderTop + n), this.lastRenderHeight, void 0, void 0, !0), this.setScrollTop(this.lastRenderTop), this.eventuallyUpdateScrollDimensions(), this.supportDynamicHeights && this._rerender(this.lastRenderTop, this.lastRenderHeight);
    }
  }
  createRangeMap(e) {
    return new Yte(e);
  }
  splice(e, t, i = []) {
    if (this.splicing)
      throw new Error("Can't run recursive splices.");
    this.splicing = !0;
    try {
      return this._splice(e, t, i);
    } finally {
      this.splicing = !1, this._onDidChangeContentHeight.fire(this.contentHeight);
    }
  }
  _splice(e, t, i = []) {
    const n = this.getRenderRange(this.lastRenderTop, this.lastRenderHeight), s = { start: e, end: e + t }, o = In.intersect(n, s), a = /* @__PURE__ */ new Map();
    for (let S = o.end - 1; S >= o.start; S--) {
      const y = this.items[S];
      if (y.dragStartDisposable.dispose(), y.checkedDisposable.dispose(), y.row) {
        let k = a.get(y.templateId);
        k || (k = [], a.set(y.templateId, k));
        const E = this.renderers.get(y.templateId);
        E && E.disposeElement && E.disposeElement(y.element, S, y.row.templateData, y.size), k.unshift(y.row);
      }
      y.row = null, y.stale = !0;
    }
    const l = { start: e + t, end: this.items.length }, d = In.intersect(l, n), c = In.relativeComplement(l, n), h = i.map((S) => ({
      id: String(this.itemId++),
      element: S,
      templateId: this.virtualDelegate.getTemplateId(S),
      size: this.virtualDelegate.getHeight(S),
      width: void 0,
      hasDynamicHeight: !!this.virtualDelegate.hasDynamicHeight && this.virtualDelegate.hasDynamicHeight(S),
      lastDynamicHeightWidth: void 0,
      row: null,
      uri: void 0,
      dropTarget: !1,
      dragStartDisposable: P.None,
      checkedDisposable: P.None,
      stale: !1
    }));
    let u;
    e === 0 && t >= this.items.length ? (this.rangeMap = this.createRangeMap(this.rangeMap.paddingTop), this.rangeMap.splice(0, 0, h), u = this.items, this.items = h) : (this.rangeMap.splice(e, t, h), u = this.items.splice(e, t, ...h));
    const g = i.length - t, f = this.getRenderRange(this.lastRenderTop, this.lastRenderHeight), m = UI(d, g), _ = In.intersect(f, m);
    for (let S = _.start; S < _.end; S++)
      this.updateItemInDOM(this.items[S], S);
    const v = In.relativeComplement(m, f);
    for (const S of v)
      for (let y = S.start; y < S.end; y++)
        this.removeItemFromDOM(y);
    const b = c.map((S) => UI(S, g)), w = [{ start: e, end: e + i.length }, ...b].map((S) => In.intersect(f, S)).reverse();
    for (const S of w)
      for (let y = S.end - 1; y >= S.start; y--) {
        const k = this.items[y], E = a.get(k.templateId), N = E == null ? void 0 : E.pop();
        this.insertItemInDOM(y, N);
      }
    for (const S of a.values())
      for (const y of S)
        this.cache.release(y);
    return this.eventuallyUpdateScrollDimensions(), this.supportDynamicHeights && this._rerender(this.scrollTop, this.renderHeight), u.map((S) => S.element);
  }
  eventuallyUpdateScrollDimensions() {
    this._scrollHeight = this.contentHeight, this.rowsContainer.style.height = `${this._scrollHeight}px`, this.scrollableElementUpdateDisposable || (this.scrollableElementUpdateDisposable = Us(we(this.domNode), () => {
      this.scrollableElement.setScrollDimensions({ scrollHeight: this.scrollHeight }), this.updateScrollWidth(), this.scrollableElementUpdateDisposable = null;
    }));
  }
  eventuallyUpdateScrollWidth() {
    if (!this.horizontalScrolling) {
      this.scrollableElementWidthDelayer.cancel();
      return;
    }
    this.scrollableElementWidthDelayer.trigger(() => this.updateScrollWidth());
  }
  updateScrollWidth() {
    if (!this.horizontalScrolling)
      return;
    let e = 0;
    for (const t of this.items)
      typeof t.width < "u" && (e = Math.max(e, t.width));
    this.scrollWidth = e, this.scrollableElement.setScrollDimensions({ scrollWidth: e === 0 ? 0 : e + 10 }), this._onDidChangeContentWidth.fire(this.scrollWidth);
  }
  rerender() {
    if (this.supportDynamicHeights) {
      for (const e of this.items)
        e.lastDynamicHeightWidth = void 0;
      this._rerender(this.lastRenderTop, this.lastRenderHeight);
    }
  }
  get length() {
    return this.items.length;
  }
  get renderHeight() {
    return this.scrollableElement.getScrollDimensions().height;
  }
  get firstVisibleIndex() {
    return this.getRenderRange(this.lastRenderTop, this.lastRenderHeight).start;
  }
  element(e) {
    return this.items[e].element;
  }
  indexOf(e) {
    return this.items.findIndex((t) => t.element === e);
  }
  domElement(e) {
    const t = this.items[e].row;
    return t && t.domNode;
  }
  elementHeight(e) {
    return this.items[e].size;
  }
  elementTop(e) {
    return this.rangeMap.positionAt(e);
  }
  indexAt(e) {
    return this.rangeMap.indexAt(e);
  }
  indexAfter(e) {
    return this.rangeMap.indexAfter(e);
  }
  layout(e, t) {
    const i = {
      height: typeof e == "number" ? e : U8(this.domNode)
    };
    this.scrollableElementUpdateDisposable && (this.scrollableElementUpdateDisposable.dispose(), this.scrollableElementUpdateDisposable = null, i.scrollHeight = this.scrollHeight), this.scrollableElement.setScrollDimensions(i), typeof t < "u" && (this.renderWidth = t, this.supportDynamicHeights && this._rerender(this.scrollTop, this.renderHeight)), this.horizontalScrolling && this.scrollableElement.setScrollDimensions({
      width: typeof t == "number" ? t : ED(this.domNode)
    });
  }
  // Render
  render(e, t, i, n, s, o = !1) {
    const a = this.getRenderRange(t, i), l = In.relativeComplement(a, e).reverse(), d = In.relativeComplement(e, a);
    if (o) {
      const c = In.intersect(e, a);
      for (let h = c.start; h < c.end; h++)
        this.updateItemInDOM(this.items[h], h);
    }
    this.cache.transact(() => {
      for (const c of d)
        for (let h = c.start; h < c.end; h++)
          this.removeItemFromDOM(h);
      for (const c of l)
        for (let h = c.end - 1; h >= c.start; h--)
          this.insertItemInDOM(h);
    }), n !== void 0 && (this.rowsContainer.style.left = `-${n}px`), this.rowsContainer.style.top = `-${t}px`, this.horizontalScrolling && s !== void 0 && (this.rowsContainer.style.width = `${Math.max(s, this.renderWidth)}px`), this.lastRenderTop = t, this.lastRenderHeight = i;
  }
  // DOM operations
  insertItemInDOM(e, t) {
    var i, n, s;
    const o = this.items[e];
    if (!o.row)
      if (t)
        o.row = t, o.stale = !0;
      else {
        const h = this.cache.alloc(o.templateId);
        o.row = h.row, o.stale || (o.stale = h.isReusingConnectedDomNode);
      }
    const a = this.accessibilityProvider.getRole(o.element) || "listitem";
    o.row.domNode.setAttribute("role", a);
    const l = this.accessibilityProvider.isChecked(o.element);
    if (typeof l == "boolean")
      o.row.domNode.setAttribute("aria-checked", String(!!l));
    else if (l) {
      const h = (u) => o.row.domNode.setAttribute("aria-checked", String(!!u));
      h(l.value), o.checkedDisposable = l.onDidChange(() => h(l.value));
    }
    if (o.stale || !o.row.domNode.parentElement) {
      const h = (s = (n = (i = this.items.at(e + 1)) === null || i === void 0 ? void 0 : i.row) === null || n === void 0 ? void 0 : n.domNode) !== null && s !== void 0 ? s : null;
      (o.row.domNode.parentElement !== this.rowsContainer || o.row.domNode.nextElementSibling !== h) && this.rowsContainer.insertBefore(o.row.domNode, h), o.stale = !1;
    }
    this.updateItemInDOM(o, e);
    const d = this.renderers.get(o.templateId);
    if (!d)
      throw new Error(`No renderer found for template id ${o.templateId}`);
    d == null || d.renderElement(o.element, e, o.row.templateData, o.size);
    const c = this.dnd.getDragURI(o.element);
    o.dragStartDisposable.dispose(), o.row.domNode.draggable = !!c, c && (o.dragStartDisposable = W(o.row.domNode, "dragstart", (h) => this.onDragStart(o.element, c, h))), this.horizontalScrolling && (this.measureItemWidth(o), this.eventuallyUpdateScrollWidth());
  }
  measureItemWidth(e) {
    if (!e.row || !e.row.domNode)
      return;
    e.row.domNode.style.width = "fit-content", e.width = ED(e.row.domNode);
    const t = we(e.row.domNode).getComputedStyle(e.row.domNode);
    t.paddingLeft && (e.width += parseFloat(t.paddingLeft)), t.paddingRight && (e.width += parseFloat(t.paddingRight)), e.row.domNode.style.width = "";
  }
  updateItemInDOM(e, t) {
    e.row.domNode.style.top = `${this.elementTop(t)}px`, this.setRowHeight && (e.row.domNode.style.height = `${e.size}px`), this.setRowLineHeight && (e.row.domNode.style.lineHeight = `${e.size}px`), e.row.domNode.setAttribute("data-index", `${t}`), e.row.domNode.setAttribute("data-last-element", t === this.length - 1 ? "true" : "false"), e.row.domNode.setAttribute("data-parity", t % 2 === 0 ? "even" : "odd"), e.row.domNode.setAttribute("aria-setsize", String(this.accessibilityProvider.getSetSize(e.element, t, this.length))), e.row.domNode.setAttribute("aria-posinset", String(this.accessibilityProvider.getPosInSet(e.element, t))), e.row.domNode.setAttribute("id", this.getElementDomId(t)), e.row.domNode.classList.toggle("drop-target", e.dropTarget);
  }
  removeItemFromDOM(e) {
    const t = this.items[e];
    if (t.dragStartDisposable.dispose(), t.checkedDisposable.dispose(), t.row) {
      const i = this.renderers.get(t.templateId);
      i && i.disposeElement && i.disposeElement(t.element, e, t.row.templateData, t.size), this.cache.release(t.row), t.row = null;
    }
    this.horizontalScrolling && this.eventuallyUpdateScrollWidth();
  }
  getScrollTop() {
    return this.scrollableElement.getScrollPosition().scrollTop;
  }
  setScrollTop(e, t) {
    this.scrollableElementUpdateDisposable && (this.scrollableElementUpdateDisposable.dispose(), this.scrollableElementUpdateDisposable = null, this.scrollableElement.setScrollDimensions({ scrollHeight: this.scrollHeight })), this.scrollableElement.setScrollPosition({ scrollTop: e, reuseAnimation: t });
  }
  get scrollTop() {
    return this.getScrollTop();
  }
  set scrollTop(e) {
    this.setScrollTop(e);
  }
  get scrollHeight() {
    return this._scrollHeight + (this.horizontalScrolling ? 10 : 0) + this.paddingBottom;
  }
  // Events
  get onMouseClick() {
    return ne.map(this.disposables.add(new tt(this.domNode, "click")).event, (e) => this.toMouseEvent(e), this.disposables);
  }
  get onMouseDblClick() {
    return ne.map(this.disposables.add(new tt(this.domNode, "dblclick")).event, (e) => this.toMouseEvent(e), this.disposables);
  }
  get onMouseMiddleClick() {
    return ne.filter(ne.map(this.disposables.add(new tt(this.domNode, "auxclick")).event, (e) => this.toMouseEvent(e), this.disposables), (e) => e.browserEvent.button === 1, this.disposables);
  }
  get onMouseDown() {
    return ne.map(this.disposables.add(new tt(this.domNode, "mousedown")).event, (e) => this.toMouseEvent(e), this.disposables);
  }
  get onMouseOver() {
    return ne.map(this.disposables.add(new tt(this.domNode, "mouseover")).event, (e) => this.toMouseEvent(e), this.disposables);
  }
  get onMouseOut() {
    return ne.map(this.disposables.add(new tt(this.domNode, "mouseout")).event, (e) => this.toMouseEvent(e), this.disposables);
  }
  get onContextMenu() {
    return ne.any(ne.map(this.disposables.add(new tt(this.domNode, "contextmenu")).event, (e) => this.toMouseEvent(e), this.disposables), ne.map(this.disposables.add(new tt(this.domNode, Pt.Contextmenu)).event, (e) => this.toGestureEvent(e), this.disposables));
  }
  get onTouchStart() {
    return ne.map(this.disposables.add(new tt(this.domNode, "touchstart")).event, (e) => this.toTouchEvent(e), this.disposables);
  }
  get onTap() {
    return ne.map(this.disposables.add(new tt(this.rowsContainer, Pt.Tap)).event, (e) => this.toGestureEvent(e), this.disposables);
  }
  toMouseEvent(e) {
    const t = this.getItemIndexFromEventTarget(e.target || null), i = typeof t > "u" ? void 0 : this.items[t], n = i && i.element;
    return { browserEvent: e, index: t, element: n };
  }
  toTouchEvent(e) {
    const t = this.getItemIndexFromEventTarget(e.target || null), i = typeof t > "u" ? void 0 : this.items[t], n = i && i.element;
    return { browserEvent: e, index: t, element: n };
  }
  toGestureEvent(e) {
    const t = this.getItemIndexFromEventTarget(e.initialTarget || null), i = typeof t > "u" ? void 0 : this.items[t], n = i && i.element;
    return { browserEvent: e, index: t, element: n };
  }
  toDragEvent(e) {
    const t = this.getItemIndexFromEventTarget(e.target || null), i = typeof t > "u" ? void 0 : this.items[t], n = i && i.element, s = this.getTargetSector(e, t);
    return { browserEvent: e, index: t, element: n, sector: s };
  }
  onScroll(e) {
    try {
      const t = this.getRenderRange(this.lastRenderTop, this.lastRenderHeight);
      this.render(t, e.scrollTop, e.height, e.scrollLeft, e.scrollWidth), this.supportDynamicHeights && this._rerender(e.scrollTop, e.height, e.inSmoothScrolling);
    } catch (t) {
      throw console.error("Got bad scroll event:", e), t;
    }
  }
  onTouchChange(e) {
    e.preventDefault(), e.stopPropagation(), this.scrollTop -= e.translationY;
  }
  // DND
  onDragStart(e, t, i) {
    var n, s;
    if (!i.dataTransfer)
      return;
    const o = this.dnd.getDragElements(e);
    if (i.dataTransfer.effectAllowed = "copyMove", i.dataTransfer.setData(lv.TEXT, t), i.dataTransfer.setDragImage) {
      let a;
      this.dnd.getDragLabel && (a = this.dnd.getDragLabel(o, i)), typeof a > "u" && (a = String(o.length));
      const l = X(".monaco-drag-image");
      l.textContent = a;
      const c = ((h) => {
        for (; h && !h.classList.contains("monaco-workbench"); )
          h = h.parentElement;
        return h || this.domNode.ownerDocument;
      })(this.domNode);
      c.appendChild(l), i.dataTransfer.setDragImage(l, -10, -10), setTimeout(() => c.removeChild(l), 0);
    }
    this.domNode.classList.add("dragging"), this.currentDragData = new Lb(o), yh.CurrentDragAndDropData = new Jte(o), (s = (n = this.dnd).onDragStart) === null || s === void 0 || s.call(n, this.currentDragData, i);
  }
  onDragOver(e) {
    var t, i;
    if (e.browserEvent.preventDefault(), this.onDragLeaveTimeout.dispose(), yh.CurrentDragAndDropData && yh.CurrentDragAndDropData.getData() === "vscode-ui" || (this.setupDragAndDropScrollTopAnimation(e.browserEvent), !e.browserEvent.dataTransfer))
      return !1;
    if (!this.currentDragData)
      if (yh.CurrentDragAndDropData)
        this.currentDragData = yh.CurrentDragAndDropData;
      else {
        if (!e.browserEvent.dataTransfer.types)
          return !1;
        this.currentDragData = new eie();
      }
    const n = this.dnd.onDragOver(this.currentDragData, e.element, e.index, e.sector, e.browserEvent);
    if (this.canDrop = typeof n == "boolean" ? n : n.accept, !this.canDrop)
      return this.currentDragFeedback = void 0, this.currentDragFeedbackDisposable.dispose(), !1;
    e.browserEvent.dataTransfer.dropEffect = typeof n != "boolean" && ((t = n.effect) === null || t === void 0 ? void 0 : t.type) === 0 ? "copy" : "move";
    let s;
    typeof n != "boolean" && n.feedback ? s = n.feedback : typeof e.index > "u" ? s = [-1] : s = [e.index], s = rd(s).filter((a) => a >= -1 && a < this.length).sort((a, l) => a - l), s = s[0] === -1 ? [-1] : s;
    let o = typeof n != "boolean" && n.effect && n.effect.position ? n.effect.position : "drop-target";
    if (tie(this.currentDragFeedback, s) && this.currentDragFeedbackPosition === o)
      return !0;
    if (this.currentDragFeedback = s, this.currentDragFeedbackPosition = o, this.currentDragFeedbackDisposable.dispose(), s[0] === -1)
      this.domNode.classList.add(o), this.rowsContainer.classList.add(o), this.currentDragFeedbackDisposable = Se(() => {
        this.domNode.classList.remove(o), this.rowsContainer.classList.remove(o);
      });
    else {
      if (s.length > 1 && o !== "drop-target")
        throw new Error("Can't use multiple feedbacks with position different than 'over'");
      o === "drop-target-after" && s[0] < this.length - 1 && (s[0] += 1, o = "drop-target-before");
      for (const a of s) {
        const l = this.items[a];
        l.dropTarget = !0, (i = l.row) === null || i === void 0 || i.domNode.classList.add(o);
      }
      this.currentDragFeedbackDisposable = Se(() => {
        var a;
        for (const l of s) {
          const d = this.items[l];
          d.dropTarget = !1, (a = d.row) === null || a === void 0 || a.domNode.classList.remove(o);
        }
      });
    }
    return !0;
  }
  onDragLeave(e) {
    var t, i;
    this.onDragLeaveTimeout.dispose(), this.onDragLeaveTimeout = Mc(() => this.clearDragOverFeedback(), 100, this.disposables), this.currentDragData && ((i = (t = this.dnd).onDragLeave) === null || i === void 0 || i.call(t, this.currentDragData, e.element, e.index, e.browserEvent));
  }
  onDrop(e) {
    if (!this.canDrop)
      return;
    const t = this.currentDragData;
    this.teardownDragAndDropScrollTopAnimation(), this.clearDragOverFeedback(), this.domNode.classList.remove("dragging"), this.currentDragData = void 0, yh.CurrentDragAndDropData = void 0, !(!t || !e.browserEvent.dataTransfer) && (e.browserEvent.preventDefault(), t.update(e.browserEvent.dataTransfer), this.dnd.drop(t, e.element, e.index, e.sector, e.browserEvent));
  }
  onDragEnd(e) {
    var t, i;
    this.canDrop = !1, this.teardownDragAndDropScrollTopAnimation(), this.clearDragOverFeedback(), this.domNode.classList.remove("dragging"), this.currentDragData = void 0, yh.CurrentDragAndDropData = void 0, (i = (t = this.dnd).onDragEnd) === null || i === void 0 || i.call(t, e);
  }
  clearDragOverFeedback() {
    this.currentDragFeedback = void 0, this.currentDragFeedbackPosition = void 0, this.currentDragFeedbackDisposable.dispose(), this.currentDragFeedbackDisposable = P.None;
  }
  // DND scroll top animation
  setupDragAndDropScrollTopAnimation(e) {
    if (!this.dragOverAnimationDisposable) {
      const t = HH(this.domNode).top;
      this.dragOverAnimationDisposable = t6(we(this.domNode), this.animateDragAndDropScrollTop.bind(this, t));
    }
    this.dragOverAnimationStopDisposable.dispose(), this.dragOverAnimationStopDisposable = Mc(() => {
      this.dragOverAnimationDisposable && (this.dragOverAnimationDisposable.dispose(), this.dragOverAnimationDisposable = void 0);
    }, 1e3, this.disposables), this.dragOverMouseY = e.pageY;
  }
  animateDragAndDropScrollTop(e) {
    if (this.dragOverMouseY === void 0)
      return;
    const t = this.dragOverMouseY - e, i = this.renderHeight - 35;
    t < 35 ? this.scrollTop += Math.max(-14, Math.floor(0.3 * (t - 35))) : t > i && (this.scrollTop += Math.min(14, Math.floor(0.3 * (t - i))));
  }
  teardownDragAndDropScrollTopAnimation() {
    this.dragOverAnimationStopDisposable.dispose(), this.dragOverAnimationDisposable && (this.dragOverAnimationDisposable.dispose(), this.dragOverAnimationDisposable = void 0);
  }
  // Util
  getTargetSector(e, t) {
    if (t === void 0)
      return;
    const i = e.offsetY / this.items[t].size, n = Math.floor(i / 0.25);
    return Yn(n, 0, 3);
  }
  getItemIndexFromEventTarget(e) {
    const t = this.scrollableElement.getDomNode();
    let i = e;
    for (; ln(i) && i !== this.rowsContainer && t.contains(i); ) {
      const n = i.getAttribute("data-index");
      if (n) {
        const s = Number(n);
        if (!isNaN(s))
          return s;
      }
      i = i.parentElement;
    }
  }
  getRenderRange(e, t) {
    return {
      start: this.rangeMap.indexAt(e),
      end: this.rangeMap.indexAfter(e + t - 1)
    };
  }
  /**
   * Given a stable rendered state, checks every rendered element whether it needs
   * to be probed for dynamic height. Adjusts scroll height and top if necessary.
   */
  _rerender(e, t, i) {
    const n = this.getRenderRange(e, t);
    let s, o;
    e === this.elementTop(n.start) ? (s = n.start, o = 0) : n.end - n.start > 1 && (s = n.start + 1, o = this.elementTop(s) - e);
    let a = 0;
    for (; ; ) {
      const l = this.getRenderRange(e, t);
      let d = !1;
      for (let c = l.start; c < l.end; c++) {
        const h = this.probeDynamicHeight(c);
        h !== 0 && this.rangeMap.splice(c, 1, [this.items[c]]), a += h, d = d || h !== 0;
      }
      if (!d) {
        a !== 0 && this.eventuallyUpdateScrollDimensions();
        const c = In.relativeComplement(n, l);
        for (const u of c)
          for (let g = u.start; g < u.end; g++)
            this.items[g].row && this.removeItemFromDOM(g);
        const h = In.relativeComplement(l, n).reverse();
        for (const u of h)
          for (let g = u.end - 1; g >= u.start; g--)
            this.insertItemInDOM(g);
        for (let u = l.start; u < l.end; u++)
          this.items[u].row && this.updateItemInDOM(this.items[u], u);
        if (typeof s == "number") {
          const u = this.scrollable.getFutureScrollPosition().scrollTop - e, g = this.elementTop(s) - o + u;
          this.setScrollTop(g, i);
        }
        this._onDidChangeContentHeight.fire(this.contentHeight);
        return;
      }
    }
  }
  probeDynamicHeight(e) {
    var t, i, n;
    const s = this.items[e];
    if (this.virtualDelegate.getDynamicHeight) {
      const d = this.virtualDelegate.getDynamicHeight(s.element);
      if (d !== null) {
        const c = s.size;
        return s.size = d, s.lastDynamicHeightWidth = this.renderWidth, d - c;
      }
    }
    if (!s.hasDynamicHeight || s.lastDynamicHeightWidth === this.renderWidth || this.virtualDelegate.hasDynamicHeight && !this.virtualDelegate.hasDynamicHeight(s.element))
      return 0;
    const o = s.size;
    if (s.row)
      return s.row.domNode.style.height = "", s.size = s.row.domNode.offsetHeight, s.size === 0 && !qi(s.row.domNode, we(s.row.domNode).document.body) && console.warn("Measuring item node that is not in DOM! Add ListView to the DOM before measuring row height!"), s.lastDynamicHeightWidth = this.renderWidth, s.size - o;
    const { row: a } = this.cache.alloc(s.templateId);
    a.domNode.style.height = "", this.rowsContainer.appendChild(a.domNode);
    const l = this.renderers.get(s.templateId);
    if (!l)
      throw new Li("Missing renderer for templateId: " + s.templateId);
    return l.renderElement(s.element, e, a.templateData, void 0), s.size = a.domNode.offsetHeight, (t = l.disposeElement) === null || t === void 0 || t.call(l, s.element, e, a.templateData, void 0), (n = (i = this.virtualDelegate).setDynamicHeight) === null || n === void 0 || n.call(i, s.element, s.size), s.lastDynamicHeightWidth = this.renderWidth, this.rowsContainer.removeChild(a.domNode), this.cache.release(a), s.size - o;
  }
  getElementDomId(e) {
    return `${this.domId}_${e}`;
  }
  // Dispose
  dispose() {
    var e, t;
    for (const i of this.items)
      if (i.dragStartDisposable.dispose(), i.checkedDisposable.dispose(), i.row) {
        const n = this.renderers.get(i.row.templateId);
        n && ((e = n.disposeElement) === null || e === void 0 || e.call(n, i.element, -1, i.row.templateData, void 0), n.disposeTemplate(i.row.templateData));
      }
    this.items = [], this.domNode && this.domNode.parentNode && this.domNode.parentNode.removeChild(this.domNode), (t = this.dragOverAnimationDisposable) === null || t === void 0 || t.dispose(), this.disposables.dispose();
  }
}
zo.InstanceCount = 0;
yd([
  ki
], zo.prototype, "onMouseClick", null);
yd([
  ki
], zo.prototype, "onMouseDblClick", null);
yd([
  ki
], zo.prototype, "onMouseMiddleClick", null);
yd([
  ki
], zo.prototype, "onMouseDown", null);
yd([
  ki
], zo.prototype, "onMouseOver", null);
yd([
  ki
], zo.prototype, "onMouseOut", null);
yd([
  ki
], zo.prototype, "onContextMenu", null);
yd([
  ki
], zo.prototype, "onTouchStart", null);
yd([
  ki
], zo.prototype, "onTap", null);
const ta = (r, e) => r === e;
function $I(r = ta) {
  return (e, t) => ci(e, t, r);
}
function vz() {
  return (r, e) => r.equals(e);
}
function nie(r, e, t) {
  return !r || !e ? r === e : t(r, e);
}
class Ds {
  constructor(e, t, i) {
    this.owner = e, this.debugNameSource = t, this.referenceFn = i;
  }
  getDebugName(e) {
    return sie(e, this);
  }
}
const YO = /* @__PURE__ */ new Map(), KI = /* @__PURE__ */ new WeakMap();
function sie(r, e) {
  var t;
  const i = KI.get(r);
  if (i)
    return i;
  const n = oie(r, e);
  if (n) {
    let s = (t = YO.get(n)) !== null && t !== void 0 ? t : 0;
    s++, YO.set(n, s);
    const o = s === 1 ? n : `${n}#${s}`;
    return KI.set(r, o), o;
  }
}
function oie(r, e) {
  const t = KI.get(r);
  if (t)
    return t;
  const i = e.owner ? aie(e.owner) + "." : "";
  let n;
  const s = e.debugNameSource;
  if (s !== void 0)
    if (typeof s == "function") {
      if (n = s(), n !== void 0)
        return i + n;
    } else
      return i + s;
  const o = e.referenceFn;
  if (o !== void 0 && (n = q0(o), n !== void 0))
    return i + n;
  if (e.owner !== void 0) {
    const a = rie(e.owner, r);
    if (a !== void 0)
      return i + a;
  }
}
function rie(r, e) {
  for (const t in r)
    if (r[t] === e)
      return t;
}
const QO = /* @__PURE__ */ new Map(), XO = /* @__PURE__ */ new WeakMap();
function aie(r) {
  var e;
  const t = XO.get(r);
  if (t)
    return t;
  const i = lie(r);
  let n = (e = QO.get(i)) !== null && e !== void 0 ? e : 0;
  n++, QO.set(i, n);
  const s = n === 1 ? i : `${i}#${n}`;
  return XO.set(r, s), s;
}
function lie(r) {
  const e = r.constructor;
  return e ? e.name : "Object";
}
function q0(r) {
  const e = r.toString(), i = /\/\*\*\s*@description\s*([^*]*)\*\//.exec(e), n = i ? i[1] : void 0;
  return n == null ? void 0 : n.trim();
}
let die;
function Za() {
  return die;
}
let bz;
function cie(r) {
  bz = r;
}
let Cz;
function hie(r) {
  Cz = r;
}
class wz {
  get TChange() {
    return null;
  }
  reportChanges() {
    this.get();
  }
  /** @sealed */
  read(e) {
    return e ? e.readObservable(this) : this.get();
  }
  map(e, t) {
    const i = t === void 0 ? void 0 : e, n = t === void 0 ? e : t;
    return Cz({
      owner: i,
      debugName: () => {
        const s = q0(n);
        if (s !== void 0)
          return s;
        const a = /^\s*\(?\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\s*\)?\s*=>\s*\1(?:\??)\.([a-zA-Z_$][a-zA-Z_$0-9]*)\s*$/.exec(n.toString());
        if (a)
          return `${this.debugName}.${a[2]}`;
        if (!i)
          return `${this.debugName} (mapped)`;
      },
      debugReferenceFn: n
    }, (s) => n(this.read(s), s));
  }
  recomputeInitiallyAndOnChange(e, t) {
    return e.add(bz(this, t)), this;
  }
}
class Db extends wz {
  constructor() {
    super(...arguments), this.observers = /* @__PURE__ */ new Set();
  }
  addObserver(e) {
    const t = this.observers.size;
    this.observers.add(e), t === 0 && this.onFirstObserverAdded();
  }
  removeObserver(e) {
    this.observers.delete(e) && this.observers.size === 0 && this.onLastObserverRemoved();
  }
  onFirstObserverAdded() {
  }
  onLastObserverRemoved() {
  }
}
function Nt(r, e) {
  const t = new G0(r, e);
  try {
    r(t);
  } finally {
    t.finish();
  }
}
let HC;
function Hw(r) {
  if (HC)
    r(HC);
  else {
    const e = new G0(r, void 0);
    HC = e;
    try {
      r(e);
    } finally {
      e.finish(), HC = void 0;
    }
  }
}
async function uie(r, e) {
  const t = new G0(r, e);
  try {
    await r(t);
  } finally {
    t.finish();
  }
}
function dv(r, e, t) {
  r ? e(r) : Nt(e, t);
}
class G0 {
  constructor(e, t) {
    var i;
    this._fn = e, this._getDebugName = t, this.updatingObservers = [], (i = Za()) === null || i === void 0 || i.handleBeginTransaction(this);
  }
  getDebugName() {
    return this._getDebugName ? this._getDebugName() : q0(this._fn);
  }
  updateObserver(e, t) {
    this.updatingObservers.push({ observer: e, observable: t }), e.beginUpdate(t);
  }
  finish() {
    var e;
    const t = this.updatingObservers;
    for (let i = 0; i < t.length; i++) {
      const { observer: n, observable: s } = t[i];
      n.endUpdate(s);
    }
    this.updatingObservers = null, (e = Za()) === null || e === void 0 || e.handleEndTransaction();
  }
}
function rt(r, e) {
  let t;
  return typeof r == "string" ? t = new Ds(void 0, r, void 0) : t = new Ds(r, void 0, void 0), new mM(t, e, ta);
}
function gie(r, e) {
  var t;
  return new mM(new Ds(r.owner, r.debugName, void 0), e, (t = r.equalsFn) !== null && t !== void 0 ? t : ta);
}
class mM extends Db {
  get debugName() {
    var e;
    return (e = this._debugNameData.getDebugName(this)) !== null && e !== void 0 ? e : "ObservableValue";
  }
  constructor(e, t, i) {
    super(), this._debugNameData = e, this._equalityComparator = i, this._value = t;
  }
  get() {
    return this._value;
  }
  set(e, t, i) {
    var n;
    if (i === void 0 && this._equalityComparator(this._value, e))
      return;
    let s;
    t || (t = s = new G0(() => {
    }, () => `Setting ${this.debugName}`));
    try {
      const o = this._value;
      this._setValue(e), (n = Za()) === null || n === void 0 || n.handleObservableChanged(this, { oldValue: o, newValue: e, change: i, didChange: !0, hadValue: !0 });
      for (const a of this.observers)
        t.updateObserver(a, this), a.handleChange(this, i);
    } finally {
      s && s.finish();
    }
  }
  toString() {
    return `${this.debugName}: ${this._value}`;
  }
  _setValue(e) {
    this._value = e;
  }
}
function cv(r, e) {
  let t;
  return typeof r == "string" ? t = new Ds(void 0, r, void 0) : t = new Ds(r, void 0, void 0), new fie(t, e, ta);
}
class fie extends mM {
  _setValue(e) {
    this._value !== e && (this._value && this._value.dispose(), this._value = e);
  }
  dispose() {
    var e;
    (e = this._value) === null || e === void 0 || e.dispose();
  }
}
function Pe(r, e) {
  return e !== void 0 ? new xu(new Ds(r, void 0, e), e, void 0, void 0, void 0, ta) : new xu(new Ds(void 0, void 0, r), r, void 0, void 0, void 0, ta);
}
function Sz(r, e, t) {
  return new mie(new Ds(r, void 0, e), e, void 0, void 0, void 0, ta, t);
}
function Fl(r, e) {
  var t;
  return new xu(new Ds(r.owner, r.debugName, r.debugReferenceFn), e, void 0, void 0, r.onLastObserverRemoved, (t = r.equalsFn) !== null && t !== void 0 ? t : ta);
}
hie(Fl);
function pie(r, e) {
  var t;
  return new xu(new Ds(r.owner, r.debugName, void 0), e, r.createEmptyChangeSummary, r.handleChange, void 0, (t = r.equalityComparer) !== null && t !== void 0 ? t : ta);
}
function ig(r, e) {
  let t, i;
  e === void 0 ? (t = r, i = void 0) : (i = r, t = e);
  const n = new q();
  return new xu(new Ds(i, void 0, t), (s) => (n.clear(), t(s, n)), void 0, void 0, () => n.dispose(), ta);
}
function Da(r, e) {
  let t, i;
  e === void 0 ? (t = r, i = void 0) : (i = r, t = e);
  const n = new q();
  return new xu(new Ds(i, void 0, t), (s) => {
    n.clear();
    const o = t(s);
    return o && n.add(o), o;
  }, void 0, void 0, () => n.dispose(), ta);
}
class xu extends Db {
  get debugName() {
    var e;
    return (e = this._debugNameData.getDebugName(this)) !== null && e !== void 0 ? e : "(anonymous)";
  }
  constructor(e, t, i, n, s = void 0, o) {
    var a, l;
    super(), this._debugNameData = e, this._computeFn = t, this.createChangeSummary = i, this._handleChange = n, this._handleLastObserverRemoved = s, this._equalityComparator = o, this.state = 0, this.value = void 0, this.updateCount = 0, this.dependencies = /* @__PURE__ */ new Set(), this.dependenciesToBeRemoved = /* @__PURE__ */ new Set(), this.changeSummary = void 0, this.changeSummary = (a = this.createChangeSummary) === null || a === void 0 ? void 0 : a.call(this), (l = Za()) === null || l === void 0 || l.handleDerivedCreated(this);
  }
  onLastObserverRemoved() {
    var e;
    this.state = 0, this.value = void 0;
    for (const t of this.dependencies)
      t.removeObserver(this);
    this.dependencies.clear(), (e = this._handleLastObserverRemoved) === null || e === void 0 || e.call(this);
  }
  get() {
    var e;
    if (this.observers.size === 0) {
      const t = this._computeFn(this, (e = this.createChangeSummary) === null || e === void 0 ? void 0 : e.call(this));
      return this.onLastObserverRemoved(), t;
    } else {
      do {
        if (this.state === 1) {
          for (const t of this.dependencies)
            if (t.reportChanges(), this.state === 2)
              break;
        }
        this.state === 1 && (this.state = 3), this._recomputeIfNeeded();
      } while (this.state !== 3);
      return this.value;
    }
  }
  _recomputeIfNeeded() {
    var e, t;
    if (this.state === 3)
      return;
    const i = this.dependenciesToBeRemoved;
    this.dependenciesToBeRemoved = this.dependencies, this.dependencies = i;
    const n = this.state !== 0, s = this.value;
    this.state = 3;
    const o = this.changeSummary;
    this.changeSummary = (e = this.createChangeSummary) === null || e === void 0 ? void 0 : e.call(this);
    try {
      this.value = this._computeFn(this, o);
    } finally {
      for (const l of this.dependenciesToBeRemoved)
        l.removeObserver(this);
      this.dependenciesToBeRemoved.clear();
    }
    const a = n && !this._equalityComparator(s, this.value);
    if ((t = Za()) === null || t === void 0 || t.handleDerivedRecomputed(this, {
      oldValue: s,
      newValue: this.value,
      change: void 0,
      didChange: a,
      hadValue: n
    }), a)
      for (const l of this.observers)
        l.handleChange(this, void 0);
  }
  toString() {
    return `LazyDerived<${this.debugName}>`;
  }
  // IObserver Implementation
  beginUpdate(e) {
    this.updateCount++;
    const t = this.updateCount === 1;
    if (this.state === 3 && (this.state = 1, !t))
      for (const i of this.observers)
        i.handlePossibleChange(this);
    if (t)
      for (const i of this.observers)
        i.beginUpdate(this);
  }
  endUpdate(e) {
    if (this.updateCount--, this.updateCount === 0) {
      const t = [...this.observers];
      for (const i of t)
        i.endUpdate(this);
    }
    aH(() => this.updateCount >= 0);
  }
  handlePossibleChange(e) {
    if (this.state === 3 && this.dependencies.has(e) && !this.dependenciesToBeRemoved.has(e)) {
      this.state = 1;
      for (const t of this.observers)
        t.handlePossibleChange(this);
    }
  }
  handleChange(e, t) {
    if (this.dependencies.has(e) && !this.dependenciesToBeRemoved.has(e)) {
      const i = this._handleChange ? this._handleChange({
        changedObservable: e,
        change: t,
        didChange: (s) => s === e
      }, this.changeSummary) : !0, n = this.state === 3;
      if (i && (this.state === 1 || n) && (this.state = 2, n))
        for (const s of this.observers)
          s.handlePossibleChange(this);
    }
  }
  // IReader Implementation
  readObservable(e) {
    e.addObserver(this);
    const t = e.get();
    return this.dependencies.add(e), this.dependenciesToBeRemoved.delete(e), t;
  }
  addObserver(e) {
    const t = !this.observers.has(e) && this.updateCount > 0;
    super.addObserver(e), t && e.beginUpdate(this);
  }
  removeObserver(e) {
    const t = this.observers.has(e) && this.updateCount > 0;
    super.removeObserver(e), t && e.endUpdate(this);
  }
}
class mie extends xu {
  constructor(e, t, i, n, s = void 0, o, a) {
    super(e, t, i, n, s, o), this.set = a;
  }
}
function qe(r) {
  return new Y0(new Ds(void 0, void 0, r), r, void 0, void 0);
}
function Z0(r, e) {
  var t;
  return new Y0(new Ds(r.owner, r.debugName, (t = r.debugReferenceFn) !== null && t !== void 0 ? t : e), e, void 0, void 0);
}
function kb(r, e) {
  var t;
  return new Y0(new Ds(r.owner, r.debugName, (t = r.debugReferenceFn) !== null && t !== void 0 ? t : e), e, r.createEmptyChangeSummary, r.handleChange);
}
function Wo(r) {
  const e = new q(), t = Z0({
    owner: void 0,
    debugName: void 0,
    debugReferenceFn: r
  }, (i) => {
    e.clear(), r(i, e);
  });
  return Se(() => {
    t.dispose(), e.dispose();
  });
}
class Y0 {
  get debugName() {
    var e;
    return (e = this._debugNameData.getDebugName(this)) !== null && e !== void 0 ? e : "(anonymous)";
  }
  constructor(e, t, i, n) {
    var s, o;
    this._debugNameData = e, this._runFn = t, this.createChangeSummary = i, this._handleChange = n, this.state = 2, this.updateCount = 0, this.disposed = !1, this.dependencies = /* @__PURE__ */ new Set(), this.dependenciesToBeRemoved = /* @__PURE__ */ new Set(), this.changeSummary = (s = this.createChangeSummary) === null || s === void 0 ? void 0 : s.call(this), (o = Za()) === null || o === void 0 || o.handleAutorunCreated(this), this._runIfNeeded();
  }
  dispose() {
    this.disposed = !0;
    for (const e of this.dependencies)
      e.removeObserver(this);
    this.dependencies.clear();
  }
  _runIfNeeded() {
    var e, t, i;
    if (this.state === 3)
      return;
    const n = this.dependenciesToBeRemoved;
    this.dependenciesToBeRemoved = this.dependencies, this.dependencies = n, this.state = 3;
    const s = this.disposed;
    try {
      if (!s) {
        (e = Za()) === null || e === void 0 || e.handleAutorunTriggered(this);
        const o = this.changeSummary;
        this.changeSummary = (t = this.createChangeSummary) === null || t === void 0 ? void 0 : t.call(this), this._runFn(this, o);
      }
    } finally {
      s || (i = Za()) === null || i === void 0 || i.handleAutorunFinished(this);
      for (const o of this.dependenciesToBeRemoved)
        o.removeObserver(this);
      this.dependenciesToBeRemoved.clear();
    }
  }
  toString() {
    return `Autorun<${this.debugName}>`;
  }
  // IObserver implementation
  beginUpdate() {
    this.state === 3 && (this.state = 1), this.updateCount++;
  }
  endUpdate() {
    if (this.updateCount === 1)
      do {
        if (this.state === 1) {
          this.state = 3;
          for (const e of this.dependencies)
            if (e.reportChanges(), this.state === 2)
              break;
        }
        this._runIfNeeded();
      } while (this.state !== 3);
    this.updateCount--, aH(() => this.updateCount >= 0);
  }
  handlePossibleChange(e) {
    this.state === 3 && this.dependencies.has(e) && !this.dependenciesToBeRemoved.has(e) && (this.state = 1);
  }
  handleChange(e, t) {
    this.dependencies.has(e) && !this.dependenciesToBeRemoved.has(e) && (!this._handleChange || this._handleChange({
      changedObservable: e,
      change: t,
      didChange: (n) => n === e
    }, this.changeSummary)) && (this.state = 2);
  }
  // IReader implementation
  readObservable(e) {
    if (this.disposed)
      return e.get();
    e.addObserver(this);
    const t = e.get();
    return this.dependencies.add(e), this.dependenciesToBeRemoved.delete(e), t;
  }
}
(function(r) {
  r.Observer = Y0;
})(qe || (qe = {}));
function Hr(r) {
  return new _ie(r);
}
class _ie extends wz {
  constructor(e) {
    super(), this.value = e;
  }
  get debugName() {
    return this.toString();
  }
  get() {
    return this.value;
  }
  addObserver(e) {
  }
  removeObserver(e) {
  }
  toString() {
    return `Const: ${this.value}`;
  }
}
function Lt(r, e) {
  return new Qh(r, e);
}
class Qh extends Db {
  constructor(e, t) {
    super(), this.event = e, this._getValue = t, this.hasValue = !1, this.handleEvent = (i) => {
      var n;
      const s = this._getValue(i), o = this.value, a = !this.hasValue || o !== s;
      let l = !1;
      a && (this.value = s, this.hasValue && (l = !0, dv(Qh.globalTransaction, (d) => {
        var c;
        (c = Za()) === null || c === void 0 || c.handleFromEventObservableTriggered(this, { oldValue: o, newValue: s, change: void 0, didChange: a, hadValue: this.hasValue });
        for (const h of this.observers)
          d.updateObserver(h, this), h.handleChange(this, void 0);
      }, () => {
        const d = this.getDebugName();
        return "Event fired" + (d ? `: ${d}` : "");
      })), this.hasValue = !0), l || (n = Za()) === null || n === void 0 || n.handleFromEventObservableTriggered(this, { oldValue: o, newValue: s, change: void 0, didChange: a, hadValue: this.hasValue });
    };
  }
  getDebugName() {
    return q0(this._getValue);
  }
  get debugName() {
    const e = this.getDebugName();
    return "From Event" + (e ? `: ${e}` : "");
  }
  onFirstObserverAdded() {
    this.subscription = this.event(this.handleEvent);
  }
  onLastObserverRemoved() {
    this.subscription.dispose(), this.subscription = void 0, this.hasValue = !1, this.value = void 0;
  }
  get() {
    return this.subscription ? (this.hasValue || this.handleEvent(void 0), this.value) : this._getValue(void 0);
  }
}
(function(r) {
  r.Observer = Qh;
  function e(t, i) {
    let n = !1;
    Qh.globalTransaction === void 0 && (Qh.globalTransaction = t, n = !0);
    try {
      i();
    } finally {
      n && (Qh.globalTransaction = void 0);
    }
  }
  r.batchEventsGlobally = e;
})(Lt || (Lt = {}));
function Mn(r, e) {
  return new vie(r, e);
}
class vie extends Db {
  constructor(e, t) {
    super(), this.debugName = e, this.event = t, this.handleEvent = () => {
      Nt((i) => {
        for (const n of this.observers)
          i.updateObserver(n, this), n.handleChange(this, void 0);
      }, () => this.debugName);
    };
  }
  onFirstObserverAdded() {
    this.subscription = this.event(this.handleEvent);
  }
  onLastObserverRemoved() {
    this.subscription.dispose(), this.subscription = void 0;
  }
  get() {
  }
}
function Q0(r) {
  return typeof r == "string" ? new JO(r) : new JO(void 0, r);
}
class JO extends Db {
  get debugName() {
    var e;
    return (e = new Ds(this._owner, this._debugName, void 0).getDebugName(this)) !== null && e !== void 0 ? e : "Observable Signal";
  }
  constructor(e, t) {
    super(), this._debugName = e, this._owner = t;
  }
  trigger(e, t) {
    if (!e) {
      Nt((i) => {
        this.trigger(i, t);
      }, () => `Trigger signal ${this.debugName}`);
      return;
    }
    for (const i of this.observers)
      e.updateObserver(i, this), i.handleChange(this, t);
  }
  get() {
  }
}
function xb(r, e) {
  const t = new bie(!0, e);
  return r.addObserver(t), e ? e(r.get()) : r.reportChanges(), Se(() => {
    r.removeObserver(t);
  });
}
cie(xb);
class bie {
  constructor(e, t) {
    this._forceRecompute = e, this._handleValue = t, this._counter = 0;
  }
  beginUpdate(e) {
    this._counter++;
  }
  endUpdate(e) {
    this._counter--, this._counter === 0 && this._forceRecompute && (this._handleValue ? this._handleValue(e.get()) : e.reportChanges());
  }
  handlePossibleChange(e) {
  }
  handleChange(e, t) {
  }
}
function Cie(r, e) {
  let t;
  return Pe(r, (n) => (t = e(n, t), t));
}
function wie(r, e, t, i) {
  let n = new eF(t, i);
  return Fl({
    debugReferenceFn: t,
    owner: r,
    onLastObserverRemoved: () => {
      n.dispose(), n = new eF(t);
    }
  }, (o) => (n.setItems(e.read(o)), n.getItems()));
}
class eF {
  constructor(e, t) {
    this._map = e, this._keySelector = t, this._cache = /* @__PURE__ */ new Map(), this._items = [];
  }
  dispose() {
    this._cache.forEach((e) => e.store.dispose()), this._cache.clear();
  }
  setItems(e) {
    const t = [], i = new Set(this._cache.keys());
    for (const n of e) {
      const s = this._keySelector ? this._keySelector(n) : n;
      let o = this._cache.get(s);
      if (o)
        i.delete(s);
      else {
        const a = new q();
        o = { out: this._map(n, a), store: a }, this._cache.set(s, o);
      }
      t.push(o.out);
    }
    for (const n of i)
      this._cache.get(n).store.dispose(), this._cache.delete(n);
    this._items = t;
  }
  getItems() {
    return this._items;
  }
}
function yz(r, e, t, i) {
  return e || (e = (n) => n != null), new Promise((n, s) => {
    let o = !0, a = !1;
    const l = r.map((c) => ({
      isFinished: e(c),
      error: t ? t(c) : !1,
      state: c
    })), d = qe((c) => {
      const { isFinished: h, error: u, state: g } = l.read(c);
      (h || u) && (o ? a = !0 : d.dispose(), u ? s(u === !0 ? g : u) : n(g));
    });
    if (i) {
      const c = i.onCancellationRequested(() => {
        d.dispose(), c.dispose(), s(new Ja());
      });
      if (i.isCancellationRequested) {
        d.dispose(), c.dispose(), s(new Ja());
        return;
      }
    }
    o = !1, a && d.dispose();
  });
}
var oh = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
};
class Sie {
  constructor(e) {
    this.trait = e, this.renderedElements = [];
  }
  get templateId() {
    return `template:${this.trait.name}`;
  }
  renderTemplate(e) {
    return e;
  }
  renderElement(e, t, i) {
    const n = this.renderedElements.findIndex((s) => s.templateData === i);
    if (n >= 0) {
      const s = this.renderedElements[n];
      this.trait.unrender(i), s.index = t;
    } else {
      const s = { index: t, templateData: i };
      this.renderedElements.push(s);
    }
    this.trait.renderIndex(t, i);
  }
  splice(e, t, i) {
    const n = [];
    for (const s of this.renderedElements)
      s.index < e ? n.push(s) : s.index >= e + t && n.push({
        index: s.index + i - t,
        templateData: s.templateData
      });
    this.renderedElements = n;
  }
  renderIndexes(e) {
    for (const { index: t, templateData: i } of this.renderedElements)
      e.indexOf(t) > -1 && this.trait.renderIndex(t, i);
  }
  disposeTemplate(e) {
    const t = this.renderedElements.findIndex((i) => i.templateData === e);
    t < 0 || this.renderedElements.splice(t, 1);
  }
}
let jS = class {
  get name() {
    return this._trait;
  }
  get renderer() {
    return new Sie(this);
  }
  constructor(e) {
    this._trait = e, this.indexes = [], this.sortedIndexes = [], this._onChange = new R(), this.onChange = this._onChange.event;
  }
  splice(e, t, i) {
    const n = i.length - t, s = e + t, o = [];
    let a = 0;
    for (; a < this.sortedIndexes.length && this.sortedIndexes[a] < e; )
      o.push(this.sortedIndexes[a++]);
    for (let l = 0; l < i.length; l++)
      i[l] && o.push(l + e);
    for (; a < this.sortedIndexes.length && this.sortedIndexes[a] >= s; )
      o.push(this.sortedIndexes[a++] + n);
    this.renderer.splice(e, t, i.length), this._set(o, o);
  }
  renderIndex(e, t) {
    t.classList.toggle(this._trait, this.contains(e));
  }
  unrender(e) {
    e.classList.remove(this._trait);
  }
  /**
   * Sets the indexes which should have this trait.
   *
   * @param indexes Indexes which should have this trait.
   * @return The old indexes which had this trait.
   */
  set(e, t) {
    return this._set(e, [...e].sort(iF), t);
  }
  _set(e, t, i) {
    const n = this.indexes, s = this.sortedIndexes;
    this.indexes = e, this.sortedIndexes = t;
    const o = jI(s, e);
    return this.renderer.renderIndexes(o), this._onChange.fire({ indexes: e, browserEvent: i }), n;
  }
  get() {
    return this.indexes;
  }
  contains(e) {
    return R_(this.sortedIndexes, e, iF) >= 0;
  }
  dispose() {
    zt(this._onChange);
  }
};
oh([
  ki
], jS.prototype, "renderer", null);
class yie extends jS {
  constructor(e) {
    super("selected"), this.setAriaSelected = e;
  }
  renderIndex(e, t) {
    super.renderIndex(e, t), this.setAriaSelected && (this.contains(e) ? t.setAttribute("aria-selected", "true") : t.setAttribute("aria-selected", "false"));
  }
}
class Lk {
  constructor(e, t, i) {
    this.trait = e, this.view = t, this.identityProvider = i;
  }
  splice(e, t, i) {
    if (!this.identityProvider)
      return this.trait.splice(e, t, new Array(i.length).fill(!1));
    const n = this.trait.get().map((a) => this.identityProvider.getId(this.view.element(a)).toString());
    if (n.length === 0)
      return this.trait.splice(e, t, new Array(i.length).fill(!1));
    const s = new Set(n), o = i.map((a) => s.has(this.identityProvider.getId(a).toString()));
    this.trait.splice(e, t, o);
  }
}
function bc(r) {
  return r.tagName === "INPUT" || r.tagName === "TEXTAREA";
}
function Ib(r, e) {
  return r.classList.contains(e) ? !0 : r.classList.contains("monaco-list") || !r.parentElement ? !1 : Ib(r.parentElement, e);
}
function Bm(r) {
  return Ib(r, "monaco-editor");
}
function Lie(r) {
  return Ib(r, "monaco-custom-toggle");
}
function Die(r) {
  return Ib(r, "action-item");
}
function v_(r) {
  return Ib(r, "monaco-tree-sticky-row");
}
function hv(r) {
  return r.classList.contains("monaco-tree-sticky-container");
}
function Lz(r) {
  return r.tagName === "A" && r.classList.contains("monaco-button") || r.tagName === "DIV" && r.classList.contains("monaco-button-dropdown") ? !0 : r.classList.contains("monaco-list") || !r.parentElement ? !1 : Lz(r.parentElement);
}
class Dz {
  get onKeyDown() {
    return ne.chain(this.disposables.add(new tt(this.view.domNode, "keydown")).event, (e) => e.filter((t) => !bc(t.target)).map((t) => new Mt(t)));
  }
  constructor(e, t, i) {
    this.list = e, this.view = t, this.disposables = new q(), this.multipleSelectionDisposables = new q(), this.multipleSelectionSupport = i.multipleSelectionSupport, this.disposables.add(this.onKeyDown((n) => {
      switch (n.keyCode) {
        case 3:
          return this.onEnter(n);
        case 16:
          return this.onUpArrow(n);
        case 18:
          return this.onDownArrow(n);
        case 11:
          return this.onPageUpArrow(n);
        case 12:
          return this.onPageDownArrow(n);
        case 9:
          return this.onEscape(n);
        case 31:
          this.multipleSelectionSupport && (Je ? n.metaKey : n.ctrlKey) && this.onCtrlA(n);
      }
    }));
  }
  updateOptions(e) {
    e.multipleSelectionSupport !== void 0 && (this.multipleSelectionSupport = e.multipleSelectionSupport);
  }
  onEnter(e) {
    e.preventDefault(), e.stopPropagation(), this.list.setSelection(this.list.getFocus(), e.browserEvent);
  }
  onUpArrow(e) {
    e.preventDefault(), e.stopPropagation(), this.list.focusPrevious(1, !1, e.browserEvent);
    const t = this.list.getFocus()[0];
    this.list.setAnchor(t), this.list.reveal(t), this.view.domNode.focus();
  }
  onDownArrow(e) {
    e.preventDefault(), e.stopPropagation(), this.list.focusNext(1, !1, e.browserEvent);
    const t = this.list.getFocus()[0];
    this.list.setAnchor(t), this.list.reveal(t), this.view.domNode.focus();
  }
  onPageUpArrow(e) {
    e.preventDefault(), e.stopPropagation(), this.list.focusPreviousPage(e.browserEvent);
    const t = this.list.getFocus()[0];
    this.list.setAnchor(t), this.list.reveal(t), this.view.domNode.focus();
  }
  onPageDownArrow(e) {
    e.preventDefault(), e.stopPropagation(), this.list.focusNextPage(e.browserEvent);
    const t = this.list.getFocus()[0];
    this.list.setAnchor(t), this.list.reveal(t), this.view.domNode.focus();
  }
  onCtrlA(e) {
    e.preventDefault(), e.stopPropagation(), this.list.setSelection(_s(this.list.length), e.browserEvent), this.list.setAnchor(void 0), this.view.domNode.focus();
  }
  onEscape(e) {
    this.list.getSelection().length && (e.preventDefault(), e.stopPropagation(), this.list.setSelection([], e.browserEvent), this.list.setAnchor(void 0), this.view.domNode.focus());
  }
  dispose() {
    this.disposables.dispose(), this.multipleSelectionDisposables.dispose();
  }
}
oh([
  ki
], Dz.prototype, "onKeyDown", null);
var Oa;
(function(r) {
  r[r.Automatic = 0] = "Automatic", r[r.Trigger = 1] = "Trigger";
})(Oa || (Oa = {}));
var nf;
(function(r) {
  r[r.Idle = 0] = "Idle", r[r.Typing = 1] = "Typing";
})(nf || (nf = {}));
const kie = new class {
  mightProducePrintableCharacter(r) {
    return r.ctrlKey || r.metaKey || r.altKey ? !1 : r.keyCode >= 31 && r.keyCode <= 56 || r.keyCode >= 21 && r.keyCode <= 30 || r.keyCode >= 98 && r.keyCode <= 107 || r.keyCode >= 85 && r.keyCode <= 95;
  }
}();
class xie {
  constructor(e, t, i, n, s) {
    this.list = e, this.view = t, this.keyboardNavigationLabelProvider = i, this.keyboardNavigationEventFilter = n, this.delegate = s, this.enabled = !1, this.state = nf.Idle, this.mode = Oa.Automatic, this.triggered = !1, this.previouslyFocused = -1, this.enabledDisposables = new q(), this.disposables = new q(), this.updateOptions(e.options);
  }
  updateOptions(e) {
    var t, i;
    !((t = e.typeNavigationEnabled) !== null && t !== void 0) || t ? this.enable() : this.disable(), this.mode = (i = e.typeNavigationMode) !== null && i !== void 0 ? i : Oa.Automatic;
  }
  enable() {
    if (this.enabled)
      return;
    let e = !1;
    const t = ne.chain(this.enabledDisposables.add(new tt(this.view.domNode, "keydown")).event, (s) => s.filter((o) => !bc(o.target)).filter(() => this.mode === Oa.Automatic || this.triggered).map((o) => new Mt(o)).filter((o) => e || this.keyboardNavigationEventFilter(o)).filter((o) => this.delegate.mightProducePrintableCharacter(o)).forEach((o) => nt.stop(o, !0)).map((o) => o.browserEvent.key)), i = ne.debounce(t, () => null, 800, void 0, void 0, void 0, this.enabledDisposables);
    ne.reduce(ne.any(t, i), (s, o) => o === null ? null : (s || "") + o, void 0, this.enabledDisposables)(this.onInput, this, this.enabledDisposables), i(this.onClear, this, this.enabledDisposables), t(() => e = !0, void 0, this.enabledDisposables), i(() => e = !1, void 0, this.enabledDisposables), this.enabled = !0, this.triggered = !1;
  }
  disable() {
    this.enabled && (this.enabledDisposables.clear(), this.enabled = !1, this.triggered = !1);
  }
  onClear() {
    var e;
    const t = this.list.getFocus();
    if (t.length > 0 && t[0] === this.previouslyFocused) {
      const i = (e = this.list.options.accessibilityProvider) === null || e === void 0 ? void 0 : e.getAriaLabel(this.list.element(t[0]));
      typeof i == "string" ? Ls(i) : i && Ls(i.get());
    }
    this.previouslyFocused = -1;
  }
  onInput(e) {
    if (!e) {
      this.state = nf.Idle, this.triggered = !1;
      return;
    }
    const t = this.list.getFocus(), i = t.length > 0 ? t[0] : 0, n = this.state === nf.Idle ? 1 : 0;
    this.state = nf.Typing;
    for (let s = 0; s < this.list.length; s++) {
      const o = (i + s + n) % this.list.length, a = this.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(this.view.element(o)), l = a && a.toString();
      if (this.list.options.typeNavigationEnabled) {
        if (typeof l < "u") {
          if (iv(e, l)) {
            this.previouslyFocused = i, this.list.setFocus([o]), this.list.reveal(o);
            return;
          }
          const d = ree(e, l);
          if (d && d[0].end - d[0].start > 1 && d.length === 1) {
            this.previouslyFocused = i, this.list.setFocus([o]), this.list.reveal(o);
            return;
          }
        }
      } else if (typeof l > "u" || iv(e, l)) {
        this.previouslyFocused = i, this.list.setFocus([o]), this.list.reveal(o);
        return;
      }
    }
  }
  dispose() {
    this.disable(), this.enabledDisposables.dispose(), this.disposables.dispose();
  }
}
class Iie {
  constructor(e, t) {
    this.list = e, this.view = t, this.disposables = new q();
    const i = ne.chain(this.disposables.add(new tt(t.domNode, "keydown")).event, (s) => s.filter((o) => !bc(o.target)).map((o) => new Mt(o)));
    ne.chain(i, (s) => s.filter((o) => o.keyCode === 2 && !o.ctrlKey && !o.metaKey && !o.shiftKey && !o.altKey))(this.onTab, this, this.disposables);
  }
  onTab(e) {
    if (e.target !== this.view.domNode)
      return;
    const t = this.list.getFocus();
    if (t.length === 0)
      return;
    const i = this.view.domElement(t[0]);
    if (!i)
      return;
    const n = i.querySelector("[tabIndex]");
    if (!n || !ln(n) || n.tabIndex === -1)
      return;
    const s = we(n).getComputedStyle(n);
    s.visibility === "hidden" || s.display === "none" || (e.preventDefault(), e.stopPropagation(), n.focus());
  }
  dispose() {
    this.disposables.dispose();
  }
}
function kz(r) {
  return Je ? r.browserEvent.metaKey : r.browserEvent.ctrlKey;
}
function xz(r) {
  return r.browserEvent.shiftKey;
}
function Eie(r) {
  return o1(r) && r.button === 2;
}
const tF = {
  isSelectionSingleChangeEvent: kz,
  isSelectionRangeChangeEvent: xz
};
class Iz {
  constructor(e) {
    this.list = e, this.disposables = new q(), this._onPointer = new R(), this.onPointer = this._onPointer.event, e.options.multipleSelectionSupport !== !1 && (this.multipleSelectionController = this.list.options.multipleSelectionController || tF), this.mouseSupport = typeof e.options.mouseSupport > "u" || !!e.options.mouseSupport, this.mouseSupport && (e.onMouseDown(this.onMouseDown, this, this.disposables), e.onContextMenu(this.onContextMenu, this, this.disposables), e.onMouseDblClick(this.onDoubleClick, this, this.disposables), e.onTouchStart(this.onMouseDown, this, this.disposables), this.disposables.add(At.addTarget(e.getHTMLElement()))), ne.any(e.onMouseClick, e.onMouseMiddleClick, e.onTap)(this.onViewPointer, this, this.disposables);
  }
  updateOptions(e) {
    e.multipleSelectionSupport !== void 0 && (this.multipleSelectionController = void 0, e.multipleSelectionSupport && (this.multipleSelectionController = this.list.options.multipleSelectionController || tF));
  }
  isSelectionSingleChangeEvent(e) {
    return this.multipleSelectionController ? this.multipleSelectionController.isSelectionSingleChangeEvent(e) : !1;
  }
  isSelectionRangeChangeEvent(e) {
    return this.multipleSelectionController ? this.multipleSelectionController.isSelectionRangeChangeEvent(e) : !1;
  }
  isSelectionChangeEvent(e) {
    return this.isSelectionSingleChangeEvent(e) || this.isSelectionRangeChangeEvent(e);
  }
  onMouseDown(e) {
    Bm(e.browserEvent.target) || Ln() !== e.browserEvent.target && this.list.domFocus();
  }
  onContextMenu(e) {
    if (bc(e.browserEvent.target) || Bm(e.browserEvent.target))
      return;
    const t = typeof e.index > "u" ? [] : [e.index];
    this.list.setFocus(t, e.browserEvent);
  }
  onViewPointer(e) {
    if (!this.mouseSupport || bc(e.browserEvent.target) || Bm(e.browserEvent.target) || e.browserEvent.isHandledByList)
      return;
    e.browserEvent.isHandledByList = !0;
    const t = e.index;
    if (typeof t > "u") {
      this.list.setFocus([], e.browserEvent), this.list.setSelection([], e.browserEvent), this.list.setAnchor(void 0);
      return;
    }
    if (this.isSelectionChangeEvent(e))
      return this.changeSelection(e);
    this.list.setFocus([t], e.browserEvent), this.list.setAnchor(t), Eie(e.browserEvent) || this.list.setSelection([t], e.browserEvent), this._onPointer.fire(e);
  }
  onDoubleClick(e) {
    if (bc(e.browserEvent.target) || Bm(e.browserEvent.target) || this.isSelectionChangeEvent(e) || e.browserEvent.isHandledByList)
      return;
    e.browserEvent.isHandledByList = !0;
    const t = this.list.getFocus();
    this.list.setSelection(t, e.browserEvent);
  }
  changeSelection(e) {
    const t = e.index;
    let i = this.list.getAnchor();
    if (this.isSelectionRangeChangeEvent(e)) {
      if (typeof i > "u") {
        const c = this.list.getFocus()[0];
        i = c ?? t, this.list.setAnchor(i);
      }
      const n = Math.min(i, t), s = Math.max(i, t), o = _s(n, s + 1), a = this.list.getSelection(), l = Mie(jI(a, [i]), i);
      if (l.length === 0)
        return;
      const d = jI(o, Rie(a, l));
      this.list.setSelection(d, e.browserEvent), this.list.setFocus([t], e.browserEvent);
    } else if (this.isSelectionSingleChangeEvent(e)) {
      const n = this.list.getSelection(), s = n.filter((o) => o !== t);
      this.list.setFocus([t]), this.list.setAnchor(t), n.length === s.length ? this.list.setSelection([...s, t], e.browserEvent) : this.list.setSelection(s, e.browserEvent);
    }
  }
  dispose() {
    this.disposables.dispose();
  }
}
class Ez {
  constructor(e, t) {
    this.styleElement = e, this.selectorSuffix = t;
  }
  style(e) {
    var t, i;
    const n = this.selectorSuffix && `.${this.selectorSuffix}`, s = [];
    e.listBackground && s.push(`.monaco-list${n} .monaco-list-rows { background: ${e.listBackground}; }`), e.listFocusBackground && (s.push(`.monaco-list${n}:focus .monaco-list-row.focused { background-color: ${e.listFocusBackground}; }`), s.push(`.monaco-list${n}:focus .monaco-list-row.focused:hover { background-color: ${e.listFocusBackground}; }`)), e.listFocusForeground && s.push(`.monaco-list${n}:focus .monaco-list-row.focused { color: ${e.listFocusForeground}; }`), e.listActiveSelectionBackground && (s.push(`.monaco-list${n}:focus .monaco-list-row.selected { background-color: ${e.listActiveSelectionBackground}; }`), s.push(`.monaco-list${n}:focus .monaco-list-row.selected:hover { background-color: ${e.listActiveSelectionBackground}; }`)), e.listActiveSelectionForeground && s.push(`.monaco-list${n}:focus .monaco-list-row.selected { color: ${e.listActiveSelectionForeground}; }`), e.listActiveSelectionIconForeground && s.push(`.monaco-list${n}:focus .monaco-list-row.selected .codicon { color: ${e.listActiveSelectionIconForeground}; }`), e.listFocusAndSelectionBackground && s.push(`
				.monaco-drag-image,
				.monaco-list${n}:focus .monaco-list-row.selected.focused { background-color: ${e.listFocusAndSelectionBackground}; }
			`), e.listFocusAndSelectionForeground && s.push(`
				.monaco-drag-image,
				.monaco-list${n}:focus .monaco-list-row.selected.focused { color: ${e.listFocusAndSelectionForeground}; }
			`), e.listInactiveFocusForeground && (s.push(`.monaco-list${n} .monaco-list-row.focused { color:  ${e.listInactiveFocusForeground}; }`), s.push(`.monaco-list${n} .monaco-list-row.focused:hover { color:  ${e.listInactiveFocusForeground}; }`)), e.listInactiveSelectionIconForeground && s.push(`.monaco-list${n} .monaco-list-row.focused .codicon { color:  ${e.listInactiveSelectionIconForeground}; }`), e.listInactiveFocusBackground && (s.push(`.monaco-list${n} .monaco-list-row.focused { background-color:  ${e.listInactiveFocusBackground}; }`), s.push(`.monaco-list${n} .monaco-list-row.focused:hover { background-color:  ${e.listInactiveFocusBackground}; }`)), e.listInactiveSelectionBackground && (s.push(`.monaco-list${n} .monaco-list-row.selected { background-color:  ${e.listInactiveSelectionBackground}; }`), s.push(`.monaco-list${n} .monaco-list-row.selected:hover { background-color:  ${e.listInactiveSelectionBackground}; }`)), e.listInactiveSelectionForeground && s.push(`.monaco-list${n} .monaco-list-row.selected { color: ${e.listInactiveSelectionForeground}; }`), e.listHoverBackground && s.push(`.monaco-list${n}:not(.drop-target):not(.dragging) .monaco-list-row:hover:not(.selected):not(.focused) { background-color: ${e.listHoverBackground}; }`), e.listHoverForeground && s.push(`.monaco-list${n}:not(.drop-target):not(.dragging) .monaco-list-row:hover:not(.selected):not(.focused) { color:  ${e.listHoverForeground}; }`);
    const o = ed(e.listFocusAndSelectionOutline, ed(e.listSelectionOutline, (t = e.listFocusOutline) !== null && t !== void 0 ? t : ""));
    o && s.push(`.monaco-list${n}:focus .monaco-list-row.focused.selected { outline: 1px solid ${o}; outline-offset: -1px;}`), e.listFocusOutline && s.push(`
				.monaco-drag-image,
				.monaco-list${n}:focus .monaco-list-row.focused { outline: 1px solid ${e.listFocusOutline}; outline-offset: -1px; }
				.monaco-workbench.context-menu-visible .monaco-list${n}.last-focused .monaco-list-row.focused { outline: 1px solid ${e.listFocusOutline}; outline-offset: -1px; }
			`);
    const a = ed(e.listSelectionOutline, (i = e.listInactiveFocusOutline) !== null && i !== void 0 ? i : "");
    a && s.push(`.monaco-list${n} .monaco-list-row.focused.selected { outline: 1px dotted ${a}; outline-offset: -1px; }`), e.listSelectionOutline && s.push(`.monaco-list${n} .monaco-list-row.selected { outline: 1px dotted ${e.listSelectionOutline}; outline-offset: -1px; }`), e.listInactiveFocusOutline && s.push(`.monaco-list${n} .monaco-list-row.focused { outline: 1px dotted ${e.listInactiveFocusOutline}; outline-offset: -1px; }`), e.listHoverOutline && s.push(`.monaco-list${n} .monaco-list-row:hover { outline: 1px dashed ${e.listHoverOutline}; outline-offset: -1px; }`), e.listDropOverBackground && s.push(`
				.monaco-list${n}.drop-target,
				.monaco-list${n} .monaco-list-rows.drop-target,
				.monaco-list${n} .monaco-list-row.drop-target { background-color: ${e.listDropOverBackground} !important; color: inherit !important; }
			`), e.listDropBetweenBackground && (s.push(`
			.monaco-list${n} .monaco-list-rows.drop-target-before .monaco-list-row:first-child::before,
			.monaco-list${n} .monaco-list-row.drop-target-before::before {
				content: ""; position: absolute; top: 0px; left: 0px; width: 100%; height: 1px;
				background-color: ${e.listDropBetweenBackground};
			}`), s.push(`
			.monaco-list${n} .monaco-list-rows.drop-target-after .monaco-list-row:last-child::after,
			.monaco-list${n} .monaco-list-row.drop-target-after::after {
				content: ""; position: absolute; bottom: 0px; left: 0px; width: 100%; height: 1px;
				background-color: ${e.listDropBetweenBackground};
			}`)), e.tableColumnsBorder && s.push(`
				.monaco-table > .monaco-split-view2,
				.monaco-table > .monaco-split-view2 .monaco-sash.vertical::before,
				.monaco-workbench:not(.reduce-motion) .monaco-table:hover > .monaco-split-view2,
				.monaco-workbench:not(.reduce-motion) .monaco-table:hover > .monaco-split-view2 .monaco-sash.vertical::before {
					border-color: ${e.tableColumnsBorder};
				}

				.monaco-workbench:not(.reduce-motion) .monaco-table > .monaco-split-view2,
				.monaco-workbench:not(.reduce-motion) .monaco-table > .monaco-split-view2 .monaco-sash.vertical::before {
					border-color: transparent;
				}
			`), e.tableOddRowsBackgroundColor && s.push(`
				.monaco-table .monaco-list-row[data-parity=odd]:not(.focused):not(.selected):not(:hover) .monaco-table-tr,
				.monaco-table .monaco-list:not(:focus) .monaco-list-row[data-parity=odd].focused:not(.selected):not(:hover) .monaco-table-tr,
				.monaco-table .monaco-list:not(.focused) .monaco-list-row[data-parity=odd].focused:not(.selected):not(:hover) .monaco-table-tr {
					background-color: ${e.tableOddRowsBackgroundColor};
				}
			`), this.styleElement.textContent = s.join(`
`);
  }
}
const Tie = {
  listFocusBackground: "#7FB0D0",
  listActiveSelectionBackground: "#0E639C",
  listActiveSelectionForeground: "#FFFFFF",
  listActiveSelectionIconForeground: "#FFFFFF",
  listFocusAndSelectionOutline: "#90C2F9",
  listFocusAndSelectionBackground: "#094771",
  listFocusAndSelectionForeground: "#FFFFFF",
  listInactiveSelectionBackground: "#3F3F46",
  listInactiveSelectionIconForeground: "#FFFFFF",
  listHoverBackground: "#2A2D2E",
  listDropOverBackground: "#383B3D",
  listDropBetweenBackground: "#EEEEEE",
  treeIndentGuidesStroke: "#a9a9a9",
  treeInactiveIndentGuidesStroke: z.fromHex("#a9a9a9").transparent(0.4).toString(),
  tableColumnsBorder: z.fromHex("#cccccc").transparent(0.2).toString(),
  tableOddRowsBackgroundColor: z.fromHex("#cccccc").transparent(0.04).toString(),
  listBackground: void 0,
  listFocusForeground: void 0,
  listInactiveSelectionForeground: void 0,
  listInactiveFocusForeground: void 0,
  listInactiveFocusBackground: void 0,
  listHoverForeground: void 0,
  listFocusOutline: void 0,
  listInactiveFocusOutline: void 0,
  listSelectionOutline: void 0,
  listHoverOutline: void 0,
  treeStickyScrollBackground: void 0,
  treeStickyScrollBorder: void 0,
  treeStickyScrollShadow: void 0
}, Nie = {
  keyboardSupport: !0,
  mouseSupport: !0,
  multipleSelectionSupport: !0,
  dnd: {
    getDragURI() {
      return null;
    },
    onDragStart() {
    },
    onDragOver() {
      return !1;
    },
    drop() {
    },
    dispose() {
    }
  }
};
function Mie(r, e) {
  const t = r.indexOf(e);
  if (t === -1)
    return [];
  const i = [];
  let n = t - 1;
  for (; n >= 0 && r[n] === e - (t - n); )
    i.push(r[n--]);
  for (i.reverse(), n = t; n < r.length && r[n] === e + (n - t); )
    i.push(r[n++]);
  return i;
}
function jI(r, e) {
  const t = [];
  let i = 0, n = 0;
  for (; i < r.length || n < e.length; )
    if (i >= r.length)
      t.push(e[n++]);
    else if (n >= e.length)
      t.push(r[i++]);
    else if (r[i] === e[n]) {
      t.push(r[i]), i++, n++;
      continue;
    } else r[i] < e[n] ? t.push(r[i++]) : t.push(e[n++]);
  return t;
}
function Rie(r, e) {
  const t = [];
  let i = 0, n = 0;
  for (; i < r.length || n < e.length; )
    if (i >= r.length)
      t.push(e[n++]);
    else if (n >= e.length)
      t.push(r[i++]);
    else if (r[i] === e[n]) {
      i++, n++;
      continue;
    } else r[i] < e[n] ? t.push(r[i++]) : n++;
  return t;
}
const iF = (r, e) => r - e;
class Aie {
  constructor(e, t) {
    this._templateId = e, this.renderers = t;
  }
  get templateId() {
    return this._templateId;
  }
  renderTemplate(e) {
    return this.renderers.map((t) => t.renderTemplate(e));
  }
  renderElement(e, t, i, n) {
    let s = 0;
    for (const o of this.renderers)
      o.renderElement(e, t, i[s++], n);
  }
  disposeElement(e, t, i, n) {
    var s;
    let o = 0;
    for (const a of this.renderers)
      (s = a.disposeElement) === null || s === void 0 || s.call(a, e, t, i[o], n), o += 1;
  }
  disposeTemplate(e) {
    let t = 0;
    for (const i of this.renderers)
      i.disposeTemplate(e[t++]);
  }
}
class Pie {
  constructor(e) {
    this.accessibilityProvider = e, this.templateId = "a18n";
  }
  renderTemplate(e) {
    return { container: e, disposables: new q() };
  }
  renderElement(e, t, i) {
    const n = this.accessibilityProvider.getAriaLabel(e), s = n && typeof n != "string" ? n : Hr(n);
    i.disposables.add(qe((a) => {
      this.setAriaLabel(a.readObservable(s), i.container);
    }));
    const o = this.accessibilityProvider.getAriaLevel && this.accessibilityProvider.getAriaLevel(e);
    typeof o == "number" ? i.container.setAttribute("aria-level", `${o}`) : i.container.removeAttribute("aria-level");
  }
  setAriaLabel(e, t) {
    e ? t.setAttribute("aria-label", e) : t.removeAttribute("aria-label");
  }
  disposeElement(e, t, i, n) {
    i.disposables.clear();
  }
  disposeTemplate(e) {
    e.disposables.dispose();
  }
}
class Oie {
  constructor(e, t) {
    this.list = e, this.dnd = t;
  }
  getDragElements(e) {
    const t = this.list.getSelectedElements();
    return t.indexOf(e) > -1 ? t : [e];
  }
  getDragURI(e) {
    return this.dnd.getDragURI(e);
  }
  getDragLabel(e, t) {
    if (this.dnd.getDragLabel)
      return this.dnd.getDragLabel(e, t);
  }
  onDragStart(e, t) {
    var i, n;
    (n = (i = this.dnd).onDragStart) === null || n === void 0 || n.call(i, e, t);
  }
  onDragOver(e, t, i, n, s) {
    return this.dnd.onDragOver(e, t, i, n, s);
  }
  onDragLeave(e, t, i, n) {
    var s, o;
    (o = (s = this.dnd).onDragLeave) === null || o === void 0 || o.call(s, e, t, i, n);
  }
  onDragEnd(e) {
    var t, i;
    (i = (t = this.dnd).onDragEnd) === null || i === void 0 || i.call(t, e);
  }
  drop(e, t, i, n, s) {
    this.dnd.drop(e, t, i, n, s);
  }
  dispose() {
    this.dnd.dispose();
  }
}
class Co {
  get onDidChangeFocus() {
    return ne.map(this.eventBufferer.wrapEvent(this.focus.onChange), (e) => this.toListEvent(e), this.disposables);
  }
  get onDidChangeSelection() {
    return ne.map(this.eventBufferer.wrapEvent(this.selection.onChange), (e) => this.toListEvent(e), this.disposables);
  }
  get domId() {
    return this.view.domId;
  }
  get onDidScroll() {
    return this.view.onDidScroll;
  }
  get onMouseClick() {
    return this.view.onMouseClick;
  }
  get onMouseDblClick() {
    return this.view.onMouseDblClick;
  }
  get onMouseMiddleClick() {
    return this.view.onMouseMiddleClick;
  }
  get onPointer() {
    return this.mouseController.onPointer;
  }
  get onMouseDown() {
    return this.view.onMouseDown;
  }
  get onMouseOver() {
    return this.view.onMouseOver;
  }
  get onMouseOut() {
    return this.view.onMouseOut;
  }
  get onTouchStart() {
    return this.view.onTouchStart;
  }
  get onTap() {
    return this.view.onTap;
  }
  /**
   * Possible context menu trigger events:
   * - ContextMenu key
   * - Shift F10
   * - Ctrl Option Shift M (macOS with VoiceOver)
   * - Mouse right click
   */
  get onContextMenu() {
    let e = !1;
    const t = ne.chain(this.disposables.add(new tt(this.view.domNode, "keydown")).event, (s) => s.map((o) => new Mt(o)).filter((o) => e = o.keyCode === 58 || o.shiftKey && o.keyCode === 68).map((o) => nt.stop(o, !0)).filter(() => !1)), i = ne.chain(this.disposables.add(new tt(this.view.domNode, "keyup")).event, (s) => s.forEach(() => e = !1).map((o) => new Mt(o)).filter((o) => o.keyCode === 58 || o.shiftKey && o.keyCode === 68).map((o) => nt.stop(o, !0)).map(({ browserEvent: o }) => {
      const a = this.getFocus(), l = a.length ? a[0] : void 0, d = typeof l < "u" ? this.view.element(l) : void 0, c = typeof l < "u" ? this.view.domElement(l) : this.view.domNode;
      return { index: l, element: d, anchor: c, browserEvent: o };
    })), n = ne.chain(this.view.onContextMenu, (s) => s.filter((o) => !e).map(({ element: o, index: a, browserEvent: l }) => ({ element: o, index: a, anchor: new rr(we(this.view.domNode), l), browserEvent: l })));
    return ne.any(t, i, n);
  }
  get onKeyDown() {
    return this.disposables.add(new tt(this.view.domNode, "keydown")).event;
  }
  get onDidFocus() {
    return ne.signal(this.disposables.add(new tt(this.view.domNode, "focus", !0)).event);
  }
  get onDidBlur() {
    return ne.signal(this.disposables.add(new tt(this.view.domNode, "blur", !0)).event);
  }
  constructor(e, t, i, n, s = Nie) {
    var o, a, l, d;
    this.user = e, this._options = s, this.focus = new jS("focused"), this.anchor = new jS("anchor"), this.eventBufferer = new n0(), this._ariaLabel = "", this.disposables = new q(), this._onDidDispose = new R(), this.onDidDispose = this._onDidDispose.event;
    const c = this._options.accessibilityProvider && this._options.accessibilityProvider.getWidgetRole ? (o = this._options.accessibilityProvider) === null || o === void 0 ? void 0 : o.getWidgetRole() : "list";
    this.selection = new yie(c !== "listbox");
    const h = [this.focus.renderer, this.selection.renderer];
    this.accessibilityProvider = s.accessibilityProvider, this.accessibilityProvider && (h.push(new Pie(this.accessibilityProvider)), (l = (a = this.accessibilityProvider).onDidChangeActiveDescendant) === null || l === void 0 || l.call(a, this.onDidChangeActiveDescendant, this, this.disposables)), n = n.map((g) => new Aie(g.templateId, [...h, g]));
    const u = {
      ...s,
      dnd: s.dnd && new Oie(this, s.dnd)
    };
    if (this.view = this.createListView(t, i, n, u), this.view.domNode.setAttribute("role", c), s.styleController)
      this.styleController = s.styleController(this.view.domId);
    else {
      const g = fo(this.view.domNode);
      this.styleController = new Ez(g, this.view.domId);
    }
    if (this.spliceable = new qte([
      new Lk(this.focus, this.view, s.identityProvider),
      new Lk(this.selection, this.view, s.identityProvider),
      new Lk(this.anchor, this.view, s.identityProvider),
      this.view
    ]), this.disposables.add(this.focus), this.disposables.add(this.selection), this.disposables.add(this.anchor), this.disposables.add(this.view), this.disposables.add(this._onDidDispose), this.disposables.add(new Iie(this, this.view)), (typeof s.keyboardSupport != "boolean" || s.keyboardSupport) && (this.keyboardController = new Dz(this, this.view, s), this.disposables.add(this.keyboardController)), s.keyboardNavigationLabelProvider) {
      const g = s.keyboardNavigationDelegate || kie;
      this.typeNavigationController = new xie(this, this.view, s.keyboardNavigationLabelProvider, (d = s.keyboardNavigationEventFilter) !== null && d !== void 0 ? d : () => !0, g), this.disposables.add(this.typeNavigationController);
    }
    this.mouseController = this.createMouseController(s), this.disposables.add(this.mouseController), this.onDidChangeFocus(this._onFocusChange, this, this.disposables), this.onDidChangeSelection(this._onSelectionChange, this, this.disposables), this.accessibilityProvider && (this.ariaLabel = this.accessibilityProvider.getWidgetAriaLabel()), this._options.multipleSelectionSupport !== !1 && this.view.domNode.setAttribute("aria-multiselectable", "true");
  }
  createListView(e, t, i, n) {
    return new zo(e, t, i, n);
  }
  createMouseController(e) {
    return new Iz(this);
  }
  updateOptions(e = {}) {
    var t, i;
    this._options = { ...this._options, ...e }, (t = this.typeNavigationController) === null || t === void 0 || t.updateOptions(this._options), this._options.multipleSelectionController !== void 0 && (this._options.multipleSelectionSupport ? this.view.domNode.setAttribute("aria-multiselectable", "true") : this.view.domNode.removeAttribute("aria-multiselectable")), this.mouseController.updateOptions(e), (i = this.keyboardController) === null || i === void 0 || i.updateOptions(e), this.view.updateOptions(e);
  }
  get options() {
    return this._options;
  }
  splice(e, t, i = []) {
    if (e < 0 || e > this.view.length)
      throw new Sh(this.user, `Invalid start index: ${e}`);
    if (t < 0)
      throw new Sh(this.user, `Invalid delete count: ${t}`);
    t === 0 && i.length === 0 || this.eventBufferer.bufferEvents(() => this.spliceable.splice(e, t, i));
  }
  rerender() {
    this.view.rerender();
  }
  element(e) {
    return this.view.element(e);
  }
  indexOf(e) {
    return this.view.indexOf(e);
  }
  indexAt(e) {
    return this.view.indexAt(e);
  }
  get length() {
    return this.view.length;
  }
  get contentHeight() {
    return this.view.contentHeight;
  }
  get onDidChangeContentHeight() {
    return this.view.onDidChangeContentHeight;
  }
  get scrollTop() {
    return this.view.getScrollTop();
  }
  set scrollTop(e) {
    this.view.setScrollTop(e);
  }
  get scrollHeight() {
    return this.view.scrollHeight;
  }
  get renderHeight() {
    return this.view.renderHeight;
  }
  get firstVisibleIndex() {
    return this.view.firstVisibleIndex;
  }
  get ariaLabel() {
    return this._ariaLabel;
  }
  set ariaLabel(e) {
    this._ariaLabel = e, this.view.domNode.setAttribute("aria-label", e);
  }
  domFocus() {
    this.view.domNode.focus({ preventScroll: !0 });
  }
  layout(e, t) {
    this.view.layout(e, t);
  }
  setSelection(e, t) {
    for (const i of e)
      if (i < 0 || i >= this.length)
        throw new Sh(this.user, `Invalid index ${i}`);
    this.selection.set(e, t);
  }
  getSelection() {
    return this.selection.get();
  }
  getSelectedElements() {
    return this.getSelection().map((e) => this.view.element(e));
  }
  setAnchor(e) {
    if (typeof e > "u") {
      this.anchor.set([]);
      return;
    }
    if (e < 0 || e >= this.length)
      throw new Sh(this.user, `Invalid index ${e}`);
    this.anchor.set([e]);
  }
  getAnchor() {
    return qN(this.anchor.get(), void 0);
  }
  getAnchorElement() {
    const e = this.getAnchor();
    return typeof e > "u" ? void 0 : this.element(e);
  }
  setFocus(e, t) {
    for (const i of e)
      if (i < 0 || i >= this.length)
        throw new Sh(this.user, `Invalid index ${i}`);
    this.focus.set(e, t);
  }
  focusNext(e = 1, t = !1, i, n) {
    if (this.length === 0)
      return;
    const s = this.focus.get(), o = this.findNextIndex(s.length > 0 ? s[0] + e : 0, t, n);
    o > -1 && this.setFocus([o], i);
  }
  focusPrevious(e = 1, t = !1, i, n) {
    if (this.length === 0)
      return;
    const s = this.focus.get(), o = this.findPreviousIndex(s.length > 0 ? s[0] - e : 0, t, n);
    o > -1 && this.setFocus([o], i);
  }
  async focusNextPage(e, t) {
    let i = this.view.indexAt(this.view.getScrollTop() + this.view.renderHeight);
    i = i === 0 ? 0 : i - 1;
    const n = this.getFocus()[0];
    if (n !== i && (n === void 0 || i > n)) {
      const s = this.findPreviousIndex(i, !1, t);
      s > -1 && n !== s ? this.setFocus([s], e) : this.setFocus([i], e);
    } else {
      const s = this.view.getScrollTop();
      let o = s + this.view.renderHeight;
      i > n && (o -= this.view.elementHeight(i)), this.view.setScrollTop(o), this.view.getScrollTop() !== s && (this.setFocus([]), await cd(0), await this.focusNextPage(e, t));
    }
  }
  async focusPreviousPage(e, t, i = () => 0) {
    let n;
    const s = i(), o = this.view.getScrollTop() + s;
    o === 0 ? n = this.view.indexAt(o) : n = this.view.indexAfter(o - 1);
    const a = this.getFocus()[0];
    if (a !== n && (a === void 0 || a >= n)) {
      const l = this.findNextIndex(n, !1, t);
      l > -1 && a !== l ? this.setFocus([l], e) : this.setFocus([n], e);
    } else {
      const l = o;
      this.view.setScrollTop(o - this.view.renderHeight - s), this.view.getScrollTop() + i() !== l && (this.setFocus([]), await cd(0), await this.focusPreviousPage(e, t, i));
    }
  }
  focusLast(e, t) {
    if (this.length === 0)
      return;
    const i = this.findPreviousIndex(this.length - 1, !1, t);
    i > -1 && this.setFocus([i], e);
  }
  focusFirst(e, t) {
    this.focusNth(0, e, t);
  }
  focusNth(e, t, i) {
    if (this.length === 0)
      return;
    const n = this.findNextIndex(e, !1, i);
    n > -1 && this.setFocus([n], t);
  }
  findNextIndex(e, t = !1, i) {
    for (let n = 0; n < this.length; n++) {
      if (e >= this.length && !t)
        return -1;
      if (e = e % this.length, !i || i(this.element(e)))
        return e;
      e++;
    }
    return -1;
  }
  findPreviousIndex(e, t = !1, i) {
    for (let n = 0; n < this.length; n++) {
      if (e < 0 && !t)
        return -1;
      if (e = (this.length + e % this.length) % this.length, !i || i(this.element(e)))
        return e;
      e--;
    }
    return -1;
  }
  getFocus() {
    return this.focus.get();
  }
  getFocusedElements() {
    return this.getFocus().map((e) => this.view.element(e));
  }
  reveal(e, t, i = 0) {
    if (e < 0 || e >= this.length)
      throw new Sh(this.user, `Invalid index ${e}`);
    const n = this.view.getScrollTop(), s = this.view.elementTop(e), o = this.view.elementHeight(e);
    if (Ic(t)) {
      const a = o - this.view.renderHeight + i;
      this.view.setScrollTop(a * Yn(t, 0, 1) + s - i);
    } else {
      const a = s + o, l = n + this.view.renderHeight;
      s < n + i && a >= l || (s < n + i || a >= l && o >= this.view.renderHeight ? this.view.setScrollTop(s - i) : a >= l && this.view.setScrollTop(a - this.view.renderHeight));
    }
  }
  /**
   * Returns the relative position of an element rendered in the list.
   * Returns `null` if the element isn't *entirely* in the visible viewport.
   */
  getRelativeTop(e, t = 0) {
    if (e < 0 || e >= this.length)
      throw new Sh(this.user, `Invalid index ${e}`);
    const i = this.view.getScrollTop(), n = this.view.elementTop(e), s = this.view.elementHeight(e);
    if (n < i + t || n + s > i + this.view.renderHeight)
      return null;
    const o = s - this.view.renderHeight + t;
    return Math.abs((i + t - n) / o);
  }
  getHTMLElement() {
    return this.view.domNode;
  }
  getScrollableElement() {
    return this.view.scrollableElementDomNode;
  }
  getElementID(e) {
    return this.view.getElementDomId(e);
  }
  getElementTop(e) {
    return this.view.elementTop(e);
  }
  style(e) {
    this.styleController.style(e);
  }
  toListEvent({ indexes: e, browserEvent: t }) {
    return { indexes: e, elements: e.map((i) => this.view.element(i)), browserEvent: t };
  }
  _onFocusChange() {
    const e = this.focus.get();
    this.view.domNode.classList.toggle("element-focused", e.length > 0), this.onDidChangeActiveDescendant();
  }
  onDidChangeActiveDescendant() {
    var e;
    const t = this.focus.get();
    if (t.length > 0) {
      let i;
      !((e = this.accessibilityProvider) === null || e === void 0) && e.getActiveDescendantId && (i = this.accessibilityProvider.getActiveDescendantId(this.view.element(t[0]))), this.view.domNode.setAttribute("aria-activedescendant", i || this.view.getElementDomId(t[0]));
    } else
      this.view.domNode.removeAttribute("aria-activedescendant");
  }
  _onSelectionChange() {
    const e = this.selection.get();
    this.view.domNode.classList.toggle("selection-none", e.length === 0), this.view.domNode.classList.toggle("selection-single", e.length === 1), this.view.domNode.classList.toggle("selection-multiple", e.length > 1);
  }
  dispose() {
    this._onDidDispose.fire(), this.disposables.dispose(), this._onDidDispose.dispose();
  }
}
oh([
  ki
], Co.prototype, "onDidChangeFocus", null);
oh([
  ki
], Co.prototype, "onDidChangeSelection", null);
oh([
  ki
], Co.prototype, "onContextMenu", null);
oh([
  ki
], Co.prototype, "onKeyDown", null);
oh([
  ki
], Co.prototype, "onDidFocus", null);
oh([
  ki
], Co.prototype, "onDidBlur", null);
const Xh = X, Tz = "selectOption.entry.template";
class Fie {
  get templateId() {
    return Tz;
  }
  renderTemplate(e) {
    const t = /* @__PURE__ */ Object.create(null);
    return t.root = e, t.text = G(e, Xh(".option-text")), t.detail = G(e, Xh(".option-detail")), t.decoratorRight = G(e, Xh(".option-decorator-right")), t;
  }
  renderElement(e, t, i) {
    const n = i, s = e.text, o = e.detail, a = e.decoratorRight, l = e.isDisabled;
    n.text.textContent = s, n.detail.textContent = o || "", n.decoratorRight.innerText = a || "", l ? n.root.classList.add("option-disabled") : n.root.classList.remove("option-disabled");
  }
  disposeTemplate(e) {
  }
}
class Fa extends P {
  constructor(e, t, i, n, s) {
    super(), this.options = [], this._currentSelection = 0, this._hasDetails = !1, this._skipLayout = !1, this._sticky = !1, this._isVisible = !1, this.styles = n, this.selectBoxOptions = s || /* @__PURE__ */ Object.create(null), typeof this.selectBoxOptions.minBottomMargin != "number" ? this.selectBoxOptions.minBottomMargin = Fa.DEFAULT_DROPDOWN_MINIMUM_BOTTOM_MARGIN : this.selectBoxOptions.minBottomMargin < 0 && (this.selectBoxOptions.minBottomMargin = 0), this.selectElement = document.createElement("select"), this.selectElement.className = "monaco-select-box monaco-select-box-dropdown-padding", typeof this.selectBoxOptions.ariaLabel == "string" && this.selectElement.setAttribute("aria-label", this.selectBoxOptions.ariaLabel), typeof this.selectBoxOptions.ariaDescription == "string" && this.selectElement.setAttribute("aria-description", this.selectBoxOptions.ariaDescription), this._onDidSelect = new R(), this._register(this._onDidSelect), this.registerListeners(), this.constructSelectDropDown(i), this.selected = t || 0, e && this.setOptions(e, t), this.initStyleSheet();
  }
  setTitle(e) {
    !this._hover && e ? this._hover = this._register(da().setupUpdatableHover(us("mouse"), this.selectElement, e)) : this._hover && this._hover.update(e);
  }
  // IDelegate - List renderer
  getHeight() {
    return 22;
  }
  getTemplateId() {
    return Tz;
  }
  constructSelectDropDown(e) {
    this.contextViewProvider = e, this.selectDropDownContainer = X(".monaco-select-box-dropdown-container"), this.selectDropDownContainer.classList.add("monaco-select-box-dropdown-padding"), this.selectionDetailsPane = G(this.selectDropDownContainer, Xh(".select-box-details-pane"));
    const t = G(this.selectDropDownContainer, Xh(".select-box-dropdown-container-width-control")), i = G(t, Xh(".width-control-div"));
    this.widthControlElement = document.createElement("span"), this.widthControlElement.className = "option-text-width-control", G(i, this.widthControlElement), this._dropDownPosition = 0, this.styleElement = fo(this.selectDropDownContainer), this.selectDropDownContainer.setAttribute("draggable", "true"), this._register(W(this.selectDropDownContainer, Q.DRAG_START, (n) => {
      nt.stop(n, !0);
    }));
  }
  registerListeners() {
    this._register(pi(this.selectElement, "change", (t) => {
      this.selected = t.target.selectedIndex, this._onDidSelect.fire({
        index: t.target.selectedIndex,
        selected: t.target.value
      }), this.options[this.selected] && this.options[this.selected].text && this.setTitle(this.options[this.selected].text);
    })), this._register(W(this.selectElement, Q.CLICK, (t) => {
      nt.stop(t), this._isVisible ? this.hideSelectDropDown(!0) : this.showSelectDropDown();
    })), this._register(W(this.selectElement, Q.MOUSE_DOWN, (t) => {
      nt.stop(t);
    }));
    let e;
    this._register(W(this.selectElement, "touchstart", (t) => {
      e = this._isVisible;
    })), this._register(W(this.selectElement, "touchend", (t) => {
      nt.stop(t), e ? this.hideSelectDropDown(!0) : this.showSelectDropDown();
    })), this._register(W(this.selectElement, Q.KEY_DOWN, (t) => {
      const i = new Mt(t);
      let n = !1;
      Je ? (i.keyCode === 18 || i.keyCode === 16 || i.keyCode === 10 || i.keyCode === 3) && (n = !0) : (i.keyCode === 18 && i.altKey || i.keyCode === 16 && i.altKey || i.keyCode === 10 || i.keyCode === 3) && (n = !0), n && (this.showSelectDropDown(), nt.stop(t, !0));
    }));
  }
  get onDidSelect() {
    return this._onDidSelect.event;
  }
  setOptions(e, t) {
    ci(this.options, e) || (this.options = e, this.selectElement.options.length = 0, this._hasDetails = !1, this._cachedMaxDetailsHeight = void 0, this.options.forEach((i, n) => {
      this.selectElement.add(this.createOption(i.text, n, i.isDisabled)), typeof i.description == "string" && (this._hasDetails = !0);
    })), t !== void 0 && (this.select(t), this._currentSelection = this.selected);
  }
  setOptionsList() {
    var e;
    (e = this.selectList) === null || e === void 0 || e.splice(0, this.selectList.length, this.options);
  }
  select(e) {
    e >= 0 && e < this.options.length ? this.selected = e : e > this.options.length - 1 ? this.select(this.options.length - 1) : this.selected < 0 && (this.selected = 0), this.selectElement.selectedIndex = this.selected, this.options[this.selected] && this.options[this.selected].text && this.setTitle(this.options[this.selected].text);
  }
  focus() {
    this.selectElement && (this.selectElement.tabIndex = 0, this.selectElement.focus());
  }
  blur() {
    this.selectElement && (this.selectElement.tabIndex = -1, this.selectElement.blur());
  }
  setFocusable(e) {
    this.selectElement.tabIndex = e ? 0 : -1;
  }
  render(e) {
    this.container = e, e.classList.add("select-container"), e.appendChild(this.selectElement), this.styleSelectElement();
  }
  initStyleSheet() {
    const e = [];
    this.styles.listFocusBackground && e.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.focused { background-color: ${this.styles.listFocusBackground} !important; }`), this.styles.listFocusForeground && e.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.focused { color: ${this.styles.listFocusForeground} !important; }`), this.styles.decoratorRightForeground && e.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row:not(.focused) .option-decorator-right { color: ${this.styles.decoratorRightForeground}; }`), this.styles.selectBackground && this.styles.selectBorder && this.styles.selectBorder !== this.styles.selectBackground ? (e.push(`.monaco-select-box-dropdown-container { border: 1px solid ${this.styles.selectBorder} } `), e.push(`.monaco-select-box-dropdown-container > .select-box-details-pane.border-top { border-top: 1px solid ${this.styles.selectBorder} } `), e.push(`.monaco-select-box-dropdown-container > .select-box-details-pane.border-bottom { border-bottom: 1px solid ${this.styles.selectBorder} } `)) : this.styles.selectListBorder && (e.push(`.monaco-select-box-dropdown-container > .select-box-details-pane.border-top { border-top: 1px solid ${this.styles.selectListBorder} } `), e.push(`.monaco-select-box-dropdown-container > .select-box-details-pane.border-bottom { border-bottom: 1px solid ${this.styles.selectListBorder} } `)), this.styles.listHoverForeground && e.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row:not(.option-disabled):not(.focused):hover { color: ${this.styles.listHoverForeground} !important; }`), this.styles.listHoverBackground && e.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row:not(.option-disabled):not(.focused):hover { background-color: ${this.styles.listHoverBackground} !important; }`), this.styles.listFocusOutline && e.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.focused { outline: 1.6px dotted ${this.styles.listFocusOutline} !important; outline-offset: -1.6px !important; }`), this.styles.listHoverOutline && e.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row:not(.option-disabled):not(.focused):hover { outline: 1.6px dashed ${this.styles.listHoverOutline} !important; outline-offset: -1.6px !important; }`), e.push(".monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.option-disabled.focused { background-color: transparent !important; color: inherit !important; outline: none !important; }"), e.push(".monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.option-disabled:hover { background-color: transparent !important; color: inherit !important; outline: none !important; }"), this.styleElement.textContent = e.join(`
`);
  }
  styleSelectElement() {
    var e, t, i;
    const n = (e = this.styles.selectBackground) !== null && e !== void 0 ? e : "", s = (t = this.styles.selectForeground) !== null && t !== void 0 ? t : "", o = (i = this.styles.selectBorder) !== null && i !== void 0 ? i : "";
    this.selectElement.style.backgroundColor = n, this.selectElement.style.color = s, this.selectElement.style.borderColor = o;
  }
  styleList() {
    var e, t;
    const i = (e = this.styles.selectBackground) !== null && e !== void 0 ? e : "", n = ed(this.styles.selectListBackground, i);
    this.selectDropDownListContainer.style.backgroundColor = n, this.selectionDetailsPane.style.backgroundColor = n;
    const s = (t = this.styles.focusBorder) !== null && t !== void 0 ? t : "";
    this.selectDropDownContainer.style.outlineColor = s, this.selectDropDownContainer.style.outlineOffset = "-1px", this.selectList.style(this.styles);
  }
  createOption(e, t, i) {
    const n = document.createElement("option");
    return n.value = e, n.text = e, n.disabled = !!i, n;
  }
  // ContextView dropdown methods
  showSelectDropDown() {
    this.selectionDetailsPane.innerText = "", !(!this.contextViewProvider || this._isVisible) && (this.createSelectList(this.selectDropDownContainer), this.setOptionsList(), this.contextViewProvider.showContextView({
      getAnchor: () => this.selectElement,
      render: (e) => this.renderSelectDropDown(e, !0),
      layout: () => {
        this.layoutSelectDropDown();
      },
      onHide: () => {
        this.selectDropDownContainer.classList.remove("visible"), this.selectElement.classList.remove("synthetic-focus");
      },
      anchorPosition: this._dropDownPosition
    }, this.selectBoxOptions.optionsAsChildren ? this.container : void 0), this._isVisible = !0, this.hideSelectDropDown(!1), this.contextViewProvider.showContextView({
      getAnchor: () => this.selectElement,
      render: (e) => this.renderSelectDropDown(e),
      layout: () => this.layoutSelectDropDown(),
      onHide: () => {
        this.selectDropDownContainer.classList.remove("visible"), this.selectElement.classList.remove("synthetic-focus");
      },
      anchorPosition: this._dropDownPosition
    }, this.selectBoxOptions.optionsAsChildren ? this.container : void 0), this._currentSelection = this.selected, this._isVisible = !0, this.selectElement.setAttribute("aria-expanded", "true"));
  }
  hideSelectDropDown(e) {
    !this.contextViewProvider || !this._isVisible || (this._isVisible = !1, this.selectElement.setAttribute("aria-expanded", "false"), e && this.selectElement.focus(), this.contextViewProvider.hideContextView());
  }
  renderSelectDropDown(e, t) {
    return e.appendChild(this.selectDropDownContainer), this.layoutSelectDropDown(t), {
      dispose: () => {
        try {
          e.removeChild(this.selectDropDownContainer);
        } catch {
        }
      }
    };
  }
  // Iterate over detailed descriptions, find max height
  measureMaxDetailsHeight() {
    let e = 0;
    return this.options.forEach((t, i) => {
      this.updateDetail(i), this.selectionDetailsPane.offsetHeight > e && (e = this.selectionDetailsPane.offsetHeight);
    }), e;
  }
  layoutSelectDropDown(e) {
    if (this._skipLayout)
      return !1;
    if (this.selectList) {
      this.selectDropDownContainer.classList.add("visible");
      const t = we(this.selectElement), i = Ei(this.selectElement), n = we(this.selectElement).getComputedStyle(this.selectElement), s = parseFloat(n.getPropertyValue("--dropdown-padding-top")) + parseFloat(n.getPropertyValue("--dropdown-padding-bottom")), o = t.innerHeight - i.top - i.height - (this.selectBoxOptions.minBottomMargin || 0), a = i.top - Fa.DEFAULT_DROPDOWN_MINIMUM_TOP_MARGIN, l = this.selectElement.offsetWidth, d = this.setWidthControlElement(this.widthControlElement), c = Math.max(d, Math.round(l)).toString() + "px";
      this.selectDropDownContainer.style.width = c, this.selectList.getHTMLElement().style.height = "", this.selectList.layout();
      let h = this.selectList.contentHeight;
      this._hasDetails && this._cachedMaxDetailsHeight === void 0 && (this._cachedMaxDetailsHeight = this.measureMaxDetailsHeight());
      const u = this._hasDetails ? this._cachedMaxDetailsHeight : 0, g = h + s + u, f = Math.floor((o - s - u) / this.getHeight()), m = Math.floor((a - s - u) / this.getHeight());
      if (e)
        return i.top + i.height > t.innerHeight - 22 || i.top < Fa.DEFAULT_DROPDOWN_MINIMUM_TOP_MARGIN || f < 1 && m < 1 ? !1 : (f < Fa.DEFAULT_MINIMUM_VISIBLE_OPTIONS && m > f && this.options.length > f ? (this._dropDownPosition = 1, this.selectDropDownContainer.removeChild(this.selectDropDownListContainer), this.selectDropDownContainer.removeChild(this.selectionDetailsPane), this.selectDropDownContainer.appendChild(this.selectionDetailsPane), this.selectDropDownContainer.appendChild(this.selectDropDownListContainer), this.selectionDetailsPane.classList.remove("border-top"), this.selectionDetailsPane.classList.add("border-bottom")) : (this._dropDownPosition = 0, this.selectDropDownContainer.removeChild(this.selectDropDownListContainer), this.selectDropDownContainer.removeChild(this.selectionDetailsPane), this.selectDropDownContainer.appendChild(this.selectDropDownListContainer), this.selectDropDownContainer.appendChild(this.selectionDetailsPane), this.selectionDetailsPane.classList.remove("border-bottom"), this.selectionDetailsPane.classList.add("border-top")), !0);
      if (i.top + i.height > t.innerHeight - 22 || i.top < Fa.DEFAULT_DROPDOWN_MINIMUM_TOP_MARGIN || this._dropDownPosition === 0 && f < 1 || this._dropDownPosition === 1 && m < 1)
        return this.hideSelectDropDown(!0), !1;
      if (this._dropDownPosition === 0) {
        if (this._isVisible && f + m < 1)
          return this.hideSelectDropDown(!0), !1;
        g > o && (h = f * this.getHeight());
      } else
        g > a && (h = m * this.getHeight());
      return this.selectList.layout(h), this.selectList.domFocus(), this.selectList.length > 0 && (this.selectList.setFocus([this.selected || 0]), this.selectList.reveal(this.selectList.getFocus()[0] || 0)), this._hasDetails ? (this.selectList.getHTMLElement().style.height = h + s + "px", this.selectDropDownContainer.style.height = "") : this.selectDropDownContainer.style.height = h + s + "px", this.updateDetail(this.selected), this.selectDropDownContainer.style.width = c, this.selectDropDownListContainer.setAttribute("tabindex", "0"), this.selectElement.classList.add("synthetic-focus"), this.selectDropDownContainer.classList.add("synthetic-focus"), !0;
    } else
      return !1;
  }
  setWidthControlElement(e) {
    let t = 0;
    if (e) {
      let i = 0, n = 0;
      this.options.forEach((s, o) => {
        const a = s.detail ? s.detail.length : 0, l = s.decoratorRight ? s.decoratorRight.length : 0, d = s.text.length + a + l;
        d > n && (i = o, n = d);
      }), e.textContent = this.options[i].text + (this.options[i].decoratorRight ? this.options[i].decoratorRight + " " : ""), t = Ms(e);
    }
    return t;
  }
  createSelectList(e) {
    if (this.selectList)
      return;
    this.selectDropDownListContainer = G(e, Xh(".select-box-dropdown-list-container")), this.listRenderer = new Fie(), this.selectList = new Co("SelectBoxCustom", this.selectDropDownListContainer, this, [this.listRenderer], {
      useShadows: !1,
      verticalScrollMode: 3,
      keyboardSupport: !1,
      mouseSupport: !1,
      accessibilityProvider: {
        getAriaLabel: (n) => {
          let s = n.text;
          return n.detail && (s += `. ${n.detail}`), n.decoratorRight && (s += `. ${n.decoratorRight}`), n.description && (s += `. ${n.description}`), s;
        },
        getWidgetAriaLabel: () => p({ key: "selectBox", comment: ["Behave like native select dropdown element."] }, "Select Box"),
        getRole: () => Je ? "" : "option",
        getWidgetRole: () => "listbox"
      }
    }), this.selectBoxOptions.ariaLabel && (this.selectList.ariaLabel = this.selectBoxOptions.ariaLabel);
    const t = this._register(new tt(this.selectDropDownListContainer, "keydown")), i = ne.chain(t.event, (n) => n.filter(() => this.selectList.length > 0).map((s) => new Mt(s)));
    this._register(ne.chain(i, (n) => n.filter(
      (s) => s.keyCode === 3
      /* KeyCode.Enter */
    ))(this.onEnter, this)), this._register(ne.chain(i, (n) => n.filter(
      (s) => s.keyCode === 2
      /* KeyCode.Tab */
    ))(this.onEnter, this)), this._register(ne.chain(i, (n) => n.filter(
      (s) => s.keyCode === 9
      /* KeyCode.Escape */
    ))(this.onEscape, this)), this._register(ne.chain(i, (n) => n.filter(
      (s) => s.keyCode === 16
      /* KeyCode.UpArrow */
    ))(this.onUpArrow, this)), this._register(ne.chain(i, (n) => n.filter(
      (s) => s.keyCode === 18
      /* KeyCode.DownArrow */
    ))(this.onDownArrow, this)), this._register(ne.chain(i, (n) => n.filter(
      (s) => s.keyCode === 12
      /* KeyCode.PageDown */
    ))(this.onPageDown, this)), this._register(ne.chain(i, (n) => n.filter(
      (s) => s.keyCode === 11
      /* KeyCode.PageUp */
    ))(this.onPageUp, this)), this._register(ne.chain(i, (n) => n.filter(
      (s) => s.keyCode === 14
      /* KeyCode.Home */
    ))(this.onHome, this)), this._register(ne.chain(i, (n) => n.filter(
      (s) => s.keyCode === 13
      /* KeyCode.End */
    ))(this.onEnd, this)), this._register(ne.chain(i, (n) => n.filter((s) => s.keyCode >= 21 && s.keyCode <= 56 || s.keyCode >= 85 && s.keyCode <= 113))(this.onCharacter, this)), this._register(W(this.selectList.getHTMLElement(), Q.POINTER_UP, (n) => this.onPointerUp(n))), this._register(this.selectList.onMouseOver((n) => typeof n.index < "u" && this.selectList.setFocus([n.index]))), this._register(this.selectList.onDidChangeFocus((n) => this.onListFocus(n))), this._register(W(this.selectDropDownContainer, Q.FOCUS_OUT, (n) => {
      !this._isVisible || qi(n.relatedTarget, this.selectDropDownContainer) || this.onListBlur();
    })), this.selectList.getHTMLElement().setAttribute("aria-label", this.selectBoxOptions.ariaLabel || ""), this.selectList.getHTMLElement().setAttribute("aria-expanded", "true"), this.styleList();
  }
  // List methods
  // List mouse controller - active exit, select option, fire onDidSelect if change, return focus to parent select
  // Also takes in touchend events
  onPointerUp(e) {
    if (!this.selectList.length)
      return;
    nt.stop(e);
    const t = e.target;
    if (!t || t.classList.contains("slider"))
      return;
    const i = t.closest(".monaco-list-row");
    if (!i)
      return;
    const n = Number(i.getAttribute("data-index")), s = i.classList.contains("option-disabled");
    n >= 0 && n < this.options.length && !s && (this.selected = n, this.select(this.selected), this.selectList.setFocus([this.selected]), this.selectList.reveal(this.selectList.getFocus()[0]), this.selected !== this._currentSelection && (this._currentSelection = this.selected, this._onDidSelect.fire({
      index: this.selectElement.selectedIndex,
      selected: this.options[this.selected].text
    }), this.options[this.selected] && this.options[this.selected].text && this.setTitle(this.options[this.selected].text)), this.hideSelectDropDown(!0));
  }
  // List Exit - passive - implicit no selection change, hide drop-down
  onListBlur() {
    this._sticky || (this.selected !== this._currentSelection && this.select(this._currentSelection), this.hideSelectDropDown(!1));
  }
  renderDescriptionMarkdown(e, t) {
    const i = (s) => {
      for (let o = 0; o < s.childNodes.length; o++) {
        const a = s.childNodes.item(o);
        (a.tagName && a.tagName.toLowerCase()) === "img" ? s.removeChild(a) : i(a);
      }
    }, n = z0({ value: e, supportThemeIcons: !0 }, { actionHandler: t });
    return n.element.classList.add("select-box-description-markdown"), i(n.element), n.element;
  }
  // List Focus Change - passive - update details pane with newly focused element's data
  onListFocus(e) {
    !this._isVisible || !this._hasDetails || this.updateDetail(e.indexes[0]);
  }
  updateDetail(e) {
    var t, i;
    this.selectionDetailsPane.innerText = "";
    const n = this.options[e], s = (t = n == null ? void 0 : n.description) !== null && t !== void 0 ? t : "", o = (i = n == null ? void 0 : n.descriptionIsMarkdown) !== null && i !== void 0 ? i : !1;
    if (s) {
      if (o) {
        const a = n.descriptionMarkdownActionHandler;
        this.selectionDetailsPane.appendChild(this.renderDescriptionMarkdown(s, a));
      } else
        this.selectionDetailsPane.innerText = s;
      this.selectionDetailsPane.style.display = "block";
    } else
      this.selectionDetailsPane.style.display = "none";
    this._skipLayout = !0, this.contextViewProvider.layout(), this._skipLayout = !1;
  }
  // List keyboard controller
  // List exit - active - hide ContextView dropdown, reset selection, return focus to parent select
  onEscape(e) {
    nt.stop(e), this.select(this._currentSelection), this.hideSelectDropDown(!0);
  }
  // List exit - active - hide ContextView dropdown, return focus to parent select, fire onDidSelect if change
  onEnter(e) {
    nt.stop(e), this.selected !== this._currentSelection && (this._currentSelection = this.selected, this._onDidSelect.fire({
      index: this.selectElement.selectedIndex,
      selected: this.options[this.selected].text
    }), this.options[this.selected] && this.options[this.selected].text && this.setTitle(this.options[this.selected].text)), this.hideSelectDropDown(!0);
  }
  // List navigation - have to handle a disabled option (jump over)
  onDownArrow(e) {
    if (this.selected < this.options.length - 1) {
      nt.stop(e, !0);
      const t = this.options[this.selected + 1].isDisabled;
      if (t && this.options.length > this.selected + 2)
        this.selected += 2;
      else {
        if (t)
          return;
        this.selected++;
      }
      this.select(this.selected), this.selectList.setFocus([this.selected]), this.selectList.reveal(this.selectList.getFocus()[0]);
    }
  }
  onUpArrow(e) {
    this.selected > 0 && (nt.stop(e, !0), this.options[this.selected - 1].isDisabled && this.selected > 1 ? this.selected -= 2 : this.selected--, this.select(this.selected), this.selectList.setFocus([this.selected]), this.selectList.reveal(this.selectList.getFocus()[0]));
  }
  onPageUp(e) {
    nt.stop(e), this.selectList.focusPreviousPage(), setTimeout(() => {
      this.selected = this.selectList.getFocus()[0], this.options[this.selected].isDisabled && this.selected < this.options.length - 1 && (this.selected++, this.selectList.setFocus([this.selected])), this.selectList.reveal(this.selected), this.select(this.selected);
    }, 1);
  }
  onPageDown(e) {
    nt.stop(e), this.selectList.focusNextPage(), setTimeout(() => {
      this.selected = this.selectList.getFocus()[0], this.options[this.selected].isDisabled && this.selected > 0 && (this.selected--, this.selectList.setFocus([this.selected])), this.selectList.reveal(this.selected), this.select(this.selected);
    }, 1);
  }
  onHome(e) {
    nt.stop(e), !(this.options.length < 2) && (this.selected = 0, this.options[this.selected].isDisabled && this.selected > 1 && this.selected++, this.selectList.setFocus([this.selected]), this.selectList.reveal(this.selected), this.select(this.selected));
  }
  onEnd(e) {
    nt.stop(e), !(this.options.length < 2) && (this.selected = this.options.length - 1, this.options[this.selected].isDisabled && this.selected > 1 && this.selected--, this.selectList.setFocus([this.selected]), this.selectList.reveal(this.selected), this.select(this.selected));
  }
  // Mimic option first character navigation of native select
  onCharacter(e) {
    const t = Ph.toString(e.keyCode);
    let i = -1;
    for (let n = 0; n < this.options.length - 1; n++)
      if (i = (n + this.selected + 1) % this.options.length, this.options[i].text.charAt(0).toUpperCase() === t && !this.options[i].isDisabled) {
        this.select(i), this.selectList.setFocus([i]), this.selectList.reveal(this.selectList.getFocus()[0]), nt.stop(e);
        break;
      }
  }
  dispose() {
    this.hideSelectDropDown(!1), super.dispose();
  }
}
Fa.DEFAULT_DROPDOWN_MINIMUM_BOTTOM_MARGIN = 32;
Fa.DEFAULT_DROPDOWN_MINIMUM_TOP_MARGIN = 2;
Fa.DEFAULT_MINIMUM_VISIBLE_OPTIONS = 3;
class Wie extends P {
  constructor(e, t, i, n) {
    super(), this.selected = 0, this.selectBoxOptions = n || /* @__PURE__ */ Object.create(null), this.options = [], this.selectElement = document.createElement("select"), this.selectElement.className = "monaco-select-box", typeof this.selectBoxOptions.ariaLabel == "string" && this.selectElement.setAttribute("aria-label", this.selectBoxOptions.ariaLabel), typeof this.selectBoxOptions.ariaDescription == "string" && this.selectElement.setAttribute("aria-description", this.selectBoxOptions.ariaDescription), this._onDidSelect = this._register(new R()), this.styles = i, this.registerListeners(), this.setOptions(e, t);
  }
  registerListeners() {
    this._register(At.addTarget(this.selectElement)), [Pt.Tap].forEach((e) => {
      this._register(W(this.selectElement, e, (t) => {
        this.selectElement.focus();
      }));
    }), this._register(pi(this.selectElement, "click", (e) => {
      nt.stop(e, !0);
    })), this._register(pi(this.selectElement, "change", (e) => {
      this.selectElement.title = e.target.value, this._onDidSelect.fire({
        index: e.target.selectedIndex,
        selected: e.target.value
      });
    })), this._register(pi(this.selectElement, "keydown", (e) => {
      let t = !1;
      Je ? (e.keyCode === 18 || e.keyCode === 16 || e.keyCode === 10) && (t = !0) : (e.keyCode === 18 && e.altKey || e.keyCode === 10 || e.keyCode === 3) && (t = !0), t && e.stopPropagation();
    }));
  }
  get onDidSelect() {
    return this._onDidSelect.event;
  }
  setOptions(e, t) {
    (!this.options || !ci(this.options, e)) && (this.options = e, this.selectElement.options.length = 0, this.options.forEach((i, n) => {
      this.selectElement.add(this.createOption(i.text, n, i.isDisabled));
    })), t !== void 0 && this.select(t);
  }
  select(e) {
    this.options.length === 0 ? this.selected = 0 : e >= 0 && e < this.options.length ? this.selected = e : e > this.options.length - 1 ? this.select(this.options.length - 1) : this.selected < 0 && (this.selected = 0), this.selectElement.selectedIndex = this.selected, this.selected < this.options.length && typeof this.options[this.selected].text == "string" ? this.selectElement.title = this.options[this.selected].text : this.selectElement.title = "";
  }
  focus() {
    this.selectElement && (this.selectElement.tabIndex = 0, this.selectElement.focus());
  }
  blur() {
    this.selectElement && (this.selectElement.tabIndex = -1, this.selectElement.blur());
  }
  setFocusable(e) {
    this.selectElement.tabIndex = e ? 0 : -1;
  }
  render(e) {
    e.classList.add("select-container"), e.appendChild(this.selectElement), this.setOptions(this.options, this.selected), this.applyStyles();
  }
  applyStyles() {
    var e, t, i;
    this.selectElement && (this.selectElement.style.backgroundColor = (e = this.styles.selectBackground) !== null && e !== void 0 ? e : "", this.selectElement.style.color = (t = this.styles.selectForeground) !== null && t !== void 0 ? t : "", this.selectElement.style.borderColor = (i = this.styles.selectBorder) !== null && i !== void 0 ? i : "");
  }
  createOption(e, t, i) {
    const n = document.createElement("option");
    return n.value = e, n.text = e, n.disabled = !!i, n;
  }
}
class Bie extends bo {
  constructor(e, t, i, n, s) {
    super(), Je && !(s != null && s.useCustomDrawn) ? this.selectBoxDelegate = new Wie(e, t, n, s) : this.selectBoxDelegate = new Fa(e, t, i, n, s), this._register(this.selectBoxDelegate);
  }
  // Public SelectBox Methods - routed through delegate interface
  get onDidSelect() {
    return this.selectBoxDelegate.onDidSelect;
  }
  setOptions(e, t) {
    this.selectBoxDelegate.setOptions(e, t);
  }
  select(e) {
    this.selectBoxDelegate.select(e);
  }
  focus() {
    this.selectBoxDelegate.focus();
  }
  blur() {
    this.selectBoxDelegate.blur();
  }
  setFocusable(e) {
    this.selectBoxDelegate.setFocusable(e);
  }
  render(e) {
    this.selectBoxDelegate.render(e);
  }
}
class Rr extends P {
  get action() {
    return this._action;
  }
  constructor(e, t, i = {}) {
    super(), this.options = i, this._context = e || this, this._action = t, t instanceof Bs && this._register(t.onDidChange((n) => {
      this.element && this.handleActionChangeEvent(n);
    }));
  }
  handleActionChangeEvent(e) {
    e.enabled !== void 0 && this.updateEnabled(), e.checked !== void 0 && this.updateChecked(), e.class !== void 0 && this.updateClass(), e.label !== void 0 && (this.updateLabel(), this.updateTooltip()), e.tooltip !== void 0 && this.updateTooltip();
  }
  get actionRunner() {
    return this._actionRunner || (this._actionRunner = this._register(new wu())), this._actionRunner;
  }
  set actionRunner(e) {
    this._actionRunner = e;
  }
  isEnabled() {
    return this._action.enabled;
  }
  setActionContext(e) {
    this._context = e;
  }
  render(e) {
    const t = this.element = e;
    this._register(At.addTarget(e));
    const i = this.options && this.options.draggable;
    i && (e.draggable = !0, Oo && this._register(W(e, Q.DRAG_START, (n) => {
      var s;
      return (s = n.dataTransfer) === null || s === void 0 ? void 0 : s.setData(lv.TEXT, this._action.label);
    }))), this._register(W(t, Pt.Tap, (n) => this.onClick(n, !0))), this._register(W(t, Q.MOUSE_DOWN, (n) => {
      i || nt.stop(n, !0), this._action.enabled && n.button === 0 && t.classList.add("active");
    })), Je && this._register(W(t, Q.CONTEXT_MENU, (n) => {
      n.button === 0 && n.ctrlKey === !0 && this.onClick(n);
    })), this._register(W(t, Q.CLICK, (n) => {
      nt.stop(n, !0), this.options && this.options.isMenu || this.onClick(n);
    })), this._register(W(t, Q.DBLCLICK, (n) => {
      nt.stop(n, !0);
    })), [Q.MOUSE_UP, Q.MOUSE_OUT].forEach((n) => {
      this._register(W(t, n, (s) => {
        nt.stop(s), t.classList.remove("active");
      }));
    });
  }
  onClick(e, t = !1) {
    var i;
    nt.stop(e, !0);
    const n = Ma(this._context) ? !((i = this.options) === null || i === void 0) && i.useEventAsContext ? e : { preserveFocus: t } : this._context;
    this.actionRunner.run(this._action, n);
  }
  // Only set the tabIndex on the element once it is about to get focused
  // That way this element wont be a tab stop when it is not needed #106441
  focus() {
    this.element && (this.element.tabIndex = 0, this.element.focus(), this.element.classList.add("focused"));
  }
  blur() {
    this.element && (this.element.blur(), this.element.tabIndex = -1, this.element.classList.remove("focused"));
  }
  setFocusable(e) {
    this.element && (this.element.tabIndex = e ? 0 : -1);
  }
  get trapsArrowNavigation() {
    return !1;
  }
  updateEnabled() {
  }
  updateLabel() {
  }
  getClass() {
    return this.action.class;
  }
  getTooltip() {
    return this.action.tooltip;
  }
  updateTooltip() {
    var e, t, i;
    if (!this.element)
      return;
    const n = (e = this.getTooltip()) !== null && e !== void 0 ? e : "";
    if (this.updateAriaLabel(), !((t = this.options.hoverDelegate) === null || t === void 0) && t.showNativeHover)
      this.element.title = n;
    else if (!this.customHover && n !== "") {
      const s = (i = this.options.hoverDelegate) !== null && i !== void 0 ? i : us("element");
      this.customHover = this._store.add(da().setupUpdatableHover(s, this.element, n));
    } else this.customHover && this.customHover.update(n);
  }
  updateAriaLabel() {
    var e;
    if (this.element) {
      const t = (e = this.getTooltip()) !== null && e !== void 0 ? e : "";
      this.element.setAttribute("aria-label", t);
    }
  }
  updateClass() {
  }
  updateChecked() {
  }
  dispose() {
    this.element && (this.element.remove(), this.element = void 0), this._context = void 0, super.dispose();
  }
}
class sp extends Rr {
  constructor(e, t, i) {
    super(e, t, i), this.options = i, this.options.icon = i.icon !== void 0 ? i.icon : !1, this.options.label = i.label !== void 0 ? i.label : !0, this.cssClass = "";
  }
  render(e) {
    super.render(e), ct(this.element);
    const t = document.createElement("a");
    if (t.classList.add("action-label"), t.setAttribute("role", this.getDefaultAriaRole()), this.label = t, this.element.appendChild(t), this.options.label && this.options.keybinding) {
      const i = document.createElement("span");
      i.classList.add("keybinding"), i.textContent = this.options.keybinding, this.element.appendChild(i);
    }
    this.updateClass(), this.updateLabel(), this.updateTooltip(), this.updateEnabled(), this.updateChecked();
  }
  getDefaultAriaRole() {
    return this._action.id === Oi.ID ? "presentation" : this.options.isMenu ? "menuitem" : "button";
  }
  // Only set the tabIndex on the element once it is about to get focused
  // That way this element wont be a tab stop when it is not needed #106441
  focus() {
    this.label && (this.label.tabIndex = 0, this.label.focus());
  }
  blur() {
    this.label && (this.label.tabIndex = -1);
  }
  setFocusable(e) {
    this.label && (this.label.tabIndex = e ? 0 : -1);
  }
  updateLabel() {
    this.options.label && this.label && (this.label.textContent = this.action.label);
  }
  getTooltip() {
    let e = null;
    return this.action.tooltip ? e = this.action.tooltip : !this.options.label && this.action.label && this.options.icon && (e = this.action.label, this.options.keybinding && (e = p({ key: "titleLabel", comment: ["action title", "action keybinding"] }, "{0} ({1})", e, this.options.keybinding))), e ?? void 0;
  }
  updateClass() {
    var e;
    this.cssClass && this.label && this.label.classList.remove(...this.cssClass.split(" ")), this.options.icon ? (this.cssClass = this.getClass(), this.label && (this.label.classList.add("codicon"), this.cssClass && this.label.classList.add(...this.cssClass.split(" "))), this.updateEnabled()) : (e = this.label) === null || e === void 0 || e.classList.remove("codicon");
  }
  updateEnabled() {
    var e, t;
    this.action.enabled ? (this.label && (this.label.removeAttribute("aria-disabled"), this.label.classList.remove("disabled")), (e = this.element) === null || e === void 0 || e.classList.remove("disabled")) : (this.label && (this.label.setAttribute("aria-disabled", "true"), this.label.classList.add("disabled")), (t = this.element) === null || t === void 0 || t.classList.add("disabled"));
  }
  updateAriaLabel() {
    var e;
    if (this.label) {
      const t = (e = this.getTooltip()) !== null && e !== void 0 ? e : "";
      this.label.setAttribute("aria-label", t);
    }
  }
  updateChecked() {
    this.label && (this.action.checked !== void 0 ? (this.label.classList.toggle("checked", this.action.checked), this.label.setAttribute("aria-checked", this.action.checked ? "true" : "false"), this.label.setAttribute("role", "checkbox")) : (this.label.classList.remove("checked"), this.label.removeAttribute("aria-checked"), this.label.setAttribute("role", this.getDefaultAriaRole())));
  }
}
class Hie extends Rr {
  constructor(e, t, i, n, s, o, a) {
    super(e, t), this.selectBox = new Bie(i, n, s, o, a), this.selectBox.setFocusable(!1), this._register(this.selectBox), this.registerListeners();
  }
  select(e) {
    this.selectBox.select(e);
  }
  registerListeners() {
    this._register(this.selectBox.onDidSelect((e) => this.runAction(e.selected, e.index)));
  }
  runAction(e, t) {
    this.actionRunner.run(this._action, this.getActionContext(e, t));
  }
  getActionContext(e, t) {
    return e;
  }
  setFocusable(e) {
    this.selectBox.setFocusable(e);
  }
  focus() {
    var e;
    (e = this.selectBox) === null || e === void 0 || e.focus();
  }
  blur() {
    var e;
    (e = this.selectBox) === null || e === void 0 || e.blur();
  }
  render(e) {
    this.selectBox.render(e);
  }
}
class Vie extends wu {
  constructor(e, t) {
    super(), this._onDidChangeVisibility = this._register(new R()), this.onDidChangeVisibility = this._onDidChangeVisibility.event, this._element = G(e, X(".monaco-dropdown")), this._label = G(this._element, X(".dropdown-label"));
    let i = t.labelRenderer;
    i || (i = (s) => (s.textContent = t.label || "", null));
    for (const s of [Q.CLICK, Q.MOUSE_DOWN, Pt.Tap])
      this._register(W(this.element, s, (o) => nt.stop(o, !0)));
    for (const s of [Q.MOUSE_DOWN, Pt.Tap])
      this._register(W(this._label, s, (o) => {
        o1(o) && (o.detail > 1 || o.button !== 0) || (this.visible ? this.hide() : this.show());
      }));
    this._register(W(this._label, Q.KEY_UP, (s) => {
      const o = new Mt(s);
      (o.equals(
        3
        /* KeyCode.Enter */
      ) || o.equals(
        10
        /* KeyCode.Space */
      )) && (nt.stop(s, !0), this.visible ? this.hide() : this.show());
    }));
    const n = i(this._label);
    n && this._register(n), this._register(At.addTarget(this._label));
  }
  get element() {
    return this._element;
  }
  show() {
    this.visible || (this.visible = !0, this._onDidChangeVisibility.fire(!0));
  }
  hide() {
    this.visible && (this.visible = !1, this._onDidChangeVisibility.fire(!1));
  }
  dispose() {
    super.dispose(), this.hide(), this.boxContainer && (this.boxContainer.remove(), this.boxContainer = void 0), this.contents && (this.contents.remove(), this.contents = void 0), this._label && (this._label.remove(), this._label = void 0);
  }
}
class zie extends Vie {
  constructor(e, t) {
    super(e, t), this._options = t, this._actions = [], this.actions = t.actions || [];
  }
  set menuOptions(e) {
    this._menuOptions = e;
  }
  get menuOptions() {
    return this._menuOptions;
  }
  get actions() {
    return this._options.actionProvider ? this._options.actionProvider.getActions() : this._actions;
  }
  set actions(e) {
    this._actions = e;
  }
  show() {
    super.show(), this.element.classList.add("active"), this._options.contextMenuProvider.showContextMenu({
      getAnchor: () => this.element,
      getActions: () => this.actions,
      getActionsContext: () => this.menuOptions ? this.menuOptions.context : null,
      getActionViewItem: (e, t) => this.menuOptions && this.menuOptions.actionViewItemProvider ? this.menuOptions.actionViewItemProvider(e, t) : void 0,
      getKeyBinding: (e) => this.menuOptions && this.menuOptions.getKeyBinding ? this.menuOptions.getKeyBinding(e) : void 0,
      getMenuClassName: () => this._options.menuClassName || "",
      onHide: () => this.onHide(),
      actionRunner: this.menuOptions ? this.menuOptions.actionRunner : void 0,
      anchorAlignment: this.menuOptions ? this.menuOptions.anchorAlignment : 0,
      domForShadowRoot: this._options.menuAsChild ? this.element : void 0,
      skipTelemetry: this._options.skipTelemetry
    });
  }
  hide() {
    super.hide();
  }
  onHide() {
    this.hide(), this.element.classList.remove("active");
  }
}
class qS extends Rr {
  constructor(e, t, i, n = /* @__PURE__ */ Object.create(null)) {
    super(null, e, n), this.actionItem = null, this._onDidChangeVisibility = this._register(new R()), this.onDidChangeVisibility = this._onDidChangeVisibility.event, this.menuActionsOrProvider = t, this.contextMenuProvider = i, this.options = n, this.options.actionRunner && (this.actionRunner = this.options.actionRunner);
  }
  render(e) {
    this.actionItem = e;
    const t = (s) => {
      var o;
      this.element = G(s, X("a.action-label"));
      let a = [];
      return typeof this.options.classNames == "string" ? a = this.options.classNames.split(/\s+/g).filter((l) => !!l) : this.options.classNames && (a = this.options.classNames), a.find((l) => l === "icon") || a.push("codicon"), this.element.classList.add(...a), this.element.setAttribute("role", "button"), this.element.setAttribute("aria-haspopup", "true"), this.element.setAttribute("aria-expanded", "false"), this._action.label && this._register(da().setupUpdatableHover((o = this.options.hoverDelegate) !== null && o !== void 0 ? o : us("mouse"), this.element, this._action.label)), this.element.ariaLabel = this._action.label || "", null;
    }, i = Array.isArray(this.menuActionsOrProvider), n = {
      contextMenuProvider: this.contextMenuProvider,
      labelRenderer: t,
      menuAsChild: this.options.menuAsChild,
      actions: i ? this.menuActionsOrProvider : void 0,
      actionProvider: i ? void 0 : this.menuActionsOrProvider,
      skipTelemetry: this.options.skipTelemetry
    };
    if (this.dropdownMenu = this._register(new zie(e, n)), this._register(this.dropdownMenu.onDidChangeVisibility((s) => {
      var o;
      (o = this.element) === null || o === void 0 || o.setAttribute("aria-expanded", `${s}`), this._onDidChangeVisibility.fire(s);
    })), this.dropdownMenu.menuOptions = {
      actionViewItemProvider: this.options.actionViewItemProvider,
      actionRunner: this.actionRunner,
      getKeyBinding: this.options.keybindingProvider,
      context: this._context
    }, this.options.anchorAlignmentProvider) {
      const s = this;
      this.dropdownMenu.menuOptions = {
        ...this.dropdownMenu.menuOptions,
        get anchorAlignment() {
          return s.options.anchorAlignmentProvider();
        }
      };
    }
    this.updateTooltip(), this.updateEnabled();
  }
  getTooltip() {
    let e = null;
    return this.action.tooltip ? e = this.action.tooltip : this.action.label && (e = this.action.label), e ?? void 0;
  }
  setActionContext(e) {
    super.setActionContext(e), this.dropdownMenu && (this.dropdownMenu.menuOptions ? this.dropdownMenu.menuOptions.context = e : this.dropdownMenu.menuOptions = { context: e });
  }
  show() {
    var e;
    (e = this.dropdownMenu) === null || e === void 0 || e.show();
  }
  updateEnabled() {
    var e, t;
    const i = !this.action.enabled;
    (e = this.actionItem) === null || e === void 0 || e.classList.toggle("disabled", i), (t = this.element) === null || t === void 0 || t.classList.toggle("disabled", i);
  }
}
function Uie(r) {
  return r && typeof r == "object" && typeof r.original == "string" && typeof r.value == "string";
}
function $ie(r) {
  return r ? r.condition !== void 0 : !1;
}
var If;
(function(r) {
  r[r.STORAGE_DOES_NOT_EXIST = 0] = "STORAGE_DOES_NOT_EXIST", r[r.STORAGE_IN_MEMORY = 1] = "STORAGE_IN_MEMORY";
})(If || (If = {}));
var sf;
(function(r) {
  r[r.None = 0] = "None", r[r.Initialized = 1] = "Initialized", r[r.Closed = 2] = "Closed";
})(sf || (sf = {}));
class Ef extends P {
  constructor(e, t = /* @__PURE__ */ Object.create(null)) {
    super(), this.database = e, this.options = t, this._onDidChangeStorage = this._register(new Wf()), this.onDidChangeStorage = this._onDidChangeStorage.event, this.state = sf.None, this.cache = /* @__PURE__ */ new Map(), this.flushDelayer = this._register(new kH(Ef.DEFAULT_FLUSH_DELAY)), this.pendingDeletes = /* @__PURE__ */ new Set(), this.pendingInserts = /* @__PURE__ */ new Map(), this.whenFlushedCallbacks = [], this.registerListeners();
  }
  registerListeners() {
    this._register(this.database.onDidChangeItemsExternal((e) => this.onDidChangeItemsExternal(e)));
  }
  onDidChangeItemsExternal(e) {
    var t, i;
    this._onDidChangeStorage.pause();
    try {
      (t = e.changed) === null || t === void 0 || t.forEach((n, s) => this.acceptExternal(s, n)), (i = e.deleted) === null || i === void 0 || i.forEach((n) => this.acceptExternal(n, void 0));
    } finally {
      this._onDidChangeStorage.resume();
    }
  }
  acceptExternal(e, t) {
    if (this.state === sf.Closed)
      return;
    let i = !1;
    Ma(t) ? i = this.cache.delete(e) : this.cache.get(e) !== t && (this.cache.set(e, t), i = !0), i && this._onDidChangeStorage.fire({ key: e, external: !0 });
  }
  get(e, t) {
    const i = this.cache.get(e);
    return Ma(i) ? t : i;
  }
  getBoolean(e, t) {
    const i = this.get(e);
    return Ma(i) ? t : i === "true";
  }
  getNumber(e, t) {
    const i = this.get(e);
    return Ma(i) ? t : parseInt(i, 10);
  }
  async set(e, t, i = !1) {
    if (this.state === sf.Closed)
      return;
    if (Ma(t))
      return this.delete(e, i);
    const n = ur(t) || Array.isArray(t) ? Dee(t) : String(t);
    if (this.cache.get(e) !== n)
      return this.cache.set(e, n), this.pendingInserts.set(e, n), this.pendingDeletes.delete(e), this._onDidChangeStorage.fire({ key: e, external: i }), this.doFlush();
  }
  async delete(e, t = !1) {
    if (!(this.state === sf.Closed || !this.cache.delete(e)))
      return this.pendingDeletes.has(e) || this.pendingDeletes.add(e), this.pendingInserts.delete(e), this._onDidChangeStorage.fire({ key: e, external: t }), this.doFlush();
  }
  get hasPending() {
    return this.pendingInserts.size > 0 || this.pendingDeletes.size > 0;
  }
  async flushPending() {
    if (!this.hasPending)
      return;
    const e = { insert: this.pendingInserts, delete: this.pendingDeletes };
    return this.pendingDeletes = /* @__PURE__ */ new Set(), this.pendingInserts = /* @__PURE__ */ new Map(), this.database.updateItems(e).finally(() => {
      var t;
      if (!this.hasPending)
        for (; this.whenFlushedCallbacks.length; )
          (t = this.whenFlushedCallbacks.pop()) === null || t === void 0 || t();
    });
  }
  async doFlush(e) {
    return this.options.hint === If.STORAGE_IN_MEMORY ? this.flushPending() : this.flushDelayer.trigger(() => this.flushPending(), e);
  }
}
Ef.DEFAULT_FLUSH_DELAY = 100;
class Dk {
  constructor() {
    this.onDidChangeItemsExternal = ne.None, this.items = /* @__PURE__ */ new Map();
  }
  async updateItems(e) {
    var t, i;
    (t = e.insert) === null || t === void 0 || t.forEach((n, s) => this.items.set(s, n)), (i = e.delete) === null || i === void 0 || i.forEach((n) => this.items.delete(n));
  }
}
const Vw = "__$__targetStorageMarker", br = et("storageService");
var uv;
(function(r) {
  r[r.NONE = 0] = "NONE", r[r.SHUTDOWN = 1] = "SHUTDOWN";
})(uv || (uv = {}));
function Kie(r) {
  const e = r.get(Vw);
  if (e)
    try {
      return JSON.parse(e);
    } catch {
    }
  return /* @__PURE__ */ Object.create(null);
}
class X0 extends P {
  constructor(e = { flushInterval: X0.DEFAULT_FLUSH_INTERVAL }) {
    super(), this.options = e, this._onDidChangeValue = this._register(new Wf()), this._onDidChangeTarget = this._register(new Wf()), this._onWillSaveState = this._register(new R()), this.onWillSaveState = this._onWillSaveState.event, this._workspaceKeyTargets = void 0, this._profileKeyTargets = void 0, this._applicationKeyTargets = void 0;
  }
  onDidChangeValue(e, t, i) {
    return ne.filter(this._onDidChangeValue.event, (n) => n.scope === e && (t === void 0 || n.key === t), i);
  }
  emitDidChangeValue(e, t) {
    const { key: i, external: n } = t;
    if (i === Vw) {
      switch (e) {
        case -1:
          this._applicationKeyTargets = void 0;
          break;
        case 0:
          this._profileKeyTargets = void 0;
          break;
        case 1:
          this._workspaceKeyTargets = void 0;
          break;
      }
      this._onDidChangeTarget.fire({ scope: e });
    } else
      this._onDidChangeValue.fire({ scope: e, key: i, target: this.getKeyTargets(e)[i], external: n });
  }
  get(e, t, i) {
    var n;
    return (n = this.getStorage(t)) === null || n === void 0 ? void 0 : n.get(e, i);
  }
  getBoolean(e, t, i) {
    var n;
    return (n = this.getStorage(t)) === null || n === void 0 ? void 0 : n.getBoolean(e, i);
  }
  getNumber(e, t, i) {
    var n;
    return (n = this.getStorage(t)) === null || n === void 0 ? void 0 : n.getNumber(e, i);
  }
  store(e, t, i, n, s = !1) {
    if (Ma(t)) {
      this.remove(e, i, s);
      return;
    }
    this.withPausedEmitters(() => {
      var o;
      this.updateKeyTarget(e, i, n), (o = this.getStorage(i)) === null || o === void 0 || o.set(e, t, s);
    });
  }
  remove(e, t, i = !1) {
    this.withPausedEmitters(() => {
      var n;
      this.updateKeyTarget(e, t, void 0), (n = this.getStorage(t)) === null || n === void 0 || n.delete(e, i);
    });
  }
  withPausedEmitters(e) {
    this._onDidChangeValue.pause(), this._onDidChangeTarget.pause();
    try {
      e();
    } finally {
      this._onDidChangeValue.resume(), this._onDidChangeTarget.resume();
    }
  }
  updateKeyTarget(e, t, i, n = !1) {
    var s, o;
    const a = this.getKeyTargets(t);
    typeof i == "number" ? a[e] !== i && (a[e] = i, (s = this.getStorage(t)) === null || s === void 0 || s.set(Vw, JSON.stringify(a), n)) : typeof a[e] == "number" && (delete a[e], (o = this.getStorage(t)) === null || o === void 0 || o.set(Vw, JSON.stringify(a), n));
  }
  get workspaceKeyTargets() {
    return this._workspaceKeyTargets || (this._workspaceKeyTargets = this.loadKeyTargets(
      1
      /* StorageScope.WORKSPACE */
    )), this._workspaceKeyTargets;
  }
  get profileKeyTargets() {
    return this._profileKeyTargets || (this._profileKeyTargets = this.loadKeyTargets(
      0
      /* StorageScope.PROFILE */
    )), this._profileKeyTargets;
  }
  get applicationKeyTargets() {
    return this._applicationKeyTargets || (this._applicationKeyTargets = this.loadKeyTargets(
      -1
      /* StorageScope.APPLICATION */
    )), this._applicationKeyTargets;
  }
  getKeyTargets(e) {
    switch (e) {
      case -1:
        return this.applicationKeyTargets;
      case 0:
        return this.profileKeyTargets;
      default:
        return this.workspaceKeyTargets;
    }
  }
  loadKeyTargets(e) {
    const t = this.getStorage(e);
    return t ? Kie(t) : /* @__PURE__ */ Object.create(null);
  }
}
X0.DEFAULT_FLUSH_INTERVAL = 60 * 1e3;
class jie extends X0 {
  constructor() {
    super(), this.applicationStorage = this._register(new Ef(new Dk(), { hint: If.STORAGE_IN_MEMORY })), this.profileStorage = this._register(new Ef(new Dk(), { hint: If.STORAGE_IN_MEMORY })), this.workspaceStorage = this._register(new Ef(new Dk(), { hint: If.STORAGE_IN_MEMORY })), this._register(this.workspaceStorage.onDidChangeStorage((e) => this.emitDidChangeValue(1, e))), this._register(this.profileStorage.onDidChangeStorage((e) => this.emitDidChangeValue(0, e))), this._register(this.applicationStorage.onDidChangeStorage((e) => this.emitDidChangeValue(-1, e)));
  }
  getStorage(e) {
    switch (e) {
      case -1:
        return this.applicationStorage;
      case 0:
        return this.profileStorage;
      default:
        return this.workspaceStorage;
    }
  }
}
function qie(r, e) {
  const t = { ...e };
  for (const i in r) {
    const n = r[i];
    t[i] = n !== void 0 ? le(n) : void 0;
  }
  return t;
}
const Gie = {
  keybindingLabelBackground: le(h9),
  keybindingLabelForeground: le(u9),
  keybindingLabelBorder: le(g9),
  keybindingLabelBottomBorder: le(f9),
  keybindingLabelShadow: le(jl)
}, Zie = {
  buttonForeground: le(Tm),
  buttonSeparator: le(n9),
  buttonBackground: le(Nm),
  buttonHoverBackground: le(s9),
  buttonSecondaryForeground: le(r9),
  buttonSecondaryBackground: le(qx),
  buttonSecondaryHoverBackground: le(a9),
  buttonBorder: le(o9)
}, Yie = {
  progressBarBackground: le(CG)
}, GS = {
  inputActiveOptionBorder: le(w1),
  inputActiveOptionForeground: le(S1),
  inputActiveOptionBackground: le(Gh)
};
le(l9), le(c9), le(d9);
le(Di), le(Vl), le(jl), le(it), le(BG), le(HG), le(VG), le(vG);
const ZS = {
  inputBackground: le(jx),
  inputForeground: le(MV),
  inputBorder: le(RV),
  inputValidationInfoBorder: le(ZG),
  inputValidationInfoBackground: le(qG),
  inputValidationInfoForeground: le(GG),
  inputValidationWarningBorder: le(XG),
  inputValidationWarningBackground: le(YG),
  inputValidationWarningForeground: le(QG),
  inputValidationErrorBorder: le(t9),
  inputValidationErrorBackground: le(JG),
  inputValidationErrorForeground: le(e9)
}, Qie = {
  listFilterWidgetBackground: le(k9),
  listFilterWidgetOutline: le(x9),
  listFilterWidgetNoMatchesOutline: le(I9),
  listFilterWidgetShadow: le(E9),
  inputBoxStyles: ZS,
  toggleStyles: GS
}, Nz = {
  badgeBackground: le(Nw),
  badgeForeground: le(bG),
  badgeBorder: le(it)
};
le(FG), le(OG), le(rP), le(rP), le(WG);
const ng = {
  listBackground: void 0,
  listInactiveFocusForeground: void 0,
  listFocusBackground: le(p9),
  listFocusForeground: le(m9),
  listFocusOutline: le(_9),
  listActiveSelectionBackground: le(Gl),
  listActiveSelectionForeground: le(Ua),
  listActiveSelectionIconForeground: le(Mm),
  listFocusAndSelectionOutline: le(v9),
  listFocusAndSelectionBackground: le(Gl),
  listFocusAndSelectionForeground: le(Ua),
  listInactiveSelectionBackground: le(b9),
  listInactiveSelectionIconForeground: le(w9),
  listInactiveSelectionForeground: le(C9),
  listInactiveFocusBackground: le(S9),
  listInactiveFocusOutline: le(y9),
  listHoverBackground: le(AV),
  listHoverForeground: le(PV),
  listDropOverBackground: le(L9),
  listDropBetweenBackground: le(D9),
  listSelectionOutline: le(Gt),
  listHoverOutline: le(Gt),
  treeIndentGuidesStroke: le(Rm),
  treeInactiveIndentGuidesStroke: le(T9),
  treeStickyScrollBackground: void 0,
  treeStickyScrollBorder: void 0,
  treeStickyScrollShadow: void 0,
  tableColumnsBorder: le(N9),
  tableOddRowsBackgroundColor: le(M9)
};
function sg(r) {
  return qie(r, ng);
}
const Xie = {
  selectBackground: le(za),
  selectListBackground: le(i9),
  selectForeground: le(ql),
  decoratorRightForeground: le(OV),
  selectBorder: le(Gg),
  focusBorder: le(To),
  listFocusBackground: le(nc),
  listInactiveSelectionIconForeground: le(Zg),
  listFocusForeground: le(ic),
  listFocusOutline: fG(Gt, z.transparent.toString()),
  listHoverBackground: le(AV),
  listHoverForeground: le(PV),
  listHoverOutline: le(Gt),
  selectListBorder: le(zl),
  listBackground: void 0,
  listActiveSelectionBackground: void 0,
  listActiveSelectionForeground: void 0,
  listActiveSelectionIconForeground: void 0,
  listFocusAndSelectionBackground: void 0,
  listDropOverBackground: void 0,
  listDropBetweenBackground: void 0,
  listInactiveSelectionBackground: void 0,
  listInactiveSelectionForeground: void 0,
  listInactiveFocusBackground: void 0,
  listInactiveFocusOutline: void 0,
  listSelectionOutline: void 0,
  listFocusAndSelectionForeground: void 0,
  listFocusAndSelectionOutline: void 0,
  listInactiveFocusForeground: void 0,
  tableColumnsBorder: void 0,
  tableOddRowsBackgroundColor: void 0,
  treeIndentGuidesStroke: void 0,
  treeInactiveIndentGuidesStroke: void 0,
  treeStickyScrollBackground: void 0,
  treeStickyScrollBorder: void 0,
  treeStickyScrollShadow: void 0
}, Jie = {
  shadowColor: le(jl),
  borderColor: le(R9),
  foregroundColor: le(A9),
  backgroundColor: le(P9),
  selectionForegroundColor: le(O9),
  selectionBackgroundColor: le(F9),
  selectionBorderColor: le(W9),
  separatorColor: le(B9),
  scrollbarShadow: le(Dm),
  scrollbarSliderBackground: le(km),
  scrollbarSliderHoverBackground: le(xm),
  scrollbarSliderActiveBackground: le(Im)
};
var J0 = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Cs = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
function ene(r, e, t, i) {
  const n = r.getActions(e), s = Hl.getInstance(), o = s.keyStatus.altKey || (Ks || os) && s.keyStatus.shiftKey;
  Mz(n, t, o, (a) => a === "navigation");
}
function eL(r, e, t, i, n, s) {
  const o = r.getActions(e);
  Mz(o, t, !1, typeof i == "string" ? (l) => l === i : i, n, s);
}
function Mz(r, e, t, i = (o) => o === "navigation", n = () => !1, s = !1) {
  let o, a;
  Array.isArray(e) ? (o = e, a = e) : (o = e.primary, a = e.secondary);
  const l = /* @__PURE__ */ new Set();
  for (const [d, c] of r) {
    let h;
    i(d) ? (h = o, h.length > 0 && s && h.push(new Oi())) : (h = a, h.length > 0 && h.push(new Oi()));
    for (let u of c) {
      t && (u = u instanceof Hs && u.alt ? u.alt : u);
      const g = h.push(u);
      u instanceof Bf && l.add({ group: d, action: u, index: g - 1 });
    }
  }
  for (const { group: d, action: c, index: h } of l) {
    const u = i(d) ? o : a, g = c.actions;
    n(c, d, u.length) && u.splice(h, 1, ...g);
  }
}
let Hc = class extends sp {
  constructor(e, t, i, n, s, o, a, l) {
    super(void 0, e, { icon: !!(e.class || e.item.icon), label: !e.class && !e.item.icon, draggable: t == null ? void 0 : t.draggable, keybinding: t == null ? void 0 : t.keybinding, hoverDelegate: t == null ? void 0 : t.hoverDelegate }), this._keybindingService = i, this._notificationService = n, this._contextKeyService = s, this._themeService = o, this._contextMenuService = a, this._accessibilityService = l, this._wantsAltCommand = !1, this._itemClassDispose = this._register(new Yi()), this._altKey = Hl.getInstance();
  }
  get _menuItemAction() {
    return this._action;
  }
  get _commandAction() {
    return this._wantsAltCommand && this._menuItemAction.alt || this._menuItemAction;
  }
  async onClick(e) {
    e.preventDefault(), e.stopPropagation();
    try {
      await this.actionRunner.run(this._commandAction, this._context);
    } catch (t) {
      this._notificationService.error(t);
    }
  }
  render(e) {
    if (super.render(e), e.classList.add("menu-entry"), this.options.icon && this._updateItemClass(this._menuItemAction.item), this._menuItemAction.alt) {
      let t = !1;
      const i = () => {
        var n;
        const s = !!(!((n = this._menuItemAction.alt) === null || n === void 0) && n.enabled) && (!this._accessibilityService.isMotionReduced() || t) && (this._altKey.keyStatus.altKey || this._altKey.keyStatus.shiftKey && t);
        s !== this._wantsAltCommand && (this._wantsAltCommand = s, this.updateLabel(), this.updateTooltip(), this.updateClass());
      };
      this._register(this._altKey.event(i)), this._register(W(e, "mouseleave", (n) => {
        t = !1, i();
      })), this._register(W(e, "mouseenter", (n) => {
        t = !0, i();
      })), i();
    }
  }
  updateLabel() {
    this.options.label && this.label && (this.label.textContent = this._commandAction.label);
  }
  getTooltip() {
    var e;
    const t = this._keybindingService.lookupKeybinding(this._commandAction.id, this._contextKeyService), i = t && t.getLabel(), n = this._commandAction.tooltip || this._commandAction.label;
    let s = i ? p("titleAndKb", "{0} ({1})", n, i) : n;
    if (!this._wantsAltCommand && (!((e = this._menuItemAction.alt) === null || e === void 0) && e.enabled)) {
      const o = this._menuItemAction.alt.tooltip || this._menuItemAction.alt.label, a = this._keybindingService.lookupKeybinding(this._menuItemAction.alt.id, this._contextKeyService), l = a && a.getLabel(), d = l ? p("titleAndKb", "{0} ({1})", o, l) : o;
      s = p("titleAndKbAndAlt", `{0}
[{1}] {2}`, s, fM.modifierLabels[Os].altKey, d);
    }
    return s;
  }
  updateClass() {
    this.options.icon && (this._commandAction !== this._menuItemAction ? this._menuItemAction.alt && this._updateItemClass(this._menuItemAction.alt.item) : this._updateItemClass(this._menuItemAction.item));
  }
  _updateItemClass(e) {
    this._itemClassDispose.value = void 0;
    const { element: t, label: i } = this;
    if (!t || !i)
      return;
    const n = this._commandAction.checked && $ie(e.toggled) && e.toggled.icon ? e.toggled.icon : e.icon;
    if (n)
      if (Le.isThemeIcon(n)) {
        const s = Le.asClassNameArray(n);
        i.classList.add(...s), this._itemClassDispose.value = Se(() => {
          i.classList.remove(...s);
        });
      } else
        i.style.backgroundImage = jf(this._themeService.getColorTheme().type) ? hd(n.dark) : hd(n.light), i.classList.add("icon"), this._itemClassDispose.value = Ur(Se(() => {
          i.style.backgroundImage = "", i.classList.remove("icon");
        }), this._themeService.onDidColorThemeChange(() => {
          this.updateClass();
        }));
  }
};
Hc = J0([
  Cs(2, _t),
  Cs(3, xi),
  Cs(4, De),
  Cs(5, $i),
  Cs(6, Zs),
  Cs(7, qs)
], Hc);
let qI = class extends qS {
  constructor(e, t, i, n, s) {
    var o, a, l;
    const d = {
      ...t,
      menuAsChild: (o = t == null ? void 0 : t.menuAsChild) !== null && o !== void 0 ? o : !1,
      classNames: (a = t == null ? void 0 : t.classNames) !== null && a !== void 0 ? a : Le.isThemeIcon(e.item.icon) ? Le.asClassName(e.item.icon) : void 0,
      keybindingProvider: (l = t == null ? void 0 : t.keybindingProvider) !== null && l !== void 0 ? l : (c) => i.lookupKeybinding(c.id)
    };
    super(e, { getActions: () => e.actions }, n, d), this._keybindingService = i, this._contextMenuService = n, this._themeService = s;
  }
  render(e) {
    super.render(e), ct(this.element), e.classList.add("menu-entry");
    const t = this._action, { icon: i } = t.item;
    if (i && !Le.isThemeIcon(i)) {
      this.element.classList.add("icon");
      const n = () => {
        this.element && (this.element.style.backgroundImage = jf(this._themeService.getColorTheme().type) ? hd(i.dark) : hd(i.light));
      };
      n(), this._register(this._themeService.onDidColorThemeChange(() => {
        n();
      }));
    }
  }
};
qI = J0([
  Cs(2, _t),
  Cs(3, Zs),
  Cs(4, $i)
], qI);
let GI = class extends Rr {
  constructor(e, t, i, n, s, o, a, l) {
    var d, c, h;
    super(null, e), this._keybindingService = i, this._notificationService = n, this._contextMenuService = s, this._menuService = o, this._instaService = a, this._storageService = l, this._container = null, this._options = t, this._storageKey = `${e.item.submenu.id}_lastActionId`;
    let u;
    const g = t != null && t.persistLastActionId ? l.get(
      this._storageKey,
      1
      /* StorageScope.WORKSPACE */
    ) : void 0;
    g && (u = e.actions.find((m) => g === m.id)), u || (u = e.actions[0]), this._defaultAction = this._instaService.createInstance(Hc, u, { keybinding: this._getDefaultActionKeybindingLabel(u) });
    const f = {
      keybindingProvider: (m) => this._keybindingService.lookupKeybinding(m.id),
      ...t,
      menuAsChild: (d = t == null ? void 0 : t.menuAsChild) !== null && d !== void 0 ? d : !0,
      classNames: (c = t == null ? void 0 : t.classNames) !== null && c !== void 0 ? c : ["codicon", "codicon-chevron-down"],
      actionRunner: (h = t == null ? void 0 : t.actionRunner) !== null && h !== void 0 ? h : new wu()
    };
    this._dropdown = new qS(e, e.actions, this._contextMenuService, f), this._register(this._dropdown.actionRunner.onDidRun((m) => {
      m.action instanceof Hs && this.update(m.action);
    }));
  }
  update(e) {
    var t;
    !((t = this._options) === null || t === void 0) && t.persistLastActionId && this._storageService.store(
      this._storageKey,
      e.id,
      1,
      1
      /* StorageTarget.MACHINE */
    ), this._defaultAction.dispose(), this._defaultAction = this._instaService.createInstance(Hc, e, { keybinding: this._getDefaultActionKeybindingLabel(e) }), this._defaultAction.actionRunner = new class extends wu {
      async runAction(i, n) {
        await i.run(void 0);
      }
    }(), this._container && this._defaultAction.render(r1(this._container, X(".action-container")));
  }
  _getDefaultActionKeybindingLabel(e) {
    var t;
    let i;
    if (!((t = this._options) === null || t === void 0) && t.renderKeybindingWithDefaultActionLabel) {
      const n = this._keybindingService.lookupKeybinding(e.id);
      n && (i = `(${n.getLabel()})`);
    }
    return i;
  }
  setActionContext(e) {
    super.setActionContext(e), this._defaultAction.setActionContext(e), this._dropdown.setActionContext(e);
  }
  render(e) {
    this._container = e, super.render(this._container), this._container.classList.add("monaco-dropdown-with-default");
    const t = X(".action-container");
    this._defaultAction.render(G(this._container, t)), this._register(W(t, Q.KEY_DOWN, (n) => {
      const s = new Mt(n);
      s.equals(
        17
        /* KeyCode.RightArrow */
      ) && (this._defaultAction.element.tabIndex = -1, this._dropdown.focus(), s.stopPropagation());
    }));
    const i = X(".dropdown-action-container");
    this._dropdown.render(G(this._container, i)), this._register(W(i, Q.KEY_DOWN, (n) => {
      var s;
      const o = new Mt(n);
      o.equals(
        15
        /* KeyCode.LeftArrow */
      ) && (this._defaultAction.element.tabIndex = 0, this._dropdown.setFocusable(!1), (s = this._defaultAction.element) === null || s === void 0 || s.focus(), o.stopPropagation());
    }));
  }
  focus(e) {
    e ? this._dropdown.focus() : (this._defaultAction.element.tabIndex = 0, this._defaultAction.element.focus());
  }
  blur() {
    this._defaultAction.element.tabIndex = -1, this._dropdown.blur(), this._container.blur();
  }
  setFocusable(e) {
    e ? this._defaultAction.element.tabIndex = 0 : (this._defaultAction.element.tabIndex = -1, this._dropdown.setFocusable(!1));
  }
  dispose() {
    this._defaultAction.dispose(), this._dropdown.dispose(), super.dispose();
  }
};
GI = J0([
  Cs(2, _t),
  Cs(3, xi),
  Cs(4, Zs),
  Cs(5, vo),
  Cs(6, be),
  Cs(7, br)
], GI);
let ZI = class extends Hie {
  constructor(e, t) {
    super(null, e, e.actions.map((i) => ({
      text: i.id === Oi.ID ? "" : i.label,
      isDisabled: !i.enabled
    })), 0, t, Xie, { ariaLabel: e.tooltip, optionsAsChildren: !0 }), this.select(Math.max(0, e.actions.findIndex((i) => i.checked)));
  }
  render(e) {
    super.render(e), e.style.borderColor = le(Gg);
  }
  runAction(e, t) {
    const i = this.action.actions[t];
    i && this.actionRunner.run(i);
  }
};
ZI = J0([
  Cs(1, Sd)
], ZI);
function Rz(r, e, t) {
  return e instanceof Hs ? r.createInstance(Hc, e, t) : e instanceof gf ? e.item.isSelection ? r.createInstance(ZI, e) : e.item.rememberDefaultAction ? r.createInstance(GI, e, { ...t, persistLastActionId: !0 }) : r.createInstance(qI, e, t) : void 0;
}
class Bo extends P {
  constructor(e, t = {}) {
    var i, n, s, o, a, l, d;
    super(), this._actionRunnerDisposables = this._register(new q()), this.viewItemDisposables = this._register(new KN()), this.triggerKeyDown = !1, this.focusable = !0, this._onDidBlur = this._register(new R()), this.onDidBlur = this._onDidBlur.event, this._onDidCancel = this._register(new R({ onWillAddFirstListener: () => this.cancelHasListener = !0 })), this.onDidCancel = this._onDidCancel.event, this.cancelHasListener = !1, this._onDidRun = this._register(new R()), this.onDidRun = this._onDidRun.event, this._onWillRun = this._register(new R()), this.onWillRun = this._onWillRun.event, this.options = t, this._context = (i = t.context) !== null && i !== void 0 ? i : null, this._orientation = (n = this.options.orientation) !== null && n !== void 0 ? n : 0, this._triggerKeys = {
      keyDown: (o = (s = this.options.triggerKeys) === null || s === void 0 ? void 0 : s.keyDown) !== null && o !== void 0 ? o : !1,
      keys: (l = (a = this.options.triggerKeys) === null || a === void 0 ? void 0 : a.keys) !== null && l !== void 0 ? l : [
        3,
        10
        /* KeyCode.Space */
      ]
    }, this._hoverDelegate = (d = t.hoverDelegate) !== null && d !== void 0 ? d : this._register(np()), this.options.actionRunner ? this._actionRunner = this.options.actionRunner : (this._actionRunner = new wu(), this._actionRunnerDisposables.add(this._actionRunner)), this._actionRunnerDisposables.add(this._actionRunner.onDidRun((u) => this._onDidRun.fire(u))), this._actionRunnerDisposables.add(this._actionRunner.onWillRun((u) => this._onWillRun.fire(u))), this.viewItems = [], this.focusedItem = void 0, this.domNode = document.createElement("div"), this.domNode.className = "monaco-action-bar";
    let c, h;
    switch (this._orientation) {
      case 0:
        c = [
          15
          /* KeyCode.LeftArrow */
        ], h = [
          17
          /* KeyCode.RightArrow */
        ];
        break;
      case 1:
        c = [
          16
          /* KeyCode.UpArrow */
        ], h = [
          18
          /* KeyCode.DownArrow */
        ], this.domNode.className += " vertical";
        break;
    }
    this._register(W(this.domNode, Q.KEY_DOWN, (u) => {
      const g = new Mt(u);
      let f = !0;
      const m = typeof this.focusedItem == "number" ? this.viewItems[this.focusedItem] : void 0;
      c && (g.equals(c[0]) || g.equals(c[1])) ? f = this.focusPrevious() : h && (g.equals(h[0]) || g.equals(h[1])) ? f = this.focusNext() : g.equals(
        9
        /* KeyCode.Escape */
      ) && this.cancelHasListener ? this._onDidCancel.fire() : g.equals(
        14
        /* KeyCode.Home */
      ) ? f = this.focusFirst() : g.equals(
        13
        /* KeyCode.End */
      ) ? f = this.focusLast() : g.equals(
        2
        /* KeyCode.Tab */
      ) && m instanceof Rr && m.trapsArrowNavigation ? f = this.focusNext() : this.isTriggerKeyEvent(g) ? this._triggerKeys.keyDown ? this.doTrigger(g) : this.triggerKeyDown = !0 : f = !1, f && (g.preventDefault(), g.stopPropagation());
    })), this._register(W(this.domNode, Q.KEY_UP, (u) => {
      const g = new Mt(u);
      this.isTriggerKeyEvent(g) ? (!this._triggerKeys.keyDown && this.triggerKeyDown && (this.triggerKeyDown = !1, this.doTrigger(g)), g.preventDefault(), g.stopPropagation()) : (g.equals(
        2
        /* KeyCode.Tab */
      ) || g.equals(
        1026
        /* KeyCode.Tab */
      ) || g.equals(
        16
        /* KeyCode.UpArrow */
      ) || g.equals(
        18
        /* KeyCode.DownArrow */
      ) || g.equals(
        15
        /* KeyCode.LeftArrow */
      ) || g.equals(
        17
        /* KeyCode.RightArrow */
      )) && this.updateFocusedItem();
    })), this.focusTracker = this._register(Xr(this.domNode)), this._register(this.focusTracker.onDidBlur(() => {
      (Ln() === this.domNode || !qi(Ln(), this.domNode)) && (this._onDidBlur.fire(), this.previouslyFocusedItem = this.focusedItem, this.focusedItem = void 0, this.triggerKeyDown = !1);
    })), this._register(this.focusTracker.onDidFocus(() => this.updateFocusedItem())), this.actionsList = document.createElement("ul"), this.actionsList.className = "actions-container", this.options.highlightToggledItems && this.actionsList.classList.add("highlight-toggled"), this.actionsList.setAttribute("role", this.options.ariaRole || "toolbar"), this.options.ariaLabel && this.actionsList.setAttribute("aria-label", this.options.ariaLabel), this.domNode.appendChild(this.actionsList), e.appendChild(this.domNode);
  }
  refreshRole() {
    this.length() >= 1 ? this.actionsList.setAttribute("role", this.options.ariaRole || "toolbar") : this.actionsList.setAttribute("role", "presentation");
  }
  // Some action bars should not be focusable at times
  // When an action bar is not focusable make sure to make all the elements inside it not focusable
  // When an action bar is focusable again, make sure the first item can be focused
  setFocusable(e) {
    if (this.focusable = e, this.focusable) {
      const t = this.viewItems.find((i) => i instanceof Rr && i.isEnabled());
      t instanceof Rr && t.setFocusable(!0);
    } else
      this.viewItems.forEach((t) => {
        t instanceof Rr && t.setFocusable(!1);
      });
  }
  isTriggerKeyEvent(e) {
    let t = !1;
    return this._triggerKeys.keys.forEach((i) => {
      t = t || e.equals(i);
    }), t;
  }
  updateFocusedItem() {
    var e, t;
    for (let i = 0; i < this.actionsList.children.length; i++) {
      const n = this.actionsList.children[i];
      if (qi(Ln(), n)) {
        this.focusedItem = i, (t = (e = this.viewItems[this.focusedItem]) === null || e === void 0 ? void 0 : e.showHover) === null || t === void 0 || t.call(e);
        break;
      }
    }
  }
  get context() {
    return this._context;
  }
  set context(e) {
    this._context = e, this.viewItems.forEach((t) => t.setActionContext(e));
  }
  get actionRunner() {
    return this._actionRunner;
  }
  set actionRunner(e) {
    this._actionRunner = e, this._actionRunnerDisposables.clear(), this._actionRunnerDisposables.add(this._actionRunner.onDidRun((t) => this._onDidRun.fire(t))), this._actionRunnerDisposables.add(this._actionRunner.onWillRun((t) => this._onWillRun.fire(t))), this.viewItems.forEach((t) => t.actionRunner = e);
  }
  getContainer() {
    return this.domNode;
  }
  getAction(e) {
    var t;
    if (typeof e == "number")
      return (t = this.viewItems[e]) === null || t === void 0 ? void 0 : t.action;
    if (ln(e)) {
      for (; e.parentElement !== this.actionsList; ) {
        if (!e.parentElement)
          return;
        e = e.parentElement;
      }
      for (let i = 0; i < this.actionsList.childNodes.length; i++)
        if (this.actionsList.childNodes[i] === e)
          return this.viewItems[i].action;
    }
  }
  push(e, t = {}) {
    const i = Array.isArray(e) ? e : [e];
    let n = Ic(t.index) ? t.index : null;
    i.forEach((s) => {
      const o = document.createElement("li");
      o.className = "action-item", o.setAttribute("role", "presentation");
      let a;
      const l = { hoverDelegate: this._hoverDelegate, ...t };
      this.options.actionViewItemProvider && (a = this.options.actionViewItemProvider(s, l)), a || (a = new sp(this.context, s, l)), this.options.allowContextMenu || this.viewItemDisposables.set(a, W(o, Q.CONTEXT_MENU, (d) => {
        nt.stop(d, !0);
      })), a.actionRunner = this._actionRunner, a.setActionContext(this.context), a.render(o), this.focusable && a instanceof Rr && this.viewItems.length === 0 && a.setFocusable(!0), n === null || n < 0 || n >= this.actionsList.children.length ? (this.actionsList.appendChild(o), this.viewItems.push(a)) : (this.actionsList.insertBefore(o, this.actionsList.children[n]), this.viewItems.splice(n, 0, a), n++);
    }), typeof this.focusedItem == "number" && this.focus(this.focusedItem), this.refreshRole();
  }
  clear() {
    this.isEmpty() || (this.viewItems = zt(this.viewItems), this.viewItemDisposables.clearAndDisposeAll(), pn(this.actionsList), this.refreshRole());
  }
  length() {
    return this.viewItems.length;
  }
  isEmpty() {
    return this.viewItems.length === 0;
  }
  focus(e) {
    let t = !1, i;
    if (e === void 0 ? t = !0 : typeof e == "number" ? i = e : typeof e == "boolean" && (t = e), t && typeof this.focusedItem > "u") {
      const n = this.viewItems.findIndex((s) => s.isEnabled());
      this.focusedItem = n === -1 ? void 0 : n, this.updateFocus(void 0, void 0, !0);
    } else
      i !== void 0 && (this.focusedItem = i), this.updateFocus(void 0, void 0, !0);
  }
  focusFirst() {
    return this.focusedItem = this.length() - 1, this.focusNext(!0);
  }
  focusLast() {
    return this.focusedItem = 0, this.focusPrevious(!0);
  }
  focusNext(e) {
    if (typeof this.focusedItem > "u")
      this.focusedItem = this.viewItems.length - 1;
    else if (this.viewItems.length <= 1)
      return !1;
    const t = this.focusedItem;
    let i;
    do {
      if (!e && this.options.preventLoopNavigation && this.focusedItem + 1 >= this.viewItems.length)
        return this.focusedItem = t, !1;
      this.focusedItem = (this.focusedItem + 1) % this.viewItems.length, i = this.viewItems[this.focusedItem];
    } while (this.focusedItem !== t && (this.options.focusOnlyEnabledItems && !i.isEnabled() || i.action.id === Oi.ID));
    return this.updateFocus(), !0;
  }
  focusPrevious(e) {
    if (typeof this.focusedItem > "u")
      this.focusedItem = 0;
    else if (this.viewItems.length <= 1)
      return !1;
    const t = this.focusedItem;
    let i;
    do {
      if (this.focusedItem = this.focusedItem - 1, this.focusedItem < 0) {
        if (!e && this.options.preventLoopNavigation)
          return this.focusedItem = t, !1;
        this.focusedItem = this.viewItems.length - 1;
      }
      i = this.viewItems[this.focusedItem];
    } while (this.focusedItem !== t && (this.options.focusOnlyEnabledItems && !i.isEnabled() || i.action.id === Oi.ID));
    return this.updateFocus(!0), !0;
  }
  updateFocus(e, t, i = !1) {
    var n, s;
    typeof this.focusedItem > "u" && this.actionsList.focus({ preventScroll: t }), this.previouslyFocusedItem !== void 0 && this.previouslyFocusedItem !== this.focusedItem && ((n = this.viewItems[this.previouslyFocusedItem]) === null || n === void 0 || n.blur());
    const o = this.focusedItem !== void 0 ? this.viewItems[this.focusedItem] : void 0;
    if (o) {
      let a = !0;
      aS(o.focus) || (a = !1), this.options.focusOnlyEnabledItems && aS(o.isEnabled) && !o.isEnabled() && (a = !1), o.action.id === Oi.ID && (a = !1), a ? (i || this.previouslyFocusedItem !== this.focusedItem) && (o.focus(e), this.previouslyFocusedItem = this.focusedItem) : (this.actionsList.focus({ preventScroll: t }), this.previouslyFocusedItem = void 0), a && ((s = o.showHover) === null || s === void 0 || s.call(o));
    }
  }
  doTrigger(e) {
    if (typeof this.focusedItem > "u")
      return;
    const t = this.viewItems[this.focusedItem];
    if (t instanceof Rr) {
      const i = t._context === null || t._context === void 0 ? e : t._context;
      this.run(t._action, i);
    }
  }
  async run(e, t) {
    await this._actionRunner.run(e, t);
  }
  dispose() {
    this._context = void 0, this.viewItems = zt(this.viewItems), this.getContainer().remove(), super.dispose();
  }
}
const YI = /\(&([^\s&])\)|(^|[^&])&([^\s&])/, kk = /(&amp;)?(&amp;)([^\s&])/g;
var YS;
(function(r) {
  r[r.Right = 0] = "Right", r[r.Left = 1] = "Left";
})(YS || (YS = {}));
var QI;
(function(r) {
  r[r.Above = 0] = "Above", r[r.Below = 1] = "Below";
})(QI || (QI = {}));
class Tf extends Bo {
  constructor(e, t, i, n) {
    e.classList.add("monaco-menu-container"), e.setAttribute("role", "presentation");
    const s = document.createElement("div");
    s.classList.add("monaco-menu"), s.setAttribute("role", "presentation"), super(s, {
      orientation: 1,
      actionViewItemProvider: (d) => this.doGetActionViewItem(d, i, o),
      context: i.context,
      actionRunner: i.actionRunner,
      ariaLabel: i.ariaLabel,
      ariaRole: "menu",
      focusOnlyEnabledItems: !0,
      triggerKeys: { keys: [3, ...Je || os ? [
        10
        /* KeyCode.Space */
      ] : []], keyDown: !0 }
    }), this.menuStyles = n, this.menuElement = s, this.actionsList.tabIndex = 0, this.initializeOrUpdateStyleSheet(e, n), this._register(At.addTarget(s)), this._register(W(s, Q.KEY_DOWN, (d) => {
      new Mt(d).equals(
        2
        /* KeyCode.Tab */
      ) && d.preventDefault();
    })), i.enableMnemonics && this._register(W(s, Q.KEY_DOWN, (d) => {
      const c = d.key.toLocaleLowerCase();
      if (this.mnemonics.has(c)) {
        nt.stop(d, !0);
        const h = this.mnemonics.get(c);
        if (h.length === 1 && (h[0] instanceof nF && h[0].container && this.focusItemByElement(h[0].container), h[0].onClick(d)), h.length > 1) {
          const u = h.shift();
          u && u.container && (this.focusItemByElement(u.container), h.push(u)), this.mnemonics.set(c, h);
        }
      }
    })), os && this._register(W(s, Q.KEY_DOWN, (d) => {
      const c = new Mt(d);
      c.equals(
        14
        /* KeyCode.Home */
      ) || c.equals(
        11
        /* KeyCode.PageUp */
      ) ? (this.focusedItem = this.viewItems.length - 1, this.focusNext(), nt.stop(d, !0)) : (c.equals(
        13
        /* KeyCode.End */
      ) || c.equals(
        12
        /* KeyCode.PageDown */
      )) && (this.focusedItem = 0, this.focusPrevious(), nt.stop(d, !0));
    })), this._register(W(this.domNode, Q.MOUSE_OUT, (d) => {
      const c = d.relatedTarget;
      qi(c, this.domNode) || (this.focusedItem = void 0, this.updateFocus(), d.stopPropagation());
    })), this._register(W(this.actionsList, Q.MOUSE_OVER, (d) => {
      let c = d.target;
      if (!(!c || !qi(c, this.actionsList) || c === this.actionsList)) {
        for (; c.parentElement !== this.actionsList && c.parentElement !== null; )
          c = c.parentElement;
        if (c.classList.contains("action-item")) {
          const h = this.focusedItem;
          this.setFocusedItem(c), h !== this.focusedItem && this.updateFocus();
        }
      }
    })), this._register(At.addTarget(this.actionsList)), this._register(W(this.actionsList, Pt.Tap, (d) => {
      let c = d.initialTarget;
      if (!(!c || !qi(c, this.actionsList) || c === this.actionsList)) {
        for (; c.parentElement !== this.actionsList && c.parentElement !== null; )
          c = c.parentElement;
        if (c.classList.contains("action-item")) {
          const h = this.focusedItem;
          this.setFocusedItem(c), h !== this.focusedItem && this.updateFocus();
        }
      }
    }));
    const o = {
      parent: this
    };
    this.mnemonics = /* @__PURE__ */ new Map(), this.scrollableElement = this._register(new pb(s, {
      alwaysConsumeMouseWheel: !0,
      horizontal: 2,
      vertical: 3,
      verticalScrollbarSize: 7,
      handleMouseWheel: !0,
      useShadows: !0
    }));
    const a = this.scrollableElement.getDomNode();
    a.style.position = "", this.styleScrollElement(a, n), this._register(W(s, Pt.Change, (d) => {
      nt.stop(d, !0);
      const c = this.scrollableElement.getScrollPosition().scrollTop;
      this.scrollableElement.setScrollPosition({ scrollTop: c - d.translationY });
    })), this._register(W(a, Q.MOUSE_UP, (d) => {
      d.preventDefault();
    }));
    const l = we(e);
    s.style.maxHeight = `${Math.max(10, l.innerHeight - e.getBoundingClientRect().top - 35)}px`, t = t.filter((d, c) => {
      var h;
      return !((h = i.submenuIds) === null || h === void 0) && h.has(d.id) ? (console.warn(`Found submenu cycle: ${d.id}`), !1) : !(d instanceof Oi && (c === t.length - 1 || c === 0 || t[c - 1] instanceof Oi));
    }), this.push(t, { icon: !0, label: !0, isMenu: !0 }), e.appendChild(this.scrollableElement.getDomNode()), this.scrollableElement.scanDomNode(), this.viewItems.filter((d) => !(d instanceof sF)).forEach((d, c, h) => {
      d.updatePositionInSet(c + 1, h.length);
    });
  }
  initializeOrUpdateStyleSheet(e, t) {
    this.styleSheet || (uS(e) ? this.styleSheet = fo(e) : (Tf.globalStyleSheet || (Tf.globalStyleSheet = fo()), this.styleSheet = Tf.globalStyleSheet)), this.styleSheet.textContent = ine(t, uS(e));
  }
  styleScrollElement(e, t) {
    var i, n;
    const s = (i = t.foregroundColor) !== null && i !== void 0 ? i : "", o = (n = t.backgroundColor) !== null && n !== void 0 ? n : "", a = t.borderColor ? `1px solid ${t.borderColor}` : "", l = "5px", d = t.shadowColor ? `0 2px 8px ${t.shadowColor}` : "";
    e.style.outline = a, e.style.borderRadius = l, e.style.color = s, e.style.backgroundColor = o, e.style.boxShadow = d;
  }
  getContainer() {
    return this.scrollableElement.getDomNode();
  }
  get onScroll() {
    return this.scrollableElement.onScroll;
  }
  focusItemByElement(e) {
    const t = this.focusedItem;
    this.setFocusedItem(e), t !== this.focusedItem && this.updateFocus();
  }
  setFocusedItem(e) {
    for (let t = 0; t < this.actionsList.children.length; t++) {
      const i = this.actionsList.children[t];
      if (e === i) {
        this.focusedItem = t;
        break;
      }
    }
  }
  updateFocus(e) {
    super.updateFocus(e, !0, !0), typeof this.focusedItem < "u" && this.scrollableElement.setScrollPosition({
      scrollTop: Math.round(this.menuElement.scrollTop)
    });
  }
  doGetActionViewItem(e, t, i) {
    if (e instanceof Oi)
      return new sF(t.context, e, { icon: !0 }, this.menuStyles);
    if (e instanceof Bf) {
      const n = new nF(e, e.actions, i, { ...t, submenuIds: /* @__PURE__ */ new Set([...t.submenuIds || [], e.id]) }, this.menuStyles);
      if (t.enableMnemonics) {
        const s = n.getMnemonic();
        if (s && n.isEnabled()) {
          let o = [];
          this.mnemonics.has(s) && (o = this.mnemonics.get(s)), o.push(n), this.mnemonics.set(s, o);
        }
      }
      return n;
    } else {
      const n = { enableMnemonics: t.enableMnemonics, useEventAsContext: t.useEventAsContext };
      if (t.getKeyBinding) {
        const o = t.getKeyBinding(e);
        if (o) {
          const a = o.getLabel();
          a && (n.keybinding = a);
        }
      }
      const s = new Az(t.context, e, n, this.menuStyles);
      if (t.enableMnemonics) {
        const o = s.getMnemonic();
        if (o && s.isEnabled()) {
          let a = [];
          this.mnemonics.has(o) && (a = this.mnemonics.get(o)), a.push(s), this.mnemonics.set(o, a);
        }
      }
      return s;
    }
  }
}
class Az extends Rr {
  constructor(e, t, i, n) {
    if (i.isMenu = !0, super(t, t, i), this.menuStyle = n, this.options = i, this.options.icon = i.icon !== void 0 ? i.icon : !1, this.options.label = i.label !== void 0 ? i.label : !0, this.cssClass = "", this.options.label && i.enableMnemonics) {
      const s = this.action.label;
      if (s) {
        const o = YI.exec(s);
        o && (this.mnemonic = (o[1] ? o[1] : o[3]).toLocaleLowerCase());
      }
    }
    this.runOnceToEnableMouseUp = new xt(() => {
      this.element && (this._register(W(this.element, Q.MOUSE_UP, (s) => {
        if (nt.stop(s, !0), Oo) {
          if (new rr(we(this.element), s).rightButton)
            return;
          this.onClick(s);
        } else
          setTimeout(() => {
            this.onClick(s);
          }, 0);
      })), this._register(W(this.element, Q.CONTEXT_MENU, (s) => {
        nt.stop(s, !0);
      })));
    }, 100), this._register(this.runOnceToEnableMouseUp);
  }
  render(e) {
    super.render(e), this.element && (this.container = e, this.item = G(this.element, X("a.action-menu-item")), this._action.id === Oi.ID ? this.item.setAttribute("role", "presentation") : (this.item.setAttribute("role", "menuitem"), this.mnemonic && this.item.setAttribute("aria-keyshortcuts", `${this.mnemonic}`)), this.check = G(this.item, X("span.menu-item-check" + Le.asCSSSelector(me.menuSelection))), this.check.setAttribute("role", "none"), this.label = G(this.item, X("span.action-label")), this.options.label && this.options.keybinding && (G(this.item, X("span.keybinding")).textContent = this.options.keybinding), this.runOnceToEnableMouseUp.schedule(), this.updateClass(), this.updateLabel(), this.updateTooltip(), this.updateEnabled(), this.updateChecked(), this.applyStyle());
  }
  blur() {
    super.blur(), this.applyStyle();
  }
  focus() {
    var e;
    super.focus(), (e = this.item) === null || e === void 0 || e.focus(), this.applyStyle();
  }
  updatePositionInSet(e, t) {
    this.item && (this.item.setAttribute("aria-posinset", `${e}`), this.item.setAttribute("aria-setsize", `${t}`));
  }
  updateLabel() {
    var e;
    if (this.label && this.options.label) {
      pn(this.label);
      let t = cM(this.action.label);
      if (t) {
        const i = tne(t);
        this.options.enableMnemonics || (t = i), this.label.setAttribute("aria-label", i.replace(/&&/g, "&"));
        const n = YI.exec(t);
        if (n) {
          t = Ym(t), kk.lastIndex = 0;
          let s = kk.exec(t);
          for (; s && s[1]; )
            s = kk.exec(t);
          const o = (a) => a.replace(/&amp;&amp;/g, "&amp;");
          s ? this.label.append(i0(o(t.substr(0, s.index)), " "), X("u", { "aria-hidden": "true" }, s[3]), B5(o(t.substr(s.index + s[0].length)), " ")) : this.label.innerText = o(t).trim(), (e = this.item) === null || e === void 0 || e.setAttribute("aria-keyshortcuts", (n[1] ? n[1] : n[3]).toLocaleLowerCase());
        } else
          this.label.innerText = t.replace(/&&/g, "&").trim();
      }
    }
  }
  updateTooltip() {
  }
  updateClass() {
    this.cssClass && this.item && this.item.classList.remove(...this.cssClass.split(" ")), this.options.icon && this.label ? (this.cssClass = this.action.class || "", this.label.classList.add("icon"), this.cssClass && this.label.classList.add(...this.cssClass.split(" ")), this.updateEnabled()) : this.label && this.label.classList.remove("icon");
  }
  updateEnabled() {
    this.action.enabled ? (this.element && (this.element.classList.remove("disabled"), this.element.removeAttribute("aria-disabled")), this.item && (this.item.classList.remove("disabled"), this.item.removeAttribute("aria-disabled"), this.item.tabIndex = 0)) : (this.element && (this.element.classList.add("disabled"), this.element.setAttribute("aria-disabled", "true")), this.item && (this.item.classList.add("disabled"), this.item.setAttribute("aria-disabled", "true")));
  }
  updateChecked() {
    if (!this.item)
      return;
    const e = this.action.checked;
    this.item.classList.toggle("checked", !!e), e !== void 0 ? (this.item.setAttribute("role", "menuitemcheckbox"), this.item.setAttribute("aria-checked", e ? "true" : "false")) : (this.item.setAttribute("role", "menuitem"), this.item.setAttribute("aria-checked", ""));
  }
  getMnemonic() {
    return this.mnemonic;
  }
  applyStyle() {
    const e = this.element && this.element.classList.contains("focused"), t = e && this.menuStyle.selectionForegroundColor ? this.menuStyle.selectionForegroundColor : this.menuStyle.foregroundColor, i = e && this.menuStyle.selectionBackgroundColor ? this.menuStyle.selectionBackgroundColor : void 0, n = e && this.menuStyle.selectionBorderColor ? `1px solid ${this.menuStyle.selectionBorderColor}` : "", s = e && this.menuStyle.selectionBorderColor ? "-1px" : "";
    this.item && (this.item.style.color = t ?? "", this.item.style.backgroundColor = i ?? "", this.item.style.outline = n, this.item.style.outlineOffset = s), this.check && (this.check.style.color = t ?? "");
  }
}
class nF extends Az {
  constructor(e, t, i, n, s) {
    super(e, e, n, s), this.submenuActions = t, this.parentData = i, this.submenuOptions = n, this.mysubmenu = null, this.submenuDisposables = this._register(new q()), this.mouseOver = !1, this.expandDirection = n && n.expandDirection !== void 0 ? n.expandDirection : { horizontal: YS.Right, vertical: QI.Below }, this.showScheduler = new xt(() => {
      this.mouseOver && (this.cleanupExistingSubmenu(!1), this.createSubmenu(!1));
    }, 250), this.hideScheduler = new xt(() => {
      this.element && !qi(Ln(), this.element) && this.parentData.submenu === this.mysubmenu && (this.parentData.parent.focus(!1), this.cleanupExistingSubmenu(!0));
    }, 750);
  }
  render(e) {
    super.render(e), this.element && (this.item && (this.item.classList.add("monaco-submenu-item"), this.item.tabIndex = 0, this.item.setAttribute("aria-haspopup", "true"), this.updateAriaExpanded("false"), this.submenuIndicator = G(this.item, X("span.submenu-indicator" + Le.asCSSSelector(me.menuSubmenu))), this.submenuIndicator.setAttribute("aria-hidden", "true")), this._register(W(this.element, Q.KEY_UP, (t) => {
      const i = new Mt(t);
      (i.equals(
        17
        /* KeyCode.RightArrow */
      ) || i.equals(
        3
        /* KeyCode.Enter */
      )) && (nt.stop(t, !0), this.createSubmenu(!0));
    })), this._register(W(this.element, Q.KEY_DOWN, (t) => {
      const i = new Mt(t);
      Ln() === this.item && (i.equals(
        17
        /* KeyCode.RightArrow */
      ) || i.equals(
        3
        /* KeyCode.Enter */
      )) && nt.stop(t, !0);
    })), this._register(W(this.element, Q.MOUSE_OVER, (t) => {
      this.mouseOver || (this.mouseOver = !0, this.showScheduler.schedule());
    })), this._register(W(this.element, Q.MOUSE_LEAVE, (t) => {
      this.mouseOver = !1;
    })), this._register(W(this.element, Q.FOCUS_OUT, (t) => {
      this.element && !qi(Ln(), this.element) && this.hideScheduler.schedule();
    })), this._register(this.parentData.parent.onScroll(() => {
      this.parentData.submenu === this.mysubmenu && (this.parentData.parent.focus(!1), this.cleanupExistingSubmenu(!0));
    })));
  }
  updateEnabled() {
  }
  onClick(e) {
    nt.stop(e, !0), this.cleanupExistingSubmenu(!1), this.createSubmenu(!0);
  }
  cleanupExistingSubmenu(e) {
    if (this.parentData.submenu && (e || this.parentData.submenu !== this.mysubmenu)) {
      try {
        this.parentData.submenu.dispose();
      } catch {
      }
      this.parentData.submenu = void 0, this.updateAriaExpanded("false"), this.submenuContainer && (this.submenuDisposables.clear(), this.submenuContainer = void 0);
    }
  }
  calculateSubmenuMenuLayout(e, t, i, n) {
    const s = { top: 0, left: 0 };
    return s.left = ef(e.width, t.width, { position: n.horizontal === YS.Right ? 0 : 1, offset: i.left, size: i.width }), s.left >= i.left && s.left < i.left + i.width && (i.left + 10 + t.width <= e.width && (s.left = i.left + 10), i.top += 10, i.height = 0), s.top = ef(e.height, t.height, { position: 0, offset: i.top, size: 0 }), s.top + t.height === i.top && s.top + i.height + t.height <= e.height && (s.top += i.height), s;
  }
  createSubmenu(e = !0) {
    if (this.element)
      if (this.parentData.submenu)
        this.parentData.submenu.focus(!1);
      else {
        this.updateAriaExpanded("true"), this.submenuContainer = G(this.element, X("div.monaco-submenu")), this.submenuContainer.classList.add("menubar-menu-items-holder", "context-view");
        const t = we(this.parentData.parent.domNode).getComputedStyle(this.parentData.parent.domNode), i = parseFloat(t.paddingTop || "0") || 0;
        this.submenuContainer.style.zIndex = "1", this.submenuContainer.style.position = "fixed", this.submenuContainer.style.top = "0", this.submenuContainer.style.left = "0", this.parentData.submenu = new Tf(this.submenuContainer, this.submenuActions.length ? this.submenuActions : [new l0()], this.submenuOptions, this.menuStyle);
        const n = this.element.getBoundingClientRect(), s = {
          top: n.top - i,
          left: n.left,
          height: n.height + 2 * i,
          width: n.width
        }, o = this.submenuContainer.getBoundingClientRect(), a = we(this.element), { top: l, left: d } = this.calculateSubmenuMenuLayout(new pt(a.innerWidth, a.innerHeight), pt.lift(o), s, this.expandDirection);
        this.submenuContainer.style.left = `${d - o.left}px`, this.submenuContainer.style.top = `${l - o.top}px`, this.submenuDisposables.add(W(this.submenuContainer, Q.KEY_UP, (c) => {
          new Mt(c).equals(
            15
            /* KeyCode.LeftArrow */
          ) && (nt.stop(c, !0), this.parentData.parent.focus(), this.cleanupExistingSubmenu(!0));
        })), this.submenuDisposables.add(W(this.submenuContainer, Q.KEY_DOWN, (c) => {
          new Mt(c).equals(
            15
            /* KeyCode.LeftArrow */
          ) && nt.stop(c, !0);
        })), this.submenuDisposables.add(this.parentData.submenu.onDidCancel(() => {
          this.parentData.parent.focus(), this.cleanupExistingSubmenu(!0);
        })), this.parentData.submenu.focus(e), this.mysubmenu = this.parentData.submenu;
      }
  }
  updateAriaExpanded(e) {
    var t;
    this.item && ((t = this.item) === null || t === void 0 || t.setAttribute("aria-expanded", e));
  }
  applyStyle() {
    super.applyStyle();
    const t = this.element && this.element.classList.contains("focused") && this.menuStyle.selectionForegroundColor ? this.menuStyle.selectionForegroundColor : this.menuStyle.foregroundColor;
    this.submenuIndicator && (this.submenuIndicator.style.color = t ?? "");
  }
  dispose() {
    super.dispose(), this.hideScheduler.dispose(), this.mysubmenu && (this.mysubmenu.dispose(), this.mysubmenu = null), this.submenuContainer && (this.submenuContainer = void 0);
  }
}
class sF extends sp {
  constructor(e, t, i, n) {
    super(e, t, i), this.menuStyles = n;
  }
  render(e) {
    super.render(e), this.label && (this.label.style.borderBottomColor = this.menuStyles.separatorColor ? `${this.menuStyles.separatorColor}` : "");
  }
}
function tne(r) {
  const e = YI, t = e.exec(r);
  if (!t)
    return r;
  const i = !t[1];
  return r.replace(e, i ? "$2$3" : "").trim();
}
function oF(r) {
  const e = lH()[r.id];
  return `.codicon-${r.id}:before { content: '\\${e.toString(16)}'; }`;
}
function ine(r, e) {
  let t = (
    /* css */
    `
.monaco-menu {
	font-size: 13px;
	border-radius: 5px;
	min-width: 160px;
}

${oF(me.menuSelection)}
${oF(me.menuSubmenu)}

.monaco-menu .monaco-action-bar {
	text-align: right;
	overflow: hidden;
	white-space: nowrap;
}

.monaco-menu .monaco-action-bar .actions-container {
	display: flex;
	margin: 0 auto;
	padding: 0;
	width: 100%;
	justify-content: flex-end;
}

.monaco-menu .monaco-action-bar.vertical .actions-container {
	display: inline-block;
}

.monaco-menu .monaco-action-bar.reverse .actions-container {
	flex-direction: row-reverse;
}

.monaco-menu .monaco-action-bar .action-item {
	cursor: pointer;
	display: inline-block;
	transition: transform 50ms ease;
	position: relative;  /* DO NOT REMOVE - this is the key to preventing the ghosting icon bug in Chrome 42 */
}

.monaco-menu .monaco-action-bar .action-item.disabled {
	cursor: default;
}

.monaco-menu .monaco-action-bar .action-item .icon,
.monaco-menu .monaco-action-bar .action-item .codicon {
	display: inline-block;
}

.monaco-menu .monaco-action-bar .action-item .codicon {
	display: flex;
	align-items: center;
}

.monaco-menu .monaco-action-bar .action-label {
	font-size: 11px;
	margin-right: 4px;
}

.monaco-menu .monaco-action-bar .action-item.disabled .action-label,
.monaco-menu .monaco-action-bar .action-item.disabled .action-label:hover {
	color: var(--vscode-disabledForeground);
}

/* Vertical actions */

.monaco-menu .monaco-action-bar.vertical {
	text-align: left;
}

.monaco-menu .monaco-action-bar.vertical .action-item {
	display: block;
}

.monaco-menu .monaco-action-bar.vertical .action-label.separator {
	display: block;
	border-bottom: 1px solid var(--vscode-menu-separatorBackground);
	padding-top: 1px;
	padding: 30px;
}

.monaco-menu .secondary-actions .monaco-action-bar .action-label {
	margin-left: 6px;
}

/* Action Items */
.monaco-menu .monaco-action-bar .action-item.select-container {
	overflow: hidden; /* somehow the dropdown overflows its container, we prevent it here to not push */
	flex: 1;
	max-width: 170px;
	min-width: 60px;
	display: flex;
	align-items: center;
	justify-content: center;
	margin-right: 10px;
}

.monaco-menu .monaco-action-bar.vertical {
	margin-left: 0;
	overflow: visible;
}

.monaco-menu .monaco-action-bar.vertical .actions-container {
	display: block;
}

.monaco-menu .monaco-action-bar.vertical .action-item {
	padding: 0;
	transform: none;
	display: flex;
}

.monaco-menu .monaco-action-bar.vertical .action-item.active {
	transform: none;
}

.monaco-menu .monaco-action-bar.vertical .action-menu-item {
	flex: 1 1 auto;
	display: flex;
	height: 2em;
	align-items: center;
	position: relative;
	margin: 0 4px;
	border-radius: 4px;
}

.monaco-menu .monaco-action-bar.vertical .action-menu-item:hover .keybinding,
.monaco-menu .monaco-action-bar.vertical .action-menu-item:focus .keybinding {
	opacity: unset;
}

.monaco-menu .monaco-action-bar.vertical .action-label {
	flex: 1 1 auto;
	text-decoration: none;
	padding: 0 1em;
	background: none;
	font-size: 12px;
	line-height: 1;
}

.monaco-menu .monaco-action-bar.vertical .keybinding,
.monaco-menu .monaco-action-bar.vertical .submenu-indicator {
	display: inline-block;
	flex: 2 1 auto;
	padding: 0 1em;
	text-align: right;
	font-size: 12px;
	line-height: 1;
}

.monaco-menu .monaco-action-bar.vertical .submenu-indicator {
	height: 100%;
}

.monaco-menu .monaco-action-bar.vertical .submenu-indicator.codicon {
	font-size: 16px !important;
	display: flex;
	align-items: center;
}

.monaco-menu .monaco-action-bar.vertical .submenu-indicator.codicon::before {
	margin-left: auto;
	margin-right: -20px;
}

.monaco-menu .monaco-action-bar.vertical .action-item.disabled .keybinding,
.monaco-menu .monaco-action-bar.vertical .action-item.disabled .submenu-indicator {
	opacity: 0.4;
}

.monaco-menu .monaco-action-bar.vertical .action-label:not(.separator) {
	display: inline-block;
	box-sizing: border-box;
	margin: 0;
}

.monaco-menu .monaco-action-bar.vertical .action-item {
	position: static;
	overflow: visible;
}

.monaco-menu .monaco-action-bar.vertical .action-item .monaco-submenu {
	position: absolute;
}

.monaco-menu .monaco-action-bar.vertical .action-label.separator {
	width: 100%;
	height: 0px !important;
	opacity: 1;
}

.monaco-menu .monaco-action-bar.vertical .action-label.separator.text {
	padding: 0.7em 1em 0.1em 1em;
	font-weight: bold;
	opacity: 1;
}

.monaco-menu .monaco-action-bar.vertical .action-label:hover {
	color: inherit;
}

.monaco-menu .monaco-action-bar.vertical .menu-item-check {
	position: absolute;
	visibility: hidden;
	width: 1em;
	height: 100%;
}

.monaco-menu .monaco-action-bar.vertical .action-menu-item.checked .menu-item-check {
	visibility: visible;
	display: flex;
	align-items: center;
	justify-content: center;
}

/* Context Menu */

.context-view.monaco-menu-container {
	outline: 0;
	border: none;
	animation: fadeIn 0.083s linear;
	-webkit-app-region: no-drag;
}

.context-view.monaco-menu-container :focus,
.context-view.monaco-menu-container .monaco-action-bar.vertical:focus,
.context-view.monaco-menu-container .monaco-action-bar.vertical :focus {
	outline: 0;
}

.hc-black .context-view.monaco-menu-container,
.hc-light .context-view.monaco-menu-container,
:host-context(.hc-black) .context-view.monaco-menu-container,
:host-context(.hc-light) .context-view.monaco-menu-container {
	box-shadow: none;
}

.hc-black .monaco-menu .monaco-action-bar.vertical .action-item.focused,
.hc-light .monaco-menu .monaco-action-bar.vertical .action-item.focused,
:host-context(.hc-black) .monaco-menu .monaco-action-bar.vertical .action-item.focused,
:host-context(.hc-light) .monaco-menu .monaco-action-bar.vertical .action-item.focused {
	background: none;
}

/* Vertical Action Bar Styles */

.monaco-menu .monaco-action-bar.vertical {
	padding: 4px 0;
}

.monaco-menu .monaco-action-bar.vertical .action-menu-item {
	height: 2em;
}

.monaco-menu .monaco-action-bar.vertical .action-label:not(.separator),
.monaco-menu .monaco-action-bar.vertical .keybinding {
	font-size: inherit;
	padding: 0 2em;
	max-height: 100%;
}

.monaco-menu .monaco-action-bar.vertical .menu-item-check {
	font-size: inherit;
	width: 2em;
}

.monaco-menu .monaco-action-bar.vertical .action-label.separator {
	font-size: inherit;
	margin: 5px 0 !important;
	padding: 0;
	border-radius: 0;
}

.linux .monaco-menu .monaco-action-bar.vertical .action-label.separator,
:host-context(.linux) .monaco-menu .monaco-action-bar.vertical .action-label.separator {
	margin-left: 0;
	margin-right: 0;
}

.monaco-menu .monaco-action-bar.vertical .submenu-indicator {
	font-size: 60%;
	padding: 0 1.8em;
}

.linux .monaco-menu .monaco-action-bar.vertical .submenu-indicator,
:host-context(.linux) .monaco-menu .monaco-action-bar.vertical .submenu-indicator {
	height: 100%;
	mask-size: 10px 10px;
	-webkit-mask-size: 10px 10px;
}

.monaco-menu .action-item {
	cursor: default;
}`
  );
  if (e) {
    t += `
			/* Arrows */
			.monaco-scrollable-element > .scrollbar > .scra {
				cursor: pointer;
				font-size: 11px !important;
			}

			.monaco-scrollable-element > .visible {
				opacity: 1;

				/* Background rule added for IE9 - to allow clicks on dom node */
				background:rgba(0,0,0,0);

				transition: opacity 100ms linear;
			}
			.monaco-scrollable-element > .invisible {
				opacity: 0;
				pointer-events: none;
			}
			.monaco-scrollable-element > .invisible.fade {
				transition: opacity 800ms linear;
			}

			/* Scrollable Content Inset Shadow */
			.monaco-scrollable-element > .shadow {
				position: absolute;
				display: none;
			}
			.monaco-scrollable-element > .shadow.top {
				display: block;
				top: 0;
				left: 3px;
				height: 3px;
				width: 100%;
			}
			.monaco-scrollable-element > .shadow.left {
				display: block;
				top: 3px;
				left: 0;
				height: 100%;
				width: 3px;
			}
			.monaco-scrollable-element > .shadow.top-left-corner {
				display: block;
				top: 0;
				left: 0;
				height: 3px;
				width: 3px;
			}
		`;
    const i = r.scrollbarShadow;
    i && (t += `
				.monaco-scrollable-element > .shadow.top {
					box-shadow: ${i} 0 6px 6px -6px inset;
				}

				.monaco-scrollable-element > .shadow.left {
					box-shadow: ${i} 6px 0 6px -6px inset;
				}

				.monaco-scrollable-element > .shadow.top.left {
					box-shadow: ${i} 6px 6px 6px -6px inset;
				}
			`);
    const n = r.scrollbarSliderBackground;
    n && (t += `
				.monaco-scrollable-element > .scrollbar > .slider {
					background: ${n};
				}
			`);
    const s = r.scrollbarSliderHoverBackground;
    s && (t += `
				.monaco-scrollable-element > .scrollbar > .slider:hover {
					background: ${s};
				}
			`);
    const o = r.scrollbarSliderActiveBackground;
    o && (t += `
				.monaco-scrollable-element > .scrollbar > .slider.active {
					background: ${o};
				}
			`);
  }
  return t;
}
class nne {
  constructor(e, t, i, n) {
    this.contextViewService = e, this.telemetryService = t, this.notificationService = i, this.keybindingService = n, this.focusToReturn = null, this.lastContainer = null, this.block = null, this.blockDisposable = null, this.options = { blockMouse: !0 };
  }
  configure(e) {
    this.options = e;
  }
  showContextMenu(e) {
    const t = e.getActions();
    if (!t.length)
      return;
    this.focusToReturn = Ln();
    let i;
    const n = ln(e.domForShadowRoot) ? e.domForShadowRoot : void 0;
    this.contextViewService.showContextView({
      getAnchor: () => e.getAnchor(),
      canRelayout: !1,
      anchorAlignment: e.anchorAlignment,
      anchorAxisAlignment: e.anchorAxisAlignment,
      render: (s) => {
        var o;
        this.lastContainer = s;
        const a = e.getMenuClassName ? e.getMenuClassName() : "";
        a && (s.className += " " + a), this.options.blockMouse && (this.block = s.appendChild(X(".context-view-block")), this.block.style.position = "fixed", this.block.style.cursor = "initial", this.block.style.left = "0", this.block.style.top = "0", this.block.style.width = "100%", this.block.style.height = "100%", this.block.style.zIndex = "-1", (o = this.blockDisposable) === null || o === void 0 || o.dispose(), this.blockDisposable = W(this.block, Q.MOUSE_DOWN, (h) => h.stopPropagation()));
        const l = new q(), d = e.actionRunner || new wu();
        d.onWillRun((h) => this.onActionRun(h, !e.skipTelemetry), this, l), d.onDidRun(this.onDidActionRun, this, l), i = new Tf(s, t, {
          actionViewItemProvider: e.getActionViewItem,
          context: e.getActionsContext ? e.getActionsContext() : null,
          actionRunner: d,
          getKeyBinding: e.getKeyBinding ? e.getKeyBinding : (h) => this.keybindingService.lookupKeybinding(h.id)
        }, Jie), i.onDidCancel(() => this.contextViewService.hideContextView(!0), null, l), i.onDidBlur(() => this.contextViewService.hideContextView(!0), null, l);
        const c = we(s);
        return l.add(W(c, Q.BLUR, () => this.contextViewService.hideContextView(!0))), l.add(W(c, Q.MOUSE_DOWN, (h) => {
          if (h.defaultPrevented)
            return;
          const u = new rr(c, h);
          let g = u.target;
          if (!u.rightButton) {
            for (; g; ) {
              if (g === s)
                return;
              g = g.parentElement;
            }
            this.contextViewService.hideContextView(!0);
          }
        })), Ur(l, i);
      },
      focus: () => {
        i == null || i.focus(!!e.autoSelectFirstItem);
      },
      onHide: (s) => {
        var o, a, l;
        (o = e.onHide) === null || o === void 0 || o.call(e, !!s), this.block && (this.block.remove(), this.block = null), (a = this.blockDisposable) === null || a === void 0 || a.dispose(), this.blockDisposable = null, this.lastContainer && (Ln() === this.lastContainer || qi(Ln(), this.lastContainer)) && ((l = this.focusToReturn) === null || l === void 0 || l.focus()), this.lastContainer = null;
      }
    }, n, !!n);
  }
  onActionRun(e, t) {
    t && this.telemetryService.publicLog2("workbenchActionExecuted", { id: e.action.id, from: "contextMenu" }), this.contextViewService.hideContextView(!1);
  }
  onDidActionRun(e) {
    e.error && !cl(e.error) && this.notificationService.error(e.error);
  }
}
var sne = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, bg = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
let XI = class extends P {
  get contextMenuHandler() {
    return this._contextMenuHandler || (this._contextMenuHandler = new nne(this.contextViewService, this.telemetryService, this.notificationService, this.keybindingService)), this._contextMenuHandler;
  }
  constructor(e, t, i, n, s, o) {
    super(), this.telemetryService = e, this.notificationService = t, this.contextViewService = i, this.keybindingService = n, this.menuService = s, this.contextKeyService = o, this._contextMenuHandler = void 0, this._onDidShowContextMenu = this._store.add(new R()), this.onDidShowContextMenu = this._onDidShowContextMenu.event, this._onDidHideContextMenu = this._store.add(new R());
  }
  configure(e) {
    this.contextMenuHandler.configure(e);
  }
  // ContextMenu
  showContextMenu(e) {
    e = JI.transform(e, this.menuService, this.contextKeyService), this.contextMenuHandler.showContextMenu({
      ...e,
      onHide: (t) => {
        var i;
        (i = e.onHide) === null || i === void 0 || i.call(e, t), this._onDidHideContextMenu.fire();
      }
    }), Hl.getInstance().resetKeyStatus(), this._onDidShowContextMenu.fire();
  }
};
XI = sne([
  bg(0, kn),
  bg(1, xi),
  bg(2, Sd),
  bg(3, _t),
  bg(4, vo),
  bg(5, De)
], XI);
var JI;
(function(r) {
  function e(i) {
    return i && i.menuId instanceof D;
  }
  function t(i, n, s) {
    if (!e(i))
      return i;
    const { menuId: o, menuActionOptions: a, contextKeyService: l } = i;
    return {
      ...i,
      getActions: () => {
        const d = [];
        if (o) {
          const c = n.createMenu(o, l ?? s);
          ene(c, a, d), c.dispose();
        }
        return i.getActions ? Oi.join(i.getActions(), d) : d;
      }
    };
  }
  r.transform = t;
})(JI || (JI = {}));
var QS;
(function(r) {
  r[r.API = 0] = "API", r[r.USER = 1] = "USER";
})(QS || (QS = {}));
var _M = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, XS = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
let eE = class {
  constructor(e) {
    this._commandService = e;
  }
  async open(e, t) {
    if (!i1(e, Ne.command))
      return !1;
    if (!(t != null && t.allowCommands) || (typeof e == "string" && (e = Ee.parse(e)), Array.isArray(t.allowCommands) && !t.allowCommands.includes(e.path)))
      return !0;
    let i = [];
    try {
      i = TI(decodeURIComponent(e.query));
    } catch {
      try {
        i = TI(e.query);
      } catch {
      }
    }
    return Array.isArray(i) || (i = [i]), await this._commandService.executeCommand(e.path, ...i), !0;
  }
};
eE = _M([
  XS(0, $t)
], eE);
let tE = class {
  constructor(e) {
    this._editorService = e;
  }
  async open(e, t) {
    typeof e == "string" && (e = Ee.parse(e));
    const { selection: i, uri: n } = UJ(e);
    return e = n, e.scheme === Ne.file && (e = uQ(e)), await this._editorService.openCodeEditor({
      resource: e,
      options: {
        selection: i,
        source: t != null && t.fromUserGesture ? QS.USER : QS.API,
        ...t == null ? void 0 : t.editorOptions
      }
    }, this._editorService.getFocusedCodeEditor(), t == null ? void 0 : t.openToSide), !0;
  }
};
tE = _M([
  XS(0, ht)
], tE);
let iE = class {
  constructor(e, t) {
    this._openers = new Ps(), this._validators = new Ps(), this._resolvers = new Ps(), this._resolvedUriTargets = new an((i) => i.with({ path: null, fragment: null, query: null }).toString()), this._externalOpeners = new Ps(), this._defaultExternalOpener = {
      openExternal: async (i) => (Ix(i, Ne.http, Ne.https) ? GH(i) : Dt.location.href = i, !0)
    }, this._openers.push({
      open: async (i, n) => n != null && n.openExternal || Ix(i, Ne.mailto, Ne.http, Ne.https, Ne.vsls) ? (await this._doOpenExternal(i, n), !0) : !1
    }), this._openers.push(new eE(t)), this._openers.push(new tE(e));
  }
  registerOpener(e) {
    return { dispose: this._openers.unshift(e) };
  }
  async open(e, t) {
    var i;
    const n = typeof e == "string" ? Ee.parse(e) : e, s = (i = this._resolvedUriTargets.get(n)) !== null && i !== void 0 ? i : e;
    for (const o of this._validators)
      if (!await o.shouldOpen(s, t))
        return !1;
    for (const o of this._openers)
      if (await o.open(e, t))
        return !0;
    return !1;
  }
  async resolveExternalUri(e, t) {
    for (const i of this._resolvers)
      try {
        const n = await i.resolveExternalUri(e, t);
        if (n)
          return this._resolvedUriTargets.has(n.resolved) || this._resolvedUriTargets.set(n.resolved, e), n;
      } catch {
      }
    throw new Error("Could not resolve external URI: " + e.toString());
  }
  async _doOpenExternal(e, t) {
    const i = typeof e == "string" ? Ee.parse(e) : e;
    let n;
    try {
      n = (await this.resolveExternalUri(i, t)).resolved;
    } catch {
      n = i;
    }
    let s;
    if (typeof e == "string" && i.toString() === n.toString() ? s = e : s = encodeURI(n.toString(!0)), t != null && t.allowContributedOpeners) {
      const o = typeof (t == null ? void 0 : t.allowContributedOpeners) == "string" ? t == null ? void 0 : t.allowContributedOpeners : void 0;
      for (const a of this._externalOpeners)
        if (await a.openExternal(s, {
          sourceUri: i,
          preferredOpenerId: o
        }, at.None))
          return !0;
    }
    return this._defaultExternalOpener.openExternal(s, { sourceUri: i }, at.None);
  }
  dispose() {
    this._validators.clear();
  }
};
iE = _M([
  XS(0, ht),
  XS(1, $t)
], iE);
const Uo = et("editorWorkerService");
var di;
(function(r) {
  r[r.Hint = 1] = "Hint", r[r.Info = 2] = "Info", r[r.Warning = 4] = "Warning", r[r.Error = 8] = "Error";
})(di || (di = {}));
(function(r) {
  function e(o, a) {
    return a - o;
  }
  r.compare = e;
  const t = /* @__PURE__ */ Object.create(null);
  t[r.Error] = p("sev.error", "Error"), t[r.Warning] = p("sev.warning", "Warning"), t[r.Info] = p("sev.info", "Info");
  function i(o) {
    return t[o] || "";
  }
  r.toString = i;
  function n(o) {
    switch (o) {
      case yi.Error:
        return r.Error;
      case yi.Warning:
        return r.Warning;
      case yi.Info:
        return r.Info;
      case yi.Ignore:
        return r.Hint;
    }
  }
  r.fromSeverity = n;
  function s(o) {
    switch (o) {
      case r.Error:
        return yi.Error;
      case r.Warning:
        return yi.Warning;
      case r.Info:
        return yi.Info;
      case r.Hint:
        return yi.Ignore;
    }
  }
  r.toSeverity = s;
})(di || (di = {}));
var JS;
(function(r) {
  const e = "";
  function t(n) {
    return i(n, !0);
  }
  r.makeKey = t;
  function i(n, s) {
    const o = [e];
    return n.source ? o.push(n.source.replace("", "\\")) : o.push(e), n.code ? typeof n.code == "string" ? o.push(n.code.replace("", "\\")) : o.push(n.code.value.replace("", "\\")) : o.push(e), n.severity !== void 0 && n.severity !== null ? o.push(di.toString(n.severity)) : o.push(e), n.message && s ? o.push(n.message.replace("", "\\")) : o.push(e), n.startLineNumber !== void 0 && n.startLineNumber !== null ? o.push(n.startLineNumber.toString()) : o.push(e), n.startColumn !== void 0 && n.startColumn !== null ? o.push(n.startColumn.toString()) : o.push(e), n.endLineNumber !== void 0 && n.endLineNumber !== null ? o.push(n.endLineNumber.toString()) : o.push(e), n.endColumn !== void 0 && n.endColumn !== null ? o.push(n.endColumn.toString()) : o.push(e), o.push(e), o.join("");
  }
  r.makeKeyOptionalMessage = i;
})(JS || (JS = {}));
const fl = et("markerService");
function one(r, e) {
  const t = [], i = [];
  for (const n of r)
    e.has(n) || t.push(n);
  for (const n of e)
    r.has(n) || i.push(n);
  return { removed: t, added: i };
}
function rne(r, e) {
  const t = /* @__PURE__ */ new Set();
  for (const i of e)
    r.has(i) && t.add(i);
  return t;
}
var ane = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, rF = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
let nE = class extends P {
  constructor(e, t) {
    super(), this._markerService = t, this._onDidChangeMarker = this._register(new R()), this._markerDecorations = new an(), e.getModels().forEach((i) => this._onModelAdded(i)), this._register(e.onModelAdded(this._onModelAdded, this)), this._register(e.onModelRemoved(this._onModelRemoved, this)), this._register(this._markerService.onMarkerChanged(this._handleMarkerChange, this));
  }
  dispose() {
    super.dispose(), this._markerDecorations.forEach((e) => e.dispose()), this._markerDecorations.clear();
  }
  getMarker(e, t) {
    const i = this._markerDecorations.get(e);
    return i && i.getMarker(t) || null;
  }
  _handleMarkerChange(e) {
    e.forEach((t) => {
      const i = this._markerDecorations.get(t);
      i && this._updateDecorations(i);
    });
  }
  _onModelAdded(e) {
    const t = new lne(e);
    this._markerDecorations.set(e.uri, t), this._updateDecorations(t);
  }
  _onModelRemoved(e) {
    var t;
    const i = this._markerDecorations.get(e.uri);
    i && (i.dispose(), this._markerDecorations.delete(e.uri)), (e.uri.scheme === Ne.inMemory || e.uri.scheme === Ne.internal || e.uri.scheme === Ne.vscode) && ((t = this._markerService) === null || t === void 0 || t.read({ resource: e.uri }).map((n) => n.owner).forEach((n) => this._markerService.remove(n, [e.uri])));
  }
  _updateDecorations(e) {
    const t = this._markerService.read({ resource: e.model.uri, take: 500 });
    e.update(t) && this._onDidChangeMarker.fire(e.model);
  }
};
nE = ane([
  rF(0, ii),
  rF(1, fl)
], nE);
class lne extends P {
  constructor(e) {
    super(), this.model = e, this._map = new H5(), this._register(Se(() => {
      this.model.deltaDecorations([...this._map.values()], []), this._map.clear();
    }));
  }
  update(e) {
    const { added: t, removed: i } = one(new Set(this._map.keys()), new Set(e));
    if (t.length === 0 && i.length === 0)
      return !1;
    const n = i.map((a) => this._map.get(a)), s = t.map((a) => ({
      range: this._createDecorationRange(this.model, a),
      options: this._createDecorationOption(a)
    })), o = this.model.deltaDecorations(n, s);
    for (const a of i)
      this._map.delete(a);
    for (let a = 0; a < o.length; a++)
      this._map.set(t[a], o[a]);
    return !0;
  }
  getMarker(e) {
    return this._map.getKey(e.id);
  }
  _createDecorationRange(e, t) {
    let i = L.lift(t);
    if (t.severity === di.Hint && !this._hasMarkerTag(
      t,
      1
      /* MarkerTag.Unnecessary */
    ) && !this._hasMarkerTag(
      t,
      2
      /* MarkerTag.Deprecated */
    ) && (i = i.setEndPosition(i.startLineNumber, i.startColumn + 2)), i = e.validateRange(i), i.isEmpty()) {
      const n = e.getLineLastNonWhitespaceColumn(i.startLineNumber) || e.getLineMaxColumn(i.startLineNumber);
      if (n === 1 || i.endColumn >= n)
        return i;
      const s = e.getWordAtPosition(i.getStartPosition());
      s && (i = new L(i.startLineNumber, s.startColumn, i.endLineNumber, s.endColumn));
    } else if (t.endColumn === Number.MAX_VALUE && t.startColumn === 1 && i.startLineNumber === i.endLineNumber) {
      const n = e.getLineFirstNonWhitespaceColumn(t.startLineNumber);
      n < i.endColumn && (i = new L(i.startLineNumber, n, i.endLineNumber, i.endColumn), t.startColumn = n);
    }
    return i;
  }
  _createDecorationOption(e) {
    let t, i, n, s, o;
    switch (e.severity) {
      case di.Hint:
        this._hasMarkerTag(
          e,
          2
          /* MarkerTag.Deprecated */
        ) ? t = void 0 : this._hasMarkerTag(
          e,
          1
          /* MarkerTag.Unnecessary */
        ) ? t = "squiggly-unnecessary" : t = "squiggly-hint", n = 0;
        break;
      case di.Info:
        t = "squiggly-info", i = ai(Q7), n = 10, o = {
          color: ai(zG),
          position: 1
          /* MinimapPosition.Inline */
        };
        break;
      case di.Warning:
        t = "squiggly-warning", i = ai(Y7), n = 20, o = {
          color: ai(UG),
          position: 1
          /* MinimapPosition.Inline */
        };
        break;
      case di.Error:
      default:
        t = "squiggly-error", i = ai(Z7), n = 30, o = {
          color: ai($G),
          position: 1
          /* MinimapPosition.Inline */
        };
        break;
    }
    return e.tags && (e.tags.indexOf(
      1
      /* MarkerTag.Unnecessary */
    ) !== -1 && (s = "squiggly-inline-unnecessary"), e.tags.indexOf(
      2
      /* MarkerTag.Deprecated */
    ) !== -1 && (s = "squiggly-inline-deprecated")), {
      description: "marker-decoration",
      stickiness: 1,
      className: t,
      showIfCollapsed: !0,
      overviewRuler: {
        color: i,
        position: _r.Right
      },
      minimap: o,
      zIndex: n,
      inlineClassName: s
    };
  }
  _hasMarkerTag(e, t) {
    return e.tags ? e.tags.indexOf(t) >= 0 : !1;
  }
}
var dne = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, lm = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, Ng;
function Lh(r) {
  return r.toString();
}
class cne {
  constructor(e, t, i) {
    this.model = e, this._modelEventListeners = new q(), this.model = e, this._modelEventListeners.add(e.onWillDispose(() => t(e))), this._modelEventListeners.add(e.onDidChangeLanguage((n) => i(e, n)));
  }
  dispose() {
    this._modelEventListeners.dispose();
  }
}
const hne = os || Je ? 1 : 2;
class une {
  constructor(e, t, i, n, s, o, a, l) {
    this.uri = e, this.initialUndoRedoSnapshot = t, this.time = i, this.sharesUndoRedoStack = n, this.heapSize = s, this.sha1 = o, this.versionId = a, this.alternativeVersionId = l;
  }
}
let ey = Ng = class extends P {
  constructor(e, t, i, n, s) {
    super(), this._configurationService = e, this._resourcePropertiesService = t, this._undoRedoService = i, this._languageService = n, this._languageConfigurationService = s, this._onModelAdded = this._register(new R()), this.onModelAdded = this._onModelAdded.event, this._onModelRemoved = this._register(new R()), this.onModelRemoved = this._onModelRemoved.event, this._onModelModeChanged = this._register(new R()), this.onModelLanguageChanged = this._onModelModeChanged.event, this._modelCreationOptionsByLanguageAndResource = /* @__PURE__ */ Object.create(null), this._models = {}, this._disposedModels = /* @__PURE__ */ new Map(), this._disposedModelsHeapSize = 0, this._register(this._configurationService.onDidChangeConfiguration((o) => this._updateModelOptions(o))), this._updateModelOptions(void 0);
  }
  static _readModelOptions(e, t) {
    var i;
    let n = Tn.tabSize;
    if (e.editor && typeof e.editor.tabSize < "u") {
      const g = parseInt(e.editor.tabSize, 10);
      isNaN(g) || (n = g), n < 1 && (n = 1);
    }
    let s = "tabSize";
    if (e.editor && typeof e.editor.indentSize < "u" && e.editor.indentSize !== "tabSize") {
      const g = parseInt(e.editor.indentSize, 10);
      isNaN(g) || (s = Math.max(g, 1));
    }
    let o = Tn.insertSpaces;
    e.editor && typeof e.editor.insertSpaces < "u" && (o = e.editor.insertSpaces === "false" ? !1 : !!e.editor.insertSpaces);
    let a = hne;
    const l = e.eol;
    l === `\r
` ? a = 2 : l === `
` && (a = 1);
    let d = Tn.trimAutoWhitespace;
    e.editor && typeof e.editor.trimAutoWhitespace < "u" && (d = e.editor.trimAutoWhitespace === "false" ? !1 : !!e.editor.trimAutoWhitespace);
    let c = Tn.detectIndentation;
    e.editor && typeof e.editor.detectIndentation < "u" && (c = e.editor.detectIndentation === "false" ? !1 : !!e.editor.detectIndentation);
    let h = Tn.largeFileOptimizations;
    e.editor && typeof e.editor.largeFileOptimizations < "u" && (h = e.editor.largeFileOptimizations === "false" ? !1 : !!e.editor.largeFileOptimizations);
    let u = Tn.bracketPairColorizationOptions;
    return !((i = e.editor) === null || i === void 0) && i.bracketPairColorization && typeof e.editor.bracketPairColorization == "object" && (u = {
      enabled: !!e.editor.bracketPairColorization.enabled,
      independentColorPoolPerBracketType: !!e.editor.bracketPairColorization.independentColorPoolPerBracketType
    }), {
      isForSimpleWidget: t,
      tabSize: n,
      indentSize: s,
      insertSpaces: o,
      detectIndentation: c,
      defaultEOL: a,
      trimAutoWhitespace: d,
      largeFileOptimizations: h,
      bracketPairColorizationOptions: u
    };
  }
  _getEOL(e, t) {
    if (e)
      return this._resourcePropertiesService.getEOL(e, t);
    const i = this._configurationService.getValue("files.eol", { overrideIdentifier: t });
    return i && typeof i == "string" && i !== "auto" ? i : Os === 3 || Os === 2 ? `
` : `\r
`;
  }
  _shouldRestoreUndoStack() {
    const e = this._configurationService.getValue("files.restoreUndoStack");
    return typeof e == "boolean" ? e : !0;
  }
  getCreationOptions(e, t, i) {
    const n = typeof e == "string" ? e : e.languageId;
    let s = this._modelCreationOptionsByLanguageAndResource[n + t];
    if (!s) {
      const o = this._configurationService.getValue("editor", { overrideIdentifier: n, resource: t }), a = this._getEOL(t, n);
      s = Ng._readModelOptions({ editor: o, eol: a }, i), this._modelCreationOptionsByLanguageAndResource[n + t] = s;
    }
    return s;
  }
  _updateModelOptions(e) {
    const t = this._modelCreationOptionsByLanguageAndResource;
    this._modelCreationOptionsByLanguageAndResource = /* @__PURE__ */ Object.create(null);
    const i = Object.keys(this._models);
    for (let n = 0, s = i.length; n < s; n++) {
      const o = i[n], a = this._models[o], l = a.model.getLanguageId(), d = a.model.uri;
      if (e && !e.affectsConfiguration("editor", { overrideIdentifier: l, resource: d }) && !e.affectsConfiguration("files.eol", { overrideIdentifier: l, resource: d }))
        continue;
      const c = t[l + d], h = this.getCreationOptions(l, d, a.model.isForSimpleWidget);
      Ng._setModelOptionsForModel(a.model, h, c);
    }
  }
  static _setModelOptionsForModel(e, t, i) {
    i && i.defaultEOL !== t.defaultEOL && e.getLineCount() === 1 && e.setEOL(
      t.defaultEOL === 1 ? 0 : 1
      /* EndOfLineSequence.CRLF */
    ), !(i && i.detectIndentation === t.detectIndentation && i.insertSpaces === t.insertSpaces && i.tabSize === t.tabSize && i.indentSize === t.indentSize && i.trimAutoWhitespace === t.trimAutoWhitespace && Xa(i.bracketPairColorizationOptions, t.bracketPairColorizationOptions)) && (t.detectIndentation ? (e.detectIndentation(t.insertSpaces, t.tabSize), e.updateOptions({
      trimAutoWhitespace: t.trimAutoWhitespace,
      bracketColorizationOptions: t.bracketPairColorizationOptions
    })) : e.updateOptions({
      insertSpaces: t.insertSpaces,
      tabSize: t.tabSize,
      indentSize: t.indentSize,
      trimAutoWhitespace: t.trimAutoWhitespace,
      bracketColorizationOptions: t.bracketPairColorizationOptions
    }));
  }
  // --- begin IModelService
  _insertDisposedModel(e) {
    this._disposedModels.set(Lh(e.uri), e), this._disposedModelsHeapSize += e.heapSize;
  }
  _removeDisposedModel(e) {
    const t = this._disposedModels.get(Lh(e));
    return t && (this._disposedModelsHeapSize -= t.heapSize), this._disposedModels.delete(Lh(e)), t;
  }
  _ensureDisposedModelsHeapSize(e) {
    if (this._disposedModelsHeapSize > e) {
      const t = [];
      for (this._disposedModels.forEach((i) => {
        i.sharesUndoRedoStack || t.push(i);
      }), t.sort((i, n) => i.time - n.time); t.length > 0 && this._disposedModelsHeapSize > e; ) {
        const i = t.shift();
        this._removeDisposedModel(i.uri), i.initialUndoRedoSnapshot !== null && this._undoRedoService.restoreSnapshot(i.initialUndoRedoSnapshot);
      }
    }
  }
  _createModelData(e, t, i, n) {
    const s = this.getCreationOptions(t, i, n), o = new il(e, t, s, i, this._undoRedoService, this._languageService, this._languageConfigurationService);
    if (i && this._disposedModels.has(Lh(i))) {
      const d = this._removeDisposedModel(i), c = this._undoRedoService.getElements(i), h = this._getSHA1Computer(), u = h.canComputeSHA1(o) ? h.computeSHA1(o) === d.sha1 : !1;
      if (u || d.sharesUndoRedoStack) {
        for (const g of c.past)
          Tl(g) && g.matchesResource(i) && g.setModel(o);
        for (const g of c.future)
          Tl(g) && g.matchesResource(i) && g.setModel(o);
        this._undoRedoService.setElementsValidFlag(i, !0, (g) => Tl(g) && g.matchesResource(i)), u && (o._overwriteVersionId(d.versionId), o._overwriteAlternativeVersionId(d.alternativeVersionId), o._overwriteInitialUndoRedoSnapshot(d.initialUndoRedoSnapshot));
      } else
        d.initialUndoRedoSnapshot !== null && this._undoRedoService.restoreSnapshot(d.initialUndoRedoSnapshot);
    }
    const a = Lh(o.uri);
    if (this._models[a])
      throw new Error("ModelService: Cannot add model because it already exists!");
    const l = new cne(o, (d) => this._onWillDispose(d), (d, c) => this._onDidChangeLanguage(d, c));
    return this._models[a] = l, l;
  }
  createModel(e, t, i, n = !1) {
    let s;
    return t ? s = this._createModelData(e, t, i, n) : s = this._createModelData(e, go, i, n), this._onModelAdded.fire(s.model), s.model;
  }
  getModels() {
    const e = [], t = Object.keys(this._models);
    for (let i = 0, n = t.length; i < n; i++) {
      const s = t[i];
      e.push(this._models[s].model);
    }
    return e;
  }
  getModel(e) {
    const t = Lh(e), i = this._models[t];
    return i ? i.model : null;
  }
  // --- end IModelService
  _schemaShouldMaintainUndoRedoElements(e) {
    return e.scheme === Ne.file || e.scheme === Ne.vscodeRemote || e.scheme === Ne.vscodeUserData || e.scheme === Ne.vscodeNotebookCell || e.scheme === "fake-fs";
  }
  _onWillDispose(e) {
    const t = Lh(e.uri), i = this._models[t], n = this._undoRedoService.getUriComparisonKey(e.uri) !== e.uri.toString();
    let s = !1, o = 0;
    if (n || this._shouldRestoreUndoStack() && this._schemaShouldMaintainUndoRedoElements(e.uri)) {
      const d = this._undoRedoService.getElements(e.uri);
      if (d.past.length > 0 || d.future.length > 0) {
        for (const c of d.past)
          Tl(c) && c.matchesResource(e.uri) && (s = !0, o += c.heapSize(e.uri), c.setModel(e.uri));
        for (const c of d.future)
          Tl(c) && c.matchesResource(e.uri) && (s = !0, o += c.heapSize(e.uri), c.setModel(e.uri));
      }
    }
    const a = Ng.MAX_MEMORY_FOR_CLOSED_FILES_UNDO_STACK, l = this._getSHA1Computer();
    if (s)
      if (!n && (o > a || !l.canComputeSHA1(e))) {
        const d = i.model.getInitialUndoRedoSnapshot();
        d !== null && this._undoRedoService.restoreSnapshot(d);
      } else
        this._ensureDisposedModelsHeapSize(a - o), this._undoRedoService.setElementsValidFlag(e.uri, !1, (d) => Tl(d) && d.matchesResource(e.uri)), this._insertDisposedModel(new une(e.uri, i.model.getInitialUndoRedoSnapshot(), Date.now(), n, o, l.computeSHA1(e), e.getVersionId(), e.getAlternativeVersionId()));
    else if (!n) {
      const d = i.model.getInitialUndoRedoSnapshot();
      d !== null && this._undoRedoService.restoreSnapshot(d);
    }
    delete this._models[t], i.dispose(), delete this._modelCreationOptionsByLanguageAndResource[e.getLanguageId() + e.uri], this._onModelRemoved.fire(e);
  }
  _onDidChangeLanguage(e, t) {
    const i = t.oldLanguage, n = e.getLanguageId(), s = this.getCreationOptions(i, e.uri, e.isForSimpleWidget), o = this.getCreationOptions(n, e.uri, e.isForSimpleWidget);
    Ng._setModelOptionsForModel(e, o, s), this._onModelModeChanged.fire({ model: e, oldLanguageId: i });
  }
  _getSHA1Computer() {
    return new tL();
  }
};
ey.MAX_MEMORY_FOR_CLOSED_FILES_UNDO_STACK = 20 * 1024 * 1024;
ey = Ng = dne([
  lm(0, Ge),
  lm(1, _V),
  lm(2, O0),
  lm(3, Jt),
  lm(4, Ot)
], ey);
class tL {
  canComputeSHA1(e) {
    return e.getValueLength() <= tL.MAX_MODEL_SIZE;
  }
  computeSHA1(e) {
    const t = new V5(), i = e.createSnapshot();
    let n;
    for (; n = i.read(); )
      t.update(n);
    return t.digest();
  }
}
tL.MAX_MODEL_SIZE = 10 * 1024 * 1024;
var sE;
(function(r) {
  r[r.PRESERVE = 0] = "PRESERVE", r[r.LAST = 1] = "LAST";
})(sE || (sE = {}));
const og = {
  Quickaccess: "workbench.contributions.quickaccess"
};
class gne {
  constructor() {
    this.providers = [], this.defaultProvider = void 0;
  }
  registerQuickAccessProvider(e) {
    return e.prefix.length === 0 ? this.defaultProvider = e : this.providers.push(e), this.providers.sort((t, i) => i.prefix.length - t.prefix.length), Se(() => {
      this.providers.splice(this.providers.indexOf(e), 1), this.defaultProvider === e && (this.defaultProvider = void 0);
    });
  }
  getQuickAccessProviders() {
    return Yr([this.defaultProvider, ...this.providers]);
  }
  getQuickAccessProvider(e) {
    return e && this.providers.find((i) => e.startsWith(i.prefix)) || void 0 || this.defaultProvider;
  }
}
si.add(og.Quickaccess, new gne());
const fne = { ctrlCmd: !1, alt: !1 };
var op;
(function(r) {
  r[r.Blur = 1] = "Blur", r[r.Gesture = 2] = "Gesture", r[r.Other = 3] = "Other";
})(op || (op = {}));
var Tr;
(function(r) {
  r[r.NONE = 0] = "NONE", r[r.FIRST = 1] = "FIRST", r[r.SECOND = 2] = "SECOND", r[r.LAST = 3] = "LAST";
})(Tr || (Tr = {}));
var Bt;
(function(r) {
  r[r.First = 1] = "First", r[r.Second = 2] = "Second", r[r.Last = 3] = "Last", r[r.Next = 4] = "Next", r[r.Previous = 5] = "Previous", r[r.NextPage = 6] = "NextPage", r[r.PreviousPage = 7] = "PreviousPage", r[r.NextSeparator = 8] = "NextSeparator", r[r.PreviousSeparator = 9] = "PreviousSeparator";
})(Bt || (Bt = {}));
const $o = et("quickInputService");
var pne = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, aF = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
let oE = class extends P {
  constructor(e, t) {
    super(), this.quickInputService = e, this.instantiationService = t, this.registry = si.as(og.Quickaccess), this.mapProviderToDescriptor = /* @__PURE__ */ new Map(), this.lastAcceptedPickerValues = /* @__PURE__ */ new Map(), this.visibleQuickAccess = void 0;
  }
  show(e = "", t) {
    this.doShowOrPick(e, !1, t);
  }
  doShowOrPick(e, t, i) {
    var n, s, o, a;
    const [l, d] = this.getOrInstantiateProvider(e, i == null ? void 0 : i.enabledProviderPrefixes), c = this.visibleQuickAccess, h = c == null ? void 0 : c.descriptor;
    if (c && d && h === d) {
      e !== d.prefix && !(i != null && i.preserveValue) && (c.picker.value = e), this.adjustValueSelection(c.picker, d, i);
      return;
    }
    if (d && !(i != null && i.preserveValue)) {
      let b;
      if (c && h && h !== d) {
        const C = c.value.substr(h.prefix.length);
        C && (b = `${d.prefix}${C}`);
      }
      if (!b) {
        const C = l == null ? void 0 : l.defaultFilterValue;
        C === sE.LAST ? b = this.lastAcceptedPickerValues.get(d) : typeof C == "string" && (b = `${d.prefix}${C}`);
      }
      typeof b == "string" && (e = b);
    }
    const u = (n = c == null ? void 0 : c.picker) === null || n === void 0 ? void 0 : n.valueSelection, g = (s = c == null ? void 0 : c.picker) === null || s === void 0 ? void 0 : s.value, f = new q(), m = f.add(this.quickInputService.createQuickPick());
    m.value = e, this.adjustValueSelection(m, d, i), m.placeholder = (o = i == null ? void 0 : i.placeholder) !== null && o !== void 0 ? o : d == null ? void 0 : d.placeholder, m.quickNavigate = i == null ? void 0 : i.quickNavigateConfiguration, m.hideInput = !!m.quickNavigate && !c, (typeof (i == null ? void 0 : i.itemActivation) == "number" || i != null && i.quickNavigateConfiguration) && (m.itemActivation = (a = i == null ? void 0 : i.itemActivation) !== null && a !== void 0 ? a : Tr.SECOND), m.contextKey = d == null ? void 0 : d.contextKey, m.filterValue = (b) => b.substring(d ? d.prefix.length : 0);
    let _;
    t && (_ = new ab(), f.add(ne.once(m.onWillAccept)((b) => {
      b.veto(), m.hide();
    }))), f.add(this.registerPickerListeners(m, l, d, e, i));
    const v = f.add(new mi());
    if (l && f.add(l.provide(m, v.token, i == null ? void 0 : i.providerOptions)), ne.once(m.onDidHide)(() => {
      m.selectedItems.length === 0 && v.cancel(), f.dispose(), _ == null || _.complete(m.selectedItems.slice(0));
    }), m.show(), u && g === e && (m.valueSelection = u), t)
      return _ == null ? void 0 : _.p;
  }
  adjustValueSelection(e, t, i) {
    var n;
    let s;
    i != null && i.preserveValue ? s = [e.value.length, e.value.length] : s = [(n = t == null ? void 0 : t.prefix.length) !== null && n !== void 0 ? n : 0, e.value.length], e.valueSelection = s;
  }
  registerPickerListeners(e, t, i, n, s) {
    const o = new q(), a = this.visibleQuickAccess = { picker: e, descriptor: i, value: n };
    return o.add(Se(() => {
      a === this.visibleQuickAccess && (this.visibleQuickAccess = void 0);
    })), o.add(e.onDidChangeValue((l) => {
      const [d] = this.getOrInstantiateProvider(l, s == null ? void 0 : s.enabledProviderPrefixes);
      d !== t ? this.show(l, {
        enabledProviderPrefixes: s == null ? void 0 : s.enabledProviderPrefixes,
        // do not rewrite value from user typing!
        preserveValue: !0,
        // persist the value of the providerOptions from the original showing
        providerOptions: s == null ? void 0 : s.providerOptions
      }) : a.value = l;
    })), i && o.add(e.onDidAccept(() => {
      this.lastAcceptedPickerValues.set(i, e.value);
    })), o;
  }
  getOrInstantiateProvider(e, t) {
    const i = this.registry.getQuickAccessProvider(e);
    if (!i || t && !(t != null && t.includes(i.prefix)))
      return [void 0, void 0];
    let n = this.mapProviderToDescriptor.get(i);
    return n || (n = this.instantiationService.createInstance(i.ctor), this.mapProviderToDescriptor.set(i, n)), [n, i];
  }
};
oE = pne([
  aF(0, $o),
  aF(1, be)
], oE);
class Ap extends bo {
  constructor(e) {
    var t;
    super(), this._onChange = this._register(new R()), this.onChange = this._onChange.event, this._onKeyDown = this._register(new R()), this.onKeyDown = this._onKeyDown.event, this._opts = e, this._checked = this._opts.isChecked;
    const i = ["monaco-custom-toggle"];
    this._opts.icon && (this._icon = this._opts.icon, i.push(...Le.asClassNameArray(this._icon))), this._opts.actionClassName && i.push(...this._opts.actionClassName.split(" ")), this._checked && i.push("checked"), this.domNode = document.createElement("div"), this._hover = this._register(da().setupUpdatableHover((t = e.hoverDelegate) !== null && t !== void 0 ? t : us("mouse"), this.domNode, this._opts.title)), this.domNode.classList.add(...i), this._opts.notFocusable || (this.domNode.tabIndex = 0), this.domNode.setAttribute("role", "checkbox"), this.domNode.setAttribute("aria-checked", String(this._checked)), this.domNode.setAttribute("aria-label", this._opts.title), this.applyStyles(), this.onclick(this.domNode, (n) => {
      this.enabled && (this.checked = !this._checked, this._onChange.fire(!1), n.preventDefault());
    }), this._register(this.ignoreGesture(this.domNode)), this.onkeydown(this.domNode, (n) => {
      if (n.keyCode === 10 || n.keyCode === 3) {
        this.checked = !this._checked, this._onChange.fire(!0), n.preventDefault(), n.stopPropagation();
        return;
      }
      this._onKeyDown.fire(n);
    });
  }
  get enabled() {
    return this.domNode.getAttribute("aria-disabled") !== "true";
  }
  focus() {
    this.domNode.focus();
  }
  get checked() {
    return this._checked;
  }
  set checked(e) {
    this._checked = e, this.domNode.setAttribute("aria-checked", String(this._checked)), this.domNode.classList.toggle("checked", this._checked), this.applyStyles();
  }
  width() {
    return 22;
  }
  applyStyles() {
    this.domNode && (this.domNode.style.borderColor = this._checked && this._opts.inputActiveOptionBorder || "", this.domNode.style.color = this._checked && this._opts.inputActiveOptionForeground || "inherit", this.domNode.style.backgroundColor = this._checked && this._opts.inputActiveOptionBackground || "");
  }
  enable() {
    this.domNode.setAttribute("aria-disabled", String(!1));
  }
  disable() {
    this.domNode.setAttribute("aria-disabled", String(!0));
  }
}
var mne = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
};
class Pz {
  constructor(e) {
    this.nodes = e;
  }
  toString() {
    return this.nodes.map((e) => typeof e == "string" ? e : e.label).join("");
  }
}
mne([
  ki
], Pz.prototype, "toString", null);
const _ne = /\[([^\]]+)\]\(((?:https?:\/\/|command:|file:)[^\)\s]+)(?: (["'])(.+?)(\3))?\)/gi;
function vne(r) {
  const e = [];
  let t = 0, i;
  for (; i = _ne.exec(r); ) {
    i.index - t > 0 && e.push(r.substring(t, i.index));
    const [, n, s, , o] = i;
    o ? e.push({ label: n, href: s, title: o }) : e.push({ label: n, href: s }), t = i.index + i[0].length;
  }
  return t < r.length && e.push(r.substring(t)), new Pz(e);
}
const xk = {}, bne = new hM("quick-input-button-icon-");
function Cne(r) {
  if (!r)
    return;
  let e;
  const t = r.dark.toString();
  return xk[t] ? e = xk[t] : (e = bne.nextId(), gS(`.${e}, .hc-light .${e}`, `background-image: ${hd(r.light || r.dark)}`), gS(`.vs-dark .${e}, .hc-black .${e}`, `background-image: ${hd(r.dark)}`), xk[t] = e), e;
}
function ty(r, e, t) {
  let i = r.iconClass || Cne(r.iconPath);
  return r.alwaysVisible && (i = i ? `${i} always-visible` : "always-visible"), {
    id: e,
    label: "",
    tooltip: r.tooltip || "",
    class: i,
    enabled: !0,
    run: t
  };
}
function wne(r, e, t) {
  mn(e);
  const i = vne(r);
  let n = 0;
  for (const s of i.nodes)
    if (typeof s == "string")
      e.append(..._c(s));
    else {
      let o = s.title;
      !o && s.href.startsWith("command:") ? o = p("executeCommand", "Click to execute command '{0}'", s.href.substring(8)) : o || (o = s.href);
      const a = X("a", { href: s.href, title: o, tabIndex: n++ }, s.label);
      a.style.textDecoration = "underline";
      const l = (g) => {
        Z8(g) && nt.stop(g, !0), t.callback(s.href);
      }, d = t.disposables.add(new tt(a, Q.CLICK)).event, c = t.disposables.add(new tt(a, Q.KEY_DOWN)).event, h = ne.chain(c, (g) => g.filter((f) => {
        const m = new Mt(f);
        return m.equals(
          10
          /* KeyCode.Space */
        ) || m.equals(
          3
          /* KeyCode.Enter */
        );
      }));
      t.disposables.add(At.addTarget(a));
      const u = t.disposables.add(new tt(a, Pt.Tap)).event;
      ne.any(d, u, h)(l, null, t.disposables), e.appendChild(a);
    }
}
var Sne = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, lF = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
const Oz = "inQuickInput", yne = new oe(Oz, !1, p("inQuickInput", "Whether keyboard focus is inside the quick input control")), Lne = U.has(Oz), Fz = "quickInputType", Dne = new oe(Fz, void 0, p("quickInputType", "The type of the currently visible quick input")), Wz = "cursorAtEndOfQuickInputBox", kne = new oe(Wz, !1, p("cursorAtEndOfQuickInputBox", "Whether the cursor in the quick input is at the end of the input box")), xne = U.has(Wz), rE = {
  iconClass: Le.asClassName(me.quickInputBack),
  tooltip: p("quickInput.back", "Back"),
  handle: -1
  // TODO
};
class Eb extends P {
  constructor(e) {
    super(), this.ui = e, this._widgetUpdated = !1, this.visible = !1, this._enabled = !0, this._busy = !1, this._ignoreFocusOut = !1, this._buttons = [], this.buttonsUpdated = !1, this._toggles = [], this.togglesUpdated = !1, this.noValidationMessage = Eb.noPromptMessage, this._severity = yi.Ignore, this.onDidTriggerButtonEmitter = this._register(new R()), this.onDidHideEmitter = this._register(new R()), this.onWillHideEmitter = this._register(new R()), this.onDisposeEmitter = this._register(new R()), this.visibleDisposables = this._register(new q()), this.onDidHide = this.onDidHideEmitter.event;
  }
  get title() {
    return this._title;
  }
  set title(e) {
    this._title = e, this.update();
  }
  get description() {
    return this._description;
  }
  set description(e) {
    this._description = e, this.update();
  }
  get step() {
    return this._steps;
  }
  set step(e) {
    this._steps = e, this.update();
  }
  get totalSteps() {
    return this._totalSteps;
  }
  set totalSteps(e) {
    this._totalSteps = e, this.update();
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(e) {
    this._enabled = e, this.update();
  }
  get contextKey() {
    return this._contextKey;
  }
  set contextKey(e) {
    this._contextKey = e, this.update();
  }
  get busy() {
    return this._busy;
  }
  set busy(e) {
    this._busy = e, this.update();
  }
  get ignoreFocusOut() {
    return this._ignoreFocusOut;
  }
  set ignoreFocusOut(e) {
    const t = this._ignoreFocusOut !== e && !Zr;
    this._ignoreFocusOut = e && !Zr, t && this.update();
  }
  get buttons() {
    return this._buttons;
  }
  set buttons(e) {
    this._buttons = e, this.buttonsUpdated = !0, this.update();
  }
  get toggles() {
    return this._toggles;
  }
  set toggles(e) {
    this._toggles = e ?? [], this.togglesUpdated = !0, this.update();
  }
  get validationMessage() {
    return this._validationMessage;
  }
  set validationMessage(e) {
    this._validationMessage = e, this.update();
  }
  get severity() {
    return this._severity;
  }
  set severity(e) {
    this._severity = e, this.update();
  }
  show() {
    this.visible || (this.visibleDisposables.add(this.ui.onDidTriggerButton((e) => {
      this.buttons.indexOf(e) !== -1 && this.onDidTriggerButtonEmitter.fire(e);
    })), this.ui.show(this), this.visible = !0, this._lastValidationMessage = void 0, this._lastSeverity = void 0, this.buttons.length && (this.buttonsUpdated = !0), this.toggles.length && (this.togglesUpdated = !0), this.update());
  }
  hide() {
    this.visible && this.ui.hide();
  }
  didHide(e = op.Other) {
    this.visible = !1, this.visibleDisposables.clear(), this.onDidHideEmitter.fire({ reason: e });
  }
  willHide(e = op.Other) {
    this.onWillHideEmitter.fire({ reason: e });
  }
  update() {
    var e, t;
    if (!this.visible)
      return;
    const i = this.getTitle();
    i && this.ui.title.textContent !== i ? this.ui.title.textContent = i : !i && this.ui.title.innerHTML !== "&nbsp;" && (this.ui.title.innerText = "");
    const n = this.getDescription();
    if (this.ui.description1.textContent !== n && (this.ui.description1.textContent = n), this.ui.description2.textContent !== n && (this.ui.description2.textContent = n), this._widgetUpdated && (this._widgetUpdated = !1, this._widget ? mn(this.ui.widget, this._widget) : mn(this.ui.widget)), this.busy && !this.busyDelay && (this.busyDelay = new vr(), this.busyDelay.setIfNotSet(() => {
      this.visible && this.ui.progressBar.infinite();
    }, 800)), !this.busy && this.busyDelay && (this.ui.progressBar.stop(), this.busyDelay.cancel(), this.busyDelay = void 0), this.buttonsUpdated) {
      this.buttonsUpdated = !1, this.ui.leftActionBar.clear();
      const o = this.buttons.filter((l) => l === rE).map((l, d) => ty(l, `id-${d}`, async () => this.onDidTriggerButtonEmitter.fire(l)));
      this.ui.leftActionBar.push(o, { icon: !0, label: !1 }), this.ui.rightActionBar.clear();
      const a = this.buttons.filter((l) => l !== rE).map((l, d) => ty(l, `id-${d}`, async () => this.onDidTriggerButtonEmitter.fire(l)));
      this.ui.rightActionBar.push(a, { icon: !0, label: !1 });
    }
    if (this.togglesUpdated) {
      this.togglesUpdated = !1;
      const o = (t = (e = this.toggles) === null || e === void 0 ? void 0 : e.filter((a) => a instanceof Ap)) !== null && t !== void 0 ? t : [];
      this.ui.inputBox.toggles = o;
    }
    this.ui.ignoreFocusOut = this.ignoreFocusOut, this.ui.setEnabled(this.enabled), this.ui.setContextKey(this.contextKey);
    const s = this.validationMessage || this.noValidationMessage;
    this._lastValidationMessage !== s && (this._lastValidationMessage = s, mn(this.ui.message), wne(s, this.ui.message, {
      callback: (o) => {
        this.ui.linkOpenerDelegate(o);
      },
      disposables: this.visibleDisposables
    })), this._lastSeverity !== this.severity && (this._lastSeverity = this.severity, this.showMessageDecoration(this.severity));
  }
  getTitle() {
    return this.title && this.step ? `${this.title} (${this.getSteps()})` : this.title ? this.title : this.step ? this.getSteps() : "";
  }
  getDescription() {
    return this.description || "";
  }
  getSteps() {
    return this.step && this.totalSteps ? p("quickInput.steps", "{0}/{1}", this.step, this.totalSteps) : this.step ? String(this.step) : "";
  }
  showMessageDecoration(e) {
    if (this.ui.inputBox.showDecoration(e), e !== yi.Ignore) {
      const t = this.ui.inputBox.stylesForType(e);
      this.ui.message.style.color = t.foreground ? `${t.foreground}` : "", this.ui.message.style.backgroundColor = t.background ? `${t.background}` : "", this.ui.message.style.border = t.border ? `1px solid ${t.border}` : "", this.ui.message.style.marginBottom = "-2px";
    } else
      this.ui.message.style.color = "", this.ui.message.style.backgroundColor = "", this.ui.message.style.border = "", this.ui.message.style.marginBottom = "";
  }
  dispose() {
    this.hide(), this.onDisposeEmitter.fire(), super.dispose();
  }
}
Eb.noPromptMessage = p("inputModeEntry", "Press 'Enter' to confirm your input or 'Escape' to cancel");
class gv extends Eb {
  constructor() {
    super(...arguments), this._value = "", this.onDidChangeValueEmitter = this._register(new R()), this.onWillAcceptEmitter = this._register(new R()), this.onDidAcceptEmitter = this._register(new R()), this.onDidCustomEmitter = this._register(new R()), this._items = [], this.itemsUpdated = !1, this._canSelectMany = !1, this._canAcceptInBackground = !1, this._matchOnDescription = !1, this._matchOnDetail = !1, this._matchOnLabel = !0, this._matchOnLabelMode = "fuzzy", this._sortByLabel = !0, this._keepScrollPosition = !1, this._itemActivation = Tr.FIRST, this._activeItems = [], this.activeItemsUpdated = !1, this.activeItemsToConfirm = [], this.onDidChangeActiveEmitter = this._register(new R()), this._selectedItems = [], this.selectedItemsUpdated = !1, this.selectedItemsToConfirm = [], this.onDidChangeSelectionEmitter = this._register(new R()), this.onDidTriggerItemButtonEmitter = this._register(new R()), this.onDidTriggerSeparatorButtonEmitter = this._register(new R()), this.valueSelectionUpdated = !0, this._ok = "default", this._customButton = !1, this._focusEventBufferer = new n0(), this.type = "quickPick", this.filterValue = (e) => e, this.onDidChangeValue = this.onDidChangeValueEmitter.event, this.onWillAccept = this.onWillAcceptEmitter.event, this.onDidAccept = this.onDidAcceptEmitter.event, this.onDidChangeActive = this.onDidChangeActiveEmitter.event, this.onDidChangeSelection = this.onDidChangeSelectionEmitter.event, this.onDidTriggerItemButton = this.onDidTriggerItemButtonEmitter.event, this.onDidTriggerSeparatorButton = this.onDidTriggerSeparatorButtonEmitter.event;
  }
  get quickNavigate() {
    return this._quickNavigate;
  }
  set quickNavigate(e) {
    this._quickNavigate = e, this.update();
  }
  get value() {
    return this._value;
  }
  set value(e) {
    this.doSetValue(e);
  }
  doSetValue(e, t) {
    this._value !== e && (this._value = e, t || this.update(), this.visible && this.ui.list.filter(this.filterValue(this._value)) && this.trySelectFirst(), this.onDidChangeValueEmitter.fire(this._value));
  }
  set ariaLabel(e) {
    this._ariaLabel = e, this.update();
  }
  get ariaLabel() {
    return this._ariaLabel;
  }
  get placeholder() {
    return this._placeholder;
  }
  set placeholder(e) {
    this._placeholder = e, this.update();
  }
  get items() {
    return this._items;
  }
  get scrollTop() {
    return this.ui.list.scrollTop;
  }
  set scrollTop(e) {
    this.ui.list.scrollTop = e;
  }
  set items(e) {
    this._items = e, this.itemsUpdated = !0, this.update();
  }
  get canSelectMany() {
    return this._canSelectMany;
  }
  set canSelectMany(e) {
    this._canSelectMany = e, this.update();
  }
  get canAcceptInBackground() {
    return this._canAcceptInBackground;
  }
  set canAcceptInBackground(e) {
    this._canAcceptInBackground = e;
  }
  get matchOnDescription() {
    return this._matchOnDescription;
  }
  set matchOnDescription(e) {
    this._matchOnDescription = e, this.update();
  }
  get matchOnDetail() {
    return this._matchOnDetail;
  }
  set matchOnDetail(e) {
    this._matchOnDetail = e, this.update();
  }
  get matchOnLabel() {
    return this._matchOnLabel;
  }
  set matchOnLabel(e) {
    this._matchOnLabel = e, this.update();
  }
  get matchOnLabelMode() {
    return this._matchOnLabelMode;
  }
  set matchOnLabelMode(e) {
    this._matchOnLabelMode = e, this.update();
  }
  get sortByLabel() {
    return this._sortByLabel;
  }
  set sortByLabel(e) {
    this._sortByLabel = e, this.update();
  }
  get keepScrollPosition() {
    return this._keepScrollPosition;
  }
  set keepScrollPosition(e) {
    this._keepScrollPosition = e;
  }
  get itemActivation() {
    return this._itemActivation;
  }
  set itemActivation(e) {
    this._itemActivation = e;
  }
  get activeItems() {
    return this._activeItems;
  }
  set activeItems(e) {
    this._activeItems = e, this.activeItemsUpdated = !0, this.update();
  }
  get selectedItems() {
    return this._selectedItems;
  }
  set selectedItems(e) {
    this._selectedItems = e, this.selectedItemsUpdated = !0, this.update();
  }
  get keyMods() {
    return this._quickNavigate ? fne : this.ui.keyMods;
  }
  get valueSelection() {
    const e = this.ui.inputBox.getSelection();
    if (e)
      return [e.start, e.end];
  }
  set valueSelection(e) {
    this._valueSelection = e, this.valueSelectionUpdated = !0, this.update();
  }
  get customButton() {
    return this._customButton;
  }
  set customButton(e) {
    this._customButton = e, this.update();
  }
  get customLabel() {
    return this._customButtonLabel;
  }
  set customLabel(e) {
    this._customButtonLabel = e, this.update();
  }
  get customHover() {
    return this._customButtonHover;
  }
  set customHover(e) {
    this._customButtonHover = e, this.update();
  }
  get ok() {
    return this._ok;
  }
  set ok(e) {
    this._ok = e, this.update();
  }
  get hideInput() {
    return !!this._hideInput;
  }
  set hideInput(e) {
    this._hideInput = e, this.update();
  }
  trySelectFirst() {
    this.canSelectMany || this.ui.list.focus(Bt.First);
  }
  show() {
    this.visible || (this.visibleDisposables.add(this.ui.inputBox.onDidChange((e) => {
      this.doSetValue(
        e,
        !0
        /* skip update since this originates from the UI */
      );
    })), this.visibleDisposables.add(this.ui.onDidAccept(() => {
      this.canSelectMany ? this.ui.list.getCheckedElements().length || (this._selectedItems = [], this.onDidChangeSelectionEmitter.fire(this.selectedItems)) : this.activeItems[0] && (this._selectedItems = [this.activeItems[0]], this.onDidChangeSelectionEmitter.fire(this.selectedItems)), this.handleAccept(!1);
    })), this.visibleDisposables.add(this.ui.onDidCustom(() => {
      this.onDidCustomEmitter.fire();
    })), this.visibleDisposables.add(this._focusEventBufferer.wrapEvent(
      this.ui.list.onDidChangeFocus,
      // Only fire the last event
      (e, t) => t
    )((e) => {
      this.activeItemsUpdated || this.activeItemsToConfirm !== this._activeItems && ci(e, this._activeItems, (t, i) => t === i) || (this._activeItems = e, this.onDidChangeActiveEmitter.fire(e));
    })), this.visibleDisposables.add(this.ui.list.onDidChangeSelection(({ items: e, event: t }) => {
      if (this.canSelectMany) {
        e.length && this.ui.list.setSelectedElements([]);
        return;
      }
      this.selectedItemsToConfirm !== this._selectedItems && ci(e, this._selectedItems, (i, n) => i === n) || (this._selectedItems = e, this.onDidChangeSelectionEmitter.fire(e), e.length && this.handleAccept(
        o1(t) && t.button === 1
        /* mouse middle click */
      ));
    })), this.visibleDisposables.add(this.ui.list.onChangedCheckedElements((e) => {
      this.canSelectMany && (this.selectedItemsToConfirm !== this._selectedItems && ci(e, this._selectedItems, (t, i) => t === i) || (this._selectedItems = e, this.onDidChangeSelectionEmitter.fire(e)));
    })), this.visibleDisposables.add(this.ui.list.onButtonTriggered((e) => this.onDidTriggerItemButtonEmitter.fire(e))), this.visibleDisposables.add(this.ui.list.onSeparatorButtonTriggered((e) => this.onDidTriggerSeparatorButtonEmitter.fire(e))), this.visibleDisposables.add(this.registerQuickNavigation()), this.valueSelectionUpdated = !0), super.show();
  }
  handleAccept(e) {
    let t = !1;
    this.onWillAcceptEmitter.fire({ veto: () => t = !0 }), t || this.onDidAcceptEmitter.fire({ inBackground: e });
  }
  registerQuickNavigation() {
    return W(this.ui.container, Q.KEY_UP, (e) => {
      if (this.canSelectMany || !this._quickNavigate)
        return;
      const t = new Mt(e), i = t.keyCode;
      this._quickNavigate.keybindings.some((o) => {
        const a = o.getChords();
        return a.length > 1 ? !1 : a[0].shiftKey && i === 4 ? !(t.ctrlKey || t.altKey || t.metaKey) : !!(a[0].altKey && i === 6 || a[0].ctrlKey && i === 5 || a[0].metaKey && i === 57);
      }) && (this.activeItems[0] && (this._selectedItems = [this.activeItems[0]], this.onDidChangeSelectionEmitter.fire(this.selectedItems), this.handleAccept(!1)), this._quickNavigate = void 0);
    });
  }
  update() {
    if (!this.visible)
      return;
    const e = this.keepScrollPosition ? this.scrollTop : 0, t = !!this.description, i = {
      title: !!this.title || !!this.step || !!this.buttons.length,
      description: t,
      checkAll: this.canSelectMany && !this._hideCheckAll,
      checkBox: this.canSelectMany,
      inputBox: !this._hideInput,
      progressBar: !this._hideInput || t,
      visibleCount: !0,
      count: this.canSelectMany && !this._hideCountBadge,
      ok: this.ok === "default" ? this.canSelectMany : this.ok,
      list: !0,
      message: !!this.validationMessage,
      customButton: this.customButton
    };
    this.ui.setVisibilities(i), super.update(), this.ui.inputBox.value !== this.value && (this.ui.inputBox.value = this.value), this.valueSelectionUpdated && (this.valueSelectionUpdated = !1, this.ui.inputBox.select(this._valueSelection && { start: this._valueSelection[0], end: this._valueSelection[1] })), this.ui.inputBox.placeholder !== (this.placeholder || "") && (this.ui.inputBox.placeholder = this.placeholder || "");
    let n = this.ariaLabel;
    !n && i.inputBox && (n = this.placeholder || gv.DEFAULT_ARIA_LABEL, this.title && (n += ` - ${this.title}`)), this.ui.list.ariaLabel !== n && (this.ui.list.ariaLabel = n ?? null), this.ui.list.matchOnDescription = this.matchOnDescription, this.ui.list.matchOnDetail = this.matchOnDetail, this.ui.list.matchOnLabel = this.matchOnLabel, this.ui.list.matchOnLabelMode = this.matchOnLabelMode, this.ui.list.sortByLabel = this.sortByLabel, this.itemsUpdated && (this.itemsUpdated = !1, this._focusEventBufferer.bufferEvents(() => {
      switch (this.ui.list.setElements(this.items), this.ui.list.shouldLoop = !this.canSelectMany, this.ui.list.filter(this.filterValue(this.ui.inputBox.value)), this.ui.checkAll.checked = this.ui.list.getAllVisibleChecked(), this.ui.visibleCount.setCount(this.ui.list.getVisibleCount()), this.ui.count.setCount(this.ui.list.getCheckedCount()), this._itemActivation) {
        case Tr.NONE:
          this._itemActivation = Tr.FIRST;
          break;
        case Tr.SECOND:
          this.ui.list.focus(Bt.Second), this._itemActivation = Tr.FIRST;
          break;
        case Tr.LAST:
          this.ui.list.focus(Bt.Last), this._itemActivation = Tr.FIRST;
          break;
        default:
          this.trySelectFirst();
          break;
      }
    })), this.ui.container.classList.contains("show-checkboxes") !== !!this.canSelectMany && (this.canSelectMany ? this.ui.list.clearFocus() : this.trySelectFirst()), this.activeItemsUpdated && (this.activeItemsUpdated = !1, this.activeItemsToConfirm = this._activeItems, this.ui.list.setFocusedElements(this.activeItems), this.activeItemsToConfirm === this._activeItems && (this.activeItemsToConfirm = null)), this.selectedItemsUpdated && (this.selectedItemsUpdated = !1, this.selectedItemsToConfirm = this._selectedItems, this.canSelectMany ? this.ui.list.setCheckedElements(this.selectedItems) : this.ui.list.setSelectedElements(this.selectedItems), this.selectedItemsToConfirm === this._selectedItems && (this.selectedItemsToConfirm = null)), this.ui.customButton.label = this.customLabel || "", this.ui.customButton.element.title = this.customHover || "", i.inputBox || (this.ui.list.domFocus(), this.canSelectMany && this.ui.list.focus(Bt.First)), this.keepScrollPosition && (this.scrollTop = e);
  }
  focus(e) {
    this.ui.list.focus(e), this.canSelectMany && this.ui.list.domFocus();
  }
  accept(e) {
    e && !this._canAcceptInBackground || this.activeItems[0] && (this._selectedItems = [this.activeItems[0]], this.onDidChangeSelectionEmitter.fire(this.selectedItems), this.handleAccept(e ?? !1));
  }
}
gv.DEFAULT_ARIA_LABEL = p("quickInputBox.ariaLabel", "Type to narrow down results.");
let Ine = class extends Eb {
  constructor() {
    super(...arguments), this._value = "", this.valueSelectionUpdated = !0, this._password = !1, this.onDidValueChangeEmitter = this._register(new R()), this.onDidAcceptEmitter = this._register(new R()), this.type = "inputBox", this.onDidChangeValue = this.onDidValueChangeEmitter.event, this.onDidAccept = this.onDidAcceptEmitter.event;
  }
  get value() {
    return this._value;
  }
  set value(e) {
    this._value = e || "", this.update();
  }
  get placeholder() {
    return this._placeholder;
  }
  set placeholder(e) {
    this._placeholder = e, this.update();
  }
  get password() {
    return this._password;
  }
  set password(e) {
    this._password = e, this.update();
  }
  show() {
    this.visible || (this.visibleDisposables.add(this.ui.inputBox.onDidChange((e) => {
      e !== this.value && (this._value = e, this.onDidValueChangeEmitter.fire(e));
    })), this.visibleDisposables.add(this.ui.onDidAccept(() => this.onDidAcceptEmitter.fire())), this.valueSelectionUpdated = !0), super.show();
  }
  update() {
    if (!this.visible)
      return;
    this.ui.container.classList.remove("hidden-input");
    const e = {
      title: !!this.title || !!this.step || !!this.buttons.length,
      description: !!this.description || !!this.step,
      inputBox: !0,
      message: !0,
      progressBar: !0
    };
    this.ui.setVisibilities(e), super.update(), this.ui.inputBox.value !== this.value && (this.ui.inputBox.value = this.value), this.valueSelectionUpdated && (this.valueSelectionUpdated = !1, this.ui.inputBox.select(this._valueSelection && { start: this._valueSelection[0], end: this._valueSelection[1] })), this.ui.inputBox.placeholder !== (this.placeholder || "") && (this.ui.inputBox.placeholder = this.placeholder || ""), this.ui.inputBox.password !== this.password && (this.ui.inputBox.password = this.password);
  }
}, aE = class extends Xf {
  constructor(e, t) {
    super("element", !1, (i) => this.getOverrideOptions(i), e, t);
  }
  getOverrideOptions(e) {
    var t;
    const i = (ln(e.content) ? (t = e.content.textContent) !== null && t !== void 0 ? t : "" : typeof e.content == "string" ? e.content : e.content.value).includes(`
`);
    return {
      persistence: {
        hideOnKeyDown: !1
      },
      appearance: {
        showHoverHint: i,
        skipFadeInAnimation: !0
      }
    };
  }
};
aE = Sne([
  lF(0, Ge),
  lF(1, gl)
], aE);
z.white.toString(), z.white.toString();
class iy extends P {
  get onDidClick() {
    return this._onDidClick.event;
  }
  constructor(e, t) {
    super(), this._label = "", this._onDidClick = this._register(new R()), this._onDidEscape = this._register(new R()), this.options = t, this._element = document.createElement("a"), this._element.classList.add("monaco-button"), this._element.tabIndex = 0, this._element.setAttribute("role", "button"), this._element.classList.toggle("secondary", !!t.secondary);
    const i = t.secondary ? t.buttonSecondaryBackground : t.buttonBackground, n = t.secondary ? t.buttonSecondaryForeground : t.buttonForeground;
    this._element.style.color = n || "", this._element.style.backgroundColor = i || "", t.supportShortLabel && (this._labelShortElement = document.createElement("div"), this._labelShortElement.classList.add("monaco-button-label-short"), this._element.appendChild(this._labelShortElement), this._labelElement = document.createElement("div"), this._labelElement.classList.add("monaco-button-label"), this._element.appendChild(this._labelElement), this._element.classList.add("monaco-text-button-with-short-label")), typeof t.title == "string" && this.setTitle(t.title), typeof t.ariaLabel == "string" && this._element.setAttribute("aria-label", t.ariaLabel), e.appendChild(this._element), this._register(At.addTarget(this._element)), [Q.CLICK, Pt.Tap].forEach((s) => {
      this._register(W(this._element, s, (o) => {
        if (!this.enabled) {
          nt.stop(o);
          return;
        }
        this._onDidClick.fire(o);
      }));
    }), this._register(W(this._element, Q.KEY_DOWN, (s) => {
      const o = new Mt(s);
      let a = !1;
      this.enabled && (o.equals(
        3
        /* KeyCode.Enter */
      ) || o.equals(
        10
        /* KeyCode.Space */
      )) ? (this._onDidClick.fire(s), a = !0) : o.equals(
        9
        /* KeyCode.Escape */
      ) && (this._onDidEscape.fire(s), this._element.blur(), a = !0), a && nt.stop(o, !0);
    })), this._register(W(this._element, Q.MOUSE_OVER, (s) => {
      this._element.classList.contains("disabled") || this.updateBackground(!0);
    })), this._register(W(this._element, Q.MOUSE_OUT, (s) => {
      this.updateBackground(!1);
    })), this.focusTracker = this._register(Xr(this._element)), this._register(this.focusTracker.onDidFocus(() => {
      this.enabled && this.updateBackground(!0);
    })), this._register(this.focusTracker.onDidBlur(() => {
      this.enabled && this.updateBackground(!1);
    }));
  }
  dispose() {
    super.dispose(), this._element.remove();
  }
  getContentElements(e) {
    const t = [];
    for (let i of _c(e))
      if (typeof i == "string") {
        if (i = i.trim(), i === "")
          continue;
        const n = document.createElement("span");
        n.textContent = i, t.push(n);
      } else
        t.push(i);
    return t;
  }
  updateBackground(e) {
    let t;
    this.options.secondary ? t = e ? this.options.buttonSecondaryHoverBackground : this.options.buttonSecondaryBackground : t = e ? this.options.buttonHoverBackground : this.options.buttonBackground, t && (this._element.style.backgroundColor = t);
  }
  get element() {
    return this._element;
  }
  set label(e) {
    var t;
    if (this._label === e || Gr(this._label) && Gr(e) && wee(this._label, e))
      return;
    this._element.classList.add("monaco-text-button");
    const i = this.options.supportShortLabel ? this._labelElement : this._element;
    if (Gr(e)) {
      const s = z0(e, { inline: !0 });
      s.dispose();
      const o = (t = s.element.querySelector("p")) === null || t === void 0 ? void 0 : t.innerHTML;
      if (o) {
        const a = RH(o, { ADD_TAGS: ["b", "i", "u", "code", "span"], ALLOWED_ATTR: ["class"], RETURN_TRUSTED_TYPE: !0 });
        i.innerHTML = a;
      } else
        mn(i);
    } else
      this.options.supportIcons ? mn(i, ...this.getContentElements(e)) : i.textContent = e;
    let n = "";
    typeof this.options.title == "string" ? n = this.options.title : this.options.title && (n = Tee(e)), this.setTitle(n), typeof this.options.ariaLabel == "string" ? this._element.setAttribute("aria-label", this.options.ariaLabel) : this.options.ariaLabel && this._element.setAttribute("aria-label", n), this._label = e;
  }
  get label() {
    return this._label;
  }
  set icon(e) {
    this._element.classList.add(...Le.asClassNameArray(e));
  }
  set enabled(e) {
    e ? (this._element.classList.remove("disabled"), this._element.setAttribute("aria-disabled", String(!1)), this._element.tabIndex = 0) : (this._element.classList.add("disabled"), this._element.setAttribute("aria-disabled", String(!0)));
  }
  get enabled() {
    return !this._element.classList.contains("disabled");
  }
  setTitle(e) {
    var t;
    !this._hover && e !== "" ? this._hover = this._register(da().setupUpdatableHover((t = this.options.hoverDelegate) !== null && t !== void 0 ? t : us("mouse"), this._element, e)) : this._hover && this._hover.update(e);
  }
}
class lE {
  constructor(e, t, i) {
    this.options = t, this.styles = i, this.count = 0, this.element = G(e, X(".monaco-count-badge")), this.countFormat = this.options.countFormat || "{0}", this.titleFormat = this.options.titleFormat || "", this.setCount(this.options.count || 0);
  }
  setCount(e) {
    this.count = e, this.render();
  }
  setTitleFormat(e) {
    this.titleFormat = e, this.render();
  }
  render() {
    var e, t;
    this.element.textContent = vu(this.countFormat, this.count), this.element.title = vu(this.titleFormat, this.count), this.element.style.backgroundColor = (e = this.styles.badgeBackground) !== null && e !== void 0 ? e : "", this.element.style.color = (t = this.styles.badgeForeground) !== null && t !== void 0 ? t : "", this.styles.badgeBorder && (this.element.style.border = `1px solid ${this.styles.badgeBorder}`);
  }
}
const dF = "done", cF = "active", Ik = "infinite", Ek = "infinite-long-running", hF = "discrete";
class iL extends P {
  constructor(e, t) {
    super(), this.progressSignal = this._register(new Yi()), this.workedVal = 0, this.showDelayedScheduler = this._register(new xt(() => As(this.element), 0)), this.longRunningScheduler = this._register(new xt(() => this.infiniteLongRunning(), iL.LONG_RUNNING_INFINITE_THRESHOLD)), this.create(e, t);
  }
  create(e, t) {
    this.element = document.createElement("div"), this.element.classList.add("monaco-progress-container"), this.element.setAttribute("role", "progressbar"), this.element.setAttribute("aria-valuemin", "0"), e.appendChild(this.element), this.bit = document.createElement("div"), this.bit.classList.add("progress-bit"), this.bit.style.backgroundColor = (t == null ? void 0 : t.progressBarBackground) || "#0E70C0", this.element.appendChild(this.bit);
  }
  off() {
    this.bit.style.width = "inherit", this.bit.style.opacity = "1", this.element.classList.remove(cF, Ik, Ek, hF), this.workedVal = 0, this.totalWork = void 0, this.longRunningScheduler.cancel(), this.progressSignal.clear();
  }
  /**
   * Stops the progressbar from showing any progress instantly without fading out.
   */
  stop() {
    return this.doDone(!1);
  }
  doDone(e) {
    return this.element.classList.add(dF), this.element.classList.contains(Ik) ? (this.bit.style.opacity = "0", e ? setTimeout(() => this.off(), 200) : this.off()) : (this.bit.style.width = "inherit", e ? setTimeout(() => this.off(), 200) : this.off()), this;
  }
  /**
   * Use this mode to indicate progress that has no total number of work units.
   */
  infinite() {
    return this.bit.style.width = "2%", this.bit.style.opacity = "1", this.element.classList.remove(hF, dF, Ek), this.element.classList.add(cF, Ik), this.longRunningScheduler.schedule(), this;
  }
  infiniteLongRunning() {
    this.element.classList.add(Ek);
  }
  getContainer() {
    return this.element;
  }
}
iL.LONG_RUNNING_INFINITE_THRESHOLD = 1e4;
const Ene = p("caseDescription", "Match Case"), Tne = p("wordsDescription", "Match Whole Word"), Nne = p("regexDescription", "Use Regular Expression");
class Bz extends Ap {
  constructor(e) {
    var t;
    super({
      icon: me.caseSensitive,
      title: Ene + e.appendTitle,
      isChecked: e.isChecked,
      hoverDelegate: (t = e.hoverDelegate) !== null && t !== void 0 ? t : us("element"),
      inputActiveOptionBorder: e.inputActiveOptionBorder,
      inputActiveOptionForeground: e.inputActiveOptionForeground,
      inputActiveOptionBackground: e.inputActiveOptionBackground
    });
  }
}
class Hz extends Ap {
  constructor(e) {
    var t;
    super({
      icon: me.wholeWord,
      title: Tne + e.appendTitle,
      isChecked: e.isChecked,
      hoverDelegate: (t = e.hoverDelegate) !== null && t !== void 0 ? t : us("element"),
      inputActiveOptionBorder: e.inputActiveOptionBorder,
      inputActiveOptionForeground: e.inputActiveOptionForeground,
      inputActiveOptionBackground: e.inputActiveOptionBackground
    });
  }
}
class Vz extends Ap {
  constructor(e) {
    var t;
    super({
      icon: me.regex,
      title: Nne + e.appendTitle,
      isChecked: e.isChecked,
      hoverDelegate: (t = e.hoverDelegate) !== null && t !== void 0 ? t : us("element"),
      inputActiveOptionBorder: e.inputActiveOptionBorder,
      inputActiveOptionForeground: e.inputActiveOptionForeground,
      inputActiveOptionBackground: e.inputActiveOptionBackground
    });
  }
}
class Mne {
  constructor(e, t = 0, i = e.length, n = t - 1) {
    this.items = e, this.start = t, this.end = i, this.index = n;
  }
  current() {
    return this.index === this.start - 1 || this.index === this.end ? null : this.items[this.index];
  }
  next() {
    return this.index = Math.min(this.index + 1, this.end), this.current();
  }
  previous() {
    return this.index = Math.max(this.index - 1, this.start - 1), this.current();
  }
  first() {
    return this.index = this.start, this.current();
  }
  last() {
    return this.index = this.end - 1, this.current();
  }
}
class Rne {
  constructor(e = [], t = 10) {
    this._initialize(e), this._limit = t, this._onChange();
  }
  getHistory() {
    return this._elements;
  }
  add(e) {
    this._history.delete(e), this._history.add(e), this._onChange();
  }
  next() {
    return this._navigator.next();
  }
  previous() {
    return this._currentPosition() !== 0 ? this._navigator.previous() : null;
  }
  current() {
    return this._navigator.current();
  }
  first() {
    return this._navigator.first();
  }
  last() {
    return this._navigator.last();
  }
  isLast() {
    return this._currentPosition() >= this._elements.length - 1;
  }
  isNowhere() {
    return this._navigator.current() === null;
  }
  has(e) {
    return this._history.has(e);
  }
  _onChange() {
    this._reduceToLimit();
    const e = this._elements;
    this._navigator = new Mne(e, 0, e.length, e.length);
  }
  _reduceToLimit() {
    const e = this._elements;
    e.length > this._limit && this._initialize(e.slice(e.length - this._limit));
  }
  _currentPosition() {
    const e = this._navigator.current();
    return e ? this._elements.indexOf(e) : -1;
  }
  _initialize(e) {
    this._history = /* @__PURE__ */ new Set();
    for (const t of e)
      this._history.add(t);
  }
  get _elements() {
    const e = [];
    return this._history.forEach((t) => e.push(t)), e;
  }
}
const dm = X;
class Ane extends bo {
  constructor(e, t, i) {
    var n;
    super(), this.state = "idle", this.maxHeight = Number.POSITIVE_INFINITY, this._onDidChange = this._register(new R()), this.onDidChange = this._onDidChange.event, this._onDidHeightChange = this._register(new R()), this.onDidHeightChange = this._onDidHeightChange.event, this.contextViewProvider = t, this.options = i, this.message = null, this.placeholder = this.options.placeholder || "", this.tooltip = (n = this.options.tooltip) !== null && n !== void 0 ? n : this.placeholder || "", this.ariaLabel = this.options.ariaLabel || "", this.options.validationOptions && (this.validation = this.options.validationOptions.validation), this.element = G(e, dm(".monaco-inputbox.idle"));
    const s = this.options.flexibleHeight ? "textarea" : "input", o = G(this.element, dm(".ibwrapper"));
    if (this.input = G(o, dm(s + ".input.empty")), this.input.setAttribute("autocorrect", "off"), this.input.setAttribute("autocapitalize", "off"), this.input.setAttribute("spellcheck", "false"), this.onfocus(this.input, () => this.element.classList.add("synthetic-focus")), this.onblur(this.input, () => this.element.classList.remove("synthetic-focus")), this.options.flexibleHeight) {
      this.maxHeight = typeof this.options.flexibleMaxHeight == "number" ? this.options.flexibleMaxHeight : Number.POSITIVE_INFINITY, this.mirror = G(o, dm("div.mirror")), this.mirror.innerText = "", this.scrollableElement = new zV(this.element, {
        vertical: 1
        /* ScrollbarVisibility.Auto */
      }), this.options.flexibleWidth && (this.input.setAttribute("wrap", "off"), this.mirror.style.whiteSpace = "pre", this.mirror.style.wordWrap = "initial"), G(e, this.scrollableElement.getDomNode()), this._register(this.scrollableElement), this._register(this.scrollableElement.onScroll((d) => this.input.scrollTop = d.scrollTop));
      const a = this._register(new tt(e.ownerDocument, "selectionchange")), l = ne.filter(a.event, () => {
        const d = e.ownerDocument.getSelection();
        return (d == null ? void 0 : d.anchorNode) === o;
      });
      this._register(l(this.updateScrollDimensions, this)), this._register(this.onDidHeightChange(this.updateScrollDimensions, this));
    } else
      this.input.type = this.options.type || "text", this.input.setAttribute("wrap", "off");
    this.ariaLabel && this.input.setAttribute("aria-label", this.ariaLabel), this.placeholder && !this.options.showPlaceholderOnFocus && this.setPlaceHolder(this.placeholder), this.tooltip && this.setTooltip(this.tooltip), this.oninput(this.input, () => this.onValueChange()), this.onblur(this.input, () => this.onBlur()), this.onfocus(this.input, () => this.onFocus()), this._register(this.ignoreGesture(this.input)), setTimeout(() => this.updateMirror(), 0), this.options.actions && (this.actionbar = this._register(new Bo(this.element)), this.actionbar.push(this.options.actions, { icon: !0, label: !1 })), this.applyStyles();
  }
  onBlur() {
    this._hideMessage(), this.options.showPlaceholderOnFocus && this.input.setAttribute("placeholder", "");
  }
  onFocus() {
    this._showMessage(), this.options.showPlaceholderOnFocus && this.input.setAttribute("placeholder", this.placeholder || "");
  }
  setPlaceHolder(e) {
    this.placeholder = e, this.input.setAttribute("placeholder", e);
  }
  setTooltip(e) {
    this.tooltip = e, this.hover ? this.hover.update(e) : this.hover = this._register(da().setupUpdatableHover(us("mouse"), this.input, e));
  }
  get inputElement() {
    return this.input;
  }
  get value() {
    return this.input.value;
  }
  set value(e) {
    this.input.value !== e && (this.input.value = e, this.onValueChange());
  }
  get height() {
    return typeof this.cachedHeight == "number" ? this.cachedHeight : Bl(this.element);
  }
  focus() {
    this.input.focus();
  }
  blur() {
    this.input.blur();
  }
  hasFocus() {
    return a0(this.input);
  }
  select(e = null) {
    this.input.select(), e && (this.input.setSelectionRange(e.start, e.end), e.end === this.input.value.length && (this.input.scrollLeft = this.input.scrollWidth));
  }
  isSelectionAtEnd() {
    return this.input.selectionEnd === this.input.value.length && this.input.selectionStart === this.input.selectionEnd;
  }
  getSelection() {
    var e;
    const t = this.input.selectionStart;
    if (t === null)
      return null;
    const i = (e = this.input.selectionEnd) !== null && e !== void 0 ? e : t;
    return {
      start: t,
      end: i
    };
  }
  enable() {
    this.input.removeAttribute("disabled");
  }
  disable() {
    this.blur(), this.input.disabled = !0, this._hideMessage();
  }
  set paddingRight(e) {
    this.input.style.width = `calc(100% - ${e}px)`, this.mirror && (this.mirror.style.paddingRight = e + "px");
  }
  updateScrollDimensions() {
    if (typeof this.cachedContentHeight != "number" || typeof this.cachedHeight != "number" || !this.scrollableElement)
      return;
    const e = this.cachedContentHeight, t = this.cachedHeight, i = this.input.scrollTop;
    this.scrollableElement.setScrollDimensions({ scrollHeight: e, height: t }), this.scrollableElement.setScrollPosition({ scrollTop: i });
  }
  showMessage(e, t) {
    if (this.state === "open" && Xa(this.message, e))
      return;
    this.message = e, this.element.classList.remove("idle"), this.element.classList.remove("info"), this.element.classList.remove("warning"), this.element.classList.remove("error"), this.element.classList.add(this.classForType(e.type));
    const i = this.stylesForType(this.message.type);
    this.element.style.border = `1px solid ${ed(i.border, "transparent")}`, this.message.content && (this.hasFocus() || t) && this._showMessage();
  }
  hideMessage() {
    this.message = null, this.element.classList.remove("info"), this.element.classList.remove("warning"), this.element.classList.remove("error"), this.element.classList.add("idle"), this._hideMessage(), this.applyStyles();
  }
  validate() {
    let e = null;
    return this.validation && (e = this.validation(this.value), e ? (this.inputElement.setAttribute("aria-invalid", "true"), this.showMessage(e)) : this.inputElement.hasAttribute("aria-invalid") && (this.inputElement.removeAttribute("aria-invalid"), this.hideMessage())), e == null ? void 0 : e.type;
  }
  stylesForType(e) {
    const t = this.options.inputBoxStyles;
    switch (e) {
      case 1:
        return { border: t.inputValidationInfoBorder, background: t.inputValidationInfoBackground, foreground: t.inputValidationInfoForeground };
      case 2:
        return { border: t.inputValidationWarningBorder, background: t.inputValidationWarningBackground, foreground: t.inputValidationWarningForeground };
      default:
        return { border: t.inputValidationErrorBorder, background: t.inputValidationErrorBackground, foreground: t.inputValidationErrorForeground };
    }
  }
  classForType(e) {
    switch (e) {
      case 1:
        return "info";
      case 2:
        return "warning";
      default:
        return "error";
    }
  }
  _showMessage() {
    if (!this.contextViewProvider || !this.message)
      return;
    let e;
    const t = () => e.style.width = Ms(this.element) + "px";
    this.contextViewProvider.showContextView({
      getAnchor: () => this.element,
      anchorAlignment: 1,
      render: (n) => {
        var s, o;
        if (!this.message)
          return null;
        e = G(n, dm(".monaco-inputbox-container")), t();
        const a = {
          inline: !0,
          className: "monaco-inputbox-message"
        }, l = this.message.formatContent ? KJ(this.message.content, a) : $J(this.message.content, a);
        l.classList.add(this.classForType(this.message.type));
        const d = this.stylesForType(this.message.type);
        return l.style.backgroundColor = (s = d.background) !== null && s !== void 0 ? s : "", l.style.color = (o = d.foreground) !== null && o !== void 0 ? o : "", l.style.border = d.border ? `1px solid ${d.border}` : "", G(e, l), null;
      },
      onHide: () => {
        this.state = "closed";
      },
      layout: t
    });
    let i;
    this.message.type === 3 ? i = p("alertErrorMessage", "Error: {0}", this.message.content) : this.message.type === 2 ? i = p("alertWarningMessage", "Warning: {0}", this.message.content) : i = p("alertInfoMessage", "Info: {0}", this.message.content), Ls(i), this.state = "open";
  }
  _hideMessage() {
    this.contextViewProvider && (this.state === "open" && this.contextViewProvider.hideContextView(), this.state = "idle");
  }
  onValueChange() {
    this._onDidChange.fire(this.value), this.validate(), this.updateMirror(), this.input.classList.toggle("empty", !this.value), this.state === "open" && this.contextViewProvider && this.contextViewProvider.layout();
  }
  updateMirror() {
    if (!this.mirror)
      return;
    const e = this.value, i = e.charCodeAt(e.length - 1) === 10 ? " " : "";
    (e + i).replace(/\u000c/g, "") ? this.mirror.textContent = e + i : this.mirror.innerText = "", this.layout();
  }
  applyStyles() {
    var e, t, i;
    const n = this.options.inputBoxStyles, s = (e = n.inputBackground) !== null && e !== void 0 ? e : "", o = (t = n.inputForeground) !== null && t !== void 0 ? t : "", a = (i = n.inputBorder) !== null && i !== void 0 ? i : "";
    this.element.style.backgroundColor = s, this.element.style.color = o, this.input.style.backgroundColor = "inherit", this.input.style.color = o, this.element.style.border = `1px solid ${ed(a, "transparent")}`;
  }
  layout() {
    if (!this.mirror)
      return;
    const e = this.cachedContentHeight;
    this.cachedContentHeight = Bl(this.mirror), e !== this.cachedContentHeight && (this.cachedHeight = Math.min(this.cachedContentHeight, this.maxHeight), this.input.style.height = this.cachedHeight + "px", this._onDidHeightChange.fire(this.cachedContentHeight));
  }
  insertAtCursor(e) {
    const t = this.inputElement, i = t.selectionStart, n = t.selectionEnd, s = t.value;
    i !== null && n !== null && (this.value = s.substr(0, i) + e + s.substr(n), t.setSelectionRange(i + 1, i + 1), this.layout());
  }
  dispose() {
    var e;
    this._hideMessage(), this.message = null, (e = this.actionbar) === null || e === void 0 || e.dispose(), super.dispose();
  }
}
class zz extends Ane {
  constructor(e, t, i) {
    const n = p({
      key: "history.inputbox.hint.suffix.noparens",
      comment: ['Text is the suffix of an input field placeholder coming after the action the input field performs, this will be used when the input field ends in a closing parenthesis ")", for example "Filter (e.g. text, !exclude)". The character inserted into the final string is  to represent the up and down arrow keys.']
    }, " or {0} for history", ""), s = p({
      key: "history.inputbox.hint.suffix.inparens",
      comment: ['Text is the suffix of an input field placeholder coming after the action the input field performs, this will be used when the input field does NOT end in a closing parenthesis (eg. "Find"). The character inserted into the final string is  to represent the up and down arrow keys.']
    }, " ({0} for history)", "");
    super(e, t, i), this._onDidFocus = this._register(new R()), this.onDidFocus = this._onDidFocus.event, this._onDidBlur = this._register(new R()), this.onDidBlur = this._onDidBlur.event, this.history = new Rne(i.history, 100);
    const o = () => {
      if (i.showHistoryHint && i.showHistoryHint() && !this.placeholder.endsWith(n) && !this.placeholder.endsWith(s) && this.history.getHistory().length) {
        const a = this.placeholder.endsWith(")") ? n : s, l = this.placeholder + a;
        i.showPlaceholderOnFocus && !a0(this.input) ? this.placeholder = l : this.setPlaceHolder(l);
      }
    };
    this.observer = new MutationObserver((a, l) => {
      a.forEach((d) => {
        d.target.textContent || o();
      });
    }), this.observer.observe(this.input, { attributeFilter: ["class"] }), this.onfocus(this.input, () => o()), this.onblur(this.input, () => {
      const a = (l) => {
        if (this.placeholder.endsWith(l)) {
          const d = this.placeholder.slice(0, this.placeholder.length - l.length);
          return i.showPlaceholderOnFocus ? this.placeholder = d : this.setPlaceHolder(d), !0;
        } else
          return !1;
      };
      a(s) || a(n);
    });
  }
  dispose() {
    super.dispose(), this.observer && (this.observer.disconnect(), this.observer = void 0);
  }
  addToHistory(e) {
    this.value && (e || this.value !== this.getCurrentValue()) && this.history.add(this.value);
  }
  isAtLastInHistory() {
    return this.history.isLast();
  }
  isNowhereInHistory() {
    return this.history.isNowhere();
  }
  showNextValue() {
    this.history.has(this.value) || this.addToHistory();
    let e = this.getNextValue();
    e && (e = e === this.value ? this.getNextValue() : e), this.value = e ?? "", el(this.value ? this.value : p("clearedInput", "Cleared Input"));
  }
  showPreviousValue() {
    this.history.has(this.value) || this.addToHistory();
    let e = this.getPreviousValue();
    e && (e = e === this.value ? this.getPreviousValue() : e), e && (this.value = e, el(this.value));
  }
  setPlaceHolder(e) {
    super.setPlaceHolder(e), this.setTooltip(e);
  }
  onBlur() {
    super.onBlur(), this._onDidBlur.fire();
  }
  onFocus() {
    super.onFocus(), this._onDidFocus.fire();
  }
  getCurrentValue() {
    let e = this.history.current();
    return e || (e = this.history.last(), this.history.next()), e;
  }
  getPreviousValue() {
    return this.history.previous() || this.history.first();
  }
  getNextValue() {
    return this.history.next();
  }
}
const Pne = p("defaultLabel", "input");
class Uz extends bo {
  constructor(e, t, i) {
    super(), this.fixFocusOnOptionClickEnabled = !0, this.imeSessionInProgress = !1, this.additionalTogglesDisposables = this._register(new Yi()), this.additionalToggles = [], this._onDidOptionChange = this._register(new R()), this.onDidOptionChange = this._onDidOptionChange.event, this._onKeyDown = this._register(new R()), this.onKeyDown = this._onKeyDown.event, this._onMouseDown = this._register(new R()), this.onMouseDown = this._onMouseDown.event, this._onInput = this._register(new R()), this._onKeyUp = this._register(new R()), this._onCaseSensitiveKeyDown = this._register(new R()), this.onCaseSensitiveKeyDown = this._onCaseSensitiveKeyDown.event, this._onRegexKeyDown = this._register(new R()), this.onRegexKeyDown = this._onRegexKeyDown.event, this._lastHighlightFindOptions = 0, this.placeholder = i.placeholder || "", this.validation = i.validation, this.label = i.label || Pne, this.showCommonFindToggles = !!i.showCommonFindToggles;
    const n = i.appendCaseSensitiveLabel || "", s = i.appendWholeWordsLabel || "", o = i.appendRegexLabel || "", a = i.history || [], l = !!i.flexibleHeight, d = !!i.flexibleWidth, c = i.flexibleMaxHeight;
    this.domNode = document.createElement("div"), this.domNode.classList.add("monaco-findInput"), this.inputBox = this._register(new zz(this.domNode, t, {
      placeholder: this.placeholder || "",
      ariaLabel: this.label || "",
      validationOptions: {
        validation: this.validation
      },
      history: a,
      showHistoryHint: i.showHistoryHint,
      flexibleHeight: l,
      flexibleWidth: d,
      flexibleMaxHeight: c,
      inputBoxStyles: i.inputBoxStyles
    }));
    const h = this._register(np());
    if (this.showCommonFindToggles) {
      this.regex = this._register(new Vz({
        appendTitle: o,
        isChecked: !1,
        hoverDelegate: h,
        ...i.toggleStyles
      })), this._register(this.regex.onChange((g) => {
        this._onDidOptionChange.fire(g), !g && this.fixFocusOnOptionClickEnabled && this.inputBox.focus(), this.validate();
      })), this._register(this.regex.onKeyDown((g) => {
        this._onRegexKeyDown.fire(g);
      })), this.wholeWords = this._register(new Hz({
        appendTitle: s,
        isChecked: !1,
        hoverDelegate: h,
        ...i.toggleStyles
      })), this._register(this.wholeWords.onChange((g) => {
        this._onDidOptionChange.fire(g), !g && this.fixFocusOnOptionClickEnabled && this.inputBox.focus(), this.validate();
      })), this.caseSensitive = this._register(new Bz({
        appendTitle: n,
        isChecked: !1,
        hoverDelegate: h,
        ...i.toggleStyles
      })), this._register(this.caseSensitive.onChange((g) => {
        this._onDidOptionChange.fire(g), !g && this.fixFocusOnOptionClickEnabled && this.inputBox.focus(), this.validate();
      })), this._register(this.caseSensitive.onKeyDown((g) => {
        this._onCaseSensitiveKeyDown.fire(g);
      }));
      const u = [this.caseSensitive.domNode, this.wholeWords.domNode, this.regex.domNode];
      this.onkeydown(this.domNode, (g) => {
        if (g.equals(
          15
          /* KeyCode.LeftArrow */
        ) || g.equals(
          17
          /* KeyCode.RightArrow */
        ) || g.equals(
          9
          /* KeyCode.Escape */
        )) {
          const f = u.indexOf(this.domNode.ownerDocument.activeElement);
          if (f >= 0) {
            let m = -1;
            g.equals(
              17
              /* KeyCode.RightArrow */
            ) ? m = (f + 1) % u.length : g.equals(
              15
              /* KeyCode.LeftArrow */
            ) && (f === 0 ? m = u.length - 1 : m = f - 1), g.equals(
              9
              /* KeyCode.Escape */
            ) ? (u[f].blur(), this.inputBox.focus()) : m >= 0 && u[m].focus(), nt.stop(g, !0);
          }
        }
      });
    }
    this.controls = document.createElement("div"), this.controls.className = "controls", this.controls.style.display = this.showCommonFindToggles ? "" : "none", this.caseSensitive && this.controls.append(this.caseSensitive.domNode), this.wholeWords && this.controls.appendChild(this.wholeWords.domNode), this.regex && this.controls.appendChild(this.regex.domNode), this.setAdditionalToggles(i == null ? void 0 : i.additionalToggles), this.controls && this.domNode.appendChild(this.controls), e == null || e.appendChild(this.domNode), this._register(W(this.inputBox.inputElement, "compositionstart", (u) => {
      this.imeSessionInProgress = !0;
    })), this._register(W(this.inputBox.inputElement, "compositionend", (u) => {
      this.imeSessionInProgress = !1, this._onInput.fire();
    })), this.onkeydown(this.inputBox.inputElement, (u) => this._onKeyDown.fire(u)), this.onkeyup(this.inputBox.inputElement, (u) => this._onKeyUp.fire(u)), this.oninput(this.inputBox.inputElement, (u) => this._onInput.fire()), this.onmousedown(this.inputBox.inputElement, (u) => this._onMouseDown.fire(u));
  }
  get onDidChange() {
    return this.inputBox.onDidChange;
  }
  layout(e) {
    this.inputBox.layout(), this.updateInputBoxPadding(e.collapsedFindWidget);
  }
  enable() {
    var e, t, i;
    this.domNode.classList.remove("disabled"), this.inputBox.enable(), (e = this.regex) === null || e === void 0 || e.enable(), (t = this.wholeWords) === null || t === void 0 || t.enable(), (i = this.caseSensitive) === null || i === void 0 || i.enable();
    for (const n of this.additionalToggles)
      n.enable();
  }
  disable() {
    var e, t, i;
    this.domNode.classList.add("disabled"), this.inputBox.disable(), (e = this.regex) === null || e === void 0 || e.disable(), (t = this.wholeWords) === null || t === void 0 || t.disable(), (i = this.caseSensitive) === null || i === void 0 || i.disable();
    for (const n of this.additionalToggles)
      n.disable();
  }
  setFocusInputOnOptionClick(e) {
    this.fixFocusOnOptionClickEnabled = e;
  }
  setEnabled(e) {
    e ? this.enable() : this.disable();
  }
  setAdditionalToggles(e) {
    for (const t of this.additionalToggles)
      t.domNode.remove();
    this.additionalToggles = [], this.additionalTogglesDisposables.value = new q();
    for (const t of e ?? [])
      this.additionalTogglesDisposables.value.add(t), this.controls.appendChild(t.domNode), this.additionalTogglesDisposables.value.add(t.onChange((i) => {
        this._onDidOptionChange.fire(i), !i && this.fixFocusOnOptionClickEnabled && this.inputBox.focus();
      })), this.additionalToggles.push(t);
    this.additionalToggles.length > 0 && (this.controls.style.display = ""), this.updateInputBoxPadding();
  }
  updateInputBoxPadding(e = !1) {
    var t, i, n, s, o, a;
    e ? this.inputBox.paddingRight = 0 : this.inputBox.paddingRight = ((i = (t = this.caseSensitive) === null || t === void 0 ? void 0 : t.width()) !== null && i !== void 0 ? i : 0) + ((s = (n = this.wholeWords) === null || n === void 0 ? void 0 : n.width()) !== null && s !== void 0 ? s : 0) + ((a = (o = this.regex) === null || o === void 0 ? void 0 : o.width()) !== null && a !== void 0 ? a : 0) + this.additionalToggles.reduce((l, d) => l + d.width(), 0);
  }
  getValue() {
    return this.inputBox.value;
  }
  setValue(e) {
    this.inputBox.value !== e && (this.inputBox.value = e);
  }
  select() {
    this.inputBox.select();
  }
  focus() {
    this.inputBox.focus();
  }
  getCaseSensitive() {
    var e, t;
    return (t = (e = this.caseSensitive) === null || e === void 0 ? void 0 : e.checked) !== null && t !== void 0 ? t : !1;
  }
  setCaseSensitive(e) {
    this.caseSensitive && (this.caseSensitive.checked = e);
  }
  getWholeWords() {
    var e, t;
    return (t = (e = this.wholeWords) === null || e === void 0 ? void 0 : e.checked) !== null && t !== void 0 ? t : !1;
  }
  setWholeWords(e) {
    this.wholeWords && (this.wholeWords.checked = e);
  }
  getRegex() {
    var e, t;
    return (t = (e = this.regex) === null || e === void 0 ? void 0 : e.checked) !== null && t !== void 0 ? t : !1;
  }
  setRegex(e) {
    this.regex && (this.regex.checked = e, this.validate());
  }
  focusOnCaseSensitive() {
    var e;
    (e = this.caseSensitive) === null || e === void 0 || e.focus();
  }
  highlightFindOptions() {
    this.domNode.classList.remove("highlight-" + this._lastHighlightFindOptions), this._lastHighlightFindOptions = 1 - this._lastHighlightFindOptions, this.domNode.classList.add("highlight-" + this._lastHighlightFindOptions);
  }
  validate() {
    this.inputBox.validate();
  }
  showMessage(e) {
    this.inputBox.showMessage(e);
  }
  clearMessage() {
    this.inputBox.hideMessage();
  }
}
const One = X;
class Fne extends P {
  constructor(e, t, i) {
    super(), this.parent = e, this.onKeyDown = (s) => pi(this.findInput.inputBox.inputElement, Q.KEY_DOWN, s), this.onDidChange = (s) => this.findInput.onDidChange(s), this.container = G(this.parent, One(".quick-input-box")), this.findInput = this._register(new Uz(this.container, void 0, { label: "", inputBoxStyles: t, toggleStyles: i }));
    const n = this.findInput.inputBox.inputElement;
    n.role = "combobox", n.ariaHasPopup = "menu", n.ariaAutoComplete = "list", n.ariaExpanded = "true";
  }
  get value() {
    return this.findInput.getValue();
  }
  set value(e) {
    this.findInput.setValue(e);
  }
  select(e = null) {
    this.findInput.inputBox.select(e);
  }
  getSelection() {
    return this.findInput.inputBox.getSelection();
  }
  isSelectionAtEnd() {
    return this.findInput.inputBox.isSelectionAtEnd();
  }
  get placeholder() {
    return this.findInput.inputBox.inputElement.getAttribute("placeholder") || "";
  }
  set placeholder(e) {
    this.findInput.inputBox.setPlaceHolder(e);
  }
  get password() {
    return this.findInput.inputBox.inputElement.type === "password";
  }
  set password(e) {
    this.findInput.inputBox.inputElement.type = e ? "password" : "text";
  }
  set enabled(e) {
    this.findInput.inputBox.inputElement.toggleAttribute("readonly", !e);
  }
  set toggles(e) {
    this.findInput.setAdditionalToggles(e);
  }
  setAttribute(e, t) {
    this.findInput.inputBox.inputElement.setAttribute(e, t);
  }
  showDecoration(e) {
    e === yi.Ignore ? this.findInput.clearMessage() : this.findInput.showMessage({ type: e === yi.Info ? 1 : e === yi.Warning ? 2 : 3, content: "" });
  }
  stylesForType(e) {
    return this.findInput.inputBox.stylesForType(
      e === yi.Info ? 1 : e === yi.Warning ? 2 : 3
      /* MessageType.ERROR */
    );
  }
  setFocus() {
    this.findInput.focus();
  }
  layout() {
    this.findInput.inputBox.layout();
  }
}
class Wne {
  get templateId() {
    return this.renderer.templateId;
  }
  constructor(e, t) {
    this.renderer = e, this.modelProvider = t;
  }
  renderTemplate(e) {
    return { data: this.renderer.renderTemplate(e), disposable: P.None };
  }
  renderElement(e, t, i, n) {
    var s;
    if ((s = i.disposable) === null || s === void 0 || s.dispose(), !i.data)
      return;
    const o = this.modelProvider();
    if (o.isResolved(e))
      return this.renderer.renderElement(o.get(e), e, i.data, n);
    const a = new mi(), l = o.resolve(e, a.token);
    i.disposable = { dispose: () => a.cancel() }, this.renderer.renderPlaceholder(e, i.data), l.then((d) => this.renderer.renderElement(d, e, i.data, n));
  }
  disposeTemplate(e) {
    e.disposable && (e.disposable.dispose(), e.disposable = void 0), e.data && (this.renderer.disposeTemplate(e.data), e.data = void 0);
  }
}
class Bne {
  constructor(e, t) {
    this.modelProvider = e, this.accessibilityProvider = t;
  }
  getWidgetAriaLabel() {
    return this.accessibilityProvider.getWidgetAriaLabel();
  }
  getAriaLabel(e) {
    const t = this.modelProvider();
    return t.isResolved(e) ? this.accessibilityProvider.getAriaLabel(t.get(e)) : null;
  }
}
function Hne(r, e) {
  return {
    ...e,
    accessibilityProvider: e.accessibilityProvider && new Bne(r, e.accessibilityProvider)
  };
}
class Vne {
  constructor(e, t, i, n, s = {}) {
    const o = () => this.model, a = n.map((l) => new Wne(l, o));
    this.list = new Co(e, t, i, a, Hne(o, s));
  }
  updateOptions(e) {
    this.list.updateOptions(e);
  }
  getHTMLElement() {
    return this.list.getHTMLElement();
  }
  get onDidFocus() {
    return this.list.onDidFocus;
  }
  get widget() {
    return this.list;
  }
  get onDidDispose() {
    return this.list.onDidDispose;
  }
  get onMouseDblClick() {
    return ne.map(this.list.onMouseDblClick, ({ element: e, index: t, browserEvent: i }) => ({ element: e === void 0 ? void 0 : this._model.get(e), index: t, browserEvent: i }));
  }
  get onPointer() {
    return ne.map(this.list.onPointer, ({ element: e, index: t, browserEvent: i }) => ({ element: e === void 0 ? void 0 : this._model.get(e), index: t, browserEvent: i }));
  }
  get onDidChangeSelection() {
    return ne.map(this.list.onDidChangeSelection, ({ elements: e, indexes: t, browserEvent: i }) => ({ elements: e.map((n) => this._model.get(n)), indexes: t, browserEvent: i }));
  }
  get model() {
    return this._model;
  }
  set model(e) {
    this._model = e, this.list.splice(0, this.list.length, _s(e.length));
  }
  getFocus() {
    return this.list.getFocus();
  }
  getSelection() {
    return this.list.getSelection();
  }
  getSelectedElements() {
    return this.getSelection().map((e) => this.model.get(e));
  }
  style(e) {
    this.list.style(e);
  }
  dispose() {
    this.list.dispose();
  }
}
var Pp = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
};
const zne = !1;
var ny;
(function(r) {
  r.North = "north", r.South = "south", r.East = "east", r.West = "west";
})(ny || (ny = {}));
let Une = 4;
const $ne = new R();
let Kne = 300;
const jne = new R();
class vM {
  constructor(e) {
    this.el = e, this.disposables = new q();
  }
  get onPointerMove() {
    return this.disposables.add(new tt(we(this.el), "mousemove")).event;
  }
  get onPointerUp() {
    return this.disposables.add(new tt(we(this.el), "mouseup")).event;
  }
  dispose() {
    this.disposables.dispose();
  }
}
Pp([
  ki
], vM.prototype, "onPointerMove", null);
Pp([
  ki
], vM.prototype, "onPointerUp", null);
class bM {
  get onPointerMove() {
    return this.disposables.add(new tt(this.el, Pt.Change)).event;
  }
  get onPointerUp() {
    return this.disposables.add(new tt(this.el, Pt.End)).event;
  }
  constructor(e) {
    this.el = e, this.disposables = new q();
  }
  dispose() {
    this.disposables.dispose();
  }
}
Pp([
  ki
], bM.prototype, "onPointerMove", null);
Pp([
  ki
], bM.prototype, "onPointerUp", null);
class sy {
  get onPointerMove() {
    return this.factory.onPointerMove;
  }
  get onPointerUp() {
    return this.factory.onPointerUp;
  }
  constructor(e) {
    this.factory = e;
  }
  dispose() {
  }
}
Pp([
  ki
], sy.prototype, "onPointerMove", null);
Pp([
  ki
], sy.prototype, "onPointerUp", null);
const uF = "pointer-events-disabled";
class En extends P {
  get state() {
    return this._state;
  }
  get orthogonalStartSash() {
    return this._orthogonalStartSash;
  }
  get orthogonalEndSash() {
    return this._orthogonalEndSash;
  }
  /**
   * The state of a sash defines whether it can be interacted with by the user
   * as well as what mouse cursor to use, when hovered.
   */
  set state(e) {
    this._state !== e && (this.el.classList.toggle(
      "disabled",
      e === 0
      /* SashState.Disabled */
    ), this.el.classList.toggle(
      "minimum",
      e === 1
      /* SashState.AtMinimum */
    ), this.el.classList.toggle(
      "maximum",
      e === 2
      /* SashState.AtMaximum */
    ), this._state = e, this.onDidEnablementChange.fire(e));
  }
  /**
   * A reference to another sash, perpendicular to this one, which
   * aligns at the start of this one. A corner sash will be created
   * automatically at that location.
   *
   * The start of a horizontal sash is its left-most position.
   * The start of a vertical sash is its top-most position.
   */
  set orthogonalStartSash(e) {
    if (this._orthogonalStartSash !== e) {
      if (this.orthogonalStartDragHandleDisposables.clear(), this.orthogonalStartSashDisposables.clear(), e) {
        const t = (i) => {
          this.orthogonalStartDragHandleDisposables.clear(), i !== 0 && (this._orthogonalStartDragHandle = G(this.el, X(".orthogonal-drag-handle.start")), this.orthogonalStartDragHandleDisposables.add(Se(() => this._orthogonalStartDragHandle.remove())), this.orthogonalStartDragHandleDisposables.add(new tt(this._orthogonalStartDragHandle, "mouseenter")).event(() => En.onMouseEnter(e), void 0, this.orthogonalStartDragHandleDisposables), this.orthogonalStartDragHandleDisposables.add(new tt(this._orthogonalStartDragHandle, "mouseleave")).event(() => En.onMouseLeave(e), void 0, this.orthogonalStartDragHandleDisposables));
        };
        this.orthogonalStartSashDisposables.add(e.onDidEnablementChange.event(t, this)), t(e.state);
      }
      this._orthogonalStartSash = e;
    }
  }
  /**
   * A reference to another sash, perpendicular to this one, which
   * aligns at the end of this one. A corner sash will be created
   * automatically at that location.
   *
   * The end of a horizontal sash is its right-most position.
   * The end of a vertical sash is its bottom-most position.
   */
  set orthogonalEndSash(e) {
    if (this._orthogonalEndSash !== e) {
      if (this.orthogonalEndDragHandleDisposables.clear(), this.orthogonalEndSashDisposables.clear(), e) {
        const t = (i) => {
          this.orthogonalEndDragHandleDisposables.clear(), i !== 0 && (this._orthogonalEndDragHandle = G(this.el, X(".orthogonal-drag-handle.end")), this.orthogonalEndDragHandleDisposables.add(Se(() => this._orthogonalEndDragHandle.remove())), this.orthogonalEndDragHandleDisposables.add(new tt(this._orthogonalEndDragHandle, "mouseenter")).event(() => En.onMouseEnter(e), void 0, this.orthogonalEndDragHandleDisposables), this.orthogonalEndDragHandleDisposables.add(new tt(this._orthogonalEndDragHandle, "mouseleave")).event(() => En.onMouseLeave(e), void 0, this.orthogonalEndDragHandleDisposables));
        };
        this.orthogonalEndSashDisposables.add(e.onDidEnablementChange.event(t, this)), t(e.state);
      }
      this._orthogonalEndSash = e;
    }
  }
  constructor(e, t, i) {
    super(), this.hoverDelay = Kne, this.hoverDelayer = this._register(new pr(this.hoverDelay)), this._state = 3, this.onDidEnablementChange = this._register(new R()), this._onDidStart = this._register(new R()), this._onDidChange = this._register(new R()), this._onDidReset = this._register(new R()), this._onDidEnd = this._register(new R()), this.orthogonalStartSashDisposables = this._register(new q()), this.orthogonalStartDragHandleDisposables = this._register(new q()), this.orthogonalEndSashDisposables = this._register(new q()), this.orthogonalEndDragHandleDisposables = this._register(new q()), this.onDidStart = this._onDidStart.event, this.onDidChange = this._onDidChange.event, this.onDidReset = this._onDidReset.event, this.onDidEnd = this._onDidEnd.event, this.linkedSash = void 0, this.el = G(e, X(".monaco-sash")), i.orthogonalEdge && this.el.classList.add(`orthogonal-edge-${i.orthogonalEdge}`), Je && this.el.classList.add("mac");
    const n = this._register(new tt(this.el, "mousedown")).event;
    this._register(n((h) => this.onPointerStart(h, new vM(e)), this));
    const s = this._register(new tt(this.el, "dblclick")).event;
    this._register(s(this.onPointerDoublePress, this));
    const o = this._register(new tt(this.el, "mouseenter")).event;
    this._register(o(() => En.onMouseEnter(this)));
    const a = this._register(new tt(this.el, "mouseleave")).event;
    this._register(a(() => En.onMouseLeave(this))), this._register(At.addTarget(this.el));
    const l = this._register(new tt(this.el, Pt.Start)).event;
    this._register(l((h) => this.onPointerStart(h, new bM(this.el)), this));
    const d = this._register(new tt(this.el, Pt.Tap)).event;
    let c;
    this._register(d((h) => {
      if (c) {
        clearTimeout(c), c = void 0, this.onPointerDoublePress(h);
        return;
      }
      clearTimeout(c), c = setTimeout(() => c = void 0, 250);
    }, this)), typeof i.size == "number" ? (this.size = i.size, i.orientation === 0 ? this.el.style.width = `${this.size}px` : this.el.style.height = `${this.size}px`) : (this.size = Une, this._register($ne.event((h) => {
      this.size = h, this.layout();
    }))), this._register(jne.event((h) => this.hoverDelay = h)), this.layoutProvider = t, this.orthogonalStartSash = i.orthogonalStartSash, this.orthogonalEndSash = i.orthogonalEndSash, this.orientation = i.orientation || 0, this.orientation === 1 ? (this.el.classList.add("horizontal"), this.el.classList.remove("vertical")) : (this.el.classList.remove("horizontal"), this.el.classList.add("vertical")), this.el.classList.toggle("debug", zne), this.layout();
  }
  onPointerStart(e, t) {
    nt.stop(e);
    let i = !1;
    if (!e.__orthogonalSashEvent) {
      const f = this.getOrthogonalSash(e);
      f && (i = !0, e.__orthogonalSashEvent = !0, f.onPointerStart(e, new sy(t)));
    }
    if (this.linkedSash && !e.__linkedSashEvent && (e.__linkedSashEvent = !0, this.linkedSash.onPointerStart(e, new sy(t))), !this.state)
      return;
    const n = this.el.ownerDocument.getElementsByTagName("iframe");
    for (const f of n)
      f.classList.add(uF);
    const s = e.pageX, o = e.pageY, a = e.altKey, l = { startX: s, currentX: s, startY: o, currentY: o, altKey: a };
    this.el.classList.add("active"), this._onDidStart.fire(l);
    const d = fo(this.el), c = () => {
      let f = "";
      i ? f = "all-scroll" : this.orientation === 1 ? this.state === 1 ? f = "s-resize" : this.state === 2 ? f = "n-resize" : f = Je ? "row-resize" : "ns-resize" : this.state === 1 ? f = "e-resize" : this.state === 2 ? f = "w-resize" : f = Je ? "col-resize" : "ew-resize", d.textContent = `* { cursor: ${f} !important; }`;
    }, h = new q();
    c(), i || this.onDidEnablementChange.event(c, null, h);
    const u = (f) => {
      nt.stop(f, !1);
      const m = { startX: s, currentX: f.pageX, startY: o, currentY: f.pageY, altKey: a };
      this._onDidChange.fire(m);
    }, g = (f) => {
      nt.stop(f, !1), this.el.removeChild(d), this.el.classList.remove("active"), this._onDidEnd.fire(), h.dispose();
      for (const m of n)
        m.classList.remove(uF);
    };
    t.onPointerMove(u, null, h), t.onPointerUp(g, null, h), h.add(t);
  }
  onPointerDoublePress(e) {
    const t = this.getOrthogonalSash(e);
    t && t._onDidReset.fire(), this.linkedSash && this.linkedSash._onDidReset.fire(), this._onDidReset.fire();
  }
  static onMouseEnter(e, t = !1) {
    e.el.classList.contains("active") ? (e.hoverDelayer.cancel(), e.el.classList.add("hover")) : e.hoverDelayer.trigger(() => e.el.classList.add("hover"), e.hoverDelay).then(void 0, () => {
    }), !t && e.linkedSash && En.onMouseEnter(e.linkedSash, !0);
  }
  static onMouseLeave(e, t = !1) {
    e.hoverDelayer.cancel(), e.el.classList.remove("hover"), !t && e.linkedSash && En.onMouseLeave(e.linkedSash, !0);
  }
  /**
   * Forcefully stop any user interactions with this sash.
   * Useful when hiding a parent component, while the user is still
   * interacting with the sash.
   */
  clearSashHoverState() {
    En.onMouseLeave(this);
  }
  /**
   * Layout the sash. The sash will size and position itself
   * based on its provided {@link ISashLayoutProvider layout provider}.
   */
  layout() {
    if (this.orientation === 0) {
      const e = this.layoutProvider;
      this.el.style.left = e.getVerticalSashLeft(this) - this.size / 2 + "px", e.getVerticalSashTop && (this.el.style.top = e.getVerticalSashTop(this) + "px"), e.getVerticalSashHeight && (this.el.style.height = e.getVerticalSashHeight(this) + "px");
    } else {
      const e = this.layoutProvider;
      this.el.style.top = e.getHorizontalSashTop(this) - this.size / 2 + "px", e.getHorizontalSashLeft && (this.el.style.left = e.getHorizontalSashLeft(this) + "px"), e.getHorizontalSashWidth && (this.el.style.width = e.getHorizontalSashWidth(this) + "px");
    }
  }
  getOrthogonalSash(e) {
    var t;
    const i = (t = e.initialTarget) !== null && t !== void 0 ? t : e.target;
    if (!(!i || !ln(i)) && i.classList.contains("orthogonal-drag-handle"))
      return i.classList.contains("start") ? this.orthogonalStartSash : this.orthogonalEndSash;
  }
  dispose() {
    super.dispose(), this.el.remove();
  }
}
const qne = {
  separatorBorder: z.transparent
};
class $z {
  set size(e) {
    this._size = e;
  }
  get size() {
    return this._size;
  }
  get visible() {
    return typeof this._cachedVisibleSize > "u";
  }
  setVisible(e, t) {
    var i, n;
    if (e !== this.visible) {
      e ? (this.size = Yn(this._cachedVisibleSize, this.viewMinimumSize, this.viewMaximumSize), this._cachedVisibleSize = void 0) : (this._cachedVisibleSize = typeof t == "number" ? t : this.size, this.size = 0), this.container.classList.toggle("visible", e);
      try {
        (n = (i = this.view).setVisible) === null || n === void 0 || n.call(i, e);
      } catch (s) {
        console.error("Splitview: Failed to set visible view"), console.error(s);
      }
    }
  }
  get minimumSize() {
    return this.visible ? this.view.minimumSize : 0;
  }
  get viewMinimumSize() {
    return this.view.minimumSize;
  }
  get maximumSize() {
    return this.visible ? this.view.maximumSize : 0;
  }
  get viewMaximumSize() {
    return this.view.maximumSize;
  }
  get priority() {
    return this.view.priority;
  }
  get proportionalLayout() {
    var e;
    return (e = this.view.proportionalLayout) !== null && e !== void 0 ? e : !0;
  }
  get snap() {
    return !!this.view.snap;
  }
  set enabled(e) {
    this.container.style.pointerEvents = e ? "" : "none";
  }
  constructor(e, t, i, n) {
    this.container = e, this.view = t, this.disposable = n, this._cachedVisibleSize = void 0, typeof i == "number" ? (this._size = i, this._cachedVisibleSize = void 0, e.classList.add("visible")) : (this._size = 0, this._cachedVisibleSize = i.cachedVisibleSize);
  }
  layout(e, t) {
    this.layoutContainer(e);
    try {
      this.view.layout(this.size, e, t);
    } catch (i) {
      console.error("Splitview: Failed to layout view"), console.error(i);
    }
  }
  dispose() {
    this.disposable.dispose();
  }
}
class Gne extends $z {
  layoutContainer(e) {
    this.container.style.top = `${e}px`, this.container.style.height = `${this.size}px`;
  }
}
class Zne extends $z {
  layoutContainer(e) {
    this.container.style.left = `${e}px`, this.container.style.width = `${this.size}px`;
  }
}
var xl;
(function(r) {
  r[r.Idle = 0] = "Idle", r[r.Busy = 1] = "Busy";
})(xl || (xl = {}));
var oy;
(function(r) {
  r.Distribute = { type: "distribute" };
  function e(n) {
    return { type: "split", index: n };
  }
  r.Split = e;
  function t(n) {
    return { type: "auto", index: n };
  }
  r.Auto = t;
  function i(n) {
    return { type: "invisible", cachedVisibleSize: n };
  }
  r.Invisible = i;
})(oy || (oy = {}));
class Kz extends P {
  get orthogonalStartSash() {
    return this._orthogonalStartSash;
  }
  get orthogonalEndSash() {
    return this._orthogonalEndSash;
  }
  get startSnappingEnabled() {
    return this._startSnappingEnabled;
  }
  get endSnappingEnabled() {
    return this._endSnappingEnabled;
  }
  /**
   * A reference to a sash, perpendicular to all sashes in this {@link SplitView},
   * located at the left- or top-most side of the SplitView.
   * Corner sashes will be created automatically at the intersections.
   */
  set orthogonalStartSash(e) {
    for (const t of this.sashItems)
      t.sash.orthogonalStartSash = e;
    this._orthogonalStartSash = e;
  }
  /**
   * A reference to a sash, perpendicular to all sashes in this {@link SplitView},
   * located at the right- or bottom-most side of the SplitView.
   * Corner sashes will be created automatically at the intersections.
   */
  set orthogonalEndSash(e) {
    for (const t of this.sashItems)
      t.sash.orthogonalEndSash = e;
    this._orthogonalEndSash = e;
  }
  /**
   * Enable/disable snapping at the beginning of this {@link SplitView}.
   */
  set startSnappingEnabled(e) {
    this._startSnappingEnabled !== e && (this._startSnappingEnabled = e, this.updateSashEnablement());
  }
  /**
   * Enable/disable snapping at the end of this {@link SplitView}.
   */
  set endSnappingEnabled(e) {
    this._endSnappingEnabled !== e && (this._endSnappingEnabled = e, this.updateSashEnablement());
  }
  /**
   * Create a new {@link SplitView} instance.
   */
  constructor(e, t = {}) {
    var i, n, s, o, a;
    super(), this.size = 0, this._contentSize = 0, this.proportions = void 0, this.viewItems = [], this.sashItems = [], this.state = xl.Idle, this._onDidSashChange = this._register(new R()), this._onDidSashReset = this._register(new R()), this._startSnappingEnabled = !0, this._endSnappingEnabled = !0, this.onDidSashChange = this._onDidSashChange.event, this.onDidSashReset = this._onDidSashReset.event, this.orientation = (i = t.orientation) !== null && i !== void 0 ? i : 0, this.inverseAltBehavior = (n = t.inverseAltBehavior) !== null && n !== void 0 ? n : !1, this.proportionalLayout = (s = t.proportionalLayout) !== null && s !== void 0 ? s : !0, this.getSashOrthogonalSize = t.getSashOrthogonalSize, this.el = document.createElement("div"), this.el.classList.add("monaco-split-view2"), this.el.classList.add(this.orientation === 0 ? "vertical" : "horizontal"), e.appendChild(this.el), this.sashContainer = G(this.el, X(".sash-container")), this.viewContainer = X(".split-view-container"), this.scrollable = this._register(new Mp({
      forceIntegerValues: !0,
      smoothScrollDuration: 125,
      scheduleAtNextAnimationFrame: (d) => Us(we(this.el), d)
    })), this.scrollableElement = this._register(new I0(this.viewContainer, {
      vertical: this.orientation === 0 ? (o = t.scrollbarVisibility) !== null && o !== void 0 ? o : 1 : 2,
      horizontal: this.orientation === 1 ? (a = t.scrollbarVisibility) !== null && a !== void 0 ? a : 1 : 2
      /* ScrollbarVisibility.Hidden */
    }, this.scrollable));
    const l = this._register(new tt(this.viewContainer, "scroll")).event;
    this._register(l((d) => {
      const c = this.scrollableElement.getScrollPosition(), h = Math.abs(this.viewContainer.scrollLeft - c.scrollLeft) <= 1 ? void 0 : this.viewContainer.scrollLeft, u = Math.abs(this.viewContainer.scrollTop - c.scrollTop) <= 1 ? void 0 : this.viewContainer.scrollTop;
      (h !== void 0 || u !== void 0) && this.scrollableElement.setScrollPosition({ scrollLeft: h, scrollTop: u });
    })), this.onDidScroll = this.scrollableElement.onScroll, this._register(this.onDidScroll((d) => {
      d.scrollTopChanged && (this.viewContainer.scrollTop = d.scrollTop), d.scrollLeftChanged && (this.viewContainer.scrollLeft = d.scrollLeft);
    })), G(this.el, this.scrollableElement.getDomNode()), this.style(t.styles || qne), t.descriptor && (this.size = t.descriptor.size, t.descriptor.views.forEach((d, c) => {
      const h = Fs(d.visible) || d.visible ? d.size : { type: "invisible", cachedVisibleSize: d.size }, u = d.view;
      this.doAddView(u, h, c, !0);
    }), this._contentSize = this.viewItems.reduce((d, c) => d + c.size, 0), this.saveProportions());
  }
  style(e) {
    e.separatorBorder.isTransparent() ? (this.el.classList.remove("separator-border"), this.el.style.removeProperty("--separator-border")) : (this.el.classList.add("separator-border"), this.el.style.setProperty("--separator-border", e.separatorBorder.toString()));
  }
  /**
   * Add a {@link IView view} to this {@link SplitView}.
   *
   * @param view The view to add.
   * @param size Either a fixed size, or a dynamic {@link Sizing} strategy.
   * @param index The index to insert the view on.
   * @param skipLayout Whether layout should be skipped.
   */
  addView(e, t, i = this.viewItems.length, n) {
    this.doAddView(e, t, i, n);
  }
  /**
   * Layout the {@link SplitView}.
   *
   * @param size The entire size of the {@link SplitView}.
   * @param layoutContext An optional layout context to pass along to {@link IView views}.
   */
  layout(e, t) {
    const i = Math.max(this.size, this._contentSize);
    if (this.size = e, this.layoutContext = t, this.proportions) {
      let n = 0;
      for (let s = 0; s < this.viewItems.length; s++) {
        const o = this.viewItems[s], a = this.proportions[s];
        typeof a == "number" ? n += a : e -= o.size;
      }
      for (let s = 0; s < this.viewItems.length; s++) {
        const o = this.viewItems[s], a = this.proportions[s];
        typeof a == "number" && n > 0 && (o.size = Yn(Math.round(a * e / n), o.minimumSize, o.maximumSize));
      }
    } else {
      const n = _s(this.viewItems.length), s = n.filter(
        (a) => this.viewItems[a].priority === 1
        /* LayoutPriority.Low */
      ), o = n.filter(
        (a) => this.viewItems[a].priority === 2
        /* LayoutPriority.High */
      );
      this.resize(this.viewItems.length - 1, e - i, void 0, s, o);
    }
    this.distributeEmptySpace(), this.layoutViews();
  }
  saveProportions() {
    this.proportionalLayout && this._contentSize > 0 && (this.proportions = this.viewItems.map((e) => e.proportionalLayout && e.visible ? e.size / this._contentSize : void 0));
  }
  onSashStart({ sash: e, start: t, alt: i }) {
    for (const a of this.viewItems)
      a.enabled = !1;
    const n = this.sashItems.findIndex((a) => a.sash === e), s = Ur(W(this.el.ownerDocument.body, "keydown", (a) => o(this.sashDragState.current, a.altKey)), W(this.el.ownerDocument.body, "keyup", () => o(this.sashDragState.current, !1))), o = (a, l) => {
      const d = this.viewItems.map((f) => f.size);
      let c = Number.NEGATIVE_INFINITY, h = Number.POSITIVE_INFINITY;
      if (this.inverseAltBehavior && (l = !l), l)
        if (n === this.sashItems.length - 1) {
          const m = this.viewItems[n];
          c = (m.minimumSize - m.size) / 2, h = (m.maximumSize - m.size) / 2;
        } else {
          const m = this.viewItems[n + 1];
          c = (m.size - m.maximumSize) / 2, h = (m.size - m.minimumSize) / 2;
        }
      let u, g;
      if (!l) {
        const f = _s(n, -1), m = _s(n + 1, this.viewItems.length), _ = f.reduce((E, N) => E + (this.viewItems[N].minimumSize - d[N]), 0), v = f.reduce((E, N) => E + (this.viewItems[N].viewMaximumSize - d[N]), 0), b = m.length === 0 ? Number.POSITIVE_INFINITY : m.reduce((E, N) => E + (d[N] - this.viewItems[N].minimumSize), 0), C = m.length === 0 ? Number.NEGATIVE_INFINITY : m.reduce((E, N) => E + (d[N] - this.viewItems[N].viewMaximumSize), 0), w = Math.max(_, C), S = Math.min(b, v), y = this.findFirstSnapIndex(f), k = this.findFirstSnapIndex(m);
        if (typeof y == "number") {
          const E = this.viewItems[y], N = Math.floor(E.viewMinimumSize / 2);
          u = {
            index: y,
            limitDelta: E.visible ? w - N : w + N,
            size: E.size
          };
        }
        if (typeof k == "number") {
          const E = this.viewItems[k], N = Math.floor(E.viewMinimumSize / 2);
          g = {
            index: k,
            limitDelta: E.visible ? S + N : S - N,
            size: E.size
          };
        }
      }
      this.sashDragState = { start: a, current: a, index: n, sizes: d, minDelta: c, maxDelta: h, alt: l, snapBefore: u, snapAfter: g, disposable: s };
    };
    o(t, i);
  }
  onSashChange({ current: e }) {
    const { index: t, start: i, sizes: n, alt: s, minDelta: o, maxDelta: a, snapBefore: l, snapAfter: d } = this.sashDragState;
    this.sashDragState.current = e;
    const c = e - i, h = this.resize(t, c, n, void 0, void 0, o, a, l, d);
    if (s) {
      const u = t === this.sashItems.length - 1, g = this.viewItems.map((C) => C.size), f = u ? t : t + 1, m = this.viewItems[f], _ = m.size - m.maximumSize, v = m.size - m.minimumSize, b = u ? t - 1 : t + 1;
      this.resize(b, -h, g, void 0, void 0, _, v);
    }
    this.distributeEmptySpace(), this.layoutViews();
  }
  onSashEnd(e) {
    this._onDidSashChange.fire(e), this.sashDragState.disposable.dispose(), this.saveProportions();
    for (const t of this.viewItems)
      t.enabled = !0;
  }
  onViewChange(e, t) {
    const i = this.viewItems.indexOf(e);
    i < 0 || i >= this.viewItems.length || (t = typeof t == "number" ? t : e.size, t = Yn(t, e.minimumSize, e.maximumSize), this.inverseAltBehavior && i > 0 ? (this.resize(i - 1, Math.floor((e.size - t) / 2)), this.distributeEmptySpace(), this.layoutViews()) : (e.size = t, this.relayout([i], void 0)));
  }
  /**
   * Resize a {@link IView view} within the {@link SplitView}.
   *
   * @param index The {@link IView view} index.
   * @param size The {@link IView view} size.
   */
  resizeView(e, t) {
    if (!(e < 0 || e >= this.viewItems.length)) {
      if (this.state !== xl.Idle)
        throw new Error("Cant modify splitview");
      this.state = xl.Busy;
      try {
        const i = _s(this.viewItems.length).filter((a) => a !== e), n = [...i.filter(
          (a) => this.viewItems[a].priority === 1
          /* LayoutPriority.Low */
        ), e], s = i.filter(
          (a) => this.viewItems[a].priority === 2
          /* LayoutPriority.High */
        ), o = this.viewItems[e];
        t = Math.round(t), t = Yn(t, o.minimumSize, Math.min(o.maximumSize, this.size)), o.size = t, this.relayout(n, s);
      } finally {
        this.state = xl.Idle;
      }
    }
  }
  /**
   * Distribute the entire {@link SplitView} size among all {@link IView views}.
   */
  distributeViewSizes() {
    const e = [];
    let t = 0;
    for (const a of this.viewItems)
      a.maximumSize - a.minimumSize > 0 && (e.push(a), t += a.size);
    const i = Math.floor(t / e.length);
    for (const a of e)
      a.size = Yn(i, a.minimumSize, a.maximumSize);
    const n = _s(this.viewItems.length), s = n.filter(
      (a) => this.viewItems[a].priority === 1
      /* LayoutPriority.Low */
    ), o = n.filter(
      (a) => this.viewItems[a].priority === 2
      /* LayoutPriority.High */
    );
    this.relayout(s, o);
  }
  /**
   * Returns the size of a {@link IView view}.
   */
  getViewSize(e) {
    return e < 0 || e >= this.viewItems.length ? -1 : this.viewItems[e].size;
  }
  doAddView(e, t, i = this.viewItems.length, n) {
    if (this.state !== xl.Idle)
      throw new Error("Cant modify splitview");
    this.state = xl.Busy;
    try {
      const s = X(".split-view-view");
      i === this.viewItems.length ? this.viewContainer.appendChild(s) : this.viewContainer.insertBefore(s, this.viewContainer.children.item(i));
      const o = e.onDidChange((u) => this.onViewChange(c, u)), a = Se(() => this.viewContainer.removeChild(s)), l = Ur(o, a);
      let d;
      typeof t == "number" ? d = t : (t.type === "auto" && (this.areViewsDistributed() ? t = { type: "distribute" } : t = { type: "split", index: t.index }), t.type === "split" ? d = this.getViewSize(t.index) / 2 : t.type === "invisible" ? d = { cachedVisibleSize: t.cachedVisibleSize } : d = e.minimumSize);
      const c = this.orientation === 0 ? new Gne(s, e, d, l) : new Zne(s, e, d, l);
      if (this.viewItems.splice(i, 0, c), this.viewItems.length > 1) {
        const u = { orthogonalStartSash: this.orthogonalStartSash, orthogonalEndSash: this.orthogonalEndSash }, g = this.orientation === 0 ? new En(this.sashContainer, { getHorizontalSashTop: (E) => this.getSashPosition(E), getHorizontalSashWidth: this.getSashOrthogonalSize }, {
          ...u,
          orientation: 1
          /* Orientation.HORIZONTAL */
        }) : new En(this.sashContainer, { getVerticalSashLeft: (E) => this.getSashPosition(E), getVerticalSashHeight: this.getSashOrthogonalSize }, {
          ...u,
          orientation: 0
          /* Orientation.VERTICAL */
        }), f = this.orientation === 0 ? (E) => ({ sash: g, start: E.startY, current: E.currentY, alt: E.altKey }) : (E) => ({ sash: g, start: E.startX, current: E.currentX, alt: E.altKey }), _ = ne.map(g.onDidStart, f)(this.onSashStart, this), b = ne.map(g.onDidChange, f)(this.onSashChange, this), w = ne.map(g.onDidEnd, () => this.sashItems.findIndex((E) => E.sash === g))(this.onSashEnd, this), S = g.onDidReset(() => {
          const E = this.sashItems.findIndex((H) => H.sash === g), N = _s(E, -1), F = _s(E + 1, this.viewItems.length), V = this.findFirstSnapIndex(N), Z = this.findFirstSnapIndex(F);
          typeof V == "number" && !this.viewItems[V].visible || typeof Z == "number" && !this.viewItems[Z].visible || this._onDidSashReset.fire(E);
        }), y = Ur(_, b, w, S, g), k = { sash: g, disposable: y };
        this.sashItems.splice(i - 1, 0, k);
      }
      s.appendChild(e.element);
      let h;
      typeof t != "number" && t.type === "split" && (h = [t.index]), n || this.relayout([i], h), !n && typeof t != "number" && t.type === "distribute" && this.distributeViewSizes();
    } finally {
      this.state = xl.Idle;
    }
  }
  relayout(e, t) {
    const i = this.viewItems.reduce((n, s) => n + s.size, 0);
    this.resize(this.viewItems.length - 1, this.size - i, void 0, e, t), this.distributeEmptySpace(), this.layoutViews(), this.saveProportions();
  }
  resize(e, t, i = this.viewItems.map((c) => c.size), n, s, o = Number.NEGATIVE_INFINITY, a = Number.POSITIVE_INFINITY, l, d) {
    if (e < 0 || e >= this.viewItems.length)
      return 0;
    const c = _s(e, -1), h = _s(e + 1, this.viewItems.length);
    if (s)
      for (const k of s)
        CD(c, k), CD(h, k);
    if (n)
      for (const k of n)
        tC(c, k), tC(h, k);
    const u = c.map((k) => this.viewItems[k]), g = c.map((k) => i[k]), f = h.map((k) => this.viewItems[k]), m = h.map((k) => i[k]), _ = c.reduce((k, E) => k + (this.viewItems[E].minimumSize - i[E]), 0), v = c.reduce((k, E) => k + (this.viewItems[E].maximumSize - i[E]), 0), b = h.length === 0 ? Number.POSITIVE_INFINITY : h.reduce((k, E) => k + (i[E] - this.viewItems[E].minimumSize), 0), C = h.length === 0 ? Number.NEGATIVE_INFINITY : h.reduce((k, E) => k + (i[E] - this.viewItems[E].maximumSize), 0), w = Math.max(_, C, o), S = Math.min(b, v, a);
    let y = !1;
    if (l) {
      const k = this.viewItems[l.index], E = t >= l.limitDelta;
      y = E !== k.visible, k.setVisible(E, l.size);
    }
    if (!y && d) {
      const k = this.viewItems[d.index], E = t < d.limitDelta;
      y = E !== k.visible, k.setVisible(E, d.size);
    }
    if (y)
      return this.resize(e, t, i, n, s, o, a);
    t = Yn(t, w, S);
    for (let k = 0, E = t; k < u.length; k++) {
      const N = u[k], F = Yn(g[k] + E, N.minimumSize, N.maximumSize), V = F - g[k];
      E -= V, N.size = F;
    }
    for (let k = 0, E = t; k < f.length; k++) {
      const N = f[k], F = Yn(m[k] - E, N.minimumSize, N.maximumSize), V = F - m[k];
      E += V, N.size = F;
    }
    return t;
  }
  distributeEmptySpace(e) {
    const t = this.viewItems.reduce((a, l) => a + l.size, 0);
    let i = this.size - t;
    const n = _s(this.viewItems.length - 1, -1), s = n.filter(
      (a) => this.viewItems[a].priority === 1
      /* LayoutPriority.Low */
    ), o = n.filter(
      (a) => this.viewItems[a].priority === 2
      /* LayoutPriority.High */
    );
    for (const a of o)
      CD(n, a);
    for (const a of s)
      tC(n, a);
    typeof e == "number" && tC(n, e);
    for (let a = 0; i !== 0 && a < n.length; a++) {
      const l = this.viewItems[n[a]], d = Yn(l.size + i, l.minimumSize, l.maximumSize), c = d - l.size;
      i -= c, l.size = d;
    }
  }
  layoutViews() {
    this._contentSize = this.viewItems.reduce((t, i) => t + i.size, 0);
    let e = 0;
    for (const t of this.viewItems)
      t.layout(e, this.layoutContext), e += t.size;
    this.sashItems.forEach((t) => t.sash.layout()), this.updateSashEnablement(), this.updateScrollableElement();
  }
  updateScrollableElement() {
    this.orientation === 0 ? this.scrollableElement.setScrollDimensions({
      height: this.size,
      scrollHeight: this._contentSize
    }) : this.scrollableElement.setScrollDimensions({
      width: this.size,
      scrollWidth: this._contentSize
    });
  }
  updateSashEnablement() {
    let e = !1;
    const t = this.viewItems.map((l) => e = l.size - l.minimumSize > 0 || e);
    e = !1;
    const i = this.viewItems.map((l) => e = l.maximumSize - l.size > 0 || e), n = [...this.viewItems].reverse();
    e = !1;
    const s = n.map((l) => e = l.size - l.minimumSize > 0 || e).reverse();
    e = !1;
    const o = n.map((l) => e = l.maximumSize - l.size > 0 || e).reverse();
    let a = 0;
    for (let l = 0; l < this.sashItems.length; l++) {
      const { sash: d } = this.sashItems[l], c = this.viewItems[l];
      a += c.size;
      const h = !(t[l] && o[l + 1]), u = !(i[l] && s[l + 1]);
      if (h && u) {
        const g = _s(l, -1), f = _s(l + 1, this.viewItems.length), m = this.findFirstSnapIndex(g), _ = this.findFirstSnapIndex(f), v = typeof m == "number" && !this.viewItems[m].visible, b = typeof _ == "number" && !this.viewItems[_].visible;
        v && s[l] && (a > 0 || this.startSnappingEnabled) ? d.state = 1 : b && t[l] && (a < this._contentSize || this.endSnappingEnabled) ? d.state = 2 : d.state = 0;
      } else h && !u ? d.state = 1 : !h && u ? d.state = 2 : d.state = 3;
    }
  }
  getSashPosition(e) {
    let t = 0;
    for (let i = 0; i < this.sashItems.length; i++)
      if (t += this.viewItems[i].size, this.sashItems[i].sash === e)
        return t;
    return 0;
  }
  findFirstSnapIndex(e) {
    for (const t of e) {
      const i = this.viewItems[t];
      if (i.visible && i.snap)
        return t;
    }
    for (const t of e) {
      const i = this.viewItems[t];
      if (i.visible && i.maximumSize - i.minimumSize > 0)
        return;
      if (!i.visible && i.snap)
        return t;
    }
  }
  areViewsDistributed() {
    let e, t;
    for (const i of this.viewItems)
      if (e = e === void 0 ? i.size : Math.min(e, i.size), t = t === void 0 ? i.size : Math.max(t, i.size), t - e > 2)
        return !1;
    return !0;
  }
  dispose() {
    var e;
    (e = this.sashDragState) === null || e === void 0 || e.disposable.dispose(), zt(this.viewItems), this.viewItems = [], this.sashItems.forEach((t) => t.disposable.dispose()), this.sashItems = [], super.dispose();
  }
}
class Tb {
  constructor(e, t, i) {
    this.columns = e, this.getColumnSize = i, this.templateId = Tb.TemplateId, this.renderedTemplates = /* @__PURE__ */ new Set();
    const n = new Map(t.map((s) => [s.templateId, s]));
    this.renderers = [];
    for (const s of e) {
      const o = n.get(s.templateId);
      if (!o)
        throw new Error(`Table cell renderer for template id ${s.templateId} not found.`);
      this.renderers.push(o);
    }
  }
  renderTemplate(e) {
    const t = G(e, X(".monaco-table-tr")), i = [], n = [];
    for (let o = 0; o < this.columns.length; o++) {
      const a = this.renderers[o], l = G(t, X(".monaco-table-td", { "data-col-index": o }));
      l.style.width = `${this.getColumnSize(o)}px`, i.push(l), n.push(a.renderTemplate(l));
    }
    const s = { container: e, cellContainers: i, cellTemplateData: n };
    return this.renderedTemplates.add(s), s;
  }
  renderElement(e, t, i, n) {
    for (let s = 0; s < this.columns.length; s++) {
      const a = this.columns[s].project(e);
      this.renderers[s].renderElement(a, t, i.cellTemplateData[s], n);
    }
  }
  disposeElement(e, t, i, n) {
    for (let s = 0; s < this.columns.length; s++) {
      const o = this.renderers[s];
      if (o.disposeElement) {
        const l = this.columns[s].project(e);
        o.disposeElement(l, t, i.cellTemplateData[s], n);
      }
    }
  }
  disposeTemplate(e) {
    for (let t = 0; t < this.columns.length; t++)
      this.renderers[t].disposeTemplate(e.cellTemplateData[t]);
    pn(e.container), this.renderedTemplates.delete(e);
  }
  layoutColumn(e, t) {
    for (const { cellContainers: i } of this.renderedTemplates)
      i[e].style.width = `${t}px`;
  }
}
Tb.TemplateId = "row";
function Yne(r) {
  return {
    getHeight(e) {
      return r.getHeight(e);
    },
    getTemplateId() {
      return Tb.TemplateId;
    }
  };
}
class Qne extends P {
  get minimumSize() {
    var e;
    return (e = this.column.minimumWidth) !== null && e !== void 0 ? e : 120;
  }
  get maximumSize() {
    var e;
    return (e = this.column.maximumWidth) !== null && e !== void 0 ? e : Number.POSITIVE_INFINITY;
  }
  get onDidChange() {
    var e;
    return (e = this.column.onDidChangeWidthConstraints) !== null && e !== void 0 ? e : ne.None;
  }
  constructor(e, t) {
    super(), this.column = e, this.index = t, this._onDidLayout = new R(), this.onDidLayout = this._onDidLayout.event, this.element = X(".monaco-table-th", { "data-col-index": t }, e.label), e.tooltip && this._register(da().setupUpdatableHover(us("mouse"), this.element, e.tooltip));
  }
  layout(e) {
    this._onDidLayout.fire([this.index, e]);
  }
}
class nL {
  get onDidChangeFocus() {
    return this.list.onDidChangeFocus;
  }
  get onDidChangeSelection() {
    return this.list.onDidChangeSelection;
  }
  get onDidScroll() {
    return this.list.onDidScroll;
  }
  get onMouseDblClick() {
    return this.list.onMouseDblClick;
  }
  get onPointer() {
    return this.list.onPointer;
  }
  get onDidFocus() {
    return this.list.onDidFocus;
  }
  get scrollTop() {
    return this.list.scrollTop;
  }
  set scrollTop(e) {
    this.list.scrollTop = e;
  }
  get scrollHeight() {
    return this.list.scrollHeight;
  }
  get renderHeight() {
    return this.list.renderHeight;
  }
  get onDidDispose() {
    return this.list.onDidDispose;
  }
  constructor(e, t, i, n, s, o) {
    this.virtualDelegate = i, this.domId = `table_id_${++nL.InstanceCount}`, this.disposables = new q(), this.cachedWidth = 0, this.cachedHeight = 0, this.domNode = G(t, X(`.monaco-table.${this.domId}`));
    const a = n.map((c, h) => this.disposables.add(new Qne(c, h))), l = {
      size: a.reduce((c, h) => c + h.column.weight, 0),
      views: a.map((c) => ({ size: c.column.weight, view: c }))
    };
    this.splitview = this.disposables.add(new Kz(this.domNode, {
      orientation: 1,
      scrollbarVisibility: 2,
      getSashOrthogonalSize: () => this.cachedHeight,
      descriptor: l
    })), this.splitview.el.style.height = `${i.headerRowHeight}px`, this.splitview.el.style.lineHeight = `${i.headerRowHeight}px`;
    const d = new Tb(n, s, (c) => this.splitview.getViewSize(c));
    this.list = this.disposables.add(new Co(e, this.domNode, Yne(i), [d], o)), ne.any(...a.map((c) => c.onDidLayout))(([c, h]) => d.layoutColumn(c, h), null, this.disposables), this.splitview.onDidSashReset((c) => {
      const h = n.reduce((g, f) => g + f.weight, 0), u = n[c].weight / h * this.cachedWidth;
      this.splitview.resizeView(c, u);
    }, null, this.disposables), this.styleElement = fo(this.domNode), this.style(Tie);
  }
  updateOptions(e) {
    this.list.updateOptions(e);
  }
  splice(e, t, i = []) {
    this.list.splice(e, t, i);
  }
  getHTMLElement() {
    return this.domNode;
  }
  style(e) {
    const t = [];
    t.push(`.monaco-table.${this.domId} > .monaco-split-view2 .monaco-sash.vertical::before {
			top: ${this.virtualDelegate.headerRowHeight + 1}px;
			height: calc(100% - ${this.virtualDelegate.headerRowHeight}px);
		}`), this.styleElement.textContent = t.join(`
`), this.list.style(e);
  }
  getSelectedElements() {
    return this.list.getSelectedElements();
  }
  getSelection() {
    return this.list.getSelection();
  }
  getFocus() {
    return this.list.getFocus();
  }
  dispose() {
    this.disposables.dispose();
  }
}
nL.InstanceCount = 0;
var no;
(function(r) {
  r[r.Expanded = 0] = "Expanded", r[r.Collapsed = 1] = "Collapsed", r[r.PreserveOrExpanded = 2] = "PreserveOrExpanded", r[r.PreserveOrCollapsed = 3] = "PreserveOrCollapsed";
})(no || (no = {}));
var Jh;
(function(r) {
  r[r.Unknown = 0] = "Unknown", r[r.Twistie = 1] = "Twistie", r[r.Element = 2] = "Element", r[r.Filter = 3] = "Filter";
})(Jh || (Jh = {}));
class ao extends Error {
  constructor(e, t) {
    super(`TreeError [${e}] ${t}`);
  }
}
class CM {
  constructor(e) {
    this.fn = e, this._map = /* @__PURE__ */ new WeakMap();
  }
  map(e) {
    let t = this._map.get(e);
    return t || (t = this.fn(e), this._map.set(e, t)), t;
  }
}
function wM(r) {
  return typeof r == "object" && "visibility" in r && "data" in r;
}
function fv(r) {
  switch (r) {
    case !0:
      return 1;
    case !1:
      return 0;
    default:
      return r;
  }
}
function Tk(r) {
  return typeof r.collapsible == "boolean";
}
class Xne {
  constructor(e, t, i, n = {}) {
    var s;
    this.user = e, this.list = t, this.rootRef = [], this.eventBufferer = new n0(), this._onDidChangeCollapseState = new R(), this.onDidChangeCollapseState = this.eventBufferer.wrapEvent(this._onDidChangeCollapseState.event), this._onDidChangeRenderNodeCount = new R(), this.onDidChangeRenderNodeCount = this.eventBufferer.wrapEvent(this._onDidChangeRenderNodeCount.event), this._onDidSplice = new R(), this.onDidSplice = this._onDidSplice.event, this.refilterDelayer = new pr(DH), this.collapseByDefault = typeof n.collapseByDefault > "u" ? !1 : n.collapseByDefault, this.allowNonCollapsibleParents = (s = n.allowNonCollapsibleParents) !== null && s !== void 0 ? s : !1, this.filter = n.filter, this.autoExpandSingleChildren = typeof n.autoExpandSingleChildren > "u" ? !1 : n.autoExpandSingleChildren, this.root = {
      parent: void 0,
      element: i,
      children: [],
      depth: 0,
      visibleChildrenCount: 0,
      visibleChildIndex: -1,
      collapsible: !1,
      collapsed: !1,
      renderNodeCount: 0,
      visibility: 1,
      visible: !0,
      filterData: void 0
    };
  }
  splice(e, t, i = ut.empty(), n = {}) {
    if (e.length === 0)
      throw new ao(this.user, "Invalid tree location");
    n.diffIdentityProvider ? this.spliceSmart(n.diffIdentityProvider, e, t, i, n) : this.spliceSimple(e, t, i, n);
  }
  spliceSmart(e, t, i, n, s, o) {
    var a;
    n === void 0 && (n = ut.empty()), o === void 0 && (o = (a = s.diffDepth) !== null && a !== void 0 ? a : 0);
    const { parentNode: l } = this.getParentNodeWithListIndex(t);
    if (!l.lastDiffIds)
      return this.spliceSimple(t, i, n, s);
    const d = [...n], c = t[t.length - 1], h = new dH({ getElements: () => l.lastDiffIds }, {
      getElements: () => [
        ...l.children.slice(0, c),
        ...d,
        ...l.children.slice(c + i)
      ].map((_) => e.getId(_.element).toString())
    }).ComputeDiff(!1);
    if (h.quitEarly)
      return l.lastDiffIds = void 0, this.spliceSimple(t, i, d, s);
    const u = t.slice(0, -1), g = (_, v, b) => {
      if (o > 0)
        for (let C = 0; C < b; C++)
          _--, v--, this.spliceSmart(e, [...u, _, 0], Number.MAX_SAFE_INTEGER, d[v].children, s, o - 1);
    };
    let f = Math.min(l.children.length, c + i), m = d.length;
    for (const _ of h.changes.sort((v, b) => b.originalStart - v.originalStart))
      g(f, m, f - (_.originalStart + _.originalLength)), f = _.originalStart, m = _.modifiedStart - c, this.spliceSimple([...u, f], _.originalLength, ut.slice(d, m, m + _.modifiedLength), s);
    g(f, m, f);
  }
  spliceSimple(e, t, i = ut.empty(), { onDidCreateNode: n, onDidDeleteNode: s, diffIdentityProvider: o }) {
    const { parentNode: a, listIndex: l, revealed: d, visible: c } = this.getParentNodeWithListIndex(e), h = [], u = ut.map(i, (S) => this.createTreeNode(S, a, a.visible ? 1 : 0, d, h, n)), g = e[e.length - 1];
    let f = 0;
    for (let S = g; S >= 0 && S < a.children.length; S--) {
      const y = a.children[S];
      if (y.visible) {
        f = y.visibleChildIndex;
        break;
      }
    }
    const m = [];
    let _ = 0, v = 0;
    for (const S of u)
      m.push(S), v += S.renderNodeCount, S.visible && (S.visibleChildIndex = f + _++);
    const b = oA(a.children, g, t, m);
    o ? a.lastDiffIds ? oA(a.lastDiffIds, g, t, m.map((S) => o.getId(S.element).toString())) : a.lastDiffIds = a.children.map((S) => o.getId(S.element).toString()) : a.lastDiffIds = void 0;
    let C = 0;
    for (const S of b)
      S.visible && C++;
    if (C !== 0)
      for (let S = g + m.length; S < a.children.length; S++) {
        const y = a.children[S];
        y.visible && (y.visibleChildIndex -= C);
      }
    if (a.visibleChildrenCount += _ - C, d && c) {
      const S = b.reduce((y, k) => y + (k.visible ? k.renderNodeCount : 0), 0);
      this._updateAncestorsRenderNodeCount(a, v - S), this.list.splice(l, S, h);
    }
    if (b.length > 0 && s) {
      const S = (y) => {
        s(y), y.children.forEach(S);
      };
      b.forEach(S);
    }
    this._onDidSplice.fire({ insertedNodes: m, deletedNodes: b });
    let w = a;
    for (; w; ) {
      if (w.visibility === 2) {
        this.refilterDelayer.trigger(() => this.refilter());
        break;
      }
      w = w.parent;
    }
  }
  rerender(e) {
    if (e.length === 0)
      throw new ao(this.user, "Invalid tree location");
    const { node: t, listIndex: i, revealed: n } = this.getTreeNodeWithListIndex(e);
    t.visible && n && this.list.splice(i, 1, [t]);
  }
  has(e) {
    return this.hasTreeNode(e);
  }
  getListIndex(e) {
    const { listIndex: t, visible: i, revealed: n } = this.getTreeNodeWithListIndex(e);
    return i && n ? t : -1;
  }
  getListRenderCount(e) {
    return this.getTreeNode(e).renderNodeCount;
  }
  isCollapsible(e) {
    return this.getTreeNode(e).collapsible;
  }
  setCollapsible(e, t) {
    const i = this.getTreeNode(e);
    typeof t > "u" && (t = !i.collapsible);
    const n = { collapsible: t };
    return this.eventBufferer.bufferEvents(() => this._setCollapseState(e, n));
  }
  isCollapsed(e) {
    return this.getTreeNode(e).collapsed;
  }
  setCollapsed(e, t, i) {
    const n = this.getTreeNode(e);
    typeof t > "u" && (t = !n.collapsed);
    const s = { collapsed: t, recursive: i || !1 };
    return this.eventBufferer.bufferEvents(() => this._setCollapseState(e, s));
  }
  _setCollapseState(e, t) {
    const { node: i, listIndex: n, revealed: s } = this.getTreeNodeWithListIndex(e), o = this._setListNodeCollapseState(i, n, s, t);
    if (i !== this.root && this.autoExpandSingleChildren && o && !Tk(t) && i.collapsible && !i.collapsed && !t.recursive) {
      let a = -1;
      for (let l = 0; l < i.children.length; l++)
        if (i.children[l].visible)
          if (a > -1) {
            a = -1;
            break;
          } else
            a = l;
      a > -1 && this._setCollapseState([...e, a], t);
    }
    return o;
  }
  _setListNodeCollapseState(e, t, i, n) {
    const s = this._setNodeCollapseState(e, n, !1);
    if (!i || !e.visible || !s)
      return s;
    const o = e.renderNodeCount, a = this.updateNodeAfterCollapseChange(e), l = o - (t === -1 ? 0 : 1);
    return this.list.splice(t + 1, l, a.slice(1)), s;
  }
  _setNodeCollapseState(e, t, i) {
    let n;
    if (e === this.root ? n = !1 : (Tk(t) ? (n = e.collapsible !== t.collapsible, e.collapsible = t.collapsible) : e.collapsible ? (n = e.collapsed !== t.collapsed, e.collapsed = t.collapsed) : n = !1, n && this._onDidChangeCollapseState.fire({ node: e, deep: i })), !Tk(t) && t.recursive)
      for (const s of e.children)
        n = this._setNodeCollapseState(s, t, !0) || n;
    return n;
  }
  expandTo(e) {
    this.eventBufferer.bufferEvents(() => {
      let t = this.getTreeNode(e);
      for (; t.parent; )
        t = t.parent, e = e.slice(0, e.length - 1), t.collapsed && this._setCollapseState(e, { collapsed: !1, recursive: !1 });
    });
  }
  refilter() {
    const e = this.root.renderNodeCount, t = this.updateNodeAfterFilterChange(this.root);
    this.list.splice(0, e, t), this.refilterDelayer.cancel();
  }
  createTreeNode(e, t, i, n, s, o) {
    const a = {
      parent: t,
      element: e.element,
      children: [],
      depth: t.depth + 1,
      visibleChildrenCount: 0,
      visibleChildIndex: -1,
      collapsible: typeof e.collapsible == "boolean" ? e.collapsible : typeof e.collapsed < "u",
      collapsed: typeof e.collapsed > "u" ? this.collapseByDefault : e.collapsed,
      renderNodeCount: 1,
      visibility: 1,
      visible: !0,
      filterData: void 0
    }, l = this._filterNode(a, i);
    a.visibility = l, n && s.push(a);
    const d = e.children || ut.empty(), c = n && l !== 0 && !a.collapsed;
    let h = 0, u = 1;
    for (const g of d) {
      const f = this.createTreeNode(g, a, l, c, s, o);
      a.children.push(f), u += f.renderNodeCount, f.visible && (f.visibleChildIndex = h++);
    }
    return this.allowNonCollapsibleParents || (a.collapsible = a.collapsible || a.children.length > 0), a.visibleChildrenCount = h, a.visible = l === 2 ? h > 0 : l === 1, a.visible ? a.collapsed || (a.renderNodeCount = u) : (a.renderNodeCount = 0, n && s.pop()), o == null || o(a), a;
  }
  updateNodeAfterCollapseChange(e) {
    const t = e.renderNodeCount, i = [];
    return this._updateNodeAfterCollapseChange(e, i), this._updateAncestorsRenderNodeCount(e.parent, i.length - t), i;
  }
  _updateNodeAfterCollapseChange(e, t) {
    if (e.visible === !1)
      return 0;
    if (t.push(e), e.renderNodeCount = 1, !e.collapsed)
      for (const i of e.children)
        e.renderNodeCount += this._updateNodeAfterCollapseChange(i, t);
    return this._onDidChangeRenderNodeCount.fire(e), e.renderNodeCount;
  }
  updateNodeAfterFilterChange(e) {
    const t = e.renderNodeCount, i = [];
    return this._updateNodeAfterFilterChange(e, e.visible ? 1 : 0, i), this._updateAncestorsRenderNodeCount(e.parent, i.length - t), i;
  }
  _updateNodeAfterFilterChange(e, t, i, n = !0) {
    let s;
    if (e !== this.root) {
      if (s = this._filterNode(e, t), s === 0)
        return e.visible = !1, e.renderNodeCount = 0, !1;
      n && i.push(e);
    }
    const o = i.length;
    e.renderNodeCount = e === this.root ? 0 : 1;
    let a = !1;
    if (!e.collapsed || s !== 0) {
      let l = 0;
      for (const d of e.children)
        a = this._updateNodeAfterFilterChange(d, s, i, n && !e.collapsed) || a, d.visible && (d.visibleChildIndex = l++);
      e.visibleChildrenCount = l;
    } else
      e.visibleChildrenCount = 0;
    return e !== this.root && (e.visible = s === 2 ? a : s === 1, e.visibility = s), e.visible ? e.collapsed || (e.renderNodeCount += i.length - o) : (e.renderNodeCount = 0, n && i.pop()), this._onDidChangeRenderNodeCount.fire(e), e.visible;
  }
  _updateAncestorsRenderNodeCount(e, t) {
    if (t !== 0)
      for (; e; )
        e.renderNodeCount += t, this._onDidChangeRenderNodeCount.fire(e), e = e.parent;
  }
  _filterNode(e, t) {
    const i = this.filter ? this.filter.filter(e.element, t) : 1;
    return typeof i == "boolean" ? (e.filterData = void 0, i ? 1 : 0) : wM(i) ? (e.filterData = i.data, fv(i.visibility)) : (e.filterData = void 0, fv(i));
  }
  // cheap
  hasTreeNode(e, t = this.root) {
    if (!e || e.length === 0)
      return !0;
    const [i, ...n] = e;
    return i < 0 || i > t.children.length ? !1 : this.hasTreeNode(n, t.children[i]);
  }
  // cheap
  getTreeNode(e, t = this.root) {
    if (!e || e.length === 0)
      return t;
    const [i, ...n] = e;
    if (i < 0 || i > t.children.length)
      throw new ao(this.user, "Invalid tree location");
    return this.getTreeNode(n, t.children[i]);
  }
  // expensive
  getTreeNodeWithListIndex(e) {
    if (e.length === 0)
      return { node: this.root, listIndex: -1, revealed: !0, visible: !1 };
    const { parentNode: t, listIndex: i, revealed: n, visible: s } = this.getParentNodeWithListIndex(e), o = e[e.length - 1];
    if (o < 0 || o > t.children.length)
      throw new ao(this.user, "Invalid tree location");
    const a = t.children[o];
    return { node: a, listIndex: i, revealed: n, visible: s && a.visible };
  }
  getParentNodeWithListIndex(e, t = this.root, i = 0, n = !0, s = !0) {
    const [o, ...a] = e;
    if (o < 0 || o > t.children.length)
      throw new ao(this.user, "Invalid tree location");
    for (let l = 0; l < o; l++)
      i += t.children[l].renderNodeCount;
    return n = n && !t.collapsed, s = s && t.visible, a.length === 0 ? { parentNode: t, listIndex: i, revealed: n, visible: s } : this.getParentNodeWithListIndex(a, t.children[o], i + 1, n, s);
  }
  getNode(e = []) {
    return this.getTreeNode(e);
  }
  // TODO@joao perf!
  getNodeLocation(e) {
    const t = [];
    let i = e;
    for (; i.parent; )
      t.push(i.parent.children.indexOf(i)), i = i.parent;
    return t.reverse();
  }
  getParentNodeLocation(e) {
    if (e.length !== 0)
      return e.length === 1 ? [] : z5(e)[0];
  }
  getFirstElementChild(e) {
    const t = this.getTreeNode(e);
    if (t.children.length !== 0)
      return t.children[0].element;
  }
}
class Jne extends Lb {
  constructor(e) {
    super(e.elements.map((t) => t.element)), this.data = e;
  }
}
function Nk(r) {
  return r instanceof Lb ? new Jne(r) : r;
}
class ese {
  constructor(e, t) {
    this.modelProvider = e, this.dnd = t, this.autoExpandDisposable = P.None, this.disposables = new q();
  }
  getDragURI(e) {
    return this.dnd.getDragURI(e.element);
  }
  getDragLabel(e, t) {
    if (this.dnd.getDragLabel)
      return this.dnd.getDragLabel(e.map((i) => i.element), t);
  }
  onDragStart(e, t) {
    var i, n;
    (n = (i = this.dnd).onDragStart) === null || n === void 0 || n.call(i, Nk(e), t);
  }
  onDragOver(e, t, i, n, s, o = !0) {
    const a = this.dnd.onDragOver(Nk(e), t && t.element, i, n, s), l = this.autoExpandNode !== t;
    if (l && (this.autoExpandDisposable.dispose(), this.autoExpandNode = t), typeof t > "u")
      return a;
    if (l && typeof a != "boolean" && a.autoExpand && (this.autoExpandDisposable = Mc(() => {
      const g = this.modelProvider(), f = g.getNodeLocation(t);
      g.isCollapsed(f) && g.setCollapsed(f, !1), this.autoExpandNode = void 0;
    }, 500, this.disposables)), typeof a == "boolean" || !a.accept || typeof a.bubble > "u" || a.feedback) {
      if (!o) {
        const g = typeof a == "boolean" ? a : a.accept, f = typeof a == "boolean" ? void 0 : a.effect;
        return { accept: g, effect: f, feedback: [i] };
      }
      return a;
    }
    if (a.bubble === 1) {
      const g = this.modelProvider(), f = g.getNodeLocation(t), m = g.getParentNodeLocation(f), _ = g.getNode(m), v = m && g.getListIndex(m);
      return this.onDragOver(e, _, v, n, s, !1);
    }
    const d = this.modelProvider(), c = d.getNodeLocation(t), h = d.getListIndex(c), u = d.getListRenderCount(c);
    return { ...a, feedback: _s(h, h + u) };
  }
  drop(e, t, i, n, s) {
    this.autoExpandDisposable.dispose(), this.autoExpandNode = void 0, this.dnd.drop(Nk(e), t && t.element, i, n, s);
  }
  onDragEnd(e) {
    var t, i;
    (i = (t = this.dnd).onDragEnd) === null || i === void 0 || i.call(t, e);
  }
  dispose() {
    this.disposables.dispose(), this.dnd.dispose();
  }
}
function tse(r, e) {
  return e && {
    ...e,
    identityProvider: e.identityProvider && {
      getId(t) {
        return e.identityProvider.getId(t.element);
      }
    },
    dnd: e.dnd && new ese(r, e.dnd),
    multipleSelectionController: e.multipleSelectionController && {
      isSelectionSingleChangeEvent(t) {
        return e.multipleSelectionController.isSelectionSingleChangeEvent({ ...t, element: t.element });
      },
      isSelectionRangeChangeEvent(t) {
        return e.multipleSelectionController.isSelectionRangeChangeEvent({ ...t, element: t.element });
      }
    },
    accessibilityProvider: e.accessibilityProvider && {
      ...e.accessibilityProvider,
      getSetSize(t) {
        const i = r(), n = i.getNodeLocation(t), s = i.getParentNodeLocation(n);
        return i.getNode(s).visibleChildrenCount;
      },
      getPosInSet(t) {
        return t.visibleChildIndex + 1;
      },
      isChecked: e.accessibilityProvider && e.accessibilityProvider.isChecked ? (t) => e.accessibilityProvider.isChecked(t.element) : void 0,
      getRole: e.accessibilityProvider && e.accessibilityProvider.getRole ? (t) => e.accessibilityProvider.getRole(t.element) : () => "treeitem",
      getAriaLabel(t) {
        return e.accessibilityProvider.getAriaLabel(t.element);
      },
      getWidgetAriaLabel() {
        return e.accessibilityProvider.getWidgetAriaLabel();
      },
      getWidgetRole: e.accessibilityProvider && e.accessibilityProvider.getWidgetRole ? () => e.accessibilityProvider.getWidgetRole() : () => "tree",
      getAriaLevel: e.accessibilityProvider && e.accessibilityProvider.getAriaLevel ? (t) => e.accessibilityProvider.getAriaLevel(t.element) : (t) => t.depth,
      getActiveDescendantId: e.accessibilityProvider.getActiveDescendantId && ((t) => e.accessibilityProvider.getActiveDescendantId(t.element))
    },
    keyboardNavigationLabelProvider: e.keyboardNavigationLabelProvider && {
      ...e.keyboardNavigationLabelProvider,
      getKeyboardNavigationLabel(t) {
        return e.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(t.element);
      }
    }
  };
}
class SM {
  constructor(e) {
    this.delegate = e;
  }
  getHeight(e) {
    return this.delegate.getHeight(e.element);
  }
  getTemplateId(e) {
    return this.delegate.getTemplateId(e.element);
  }
  hasDynamicHeight(e) {
    return !!this.delegate.hasDynamicHeight && this.delegate.hasDynamicHeight(e.element);
  }
  setDynamicHeight(e, t) {
    var i, n;
    (n = (i = this.delegate).setDynamicHeight) === null || n === void 0 || n.call(i, e.element, t);
  }
}
var rp;
(function(r) {
  r.None = "none", r.OnHover = "onHover", r.Always = "always";
})(rp || (rp = {}));
class ise {
  get elements() {
    return this._elements;
  }
  constructor(e, t = []) {
    this._elements = t, this.disposables = new q(), this.onDidChange = ne.forEach(e, (i) => this._elements = i, this.disposables);
  }
  dispose() {
    this.disposables.dispose();
  }
}
class pv {
  constructor(e, t, i, n, s, o = {}) {
    var a;
    this.renderer = e, this.modelProvider = t, this.activeNodes = n, this.renderedIndentGuides = s, this.renderedElements = /* @__PURE__ */ new Map(), this.renderedNodes = /* @__PURE__ */ new Map(), this.indent = pv.DefaultIndent, this.hideTwistiesOfChildlessElements = !1, this.shouldRenderIndentGuides = !1, this.activeIndentNodes = /* @__PURE__ */ new Set(), this.indentGuidesDisposable = P.None, this.disposables = new q(), this.templateId = e.templateId, this.updateOptions(o), ne.map(i, (l) => l.node)(this.onDidChangeNodeTwistieState, this, this.disposables), (a = e.onDidChangeTwistieState) === null || a === void 0 || a.call(e, this.onDidChangeTwistieState, this, this.disposables);
  }
  updateOptions(e = {}) {
    if (typeof e.indent < "u") {
      const t = Yn(e.indent, 0, 40);
      if (t !== this.indent) {
        this.indent = t;
        for (const [i, n] of this.renderedNodes)
          this.renderTreeElement(i, n);
      }
    }
    if (typeof e.renderIndentGuides < "u") {
      const t = e.renderIndentGuides !== rp.None;
      if (t !== this.shouldRenderIndentGuides) {
        this.shouldRenderIndentGuides = t;
        for (const [i, n] of this.renderedNodes)
          this._renderIndentGuides(i, n);
        if (this.indentGuidesDisposable.dispose(), t) {
          const i = new q();
          this.activeNodes.onDidChange(this._onDidChangeActiveNodes, this, i), this.indentGuidesDisposable = i, this._onDidChangeActiveNodes(this.activeNodes.elements);
        }
      }
    }
    typeof e.hideTwistiesOfChildlessElements < "u" && (this.hideTwistiesOfChildlessElements = e.hideTwistiesOfChildlessElements);
  }
  renderTemplate(e) {
    const t = G(e, X(".monaco-tl-row")), i = G(t, X(".monaco-tl-indent")), n = G(t, X(".monaco-tl-twistie")), s = G(t, X(".monaco-tl-contents")), o = this.renderer.renderTemplate(s);
    return { container: e, indent: i, twistie: n, indentGuidesDisposable: P.None, templateData: o };
  }
  renderElement(e, t, i, n) {
    this.renderedNodes.set(e, i), this.renderedElements.set(e.element, e), this.renderTreeElement(e, i), this.renderer.renderElement(e, t, i.templateData, n);
  }
  disposeElement(e, t, i, n) {
    var s, o;
    i.indentGuidesDisposable.dispose(), (o = (s = this.renderer).disposeElement) === null || o === void 0 || o.call(s, e, t, i.templateData, n), typeof n == "number" && (this.renderedNodes.delete(e), this.renderedElements.delete(e.element));
  }
  disposeTemplate(e) {
    this.renderer.disposeTemplate(e.templateData);
  }
  onDidChangeTwistieState(e) {
    const t = this.renderedElements.get(e);
    t && this.onDidChangeNodeTwistieState(t);
  }
  onDidChangeNodeTwistieState(e) {
    const t = this.renderedNodes.get(e);
    t && (this._onDidChangeActiveNodes(this.activeNodes.elements), this.renderTreeElement(e, t));
  }
  renderTreeElement(e, t) {
    const i = pv.DefaultIndent + (e.depth - 1) * this.indent;
    t.twistie.style.paddingLeft = `${i}px`, t.indent.style.width = `${i + this.indent - 16}px`, e.collapsible ? t.container.setAttribute("aria-expanded", String(!e.collapsed)) : t.container.removeAttribute("aria-expanded"), t.twistie.classList.remove(...Le.asClassNameArray(me.treeItemExpanded));
    let n = !1;
    this.renderer.renderTwistie && (n = this.renderer.renderTwistie(e.element, t.twistie)), e.collapsible && (!this.hideTwistiesOfChildlessElements || e.visibleChildrenCount > 0) ? (n || t.twistie.classList.add(...Le.asClassNameArray(me.treeItemExpanded)), t.twistie.classList.add("collapsible"), t.twistie.classList.toggle("collapsed", e.collapsed)) : t.twistie.classList.remove("collapsible", "collapsed"), this._renderIndentGuides(e, t);
  }
  _renderIndentGuides(e, t) {
    if (pn(t.indent), t.indentGuidesDisposable.dispose(), !this.shouldRenderIndentGuides)
      return;
    const i = new q(), n = this.modelProvider();
    for (; ; ) {
      const s = n.getNodeLocation(e), o = n.getParentNodeLocation(s);
      if (!o)
        break;
      const a = n.getNode(o), l = X(".indent-guide", { style: `width: ${this.indent}px` });
      this.activeIndentNodes.has(a) && l.classList.add("active"), t.indent.childElementCount === 0 ? t.indent.appendChild(l) : t.indent.insertBefore(l, t.indent.firstElementChild), this.renderedIndentGuides.add(a, l), i.add(Se(() => this.renderedIndentGuides.delete(a, l))), e = a;
    }
    t.indentGuidesDisposable = i;
  }
  _onDidChangeActiveNodes(e) {
    if (!this.shouldRenderIndentGuides)
      return;
    const t = /* @__PURE__ */ new Set(), i = this.modelProvider();
    e.forEach((n) => {
      const s = i.getNodeLocation(n);
      try {
        const o = i.getParentNodeLocation(s);
        n.collapsible && n.children.length > 0 && !n.collapsed ? t.add(n) : o && t.add(i.getNode(o));
      } catch {
      }
    }), this.activeIndentNodes.forEach((n) => {
      t.has(n) || this.renderedIndentGuides.forEach(n, (s) => s.classList.remove("active"));
    }), t.forEach((n) => {
      this.activeIndentNodes.has(n) || this.renderedIndentGuides.forEach(n, (s) => s.classList.add("active"));
    }), this.activeIndentNodes = t;
  }
  dispose() {
    this.renderedNodes.clear(), this.renderedElements.clear(), this.indentGuidesDisposable.dispose(), zt(this.disposables);
  }
}
pv.DefaultIndent = 8;
class nse {
  get totalCount() {
    return this._totalCount;
  }
  get matchCount() {
    return this._matchCount;
  }
  constructor(e, t, i) {
    this.tree = e, this.keyboardNavigationLabelProvider = t, this._filter = i, this._totalCount = 0, this._matchCount = 0, this._pattern = "", this._lowercasePattern = "", this.disposables = new q(), e.onWillRefilter(this.reset, this, this.disposables);
  }
  filter(e, t) {
    let i = 1;
    if (this._filter) {
      const o = this._filter.filter(e, t);
      if (typeof o == "boolean" ? i = o ? 1 : 0 : wM(o) ? i = fv(o.visibility) : i = o, i === 0)
        return !1;
    }
    if (this._totalCount++, !this._pattern)
      return this._matchCount++, { data: qr.Default, visibility: i };
    const n = this.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(e), s = Array.isArray(n) ? n : [n];
    for (const o of s) {
      const a = o && o.toString();
      if (typeof a > "u")
        return { data: qr.Default, visibility: i };
      let l;
      if (this.tree.findMatchType === Iu.Contiguous) {
        const d = a.toLowerCase().indexOf(this._lowercasePattern);
        if (d > -1) {
          l = [Number.MAX_SAFE_INTEGER, 0];
          for (let c = this._lowercasePattern.length; c > 0; c--)
            l.push(d + c - 1);
        }
      } else
        l = Du(this._pattern, this._lowercasePattern, 0, a, a.toLowerCase(), 0, { firstMatchCanBeWeak: !0, boostFullMatch: !0 });
      if (l)
        return this._matchCount++, s.length === 1 ? { data: l, visibility: i } : { data: { label: a, score: l }, visibility: i };
    }
    return this.tree.findMode === Jl.Filter ? typeof this.tree.options.defaultFindVisibility == "number" ? this.tree.options.defaultFindVisibility : this.tree.options.defaultFindVisibility ? this.tree.options.defaultFindVisibility(e) : 2 : { data: qr.Default, visibility: i };
  }
  reset() {
    this._totalCount = 0, this._matchCount = 0;
  }
  dispose() {
    zt(this.disposables);
  }
}
var Jl;
(function(r) {
  r[r.Highlight = 0] = "Highlight", r[r.Filter = 1] = "Filter";
})(Jl || (Jl = {}));
var Iu;
(function(r) {
  r[r.Fuzzy = 0] = "Fuzzy", r[r.Contiguous = 1] = "Contiguous";
})(Iu || (Iu = {}));
let sse = class {
  get pattern() {
    return this._pattern;
  }
  get mode() {
    return this._mode;
  }
  set mode(e) {
    e !== this._mode && (this._mode = e, this.widget && (this.widget.mode = this._mode), this.tree.refilter(), this.render(), this._onDidChangeMode.fire(e));
  }
  get matchType() {
    return this._matchType;
  }
  set matchType(e) {
    e !== this._matchType && (this._matchType = e, this.widget && (this.widget.matchType = this._matchType), this.tree.refilter(), this.render(), this._onDidChangeMatchType.fire(e));
  }
  constructor(e, t, i, n, s, o = {}) {
    var a, l;
    this.tree = e, this.view = i, this.filter = n, this.contextViewProvider = s, this.options = o, this._pattern = "", this.width = 0, this._onDidChangeMode = new R(), this.onDidChangeMode = this._onDidChangeMode.event, this._onDidChangeMatchType = new R(), this.onDidChangeMatchType = this._onDidChangeMatchType.event, this._onDidChangePattern = new R(), this._onDidChangeOpenState = new R(), this.onDidChangeOpenState = this._onDidChangeOpenState.event, this.enabledDisposables = new q(), this.disposables = new q(), this._mode = (a = e.options.defaultFindMode) !== null && a !== void 0 ? a : Jl.Highlight, this._matchType = (l = e.options.defaultFindMatchType) !== null && l !== void 0 ? l : Iu.Fuzzy, t.onDidSplice(this.onDidSpliceModel, this, this.disposables);
  }
  updateOptions(e = {}) {
    e.defaultFindMode !== void 0 && (this.mode = e.defaultFindMode), e.defaultFindMatchType !== void 0 && (this.matchType = e.defaultFindMatchType);
  }
  onDidSpliceModel() {
    !this.widget || this.pattern.length === 0 || (this.tree.refilter(), this.render());
  }
  render() {
    var e, t, i, n;
    const s = this.filter.totalCount > 0 && this.filter.matchCount === 0;
    this.pattern && s ? !((e = this.tree.options.showNotFoundMessage) !== null && e !== void 0) || e ? (t = this.widget) === null || t === void 0 || t.showMessage({ type: 2, content: p("not found", "No elements found.") }) : (i = this.widget) === null || i === void 0 || i.showMessage({
      type: 2
      /* MessageType.WARNING */
    }) : (n = this.widget) === null || n === void 0 || n.clearMessage();
  }
  shouldAllowFocus(e) {
    return !this.widget || !this.pattern || this.filter.totalCount > 0 && this.filter.matchCount <= 1 ? !0 : !qr.isDefault(e.filterData);
  }
  layout(e) {
    var t;
    this.width = e, (t = this.widget) === null || t === void 0 || t.layout(e);
  }
  dispose() {
    this._history = void 0, this._onDidChangePattern.dispose(), this.enabledDisposables.dispose(), this.disposables.dispose();
  }
};
function ose(r, e) {
  return r.position === e.position && jz(r, e);
}
function jz(r, e) {
  return r.node.element === e.node.element && r.startIndex === e.startIndex && r.height === e.height && r.endIndex === e.endIndex;
}
class rse {
  constructor(e = []) {
    this.stickyNodes = e;
  }
  get count() {
    return this.stickyNodes.length;
  }
  equal(e) {
    return ci(this.stickyNodes, e.stickyNodes, ose);
  }
  lastNodePartiallyVisible() {
    if (this.count === 0)
      return !1;
    const e = this.stickyNodes[this.count - 1];
    if (this.count === 1)
      return e.position !== 0;
    const t = this.stickyNodes[this.count - 2];
    return t.position + t.height !== e.position;
  }
  animationStateChanged(e) {
    if (!ci(this.stickyNodes, e.stickyNodes, jz) || this.count === 0)
      return !1;
    const t = this.stickyNodes[this.count - 1], i = e.stickyNodes[e.count - 1];
    return t.position !== i.position;
  }
}
class ase {
  constrainStickyScrollNodes(e, t, i) {
    for (let n = 0; n < e.length; n++) {
      const s = e[n];
      if (s.position + s.height > i || n >= t)
        return e.slice(0, n);
    }
    return e;
  }
}
let gF = class extends P {
  constructor(e, t, i, n, s, o = {}) {
    var a;
    super(), this.tree = e, this.model = t, this.view = i, this.treeDelegate = s, this.maxWidgetViewRatio = 0.4;
    const l = this.validateStickySettings(o);
    this.stickyScrollMaxItemCount = l.stickyScrollMaxItemCount, this.stickyScrollDelegate = (a = o.stickyScrollDelegate) !== null && a !== void 0 ? a : new ase(), this._widget = this._register(new lse(i.getScrollableElement(), i, e, n, s, o.accessibilityProvider)), this.onDidChangeHasFocus = this._widget.onDidChangeHasFocus, this.onContextMenu = this._widget.onContextMenu, this._register(i.onDidScroll(() => this.update())), this._register(i.onDidChangeContentHeight(() => this.update())), this._register(e.onDidChangeCollapseState(() => this.update())), this.update();
  }
  get height() {
    return this._widget.height;
  }
  getNodeAtHeight(e) {
    let t;
    if (e === 0 ? t = this.view.firstVisibleIndex : t = this.view.indexAt(e + this.view.scrollTop), !(t < 0 || t >= this.view.length))
      return this.view.element(t);
  }
  update() {
    const e = this.getNodeAtHeight(0);
    if (!e || this.tree.scrollTop === 0) {
      this._widget.setState(void 0);
      return;
    }
    const t = this.findStickyState(e);
    this._widget.setState(t);
  }
  findStickyState(e) {
    const t = [];
    let i = e, n = 0, s = this.getNextStickyNode(i, void 0, n);
    for (; s && (t.push(s), n += s.height, !(t.length <= this.stickyScrollMaxItemCount && (i = this.getNextVisibleNode(s), !i))); )
      s = this.getNextStickyNode(i, s.node, n);
    const o = this.constrainStickyNodes(t);
    return o.length ? new rse(o) : void 0;
  }
  getNextVisibleNode(e) {
    return this.getNodeAtHeight(e.position + e.height);
  }
  getNextStickyNode(e, t, i) {
    const n = this.getAncestorUnderPrevious(e, t);
    if (n && !(n === e && (!this.nodeIsUncollapsedParent(e) || this.nodeTopAlignsWithStickyNodesBottom(e, i))))
      return this.createStickyScrollNode(n, i);
  }
  nodeTopAlignsWithStickyNodesBottom(e, t) {
    const i = this.getNodeIndex(e), n = this.view.getElementTop(i), s = t;
    return this.view.scrollTop === n - s;
  }
  createStickyScrollNode(e, t) {
    const i = this.treeDelegate.getHeight(e), { startIndex: n, endIndex: s } = this.getNodeRange(e), o = this.calculateStickyNodePosition(s, t, i);
    return { node: e, position: o, height: i, startIndex: n, endIndex: s };
  }
  getAncestorUnderPrevious(e, t = void 0) {
    let i = e, n = this.getParentNode(i);
    for (; n; ) {
      if (n === t)
        return i;
      i = n, n = this.getParentNode(i);
    }
    if (t === void 0)
      return i;
  }
  calculateStickyNodePosition(e, t, i) {
    let n = this.view.getRelativeTop(e);
    if (n === null && this.view.firstVisibleIndex === e && e + 1 < this.view.length) {
      const d = this.treeDelegate.getHeight(this.view.element(e)), c = this.view.getRelativeTop(e + 1);
      n = c ? c - d / this.view.renderHeight : null;
    }
    if (n === null)
      return t;
    const s = this.view.element(e), o = this.treeDelegate.getHeight(s), l = n * this.view.renderHeight + o;
    return t + i > l && t <= l ? l - i : t;
  }
  constrainStickyNodes(e) {
    if (e.length === 0)
      return [];
    const t = this.view.renderHeight * this.maxWidgetViewRatio, i = e[e.length - 1];
    if (e.length <= this.stickyScrollMaxItemCount && i.position + i.height <= t)
      return e;
    const n = this.stickyScrollDelegate.constrainStickyScrollNodes(e, this.stickyScrollMaxItemCount, t);
    if (!n.length)
      return [];
    const s = n[n.length - 1];
    if (n.length > this.stickyScrollMaxItemCount || s.position + s.height > t)
      throw new Error("stickyScrollDelegate violates constraints");
    return n;
  }
  getParentNode(e) {
    const t = this.model.getNodeLocation(e), i = this.model.getParentNodeLocation(t);
    return i ? this.model.getNode(i) : void 0;
  }
  nodeIsUncollapsedParent(e) {
    const t = this.model.getNodeLocation(e);
    return this.model.getListRenderCount(t) > 1;
  }
  getNodeIndex(e) {
    const t = this.model.getNodeLocation(e);
    return this.model.getListIndex(t);
  }
  getNodeRange(e) {
    const t = this.model.getNodeLocation(e), i = this.model.getListIndex(t);
    if (i < 0)
      throw new Error("Node not found in tree");
    const n = this.model.getListRenderCount(t), s = i + n - 1;
    return { startIndex: i, endIndex: s };
  }
  nodePositionTopBelowWidget(e) {
    const t = [];
    let i = this.getParentNode(e);
    for (; i; )
      t.push(i), i = this.getParentNode(i);
    let n = 0;
    for (let s = 0; s < t.length && s < this.stickyScrollMaxItemCount; s++)
      n += this.treeDelegate.getHeight(t[s]);
    return n;
  }
  domFocus() {
    this._widget.domFocus();
  }
  // Whether sticky scroll was the last focused part in the tree or not
  focusedLast() {
    return this._widget.focusedLast();
  }
  updateOptions(e = {}) {
    if (!e.stickyScrollMaxItemCount)
      return;
    const t = this.validateStickySettings(e);
    this.stickyScrollMaxItemCount !== t.stickyScrollMaxItemCount && (this.stickyScrollMaxItemCount = t.stickyScrollMaxItemCount, this.update());
  }
  validateStickySettings(e) {
    let t = 7;
    return typeof e.stickyScrollMaxItemCount == "number" && (t = Math.max(e.stickyScrollMaxItemCount, 1)), { stickyScrollMaxItemCount: t };
  }
}, lse = class {
  constructor(e, t, i, n, s, o) {
    this.view = t, this.tree = i, this.treeRenderers = n, this.treeDelegate = s, this.accessibilityProvider = o, this._previousElements = [], this._previousStateDisposables = new q(), this._rootDomNode = X(".monaco-tree-sticky-container.empty"), e.appendChild(this._rootDomNode);
    const a = X(".monaco-tree-sticky-container-shadow");
    this._rootDomNode.appendChild(a), this.stickyScrollFocus = new dse(this._rootDomNode, t), this.onDidChangeHasFocus = this.stickyScrollFocus.onDidChangeHasFocus, this.onContextMenu = this.stickyScrollFocus.onContextMenu;
  }
  get height() {
    if (!this._previousState)
      return 0;
    const e = this._previousState.stickyNodes[this._previousState.count - 1];
    return e.position + e.height;
  }
  setState(e) {
    const t = !!this._previousState && this._previousState.count > 0, i = !!e && e.count > 0;
    if (!t && !i || t && i && this._previousState.equal(e))
      return;
    if (t !== i && this.setVisible(i), !i) {
      this._previousState = void 0, this._previousElements = [], this._previousStateDisposables.clear();
      return;
    }
    const n = e.stickyNodes[e.count - 1];
    if (this._previousState && e.animationStateChanged(this._previousState))
      this._previousElements[this._previousState.count - 1].style.top = `${n.position}px`;
    else {
      this._previousStateDisposables.clear();
      const s = Array(e.count);
      for (let o = e.count - 1; o >= 0; o--) {
        const a = e.stickyNodes[o], { element: l, disposable: d } = this.createElement(a, o, e.count);
        s[o] = l, this._rootDomNode.appendChild(l), this._previousStateDisposables.add(d);
      }
      this.stickyScrollFocus.updateElements(s, e), this._previousElements = s;
    }
    this._previousState = e, this._rootDomNode.style.height = `${n.position + n.height}px`;
  }
  createElement(e, t, i) {
    const n = e.startIndex, s = document.createElement("div");
    s.style.top = `${e.position}px`, this.tree.options.setRowHeight !== !1 && (s.style.height = `${e.height}px`), this.tree.options.setRowLineHeight !== !1 && (s.style.lineHeight = `${e.height}px`), s.classList.add("monaco-tree-sticky-row"), s.classList.add("monaco-list-row"), s.setAttribute("data-index", `${n}`), s.setAttribute("data-parity", n % 2 === 0 ? "even" : "odd"), s.setAttribute("id", this.view.getElementID(n));
    const o = this.setAccessibilityAttributes(s, e.node.element, t, i), a = this.treeDelegate.getTemplateId(e.node), l = this.treeRenderers.find((u) => u.templateId === a);
    if (!l)
      throw new Error(`No renderer found for template id ${a}`);
    let d = e.node;
    d === this.tree.getNode(this.tree.getNodeLocation(e.node)) && (d = new Proxy(e.node, {}));
    const c = l.renderTemplate(s);
    l.renderElement(d, e.startIndex, c, e.height);
    const h = Se(() => {
      o.dispose(), l.disposeElement(d, e.startIndex, c, e.height), l.disposeTemplate(c), s.remove();
    });
    return { element: s, disposable: h };
  }
  setAccessibilityAttributes(e, t, i, n) {
    var s;
    if (!this.accessibilityProvider)
      return P.None;
    this.accessibilityProvider.getSetSize && e.setAttribute("aria-setsize", String(this.accessibilityProvider.getSetSize(t, i, n))), this.accessibilityProvider.getPosInSet && e.setAttribute("aria-posinset", String(this.accessibilityProvider.getPosInSet(t, i))), this.accessibilityProvider.getRole && e.setAttribute("role", (s = this.accessibilityProvider.getRole(t)) !== null && s !== void 0 ? s : "treeitem");
    const o = this.accessibilityProvider.getAriaLabel(t), a = o && typeof o != "string" ? o : Hr(o), l = qe((c) => {
      const h = c.readObservable(a);
      h ? e.setAttribute("aria-label", h) : e.removeAttribute("aria-label");
    });
    typeof o == "string" || o && e.setAttribute("aria-label", o.get());
    const d = this.accessibilityProvider.getAriaLevel && this.accessibilityProvider.getAriaLevel(t);
    return typeof d == "number" && e.setAttribute("aria-level", `${d}`), e.setAttribute("aria-selected", String(!1)), l;
  }
  setVisible(e) {
    this._rootDomNode.classList.toggle("empty", !e), e || this.stickyScrollFocus.updateElements([], void 0);
  }
  domFocus() {
    this.stickyScrollFocus.domFocus();
  }
  focusedLast() {
    return this.stickyScrollFocus.focusedLast();
  }
  dispose() {
    this.stickyScrollFocus.dispose(), this._previousStateDisposables.dispose(), this._rootDomNode.remove();
  }
};
class dse extends P {
  get domHasFocus() {
    return this._domHasFocus;
  }
  set domHasFocus(e) {
    e !== this._domHasFocus && (this._onDidChangeHasFocus.fire(e), this._domHasFocus = e);
  }
  constructor(e, t) {
    super(), this.container = e, this.view = t, this.focusedIndex = -1, this.elements = [], this._onDidChangeHasFocus = new R(), this.onDidChangeHasFocus = this._onDidChangeHasFocus.event, this._onContextMenu = new R(), this.onContextMenu = this._onContextMenu.event, this._domHasFocus = !1, this.container.addEventListener("focus", () => this.onFocus()), this.container.addEventListener("blur", () => this.onBlur()), this._register(this.view.onDidFocus(() => this.toggleStickyScrollFocused(!1))), this._register(this.view.onKeyDown((i) => this.onKeyDown(i))), this._register(this.view.onMouseDown((i) => this.onMouseDown(i))), this._register(this.view.onContextMenu((i) => this.handleContextMenu(i)));
  }
  handleContextMenu(e) {
    const t = e.browserEvent.target;
    if (!hv(t) && !v_(t)) {
      this.focusedLast() && this.view.domFocus();
      return;
    }
    if (!$d(e.browserEvent)) {
      if (!this.state)
        throw new Error("Context menu should not be triggered when state is undefined");
      const o = this.state.stickyNodes.findIndex((a) => {
        var l;
        return a.node.element === ((l = e.element) === null || l === void 0 ? void 0 : l.element);
      });
      if (o === -1)
        throw new Error("Context menu should not be triggered when element is not in sticky scroll widget");
      this.container.focus(), this.setFocus(o);
      return;
    }
    if (!this.state || this.focusedIndex < 0)
      throw new Error("Context menu key should not be triggered when focus is not in sticky scroll widget");
    const n = this.state.stickyNodes[this.focusedIndex].node.element, s = this.elements[this.focusedIndex];
    this._onContextMenu.fire({ element: n, anchor: s, browserEvent: e.browserEvent, isStickyScroll: !0 });
  }
  onKeyDown(e) {
    if (this.domHasFocus && this.state) {
      if (e.key === "ArrowUp")
        this.setFocusedElement(Math.max(0, this.focusedIndex - 1)), e.preventDefault(), e.stopPropagation();
      else if (e.key === "ArrowDown" || e.key === "ArrowRight") {
        if (this.focusedIndex >= this.state.count - 1) {
          const t = this.state.stickyNodes[this.state.count - 1].startIndex + 1;
          this.view.domFocus(), this.view.setFocus([t]), this.scrollNodeUnderWidget(t, this.state);
        } else
          this.setFocusedElement(this.focusedIndex + 1);
        e.preventDefault(), e.stopPropagation();
      }
    }
  }
  onMouseDown(e) {
    const t = e.browserEvent.target;
    !hv(t) && !v_(t) || (e.browserEvent.preventDefault(), e.browserEvent.stopPropagation());
  }
  updateElements(e, t) {
    if (t && t.count === 0)
      throw new Error("Sticky scroll state must be undefined when there are no sticky nodes");
    if (t && t.count !== e.length)
      throw new Error("Sticky scroll focus received illigel state");
    const i = this.focusedIndex;
    if (this.removeFocus(), this.elements = e, this.state = t, t) {
      const n = Yn(i, 0, t.count - 1);
      this.setFocus(n);
    } else
      this.domHasFocus && this.view.domFocus();
    this.container.tabIndex = t ? 0 : -1;
  }
  setFocusedElement(e) {
    const t = this.state;
    if (!t)
      throw new Error("Cannot set focus when state is undefined");
    if (this.setFocus(e), !(e < t.count - 1) && t.lastNodePartiallyVisible()) {
      const i = t.stickyNodes[e];
      this.scrollNodeUnderWidget(i.endIndex + 1, t);
    }
  }
  scrollNodeUnderWidget(e, t) {
    const i = t.stickyNodes[t.count - 1], n = t.count > 1 ? t.stickyNodes[t.count - 2] : void 0, s = this.view.getElementTop(e), o = n ? n.position + n.height + i.height : i.height;
    this.view.scrollTop = s - o;
  }
  domFocus() {
    if (!this.state)
      throw new Error("Cannot focus when state is undefined");
    this.container.focus();
  }
  focusedLast() {
    return this.state ? this.view.getHTMLElement().classList.contains("sticky-scroll-focused") : !1;
  }
  removeFocus() {
    this.focusedIndex !== -1 && (this.toggleElementFocus(this.elements[this.focusedIndex], !1), this.focusedIndex = -1);
  }
  setFocus(e) {
    if (0 > e)
      throw new Error("addFocus() can not remove focus");
    if (!this.state && e >= 0)
      throw new Error("Cannot set focus index when state is undefined");
    if (this.state && e >= this.state.count)
      throw new Error("Cannot set focus index to an index that does not exist");
    const t = this.focusedIndex;
    t >= 0 && this.toggleElementFocus(this.elements[t], !1), e >= 0 && this.toggleElementFocus(this.elements[e], !0), this.focusedIndex = e;
  }
  toggleElementFocus(e, t) {
    this.toggleElementActiveFocus(e, t && this.domHasFocus), this.toggleElementPassiveFocus(e, t);
  }
  toggleCurrentElementActiveFocus(e) {
    this.focusedIndex !== -1 && this.toggleElementActiveFocus(this.elements[this.focusedIndex], e);
  }
  toggleElementActiveFocus(e, t) {
    e.classList.toggle("focused", t);
  }
  toggleElementPassiveFocus(e, t) {
    e.classList.toggle("passive-focused", t);
  }
  toggleStickyScrollFocused(e) {
    this.view.getHTMLElement().classList.toggle("sticky-scroll-focused", e);
  }
  onFocus() {
    if (!this.state || this.elements.length === 0)
      throw new Error("Cannot focus when state is undefined or elements are empty");
    this.domHasFocus = !0, this.toggleStickyScrollFocused(!0), this.toggleCurrentElementActiveFocus(!0), this.focusedIndex === -1 && this.setFocus(0);
  }
  onBlur() {
    this.domHasFocus = !1, this.toggleCurrentElementActiveFocus(!1);
  }
  dispose() {
    this.toggleStickyScrollFocused(!1), this._onDidChangeHasFocus.fire(!1), super.dispose();
  }
}
function VC(r) {
  let e = Jh.Unknown;
  return TD(r.browserEvent.target, "monaco-tl-twistie", "monaco-tl-row") ? e = Jh.Twistie : TD(r.browserEvent.target, "monaco-tl-contents", "monaco-tl-row") ? e = Jh.Element : TD(r.browserEvent.target, "monaco-tree-type-filter", "monaco-list") && (e = Jh.Filter), {
    browserEvent: r.browserEvent,
    element: r.element ? r.element.element : null,
    target: e
  };
}
function cse(r) {
  const e = hv(r.browserEvent.target);
  return {
    element: r.element ? r.element.element : null,
    browserEvent: r.browserEvent,
    anchor: r.anchor,
    isStickyScroll: e
  };
}
function zw(r, e) {
  e(r), r.children.forEach((t) => zw(t, e));
}
class Mk {
  get nodeSet() {
    return this._nodeSet || (this._nodeSet = this.createNodeSet()), this._nodeSet;
  }
  constructor(e, t) {
    this.getFirstViewElementWithTrait = e, this.identityProvider = t, this.nodes = [], this._onDidChange = new R(), this.onDidChange = this._onDidChange.event;
  }
  set(e, t) {
    !(t != null && t.__forceEvent) && ci(this.nodes, e) || this._set(e, !1, t);
  }
  _set(e, t, i) {
    if (this.nodes = [...e], this.elements = void 0, this._nodeSet = void 0, !t) {
      const n = this;
      this._onDidChange.fire({ get elements() {
        return n.get();
      }, browserEvent: i });
    }
  }
  get() {
    return this.elements || (this.elements = this.nodes.map((e) => e.element)), [...this.elements];
  }
  getNodes() {
    return this.nodes;
  }
  has(e) {
    return this.nodeSet.has(e);
  }
  onDidModelSplice({ insertedNodes: e, deletedNodes: t }) {
    if (!this.identityProvider) {
      const l = this.createNodeSet(), d = (c) => l.delete(c);
      t.forEach((c) => zw(c, d)), this.set([...l.values()]);
      return;
    }
    const i = /* @__PURE__ */ new Set(), n = (l) => i.add(this.identityProvider.getId(l.element).toString());
    t.forEach((l) => zw(l, n));
    const s = /* @__PURE__ */ new Map(), o = (l) => s.set(this.identityProvider.getId(l.element).toString(), l);
    e.forEach((l) => zw(l, o));
    const a = [];
    for (const l of this.nodes) {
      const d = this.identityProvider.getId(l.element).toString();
      if (!i.has(d))
        a.push(l);
      else {
        const h = s.get(d);
        h && h.visible && a.push(h);
      }
    }
    if (this.nodes.length > 0 && a.length === 0) {
      const l = this.getFirstViewElementWithTrait();
      l && a.push(l);
    }
    this._set(a, !0);
  }
  createNodeSet() {
    const e = /* @__PURE__ */ new Set();
    for (const t of this.nodes)
      e.add(t);
    return e;
  }
}
class hse extends Iz {
  constructor(e, t, i) {
    super(e), this.tree = t, this.stickyScrollProvider = i;
  }
  onViewPointer(e) {
    if (Lz(e.browserEvent.target) || bc(e.browserEvent.target) || Bm(e.browserEvent.target) || e.browserEvent.isHandledByList)
      return;
    const t = e.element;
    if (!t)
      return super.onViewPointer(e);
    if (this.isSelectionRangeChangeEvent(e) || this.isSelectionSingleChangeEvent(e))
      return super.onViewPointer(e);
    const i = e.browserEvent.target, n = i.classList.contains("monaco-tl-twistie") || i.classList.contains("monaco-icon-label") && i.classList.contains("folder-icon") && e.browserEvent.offsetX < 16, s = v_(e.browserEvent.target);
    let o = !1;
    if (s ? o = !0 : typeof this.tree.expandOnlyOnTwistieClick == "function" ? o = this.tree.expandOnlyOnTwistieClick(t.element) : o = !!this.tree.expandOnlyOnTwistieClick, s)
      this.handleStickyScrollMouseEvent(e, t);
    else {
      if (o && !n && e.browserEvent.detail !== 2)
        return super.onViewPointer(e);
      if (!this.tree.expandOnDoubleClick && e.browserEvent.detail === 2)
        return super.onViewPointer(e);
    }
    if (t.collapsible && (!s || n)) {
      const a = this.tree.getNodeLocation(t), l = e.browserEvent.altKey;
      if (this.tree.setFocus([a]), this.tree.toggleCollapsed(a, l), n) {
        e.browserEvent.isHandledByList = !0;
        return;
      }
    }
    s || super.onViewPointer(e);
  }
  handleStickyScrollMouseEvent(e, t) {
    if (Lie(e.browserEvent.target) || Die(e.browserEvent.target))
      return;
    const i = this.stickyScrollProvider();
    if (!i)
      throw new Error("Sticky scroll controller not found");
    const n = this.list.indexOf(t), s = this.list.getElementTop(n), o = i.nodePositionTopBelowWidget(t);
    this.tree.scrollTop = s - o, this.list.domFocus(), this.list.setFocus([n]), this.list.setSelection([n]);
  }
  onDoubleClick(e) {
    e.browserEvent.target.classList.contains("monaco-tl-twistie") || !this.tree.expandOnDoubleClick || e.browserEvent.isHandledByList || super.onDoubleClick(e);
  }
  // to make sure dom focus is not stolen (for example with context menu)
  onMouseDown(e) {
    const t = e.browserEvent.target;
    if (!hv(t) && !v_(t)) {
      super.onMouseDown(e);
      return;
    }
  }
  onContextMenu(e) {
    const t = e.browserEvent.target;
    if (!hv(t) && !v_(t)) {
      super.onContextMenu(e);
      return;
    }
  }
}
class use extends Co {
  constructor(e, t, i, n, s, o, a, l) {
    super(e, t, i, n, l), this.focusTrait = s, this.selectionTrait = o, this.anchorTrait = a;
  }
  createMouseController(e) {
    return new hse(this, e.tree, e.stickyScrollProvider);
  }
  splice(e, t, i = []) {
    if (super.splice(e, t, i), i.length === 0)
      return;
    const n = [], s = [];
    let o;
    i.forEach((a, l) => {
      this.focusTrait.has(a) && n.push(e + l), this.selectionTrait.has(a) && s.push(e + l), this.anchorTrait.has(a) && (o = e + l);
    }), n.length > 0 && super.setFocus(rd([...super.getFocus(), ...n])), s.length > 0 && super.setSelection(rd([...super.getSelection(), ...s])), typeof o == "number" && super.setAnchor(o);
  }
  setFocus(e, t, i = !1) {
    super.setFocus(e, t), i || this.focusTrait.set(e.map((n) => this.element(n)), t);
  }
  setSelection(e, t, i = !1) {
    super.setSelection(e, t), i || this.selectionTrait.set(e.map((n) => this.element(n)), t);
  }
  setAnchor(e, t = !1) {
    super.setAnchor(e), t || (typeof e > "u" ? this.anchorTrait.set([]) : this.anchorTrait.set([this.element(e)]));
  }
}
class qz {
  get onDidScroll() {
    return this.view.onDidScroll;
  }
  get onDidChangeFocus() {
    return this.eventBufferer.wrapEvent(this.focus.onDidChange);
  }
  get onDidChangeSelection() {
    return this.eventBufferer.wrapEvent(this.selection.onDidChange);
  }
  get onMouseDblClick() {
    return ne.filter(ne.map(this.view.onMouseDblClick, VC), (e) => e.target !== Jh.Filter);
  }
  get onMouseOver() {
    return ne.map(this.view.onMouseOver, VC);
  }
  get onMouseOut() {
    return ne.map(this.view.onMouseOut, VC);
  }
  get onContextMenu() {
    var e, t;
    return ne.any(ne.filter(ne.map(this.view.onContextMenu, cse), (i) => !i.isStickyScroll), (t = (e = this.stickyScrollController) === null || e === void 0 ? void 0 : e.onContextMenu) !== null && t !== void 0 ? t : ne.None);
  }
  get onPointer() {
    return ne.map(this.view.onPointer, VC);
  }
  get onKeyDown() {
    return this.view.onKeyDown;
  }
  get onDidFocus() {
    return this.view.onDidFocus;
  }
  get onDidChangeModel() {
    return ne.signal(this.model.onDidSplice);
  }
  get onDidChangeCollapseState() {
    return this.model.onDidChangeCollapseState;
  }
  get findMode() {
    var e, t;
    return (t = (e = this.findController) === null || e === void 0 ? void 0 : e.mode) !== null && t !== void 0 ? t : Jl.Highlight;
  }
  set findMode(e) {
    this.findController && (this.findController.mode = e);
  }
  get findMatchType() {
    var e, t;
    return (t = (e = this.findController) === null || e === void 0 ? void 0 : e.matchType) !== null && t !== void 0 ? t : Iu.Fuzzy;
  }
  set findMatchType(e) {
    this.findController && (this.findController.matchType = e);
  }
  get expandOnDoubleClick() {
    return typeof this._options.expandOnDoubleClick > "u" ? !0 : this._options.expandOnDoubleClick;
  }
  get expandOnlyOnTwistieClick() {
    return typeof this._options.expandOnlyOnTwistieClick > "u" ? !0 : this._options.expandOnlyOnTwistieClick;
  }
  get onDidDispose() {
    return this.view.onDidDispose;
  }
  constructor(e, t, i, n, s = {}) {
    var o;
    this._user = e, this._options = s, this.eventBufferer = new n0(), this.onDidChangeFindOpenState = ne.None, this.onDidChangeStickyScrollFocused = ne.None, this.disposables = new q(), this._onWillRefilter = new R(), this.onWillRefilter = this._onWillRefilter.event, this._onDidUpdateOptions = new R(), this.treeDelegate = new SM(i);
    const a = new rA(), l = new rA(), d = this.disposables.add(new ise(l.event)), c = new cH();
    this.renderers = n.map((m) => new pv(m, () => this.model, a.event, d, c, s));
    for (const m of this.renderers)
      this.disposables.add(m);
    let h;
    s.keyboardNavigationLabelProvider && (h = new nse(this, s.keyboardNavigationLabelProvider, s.filter), s = { ...s, filter: h }, this.disposables.add(h)), this.focus = new Mk(() => this.view.getFocusedElements()[0], s.identityProvider), this.selection = new Mk(() => this.view.getSelectedElements()[0], s.identityProvider), this.anchor = new Mk(() => this.view.getAnchorElement(), s.identityProvider), this.view = new use(e, t, this.treeDelegate, this.renderers, this.focus, this.selection, this.anchor, { ...tse(() => this.model, s), tree: this, stickyScrollProvider: () => this.stickyScrollController }), this.model = this.createModel(e, this.view, s), a.input = this.model.onDidChangeCollapseState;
    const u = ne.forEach(this.model.onDidSplice, (m) => {
      this.eventBufferer.bufferEvents(() => {
        this.focus.onDidModelSplice(m), this.selection.onDidModelSplice(m);
      });
    }, this.disposables);
    u(() => null, null, this.disposables);
    const g = this.disposables.add(new R()), f = this.disposables.add(new pr(0));
    if (this.disposables.add(ne.any(u, this.focus.onDidChange, this.selection.onDidChange)(() => {
      f.trigger(() => {
        const m = /* @__PURE__ */ new Set();
        for (const _ of this.focus.getNodes())
          m.add(_);
        for (const _ of this.selection.getNodes())
          m.add(_);
        g.fire([...m.values()]);
      });
    })), l.input = g.event, s.keyboardSupport !== !1) {
      const m = ne.chain(this.view.onKeyDown, (_) => _.filter((v) => !bc(v.target)).map((v) => new Mt(v)));
      ne.chain(m, (_) => _.filter(
        (v) => v.keyCode === 15
        /* KeyCode.LeftArrow */
      ))(this.onLeftArrow, this, this.disposables), ne.chain(m, (_) => _.filter(
        (v) => v.keyCode === 17
        /* KeyCode.RightArrow */
      ))(this.onRightArrow, this, this.disposables), ne.chain(m, (_) => _.filter(
        (v) => v.keyCode === 10
        /* KeyCode.Space */
      ))(this.onSpace, this, this.disposables);
    }
    if ((!((o = s.findWidgetEnabled) !== null && o !== void 0) || o) && s.keyboardNavigationLabelProvider && s.contextViewProvider) {
      const m = this.options.findWidgetStyles ? { styles: this.options.findWidgetStyles } : void 0;
      this.findController = new sse(this, this.model, this.view, h, s.contextViewProvider, m), this.focusNavigationFilter = (_) => this.findController.shouldAllowFocus(_), this.onDidChangeFindOpenState = this.findController.onDidChangeOpenState, this.disposables.add(this.findController), this.onDidChangeFindMode = this.findController.onDidChangeMode, this.onDidChangeFindMatchType = this.findController.onDidChangeMatchType;
    } else
      this.onDidChangeFindMode = ne.None, this.onDidChangeFindMatchType = ne.None;
    s.enableStickyScroll && (this.stickyScrollController = new gF(this, this.model, this.view, this.renderers, this.treeDelegate, s), this.onDidChangeStickyScrollFocused = this.stickyScrollController.onDidChangeHasFocus), this.styleElement = fo(this.view.getHTMLElement()), this.getHTMLElement().classList.toggle("always", this._options.renderIndentGuides === rp.Always);
  }
  updateOptions(e = {}) {
    var t;
    this._options = { ...this._options, ...e };
    for (const i of this.renderers)
      i.updateOptions(e);
    this.view.updateOptions(this._options), (t = this.findController) === null || t === void 0 || t.updateOptions(e), this.updateStickyScroll(e), this._onDidUpdateOptions.fire(this._options), this.getHTMLElement().classList.toggle("always", this._options.renderIndentGuides === rp.Always);
  }
  get options() {
    return this._options;
  }
  updateStickyScroll(e) {
    var t;
    !this.stickyScrollController && this._options.enableStickyScroll ? (this.stickyScrollController = new gF(this, this.model, this.view, this.renderers, this.treeDelegate, this._options), this.onDidChangeStickyScrollFocused = this.stickyScrollController.onDidChangeHasFocus) : this.stickyScrollController && !this._options.enableStickyScroll && (this.onDidChangeStickyScrollFocused = ne.None, this.stickyScrollController.dispose(), this.stickyScrollController = void 0), (t = this.stickyScrollController) === null || t === void 0 || t.updateOptions(e);
  }
  // Widget
  getHTMLElement() {
    return this.view.getHTMLElement();
  }
  get scrollTop() {
    return this.view.scrollTop;
  }
  set scrollTop(e) {
    this.view.scrollTop = e;
  }
  get scrollHeight() {
    return this.view.scrollHeight;
  }
  get renderHeight() {
    return this.view.renderHeight;
  }
  get ariaLabel() {
    return this.view.ariaLabel;
  }
  set ariaLabel(e) {
    this.view.ariaLabel = e;
  }
  domFocus() {
    var e;
    !((e = this.stickyScrollController) === null || e === void 0) && e.focusedLast() ? this.stickyScrollController.domFocus() : this.view.domFocus();
  }
  layout(e, t) {
    var i;
    this.view.layout(e, t), Ic(t) && ((i = this.findController) === null || i === void 0 || i.layout(t));
  }
  style(e) {
    var t, i;
    const n = `.${this.view.domId}`, s = [];
    e.treeIndentGuidesStroke && (s.push(`.monaco-list${n}:hover .monaco-tl-indent > .indent-guide, .monaco-list${n}.always .monaco-tl-indent > .indent-guide  { border-color: ${e.treeInactiveIndentGuidesStroke}; }`), s.push(`.monaco-list${n} .monaco-tl-indent > .indent-guide.active { border-color: ${e.treeIndentGuidesStroke}; }`));
    const o = (t = e.treeStickyScrollBackground) !== null && t !== void 0 ? t : e.listBackground;
    o && (s.push(`.monaco-list${n} .monaco-scrollable-element .monaco-tree-sticky-container { background-color: ${o}; }`), s.push(`.monaco-list${n} .monaco-scrollable-element .monaco-tree-sticky-container .monaco-tree-sticky-row { background-color: ${o}; }`)), e.treeStickyScrollBorder && s.push(`.monaco-list${n} .monaco-scrollable-element .monaco-tree-sticky-container { border-bottom: 1px solid ${e.treeStickyScrollBorder}; }`), e.treeStickyScrollShadow && s.push(`.monaco-list${n} .monaco-scrollable-element .monaco-tree-sticky-container .monaco-tree-sticky-container-shadow { box-shadow: ${e.treeStickyScrollShadow} 0 6px 6px -6px inset; height: 3px; }`), e.listFocusForeground && (s.push(`.monaco-list${n}.sticky-scroll-focused .monaco-scrollable-element .monaco-tree-sticky-container:focus .monaco-list-row.focused { color: ${e.listFocusForeground}; }`), s.push(`.monaco-list${n}:not(.sticky-scroll-focused) .monaco-scrollable-element .monaco-tree-sticky-container .monaco-list-row.focused { color: inherit; }`));
    const a = ed(e.listFocusAndSelectionOutline, ed(e.listSelectionOutline, (i = e.listFocusOutline) !== null && i !== void 0 ? i : ""));
    a && (s.push(`.monaco-list${n}.sticky-scroll-focused .monaco-scrollable-element .monaco-tree-sticky-container:focus .monaco-list-row.focused.selected { outline: 1px solid ${a}; outline-offset: -1px;}`), s.push(`.monaco-list${n}:not(.sticky-scroll-focused) .monaco-scrollable-element .monaco-tree-sticky-container .monaco-list-row.focused.selected { outline: inherit;}`)), e.listFocusOutline && (s.push(`.monaco-list${n}.sticky-scroll-focused .monaco-scrollable-element .monaco-tree-sticky-container:focus .monaco-list-row.focused { outline: 1px solid ${e.listFocusOutline}; outline-offset: -1px; }`), s.push(`.monaco-list${n}:not(.sticky-scroll-focused) .monaco-scrollable-element .monaco-tree-sticky-container .monaco-list-row.focused { outline: inherit; }`), s.push(`.monaco-workbench.context-menu-visible .monaco-list${n}.last-focused.sticky-scroll-focused .monaco-scrollable-element .monaco-tree-sticky-container .monaco-list-row.passive-focused { outline: 1px solid ${e.listFocusOutline}; outline-offset: -1px; }`), s.push(`.monaco-workbench.context-menu-visible .monaco-list${n}.last-focused.sticky-scroll-focused .monaco-list-rows .monaco-list-row.focused { outline: inherit; }`), s.push(`.monaco-workbench.context-menu-visible .monaco-list${n}.last-focused:not(.sticky-scroll-focused) .monaco-tree-sticky-container .monaco-list-rows .monaco-list-row.focused { outline: inherit; }`)), this.styleElement.textContent = s.join(`
`), this.view.style(e);
  }
  // Tree navigation
  getParentElement(e) {
    const t = this.model.getParentNodeLocation(e);
    return this.model.getNode(t).element;
  }
  getFirstElementChild(e) {
    return this.model.getFirstElementChild(e);
  }
  // Tree
  getNode(e) {
    return this.model.getNode(e);
  }
  getNodeLocation(e) {
    return this.model.getNodeLocation(e);
  }
  collapse(e, t = !1) {
    return this.model.setCollapsed(e, !0, t);
  }
  expand(e, t = !1) {
    return this.model.setCollapsed(e, !1, t);
  }
  toggleCollapsed(e, t = !1) {
    return this.model.setCollapsed(e, void 0, t);
  }
  isCollapsible(e) {
    return this.model.isCollapsible(e);
  }
  setCollapsible(e, t) {
    return this.model.setCollapsible(e, t);
  }
  isCollapsed(e) {
    return this.model.isCollapsed(e);
  }
  refilter() {
    this._onWillRefilter.fire(void 0), this.model.refilter();
  }
  setSelection(e, t) {
    this.eventBufferer.bufferEvents(() => {
      const i = e.map((s) => this.model.getNode(s));
      this.selection.set(i, t);
      const n = e.map((s) => this.model.getListIndex(s)).filter((s) => s > -1);
      this.view.setSelection(n, t, !0);
    });
  }
  getSelection() {
    return this.selection.get();
  }
  setFocus(e, t) {
    this.eventBufferer.bufferEvents(() => {
      const i = e.map((s) => this.model.getNode(s));
      this.focus.set(i, t);
      const n = e.map((s) => this.model.getListIndex(s)).filter((s) => s > -1);
      this.view.setFocus(n, t, !0);
    });
  }
  focusNext(e = 1, t = !1, i, n = $d(i) && i.altKey ? void 0 : this.focusNavigationFilter) {
    this.view.focusNext(e, t, i, n);
  }
  focusPrevious(e = 1, t = !1, i, n = $d(i) && i.altKey ? void 0 : this.focusNavigationFilter) {
    this.view.focusPrevious(e, t, i, n);
  }
  focusNextPage(e, t = $d(e) && e.altKey ? void 0 : this.focusNavigationFilter) {
    return this.view.focusNextPage(e, t);
  }
  focusPreviousPage(e, t = $d(e) && e.altKey ? void 0 : this.focusNavigationFilter) {
    return this.view.focusPreviousPage(e, t, () => {
      var i, n;
      return (n = (i = this.stickyScrollController) === null || i === void 0 ? void 0 : i.height) !== null && n !== void 0 ? n : 0;
    });
  }
  focusFirst(e, t = $d(e) && e.altKey ? void 0 : this.focusNavigationFilter) {
    this.view.focusFirst(e, t);
  }
  getFocus() {
    return this.focus.get();
  }
  reveal(e, t) {
    this.model.expandTo(e);
    const i = this.model.getListIndex(e);
    if (i !== -1)
      if (!this.stickyScrollController)
        this.view.reveal(i, t);
      else {
        const n = this.stickyScrollController.nodePositionTopBelowWidget(this.getNode(e));
        this.view.reveal(i, t, n);
      }
  }
  // List
  onLeftArrow(e) {
    e.preventDefault(), e.stopPropagation();
    const t = this.view.getFocusedElements();
    if (t.length === 0)
      return;
    const i = t[0], n = this.model.getNodeLocation(i);
    if (!this.model.setCollapsed(n, !0)) {
      const o = this.model.getParentNodeLocation(n);
      if (!o)
        return;
      const a = this.model.getListIndex(o);
      this.view.reveal(a), this.view.setFocus([a]);
    }
  }
  onRightArrow(e) {
    e.preventDefault(), e.stopPropagation();
    const t = this.view.getFocusedElements();
    if (t.length === 0)
      return;
    const i = t[0], n = this.model.getNodeLocation(i);
    if (!this.model.setCollapsed(n, !1)) {
      if (!i.children.some((l) => l.visible))
        return;
      const [o] = this.view.getFocus(), a = o + 1;
      this.view.reveal(a), this.view.setFocus([a]);
    }
  }
  onSpace(e) {
    e.preventDefault(), e.stopPropagation();
    const t = this.view.getFocusedElements();
    if (t.length === 0)
      return;
    const i = t[0], n = this.model.getNodeLocation(i), s = e.browserEvent.altKey;
    this.model.setCollapsed(n, void 0, s);
  }
  dispose() {
    var e;
    zt(this.disposables), (e = this.stickyScrollController) === null || e === void 0 || e.dispose(), this.view.dispose();
  }
}
class yM {
  constructor(e, t, i = {}) {
    this.user = e, this.rootRef = null, this.nodes = /* @__PURE__ */ new Map(), this.nodesByIdentity = /* @__PURE__ */ new Map(), this.model = new Xne(e, t, null, i), this.onDidSplice = this.model.onDidSplice, this.onDidChangeCollapseState = this.model.onDidChangeCollapseState, this.onDidChangeRenderNodeCount = this.model.onDidChangeRenderNodeCount, i.sorter && (this.sorter = {
      compare(n, s) {
        return i.sorter.compare(n.element, s.element);
      }
    }), this.identityProvider = i.identityProvider;
  }
  setChildren(e, t = ut.empty(), i = {}) {
    const n = this.getElementLocation(e);
    this._setChildren(n, this.preserveCollapseState(t), i);
  }
  _setChildren(e, t = ut.empty(), i) {
    const n = /* @__PURE__ */ new Set(), s = /* @__PURE__ */ new Set(), o = (l) => {
      var d;
      if (l.element === null)
        return;
      const c = l;
      if (n.add(c.element), this.nodes.set(c.element, c), this.identityProvider) {
        const h = this.identityProvider.getId(c.element).toString();
        s.add(h), this.nodesByIdentity.set(h, c);
      }
      (d = i.onDidCreateNode) === null || d === void 0 || d.call(i, c);
    }, a = (l) => {
      var d;
      if (l.element === null)
        return;
      const c = l;
      if (n.has(c.element) || this.nodes.delete(c.element), this.identityProvider) {
        const h = this.identityProvider.getId(c.element).toString();
        s.has(h) || this.nodesByIdentity.delete(h);
      }
      (d = i.onDidDeleteNode) === null || d === void 0 || d.call(i, c);
    };
    this.model.splice([...e, 0], Number.MAX_VALUE, t, { ...i, onDidCreateNode: o, onDidDeleteNode: a });
  }
  preserveCollapseState(e = ut.empty()) {
    return this.sorter && (e = [...e].sort(this.sorter.compare.bind(this.sorter))), ut.map(e, (t) => {
      let i = this.nodes.get(t.element);
      if (!i && this.identityProvider) {
        const o = this.identityProvider.getId(t.element).toString();
        i = this.nodesByIdentity.get(o);
      }
      if (!i) {
        let o;
        return typeof t.collapsed > "u" ? o = void 0 : t.collapsed === no.Collapsed || t.collapsed === no.PreserveOrCollapsed ? o = !0 : t.collapsed === no.Expanded || t.collapsed === no.PreserveOrExpanded ? o = !1 : o = !!t.collapsed, {
          ...t,
          children: this.preserveCollapseState(t.children),
          collapsed: o
        };
      }
      const n = typeof t.collapsible == "boolean" ? t.collapsible : i.collapsible;
      let s;
      return typeof t.collapsed > "u" || t.collapsed === no.PreserveOrCollapsed || t.collapsed === no.PreserveOrExpanded ? s = i.collapsed : t.collapsed === no.Collapsed ? s = !0 : t.collapsed === no.Expanded ? s = !1 : s = !!t.collapsed, {
        ...t,
        collapsible: n,
        collapsed: s,
        children: this.preserveCollapseState(t.children)
      };
    });
  }
  rerender(e) {
    const t = this.getElementLocation(e);
    this.model.rerender(t);
  }
  getFirstElementChild(e = null) {
    const t = this.getElementLocation(e);
    return this.model.getFirstElementChild(t);
  }
  has(e) {
    return this.nodes.has(e);
  }
  getListIndex(e) {
    const t = this.getElementLocation(e);
    return this.model.getListIndex(t);
  }
  getListRenderCount(e) {
    const t = this.getElementLocation(e);
    return this.model.getListRenderCount(t);
  }
  isCollapsible(e) {
    const t = this.getElementLocation(e);
    return this.model.isCollapsible(t);
  }
  setCollapsible(e, t) {
    const i = this.getElementLocation(e);
    return this.model.setCollapsible(i, t);
  }
  isCollapsed(e) {
    const t = this.getElementLocation(e);
    return this.model.isCollapsed(t);
  }
  setCollapsed(e, t, i) {
    const n = this.getElementLocation(e);
    return this.model.setCollapsed(n, t, i);
  }
  expandTo(e) {
    const t = this.getElementLocation(e);
    this.model.expandTo(t);
  }
  refilter() {
    this.model.refilter();
  }
  getNode(e = null) {
    if (e === null)
      return this.model.getNode(this.model.rootRef);
    const t = this.nodes.get(e);
    if (!t)
      throw new ao(this.user, `Tree element not found: ${e}`);
    return t;
  }
  getNodeLocation(e) {
    return e.element;
  }
  getParentNodeLocation(e) {
    if (e === null)
      throw new ao(this.user, "Invalid getParentNodeLocation call");
    const t = this.nodes.get(e);
    if (!t)
      throw new ao(this.user, `Tree element not found: ${e}`);
    const i = this.model.getNodeLocation(t), n = this.model.getParentNodeLocation(i);
    return this.model.getNode(n).element;
  }
  getElementLocation(e) {
    if (e === null)
      return [];
    const t = this.nodes.get(e);
    if (!t)
      throw new ao(this.user, `Tree element not found: ${e}`);
    return this.model.getNodeLocation(t);
  }
}
function Uw(r) {
  const e = [r.element], t = r.incompressible || !1;
  return {
    element: { elements: e, incompressible: t },
    children: ut.map(ut.from(r.children), Uw),
    collapsible: r.collapsible,
    collapsed: r.collapsed
  };
}
function $w(r) {
  const e = [r.element], t = r.incompressible || !1;
  let i, n;
  for (; [n, i] = ut.consume(ut.from(r.children), 2), !(n.length !== 1 || n[0].incompressible); )
    r = n[0], e.push(r.element);
  return {
    element: { elements: e, incompressible: t },
    children: ut.map(ut.concat(n, i), $w),
    collapsible: r.collapsible,
    collapsed: r.collapsed
  };
}
function dE(r, e = 0) {
  let t;
  return e < r.element.elements.length - 1 ? t = [dE(r, e + 1)] : t = ut.map(ut.from(r.children), (i) => dE(i, 0)), e === 0 && r.element.incompressible ? {
    element: r.element.elements[e],
    children: t,
    incompressible: !0,
    collapsible: r.collapsible,
    collapsed: r.collapsed
  } : {
    element: r.element.elements[e],
    children: t,
    collapsible: r.collapsible,
    collapsed: r.collapsed
  };
}
function fF(r) {
  return dE(r, 0);
}
function Gz(r, e, t) {
  return r.element === e ? { ...r, children: t } : { ...r, children: ut.map(ut.from(r.children), (i) => Gz(i, e, t)) };
}
const gse = (r) => ({
  getId(e) {
    return e.elements.map((t) => r.getId(t).toString()).join("\0");
  }
});
class fse {
  get onDidSplice() {
    return this.model.onDidSplice;
  }
  get onDidChangeCollapseState() {
    return this.model.onDidChangeCollapseState;
  }
  get onDidChangeRenderNodeCount() {
    return this.model.onDidChangeRenderNodeCount;
  }
  constructor(e, t, i = {}) {
    this.user = e, this.rootRef = null, this.nodes = /* @__PURE__ */ new Map(), this.model = new yM(e, t, i), this.enabled = typeof i.compressionEnabled > "u" ? !0 : i.compressionEnabled, this.identityProvider = i.identityProvider;
  }
  setChildren(e, t = ut.empty(), i) {
    const n = i.diffIdentityProvider && gse(i.diffIdentityProvider);
    if (e === null) {
      const f = ut.map(t, this.enabled ? $w : Uw);
      this._setChildren(null, f, { diffIdentityProvider: n, diffDepth: 1 / 0 });
      return;
    }
    const s = this.nodes.get(e);
    if (!s)
      throw new ao(this.user, "Unknown compressed tree node");
    const o = this.model.getNode(s), a = this.model.getParentNodeLocation(s), l = this.model.getNode(a), d = fF(o), c = Gz(d, e, t), h = (this.enabled ? $w : Uw)(c), u = i.diffIdentityProvider ? (f, m) => i.diffIdentityProvider.getId(f) === i.diffIdentityProvider.getId(m) : void 0;
    if (ci(h.element.elements, o.element.elements, u)) {
      this._setChildren(s, h.children || ut.empty(), { diffIdentityProvider: n, diffDepth: 1 });
      return;
    }
    const g = l.children.map((f) => f === o ? h : f);
    this._setChildren(l.element, g, {
      diffIdentityProvider: n,
      diffDepth: o.depth - l.depth
    });
  }
  isCompressionEnabled() {
    return this.enabled;
  }
  setCompressionEnabled(e) {
    if (e === this.enabled)
      return;
    this.enabled = e;
    const i = this.model.getNode().children, n = ut.map(i, fF), s = ut.map(n, e ? $w : Uw);
    this._setChildren(null, s, {
      diffIdentityProvider: this.identityProvider,
      diffDepth: 1 / 0
    });
  }
  _setChildren(e, t, i) {
    const n = /* @__PURE__ */ new Set(), s = (a) => {
      for (const l of a.element.elements)
        n.add(l), this.nodes.set(l, a.element);
    }, o = (a) => {
      for (const l of a.element.elements)
        n.has(l) || this.nodes.delete(l);
    };
    this.model.setChildren(e, t, { ...i, onDidCreateNode: s, onDidDeleteNode: o });
  }
  has(e) {
    return this.nodes.has(e);
  }
  getListIndex(e) {
    const t = this.getCompressedNode(e);
    return this.model.getListIndex(t);
  }
  getListRenderCount(e) {
    const t = this.getCompressedNode(e);
    return this.model.getListRenderCount(t);
  }
  getNode(e) {
    if (typeof e > "u")
      return this.model.getNode();
    const t = this.getCompressedNode(e);
    return this.model.getNode(t);
  }
  // TODO: review this
  getNodeLocation(e) {
    const t = this.model.getNodeLocation(e);
    return t === null ? null : t.elements[t.elements.length - 1];
  }
  // TODO: review this
  getParentNodeLocation(e) {
    const t = this.getCompressedNode(e), i = this.model.getParentNodeLocation(t);
    return i === null ? null : i.elements[i.elements.length - 1];
  }
  getFirstElementChild(e) {
    const t = this.getCompressedNode(e);
    return this.model.getFirstElementChild(t);
  }
  isCollapsible(e) {
    const t = this.getCompressedNode(e);
    return this.model.isCollapsible(t);
  }
  setCollapsible(e, t) {
    const i = this.getCompressedNode(e);
    return this.model.setCollapsible(i, t);
  }
  isCollapsed(e) {
    const t = this.getCompressedNode(e);
    return this.model.isCollapsed(t);
  }
  setCollapsed(e, t, i) {
    const n = this.getCompressedNode(e);
    return this.model.setCollapsed(n, t, i);
  }
  expandTo(e) {
    const t = this.getCompressedNode(e);
    this.model.expandTo(t);
  }
  rerender(e) {
    const t = this.getCompressedNode(e);
    this.model.rerender(t);
  }
  refilter() {
    this.model.refilter();
  }
  getCompressedNode(e) {
    if (e === null)
      return null;
    const t = this.nodes.get(e);
    if (!t)
      throw new ao(this.user, `Tree element not found: ${e}`);
    return t;
  }
}
const pse = (r) => r[r.length - 1];
class LM {
  get element() {
    return this.node.element === null ? null : this.unwrapper(this.node.element);
  }
  get children() {
    return this.node.children.map((e) => new LM(this.unwrapper, e));
  }
  get depth() {
    return this.node.depth;
  }
  get visibleChildrenCount() {
    return this.node.visibleChildrenCount;
  }
  get visibleChildIndex() {
    return this.node.visibleChildIndex;
  }
  get collapsible() {
    return this.node.collapsible;
  }
  get collapsed() {
    return this.node.collapsed;
  }
  get visible() {
    return this.node.visible;
  }
  get filterData() {
    return this.node.filterData;
  }
  constructor(e, t) {
    this.unwrapper = e, this.node = t;
  }
}
function mse(r, e) {
  return {
    splice(t, i, n) {
      e.splice(t, i, n.map((s) => r.map(s)));
    },
    updateElementHeight(t, i) {
      e.updateElementHeight(t, i);
    }
  };
}
function _se(r, e) {
  return {
    ...e,
    identityProvider: e.identityProvider && {
      getId(t) {
        return e.identityProvider.getId(r(t));
      }
    },
    sorter: e.sorter && {
      compare(t, i) {
        return e.sorter.compare(t.elements[0], i.elements[0]);
      }
    },
    filter: e.filter && {
      filter(t, i) {
        return e.filter.filter(r(t), i);
      }
    }
  };
}
class vse {
  get onDidSplice() {
    return ne.map(this.model.onDidSplice, ({ insertedNodes: e, deletedNodes: t }) => ({
      insertedNodes: e.map((i) => this.nodeMapper.map(i)),
      deletedNodes: t.map((i) => this.nodeMapper.map(i))
    }));
  }
  get onDidChangeCollapseState() {
    return ne.map(this.model.onDidChangeCollapseState, ({ node: e, deep: t }) => ({
      node: this.nodeMapper.map(e),
      deep: t
    }));
  }
  get onDidChangeRenderNodeCount() {
    return ne.map(this.model.onDidChangeRenderNodeCount, (e) => this.nodeMapper.map(e));
  }
  constructor(e, t, i = {}) {
    this.rootRef = null, this.elementMapper = i.elementMapper || pse;
    const n = (s) => this.elementMapper(s.elements);
    this.nodeMapper = new CM((s) => new LM(n, s)), this.model = new fse(e, mse(this.nodeMapper, t), _se(n, i));
  }
  setChildren(e, t = ut.empty(), i = {}) {
    this.model.setChildren(e, t, i);
  }
  isCompressionEnabled() {
    return this.model.isCompressionEnabled();
  }
  setCompressionEnabled(e) {
    this.model.setCompressionEnabled(e);
  }
  has(e) {
    return this.model.has(e);
  }
  getListIndex(e) {
    return this.model.getListIndex(e);
  }
  getListRenderCount(e) {
    return this.model.getListRenderCount(e);
  }
  getNode(e) {
    return this.nodeMapper.map(this.model.getNode(e));
  }
  getNodeLocation(e) {
    return e.element;
  }
  getParentNodeLocation(e) {
    return this.model.getParentNodeLocation(e);
  }
  getFirstElementChild(e) {
    const t = this.model.getFirstElementChild(e);
    return t === null || typeof t > "u" ? t : this.elementMapper(t.elements);
  }
  isCollapsible(e) {
    return this.model.isCollapsible(e);
  }
  setCollapsible(e, t) {
    return this.model.setCollapsible(e, t);
  }
  isCollapsed(e) {
    return this.model.isCollapsed(e);
  }
  setCollapsed(e, t, i) {
    return this.model.setCollapsed(e, t, i);
  }
  expandTo(e) {
    return this.model.expandTo(e);
  }
  rerender(e) {
    return this.model.rerender(e);
  }
  refilter() {
    return this.model.refilter();
  }
  getCompressedTreeNode(e = null) {
    return this.model.getNode(e);
  }
}
var bse = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
};
class DM extends qz {
  get onDidChangeCollapseState() {
    return this.model.onDidChangeCollapseState;
  }
  constructor(e, t, i, n, s = {}) {
    super(e, t, i, n, s), this.user = e;
  }
  setChildren(e, t = ut.empty(), i) {
    this.model.setChildren(e, t, i);
  }
  rerender(e) {
    if (e === void 0) {
      this.view.rerender();
      return;
    }
    this.model.rerender(e);
  }
  hasElement(e) {
    return this.model.has(e);
  }
  createModel(e, t, i) {
    return new yM(e, t, i);
  }
}
class Zz {
  get compressedTreeNodeProvider() {
    return this._compressedTreeNodeProvider();
  }
  constructor(e, t, i) {
    this._compressedTreeNodeProvider = e, this.stickyScrollDelegate = t, this.renderer = i, this.templateId = i.templateId, i.onDidChangeTwistieState && (this.onDidChangeTwistieState = i.onDidChangeTwistieState);
  }
  renderTemplate(e) {
    return { compressedTreeNode: void 0, data: this.renderer.renderTemplate(e) };
  }
  renderElement(e, t, i, n) {
    let s = this.stickyScrollDelegate.getCompressedNode(e);
    s || (s = this.compressedTreeNodeProvider.getCompressedTreeNode(e.element)), s.element.elements.length === 1 ? (i.compressedTreeNode = void 0, this.renderer.renderElement(e, t, i.data, n)) : (i.compressedTreeNode = s, this.renderer.renderCompressedElements(s, t, i.data, n));
  }
  disposeElement(e, t, i, n) {
    var s, o, a, l;
    i.compressedTreeNode ? (o = (s = this.renderer).disposeCompressedElements) === null || o === void 0 || o.call(s, i.compressedTreeNode, t, i.data, n) : (l = (a = this.renderer).disposeElement) === null || l === void 0 || l.call(a, e, t, i.data, n);
  }
  disposeTemplate(e) {
    this.renderer.disposeTemplate(e.data);
  }
  renderTwistie(e, t) {
    return this.renderer.renderTwistie ? this.renderer.renderTwistie(e, t) : !1;
  }
}
bse([
  ki
], Zz.prototype, "compressedTreeNodeProvider", null);
class Cse {
  constructor(e) {
    this.modelProvider = e, this.compressedStickyNodes = /* @__PURE__ */ new Map();
  }
  getCompressedNode(e) {
    return this.compressedStickyNodes.get(e);
  }
  constrainStickyScrollNodes(e, t, i) {
    if (this.compressedStickyNodes.clear(), e.length === 0)
      return [];
    for (let n = 0; n < e.length; n++) {
      const s = e[n], o = s.position + s.height;
      if (n + 1 < e.length && o + e[n + 1].height > i || n >= t - 1 && t < e.length) {
        const l = e.slice(0, n), d = e.slice(n), c = this.compressStickyNodes(d);
        return [...l, c];
      }
    }
    return e;
  }
  compressStickyNodes(e) {
    if (e.length === 0)
      throw new Error("Can't compress empty sticky nodes");
    const t = this.modelProvider();
    if (!t.isCompressionEnabled())
      return e[0];
    const i = [];
    for (let d = 0; d < e.length; d++) {
      const c = e[d], h = t.getCompressedTreeNode(c.node.element);
      if (h.element) {
        if (d !== 0 && h.element.incompressible)
          break;
        i.push(...h.element.elements);
      }
    }
    if (i.length < 2)
      return e[0];
    const n = e[e.length - 1], s = { elements: i, incompressible: !1 }, o = { ...n.node, children: [], element: s }, a = new Proxy(e[0].node, {}), l = {
      node: a,
      startIndex: e[0].startIndex,
      endIndex: n.endIndex,
      position: e[0].position,
      height: e[0].height
    };
    return this.compressedStickyNodes.set(a, o), l;
  }
}
function wse(r, e) {
  return e && {
    ...e,
    keyboardNavigationLabelProvider: e.keyboardNavigationLabelProvider && {
      getKeyboardNavigationLabel(t) {
        let i;
        try {
          i = r().getCompressedTreeNode(t);
        } catch {
          return e.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(t);
        }
        return i.element.elements.length === 1 ? e.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(t) : e.keyboardNavigationLabelProvider.getCompressedNodeKeyboardNavigationLabel(i.element.elements);
      }
    }
  };
}
class Yz extends DM {
  constructor(e, t, i, n, s = {}) {
    const o = () => this, a = new Cse(() => this.model), l = n.map((d) => new Zz(o, a, d));
    super(e, t, i, l, { ...wse(o, s), stickyScrollDelegate: a });
  }
  setChildren(e, t = ut.empty(), i) {
    this.model.setChildren(e, t, i);
  }
  createModel(e, t, i) {
    return new vse(e, t, i);
  }
  updateOptions(e = {}) {
    super.updateOptions(e), typeof e.compressionEnabled < "u" && this.model.setCompressionEnabled(e.compressionEnabled);
  }
  getCompressedTreeNode(e = null) {
    return this.model.getCompressedTreeNode(e);
  }
}
function Rk(r) {
  return {
    ...r,
    children: [],
    refreshPromise: void 0,
    stale: !0,
    slow: !1,
    forceExpanded: !1
  };
}
function cE(r, e) {
  return e.parent ? e.parent === r ? !0 : cE(r, e.parent) : !1;
}
function Sse(r, e) {
  return r === e || cE(r, e) || cE(e, r);
}
class kM {
  get element() {
    return this.node.element.element;
  }
  get children() {
    return this.node.children.map((e) => new kM(e));
  }
  get depth() {
    return this.node.depth;
  }
  get visibleChildrenCount() {
    return this.node.visibleChildrenCount;
  }
  get visibleChildIndex() {
    return this.node.visibleChildIndex;
  }
  get collapsible() {
    return this.node.collapsible;
  }
  get collapsed() {
    return this.node.collapsed;
  }
  get visible() {
    return this.node.visible;
  }
  get filterData() {
    return this.node.filterData;
  }
  constructor(e) {
    this.node = e;
  }
}
class yse {
  constructor(e, t, i) {
    this.renderer = e, this.nodeMapper = t, this.onDidChangeTwistieState = i, this.renderedNodes = /* @__PURE__ */ new Map(), this.templateId = e.templateId;
  }
  renderTemplate(e) {
    return { templateData: this.renderer.renderTemplate(e) };
  }
  renderElement(e, t, i, n) {
    this.renderer.renderElement(this.nodeMapper.map(e), t, i.templateData, n);
  }
  renderTwistie(e, t) {
    return e.slow ? (t.classList.add(...Le.asClassNameArray(me.treeItemLoading)), !0) : (t.classList.remove(...Le.asClassNameArray(me.treeItemLoading)), !1);
  }
  disposeElement(e, t, i, n) {
    var s, o;
    (o = (s = this.renderer).disposeElement) === null || o === void 0 || o.call(s, this.nodeMapper.map(e), t, i.templateData, n);
  }
  disposeTemplate(e) {
    this.renderer.disposeTemplate(e.templateData);
  }
  dispose() {
    this.renderedNodes.clear();
  }
}
function pF(r) {
  return {
    browserEvent: r.browserEvent,
    elements: r.elements.map((e) => e.element)
  };
}
function mF(r) {
  return {
    browserEvent: r.browserEvent,
    element: r.element && r.element.element,
    target: r.target
  };
}
class Lse extends Lb {
  constructor(e) {
    super(e.elements.map((t) => t.element)), this.data = e;
  }
}
function Ak(r) {
  return r instanceof Lb ? new Lse(r) : r;
}
class Dse {
  constructor(e) {
    this.dnd = e;
  }
  getDragURI(e) {
    return this.dnd.getDragURI(e.element);
  }
  getDragLabel(e, t) {
    if (this.dnd.getDragLabel)
      return this.dnd.getDragLabel(e.map((i) => i.element), t);
  }
  onDragStart(e, t) {
    var i, n;
    (n = (i = this.dnd).onDragStart) === null || n === void 0 || n.call(i, Ak(e), t);
  }
  onDragOver(e, t, i, n, s, o = !0) {
    return this.dnd.onDragOver(Ak(e), t && t.element, i, n, s);
  }
  drop(e, t, i, n, s) {
    this.dnd.drop(Ak(e), t && t.element, i, n, s);
  }
  onDragEnd(e) {
    var t, i;
    (i = (t = this.dnd).onDragEnd) === null || i === void 0 || i.call(t, e);
  }
  dispose() {
    this.dnd.dispose();
  }
}
function Qz(r) {
  return r && {
    ...r,
    collapseByDefault: !0,
    identityProvider: r.identityProvider && {
      getId(e) {
        return r.identityProvider.getId(e.element);
      }
    },
    dnd: r.dnd && new Dse(r.dnd),
    multipleSelectionController: r.multipleSelectionController && {
      isSelectionSingleChangeEvent(e) {
        return r.multipleSelectionController.isSelectionSingleChangeEvent({ ...e, element: e.element });
      },
      isSelectionRangeChangeEvent(e) {
        return r.multipleSelectionController.isSelectionRangeChangeEvent({ ...e, element: e.element });
      }
    },
    accessibilityProvider: r.accessibilityProvider && {
      ...r.accessibilityProvider,
      getPosInSet: void 0,
      getSetSize: void 0,
      getRole: r.accessibilityProvider.getRole ? (e) => r.accessibilityProvider.getRole(e.element) : () => "treeitem",
      isChecked: r.accessibilityProvider.isChecked ? (e) => {
        var t;
        return !!(!((t = r.accessibilityProvider) === null || t === void 0) && t.isChecked(e.element));
      } : void 0,
      getAriaLabel(e) {
        return r.accessibilityProvider.getAriaLabel(e.element);
      },
      getWidgetAriaLabel() {
        return r.accessibilityProvider.getWidgetAriaLabel();
      },
      getWidgetRole: r.accessibilityProvider.getWidgetRole ? () => r.accessibilityProvider.getWidgetRole() : () => "tree",
      getAriaLevel: r.accessibilityProvider.getAriaLevel && ((e) => r.accessibilityProvider.getAriaLevel(e.element)),
      getActiveDescendantId: r.accessibilityProvider.getActiveDescendantId && ((e) => r.accessibilityProvider.getActiveDescendantId(e.element))
    },
    filter: r.filter && {
      filter(e, t) {
        return r.filter.filter(e.element, t);
      }
    },
    keyboardNavigationLabelProvider: r.keyboardNavigationLabelProvider && {
      ...r.keyboardNavigationLabelProvider,
      getKeyboardNavigationLabel(e) {
        return r.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(e.element);
      }
    },
    sorter: void 0,
    expandOnlyOnTwistieClick: typeof r.expandOnlyOnTwistieClick > "u" ? void 0 : typeof r.expandOnlyOnTwistieClick != "function" ? r.expandOnlyOnTwistieClick : (e) => r.expandOnlyOnTwistieClick(e.element),
    defaultFindVisibility: (e) => e.hasChildren && e.stale ? 1 : typeof r.defaultFindVisibility == "number" ? r.defaultFindVisibility : typeof r.defaultFindVisibility > "u" ? 2 : r.defaultFindVisibility(e.element)
  };
}
function hE(r, e) {
  e(r), r.children.forEach((t) => hE(t, e));
}
class Xz {
  get onDidScroll() {
    return this.tree.onDidScroll;
  }
  get onDidChangeFocus() {
    return ne.map(this.tree.onDidChangeFocus, pF);
  }
  get onDidChangeSelection() {
    return ne.map(this.tree.onDidChangeSelection, pF);
  }
  get onMouseDblClick() {
    return ne.map(this.tree.onMouseDblClick, mF);
  }
  get onPointer() {
    return ne.map(this.tree.onPointer, mF);
  }
  get onDidFocus() {
    return this.tree.onDidFocus;
  }
  /**
   * To be used internally only!
   * @deprecated
   */
  get onDidChangeModel() {
    return this.tree.onDidChangeModel;
  }
  get onDidChangeCollapseState() {
    return this.tree.onDidChangeCollapseState;
  }
  get onDidChangeFindOpenState() {
    return this.tree.onDidChangeFindOpenState;
  }
  get onDidChangeStickyScrollFocused() {
    return this.tree.onDidChangeStickyScrollFocused;
  }
  get onDidDispose() {
    return this.tree.onDidDispose;
  }
  constructor(e, t, i, n, s, o = {}) {
    this.user = e, this.dataSource = s, this.nodes = /* @__PURE__ */ new Map(), this.subTreeRefreshPromises = /* @__PURE__ */ new Map(), this.refreshPromises = /* @__PURE__ */ new Map(), this._onDidRender = new R(), this._onDidChangeNodeSlowState = new R(), this.nodeMapper = new CM((a) => new kM(a)), this.disposables = new q(), this.identityProvider = o.identityProvider, this.autoExpandSingleChildren = typeof o.autoExpandSingleChildren > "u" ? !1 : o.autoExpandSingleChildren, this.sorter = o.sorter, this.getDefaultCollapseState = (a) => o.collapseByDefault ? o.collapseByDefault(a) ? no.PreserveOrCollapsed : no.PreserveOrExpanded : void 0, this.tree = this.createTree(e, t, i, n, o), this.onDidChangeFindMode = this.tree.onDidChangeFindMode, this.onDidChangeFindMatchType = this.tree.onDidChangeFindMatchType, this.root = Rk({
      element: void 0,
      parent: null,
      hasChildren: !0,
      defaultCollapseState: void 0
    }), this.identityProvider && (this.root = {
      ...this.root,
      id: null
    }), this.nodes.set(null, this.root), this.tree.onDidChangeCollapseState(this._onDidChangeCollapseState, this, this.disposables);
  }
  createTree(e, t, i, n, s) {
    const o = new SM(i), a = n.map((d) => new yse(d, this.nodeMapper, this._onDidChangeNodeSlowState.event)), l = Qz(s) || {};
    return new DM(e, t, o, a, l);
  }
  updateOptions(e = {}) {
    this.tree.updateOptions(e);
  }
  // Widget
  getHTMLElement() {
    return this.tree.getHTMLElement();
  }
  get scrollTop() {
    return this.tree.scrollTop;
  }
  set scrollTop(e) {
    this.tree.scrollTop = e;
  }
  get scrollHeight() {
    return this.tree.scrollHeight;
  }
  get renderHeight() {
    return this.tree.renderHeight;
  }
  domFocus() {
    this.tree.domFocus();
  }
  layout(e, t) {
    this.tree.layout(e, t);
  }
  style(e) {
    this.tree.style(e);
  }
  // Model
  getInput() {
    return this.root.element;
  }
  async setInput(e, t) {
    this.refreshPromises.forEach((n) => n.cancel()), this.refreshPromises.clear(), this.root.element = e;
    const i = t && { viewState: t, focus: [], selection: [] };
    await this._updateChildren(e, !0, !1, i), i && (this.tree.setFocus(i.focus), this.tree.setSelection(i.selection)), t && typeof t.scrollTop == "number" && (this.scrollTop = t.scrollTop);
  }
  async _updateChildren(e = this.root.element, t = !0, i = !1, n, s) {
    if (typeof this.root.element > "u")
      throw new ao(this.user, "Tree input not set");
    this.root.refreshPromise && (await this.root.refreshPromise, await ne.toPromise(this._onDidRender.event));
    const o = this.getDataNode(e);
    if (await this.refreshAndRenderNode(o, t, n, s), i)
      try {
        this.tree.rerender(o);
      } catch {
      }
  }
  // View
  rerender(e) {
    if (e === void 0 || e === this.root.element) {
      this.tree.rerender();
      return;
    }
    const t = this.getDataNode(e);
    this.tree.rerender(t);
  }
  // Tree
  getNode(e = this.root.element) {
    const t = this.getDataNode(e), i = this.tree.getNode(t === this.root ? null : t);
    return this.nodeMapper.map(i);
  }
  collapse(e, t = !1) {
    const i = this.getDataNode(e);
    return this.tree.collapse(i === this.root ? null : i, t);
  }
  async expand(e, t = !1) {
    if (typeof this.root.element > "u")
      throw new ao(this.user, "Tree input not set");
    this.root.refreshPromise && (await this.root.refreshPromise, await ne.toPromise(this._onDidRender.event));
    const i = this.getDataNode(e);
    if (this.tree.hasElement(i) && !this.tree.isCollapsible(i) || (i.refreshPromise && (await this.root.refreshPromise, await ne.toPromise(this._onDidRender.event)), i !== this.root && !i.refreshPromise && !this.tree.isCollapsed(i)))
      return !1;
    const n = this.tree.expand(i === this.root ? null : i, t);
    return i.refreshPromise && (await this.root.refreshPromise, await ne.toPromise(this._onDidRender.event)), n;
  }
  setSelection(e, t) {
    const i = e.map((n) => this.getDataNode(n));
    this.tree.setSelection(i, t);
  }
  getSelection() {
    return this.tree.getSelection().map((t) => t.element);
  }
  setFocus(e, t) {
    const i = e.map((n) => this.getDataNode(n));
    this.tree.setFocus(i, t);
  }
  getFocus() {
    return this.tree.getFocus().map((t) => t.element);
  }
  reveal(e, t) {
    this.tree.reveal(this.getDataNode(e), t);
  }
  // Tree navigation
  getParentElement(e) {
    const t = this.tree.getParentElement(this.getDataNode(e));
    return t && t.element;
  }
  getFirstElementChild(e = this.root.element) {
    const t = this.getDataNode(e), i = this.tree.getFirstElementChild(t === this.root ? null : t);
    return i && i.element;
  }
  // Implementation
  getDataNode(e) {
    const t = this.nodes.get(e === this.root.element ? null : e);
    if (!t)
      throw new ao(this.user, `Data tree node not found: ${e}`);
    return t;
  }
  async refreshAndRenderNode(e, t, i, n) {
    await this.refreshNode(e, t, i), !this.disposables.isDisposed && this.render(e, i, n);
  }
  async refreshNode(e, t, i) {
    let n;
    if (this.subTreeRefreshPromises.forEach((s, o) => {
      !n && Sse(o, e) && (n = s.then(() => this.refreshNode(e, t, i)));
    }), n)
      return n;
    if (e !== this.root && this.tree.getNode(e).collapsed) {
      e.hasChildren = !!this.dataSource.hasChildren(e.element), e.stale = !0, this.setChildren(e, [], t, i);
      return;
    }
    return this.doRefreshSubTree(e, t, i);
  }
  async doRefreshSubTree(e, t, i) {
    let n;
    e.refreshPromise = new Promise((s) => n = s), this.subTreeRefreshPromises.set(e, e.refreshPromise), e.refreshPromise.finally(() => {
      e.refreshPromise = void 0, this.subTreeRefreshPromises.delete(e);
    });
    try {
      const s = await this.doRefreshNode(e, t, i);
      e.stale = !1, await Dx.settled(s.map((o) => this.doRefreshSubTree(o, t, i)));
    } finally {
      n();
    }
  }
  async doRefreshNode(e, t, i) {
    e.hasChildren = !!this.dataSource.hasChildren(e.element);
    let n;
    if (!e.hasChildren)
      n = Promise.resolve(ut.empty());
    else {
      const s = this.doGetChildren(e);
      if (aA(s))
        n = Promise.resolve(s);
      else {
        const o = cd(800);
        o.then(() => {
          e.slow = !0, this._onDidChangeNodeSlowState.fire(e);
        }, (a) => null), n = s.finally(() => o.cancel());
      }
    }
    try {
      const s = await n;
      return this.setChildren(e, s, t, i);
    } catch (s) {
      if (e !== this.root && this.tree.hasElement(e) && this.tree.collapse(e), cl(s))
        return [];
      throw s;
    } finally {
      e.slow && (e.slow = !1, this._onDidChangeNodeSlowState.fire(e));
    }
  }
  doGetChildren(e) {
    let t = this.refreshPromises.get(e);
    if (t)
      return t;
    const i = this.dataSource.getChildren(e.element);
    return aA(i) ? this.processChildren(i) : (t = Zi(async () => this.processChildren(await i)), this.refreshPromises.set(e, t), t.finally(() => {
      this.refreshPromises.delete(e);
    }));
  }
  _onDidChangeCollapseState({ node: e, deep: t }) {
    e.element !== null && !e.collapsed && e.element.stale && (t ? this.collapse(e.element.element) : this.refreshAndRenderNode(e.element, !1).catch(He));
  }
  setChildren(e, t, i, n) {
    const s = [...t];
    if (e.children.length === 0 && s.length === 0)
      return [];
    const o = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Map();
    for (const c of e.children)
      o.set(c.element, c), this.identityProvider && a.set(c.id, { node: c, collapsed: this.tree.hasElement(c) && this.tree.isCollapsed(c) });
    const l = [], d = s.map((c) => {
      const h = !!this.dataSource.hasChildren(c);
      if (!this.identityProvider) {
        const m = Rk({ element: c, parent: e, hasChildren: h, defaultCollapseState: this.getDefaultCollapseState(c) });
        return h && m.defaultCollapseState === no.PreserveOrExpanded && l.push(m), m;
      }
      const u = this.identityProvider.getId(c).toString(), g = a.get(u);
      if (g) {
        const m = g.node;
        return o.delete(m.element), this.nodes.delete(m.element), this.nodes.set(c, m), m.element = c, m.hasChildren = h, i ? g.collapsed ? (m.children.forEach((_) => hE(_, (v) => this.nodes.delete(v.element))), m.children.splice(0, m.children.length), m.stale = !0) : l.push(m) : h && !g.collapsed && l.push(m), m;
      }
      const f = Rk({ element: c, parent: e, id: u, hasChildren: h, defaultCollapseState: this.getDefaultCollapseState(c) });
      return n && n.viewState.focus && n.viewState.focus.indexOf(u) > -1 && n.focus.push(f), n && n.viewState.selection && n.viewState.selection.indexOf(u) > -1 && n.selection.push(f), (n && n.viewState.expanded && n.viewState.expanded.indexOf(u) > -1 || h && f.defaultCollapseState === no.PreserveOrExpanded) && l.push(f), f;
    });
    for (const c of o.values())
      hE(c, (h) => this.nodes.delete(h.element));
    for (const c of d)
      this.nodes.set(c.element, c);
    return e.children.splice(0, e.children.length, ...d), e !== this.root && this.autoExpandSingleChildren && d.length === 1 && l.length === 0 && (d[0].forceExpanded = !0, l.push(d[0])), l;
  }
  render(e, t, i) {
    const n = e.children.map((o) => this.asTreeElement(o, t)), s = i && {
      ...i,
      diffIdentityProvider: i.diffIdentityProvider && {
        getId(o) {
          return i.diffIdentityProvider.getId(o.element);
        }
      }
    };
    this.tree.setChildren(e === this.root ? null : e, n, s), e !== this.root && this.tree.setCollapsible(e, e.hasChildren), this._onDidRender.fire();
  }
  asTreeElement(e, t) {
    if (e.stale)
      return {
        element: e,
        collapsible: e.hasChildren,
        collapsed: !0
      };
    let i;
    return t && t.viewState.expanded && e.id && t.viewState.expanded.indexOf(e.id) > -1 ? i = !1 : e.forceExpanded ? (i = !1, e.forceExpanded = !1) : i = e.defaultCollapseState, {
      element: e,
      children: e.hasChildren ? ut.map(e.children, (n) => this.asTreeElement(n, t)) : [],
      collapsible: e.hasChildren,
      collapsed: i
    };
  }
  processChildren(e) {
    return this.sorter && (e = [...e].sort(this.sorter.compare.bind(this.sorter))), e;
  }
  dispose() {
    this.disposables.dispose(), this.tree.dispose();
  }
}
class xM {
  get element() {
    return {
      elements: this.node.element.elements.map((e) => e.element),
      incompressible: this.node.element.incompressible
    };
  }
  get children() {
    return this.node.children.map((e) => new xM(e));
  }
  get depth() {
    return this.node.depth;
  }
  get visibleChildrenCount() {
    return this.node.visibleChildrenCount;
  }
  get visibleChildIndex() {
    return this.node.visibleChildIndex;
  }
  get collapsible() {
    return this.node.collapsible;
  }
  get collapsed() {
    return this.node.collapsed;
  }
  get visible() {
    return this.node.visible;
  }
  get filterData() {
    return this.node.filterData;
  }
  constructor(e) {
    this.node = e;
  }
}
class kse {
  constructor(e, t, i, n) {
    this.renderer = e, this.nodeMapper = t, this.compressibleNodeMapperProvider = i, this.onDidChangeTwistieState = n, this.renderedNodes = /* @__PURE__ */ new Map(), this.disposables = [], this.templateId = e.templateId;
  }
  renderTemplate(e) {
    return { templateData: this.renderer.renderTemplate(e) };
  }
  renderElement(e, t, i, n) {
    this.renderer.renderElement(this.nodeMapper.map(e), t, i.templateData, n);
  }
  renderCompressedElements(e, t, i, n) {
    this.renderer.renderCompressedElements(this.compressibleNodeMapperProvider().map(e), t, i.templateData, n);
  }
  renderTwistie(e, t) {
    return e.slow ? (t.classList.add(...Le.asClassNameArray(me.treeItemLoading)), !0) : (t.classList.remove(...Le.asClassNameArray(me.treeItemLoading)), !1);
  }
  disposeElement(e, t, i, n) {
    var s, o;
    (o = (s = this.renderer).disposeElement) === null || o === void 0 || o.call(s, this.nodeMapper.map(e), t, i.templateData, n);
  }
  disposeCompressedElements(e, t, i, n) {
    var s, o;
    (o = (s = this.renderer).disposeCompressedElements) === null || o === void 0 || o.call(s, this.compressibleNodeMapperProvider().map(e), t, i.templateData, n);
  }
  disposeTemplate(e) {
    this.renderer.disposeTemplate(e.templateData);
  }
  dispose() {
    this.renderedNodes.clear(), this.disposables = zt(this.disposables);
  }
}
function xse(r) {
  const e = r && Qz(r);
  return e && {
    ...e,
    keyboardNavigationLabelProvider: e.keyboardNavigationLabelProvider && {
      ...e.keyboardNavigationLabelProvider,
      getCompressedNodeKeyboardNavigationLabel(t) {
        return r.keyboardNavigationLabelProvider.getCompressedNodeKeyboardNavigationLabel(t.map((i) => i.element));
      }
    }
  };
}
class Ise extends Xz {
  constructor(e, t, i, n, s, o, a = {}) {
    super(e, t, i, s, o, a), this.compressionDelegate = n, this.compressibleNodeMapper = new CM((l) => new xM(l)), this.filter = a.filter;
  }
  createTree(e, t, i, n, s) {
    const o = new SM(i), a = n.map((d) => new kse(d, this.nodeMapper, () => this.compressibleNodeMapper, this._onDidChangeNodeSlowState.event)), l = xse(s) || {};
    return new Yz(e, t, o, a, l);
  }
  asTreeElement(e, t) {
    return {
      incompressible: this.compressionDelegate.isIncompressible(e.element),
      ...super.asTreeElement(e, t)
    };
  }
  updateOptions(e = {}) {
    this.tree.updateOptions(e);
  }
  render(e, t, i) {
    if (!this.identityProvider)
      return super.render(e, t);
    const n = (g) => this.identityProvider.getId(g).toString(), s = (g) => {
      const f = /* @__PURE__ */ new Set();
      for (const m of g) {
        const _ = this.tree.getCompressedTreeNode(m === this.root ? null : m);
        if (_.element)
          for (const v of _.element.elements)
            f.add(n(v.element));
      }
      return f;
    }, o = s(this.tree.getSelection()), a = s(this.tree.getFocus());
    super.render(e, t, i);
    const l = this.getSelection();
    let d = !1;
    const c = this.getFocus();
    let h = !1;
    const u = (g) => {
      const f = g.element;
      if (f)
        for (let m = 0; m < f.elements.length; m++) {
          const _ = n(f.elements[m].element), v = f.elements[f.elements.length - 1].element;
          o.has(_) && l.indexOf(v) === -1 && (l.push(v), d = !0), a.has(_) && c.indexOf(v) === -1 && (c.push(v), h = !0);
        }
      g.children.forEach(u);
    };
    u(this.tree.getCompressedTreeNode(e === this.root ? null : e)), d && this.setSelection(l), h && this.setFocus(c);
  }
  // For compressed async data trees, `TreeVisibility.Recurse` doesn't currently work
  // and we have to filter everything beforehand
  // Related to #85193 and #85835
  processChildren(e) {
    return this.filter && (e = ut.filter(e, (t) => {
      const i = this.filter.filter(
        t,
        1
        /* TreeVisibility.Visible */
      ), n = Ese(i);
      if (n === 2)
        throw new Error("Recursive tree visibility not supported in async data compressed trees");
      return n === 1;
    })), super.processChildren(e);
  }
}
function Ese(r) {
  return typeof r == "boolean" ? r ? 1 : 0 : wM(r) ? fv(r.visibility) : fv(r);
}
class Tse extends qz {
  constructor(e, t, i, n, s, o = {}) {
    super(e, t, i, n, o), this.user = e, this.dataSource = s, this.identityProvider = o.identityProvider;
  }
  createModel(e, t, i) {
    return new yM(e, t, i);
  }
}
new oe("isMac", Je, p("isMac", "Whether the operating system is macOS"));
new oe("isLinux", os, p("isLinux", "Whether the operating system is Linux"));
const sL = new oe("isWindows", Ks, p("isWindows", "Whether the operating system is Windows")), Jz = new oe("isWeb", Gu, p("isWeb", "Whether the platform is a web browser"));
new oe("isMacNative", Je && !Gu, p("isMacNative", "Whether the operating system is macOS on a non-browser platform"));
new oe("isIOS", Zr, p("isIOS", "Whether the operating system is iOS"));
new oe("isMobile", qB, p("isMobile", "Whether the platform is a mobile web browser"));
new oe("isDevelopment", !1, !0);
new oe("productQualityType", "", p("productQualityType", "Quality type of VS Code"));
const e3 = "inputFocus", t3 = new oe(e3, !1, p("inputFocus", "Whether keyboard focus is inside an input box"));
var Ld = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Ut = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
const Ko = et("listService");
class Nse {
  get lastFocusedList() {
    return this._lastFocusedWidget;
  }
  constructor() {
    this.disposables = new q(), this.lists = [], this._lastFocusedWidget = void 0, this._hasCreatedStyleController = !1;
  }
  setLastFocusedList(e) {
    var t, i;
    e !== this._lastFocusedWidget && ((t = this._lastFocusedWidget) === null || t === void 0 || t.getHTMLElement().classList.remove("last-focused"), this._lastFocusedWidget = e, (i = this._lastFocusedWidget) === null || i === void 0 || i.getHTMLElement().classList.add("last-focused"));
  }
  register(e, t) {
    if (this._hasCreatedStyleController || (this._hasCreatedStyleController = !0, new Ez(fo(), "").style(ng)), this.lists.some((n) => n.widget === e))
      throw new Error("Cannot register the same widget multiple times");
    const i = { widget: e, extraContextKeys: t };
    return this.lists.push(i), a0(e.getHTMLElement()) && this.setLastFocusedList(e), Ur(e.onDidFocus(() => this.setLastFocusedList(e)), Se(() => this.lists.splice(this.lists.indexOf(i), 1)), e.onDidDispose(() => {
      this.lists = this.lists.filter((n) => n !== i), this._lastFocusedWidget === e && this.setLastFocusedList(void 0);
    }));
  }
  dispose() {
    this.disposables.dispose();
  }
}
const mv = new oe("listScrollAtBoundary", "none");
U.or(mv.isEqualTo("top"), mv.isEqualTo("both"));
U.or(mv.isEqualTo("bottom"), mv.isEqualTo("both"));
const i3 = new oe("listFocus", !0), n3 = new oe("treestickyScrollFocused", !1), oL = new oe("listSupportsMultiselect", !0), s3 = U.and(i3, U.not(e3), n3.negate()), IM = new oe("listHasSelectionOrFocus", !1), EM = new oe("listDoubleSelection", !1), TM = new oe("listMultiSelection", !1), rL = new oe("listSelectionNavigation", !1), Mse = new oe("listSupportsFind", !0), NM = new oe("treeElementCanCollapse", !1), Rse = new oe("treeElementHasParent", !1), MM = new oe("treeElementCanExpand", !1), Ase = new oe("treeElementHasChild", !1), Pse = new oe("treeFindOpen", !1), o3 = "listTypeNavigationMode", r3 = "listAutomaticKeyboardNavigation";
function aL(r, e) {
  const t = r.createScoped(e.getHTMLElement());
  return i3.bindTo(t), t;
}
function lL(r, e) {
  const t = mv.bindTo(r), i = () => {
    const n = e.scrollTop === 0, s = e.scrollHeight - e.renderHeight - e.scrollTop < 1;
    n && s ? t.set("both") : n ? t.set("top") : s ? t.set("bottom") : t.set("none");
  };
  return i(), e.onDidScroll(i);
}
const rg = "workbench.list.multiSelectModifier", Kw = "workbench.list.openMode", Po = "workbench.list.horizontalScrolling", RM = "workbench.list.defaultFindMode", AM = "workbench.list.typeNavigationMode", ry = "workbench.list.keyboardNavigation", ia = "workbench.list.scrollByPage", PM = "workbench.list.defaultFindMatchType", _v = "workbench.tree.indent", ay = "workbench.tree.renderIndentGuides", na = "workbench.list.smoothScrolling", sl = "workbench.list.mouseWheelScrollSensitivity", ol = "workbench.list.fastScrollSensitivity", ly = "workbench.tree.expandMode", dy = "workbench.tree.enableStickyScroll", cy = "workbench.tree.stickyScrollMaxItemCount";
function rl(r) {
  return r.getValue(rg) === "alt";
}
class Ose extends P {
  constructor(e) {
    super(), this.configurationService = e, this.useAltAsMultipleSelectionModifier = rl(e), this.registerListeners();
  }
  registerListeners() {
    this._register(this.configurationService.onDidChangeConfiguration((e) => {
      e.affectsConfiguration(rg) && (this.useAltAsMultipleSelectionModifier = rl(this.configurationService));
    }));
  }
  isSelectionSingleChangeEvent(e) {
    return this.useAltAsMultipleSelectionModifier ? e.browserEvent.altKey : kz(e);
  }
  isSelectionRangeChangeEvent(e) {
    return xz(e);
  }
}
function dL(r, e) {
  var t;
  const i = r.get(Ge), n = r.get(_t), s = new q();
  return [{
    ...e,
    keyboardNavigationDelegate: { mightProducePrintableCharacter(a) {
      return n.mightProducePrintableCharacter(a);
    } },
    smoothScrolling: !!i.getValue(na),
    mouseWheelScrollSensitivity: i.getValue(sl),
    fastScrollSensitivity: i.getValue(ol),
    multipleSelectionController: (t = e.multipleSelectionController) !== null && t !== void 0 ? t : s.add(new Ose(i)),
    keyboardNavigationEventFilter: Bse(n),
    scrollByPage: !!i.getValue(ia)
  }, s];
}
let _F = class extends Co {
  constructor(e, t, i, n, s, o, a, l, d) {
    const c = typeof s.horizontalScrolling < "u" ? s.horizontalScrolling : !!l.getValue(Po), [h, u] = d.invokeFunction(dL, s);
    super(e, t, i, n, {
      keyboardSupport: !1,
      ...h,
      horizontalScrolling: c
    }), this.disposables.add(u), this.contextKeyService = aL(o, this), this.disposables.add(lL(this.contextKeyService, this)), this.listSupportsMultiSelect = oL.bindTo(this.contextKeyService), this.listSupportsMultiSelect.set(s.multipleSelectionSupport !== !1), rL.bindTo(this.contextKeyService).set(!!s.selectionNavigation), this.listHasSelectionOrFocus = IM.bindTo(this.contextKeyService), this.listDoubleSelection = EM.bindTo(this.contextKeyService), this.listMultiSelection = TM.bindTo(this.contextKeyService), this.horizontalScrolling = s.horizontalScrolling, this._useAltAsMultipleSelectionModifier = rl(l), this.disposables.add(this.contextKeyService), this.disposables.add(a.register(this)), this.updateStyles(s.overrideStyles), this.disposables.add(this.onDidChangeSelection(() => {
      const f = this.getSelection(), m = this.getFocus();
      this.contextKeyService.bufferChangeEvents(() => {
        this.listHasSelectionOrFocus.set(f.length > 0 || m.length > 0), this.listMultiSelection.set(f.length > 1), this.listDoubleSelection.set(f.length === 2);
      });
    })), this.disposables.add(this.onDidChangeFocus(() => {
      const f = this.getSelection(), m = this.getFocus();
      this.listHasSelectionOrFocus.set(f.length > 0 || m.length > 0);
    })), this.disposables.add(l.onDidChangeConfiguration((f) => {
      f.affectsConfiguration(rg) && (this._useAltAsMultipleSelectionModifier = rl(l));
      let m = {};
      if (f.affectsConfiguration(Po) && this.horizontalScrolling === void 0) {
        const _ = !!l.getValue(Po);
        m = { ...m, horizontalScrolling: _ };
      }
      if (f.affectsConfiguration(ia)) {
        const _ = !!l.getValue(ia);
        m = { ...m, scrollByPage: _ };
      }
      if (f.affectsConfiguration(na)) {
        const _ = !!l.getValue(na);
        m = { ...m, smoothScrolling: _ };
      }
      if (f.affectsConfiguration(sl)) {
        const _ = l.getValue(sl);
        m = { ...m, mouseWheelScrollSensitivity: _ };
      }
      if (f.affectsConfiguration(ol)) {
        const _ = l.getValue(ol);
        m = { ...m, fastScrollSensitivity: _ };
      }
      Object.keys(m).length > 0 && this.updateOptions(m);
    })), this.navigator = new a3(this, { configurationService: l, ...s }), this.disposables.add(this.navigator);
  }
  updateOptions(e) {
    super.updateOptions(e), e.overrideStyles !== void 0 && this.updateStyles(e.overrideStyles), e.multipleSelectionSupport !== void 0 && this.listSupportsMultiSelect.set(!!e.multipleSelectionSupport);
  }
  updateStyles(e) {
    this.style(e ? sg(e) : ng);
  }
};
_F = Ld([
  Ut(5, De),
  Ut(6, Ko),
  Ut(7, Ge),
  Ut(8, be)
], _F);
let vF = class extends Vne {
  constructor(e, t, i, n, s, o, a, l, d) {
    const c = typeof s.horizontalScrolling < "u" ? s.horizontalScrolling : !!l.getValue(Po), [h, u] = d.invokeFunction(dL, s);
    super(e, t, i, n, {
      keyboardSupport: !1,
      ...h,
      horizontalScrolling: c
    }), this.disposables = new q(), this.disposables.add(u), this.contextKeyService = aL(o, this), this.disposables.add(lL(this.contextKeyService, this.widget)), this.horizontalScrolling = s.horizontalScrolling, this.listSupportsMultiSelect = oL.bindTo(this.contextKeyService), this.listSupportsMultiSelect.set(s.multipleSelectionSupport !== !1), rL.bindTo(this.contextKeyService).set(!!s.selectionNavigation), this._useAltAsMultipleSelectionModifier = rl(l), this.disposables.add(this.contextKeyService), this.disposables.add(a.register(this)), this.updateStyles(s.overrideStyles), this.disposables.add(l.onDidChangeConfiguration((f) => {
      f.affectsConfiguration(rg) && (this._useAltAsMultipleSelectionModifier = rl(l));
      let m = {};
      if (f.affectsConfiguration(Po) && this.horizontalScrolling === void 0) {
        const _ = !!l.getValue(Po);
        m = { ...m, horizontalScrolling: _ };
      }
      if (f.affectsConfiguration(ia)) {
        const _ = !!l.getValue(ia);
        m = { ...m, scrollByPage: _ };
      }
      if (f.affectsConfiguration(na)) {
        const _ = !!l.getValue(na);
        m = { ...m, smoothScrolling: _ };
      }
      if (f.affectsConfiguration(sl)) {
        const _ = l.getValue(sl);
        m = { ...m, mouseWheelScrollSensitivity: _ };
      }
      if (f.affectsConfiguration(ol)) {
        const _ = l.getValue(ol);
        m = { ...m, fastScrollSensitivity: _ };
      }
      Object.keys(m).length > 0 && this.updateOptions(m);
    })), this.navigator = new a3(this, { configurationService: l, ...s }), this.disposables.add(this.navigator);
  }
  updateOptions(e) {
    super.updateOptions(e), e.overrideStyles !== void 0 && this.updateStyles(e.overrideStyles), e.multipleSelectionSupport !== void 0 && this.listSupportsMultiSelect.set(!!e.multipleSelectionSupport);
  }
  updateStyles(e) {
    this.style(e ? sg(e) : ng);
  }
  dispose() {
    this.disposables.dispose(), super.dispose();
  }
};
vF = Ld([
  Ut(5, De),
  Ut(6, Ko),
  Ut(7, Ge),
  Ut(8, be)
], vF);
let bF = class extends nL {
  constructor(e, t, i, n, s, o, a, l, d, c) {
    const h = typeof o.horizontalScrolling < "u" ? o.horizontalScrolling : !!d.getValue(Po), [u, g] = c.invokeFunction(dL, o);
    super(e, t, i, n, s, {
      keyboardSupport: !1,
      ...u,
      horizontalScrolling: h
    }), this.disposables.add(g), this.contextKeyService = aL(a, this), this.disposables.add(lL(this.contextKeyService, this)), this.listSupportsMultiSelect = oL.bindTo(this.contextKeyService), this.listSupportsMultiSelect.set(o.multipleSelectionSupport !== !1), rL.bindTo(this.contextKeyService).set(!!o.selectionNavigation), this.listHasSelectionOrFocus = IM.bindTo(this.contextKeyService), this.listDoubleSelection = EM.bindTo(this.contextKeyService), this.listMultiSelection = TM.bindTo(this.contextKeyService), this.horizontalScrolling = o.horizontalScrolling, this._useAltAsMultipleSelectionModifier = rl(d), this.disposables.add(this.contextKeyService), this.disposables.add(l.register(this)), this.updateStyles(o.overrideStyles), this.disposables.add(this.onDidChangeSelection(() => {
      const m = this.getSelection(), _ = this.getFocus();
      this.contextKeyService.bufferChangeEvents(() => {
        this.listHasSelectionOrFocus.set(m.length > 0 || _.length > 0), this.listMultiSelection.set(m.length > 1), this.listDoubleSelection.set(m.length === 2);
      });
    })), this.disposables.add(this.onDidChangeFocus(() => {
      const m = this.getSelection(), _ = this.getFocus();
      this.listHasSelectionOrFocus.set(m.length > 0 || _.length > 0);
    })), this.disposables.add(d.onDidChangeConfiguration((m) => {
      m.affectsConfiguration(rg) && (this._useAltAsMultipleSelectionModifier = rl(d));
      let _ = {};
      if (m.affectsConfiguration(Po) && this.horizontalScrolling === void 0) {
        const v = !!d.getValue(Po);
        _ = { ..._, horizontalScrolling: v };
      }
      if (m.affectsConfiguration(ia)) {
        const v = !!d.getValue(ia);
        _ = { ..._, scrollByPage: v };
      }
      if (m.affectsConfiguration(na)) {
        const v = !!d.getValue(na);
        _ = { ..._, smoothScrolling: v };
      }
      if (m.affectsConfiguration(sl)) {
        const v = d.getValue(sl);
        _ = { ..._, mouseWheelScrollSensitivity: v };
      }
      if (m.affectsConfiguration(ol)) {
        const v = d.getValue(ol);
        _ = { ..._, fastScrollSensitivity: v };
      }
      Object.keys(_).length > 0 && this.updateOptions(_);
    })), this.navigator = new Fse(this, { configurationService: d, ...o }), this.disposables.add(this.navigator);
  }
  updateOptions(e) {
    super.updateOptions(e), e.overrideStyles !== void 0 && this.updateStyles(e.overrideStyles), e.multipleSelectionSupport !== void 0 && this.listSupportsMultiSelect.set(!!e.multipleSelectionSupport);
  }
  updateStyles(e) {
    this.style(e ? sg(e) : ng);
  }
  dispose() {
    this.disposables.dispose(), super.dispose();
  }
};
bF = Ld([
  Ut(6, De),
  Ut(7, Ko),
  Ut(8, Ge),
  Ut(9, be)
], bF);
class OM extends P {
  constructor(e, t) {
    var i;
    super(), this.widget = e, this._onDidOpen = this._register(new R()), this.onDidOpen = this._onDidOpen.event, this._register(ne.filter(this.widget.onDidChangeSelection, (n) => $d(n.browserEvent))((n) => this.onSelectionFromKeyboard(n))), this._register(this.widget.onPointer((n) => this.onPointer(n.element, n.browserEvent))), this._register(this.widget.onMouseDblClick((n) => this.onMouseDblClick(n.element, n.browserEvent))), typeof (t == null ? void 0 : t.openOnSingleClick) != "boolean" && (t != null && t.configurationService) ? (this.openOnSingleClick = (t == null ? void 0 : t.configurationService.getValue(Kw)) !== "doubleClick", this._register(t == null ? void 0 : t.configurationService.onDidChangeConfiguration((n) => {
      n.affectsConfiguration(Kw) && (this.openOnSingleClick = (t == null ? void 0 : t.configurationService.getValue(Kw)) !== "doubleClick");
    }))) : this.openOnSingleClick = (i = t == null ? void 0 : t.openOnSingleClick) !== null && i !== void 0 ? i : !0;
  }
  onSelectionFromKeyboard(e) {
    if (e.elements.length !== 1)
      return;
    const t = e.browserEvent, i = typeof t.preserveFocus == "boolean" ? t.preserveFocus : !0, n = typeof t.pinned == "boolean" ? t.pinned : !i;
    this._open(this.getSelectedElement(), i, n, !1, e.browserEvent);
  }
  onPointer(e, t) {
    if (!this.openOnSingleClick || t.detail === 2)
      return;
    const n = t.button === 1, s = !0, o = n, a = t.ctrlKey || t.metaKey || t.altKey;
    this._open(e, s, o, a, t);
  }
  onMouseDblClick(e, t) {
    if (!t)
      return;
    const i = t.target;
    if (i.classList.contains("monaco-tl-twistie") || i.classList.contains("monaco-icon-label") && i.classList.contains("folder-icon") && t.offsetX < 16)
      return;
    const s = !1, o = !0, a = t.ctrlKey || t.metaKey || t.altKey;
    this._open(e, s, o, a, t);
  }
  _open(e, t, i, n, s) {
    e && this._onDidOpen.fire({
      editorOptions: {
        preserveFocus: t,
        pinned: i,
        revealIfVisible: !0
      },
      sideBySide: n,
      element: e,
      browserEvent: s
    });
  }
}
class a3 extends OM {
  constructor(e, t) {
    super(e, t), this.widget = e;
  }
  getSelectedElement() {
    return this.widget.getSelectedElements()[0];
  }
}
class Fse extends OM {
  constructor(e, t) {
    super(e, t);
  }
  getSelectedElement() {
    return this.widget.getSelectedElements()[0];
  }
}
class Wse extends OM {
  constructor(e, t) {
    super(e, t);
  }
  getSelectedElement() {
    var e;
    return (e = this.widget.getSelection()[0]) !== null && e !== void 0 ? e : void 0;
  }
}
function Bse(r) {
  let e = !1;
  return (t) => {
    if (t.toKeyCodeChord().isModifierKey())
      return !1;
    if (e)
      return e = !1, !1;
    const i = r.softDispatch(t, t.target);
    return i.kind === 1 ? (e = !0, !1) : (e = !1, i.kind === 0);
  };
}
let uE = class extends DM {
  constructor(e, t, i, n, s, o, a, l, d) {
    const { options: c, getTypeNavigationMode: h, disposable: u } = o.invokeFunction(Nb, s);
    super(e, t, i, n, c), this.disposables.add(u), this.internals = new Eu(this, s, h, s.overrideStyles, a, l, d), this.disposables.add(this.internals);
  }
  updateOptions(e) {
    super.updateOptions(e), this.internals.updateOptions(e);
  }
};
uE = Ld([
  Ut(5, be),
  Ut(6, De),
  Ut(7, Ko),
  Ut(8, Ge)
], uE);
let CF = class extends Yz {
  constructor(e, t, i, n, s, o, a, l, d) {
    const { options: c, getTypeNavigationMode: h, disposable: u } = o.invokeFunction(Nb, s);
    super(e, t, i, n, c), this.disposables.add(u), this.internals = new Eu(this, s, h, s.overrideStyles, a, l, d), this.disposables.add(this.internals);
  }
  updateOptions(e = {}) {
    super.updateOptions(e), e.overrideStyles && this.internals.updateStyleOverrides(e.overrideStyles), this.internals.updateOptions(e);
  }
};
CF = Ld([
  Ut(5, be),
  Ut(6, De),
  Ut(7, Ko),
  Ut(8, Ge)
], CF);
let wF = class extends Tse {
  constructor(e, t, i, n, s, o, a, l, d, c) {
    const { options: h, getTypeNavigationMode: u, disposable: g } = a.invokeFunction(Nb, o);
    super(e, t, i, n, s, h), this.disposables.add(g), this.internals = new Eu(this, o, u, o.overrideStyles, l, d, c), this.disposables.add(this.internals);
  }
  updateOptions(e = {}) {
    super.updateOptions(e), e.overrideStyles !== void 0 && this.internals.updateStyleOverrides(e.overrideStyles), this.internals.updateOptions(e);
  }
};
wF = Ld([
  Ut(6, be),
  Ut(7, De),
  Ut(8, Ko),
  Ut(9, Ge)
], wF);
let gE = class extends Xz {
  get onDidOpen() {
    return this.internals.onDidOpen;
  }
  constructor(e, t, i, n, s, o, a, l, d, c) {
    const { options: h, getTypeNavigationMode: u, disposable: g } = a.invokeFunction(Nb, o);
    super(e, t, i, n, s, h), this.disposables.add(g), this.internals = new Eu(this, o, u, o.overrideStyles, l, d, c), this.disposables.add(this.internals);
  }
  updateOptions(e = {}) {
    super.updateOptions(e), e.overrideStyles && this.internals.updateStyleOverrides(e.overrideStyles), this.internals.updateOptions(e);
  }
};
gE = Ld([
  Ut(6, be),
  Ut(7, De),
  Ut(8, Ko),
  Ut(9, Ge)
], gE);
let SF = class extends Ise {
  constructor(e, t, i, n, s, o, a, l, d, c, h) {
    const { options: u, getTypeNavigationMode: g, disposable: f } = l.invokeFunction(Nb, a);
    super(e, t, i, n, s, o, u), this.disposables.add(f), this.internals = new Eu(this, a, g, a.overrideStyles, d, c, h), this.disposables.add(this.internals);
  }
  updateOptions(e) {
    super.updateOptions(e), this.internals.updateOptions(e);
  }
};
SF = Ld([
  Ut(7, be),
  Ut(8, De),
  Ut(9, Ko),
  Ut(10, Ge)
], SF);
function l3(r) {
  const e = r.getValue(RM);
  if (e === "highlight")
    return Jl.Highlight;
  if (e === "filter")
    return Jl.Filter;
  const t = r.getValue(ry);
  if (t === "simple" || t === "highlight")
    return Jl.Highlight;
  if (t === "filter")
    return Jl.Filter;
}
function d3(r) {
  const e = r.getValue(PM);
  if (e === "fuzzy")
    return Iu.Fuzzy;
  if (e === "contiguous")
    return Iu.Contiguous;
}
function Nb(r, e) {
  var t;
  const i = r.get(Ge), n = r.get(Sd), s = r.get(De), o = r.get(be), a = () => {
    const g = s.getContextKeyValue(o3);
    if (g === "automatic")
      return Oa.Automatic;
    if (g === "trigger" || s.getContextKeyValue(r3) === !1)
      return Oa.Trigger;
    const m = i.getValue(AM);
    if (m === "automatic")
      return Oa.Automatic;
    if (m === "trigger")
      return Oa.Trigger;
  }, l = e.horizontalScrolling !== void 0 ? e.horizontalScrolling : !!i.getValue(Po), [d, c] = o.invokeFunction(dL, e), h = e.paddingBottom, u = e.renderIndentGuides !== void 0 ? e.renderIndentGuides : i.getValue(ay);
  return {
    getTypeNavigationMode: a,
    disposable: c,
    options: {
      // ...options, // TODO@Joao why is this not splatted here?
      keyboardSupport: !1,
      ...d,
      indent: typeof i.getValue(_v) == "number" ? i.getValue(_v) : void 0,
      renderIndentGuides: u,
      smoothScrolling: !!i.getValue(na),
      defaultFindMode: l3(i),
      defaultFindMatchType: d3(i),
      horizontalScrolling: l,
      scrollByPage: !!i.getValue(ia),
      paddingBottom: h,
      hideTwistiesOfChildlessElements: e.hideTwistiesOfChildlessElements,
      expandOnlyOnTwistieClick: (t = e.expandOnlyOnTwistieClick) !== null && t !== void 0 ? t : i.getValue(ly) === "doubleClick",
      contextViewProvider: n,
      findWidgetStyles: Qie,
      enableStickyScroll: !!i.getValue(dy),
      stickyScrollMaxItemCount: Number(i.getValue(cy))
    }
  };
}
let Eu = class {
  get onDidOpen() {
    return this.navigator.onDidOpen;
  }
  constructor(e, t, i, n, s, o, a) {
    var l;
    this.tree = e, this.disposables = [], this.contextKeyService = aL(s, e), this.disposables.push(lL(this.contextKeyService, e)), this.listSupportsMultiSelect = oL.bindTo(this.contextKeyService), this.listSupportsMultiSelect.set(t.multipleSelectionSupport !== !1), rL.bindTo(this.contextKeyService).set(!!t.selectionNavigation), this.listSupportFindWidget = Mse.bindTo(this.contextKeyService), this.listSupportFindWidget.set((l = t.findWidgetEnabled) !== null && l !== void 0 ? l : !0), this.hasSelectionOrFocus = IM.bindTo(this.contextKeyService), this.hasDoubleSelection = EM.bindTo(this.contextKeyService), this.hasMultiSelection = TM.bindTo(this.contextKeyService), this.treeElementCanCollapse = NM.bindTo(this.contextKeyService), this.treeElementHasParent = Rse.bindTo(this.contextKeyService), this.treeElementCanExpand = MM.bindTo(this.contextKeyService), this.treeElementHasChild = Ase.bindTo(this.contextKeyService), this.treeFindOpen = Pse.bindTo(this.contextKeyService), this.treeStickyScrollFocused = n3.bindTo(this.contextKeyService), this._useAltAsMultipleSelectionModifier = rl(a), this.updateStyleOverrides(n);
    const c = () => {
      const u = e.getFocus()[0];
      if (!u)
        return;
      const g = e.getNode(u);
      this.treeElementCanCollapse.set(g.collapsible && !g.collapsed), this.treeElementHasParent.set(!!e.getParentElement(u)), this.treeElementCanExpand.set(g.collapsible && g.collapsed), this.treeElementHasChild.set(!!e.getFirstElementChild(u));
    }, h = /* @__PURE__ */ new Set();
    h.add(o3), h.add(r3), this.disposables.push(this.contextKeyService, o.register(e), e.onDidChangeSelection(() => {
      const u = e.getSelection(), g = e.getFocus();
      this.contextKeyService.bufferChangeEvents(() => {
        this.hasSelectionOrFocus.set(u.length > 0 || g.length > 0), this.hasMultiSelection.set(u.length > 1), this.hasDoubleSelection.set(u.length === 2);
      });
    }), e.onDidChangeFocus(() => {
      const u = e.getSelection(), g = e.getFocus();
      this.hasSelectionOrFocus.set(u.length > 0 || g.length > 0), c();
    }), e.onDidChangeCollapseState(c), e.onDidChangeModel(c), e.onDidChangeFindOpenState((u) => this.treeFindOpen.set(u)), e.onDidChangeStickyScrollFocused((u) => this.treeStickyScrollFocused.set(u)), a.onDidChangeConfiguration((u) => {
      let g = {};
      if (u.affectsConfiguration(rg) && (this._useAltAsMultipleSelectionModifier = rl(a)), u.affectsConfiguration(_v)) {
        const f = a.getValue(_v);
        g = { ...g, indent: f };
      }
      if (u.affectsConfiguration(ay) && t.renderIndentGuides === void 0) {
        const f = a.getValue(ay);
        g = { ...g, renderIndentGuides: f };
      }
      if (u.affectsConfiguration(na)) {
        const f = !!a.getValue(na);
        g = { ...g, smoothScrolling: f };
      }
      if (u.affectsConfiguration(RM) || u.affectsConfiguration(ry)) {
        const f = l3(a);
        g = { ...g, defaultFindMode: f };
      }
      if (u.affectsConfiguration(AM) || u.affectsConfiguration(ry)) {
        const f = i();
        g = { ...g, typeNavigationMode: f };
      }
      if (u.affectsConfiguration(PM)) {
        const f = d3(a);
        g = { ...g, defaultFindMatchType: f };
      }
      if (u.affectsConfiguration(Po) && t.horizontalScrolling === void 0) {
        const f = !!a.getValue(Po);
        g = { ...g, horizontalScrolling: f };
      }
      if (u.affectsConfiguration(ia)) {
        const f = !!a.getValue(ia);
        g = { ...g, scrollByPage: f };
      }
      if (u.affectsConfiguration(ly) && t.expandOnlyOnTwistieClick === void 0 && (g = { ...g, expandOnlyOnTwistieClick: a.getValue(ly) === "doubleClick" }), u.affectsConfiguration(dy)) {
        const f = a.getValue(dy);
        g = { ...g, enableStickyScroll: f };
      }
      if (u.affectsConfiguration(cy)) {
        const f = Math.max(1, a.getValue(cy));
        g = { ...g, stickyScrollMaxItemCount: f };
      }
      if (u.affectsConfiguration(sl)) {
        const f = a.getValue(sl);
        g = { ...g, mouseWheelScrollSensitivity: f };
      }
      if (u.affectsConfiguration(ol)) {
        const f = a.getValue(ol);
        g = { ...g, fastScrollSensitivity: f };
      }
      Object.keys(g).length > 0 && e.updateOptions(g);
    }), this.contextKeyService.onDidChangeContext((u) => {
      u.affectsSome(h) && e.updateOptions({ typeNavigationMode: i() });
    })), this.navigator = new Wse(e, { configurationService: a, ...t }), this.disposables.push(this.navigator);
  }
  updateOptions(e) {
    e.multipleSelectionSupport !== void 0 && this.listSupportsMultiSelect.set(!!e.multipleSelectionSupport);
  }
  updateStyleOverrides(e) {
    this.tree.style(e ? sg(e) : ng);
  }
  dispose() {
    this.disposables = zt(this.disposables);
  }
};
Eu = Ld([
  Ut(4, De),
  Ut(5, Ko),
  Ut(6, Ge)
], Eu);
const Hse = si.as(aa.Configuration);
Hse.registerConfiguration({
  id: "workbench",
  order: 7,
  title: p("workbenchConfigurationTitle", "Workbench"),
  type: "object",
  properties: {
    [rg]: {
      type: "string",
      enum: ["ctrlCmd", "alt"],
      markdownEnumDescriptions: [
        p("multiSelectModifier.ctrlCmd", "Maps to `Control` on Windows and Linux and to `Command` on macOS."),
        p("multiSelectModifier.alt", "Maps to `Alt` on Windows and Linux and to `Option` on macOS.")
      ],
      default: "ctrlCmd",
      description: p({
        key: "multiSelectModifier",
        comment: [
          "- `ctrlCmd` refers to a value the setting can take and should not be localized.",
          "- `Control` and `Command` refer to the modifier keys Ctrl or Cmd on the keyboard and can be localized."
        ]
      }, "The modifier to be used to add an item in trees and lists to a multi-selection with the mouse (for example in the explorer, open editors and scm view). The 'Open to Side' mouse gestures - if supported - will adapt such that they do not conflict with the multiselect modifier.")
    },
    [Kw]: {
      type: "string",
      enum: ["singleClick", "doubleClick"],
      default: "singleClick",
      description: p({
        key: "openModeModifier",
        comment: ["`singleClick` and `doubleClick` refers to a value the setting can take and should not be localized."]
      }, "Controls how to open items in trees and lists using the mouse (if supported). Note that some trees and lists might choose to ignore this setting if it is not applicable.")
    },
    [Po]: {
      type: "boolean",
      default: !1,
      description: p("horizontalScrolling setting", "Controls whether lists and trees support horizontal scrolling in the workbench. Warning: turning on this setting has a performance implication.")
    },
    [ia]: {
      type: "boolean",
      default: !1,
      description: p("list.scrollByPage", "Controls whether clicks in the scrollbar scroll page by page.")
    },
    [_v]: {
      type: "number",
      default: 8,
      minimum: 4,
      maximum: 40,
      description: p("tree indent setting", "Controls tree indentation in pixels.")
    },
    [ay]: {
      type: "string",
      enum: ["none", "onHover", "always"],
      default: "onHover",
      description: p("render tree indent guides", "Controls whether the tree should render indent guides.")
    },
    [na]: {
      type: "boolean",
      default: !1,
      description: p("list smoothScrolling setting", "Controls whether lists and trees have smooth scrolling.")
    },
    [sl]: {
      type: "number",
      default: 1,
      markdownDescription: p("Mouse Wheel Scroll Sensitivity", "A multiplier to be used on the `deltaX` and `deltaY` of mouse wheel scroll events.")
    },
    [ol]: {
      type: "number",
      default: 5,
      markdownDescription: p("Fast Scroll Sensitivity", "Scrolling speed multiplier when pressing `Alt`.")
    },
    [RM]: {
      type: "string",
      enum: ["highlight", "filter"],
      enumDescriptions: [
        p("defaultFindModeSettingKey.highlight", "Highlight elements when searching. Further up and down navigation will traverse only the highlighted elements."),
        p("defaultFindModeSettingKey.filter", "Filter elements when searching.")
      ],
      default: "highlight",
      description: p("defaultFindModeSettingKey", "Controls the default find mode for lists and trees in the workbench.")
    },
    [ry]: {
      type: "string",
      enum: ["simple", "highlight", "filter"],
      enumDescriptions: [
        p("keyboardNavigationSettingKey.simple", "Simple keyboard navigation focuses elements which match the keyboard input. Matching is done only on prefixes."),
        p("keyboardNavigationSettingKey.highlight", "Highlight keyboard navigation highlights elements which match the keyboard input. Further up and down navigation will traverse only the highlighted elements."),
        p("keyboardNavigationSettingKey.filter", "Filter keyboard navigation will filter out and hide all the elements which do not match the keyboard input.")
      ],
      default: "highlight",
      description: p("keyboardNavigationSettingKey", "Controls the keyboard navigation style for lists and trees in the workbench. Can be simple, highlight and filter."),
      deprecated: !0,
      deprecationMessage: p("keyboardNavigationSettingKeyDeprecated", "Please use 'workbench.list.defaultFindMode' and	'workbench.list.typeNavigationMode' instead.")
    },
    [PM]: {
      type: "string",
      enum: ["fuzzy", "contiguous"],
      enumDescriptions: [
        p("defaultFindMatchTypeSettingKey.fuzzy", "Use fuzzy matching when searching."),
        p("defaultFindMatchTypeSettingKey.contiguous", "Use contiguous matching when searching.")
      ],
      default: "fuzzy",
      description: p("defaultFindMatchTypeSettingKey", "Controls the type of matching used when searching lists and trees in the workbench.")
    },
    [ly]: {
      type: "string",
      enum: ["singleClick", "doubleClick"],
      default: "singleClick",
      description: p("expand mode", "Controls how tree folders are expanded when clicking the folder names. Note that some trees and lists might choose to ignore this setting if it is not applicable.")
    },
    [dy]: {
      type: "boolean",
      default: !0,
      description: p("sticky scroll", "Controls whether sticky scrolling is enabled in trees.")
    },
    [cy]: {
      type: "number",
      minimum: 1,
      default: 7,
      markdownDescription: p("sticky scroll maximum items", "Controls the number of sticky elements displayed in the tree when `#workbench.tree.enableStickyScroll#` is enabled.")
    },
    [AM]: {
      type: "string",
      enum: ["automatic", "trigger"],
      default: "automatic",
      markdownDescription: p("typeNavigationMode2", "Controls how type navigation works in lists and trees in the workbench. When set to `trigger`, type navigation begins once the `list.triggerTypeNavigation` command is run.")
    }
  }
});
class Cc extends P {
  /**
   * Create a new {@link HighlightedLabel}.
   *
   * @param container The parent container to append to.
   */
  constructor(e, t) {
    var i;
    super(), this.options = t, this.text = "", this.title = "", this.highlights = [], this.didEverRender = !1, this.supportIcons = (i = t == null ? void 0 : t.supportIcons) !== null && i !== void 0 ? i : !1, this.domNode = G(e, X("span.monaco-highlighted-label"));
  }
  /**
   * The label's DOM node.
   */
  get element() {
    return this.domNode;
  }
  /**
   * Set the label and highlights.
   *
   * @param text The label to display.
   * @param highlights The ranges to highlight.
   * @param title An optional title for the hover tooltip.
   * @param escapeNewLines Whether to escape new lines.
   * @returns
   */
  set(e, t = [], i = "", n) {
    e || (e = ""), n && (e = Cc.escapeNewLines(e, t)), !(this.didEverRender && this.text === e && this.title === i && Xa(this.highlights, t)) && (this.text = e, this.title = i, this.highlights = t, this.render());
  }
  render() {
    var e, t, i, n;
    const s = [];
    let o = 0;
    for (const a of this.highlights) {
      if (a.end === a.start)
        continue;
      if (o < a.start) {
        const c = this.text.substring(o, a.start);
        this.supportIcons ? s.push(..._c(c)) : s.push(c), o = a.start;
      }
      const l = this.text.substring(o, a.end), d = X("span.highlight", void 0, ...this.supportIcons ? _c(l) : [l]);
      a.extraClasses && d.classList.add(...a.extraClasses), s.push(d), o = a.end;
    }
    if (o < this.text.length) {
      const a = this.text.substring(o);
      this.supportIcons ? s.push(..._c(a)) : s.push(a);
    }
    if (mn(this.domNode, ...s), !((t = (e = this.options) === null || e === void 0 ? void 0 : e.hoverDelegate) === null || t === void 0) && t.showNativeHover)
      this.domNode.title = this.title;
    else if (!this.customHover && this.title !== "") {
      const a = (n = (i = this.options) === null || i === void 0 ? void 0 : i.hoverDelegate) !== null && n !== void 0 ? n : us("mouse");
      this.customHover = this._register(da().setupUpdatableHover(a, this.domNode, this.title));
    } else this.customHover && this.customHover.update(this.title);
    this.didEverRender = !0;
  }
  static escapeNewLines(e, t) {
    let i = 0, n = 0;
    return e.replace(/\r\n|\r|\n/g, (s, o) => {
      n = s === `\r
` ? -1 : 0, o += i;
      for (const a of t)
        a.end <= o || (a.start >= o && (a.start += n), a.end >= o && (a.end += n));
      return i += n, "";
    });
  }
}
class cm {
  constructor(e) {
    this._element = e;
  }
  get element() {
    return this._element;
  }
  set textContent(e) {
    this.disposed || e === this._textContent || (this._textContent = e, this._element.textContent = e);
  }
  set className(e) {
    this.disposed || e === this._className || (this._className = e, this._element.className = e);
  }
  set empty(e) {
    this.disposed || e === this._empty || (this._empty = e, this._element.style.marginLeft = e ? "0" : "");
  }
  dispose() {
    this.disposed = !0;
  }
}
class hy extends P {
  constructor(e, t) {
    var i;
    super(), this.customHovers = /* @__PURE__ */ new Map(), this.creationOptions = t, this.domNode = this._register(new cm(G(e, X(".monaco-icon-label")))), this.labelContainer = G(this.domNode.element, X(".monaco-icon-label-container")), this.nameContainer = G(this.labelContainer, X("span.monaco-icon-name-container")), t != null && t.supportHighlights || t != null && t.supportIcons ? this.nameNode = this._register(new Use(this.nameContainer, !!t.supportIcons)) : this.nameNode = new Vse(this.nameContainer), this.hoverDelegate = (i = t == null ? void 0 : t.hoverDelegate) !== null && i !== void 0 ? i : us("mouse");
  }
  get element() {
    return this.domNode.element;
  }
  setLabel(e, t, i) {
    var n;
    const s = ["monaco-icon-label"], o = ["monaco-icon-label-container"];
    let a = "";
    i && (i.extraClasses && s.push(...i.extraClasses), i.italic && s.push("italic"), i.strikethrough && s.push("strikethrough"), i.disabledCommand && o.push("disabled"), i.title && (typeof i.title == "string" ? a += i.title : a += e));
    const l = this.domNode.element.querySelector(".monaco-icon-label-iconpath");
    if (i != null && i.iconPath) {
      let d;
      !l || !ln(l) ? (d = X(".monaco-icon-label-iconpath"), this.domNode.element.prepend(d)) : d = l, d.style.backgroundImage = hd(i == null ? void 0 : i.iconPath);
    } else l && l.remove();
    if (this.domNode.className = s.join(" "), this.domNode.element.setAttribute("aria-label", a), this.labelContainer.className = o.join(" "), this.setupHover(i != null && i.descriptionTitle ? this.labelContainer : this.element, i == null ? void 0 : i.title), this.nameNode.setLabel(e, i), t || this.descriptionNode) {
      const d = this.getOrCreateDescriptionNode();
      d instanceof Cc ? (d.set(t || "", i ? i.descriptionMatches : void 0, void 0, i == null ? void 0 : i.labelEscapeNewLines), this.setupHover(d.element, i == null ? void 0 : i.descriptionTitle)) : (d.textContent = t && (i != null && i.labelEscapeNewLines) ? Cc.escapeNewLines(t, []) : t || "", this.setupHover(d.element, (i == null ? void 0 : i.descriptionTitle) || ""), d.empty = !t);
    }
    if (i != null && i.suffix || this.suffixNode) {
      const d = this.getOrCreateSuffixNode();
      d.textContent = (n = i == null ? void 0 : i.suffix) !== null && n !== void 0 ? n : "";
    }
  }
  setupHover(e, t) {
    const i = this.customHovers.get(e);
    if (i && (i.dispose(), this.customHovers.delete(e)), !t) {
      e.removeAttribute("title");
      return;
    }
    if (this.hoverDelegate.showNativeHover)
      (function(s, o) {
        Ws(o) ? s.title = cM(o) : o != null && o.markdownNotSupportedFallback ? s.title = o.markdownNotSupportedFallback : s.removeAttribute("title");
      })(e, t);
    else {
      const n = da().setupUpdatableHover(this.hoverDelegate, e, t);
      n && this.customHovers.set(e, n);
    }
  }
  dispose() {
    super.dispose();
    for (const e of this.customHovers.values())
      e.dispose();
    this.customHovers.clear();
  }
  getOrCreateSuffixNode() {
    if (!this.suffixNode) {
      const e = this._register(new cm(X8(this.nameContainer, X("span.monaco-icon-suffix-container"))));
      this.suffixNode = this._register(new cm(G(e.element, X("span.label-suffix"))));
    }
    return this.suffixNode;
  }
  getOrCreateDescriptionNode() {
    var e;
    if (!this.descriptionNode) {
      const t = this._register(new cm(G(this.labelContainer, X("span.monaco-icon-description-container"))));
      !((e = this.creationOptions) === null || e === void 0) && e.supportDescriptionHighlights ? this.descriptionNode = this._register(new Cc(G(t.element, X("span.label-description")), { supportIcons: !!this.creationOptions.supportIcons })) : this.descriptionNode = this._register(new cm(G(t.element, X("span.label-description"))));
    }
    return this.descriptionNode;
  }
}
class Vse {
  constructor(e) {
    this.container = e, this.label = void 0, this.singleLabel = void 0;
  }
  setLabel(e, t) {
    if (!(this.label === e && Xa(this.options, t)))
      if (this.label = e, this.options = t, typeof e == "string")
        this.singleLabel || (this.container.innerText = "", this.container.classList.remove("multiple"), this.singleLabel = G(this.container, X("a.label-name", { id: t == null ? void 0 : t.domId }))), this.singleLabel.textContent = e;
      else {
        this.container.innerText = "", this.container.classList.add("multiple"), this.singleLabel = void 0;
        for (let i = 0; i < e.length; i++) {
          const n = e[i], s = (t == null ? void 0 : t.domId) && `${t == null ? void 0 : t.domId}_${i}`;
          G(this.container, X("a.label-name", { id: s, "data-icon-label-count": e.length, "data-icon-label-index": i, role: "treeitem" }, n)), i < e.length - 1 && G(this.container, X("span.label-separator", void 0, (t == null ? void 0 : t.separator) || "/"));
        }
      }
  }
}
function zse(r, e, t) {
  if (!t)
    return;
  let i = 0;
  return r.map((n) => {
    const s = { start: i, end: i + n.length }, o = t.map((a) => In.intersect(s, a)).filter((a) => !In.isEmpty(a)).map(({ start: a, end: l }) => ({ start: a - i, end: l - i }));
    return i = s.end + e.length, o;
  });
}
class Use extends P {
  constructor(e, t) {
    super(), this.container = e, this.supportIcons = t, this.label = void 0, this.singleLabel = void 0;
  }
  setLabel(e, t) {
    if (!(this.label === e && Xa(this.options, t)))
      if (this.label = e, this.options = t, typeof e == "string")
        this.singleLabel || (this.container.innerText = "", this.container.classList.remove("multiple"), this.singleLabel = this._register(new Cc(G(this.container, X("a.label-name", { id: t == null ? void 0 : t.domId })), { supportIcons: this.supportIcons }))), this.singleLabel.set(e, t == null ? void 0 : t.matches, void 0, t == null ? void 0 : t.labelEscapeNewLines);
      else {
        this.container.innerText = "", this.container.classList.add("multiple"), this.singleLabel = void 0;
        const i = (t == null ? void 0 : t.separator) || "/", n = zse(e, i, t == null ? void 0 : t.matches);
        for (let s = 0; s < e.length; s++) {
          const o = e[s], a = n ? n[s] : void 0, l = (t == null ? void 0 : t.domId) && `${t == null ? void 0 : t.domId}_${s}`, d = X("a.label-name", { id: l, "data-icon-label-count": e.length, "data-icon-label-index": s, role: "treeitem" });
          this._register(new Cc(G(this.container, d), { supportIcons: this.supportIcons })).set(o, a, void 0, t == null ? void 0 : t.labelEscapeNewLines), s < e.length - 1 && G(d, X("span.label-separator", void 0, i));
        }
      }
  }
}
const zC = X, c3 = {
  keybindingLabelBackground: void 0,
  keybindingLabelForeground: void 0,
  keybindingLabelBorder: void 0,
  keybindingLabelBottomBorder: void 0,
  keybindingLabelShadow: void 0
};
class Op extends P {
  constructor(e, t, i) {
    super(), this.os = t, this.keyElements = /* @__PURE__ */ new Set(), this.options = i || /* @__PURE__ */ Object.create(null);
    const n = this.options.keybindingLabelForeground;
    this.domNode = G(e, zC(".monaco-keybinding")), n && (this.domNode.style.color = n), this.hover = this._register(da().setupUpdatableHover(us("mouse"), this.domNode, "")), this.didEverRender = !1, e.appendChild(this.domNode);
  }
  get element() {
    return this.domNode;
  }
  set(e, t) {
    this.didEverRender && this.keybinding === e && Op.areSame(this.matches, t) || (this.keybinding = e, this.matches = t, this.render());
  }
  render() {
    var e;
    if (this.clear(), this.keybinding) {
      const t = this.keybinding.getChords();
      t[0] && this.renderChord(this.domNode, t[0], this.matches ? this.matches.firstPart : null);
      for (let n = 1; n < t.length; n++)
        G(this.domNode, zC("span.monaco-keybinding-key-chord-separator", void 0, " ")), this.renderChord(this.domNode, t[n], this.matches ? this.matches.chordPart : null);
      const i = (e = this.options.disableTitle) !== null && e !== void 0 && e ? void 0 : this.keybinding.getAriaLabel() || void 0;
      this.hover.update(i), this.domNode.setAttribute("aria-label", i || "");
    } else this.options && this.options.renderUnboundKeybindings && this.renderUnbound(this.domNode);
    this.didEverRender = !0;
  }
  clear() {
    pn(this.domNode), this.keyElements.clear();
  }
  renderChord(e, t, i) {
    const n = fM.modifierLabels[this.os];
    t.ctrlKey && this.renderKey(e, n.ctrlKey, !!(i != null && i.ctrlKey), n.separator), t.shiftKey && this.renderKey(e, n.shiftKey, !!(i != null && i.shiftKey), n.separator), t.altKey && this.renderKey(e, n.altKey, !!(i != null && i.altKey), n.separator), t.metaKey && this.renderKey(e, n.metaKey, !!(i != null && i.metaKey), n.separator);
    const s = t.keyLabel;
    s && this.renderKey(e, s, !!(i != null && i.keyCode), "");
  }
  renderKey(e, t, i, n) {
    G(e, this.createKeyElement(t, i ? ".highlight" : "")), n && G(e, zC("span.monaco-keybinding-key-separator", void 0, n));
  }
  renderUnbound(e) {
    G(e, this.createKeyElement(p("unbound", "Unbound")));
  }
  createKeyElement(e, t = "") {
    const i = zC("span.monaco-keybinding-key" + t, void 0, e);
    return this.keyElements.add(i), this.options.keybindingLabelBackground && (i.style.backgroundColor = this.options.keybindingLabelBackground), this.options.keybindingLabelBorder && (i.style.borderColor = this.options.keybindingLabelBorder), this.options.keybindingLabelBottomBorder && (i.style.borderBottomColor = this.options.keybindingLabelBottomBorder), this.options.keybindingLabelShadow && (i.style.boxShadow = `inset 0 -1px 0 ${this.options.keybindingLabelShadow}`), i;
  }
  static areSame(e, t) {
    return e === t || !e && !t ? !0 : !!e && !!t && Xa(e.firstPart, t.firstPart) && Xa(e.chordPart, t.chordPart);
  }
}
const yF = new bd(() => {
  const r = new Intl.Collator(void 0, { numeric: !0, sensitivity: "base" });
  return {
    collator: r,
    collatorIsNumeric: r.resolvedOptions().numeric
  };
});
function $se(r, e, t = !1) {
  const i = r || "", n = e || "", s = yF.value.collator.compare(i, n);
  return yF.value.collatorIsNumeric && s === 0 && i !== n ? i < n ? -1 : 1 : s;
}
function Kse(r, e, t) {
  const i = r.toLowerCase(), n = e.toLowerCase(), s = jse(r, e, t);
  if (s)
    return s;
  const o = i.endsWith(t), a = n.endsWith(t);
  if (o !== a)
    return o ? -1 : 1;
  const l = $se(i, n);
  return l !== 0 ? l : i.localeCompare(n);
}
function jse(r, e, t) {
  const i = r.toLowerCase(), n = e.toLowerCase(), s = i.startsWith(t), o = n.startsWith(t);
  if (s !== o)
    return s ? -1 : 1;
  if (s && o) {
    if (i.length < n.length)
      return -1;
    if (i.length > n.length)
      return 1;
  }
  return 0;
}
var cL = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, fE = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, pE;
const Dr = X;
class h3 {
  constructor(e, t, i) {
    this.index = e, this.hasCheckbox = t, this._hidden = !1, this._init = new bd(() => {
      var n;
      const s = (n = i.label) !== null && n !== void 0 ? n : "", o = Wm(s).text.trim(), a = i.ariaLabel || [s, this.saneDescription, this.saneDetail].map((l) => Cee(l)).filter((l) => !!l).join(", ");
      return {
        saneLabel: s,
        saneSortLabel: o,
        saneAriaLabel: a
      };
    }), this._saneDescription = i.description, this._saneTooltip = i.tooltip;
  }
  // #region Lazy Getters
  get saneLabel() {
    return this._init.value.saneLabel;
  }
  get saneSortLabel() {
    return this._init.value.saneSortLabel;
  }
  get saneAriaLabel() {
    return this._init.value.saneAriaLabel;
  }
  get element() {
    return this._element;
  }
  set element(e) {
    this._element = e;
  }
  get hidden() {
    return this._hidden;
  }
  set hidden(e) {
    this._hidden = e;
  }
  get saneDescription() {
    return this._saneDescription;
  }
  set saneDescription(e) {
    this._saneDescription = e;
  }
  get saneDetail() {
    return this._saneDetail;
  }
  set saneDetail(e) {
    this._saneDetail = e;
  }
  get saneTooltip() {
    return this._saneTooltip;
  }
  set saneTooltip(e) {
    this._saneTooltip = e;
  }
  get labelHighlights() {
    return this._labelHighlights;
  }
  set labelHighlights(e) {
    this._labelHighlights = e;
  }
  get descriptionHighlights() {
    return this._descriptionHighlights;
  }
  set descriptionHighlights(e) {
    this._descriptionHighlights = e;
  }
  get detailHighlights() {
    return this._detailHighlights;
  }
  set detailHighlights(e) {
    this._detailHighlights = e;
  }
}
class Bn extends h3 {
  constructor(e, t, i, n, s, o) {
    var a, l, d;
    super(e, t, s), this.fireButtonTriggered = i, this._onChecked = n, this.item = s, this._separator = o, this._checked = !1, this.onChecked = t ? ne.map(ne.filter(this._onChecked.event, (c) => c.element === this), (c) => c.checked) : ne.None, this._saneDetail = s.detail, this._labelHighlights = (a = s.highlights) === null || a === void 0 ? void 0 : a.label, this._descriptionHighlights = (l = s.highlights) === null || l === void 0 ? void 0 : l.description, this._detailHighlights = (d = s.highlights) === null || d === void 0 ? void 0 : d.detail;
  }
  get separator() {
    return this._separator;
  }
  set separator(e) {
    this._separator = e;
  }
  get checked() {
    return this._checked;
  }
  set checked(e) {
    e !== this._checked && (this._checked = e, this._onChecked.fire({ element: this, checked: e }));
  }
  get checkboxDisabled() {
    return !!this.item.disabled;
  }
}
var xa;
(function(r) {
  r[r.NONE = 0] = "NONE", r[r.MOUSE_HOVER = 1] = "MOUSE_HOVER", r[r.ACTIVE_ITEM = 2] = "ACTIVE_ITEM";
})(xa || (xa = {}));
class Fd extends h3 {
  constructor(e, t, i) {
    super(e, !1, i), this.fireSeparatorButtonTriggered = t, this.separator = i, this.children = new Array(), this.focusInsideSeparator = xa.NONE;
  }
}
class qse {
  getHeight(e) {
    return e instanceof Fd ? 30 : e.saneDetail ? 44 : 22;
  }
  getTemplateId(e) {
    return e instanceof Bn ? vv.ID : Mb.ID;
  }
}
class Gse {
  getWidgetAriaLabel() {
    return p("quickInput", "Quick Input");
  }
  getAriaLabel(e) {
    var t;
    return !((t = e.separator) === null || t === void 0) && t.label ? `${e.saneAriaLabel}, ${e.separator.label}` : e.saneAriaLabel;
  }
  getWidgetRole() {
    return "listbox";
  }
  getRole(e) {
    return e.hasCheckbox ? "checkbox" : "option";
  }
  isChecked(e) {
    if (!(!e.hasCheckbox || !(e instanceof Bn)))
      return {
        get value() {
          return e.checked;
        },
        onDidChange: (t) => e.onChecked(() => t())
      };
  }
}
class u3 {
  constructor(e) {
    this.hoverDelegate = e;
  }
  // TODO: only do the common stuff here and have a subclass handle their specific stuff
  renderTemplate(e) {
    const t = /* @__PURE__ */ Object.create(null);
    t.toDisposeElement = new q(), t.toDisposeTemplate = new q(), t.entry = G(e, Dr(".quick-input-list-entry"));
    const i = G(t.entry, Dr("label.quick-input-list-label"));
    t.toDisposeTemplate.add(pi(i, Q.CLICK, (d) => {
      t.checkbox.offsetParent || d.preventDefault();
    })), t.checkbox = G(i, Dr("input.quick-input-list-checkbox")), t.checkbox.type = "checkbox";
    const n = G(i, Dr(".quick-input-list-rows")), s = G(n, Dr(".quick-input-list-row")), o = G(n, Dr(".quick-input-list-row"));
    t.label = new hy(s, { supportHighlights: !0, supportDescriptionHighlights: !0, supportIcons: !0, hoverDelegate: this.hoverDelegate }), t.toDisposeTemplate.add(t.label), t.icon = r1(t.label.element, Dr(".quick-input-list-icon"));
    const a = G(s, Dr(".quick-input-list-entry-keybinding"));
    t.keybinding = new Op(a, Os), t.toDisposeTemplate.add(t.keybinding);
    const l = G(o, Dr(".quick-input-list-label-meta"));
    return t.detail = new hy(l, { supportHighlights: !0, supportIcons: !0, hoverDelegate: this.hoverDelegate }), t.toDisposeTemplate.add(t.detail), t.separator = G(t.entry, Dr(".quick-input-list-separator")), t.actionBar = new Bo(t.entry, this.hoverDelegate ? { hoverDelegate: this.hoverDelegate } : void 0), t.actionBar.domNode.classList.add("quick-input-list-entry-action-bar"), t.toDisposeTemplate.add(t.actionBar), t;
  }
  disposeTemplate(e) {
    e.toDisposeElement.dispose(), e.toDisposeTemplate.dispose();
  }
  disposeElement(e, t, i) {
    i.toDisposeElement.clear(), i.actionBar.clear();
  }
}
let vv = pE = class extends u3 {
  constructor(e, t) {
    super(e), this.themeService = t, this._itemsWithSeparatorsFrequency = /* @__PURE__ */ new Map();
  }
  get templateId() {
    return pE.ID;
  }
  renderTemplate(e) {
    const t = super.renderTemplate(e);
    return t.toDisposeTemplate.add(pi(t.checkbox, Q.CHANGE, (i) => {
      t.element.checked = t.checkbox.checked;
    })), t;
  }
  renderElement(e, t, i) {
    var n, s, o;
    const a = e.element;
    i.element = a, a.element = (n = i.entry) !== null && n !== void 0 ? n : void 0;
    const l = a.item;
    i.checkbox.checked = a.checked, i.toDisposeElement.add(a.onChecked((m) => i.checkbox.checked = m)), i.checkbox.disabled = a.checkboxDisabled;
    const { labelHighlights: d, descriptionHighlights: c, detailHighlights: h } = a;
    if (l.iconPath) {
      const m = jf(this.themeService.getColorTheme().type) ? l.iconPath.dark : (s = l.iconPath.light) !== null && s !== void 0 ? s : l.iconPath.dark, _ = Ee.revive(m);
      i.icon.className = "quick-input-list-icon", i.icon.style.backgroundImage = hd(_);
    } else
      i.icon.style.backgroundImage = "", i.icon.className = l.iconClass ? `quick-input-list-icon ${l.iconClass}` : "";
    let u;
    !a.saneTooltip && a.saneDescription && (u = {
      markdown: {
        value: a.saneDescription,
        supportThemeIcons: !0
      },
      markdownNotSupportedFallback: a.saneDescription
    });
    const g = {
      matches: d || [],
      // If we have a tooltip, we want that to be shown and not any other hover
      descriptionTitle: u,
      descriptionMatches: c || [],
      labelEscapeNewLines: !0
    };
    if (g.extraClasses = l.iconClasses, g.italic = l.italic, g.strikethrough = l.strikethrough, i.entry.classList.remove("quick-input-list-separator-as-item"), i.label.setLabel(a.saneLabel, a.saneDescription, g), i.keybinding.set(l.keybinding), a.saneDetail) {
      let m;
      a.saneTooltip || (m = {
        markdown: {
          value: a.saneDetail,
          supportThemeIcons: !0
        },
        markdownNotSupportedFallback: a.saneDetail
      }), i.detail.element.style.display = "", i.detail.setLabel(a.saneDetail, void 0, {
        matches: h,
        title: m,
        labelEscapeNewLines: !0
      });
    } else
      i.detail.element.style.display = "none";
    !((o = a.separator) === null || o === void 0) && o.label ? (i.separator.textContent = a.separator.label, i.separator.style.display = "", this.addItemWithSeparator(a)) : i.separator.style.display = "none", i.entry.classList.toggle("quick-input-list-separator-border", !!a.separator);
    const f = l.buttons;
    f && f.length ? (i.actionBar.push(f.map((m, _) => ty(m, `id-${_}`, () => a.fireButtonTriggered({ button: m, item: a.item }))), { icon: !0, label: !1 }), i.entry.classList.add("has-actions")) : i.entry.classList.remove("has-actions");
  }
  disposeElement(e, t, i) {
    this.removeItemWithSeparator(e.element), super.disposeElement(e, t, i);
  }
  isItemWithSeparatorVisible(e) {
    return this._itemsWithSeparatorsFrequency.has(e);
  }
  addItemWithSeparator(e) {
    this._itemsWithSeparatorsFrequency.set(e, (this._itemsWithSeparatorsFrequency.get(e) || 0) + 1);
  }
  removeItemWithSeparator(e) {
    const t = this._itemsWithSeparatorsFrequency.get(e) || 0;
    t > 1 ? this._itemsWithSeparatorsFrequency.set(e, t - 1) : this._itemsWithSeparatorsFrequency.delete(e);
  }
};
vv.ID = "quickpickitem";
vv = pE = cL([
  fE(1, $i)
], vv);
class Mb extends u3 {
  constructor() {
    super(...arguments), this._visibleSeparatorsFrequency = /* @__PURE__ */ new Map();
  }
  get templateId() {
    return Mb.ID;
  }
  get visibleSeparators() {
    return [...this._visibleSeparatorsFrequency.keys()];
  }
  isSeparatorVisible(e) {
    return this._visibleSeparatorsFrequency.has(e);
  }
  renderElement(e, t, i) {
    var n;
    const s = e.element;
    i.element = s, s.element = (n = i.entry) !== null && n !== void 0 ? n : void 0, s.element.classList.toggle("focus-inside", !!s.focusInsideSeparator);
    const o = s.separator, { labelHighlights: a, descriptionHighlights: l, detailHighlights: d } = s;
    i.icon.style.backgroundImage = "", i.icon.className = "";
    let c;
    !s.saneTooltip && s.saneDescription && (c = {
      markdown: {
        value: s.saneDescription,
        supportThemeIcons: !0
      },
      markdownNotSupportedFallback: s.saneDescription
    });
    const h = {
      matches: a || [],
      // If we have a tooltip, we want that to be shown and not any other hover
      descriptionTitle: c,
      descriptionMatches: l || [],
      labelEscapeNewLines: !0
    };
    if (i.entry.classList.add("quick-input-list-separator-as-item"), i.label.setLabel(s.saneLabel, s.saneDescription, h), s.saneDetail) {
      let g;
      s.saneTooltip || (g = {
        markdown: {
          value: s.saneDetail,
          supportThemeIcons: !0
        },
        markdownNotSupportedFallback: s.saneDetail
      }), i.detail.element.style.display = "", i.detail.setLabel(s.saneDetail, void 0, {
        matches: d,
        title: g,
        labelEscapeNewLines: !0
      });
    } else
      i.detail.element.style.display = "none";
    i.separator.style.display = "none", i.entry.classList.add("quick-input-list-separator-border");
    const u = o.buttons;
    u && u.length ? (i.actionBar.push(u.map((g, f) => ty(g, `id-${f}`, () => s.fireSeparatorButtonTriggered({ button: g, separator: s.separator }))), { icon: !0, label: !1 }), i.entry.classList.add("has-actions")) : i.entry.classList.remove("has-actions"), this.addSeparator(s);
  }
  disposeElement(e, t, i) {
    var n;
    this.removeSeparator(e.element), this.isSeparatorVisible(e.element) || (n = e.element.element) === null || n === void 0 || n.classList.remove("focus-inside"), super.disposeElement(e, t, i);
  }
  addSeparator(e) {
    this._visibleSeparatorsFrequency.set(e, (this._visibleSeparatorsFrequency.get(e) || 0) + 1);
  }
  removeSeparator(e) {
    const t = this._visibleSeparatorsFrequency.get(e) || 0;
    t > 1 ? this._visibleSeparatorsFrequency.set(e, t - 1) : this._visibleSeparatorsFrequency.delete(e);
  }
}
Mb.ID = "quickpickseparator";
let bv = class extends P {
  constructor(e, t, i, n, s, o) {
    super(), this.parent = e, this.hoverDelegate = t, this.linkOpenerDelegate = i, this.accessibilityService = o, this._onKeyDown = new R(), this._onLeave = new R(), this.onLeave = this._onLeave.event, this._onChangedAllVisibleChecked = new R(), this.onChangedAllVisibleChecked = this._onChangedAllVisibleChecked.event, this._onChangedCheckedCount = new R(), this.onChangedCheckedCount = this._onChangedCheckedCount.event, this._onChangedVisibleCount = new R(), this.onChangedVisibleCount = this._onChangedVisibleCount.event, this._onChangedCheckedElements = new R(), this.onChangedCheckedElements = this._onChangedCheckedElements.event, this._onButtonTriggered = new R(), this.onButtonTriggered = this._onButtonTriggered.event, this._onSeparatorButtonTriggered = new R(), this.onSeparatorButtonTriggered = this._onSeparatorButtonTriggered.event, this._elementChecked = new R(), this._inputElements = new Array(), this._elementTree = new Array(), this._itemElements = new Array(), this._elementDisposable = this._register(new q()), this._shouldFireCheckedEvents = !0, this._matchOnDescription = !1, this._matchOnDetail = !1, this._matchOnLabel = !0, this._matchOnLabelMode = "fuzzy", this._sortByLabel = !0, this._shouldLoop = !0, this._container = G(this.parent, Dr(".quick-input-list")), this._separatorRenderer = new Mb(t), this._itemRenderer = s.createInstance(vv, t), this._tree = this._register(s.createInstance(uE, "QuickInput", this._container, new qse(), [this._itemRenderer, this._separatorRenderer], {
      accessibilityProvider: new Gse(),
      setRowLineHeight: !1,
      multipleSelectionSupport: !1,
      hideTwistiesOfChildlessElements: !0,
      renderIndentGuides: rp.None,
      findWidgetEnabled: !1,
      indent: 0,
      horizontalScrolling: !1,
      allowNonCollapsibleParents: !0,
      alwaysConsumeMouseWheel: !0
    })), this._tree.getHTMLElement().id = n, this._registerListeners();
  }
  //#region public getters/setters
  get onDidChangeFocus() {
    return ne.map(this._tree.onDidChangeFocus, (e) => e.elements.filter((t) => t instanceof Bn).map((t) => t.item));
  }
  get onDidChangeSelection() {
    return ne.map(this._tree.onDidChangeSelection, (e) => ({
      items: e.elements.filter((t) => t instanceof Bn).map((t) => t.item),
      event: e.browserEvent
    }));
  }
  get scrollTop() {
    return this._tree.scrollTop;
  }
  set scrollTop(e) {
    this._tree.scrollTop = e;
  }
  get ariaLabel() {
    return this._tree.ariaLabel;
  }
  set ariaLabel(e) {
    this._tree.ariaLabel = e ?? "";
  }
  set enabled(e) {
    this._tree.getHTMLElement().style.pointerEvents = e ? "" : "none";
  }
  get matchOnDescription() {
    return this._matchOnDescription;
  }
  set matchOnDescription(e) {
    this._matchOnDescription = e;
  }
  get matchOnDetail() {
    return this._matchOnDetail;
  }
  set matchOnDetail(e) {
    this._matchOnDetail = e;
  }
  get matchOnLabel() {
    return this._matchOnLabel;
  }
  set matchOnLabel(e) {
    this._matchOnLabel = e;
  }
  get matchOnLabelMode() {
    return this._matchOnLabelMode;
  }
  set matchOnLabelMode(e) {
    this._matchOnLabelMode = e;
  }
  get sortByLabel() {
    return this._sortByLabel;
  }
  set sortByLabel(e) {
    this._sortByLabel = e;
  }
  get shouldLoop() {
    return this._shouldLoop;
  }
  set shouldLoop(e) {
    this._shouldLoop = e;
  }
  //#endregion
  //#region register listeners
  _registerListeners() {
    this._registerOnKeyDown(), this._registerOnContainerClick(), this._registerOnMouseMiddleClick(), this._registerOnElementChecked(), this._registerOnContextMenu(), this._registerHoverListeners(), this._registerSelectionChangeListener(), this._registerSeparatorActionShowingListeners();
  }
  _registerOnKeyDown() {
    this._register(this._tree.onKeyDown((e) => {
      const t = new Mt(e);
      switch (t.keyCode) {
        case 10:
          this.toggleCheckbox();
          break;
      }
      this._onKeyDown.fire(t);
    }));
  }
  _registerOnContainerClick() {
    this._register(W(this._container, Q.CLICK, (e) => {
      (e.x || e.y) && this._onLeave.fire();
    }));
  }
  _registerOnMouseMiddleClick() {
    this._register(W(this._container, Q.AUXCLICK, (e) => {
      e.button === 1 && this._onLeave.fire();
    }));
  }
  _registerOnElementChecked() {
    this._register(this._elementChecked.event((e) => this._fireCheckedEvents()));
  }
  _registerOnContextMenu() {
    this._register(this._tree.onContextMenu((e) => {
      e.element && (e.browserEvent.preventDefault(), this._tree.setSelection([e.element]));
    }));
  }
  _registerHoverListeners() {
    const e = this._register(new kH(this.hoverDelegate.delay));
    this._register(this._tree.onMouseOver(async (t) => {
      var i;
      if (xA(t.browserEvent.target)) {
        e.cancel();
        return;
      }
      if (
        // anchors are an exception as called out above so we skip them here
        !(!xA(t.browserEvent.relatedTarget) && // check if the mouse is still over the same element
        qi(t.browserEvent.relatedTarget, (i = t.element) === null || i === void 0 ? void 0 : i.element))
      )
        try {
          await e.trigger(async () => {
            t.element instanceof Bn && this.showHover(t.element);
          });
        } catch (n) {
          if (!cl(n))
            throw n;
        }
    })), this._register(this._tree.onMouseOut((t) => {
      var i;
      qi(t.browserEvent.relatedTarget, (i = t.element) === null || i === void 0 ? void 0 : i.element) || e.cancel();
    }));
  }
  /**
   * Register's focus change and mouse events so that we can track when items inside of a
   * separator's section are focused or hovered so that we can display the separator's actions
   */
  _registerSeparatorActionShowingListeners() {
    this._register(this._tree.onDidChangeFocus((e) => {
      const t = e.elements[0] ? this._tree.getParentElement(e.elements[0]) : null;
      for (const i of this._separatorRenderer.visibleSeparators) {
        const n = i === t;
        !!(i.focusInsideSeparator & xa.ACTIVE_ITEM) !== n && (n ? i.focusInsideSeparator |= xa.ACTIVE_ITEM : i.focusInsideSeparator &= ~xa.ACTIVE_ITEM, this._tree.rerender(i));
      }
    })), this._register(this._tree.onMouseOver((e) => {
      const t = e.element ? this._tree.getParentElement(e.element) : null;
      for (const i of this._separatorRenderer.visibleSeparators) {
        if (i !== t)
          continue;
        !!(i.focusInsideSeparator & xa.MOUSE_HOVER) || (i.focusInsideSeparator |= xa.MOUSE_HOVER, this._tree.rerender(i));
      }
    })), this._register(this._tree.onMouseOut((e) => {
      const t = e.element ? this._tree.getParentElement(e.element) : null;
      for (const i of this._separatorRenderer.visibleSeparators) {
        if (i !== t)
          continue;
        !!(i.focusInsideSeparator & xa.MOUSE_HOVER) && (i.focusInsideSeparator &= ~xa.MOUSE_HOVER, this._tree.rerender(i));
      }
    }));
  }
  _registerSelectionChangeListener() {
    this._register(this._tree.onDidChangeSelection((e) => {
      const t = e.elements.filter((i) => i instanceof Bn);
      t.length !== e.elements.length && (e.elements.length === 1 && e.elements[0] instanceof Fd && (this._tree.setFocus([e.elements[0].children[0]]), this._tree.reveal(e.elements[0], 0)), this._tree.setSelection(t));
    }));
  }
  //#endregion
  //#region public methods
  getAllVisibleChecked() {
    return this._allVisibleChecked(this._itemElements, !1);
  }
  getCheckedCount() {
    return this._itemElements.filter((e) => e.checked).length;
  }
  getVisibleCount() {
    return this._itemElements.filter((e) => !e.hidden).length;
  }
  setAllVisibleChecked(e) {
    try {
      this._shouldFireCheckedEvents = !1, this._itemElements.forEach((t) => {
        !t.hidden && !t.checkboxDisabled && (t.checked = e);
      });
    } finally {
      this._shouldFireCheckedEvents = !0, this._fireCheckedEvents();
    }
  }
  setElements(e) {
    this._elementDisposable.clear(), this._inputElements = e;
    const t = this.parent.classList.contains("show-checkboxes");
    let i;
    this._itemElements = new Array(), this._elementTree = e.reduce((o, a, l) => {
      let d;
      if (a.type === "separator") {
        if (!a.buttons)
          return o;
        i = new Fd(l, (c) => this.fireSeparatorButtonTriggered(c), a), d = i;
      } else {
        const c = l > 0 ? e[l - 1] : void 0;
        let h;
        c && c.type === "separator" && !c.buttons && (i = void 0, h = c);
        const u = new Bn(l, t, (g) => this.fireButtonTriggered(g), this._elementChecked, a, h);
        if (this._itemElements.push(u), i)
          return i.children.push(u), o;
        d = u;
      }
      return o.push(d), o;
    }, new Array());
    const n = new Array();
    let s = 0;
    for (const o of this._elementTree)
      o instanceof Fd ? (n.push({
        element: o,
        collapsible: !1,
        collapsed: !1,
        children: o.children.map((a) => ({
          element: a,
          collapsible: !1,
          collapsed: !1
        }))
      }), s += o.children.length + 1) : (n.push({
        element: o,
        collapsible: !1,
        collapsed: !1
      }), s++);
    this._tree.setChildren(null, n), this._onChangedVisibleCount.fire(s), this.accessibilityService.isScreenReaderOptimized() && setTimeout(() => {
      const o = this._tree.getHTMLElement().querySelector(".monaco-list-row.focused"), a = o == null ? void 0 : o.parentNode;
      if (o && a) {
        const l = o.nextSibling;
        a.removeChild(o), a.insertBefore(o, l);
      }
    }, 0);
  }
  setFocusedElements(e) {
    const t = e.map((i) => this._itemElements.find((n) => n.item === i)).filter((i) => !!i);
    if (this._tree.setFocus(t), e.length > 0) {
      const i = this._tree.getFocus()[0];
      i && this._tree.reveal(i);
    }
  }
  getActiveDescendant() {
    return this._tree.getHTMLElement().getAttribute("aria-activedescendant");
  }
  setSelectedElements(e) {
    const t = e.map((i) => this._itemElements.find((n) => n.item === i)).filter((i) => !!i);
    this._tree.setSelection(t);
  }
  getCheckedElements() {
    return this._itemElements.filter((e) => e.checked).map((e) => e.item);
  }
  setCheckedElements(e) {
    try {
      this._shouldFireCheckedEvents = !1;
      const t = /* @__PURE__ */ new Set();
      for (const i of e)
        t.add(i);
      for (const i of this._itemElements)
        i.checked = t.has(i.item);
    } finally {
      this._shouldFireCheckedEvents = !0, this._fireCheckedEvents();
    }
  }
  focus(e) {
    var t;
    if (this._itemElements.length)
      switch (e === Bt.Second && this._itemElements.length < 2 && (e = Bt.First), e) {
        case Bt.First:
          this._tree.scrollTop = 0, this._tree.focusFirst(void 0, (i) => i.element instanceof Bn);
          break;
        case Bt.Second:
          this._tree.scrollTop = 0, this._tree.setFocus([this._itemElements[1]]);
          break;
        case Bt.Last:
          this._tree.scrollTop = this._tree.scrollHeight, this._tree.setFocus([this._itemElements[this._itemElements.length - 1]]);
          break;
        case Bt.Next: {
          const i = this._tree.getFocus();
          this._tree.focusNext(void 0, this._shouldLoop, void 0, (s) => s.element instanceof Bn ? (this._tree.reveal(s.element), !0) : !1);
          const n = this._tree.getFocus();
          i.length && i[0] === n[0] && i[0] === this._itemElements[this._itemElements.length - 1] && this._onLeave.fire();
          break;
        }
        case Bt.Previous: {
          const i = this._tree.getFocus();
          this._tree.focusPrevious(void 0, this._shouldLoop, void 0, (s) => {
            if (!(s.element instanceof Bn))
              return !1;
            const o = this._tree.getParentElement(s.element);
            return o === null || o.children[0] !== s.element ? this._tree.reveal(s.element) : this._tree.reveal(o), !0;
          });
          const n = this._tree.getFocus();
          i.length && i[0] === n[0] && i[0] === this._itemElements[0] && this._onLeave.fire();
          break;
        }
        case Bt.NextPage:
          this._tree.focusNextPage(void 0, (i) => i.element instanceof Bn ? (this._tree.reveal(i.element), !0) : !1);
          break;
        case Bt.PreviousPage:
          this._tree.focusPreviousPage(void 0, (i) => {
            if (!(i.element instanceof Bn))
              return !1;
            const n = this._tree.getParentElement(i.element);
            return n === null || n.children[0] !== i.element ? this._tree.reveal(i.element) : this._tree.reveal(n), !0;
          });
          break;
        case Bt.NextSeparator: {
          let i = !1;
          const n = this._tree.getFocus()[0];
          this._tree.focusNext(void 0, !0, void 0, (o) => {
            if (i)
              return !0;
            if (o.element instanceof Fd)
              i = !0, this._separatorRenderer.isSeparatorVisible(o.element) ? this._tree.reveal(o.element.children[0]) : this._tree.reveal(o.element, 0);
            else if (o.element instanceof Bn) {
              if (o.element.separator)
                return this._itemRenderer.isItemWithSeparatorVisible(o.element) ? this._tree.reveal(o.element) : this._tree.reveal(o.element, 0), !0;
              if (o.element === this._elementTree[0])
                return this._tree.reveal(o.element, 0), !0;
            }
            return !1;
          });
          const s = this._tree.getFocus()[0];
          n === s && (this._tree.scrollTop = this._tree.scrollHeight, this._tree.setFocus([this._itemElements[this._itemElements.length - 1]]));
          break;
        }
        case Bt.PreviousSeparator: {
          let i, n = !!(!((t = this._tree.getFocus()[0]) === null || t === void 0) && t.separator);
          this._tree.focusPrevious(void 0, !0, void 0, (s) => {
            if (s.element instanceof Fd)
              n ? i || (this._separatorRenderer.isSeparatorVisible(s.element) ? this._tree.reveal(s.element) : this._tree.reveal(s.element, 0), i = s.element.children[0]) : n = !0;
            else if (s.element instanceof Bn && !i) {
              if (s.element.separator)
                this._itemRenderer.isItemWithSeparatorVisible(s.element) ? this._tree.reveal(s.element) : this._tree.reveal(s.element, 0), i = s.element;
              else if (s.element === this._elementTree[0])
                return this._tree.reveal(s.element, 0), !0;
            }
            return !1;
          }), i && this._tree.setFocus([i]);
          break;
        }
      }
  }
  clearFocus() {
    this._tree.setFocus([]);
  }
  domFocus() {
    this._tree.domFocus();
  }
  layout(e) {
    this._tree.getHTMLElement().style.maxHeight = e ? `${// Make sure height aligns with list item heights
    Math.floor(e / 44) * 44 + 6}px` : "", this._tree.layout();
  }
  filter(e) {
    if (!(this._sortByLabel || this._matchOnLabel || this._matchOnDescription || this._matchOnDetail))
      return this._tree.layout(), !1;
    const t = e;
    if (e = e.trim(), !e || !(this.matchOnLabel || this.matchOnDescription || this.matchOnDetail))
      this._itemElements.forEach((a) => {
        a.labelHighlights = void 0, a.descriptionHighlights = void 0, a.detailHighlights = void 0, a.hidden = !1;
        const l = a.index && this._inputElements[a.index - 1];
        a.item && (a.separator = l && l.type === "separator" && !l.buttons ? l : void 0);
      });
    else {
      let a;
      this._elementTree.forEach((l) => {
        var d, c, h, u;
        let g;
        this.matchOnLabelMode === "fuzzy" ? g = this.matchOnLabel && (d = Ck(e, Wm(l.saneLabel))) !== null && d !== void 0 ? d : void 0 : g = this.matchOnLabel && (c = Zse(t, Wm(l.saneLabel))) !== null && c !== void 0 ? c : void 0;
        const f = this.matchOnDescription && (h = Ck(e, Wm(l.saneDescription || ""))) !== null && h !== void 0 ? h : void 0, m = this.matchOnDetail && (u = Ck(e, Wm(l.saneDetail || ""))) !== null && u !== void 0 ? u : void 0;
        if (g || f || m ? (l.labelHighlights = g, l.descriptionHighlights = f, l.detailHighlights = m, l.hidden = !1) : (l.labelHighlights = void 0, l.descriptionHighlights = void 0, l.detailHighlights = void 0, l.hidden = l.item ? !l.item.alwaysShow : !0), l.item ? l.separator = void 0 : l.separator && (l.hidden = !0), !this.sortByLabel) {
          const _ = l.index && this._inputElements[l.index - 1];
          a = _ && _.type === "separator" ? _ : a, a && !l.hidden && (l.separator = a, a = void 0);
        }
      });
    }
    const i = this._elementTree.filter((a) => !a.hidden);
    if (this.sortByLabel && e) {
      const a = e.toLowerCase();
      i.sort((l, d) => Yse(l, d, a));
    }
    let n;
    const s = i.reduce((a, l, d) => (l instanceof Bn ? n ? n.children.push(l) : a.push(l) : l instanceof Fd && (l.children = [], n = l, a.push(l)), a), new Array()), o = new Array();
    for (const a of s)
      a instanceof Fd ? o.push({
        element: a,
        collapsible: !1,
        collapsed: !1,
        children: a.children.map((l) => ({
          element: l,
          collapsible: !1,
          collapsed: !1
        }))
      }) : o.push({
        element: a,
        collapsible: !1,
        collapsed: !1
      });
    return this._tree.setChildren(null, o), this._tree.layout(), this._onChangedAllVisibleChecked.fire(this.getAllVisibleChecked()), this._onChangedVisibleCount.fire(i.length), !0;
  }
  toggleCheckbox() {
    try {
      this._shouldFireCheckedEvents = !1;
      const e = this._tree.getFocus().filter((i) => i instanceof Bn), t = this._allVisibleChecked(e);
      for (const i of e)
        i.checkboxDisabled || (i.checked = !t);
    } finally {
      this._shouldFireCheckedEvents = !0, this._fireCheckedEvents();
    }
  }
  display(e) {
    this._container.style.display = e ? "" : "none";
  }
  isDisplayed() {
    return this._container.style.display !== "none";
  }
  style(e) {
    this._tree.style(e);
  }
  toggleHover() {
    const e = this._tree.getFocus()[0];
    if (!(e != null && e.saneTooltip) || !(e instanceof Bn))
      return;
    if (this._lastHover && !this._lastHover.isDisposed) {
      this._lastHover.dispose();
      return;
    }
    this.showHover(e);
    const t = new q();
    t.add(this._tree.onDidChangeFocus((i) => {
      i.elements[0] instanceof Bn && this.showHover(i.elements[0]);
    })), this._lastHover && t.add(this._lastHover), this._elementDisposable.add(t);
  }
  //#endregion
  //#region private methods
  _allVisibleChecked(e, t = !0) {
    for (let i = 0, n = e.length; i < n; i++) {
      const s = e[i];
      if (!s.hidden)
        if (s.checked)
          t = !0;
        else
          return !1;
    }
    return t;
  }
  _fireCheckedEvents() {
    this._shouldFireCheckedEvents && (this._onChangedAllVisibleChecked.fire(this.getAllVisibleChecked()), this._onChangedCheckedCount.fire(this.getCheckedCount()), this._onChangedCheckedElements.fire(this.getCheckedElements()));
  }
  fireButtonTriggered(e) {
    this._onButtonTriggered.fire(e);
  }
  fireSeparatorButtonTriggered(e) {
    this._onSeparatorButtonTriggered.fire(e);
  }
  /**
   * Disposes of the hover and shows a new one for the given index if it has a tooltip.
   * @param element The element to show the hover for
   */
  showHover(e) {
    var t, i, n;
    this._lastHover && !this._lastHover.isDisposed && ((i = (t = this.hoverDelegate).onDidHideHover) === null || i === void 0 || i.call(t), (n = this._lastHover) === null || n === void 0 || n.dispose()), !(!e.element || !e.saneTooltip) && (this._lastHover = this.hoverDelegate.showHover({
      content: e.saneTooltip,
      target: e.element,
      linkHandler: (s) => {
        this.linkOpenerDelegate(s);
      },
      appearance: {
        showPointer: !0
      },
      container: this._container,
      position: {
        hoverPosition: 1
        /* HoverPosition.RIGHT */
      }
    }, !1));
  }
};
cL([
  ki
], bv.prototype, "onDidChangeFocus", null);
cL([
  ki
], bv.prototype, "onDidChangeSelection", null);
bv = cL([
  fE(4, be),
  fE(5, qs)
], bv);
function Zse(r, e) {
  const { text: t, iconOffsets: i } = e;
  if (!i || i.length === 0)
    return LF(r, t);
  const n = i0(t, " "), s = t.length - n.length, o = LF(r, n);
  if (o)
    for (const a of o) {
      const l = i[a.start + s] + s;
      a.start += l, a.end += l;
    }
  return o;
}
function LF(r, e) {
  const t = e.toLowerCase().indexOf(r.toLowerCase());
  return t !== -1 ? [{ start: t, end: t + r.length }] : null;
}
function Yse(r, e, t) {
  const i = r.labelHighlights || [], n = e.labelHighlights || [];
  return i.length && !n.length ? -1 : !i.length && n.length ? 1 : i.length === 0 && n.length === 0 ? 0 : Kse(r.saneSortLabel, e.saneSortLabel, t);
}
const g3 = {
  weight: 200,
  when: U.and(U.equals(
    Fz,
    "quickPick"
    /* QuickInputType.QuickPick */
  ), Lne),
  metadata: { description: p("quickPick", "Used while in the context of the quick pick. If you change one keybinding for this command, you should change all of the other keybindings (modifier variants) of this command as well.") }
};
function Rs(r, e = {}) {
  var t;
  ls.registerCommandAndKeybindingRule({
    ...g3,
    ...r,
    secondary: Qse(r.primary, (t = r.secondary) !== null && t !== void 0 ? t : [], e)
  });
}
const uy = Je ? 256 : 2048;
function Qse(r, e, t = {}) {
  return t.withAltMod && e.push(512 + r), t.withCtrlMod && (e.push(uy + r), t.withAltMod && e.push(512 + uy + r)), t.withCmdMod && Je && (e.push(2048 + r), t.withCtrlMod && e.push(2304 + r), t.withAltMod && (e.push(2560 + r), t.withCtrlMod && e.push(2816 + r))), e;
}
function so(r, e) {
  return (t) => {
    const i = t.get($o).currentQuickInput;
    if (i)
      return e && i.quickNavigate ? i.focus(e) : i.focus(r);
  };
}
Rs({ id: "quickInput.pageNext", primary: 12, handler: so(Bt.NextPage) }, { withAltMod: !0, withCtrlMod: !0, withCmdMod: !0 });
Rs({ id: "quickInput.pagePrevious", primary: 11, handler: so(Bt.PreviousPage) }, { withAltMod: !0, withCtrlMod: !0, withCmdMod: !0 });
Rs({ id: "quickInput.first", primary: uy + 14, handler: so(Bt.First) }, { withAltMod: !0, withCmdMod: !0 });
Rs({ id: "quickInput.last", primary: uy + 13, handler: so(Bt.Last) }, { withAltMod: !0, withCmdMod: !0 });
Rs({ id: "quickInput.next", primary: 18, handler: so(Bt.Next) }, { withCtrlMod: !0 });
Rs({ id: "quickInput.previous", primary: 16, handler: so(Bt.Previous) }, { withCtrlMod: !0 });
const DF = p("quickInput.nextSeparatorWithQuickAccessFallback", "If we're in quick access mode, this will navigate to the next item. If we are not in quick access mode, this will navigate to the next separator."), kF = p("quickInput.previousSeparatorWithQuickAccessFallback", "If we're in quick access mode, this will navigate to the previous item. If we are not in quick access mode, this will navigate to the previous separator.");
Je ? (Rs({
  id: "quickInput.nextSeparatorWithQuickAccessFallback",
  primary: 2066,
  handler: so(Bt.NextSeparator, Bt.Next),
  metadata: { description: DF }
}), Rs({
  id: "quickInput.nextSeparator",
  primary: 2578,
  // Since macOS has the cmd key as the primary modifier, we need to add this additional
  // keybinding to capture cmd+ctrl+upArrow
  secondary: [
    2322
    /* KeyCode.DownArrow */
  ],
  handler: so(Bt.NextSeparator)
}, { withCtrlMod: !0 }), Rs({
  id: "quickInput.previousSeparatorWithQuickAccessFallback",
  primary: 2064,
  handler: so(Bt.PreviousSeparator, Bt.Previous),
  metadata: { description: kF }
}), Rs({
  id: "quickInput.previousSeparator",
  primary: 2576,
  // Since macOS has the cmd key as the primary modifier, we need to add this additional
  // keybinding to capture cmd+ctrl+upArrow
  secondary: [
    2320
    /* KeyCode.UpArrow */
  ],
  handler: so(Bt.PreviousSeparator)
}, { withCtrlMod: !0 })) : (Rs({
  id: "quickInput.nextSeparatorWithQuickAccessFallback",
  primary: 530,
  handler: so(Bt.NextSeparator, Bt.Next),
  metadata: { description: DF }
}), Rs({
  id: "quickInput.nextSeparator",
  primary: 2578,
  handler: so(Bt.NextSeparator)
}), Rs({
  id: "quickInput.previousSeparatorWithQuickAccessFallback",
  primary: 528,
  handler: so(Bt.PreviousSeparator, Bt.Previous),
  metadata: { description: kF }
}), Rs({
  id: "quickInput.previousSeparator",
  primary: 2576,
  handler: so(Bt.PreviousSeparator)
}));
Rs({
  id: "quickInput.acceptInBackground",
  // If we are in the quick pick but the input box is not focused or our cursor is at the end of the input box
  when: U.and(g3.when, U.or(t3.negate(), xne)),
  primary: 17,
  // Need a little extra weight to ensure this keybinding is preferred over the default cmd+alt+right arrow keybinding
  // https://github.com/microsoft/vscode/blob/1451e4fbbbf074a4355cc537c35b547b80ce1c52/src/vs/workbench/browser/parts/editor/editorActions.ts#L1178-L1195
  weight: 250,
  handler: (r) => {
    const e = r.get($o).currentQuickInput;
    e == null || e.accept(!0);
  }
}, { withAltMod: !0, withCtrlMod: !0, withCmdMod: !0 });
var Xse = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Pk = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, mE;
const Ts = X;
let gy = mE = class extends P {
  get currentQuickInput() {
    var e;
    return (e = this.controller) !== null && e !== void 0 ? e : void 0;
  }
  get container() {
    return this._container;
  }
  constructor(e, t, i, n) {
    super(), this.options = e, this.layoutService = t, this.instantiationService = i, this.contextKeyService = n, this.enabled = !0, this.onDidAcceptEmitter = this._register(new R()), this.onDidCustomEmitter = this._register(new R()), this.onDidTriggerButtonEmitter = this._register(new R()), this.keyMods = { ctrlCmd: !1, alt: !1 }, this.controller = null, this.onShowEmitter = this._register(new R()), this.onShow = this.onShowEmitter.event, this.onHideEmitter = this._register(new R()), this.onHide = this.onHideEmitter.event, this.inQuickInputContext = yne.bindTo(this.contextKeyService), this.quickInputTypeContext = Dne.bindTo(this.contextKeyService), this.endOfQuickInputBoxContext = kne.bindTo(this.contextKeyService), this.idPrefix = e.idPrefix, this._container = e.container, this.styles = e.styles, this._register(ne.runAndSubscribe(o0, ({ window: s, disposables: o }) => this.registerKeyModsListeners(s, o), { window: Dt, disposables: this._store })), this._register(O8((s) => {
      this.ui && we(this.ui.container) === s && (this.reparentUI(this.layoutService.mainContainer), this.layout(this.layoutService.mainContainerDimension, this.layoutService.mainContainerOffset.quickPickTop));
    }));
  }
  registerKeyModsListeners(e, t) {
    const i = (n) => {
      this.keyMods.ctrlCmd = n.ctrlKey || n.metaKey, this.keyMods.alt = n.altKey;
    };
    for (const n of [Q.KEY_DOWN, Q.KEY_UP, Q.MOUSE_DOWN])
      t.add(W(e, n, i, !0));
  }
  getUI(e) {
    if (this.ui)
      return e && we(this._container) !== we(this.layoutService.activeContainer) && (this.reparentUI(this.layoutService.activeContainer), this.layout(this.layoutService.activeContainerDimension, this.layoutService.activeContainerOffset.quickPickTop)), this.ui;
    const t = G(this._container, Ts(".quick-input-widget.show-file-icons"));
    t.tabIndex = -1, t.style.display = "none";
    const i = fo(t), n = G(t, Ts(".quick-input-titlebar")), s = this._register(new Bo(n, { hoverDelegate: this.options.hoverDelegate }));
    s.domNode.classList.add("quick-input-left-action-bar");
    const o = G(n, Ts(".quick-input-title")), a = this._register(new Bo(n, { hoverDelegate: this.options.hoverDelegate }));
    a.domNode.classList.add("quick-input-right-action-bar");
    const l = G(t, Ts(".quick-input-header")), d = G(l, Ts("input.quick-input-check-all"));
    d.type = "checkbox", d.setAttribute("aria-label", p("quickInput.checkAll", "Toggle all checkboxes")), this._register(pi(d, Q.CHANGE, (H) => {
      const re = d.checked;
      V.setAllVisibleChecked(re);
    })), this._register(W(d, Q.CLICK, (H) => {
      (H.x || H.y) && g.setFocus();
    }));
    const c = G(l, Ts(".quick-input-description")), h = G(l, Ts(".quick-input-and-message")), u = G(h, Ts(".quick-input-filter")), g = this._register(new Fne(u, this.styles.inputBox, this.styles.toggle));
    g.setAttribute("aria-describedby", `${this.idPrefix}message`);
    const f = G(u, Ts(".quick-input-visible-count"));
    f.setAttribute("aria-live", "polite"), f.setAttribute("aria-atomic", "true");
    const m = new lE(f, { countFormat: p({ key: "quickInput.visibleCount", comment: ["This tells the user how many items are shown in a list of items to select from. The items can be anything. Currently not visible, but read by screen readers."] }, "{0} Results") }, this.styles.countBadge), _ = G(u, Ts(".quick-input-count"));
    _.setAttribute("aria-live", "polite");
    const v = new lE(_, { countFormat: p({ key: "quickInput.countSelected", comment: ["This tells the user how many items are selected in a list of items to select from. The items can be anything."] }, "{0} Selected") }, this.styles.countBadge), b = G(l, Ts(".quick-input-action")), C = this._register(new iy(b, this.styles.button));
    C.label = p("ok", "OK"), this._register(C.onDidClick((H) => {
      this.onDidAcceptEmitter.fire();
    }));
    const w = G(l, Ts(".quick-input-action")), S = this._register(new iy(w, { ...this.styles.button, supportIcons: !0 }));
    S.label = p("custom", "Custom"), this._register(S.onDidClick((H) => {
      this.onDidCustomEmitter.fire();
    }));
    const y = G(h, Ts(`#${this.idPrefix}message.quick-input-message`)), k = this._register(new iL(t, this.styles.progressBar));
    k.getContainer().classList.add("quick-input-progress");
    const E = G(t, Ts(".quick-input-html-widget"));
    E.tabIndex = -1;
    const N = G(t, Ts(".quick-input-description")), F = this.idPrefix + "list", V = this._register(this.instantiationService.createInstance(bv, t, this.options.hoverDelegate, this.options.linkOpenerDelegate, F));
    g.setAttribute("aria-controls", F), this._register(V.onDidChangeFocus(() => {
      var H;
      g.setAttribute("aria-activedescendant", (H = V.getActiveDescendant()) !== null && H !== void 0 ? H : "");
    })), this._register(V.onChangedAllVisibleChecked((H) => {
      d.checked = H;
    })), this._register(V.onChangedVisibleCount((H) => {
      m.setCount(H);
    })), this._register(V.onChangedCheckedCount((H) => {
      v.setCount(H);
    })), this._register(V.onLeave(() => {
      setTimeout(() => {
        this.controller && (g.setFocus(), this.controller instanceof gv && this.controller.canSelectMany && V.clearFocus());
      }, 0);
    }));
    const Z = Xr(t);
    return this._register(Z), this._register(W(t, Q.FOCUS, (H) => {
      const re = this.getUI();
      if (qi(H.relatedTarget, re.inputContainer)) {
        const ue = re.inputBox.isSelectionAtEnd();
        this.endOfQuickInputBoxContext.get() !== ue && this.endOfQuickInputBoxContext.set(ue);
      }
      qi(H.relatedTarget, re.container) || (this.inQuickInputContext.set(!0), this.previousFocusElement = ln(H.relatedTarget) ? H.relatedTarget : void 0);
    }, !0)), this._register(Z.onDidBlur(() => {
      !this.getUI().ignoreFocusOut && !this.options.ignoreFocusOut() && this.hide(op.Blur), this.inQuickInputContext.set(!1), this.endOfQuickInputBoxContext.set(!1), this.previousFocusElement = void 0;
    })), this._register(g.onKeyDown((H) => {
      const re = this.getUI().inputBox.isSelectionAtEnd();
      this.endOfQuickInputBoxContext.get() !== re && this.endOfQuickInputBoxContext.set(re);
    })), this._register(W(t, Q.FOCUS, (H) => {
      g.setFocus();
    })), this._register(pi(t, Q.KEY_DOWN, (H) => {
      if (!qi(H.target, E))
        switch (H.keyCode) {
          case 3:
            nt.stop(H, !0), this.enabled && this.onDidAcceptEmitter.fire();
            break;
          case 9:
            nt.stop(H, !0), this.hide(op.Gesture);
            break;
          case 2:
            if (!H.altKey && !H.ctrlKey && !H.metaKey) {
              const re = [
                ".quick-input-list .monaco-action-bar .always-visible",
                ".quick-input-list-entry:hover .monaco-action-bar",
                ".monaco-list-row.focused .monaco-action-bar"
              ];
              if (t.classList.contains("show-checkboxes") ? re.push("input") : re.push("input[type=text]"), this.getUI().list.isDisplayed() && re.push(".monaco-list"), this.getUI().message && re.push(".quick-input-message a"), this.getUI().widget) {
                if (qi(H.target, this.getUI().widget))
                  break;
                re.push(".quick-input-html-widget");
              }
              const ue = t.querySelectorAll(re.join(", "));
              H.shiftKey && H.target === ue[0] ? (nt.stop(H, !0), V.clearFocus()) : !H.shiftKey && qi(H.target, ue[ue.length - 1]) && (nt.stop(H, !0), ue[0].focus());
            }
            break;
          case 10:
            H.ctrlKey && (nt.stop(H, !0), this.getUI().list.toggleHover());
            break;
        }
    })), this.ui = {
      container: t,
      styleSheet: i,
      leftActionBar: s,
      titleBar: n,
      title: o,
      description1: N,
      description2: c,
      widget: E,
      rightActionBar: a,
      checkAll: d,
      inputContainer: h,
      filterContainer: u,
      inputBox: g,
      visibleCountContainer: f,
      visibleCount: m,
      countContainer: _,
      count: v,
      okContainer: b,
      ok: C,
      message: y,
      customButtonContainer: w,
      customButton: S,
      list: V,
      progressBar: k,
      onDidAccept: this.onDidAcceptEmitter.event,
      onDidCustom: this.onDidCustomEmitter.event,
      onDidTriggerButton: this.onDidTriggerButtonEmitter.event,
      ignoreFocusOut: !1,
      keyMods: this.keyMods,
      show: (H) => this.show(H),
      hide: () => this.hide(),
      setVisibilities: (H) => this.setVisibilities(H),
      setEnabled: (H) => this.setEnabled(H),
      setContextKey: (H) => this.options.setContextKey(H),
      linkOpenerDelegate: (H) => this.options.linkOpenerDelegate(H)
    }, this.updateStyles(), this.ui;
  }
  reparentUI(e) {
    this.ui && (this._container = e, G(this._container, this.ui.container));
  }
  pick(e, t = {}, i = at.None) {
    return new Promise((n, s) => {
      let o = (c) => {
        var h;
        o = n, (h = t.onKeyMods) === null || h === void 0 || h.call(t, a.keyMods), n(c);
      };
      if (i.isCancellationRequested) {
        o(void 0);
        return;
      }
      const a = this.createQuickPick();
      let l;
      const d = [
        a,
        a.onDidAccept(() => {
          if (a.canSelectMany)
            o(a.selectedItems.slice()), a.hide();
          else {
            const c = a.activeItems[0];
            c && (o(c), a.hide());
          }
        }),
        a.onDidChangeActive((c) => {
          const h = c[0];
          h && t.onDidFocus && t.onDidFocus(h);
        }),
        a.onDidChangeSelection((c) => {
          if (!a.canSelectMany) {
            const h = c[0];
            h && (o(h), a.hide());
          }
        }),
        a.onDidTriggerItemButton((c) => t.onDidTriggerItemButton && t.onDidTriggerItemButton({
          ...c,
          removeItem: () => {
            const h = a.items.indexOf(c.item);
            if (h !== -1) {
              const u = a.items.slice(), g = u.splice(h, 1), f = a.activeItems.filter((_) => _ !== g[0]), m = a.keepScrollPosition;
              a.keepScrollPosition = !0, a.items = u, f && (a.activeItems = f), a.keepScrollPosition = m;
            }
          }
        })),
        a.onDidTriggerSeparatorButton((c) => {
          var h;
          return (h = t.onDidTriggerSeparatorButton) === null || h === void 0 ? void 0 : h.call(t, c);
        }),
        a.onDidChangeValue((c) => {
          l && !c && (a.activeItems.length !== 1 || a.activeItems[0] !== l) && (a.activeItems = [l]);
        }),
        i.onCancellationRequested(() => {
          a.hide();
        }),
        a.onDidHide(() => {
          zt(d), o(void 0);
        })
      ];
      a.title = t.title, a.canSelectMany = !!t.canPickMany, a.placeholder = t.placeHolder, a.ignoreFocusOut = !!t.ignoreFocusLost, a.matchOnDescription = !!t.matchOnDescription, a.matchOnDetail = !!t.matchOnDetail, a.matchOnLabel = t.matchOnLabel === void 0 || t.matchOnLabel, a.quickNavigate = t.quickNavigate, a.hideInput = !!t.hideInput, a.contextKey = t.contextKey, a.busy = !0, Promise.all([e, t.activeItem]).then(([c, h]) => {
        l = h, a.busy = !1, a.items = c, a.canSelectMany && (a.selectedItems = c.filter((u) => u.type !== "separator" && u.picked)), l && (a.activeItems = [l]);
      }), a.show(), Promise.resolve(e).then(void 0, (c) => {
        s(c), a.hide();
      });
    });
  }
  createQuickPick() {
    const e = this.getUI(!0);
    return new gv(e);
  }
  createInputBox() {
    const e = this.getUI(!0);
    return new Ine(e);
  }
  show(e) {
    const t = this.getUI(!0);
    this.onShowEmitter.fire();
    const i = this.controller;
    this.controller = e, i == null || i.didHide(), this.setEnabled(!0), t.leftActionBar.clear(), t.title.textContent = "", t.description1.textContent = "", t.description2.textContent = "", mn(t.widget), t.rightActionBar.clear(), t.checkAll.checked = !1, t.inputBox.placeholder = "", t.inputBox.password = !1, t.inputBox.showDecoration(yi.Ignore), t.visibleCount.setCount(0), t.count.setCount(0), mn(t.message), t.progressBar.stop(), t.list.setElements([]), t.list.matchOnDescription = !1, t.list.matchOnDetail = !1, t.list.matchOnLabel = !0, t.list.sortByLabel = !0, t.ignoreFocusOut = !1, t.inputBox.toggles = void 0;
    const n = this.options.backKeybindingLabel();
    rE.tooltip = n ? p("quickInput.backWithKeybinding", "Back ({0})", n) : p("quickInput.back", "Back"), t.container.style.display = "", this.updateLayout(), t.inputBox.setFocus(), this.quickInputTypeContext.set(e.type);
  }
  isVisible() {
    return !!this.ui && this.ui.container.style.display !== "none";
  }
  setVisibilities(e) {
    const t = this.getUI();
    t.title.style.display = e.title ? "" : "none", t.description1.style.display = e.description && (e.inputBox || e.checkAll) ? "" : "none", t.description2.style.display = e.description && !(e.inputBox || e.checkAll) ? "" : "none", t.checkAll.style.display = e.checkAll ? "" : "none", t.inputContainer.style.display = e.inputBox ? "" : "none", t.filterContainer.style.display = e.inputBox ? "" : "none", t.visibleCountContainer.style.display = e.visibleCount ? "" : "none", t.countContainer.style.display = e.count ? "" : "none", t.okContainer.style.display = e.ok ? "" : "none", t.customButtonContainer.style.display = e.customButton ? "" : "none", t.message.style.display = e.message ? "" : "none", t.progressBar.getContainer().style.display = e.progressBar ? "" : "none", t.list.display(!!e.list), t.container.classList.toggle("show-checkboxes", !!e.checkBox), t.container.classList.toggle("hidden-input", !e.inputBox && !e.description), this.updateLayout();
  }
  setEnabled(e) {
    if (e !== this.enabled) {
      this.enabled = e;
      for (const t of this.getUI().leftActionBar.viewItems)
        t.action.enabled = e;
      for (const t of this.getUI().rightActionBar.viewItems)
        t.action.enabled = e;
      this.getUI().checkAll.disabled = !e, this.getUI().inputBox.enabled = e, this.getUI().ok.enabled = e, this.getUI().list.enabled = e;
    }
  }
  hide(e) {
    var t, i;
    const n = this.controller;
    if (!n)
      return;
    n.willHide(e);
    const s = (t = this.ui) === null || t === void 0 ? void 0 : t.container, o = s && !UH(s);
    if (this.controller = null, this.onHideEmitter.fire(), s && (s.style.display = "none"), !o) {
      let a = this.previousFocusElement;
      for (; a && !a.offsetParent; )
        a = (i = a.parentElement) !== null && i !== void 0 ? i : void 0;
      a != null && a.offsetParent ? (a.focus(), this.previousFocusElement = void 0) : this.options.returnFocus();
    }
    n.didHide(e);
  }
  layout(e, t) {
    this.dimension = e, this.titleBarOffset = t, this.updateLayout();
  }
  updateLayout() {
    if (this.ui && this.isVisible()) {
      this.ui.container.style.top = `${this.titleBarOffset}px`;
      const e = this.ui.container.style, t = Math.min(this.dimension.width * 0.62, mE.MAX_WIDTH);
      e.width = t + "px", e.marginLeft = "-" + t / 2 + "px", this.ui.inputBox.layout(), this.ui.list.layout(this.dimension && this.dimension.height * 0.4);
    }
  }
  applyStyles(e) {
    this.styles = e, this.updateStyles();
  }
  updateStyles() {
    if (this.ui) {
      const { quickInputTitleBackground: e, quickInputBackground: t, quickInputForeground: i, widgetBorder: n, widgetShadow: s } = this.styles.widget;
      this.ui.titleBar.style.backgroundColor = e ?? "", this.ui.container.style.backgroundColor = t ?? "", this.ui.container.style.color = i ?? "", this.ui.container.style.border = n ? `1px solid ${n}` : "", this.ui.container.style.boxShadow = s ? `0 0 8px 2px ${s}` : "", this.ui.list.style(this.styles.list);
      const o = [];
      this.styles.pickerGroup.pickerGroupBorder && o.push(`.quick-input-list .quick-input-list-entry { border-top-color:  ${this.styles.pickerGroup.pickerGroupBorder}; }`), this.styles.pickerGroup.pickerGroupForeground && o.push(`.quick-input-list .quick-input-list-separator { color:  ${this.styles.pickerGroup.pickerGroupForeground}; }`), this.styles.pickerGroup.pickerGroupForeground && o.push(".quick-input-list .quick-input-list-separator-as-item { color: var(--vscode-descriptionForeground); }"), (this.styles.keybindingLabel.keybindingLabelBackground || this.styles.keybindingLabel.keybindingLabelBorder || this.styles.keybindingLabel.keybindingLabelBottomBorder || this.styles.keybindingLabel.keybindingLabelShadow || this.styles.keybindingLabel.keybindingLabelForeground) && (o.push(".quick-input-list .monaco-keybinding > .monaco-keybinding-key {"), this.styles.keybindingLabel.keybindingLabelBackground && o.push(`background-color: ${this.styles.keybindingLabel.keybindingLabelBackground};`), this.styles.keybindingLabel.keybindingLabelBorder && o.push(`border-color: ${this.styles.keybindingLabel.keybindingLabelBorder};`), this.styles.keybindingLabel.keybindingLabelBottomBorder && o.push(`border-bottom-color: ${this.styles.keybindingLabel.keybindingLabelBottomBorder};`), this.styles.keybindingLabel.keybindingLabelShadow && o.push(`box-shadow: inset 0 -1px 0 ${this.styles.keybindingLabel.keybindingLabelShadow};`), this.styles.keybindingLabel.keybindingLabelForeground && o.push(`color: ${this.styles.keybindingLabel.keybindingLabelForeground};`), o.push("}"));
      const a = o.join(`
`);
      a !== this.ui.styleSheet.textContent && (this.ui.styleSheet.textContent = a);
    }
  }
};
gy.MAX_WIDTH = 600;
gy = mE = Xse([
  Pk(1, ih),
  Pk(2, be),
  Pk(3, De)
], gy);
var Jse = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, hm = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
let _E = class extends N7 {
  get controller() {
    return this._controller || (this._controller = this._register(this.createController())), this._controller;
  }
  get hasController() {
    return !!this._controller;
  }
  get currentQuickInput() {
    return this.controller.currentQuickInput;
  }
  get quickAccess() {
    return this._quickAccess || (this._quickAccess = this._register(this.instantiationService.createInstance(oE))), this._quickAccess;
  }
  constructor(e, t, i, n, s) {
    super(i), this.instantiationService = e, this.contextKeyService = t, this.layoutService = n, this.configurationService = s, this._onShow = this._register(new R()), this._onHide = this._register(new R()), this.contexts = /* @__PURE__ */ new Map();
  }
  createController(e = this.layoutService, t) {
    const i = {
      idPrefix: "quickInput_",
      container: e.activeContainer,
      ignoreFocusOut: () => !1,
      backKeybindingLabel: () => {
      },
      setContextKey: (s) => this.setContextKey(s),
      linkOpenerDelegate: (s) => {
        this.instantiationService.invokeFunction((o) => {
          o.get(Ys).open(s, { allowCommands: !0, fromUserGesture: !0 });
        });
      },
      returnFocus: () => e.focus(),
      styles: this.computeStyles(),
      hoverDelegate: this._register(this.instantiationService.createInstance(aE))
    }, n = this._register(this.instantiationService.createInstance(gy, {
      ...i,
      ...t
    }));
    return n.layout(e.activeContainerDimension, e.activeContainerOffset.quickPickTop), this._register(e.onDidLayoutActiveContainer((s) => {
      we(e.activeContainer) === we(n.container) && n.layout(s, e.activeContainerOffset.quickPickTop);
    })), this._register(e.onDidChangeActiveContainer(() => {
      n.isVisible() || n.layout(e.activeContainerDimension, e.activeContainerOffset.quickPickTop);
    })), this._register(n.onShow(() => {
      this.resetContextKeys(), this._onShow.fire();
    })), this._register(n.onHide(() => {
      this.resetContextKeys(), this._onHide.fire();
    })), n;
  }
  setContextKey(e) {
    let t;
    e && (t = this.contexts.get(e), t || (t = new oe(e, !1).bindTo(this.contextKeyService), this.contexts.set(e, t))), !(t && t.get()) && (this.resetContextKeys(), t == null || t.set(!0));
  }
  resetContextKeys() {
    this.contexts.forEach((e) => {
      e.get() && e.reset();
    });
  }
  pick(e, t = {}, i = at.None) {
    return this.controller.pick(e, t, i);
  }
  createQuickPick() {
    return this.controller.createQuickPick();
  }
  createInputBox() {
    return this.controller.createInputBox();
  }
  updateStyles() {
    this.hasController && this.controller.applyStyles(this.computeStyles());
  }
  computeStyles() {
    return {
      widget: {
        quickInputBackground: le(hP),
        quickInputForeground: le(H9),
        quickInputTitleBackground: le(V9),
        widgetBorder: le(TV),
        widgetShadow: le(jl)
      },
      inputBox: ZS,
      toggle: GS,
      countBadge: Nz,
      button: Zie,
      progressBar: Yie,
      keybindingLabel: Gie,
      list: sg({
        listBackground: hP,
        listFocusBackground: nc,
        listFocusForeground: ic,
        // Look like focused when inactive.
        listInactiveFocusForeground: ic,
        listInactiveSelectionIconForeground: Zg,
        listInactiveFocusBackground: nc,
        listFocusOutline: Gt,
        listInactiveFocusOutline: Gt
      }),
      pickerGroup: {
        pickerGroupBorder: le(z9),
        pickerGroupForeground: le(OV)
      }
    };
  }
};
_E = Jse([
  hm(0, be),
  hm(1, De),
  hm(2, $i),
  hm(3, ih),
  hm(4, Ge)
], _E);
var f3 = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, $h = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
let vE = class extends _E {
  constructor(e, t, i, n, s, o) {
    super(t, i, n, new bI(e.getContainerDomNode(), s), o), this.host = void 0;
    const a = ap.get(e);
    if (a) {
      const l = a.widget;
      this.host = {
        _serviceBrand: void 0,
        get mainContainer() {
          return l.getDomNode();
        },
        getContainer() {
          return l.getDomNode();
        },
        whenContainerStylesLoaded() {
        },
        get containers() {
          return [l.getDomNode()];
        },
        get activeContainer() {
          return l.getDomNode();
        },
        get mainContainerDimension() {
          return e.getLayoutInfo();
        },
        get activeContainerDimension() {
          return e.getLayoutInfo();
        },
        get onDidLayoutMainContainer() {
          return e.onDidLayoutChange;
        },
        get onDidLayoutActiveContainer() {
          return e.onDidLayoutChange;
        },
        get onDidLayoutContainer() {
          return ne.map(e.onDidLayoutChange, (d) => ({ container: l.getDomNode(), dimension: d }));
        },
        get onDidChangeActiveContainer() {
          return ne.None;
        },
        get onDidAddContainer() {
          return ne.None;
        },
        get mainContainerOffset() {
          return { top: 0, quickPickTop: 0 };
        },
        get activeContainerOffset() {
          return { top: 0, quickPickTop: 0 };
        },
        focus: () => e.focus()
      };
    } else
      this.host = void 0;
  }
  createController() {
    return super.createController(this.host);
  }
};
vE = f3([
  $h(1, be),
  $h(2, De),
  $h(3, $i),
  $h(4, ht),
  $h(5, Ge)
], vE);
let bE = class {
  get activeService() {
    const e = this.codeEditorService.getFocusedCodeEditor();
    if (!e)
      throw new Error("Quick input service needs a focused editor to work.");
    let t = this.mapEditorToService.get(e);
    if (!t) {
      const i = t = this.instantiationService.createInstance(vE, e);
      this.mapEditorToService.set(e, t), Ff(e.onDidDispose)(() => {
        i.dispose(), this.mapEditorToService.delete(e);
      });
    }
    return t;
  }
  get currentQuickInput() {
    return this.activeService.currentQuickInput;
  }
  get quickAccess() {
    return this.activeService.quickAccess;
  }
  constructor(e, t) {
    this.instantiationService = e, this.codeEditorService = t, this.mapEditorToService = /* @__PURE__ */ new Map();
  }
  pick(e, t = {}, i = at.None) {
    return this.activeService.pick(e, t, i);
  }
  createQuickPick() {
    return this.activeService.createQuickPick();
  }
  createInputBox() {
    return this.activeService.createInputBox();
  }
};
bE = f3([
  $h(0, be),
  $h(1, ht)
], bE);
class ap {
  static get(e) {
    return e.getContribution(ap.ID);
  }
  constructor(e) {
    this.editor = e, this.widget = new hL(this.editor);
  }
  dispose() {
    this.widget.dispose();
  }
}
ap.ID = "editor.controller.quickInput";
class hL {
  constructor(e) {
    this.codeEditor = e, this.domNode = document.createElement("div"), this.codeEditor.addOverlayWidget(this);
  }
  getId() {
    return hL.ID;
  }
  getDomNode() {
    return this.domNode;
  }
  getPosition() {
    return {
      preference: 2
      /* OverlayWidgetPositionPreference.TOP_CENTER */
    };
  }
  dispose() {
    this.codeEditor.removeOverlayWidget(this);
  }
}
hL.ID = "editor.contrib.quickInputWidget";
gt(
  ap.ID,
  ap,
  4
  /* EditorContributionInstantiation.Lazy */
);
class eoe {
  constructor(e, t, i, n, s) {
    this._parsedThemeRuleBrand = void 0, this.token = e, this.index = t, this.fontStyle = i, this.foreground = n, this.background = s;
  }
}
function toe(r) {
  if (!r || !Array.isArray(r))
    return [];
  const e = [];
  let t = 0;
  for (let i = 0, n = r.length; i < n; i++) {
    const s = r[i];
    let o = -1;
    if (typeof s.fontStyle == "string") {
      o = 0;
      const d = s.fontStyle.split(" ");
      for (let c = 0, h = d.length; c < h; c++)
        switch (d[c]) {
          case "italic":
            o = o | 1;
            break;
          case "bold":
            o = o | 2;
            break;
          case "underline":
            o = o | 4;
            break;
          case "strikethrough":
            o = o | 8;
            break;
        }
    }
    let a = null;
    typeof s.foreground == "string" && (a = s.foreground);
    let l = null;
    typeof s.background == "string" && (l = s.background), e[t++] = new eoe(s.token || "", i, o, a, l);
  }
  return e;
}
function ioe(r, e) {
  r.sort((c, h) => {
    const u = aoe(c.token, h.token);
    return u !== 0 ? u : c.index - h.index;
  });
  let t = 0, i = "000000", n = "ffffff";
  for (; r.length >= 1 && r[0].token === ""; ) {
    const c = r.shift();
    c.fontStyle !== -1 && (t = c.fontStyle), c.foreground !== null && (i = c.foreground), c.background !== null && (n = c.background);
  }
  const s = new soe();
  for (const c of e)
    s.getId(c);
  const o = s.getId(i), a = s.getId(n), l = new FM(t, o, a), d = new WM(l);
  for (let c = 0, h = r.length; c < h; c++) {
    const u = r[c];
    d.insert(u.token, u.fontStyle, s.getId(u.foreground), s.getId(u.background));
  }
  return new p3(s, d);
}
const noe = /^#?([0-9A-Fa-f]{6})([0-9A-Fa-f]{2})?$/;
class soe {
  constructor() {
    this._lastColorId = 0, this._id2color = [], this._color2id = /* @__PURE__ */ new Map();
  }
  getId(e) {
    if (e === null)
      return 0;
    const t = e.match(noe);
    if (!t)
      throw new Error("Illegal value for token color: " + e);
    e = t[1].toUpperCase();
    let i = this._color2id.get(e);
    return i || (i = ++this._lastColorId, this._color2id.set(e, i), this._id2color[i] = z.fromHex("#" + e), i);
  }
  getColorMap() {
    return this._id2color.slice(0);
  }
}
class p3 {
  static createFromRawTokenTheme(e, t) {
    return this.createFromParsedTokenTheme(toe(e), t);
  }
  static createFromParsedTokenTheme(e, t) {
    return ioe(e, t);
  }
  constructor(e, t) {
    this._colorMap = e, this._root = t, this._cache = /* @__PURE__ */ new Map();
  }
  getColorMap() {
    return this._colorMap.getColorMap();
  }
  _match(e) {
    return this._root.match(e);
  }
  match(e, t) {
    let i = this._cache.get(t);
    if (typeof i > "u") {
      const n = this._match(t), s = roe(t);
      i = (n.metadata | s << 8) >>> 0, this._cache.set(t, i);
    }
    return (i | e << 0) >>> 0;
  }
}
const ooe = /\b(comment|string|regex|regexp)\b/;
function roe(r) {
  const e = r.match(ooe);
  if (!e)
    return 0;
  switch (e[1]) {
    case "comment":
      return 1;
    case "string":
      return 2;
    case "regex":
      return 3;
    case "regexp":
      return 3;
  }
  throw new Error("Unexpected match for standard token type!");
}
function aoe(r, e) {
  return r < e ? -1 : r > e ? 1 : 0;
}
class FM {
  constructor(e, t, i) {
    this._themeTrieElementRuleBrand = void 0, this._fontStyle = e, this._foreground = t, this._background = i, this.metadata = (this._fontStyle << 11 | this._foreground << 15 | this._background << 24) >>> 0;
  }
  clone() {
    return new FM(this._fontStyle, this._foreground, this._background);
  }
  acceptOverwrite(e, t, i) {
    e !== -1 && (this._fontStyle = e), t !== 0 && (this._foreground = t), i !== 0 && (this._background = i), this.metadata = (this._fontStyle << 11 | this._foreground << 15 | this._background << 24) >>> 0;
  }
}
class WM {
  constructor(e) {
    this._themeTrieElementBrand = void 0, this._mainRule = e, this._children = /* @__PURE__ */ new Map();
  }
  match(e) {
    if (e === "")
      return this._mainRule;
    const t = e.indexOf(".");
    let i, n;
    t === -1 ? (i = e, n = "") : (i = e.substring(0, t), n = e.substring(t + 1));
    const s = this._children.get(i);
    return typeof s < "u" ? s.match(n) : this._mainRule;
  }
  insert(e, t, i, n) {
    if (e === "") {
      this._mainRule.acceptOverwrite(t, i, n);
      return;
    }
    const s = e.indexOf(".");
    let o, a;
    s === -1 ? (o = e, a = "") : (o = e.substring(0, s), a = e.substring(s + 1));
    let l = this._children.get(o);
    typeof l > "u" && (l = new WM(this._mainRule.clone()), this._children.set(o, l)), l.insert(a, t, i, n);
  }
}
function loe(r) {
  const e = [];
  for (let t = 1, i = r.length; t < i; t++) {
    const n = r[t];
    e[t] = `.mtk${t} { color: ${n}; }`;
  }
  return e.push(".mtki { font-style: italic; }"), e.push(".mtkb { font-weight: bold; }"), e.push(".mtku { text-decoration: underline; text-underline-position: under; }"), e.push(".mtks { text-decoration: line-through; }"), e.push(".mtks.mtku { text-decoration: underline line-through; text-underline-position: under; }"), e.join(`
`);
}
const doe = {
  base: "vs",
  inherit: !1,
  rules: [
    { token: "", foreground: "000000", background: "fffffe" },
    { token: "invalid", foreground: "cd3131" },
    { token: "emphasis", fontStyle: "italic" },
    { token: "strong", fontStyle: "bold" },
    { token: "variable", foreground: "001188" },
    { token: "variable.predefined", foreground: "4864AA" },
    { token: "constant", foreground: "dd0000" },
    { token: "comment", foreground: "008000" },
    { token: "number", foreground: "098658" },
    { token: "number.hex", foreground: "3030c0" },
    { token: "regexp", foreground: "800000" },
    { token: "annotation", foreground: "808080" },
    { token: "type", foreground: "008080" },
    { token: "delimiter", foreground: "000000" },
    { token: "delimiter.html", foreground: "383838" },
    { token: "delimiter.xml", foreground: "0000FF" },
    { token: "tag", foreground: "800000" },
    { token: "tag.id.pug", foreground: "4F76AC" },
    { token: "tag.class.pug", foreground: "4F76AC" },
    { token: "meta.scss", foreground: "800000" },
    { token: "metatag", foreground: "e00000" },
    { token: "metatag.content.html", foreground: "FF0000" },
    { token: "metatag.html", foreground: "808080" },
    { token: "metatag.xml", foreground: "808080" },
    { token: "metatag.php", fontStyle: "bold" },
    { token: "key", foreground: "863B00" },
    { token: "string.key.json", foreground: "A31515" },
    { token: "string.value.json", foreground: "0451A5" },
    { token: "attribute.name", foreground: "FF0000" },
    { token: "attribute.value", foreground: "0451A5" },
    { token: "attribute.value.number", foreground: "098658" },
    { token: "attribute.value.unit", foreground: "098658" },
    { token: "attribute.value.html", foreground: "0000FF" },
    { token: "attribute.value.xml", foreground: "0000FF" },
    { token: "string", foreground: "A31515" },
    { token: "string.html", foreground: "0000FF" },
    { token: "string.sql", foreground: "FF0000" },
    { token: "string.yaml", foreground: "0451A5" },
    { token: "keyword", foreground: "0000FF" },
    { token: "keyword.json", foreground: "0451A5" },
    { token: "keyword.flow", foreground: "AF00DB" },
    { token: "keyword.flow.scss", foreground: "0000FF" },
    { token: "operator.scss", foreground: "666666" },
    { token: "operator.sql", foreground: "778899" },
    { token: "operator.swift", foreground: "666666" },
    { token: "predefined.sql", foreground: "C700C7" }
  ],
  colors: {
    [Gi]: "#FFFFFE",
    [No]: "#000000",
    [IV]: "#E5EBF1",
    [mb]: "#D3D3D3",
    [_b]: "#939393",
    [b1]: "#ADD6FF4D"
  }
}, coe = {
  base: "vs-dark",
  inherit: !1,
  rules: [
    { token: "", foreground: "D4D4D4", background: "1E1E1E" },
    { token: "invalid", foreground: "f44747" },
    { token: "emphasis", fontStyle: "italic" },
    { token: "strong", fontStyle: "bold" },
    { token: "variable", foreground: "74B0DF" },
    { token: "variable.predefined", foreground: "4864AA" },
    { token: "variable.parameter", foreground: "9CDCFE" },
    { token: "constant", foreground: "569CD6" },
    { token: "comment", foreground: "608B4E" },
    { token: "number", foreground: "B5CEA8" },
    { token: "number.hex", foreground: "5BB498" },
    { token: "regexp", foreground: "B46695" },
    { token: "annotation", foreground: "cc6666" },
    { token: "type", foreground: "3DC9B0" },
    { token: "delimiter", foreground: "DCDCDC" },
    { token: "delimiter.html", foreground: "808080" },
    { token: "delimiter.xml", foreground: "808080" },
    { token: "tag", foreground: "569CD6" },
    { token: "tag.id.pug", foreground: "4F76AC" },
    { token: "tag.class.pug", foreground: "4F76AC" },
    { token: "meta.scss", foreground: "A79873" },
    { token: "meta.tag", foreground: "CE9178" },
    { token: "metatag", foreground: "DD6A6F" },
    { token: "metatag.content.html", foreground: "9CDCFE" },
    { token: "metatag.html", foreground: "569CD6" },
    { token: "metatag.xml", foreground: "569CD6" },
    { token: "metatag.php", fontStyle: "bold" },
    { token: "key", foreground: "9CDCFE" },
    { token: "string.key.json", foreground: "9CDCFE" },
    { token: "string.value.json", foreground: "CE9178" },
    { token: "attribute.name", foreground: "9CDCFE" },
    { token: "attribute.value", foreground: "CE9178" },
    { token: "attribute.value.number.css", foreground: "B5CEA8" },
    { token: "attribute.value.unit.css", foreground: "B5CEA8" },
    { token: "attribute.value.hex.css", foreground: "D4D4D4" },
    { token: "string", foreground: "CE9178" },
    { token: "string.sql", foreground: "FF0000" },
    { token: "keyword", foreground: "569CD6" },
    { token: "keyword.flow", foreground: "C586C0" },
    { token: "keyword.json", foreground: "CE9178" },
    { token: "keyword.flow.scss", foreground: "569CD6" },
    { token: "operator.scss", foreground: "909090" },
    { token: "operator.sql", foreground: "778899" },
    { token: "operator.swift", foreground: "909090" },
    { token: "predefined.sql", foreground: "FF00FF" }
  ],
  colors: {
    [Gi]: "#1E1E1E",
    [No]: "#D4D4D4",
    [IV]: "#3A3D41",
    [mb]: "#404040",
    [_b]: "#707070",
    [b1]: "#ADD6FF26"
  }
}, hoe = {
  base: "hc-black",
  inherit: !1,
  rules: [
    { token: "", foreground: "FFFFFF", background: "000000" },
    { token: "invalid", foreground: "f44747" },
    { token: "emphasis", fontStyle: "italic" },
    { token: "strong", fontStyle: "bold" },
    { token: "variable", foreground: "1AEBFF" },
    { token: "variable.parameter", foreground: "9CDCFE" },
    { token: "constant", foreground: "569CD6" },
    { token: "comment", foreground: "608B4E" },
    { token: "number", foreground: "FFFFFF" },
    { token: "regexp", foreground: "C0C0C0" },
    { token: "annotation", foreground: "569CD6" },
    { token: "type", foreground: "3DC9B0" },
    { token: "delimiter", foreground: "FFFF00" },
    { token: "delimiter.html", foreground: "FFFF00" },
    { token: "tag", foreground: "569CD6" },
    { token: "tag.id.pug", foreground: "4F76AC" },
    { token: "tag.class.pug", foreground: "4F76AC" },
    { token: "meta", foreground: "D4D4D4" },
    { token: "meta.tag", foreground: "CE9178" },
    { token: "metatag", foreground: "569CD6" },
    { token: "metatag.content.html", foreground: "1AEBFF" },
    { token: "metatag.html", foreground: "569CD6" },
    { token: "metatag.xml", foreground: "569CD6" },
    { token: "metatag.php", fontStyle: "bold" },
    { token: "key", foreground: "9CDCFE" },
    { token: "string.key", foreground: "9CDCFE" },
    { token: "string.value", foreground: "CE9178" },
    { token: "attribute.name", foreground: "569CD6" },
    { token: "attribute.value", foreground: "3FF23F" },
    { token: "string", foreground: "CE9178" },
    { token: "string.sql", foreground: "FF0000" },
    { token: "keyword", foreground: "569CD6" },
    { token: "keyword.flow", foreground: "C586C0" },
    { token: "operator.sql", foreground: "778899" },
    { token: "operator.swift", foreground: "909090" },
    { token: "predefined.sql", foreground: "FF00FF" }
  ],
  colors: {
    [Gi]: "#000000",
    [No]: "#FFFFFF",
    [mb]: "#FFFFFF",
    [_b]: "#FFFFFF"
  }
}, uoe = {
  base: "hc-light",
  inherit: !1,
  rules: [
    { token: "", foreground: "292929", background: "FFFFFF" },
    { token: "invalid", foreground: "B5200D" },
    { token: "emphasis", fontStyle: "italic" },
    { token: "strong", fontStyle: "bold" },
    { token: "variable", foreground: "264F70" },
    { token: "variable.predefined", foreground: "4864AA" },
    { token: "constant", foreground: "dd0000" },
    { token: "comment", foreground: "008000" },
    { token: "number", foreground: "098658" },
    { token: "number.hex", foreground: "3030c0" },
    { token: "regexp", foreground: "800000" },
    { token: "annotation", foreground: "808080" },
    { token: "type", foreground: "008080" },
    { token: "delimiter", foreground: "000000" },
    { token: "delimiter.html", foreground: "383838" },
    { token: "tag", foreground: "800000" },
    { token: "tag.id.pug", foreground: "4F76AC" },
    { token: "tag.class.pug", foreground: "4F76AC" },
    { token: "meta.scss", foreground: "800000" },
    { token: "metatag", foreground: "e00000" },
    { token: "metatag.content.html", foreground: "B5200D" },
    { token: "metatag.html", foreground: "808080" },
    { token: "metatag.xml", foreground: "808080" },
    { token: "metatag.php", fontStyle: "bold" },
    { token: "key", foreground: "863B00" },
    { token: "string.key.json", foreground: "A31515" },
    { token: "string.value.json", foreground: "0451A5" },
    { token: "attribute.name", foreground: "264F78" },
    { token: "attribute.value", foreground: "0451A5" },
    { token: "string", foreground: "A31515" },
    { token: "string.sql", foreground: "B5200D" },
    { token: "keyword", foreground: "0000FF" },
    { token: "keyword.flow", foreground: "AF00DB" },
    { token: "operator.sql", foreground: "778899" },
    { token: "operator.swift", foreground: "666666" },
    { token: "predefined.sql", foreground: "C700C7" }
  ],
  colors: {
    [Gi]: "#FFFFFF",
    [No]: "#292929",
    [mb]: "#292929",
    [_b]: "#292929"
  }
}, goe = {
  IconContribution: "base.contributions.icons"
};
var xF;
(function(r) {
  function e(t, i) {
    let n = t.defaults;
    for (; Le.isThemeIcon(n); ) {
      const s = ag.getIcon(n.id);
      if (!s)
        return;
      n = s.defaults;
    }
    return n;
  }
  r.getDefinition = e;
})(xF || (xF = {}));
var IF;
(function(r) {
  function e(i) {
    return {
      weight: i.weight,
      style: i.style,
      src: i.src.map((n) => ({ format: n.format, location: n.location.toString() }))
    };
  }
  r.toJSONObject = e;
  function t(i) {
    const n = (s) => Ws(s) ? s : void 0;
    if (i && Array.isArray(i.src) && i.src.every((s) => Ws(s.format) && Ws(s.location)))
      return {
        weight: n(i.weight),
        style: n(i.style),
        src: i.src.map((s) => ({ format: s.format, location: Ee.parse(s.location) }))
      };
  }
  r.fromJSONObject = t;
})(IF || (IF = {}));
class foe {
  constructor() {
    this._onDidChange = new R(), this.onDidChange = this._onDidChange.event, this.iconSchema = {
      definitions: {
        icons: {
          type: "object",
          properties: {
            fontId: { type: "string", description: p("iconDefinition.fontId", "The id of the font to use. If not set, the font that is defined first is used.") },
            fontCharacter: { type: "string", description: p("iconDefinition.fontCharacter", "The font character associated with the icon definition.") }
          },
          additionalProperties: !1,
          defaultSnippets: [{ body: { fontCharacter: "\\\\e030" } }]
        }
      },
      type: "object",
      properties: {}
    }, this.iconReferenceSchema = { type: "string", pattern: `^${Le.iconNameExpression}$`, enum: [], enumDescriptions: [] }, this.iconsById = {}, this.iconFontsById = {};
  }
  registerIcon(e, t, i, n) {
    const s = this.iconsById[e];
    if (s) {
      if (i && !s.description) {
        s.description = i, this.iconSchema.properties[e].markdownDescription = `${i} $(${e})`;
        const l = this.iconReferenceSchema.enum.indexOf(e);
        l !== -1 && (this.iconReferenceSchema.enumDescriptions[l] = i), this._onDidChange.fire();
      }
      return s;
    }
    const o = { id: e, description: i, defaults: t, deprecationMessage: n };
    this.iconsById[e] = o;
    const a = { $ref: "#/definitions/icons" };
    return n && (a.deprecationMessage = n), i && (a.markdownDescription = `${i}: $(${e})`), this.iconSchema.properties[e] = a, this.iconReferenceSchema.enum.push(e), this.iconReferenceSchema.enumDescriptions.push(i || ""), this._onDidChange.fire(), { id: e };
  }
  getIcons() {
    return Object.keys(this.iconsById).map((e) => this.iconsById[e]);
  }
  getIcon(e) {
    return this.iconsById[e];
  }
  getIconSchema() {
    return this.iconSchema;
  }
  toString() {
    const e = (s, o) => s.id.localeCompare(o.id), t = (s) => {
      for (; Le.isThemeIcon(s.defaults); )
        s = this.iconsById[s.defaults.id];
      return `codicon codicon-${s ? s.id : ""}`;
    }, i = [];
    i.push("| preview     | identifier                        | default codicon ID                | description"), i.push("| ----------- | --------------------------------- | --------------------------------- | --------------------------------- |");
    const n = Object.keys(this.iconsById).map((s) => this.iconsById[s]);
    for (const s of n.filter((o) => !!o.description).sort(e))
      i.push(`|<i class="${t(s)}"></i>|${s.id}|${Le.isThemeIcon(s.defaults) ? s.defaults.id : s.id}|${s.description || ""}|`);
    i.push("| preview     | identifier                        "), i.push("| ----------- | --------------------------------- |");
    for (const s of n.filter((o) => !Le.isThemeIcon(o.defaults)).sort(e))
      i.push(`|<i class="${t(s)}"></i>|${s.id}|`);
    return i.join(`
`);
  }
}
const ag = new foe();
si.add(goe.IconContribution, ag);
function hi(r, e, t, i) {
  return ag.registerIcon(r, e, t, i);
}
function m3() {
  return ag;
}
function poe() {
  const r = lH();
  for (const e in r) {
    const t = "\\" + r[e].toString(16);
    ag.registerIcon(e, { fontCharacter: t });
  }
}
poe();
const _3 = "vscode://schemas/icons", v3 = si.as(w0.JSONContribution);
v3.registerSchema(_3, ag.getIconSchema());
const EF = new xt(() => v3.notifySchemaChanged(_3), 200);
ag.onDidChange(() => {
  EF.isScheduled() || EF.schedule();
});
const b3 = hi("widget-close", me.close, p("widgetClose", "Icon for the close action in widgets."));
hi("goto-previous-location", me.arrowUp, p("previousChangeIcon", "Icon for goto previous editor location."));
hi("goto-next-location", me.arrowDown, p("nextChangeIcon", "Icon for goto next editor location."));
Le.modify(me.sync, "spin");
Le.modify(me.loading, "spin");
function moe(r) {
  const e = new q(), t = e.add(new R()), i = m3();
  return e.add(i.onDidChange(() => t.fire())), r && e.add(r.onDidProductIconThemeChange(() => t.fire())), {
    dispose: () => e.dispose(),
    onDidChange: t.event,
    getCSS() {
      const n = r ? r.getProductIconTheme() : new C3(), s = {}, o = [], a = [];
      for (const l of i.getIcons()) {
        const d = n.getIcon(l);
        if (!d)
          continue;
        const c = d.font, h = `--vscode-icon-${l.id}-font-family`, u = `--vscode-icon-${l.id}-content`;
        c ? (s[c.id] = c.definition, a.push(`${h}: ${MD(c.id)};`, `${u}: '${d.fontCharacter}';`), o.push(`.codicon-${l.id}:before { content: '${d.fontCharacter}'; font-family: ${MD(c.id)}; }`)) : (a.push(`${u}: '${d.fontCharacter}'; ${h}: 'codicon';`), o.push(`.codicon-${l.id}:before { content: '${d.fontCharacter}'; }`));
      }
      for (const l in s) {
        const d = s[l], c = d.weight ? `font-weight: ${d.weight};` : "", h = d.style ? `font-style: ${d.style};` : "", u = d.src.map((g) => `${hd(g.location)} format('${g.format}')`).join(", ");
        o.push(`@font-face { src: ${u}; font-family: ${MD(l)};${c}${h} font-display: block; }`);
      }
      return o.push(`:root { ${a.join(" ")} }`), o.join(`
`);
    }
  };
}
class C3 {
  getIcon(e) {
    const t = m3();
    let i = e.defaults;
    for (; Le.isThemeIcon(i); ) {
      const n = t.getIcon(i.id);
      if (!n)
        return;
      i = n.defaults;
    }
    return i;
  }
}
const Wl = "vs", Nf = "vs-dark", hu = "hc-black", uu = "hc-light", w3 = si.as(DV.ColorContribution), _oe = si.as(UV.ThemingContribution);
class S3 {
  constructor(e, t) {
    this.semanticHighlighting = !1, this.themeData = t;
    const i = t.base;
    e.length > 0 ? (jw(e) ? this.id = e : this.id = i + " " + e, this.themeName = e) : (this.id = i, this.themeName = i), this.colors = null, this.defaultColors = /* @__PURE__ */ Object.create(null), this._tokenTheme = null;
  }
  get base() {
    return this.themeData.base;
  }
  notifyBaseUpdated() {
    this.themeData.inherit && (this.colors = null, this._tokenTheme = null);
  }
  getColors() {
    if (!this.colors) {
      const e = /* @__PURE__ */ new Map();
      for (const t in this.themeData.colors)
        e.set(t, z.fromHex(this.themeData.colors[t]));
      if (this.themeData.inherit) {
        const t = CE(this.themeData.base);
        for (const i in t.colors)
          e.has(i) || e.set(i, z.fromHex(t.colors[i]));
      }
      this.colors = e;
    }
    return this.colors;
  }
  getColor(e, t) {
    const i = this.getColors().get(e);
    if (i)
      return i;
    if (t !== !1)
      return this.getDefault(e);
  }
  getDefault(e) {
    let t = this.defaultColors[e];
    return t || (t = w3.resolveDefaultColor(e, this), this.defaultColors[e] = t, t);
  }
  defines(e) {
    return this.getColors().has(e);
  }
  get type() {
    switch (this.base) {
      case Wl:
        return Mo.LIGHT;
      case hu:
        return Mo.HIGH_CONTRAST_DARK;
      case uu:
        return Mo.HIGH_CONTRAST_LIGHT;
      default:
        return Mo.DARK;
    }
  }
  get tokenTheme() {
    if (!this._tokenTheme) {
      let e = [], t = [];
      if (this.themeData.inherit) {
        const s = CE(this.themeData.base);
        e = s.rules, s.encodedTokensColors && (t = s.encodedTokensColors);
      }
      const i = this.themeData.colors["editor.foreground"], n = this.themeData.colors["editor.background"];
      if (i || n) {
        const s = { token: "" };
        i && (s.foreground = i), n && (s.background = n), e.push(s);
      }
      e = e.concat(this.themeData.rules), this.themeData.encodedTokensColors && (t = this.themeData.encodedTokensColors), this._tokenTheme = p3.createFromRawTokenTheme(e, t);
    }
    return this._tokenTheme;
  }
  getTokenStyleMetadata(e, t, i) {
    const s = this.tokenTheme._match([e].concat(t).join(".")).metadata, o = yn.getForeground(s), a = yn.getFontStyle(s);
    return {
      foreground: o,
      italic: !!(a & 1),
      bold: !!(a & 2),
      underline: !!(a & 4),
      strikethrough: !!(a & 8)
    };
  }
}
function jw(r) {
  return r === Wl || r === Nf || r === hu || r === uu;
}
function CE(r) {
  switch (r) {
    case Wl:
      return doe;
    case Nf:
      return coe;
    case hu:
      return hoe;
    case uu:
      return uoe;
  }
}
function UC(r) {
  const e = CE(r);
  return new S3(r, e);
}
class voe extends P {
  constructor() {
    super(), this._onColorThemeChange = this._register(new R()), this.onDidColorThemeChange = this._onColorThemeChange.event, this._onProductIconThemeChange = this._register(new R()), this.onDidProductIconThemeChange = this._onProductIconThemeChange.event, this._environment = /* @__PURE__ */ Object.create(null), this._builtInProductIconTheme = new C3(), this._autoDetectHighContrast = !0, this._knownThemes = /* @__PURE__ */ new Map(), this._knownThemes.set(Wl, UC(Wl)), this._knownThemes.set(Nf, UC(Nf)), this._knownThemes.set(hu, UC(hu)), this._knownThemes.set(uu, UC(uu));
    const e = this._register(moe(this));
    this._codiconCSS = e.getCSS(), this._themeCSS = "", this._allCSS = `${this._codiconCSS}
${this._themeCSS}`, this._globalStyleElement = null, this._styleElements = [], this._colorMapOverride = null, this.setTheme(Wl), this._onOSSchemeChanged(), this._register(e.onDidChange(() => {
      this._codiconCSS = e.getCSS(), this._updateCSS();
    })), yH(Dt, "(forced-colors: active)", () => {
      this._onOSSchemeChanged();
    });
  }
  registerEditorContainer(e) {
    return uS(e) ? this._registerShadowDomContainer(e) : this._registerRegularEditorContainer();
  }
  _registerRegularEditorContainer() {
    return this._globalStyleElement || (this._globalStyleElement = fo(void 0, (e) => {
      e.className = "monaco-colors", e.textContent = this._allCSS;
    }), this._styleElements.push(this._globalStyleElement)), P.None;
  }
  _registerShadowDomContainer(e) {
    const t = fo(e, (i) => {
      i.className = "monaco-colors", i.textContent = this._allCSS;
    });
    return this._styleElements.push(t), {
      dispose: () => {
        for (let i = 0; i < this._styleElements.length; i++)
          if (this._styleElements[i] === t) {
            this._styleElements.splice(i, 1);
            return;
          }
      }
    };
  }
  defineTheme(e, t) {
    if (!/^[a-z0-9\-]+$/i.test(e))
      throw new Error("Illegal theme name!");
    if (!jw(t.base) && !jw(e))
      throw new Error("Illegal theme base!");
    this._knownThemes.set(e, new S3(e, t)), jw(e) && this._knownThemes.forEach((i) => {
      i.base === e && i.notifyBaseUpdated();
    }), this._theme.themeName === e && this.setTheme(e);
  }
  getColorTheme() {
    return this._theme;
  }
  setColorMapOverride(e) {
    this._colorMapOverride = e, this._updateThemeOrColorMap();
  }
  setTheme(e) {
    let t;
    this._knownThemes.has(e) ? t = this._knownThemes.get(e) : t = this._knownThemes.get(Wl), this._updateActualTheme(t);
  }
  _updateActualTheme(e) {
    !e || this._theme === e || (this._theme = e, this._updateThemeOrColorMap());
  }
  _onOSSchemeChanged() {
    if (this._autoDetectHighContrast) {
      const e = Dt.matchMedia("(forced-colors: active)").matches;
      if (e !== jr(this._theme.type)) {
        let t;
        jf(this._theme.type) ? t = e ? hu : Nf : t = e ? uu : Wl, this._updateActualTheme(this._knownThemes.get(t));
      }
    }
  }
  setAutoDetectHighContrast(e) {
    this._autoDetectHighContrast = e, this._onOSSchemeChanged();
  }
  _updateThemeOrColorMap() {
    const e = [], t = {}, i = {
      addRule: (o) => {
        t[o] || (e.push(o), t[o] = !0);
      }
    };
    _oe.getThemingParticipants().forEach((o) => o(this._theme, i, this._environment));
    const n = [];
    for (const o of w3.getColors()) {
      const a = this._theme.getColor(o.id, !0);
      a && n.push(`${v1(o.id)}: ${a.toString()};`);
    }
    i.addRule(`.monaco-editor, .monaco-diff-editor, .monaco-component { ${n.join(`
`)} }`);
    const s = this._colorMapOverride || this._theme.tokenTheme.getColorMap();
    i.addRule(loe(s)), this._themeCSS = e.join(`
`), this._updateCSS(), ri.setColorMap(s), this._onColorThemeChange.fire(this._theme);
  }
  _updateCSS() {
    this._allCSS = `${this._codiconCSS}
${this._themeCSS}`, this._styleElements.forEach((e) => e.textContent = this._allCSS);
  }
  getFileIconTheme() {
    return {
      hasFileIcons: !1,
      hasFolderIcons: !1,
      hidesExplorerArrows: !1
    };
  }
  getProductIconTheme() {
    return this._builtInProductIconTheme;
  }
}
const wo = et("themeService");
var boe = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Ok = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
let wE = class extends P {
  constructor(e, t, i) {
    super(), this._contextKeyService = e, this._layoutService = t, this._configurationService = i, this._accessibilitySupport = 0, this._onDidChangeScreenReaderOptimized = new R(), this._onDidChangeReducedMotion = new R(), this._accessibilityModeEnabledContext = ub.bindTo(this._contextKeyService);
    const n = () => this._accessibilityModeEnabledContext.set(this.isScreenReaderOptimized());
    this._register(this._configurationService.onDidChangeConfiguration((o) => {
      o.affectsConfiguration("editor.accessibilitySupport") && (n(), this._onDidChangeScreenReaderOptimized.fire()), o.affectsConfiguration("workbench.reduceMotion") && (this._configMotionReduced = this._configurationService.getValue("workbench.reduceMotion"), this._onDidChangeReducedMotion.fire());
    })), n(), this._register(this.onDidChangeScreenReaderOptimized(() => n()));
    const s = Dt.matchMedia("(prefers-reduced-motion: reduce)");
    this._systemMotionReduced = s.matches, this._configMotionReduced = this._configurationService.getValue("workbench.reduceMotion"), this.initReducedMotionListeners(s);
  }
  initReducedMotionListeners(e) {
    this._register(W(e, "change", () => {
      this._systemMotionReduced = e.matches, this._configMotionReduced === "auto" && this._onDidChangeReducedMotion.fire();
    }));
    const t = () => {
      const i = this.isMotionReduced();
      this._layoutService.mainContainer.classList.toggle("reduce-motion", i), this._layoutService.mainContainer.classList.toggle("enable-motion", !i);
    };
    t(), this._register(this.onDidChangeReducedMotion(() => t()));
  }
  get onDidChangeScreenReaderOptimized() {
    return this._onDidChangeScreenReaderOptimized.event;
  }
  isScreenReaderOptimized() {
    const e = this._configurationService.getValue("editor.accessibilitySupport");
    return e === "on" || e === "auto" && this._accessibilitySupport === 2;
  }
  get onDidChangeReducedMotion() {
    return this._onDidChangeReducedMotion.event;
  }
  isMotionReduced() {
    const e = this._configMotionReduced;
    return e === "on" || e === "auto" && this._systemMotionReduced;
  }
  getAccessibilitySupport() {
    return this._accessibilitySupport;
  }
};
wE = boe([
  Ok(0, De),
  Ok(1, ih),
  Ok(2, Ge)
], wE);
var uL = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Ya = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, Mg, Wd;
let SE = class {
  constructor(e, t, i) {
    this._commandService = e, this._keybindingService = t, this._hiddenStates = new fy(i);
  }
  createMenu(e, t, i) {
    return new LE(e, this._hiddenStates, { emitEventsForSubmenuChanges: !1, eventDebounceDelay: 50, ...i }, this._commandService, this._keybindingService, t);
  }
  resetHiddenStates(e) {
    this._hiddenStates.reset(e);
  }
};
SE = uL([
  Ya(0, $t),
  Ya(1, _t),
  Ya(2, br)
], SE);
let fy = Mg = class {
  constructor(e) {
    this._storageService = e, this._disposables = new q(), this._onDidChange = new R(), this.onDidChange = this._onDidChange.event, this._ignoreChangeEvent = !1, this._hiddenByDefaultCache = /* @__PURE__ */ new Map();
    try {
      const t = e.get(Mg._key, 0, "{}");
      this._data = JSON.parse(t);
    } catch {
      this._data = /* @__PURE__ */ Object.create(null);
    }
    this._disposables.add(e.onDidChangeValue(0, Mg._key, this._disposables)(() => {
      if (!this._ignoreChangeEvent)
        try {
          const t = e.get(Mg._key, 0, "{}");
          this._data = JSON.parse(t);
        } catch (t) {
          console.log("FAILED to read storage after UPDATE", t);
        }
      this._onDidChange.fire();
    }));
  }
  dispose() {
    this._onDidChange.dispose(), this._disposables.dispose();
  }
  _isHiddenByDefault(e, t) {
    var i;
    return (i = this._hiddenByDefaultCache.get(`${e.id}/${t}`)) !== null && i !== void 0 ? i : !1;
  }
  setDefaultState(e, t, i) {
    this._hiddenByDefaultCache.set(`${e.id}/${t}`, i);
  }
  isHidden(e, t) {
    var i, n;
    const s = this._isHiddenByDefault(e, t), o = (n = (i = this._data[e.id]) === null || i === void 0 ? void 0 : i.includes(t)) !== null && n !== void 0 ? n : !1;
    return s ? !o : o;
  }
  updateHidden(e, t, i) {
    this._isHiddenByDefault(e, t) && (i = !i);
    const s = this._data[e.id];
    if (i)
      s ? s.indexOf(t) < 0 && s.push(t) : this._data[e.id] = [t];
    else if (s) {
      const o = s.indexOf(t);
      o >= 0 && U5(s, o), s.length === 0 && delete this._data[e.id];
    }
    this._persist();
  }
  reset(e) {
    if (e === void 0)
      this._data = /* @__PURE__ */ Object.create(null), this._persist();
    else {
      for (const { id: t } of e)
        this._data[t] && delete this._data[t];
      this._persist();
    }
  }
  _persist() {
    try {
      this._ignoreChangeEvent = !0;
      const e = JSON.stringify(this._data);
      this._storageService.store(
        Mg._key,
        e,
        0,
        0
        /* StorageTarget.USER */
      );
    } finally {
      this._ignoreChangeEvent = !1;
    }
  }
};
fy._key = "menu.hiddenCommands";
fy = Mg = uL([
  Ya(0, br)
], fy);
let yE = Wd = class {
  constructor(e, t, i, n, s, o) {
    this._id = e, this._hiddenStates = t, this._collectContextKeysForSubmenus = i, this._commandService = n, this._keybindingService = s, this._contextKeyService = o, this._menuGroups = [], this._structureContextKeys = /* @__PURE__ */ new Set(), this._preconditionContextKeys = /* @__PURE__ */ new Set(), this._toggledContextKeys = /* @__PURE__ */ new Set(), this.refresh();
  }
  get structureContextKeys() {
    return this._structureContextKeys;
  }
  get preconditionContextKeys() {
    return this._preconditionContextKeys;
  }
  get toggledContextKeys() {
    return this._toggledContextKeys;
  }
  refresh() {
    this._menuGroups.length = 0, this._structureContextKeys.clear(), this._preconditionContextKeys.clear(), this._toggledContextKeys.clear();
    const e = on.getMenuItems(this._id);
    let t;
    e.sort(Wd._compareMenuItems);
    for (const i of e) {
      const n = i.group || "";
      (!t || t[0] !== n) && (t = [n, []], this._menuGroups.push(t)), t[1].push(i), this._collectContextKeys(i);
    }
  }
  _collectContextKeys(e) {
    if (Wd._fillInKbExprKeys(e.when, this._structureContextKeys), Vg(e)) {
      if (e.command.precondition && Wd._fillInKbExprKeys(e.command.precondition, this._preconditionContextKeys), e.command.toggled) {
        const t = e.command.toggled.condition || e.command.toggled;
        Wd._fillInKbExprKeys(t, this._toggledContextKeys);
      }
    } else this._collectContextKeysForSubmenus && on.getMenuItems(e.submenu).forEach(this._collectContextKeys, this);
  }
  createActionGroups(e) {
    const t = [];
    for (const i of this._menuGroups) {
      const [n, s] = i;
      let o;
      for (const a of s)
        if (this._contextKeyService.contextMatchesRules(a.when)) {
          const l = Vg(a);
          l && this._hiddenStates.setDefaultState(this._id, a.command.id, !!a.isHiddenByDefault);
          const d = Coe(this._id, l ? a.command : a, this._hiddenStates);
          if (l) {
            const c = y3(a.command.id, a.when, this._commandService, this._keybindingService);
            (o ?? (o = [])).push(new Hs(a.command, a.alt, e, d, c, this._contextKeyService, this._commandService));
          } else {
            const c = new Wd(a.submenu, this._hiddenStates, this._collectContextKeysForSubmenus, this._commandService, this._keybindingService, this._contextKeyService).createActionGroups(e), h = Oi.join(...c.map((u) => u[1]));
            h.length > 0 && (o ?? (o = [])).push(new gf(a, d, h));
          }
        }
      o && o.length > 0 && t.push([n, o]);
    }
    return t;
  }
  static _fillInKbExprKeys(e, t) {
    if (e)
      for (const i of e.keys())
        t.add(i);
  }
  static _compareMenuItems(e, t) {
    const i = e.group, n = t.group;
    if (i !== n) {
      if (i) {
        if (!n)
          return -1;
      } else return 1;
      if (i === "navigation")
        return -1;
      if (n === "navigation")
        return 1;
      const a = i.localeCompare(n);
      if (a !== 0)
        return a;
    }
    const s = e.order || 0, o = t.order || 0;
    return s < o ? -1 : s > o ? 1 : Wd._compareTitles(Vg(e) ? e.command.title : e.title, Vg(t) ? t.command.title : t.title);
  }
  static _compareTitles(e, t) {
    const i = typeof e == "string" ? e : e.original, n = typeof t == "string" ? t : t.original;
    return i.localeCompare(n);
  }
};
yE = Wd = uL([
  Ya(3, $t),
  Ya(4, _t),
  Ya(5, De)
], yE);
let LE = class {
  constructor(e, t, i, n, s, o) {
    this._disposables = new q(), this._menuInfo = new yE(e, t, i.emitEventsForSubmenuChanges, n, s, o);
    const a = new xt(() => {
      this._menuInfo.refresh(), this._onDidChange.fire({ menu: this, isStructuralChange: !0, isEnablementChange: !0, isToggleChange: !0 });
    }, i.eventDebounceDelay);
    this._disposables.add(a), this._disposables.add(on.onDidChangeMenu((h) => {
      h.has(e) && a.schedule();
    }));
    const l = this._disposables.add(new q()), d = (h) => {
      let u = !1, g = !1, f = !1;
      for (const m of h)
        if (u = u || m.isStructuralChange, g = g || m.isEnablementChange, f = f || m.isToggleChange, u && g && f)
          break;
      return { menu: this, isStructuralChange: u, isEnablementChange: g, isToggleChange: f };
    }, c = () => {
      l.add(o.onDidChangeContext((h) => {
        const u = h.affectsSome(this._menuInfo.structureContextKeys), g = h.affectsSome(this._menuInfo.preconditionContextKeys), f = h.affectsSome(this._menuInfo.toggledContextKeys);
        (u || g || f) && this._onDidChange.fire({ menu: this, isStructuralChange: u, isEnablementChange: g, isToggleChange: f });
      })), l.add(t.onDidChange((h) => {
        this._onDidChange.fire({ menu: this, isStructuralChange: !0, isEnablementChange: !1, isToggleChange: !1 });
      }));
    };
    this._onDidChange = new hH({
      // start/stop context key listener
      onWillAddFirstListener: c,
      onDidRemoveLastListener: l.clear.bind(l),
      delay: i.eventDebounceDelay,
      merge: d
    }), this.onDidChange = this._onDidChange.event;
  }
  getActions(e) {
    return this._menuInfo.createActionGroups(e);
  }
  dispose() {
    this._disposables.dispose(), this._onDidChange.dispose();
  }
};
LE = uL([
  Ya(3, $t),
  Ya(4, _t),
  Ya(5, De)
], LE);
function Coe(r, e, t) {
  const i = M6(e) ? e.submenu.id : e.id, n = typeof e.title == "string" ? e.title : e.title.value, s = ru({
    id: `hide/${r.id}/${i}`,
    label: p("hide.label", "Hide '{0}'", n),
    run() {
      t.updateHidden(r, i, !0);
    }
  }), o = ru({
    id: `toggle/${r.id}/${i}`,
    label: n,
    get checked() {
      return !t.isHidden(r, i);
    },
    run() {
      t.updateHidden(r, i, !!this.checked);
    }
  });
  return {
    hide: s,
    toggle: o,
    get isHidden() {
      return !o.checked;
    }
  };
}
function y3(r, e = void 0, t, i) {
  return ru({
    id: `configureKeybinding/${r}`,
    label: p("configure keybinding", "Configure Keybinding"),
    run() {
      const s = !!!i.lookupKeybinding(r) && e ? e.serialize() : void 0;
      t.executeCommand("workbench.action.openGlobalKeybindings", `@command:${r}` + (s ? ` +when:${s}` : ""));
    }
  });
}
var woe = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, TF = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, DE;
let py = DE = class extends P {
  constructor(e, t) {
    super(), this.layoutService = e, this.logService = t, this.mapTextToType = /* @__PURE__ */ new Map(), this.findText = "", this.resources = [], this.resourcesStateHash = void 0, (ld || LH) && this.installWebKitWriteTextWorkaround(), this._register(ne.runAndSubscribe(o0, ({ window: i, disposables: n }) => {
      n.add(W(i.document, "copy", () => this.clearResources()));
    }, { window: Dt, disposables: this._store }));
  }
  // In Safari, it has the following note:
  //
  // "The request to write to the clipboard must be triggered during a user gesture.
  // A call to clipboard.write or clipboard.writeText outside the scope of a user
  // gesture(such as "click" or "touch" event handlers) will result in the immediate
  // rejection of the promise returned by the API call."
  // From: https://webkit.org/blog/10855/async-clipboard-api/
  //
  // Since extensions run in a web worker, and handle gestures in an asynchronous way,
  // they are not classified by Safari as "in response to a user gesture" and will reject.
  //
  // This function sets up some handlers to work around that behavior.
  installWebKitWriteTextWorkaround() {
    const e = () => {
      const t = new ab();
      this.webKitPendingClipboardWritePromise && !this.webKitPendingClipboardWritePromise.isSettled && this.webKitPendingClipboardWritePromise.cancel(), this.webKitPendingClipboardWritePromise = t, kw().navigator.clipboard.write([new ClipboardItem({
        "text/plain": t.p
      })]).catch(async (i) => {
        (!(i instanceof Error) || i.name !== "NotAllowedError" || !t.isRejected) && this.logService.error(i);
      });
    };
    this._register(ne.runAndSubscribe(this.layoutService.onDidAddContainer, ({ container: t, disposables: i }) => {
      i.add(W(t, "click", e)), i.add(W(t, "keydown", e));
    }, { container: this.layoutService.mainContainer, disposables: this._store }));
  }
  async writeText(e, t) {
    if (this.writeResources([]), t) {
      this.mapTextToType.set(t, e);
      return;
    }
    if (this.webKitPendingClipboardWritePromise)
      return this.webKitPendingClipboardWritePromise.complete(e);
    try {
      return await kw().navigator.clipboard.writeText(e);
    } catch (i) {
      console.error(i);
    }
    this.fallbackWriteText(e);
  }
  fallbackWriteText(e) {
    const t = xp(), i = t.activeElement, n = t.body.appendChild(X("textarea", { "aria-hidden": !0 }));
    n.style.height = "1px", n.style.width = "1px", n.style.position = "absolute", n.value = e, n.focus(), n.select(), t.execCommand("copy"), ln(i) && i.focus(), t.body.removeChild(n);
  }
  async readText(e) {
    if (e)
      return this.mapTextToType.get(e) || "";
    try {
      return await kw().navigator.clipboard.readText();
    } catch (t) {
      console.error(t);
    }
    return "";
  }
  async readFindText() {
    return this.findText;
  }
  async writeFindText(e) {
    this.findText = e;
  }
  async writeResources(e) {
    e.length === 0 ? this.clearResources() : (this.resources = e, this.resourcesStateHash = await this.computeResourcesStateHash());
  }
  async readResources() {
    const e = await this.computeResourcesStateHash();
    return this.resourcesStateHash !== e && this.clearResources(), this.resources;
  }
  async computeResourcesStateHash() {
    if (this.resources.length === 0)
      return;
    const e = await this.readText();
    return Xy(e.substring(0, DE.MAX_RESOURCE_STATE_SOURCE_LENGTH));
  }
  clearResources() {
    this.resources = [], this.resourcesStateHash = void 0;
  }
};
py.MAX_RESOURCE_STATE_SOURCE_LENGTH = 1e3;
py = DE = woe([
  TF(0, ih),
  TF(1, Pn)
], py);
const Dd = et("clipboardService");
var Soe = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, yoe = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
const b_ = "data-keybinding-context";
let BM = class {
  constructor(e, t) {
    this._id = e, this._parent = t, this._value = /* @__PURE__ */ Object.create(null), this._value._contextId = e;
  }
  get value() {
    return { ...this._value };
  }
  setValue(e, t) {
    return this._value[e] !== t ? (this._value[e] = t, !0) : !1;
  }
  removeValue(e) {
    return e in this._value ? (delete this._value[e], !0) : !1;
  }
  getValue(e) {
    const t = this._value[e];
    return typeof t > "u" && this._parent ? this._parent.getValue(e) : t;
  }
};
class lp extends BM {
  constructor() {
    super(-1, null);
  }
  setValue(e, t) {
    return !1;
  }
  removeValue(e) {
    return !1;
  }
  getValue(e) {
  }
}
lp.INSTANCE = new lp();
class Cv extends BM {
  constructor(e, t, i) {
    super(e, null), this._configurationService = t, this._values = xf.forConfigKeys(), this._listener = this._configurationService.onDidChangeConfiguration((n) => {
      if (n.source === 7) {
        const s = Array.from(this._values, ([o]) => o);
        this._values.clear(), i.fire(new MF(s));
      } else {
        const s = [];
        for (const o of n.affectedKeys) {
          const a = `config.${o}`, l = this._values.findSuperstr(a);
          l !== void 0 && (s.push(...ut.map(l, ([d]) => d)), this._values.deleteSuperstr(a)), this._values.has(a) && (s.push(a), this._values.delete(a));
        }
        i.fire(new MF(s));
      }
    });
  }
  dispose() {
    this._listener.dispose();
  }
  getValue(e) {
    if (e.indexOf(Cv._keyPrefix) !== 0)
      return super.getValue(e);
    if (this._values.has(e))
      return this._values.get(e);
    const t = e.substr(Cv._keyPrefix.length), i = this._configurationService.getValue(t);
    let n;
    switch (typeof i) {
      case "number":
      case "boolean":
      case "string":
        n = i;
        break;
      default:
        Array.isArray(i) ? n = JSON.stringify(i) : n = i;
    }
    return this._values.set(e, n), n;
  }
  setValue(e, t) {
    return super.setValue(e, t);
  }
  removeValue(e) {
    return super.removeValue(e);
  }
}
Cv._keyPrefix = "config.";
class Loe {
  constructor(e, t, i) {
    this._service = e, this._key = t, this._defaultValue = i, this.reset();
  }
  set(e) {
    this._service.setContext(this._key, e);
  }
  reset() {
    typeof this._defaultValue > "u" ? this._service.removeContext(this._key) : this._service.setContext(this._key, this._defaultValue);
  }
  get() {
    return this._service.getContextKeyValue(this._key);
  }
}
class NF {
  constructor(e) {
    this.key = e;
  }
  affectsSome(e) {
    return e.has(this.key);
  }
  allKeysContainedIn(e) {
    return this.affectsSome(e);
  }
}
class MF {
  constructor(e) {
    this.keys = e;
  }
  affectsSome(e) {
    for (const t of this.keys)
      if (e.has(t))
        return !0;
    return !1;
  }
  allKeysContainedIn(e) {
    return this.keys.every((t) => e.has(t));
  }
}
class Doe {
  constructor(e) {
    this.events = e;
  }
  affectsSome(e) {
    for (const t of this.events)
      if (t.affectsSome(e))
        return !0;
    return !1;
  }
  allKeysContainedIn(e) {
    return this.events.every((t) => t.allKeysContainedIn(e));
  }
}
function koe(r, e) {
  return r.allKeysContainedIn(new Set(Object.keys(e)));
}
class L3 extends P {
  constructor(e) {
    super(), this._onDidChangeContext = this._register(new Wf({ merge: (t) => new Doe(t) })), this.onDidChangeContext = this._onDidChangeContext.event, this._isDisposed = !1, this._myContextId = e;
  }
  createKey(e, t) {
    if (this._isDisposed)
      throw new Error("AbstractContextKeyService has been disposed");
    return new Loe(this, e, t);
  }
  bufferChangeEvents(e) {
    this._onDidChangeContext.pause();
    try {
      e();
    } finally {
      this._onDidChangeContext.resume();
    }
  }
  createScoped(e) {
    if (this._isDisposed)
      throw new Error("AbstractContextKeyService has been disposed");
    return new xoe(this, e);
  }
  contextMatchesRules(e) {
    if (this._isDisposed)
      throw new Error("AbstractContextKeyService has been disposed");
    const t = this.getContextValuesContainer(this._myContextId);
    return e ? e.evaluate(t) : !0;
  }
  getContextKeyValue(e) {
    if (!this._isDisposed)
      return this.getContextValuesContainer(this._myContextId).getValue(e);
  }
  setContext(e, t) {
    if (this._isDisposed)
      return;
    const i = this.getContextValuesContainer(this._myContextId);
    i && i.setValue(e, t) && this._onDidChangeContext.fire(new NF(e));
  }
  removeContext(e) {
    this._isDisposed || this.getContextValuesContainer(this._myContextId).removeValue(e) && this._onDidChangeContext.fire(new NF(e));
  }
  getContext(e) {
    return this._isDisposed ? lp.INSTANCE : this.getContextValuesContainer(Ioe(e));
  }
  dispose() {
    super.dispose(), this._isDisposed = !0;
  }
}
let kE = class extends L3 {
  constructor(e) {
    super(0), this._contexts = /* @__PURE__ */ new Map(), this._lastContextId = 0;
    const t = this._register(new Cv(this._myContextId, e, this._onDidChangeContext));
    this._contexts.set(this._myContextId, t);
  }
  getContextValuesContainer(e) {
    return this._isDisposed ? lp.INSTANCE : this._contexts.get(e) || lp.INSTANCE;
  }
  createChildContext(e = this._myContextId) {
    if (this._isDisposed)
      throw new Error("ContextKeyService has been disposed");
    const t = ++this._lastContextId;
    return this._contexts.set(t, new BM(t, this.getContextValuesContainer(e))), t;
  }
  disposeContext(e) {
    this._isDisposed || this._contexts.delete(e);
  }
};
kE = Soe([
  yoe(0, Ge)
], kE);
class xoe extends L3 {
  constructor(e, t) {
    if (super(e.createChildContext()), this._parentChangeListener = this._register(new Yi()), this._parent = e, this._updateParentChangeListener(), this._domNode = t, this._domNode.hasAttribute(b_)) {
      let i = "";
      this._domNode.classList && (i = Array.from(this._domNode.classList.values()).join(", ")), console.error(`Element already has context attribute${i ? ": " + i : ""}`);
    }
    this._domNode.setAttribute(b_, String(this._myContextId));
  }
  _updateParentChangeListener() {
    this._parentChangeListener.value = this._parent.onDidChangeContext((e) => {
      const i = this._parent.getContextValuesContainer(this._myContextId).value;
      koe(e, i) || this._onDidChangeContext.fire(e);
    });
  }
  dispose() {
    this._isDisposed || (this._parent.disposeContext(this._myContextId), this._domNode.removeAttribute(b_), super.dispose());
  }
  getContextValuesContainer(e) {
    return this._isDisposed ? lp.INSTANCE : this._parent.getContextValuesContainer(e);
  }
  createChildContext(e = this._myContextId) {
    if (this._isDisposed)
      throw new Error("ScopedContextKeyService has been disposed");
    return this._parent.createChildContext(e);
  }
  disposeContext(e) {
    this._isDisposed || this._parent.disposeContext(e);
  }
}
function Ioe(r) {
  for (; r; ) {
    if (r.hasAttribute(b_)) {
      const e = r.getAttribute(b_);
      return e ? parseInt(e, 10) : NaN;
    }
    r = r.parentElement;
  }
  return 0;
}
function Eoe(r, e, t) {
  r.get(De).createKey(String(e), Toe(t));
}
function Toe(r) {
  return sH(r, (e) => {
    if (typeof e == "object" && e.$mid === 1)
      return Ee.revive(e).toString();
    if (e instanceof Ee)
      return e.toString();
  });
}
st.registerCommand("_setContext", Eoe);
st.registerCommand({
  id: "getContextKeyInfo",
  handler() {
    return [...oe.all()].sort((r, e) => r.key.localeCompare(e.key));
  },
  metadata: {
    description: p("getContextKeyInfo", "A command that returns information about context keys"),
    args: []
  }
});
st.registerCommand("_generateContextKeyInfo", function() {
  const r = [], e = /* @__PURE__ */ new Set();
  for (const t of oe.all())
    e.has(t.key) || (e.add(t.key), r.push(t));
  r.sort((t, i) => t.key.localeCompare(i.key)), console.log(JSON.stringify(r, void 0, 2));
});
let Noe = class {
  constructor(e, t) {
    this.key = e, this.data = t, this.incoming = /* @__PURE__ */ new Map(), this.outgoing = /* @__PURE__ */ new Map();
  }
};
class RF {
  constructor(e) {
    this._hashFn = e, this._nodes = /* @__PURE__ */ new Map();
  }
  roots() {
    const e = [];
    for (const t of this._nodes.values())
      t.outgoing.size === 0 && e.push(t);
    return e;
  }
  insertEdge(e, t) {
    const i = this.lookupOrInsertNode(e), n = this.lookupOrInsertNode(t);
    i.outgoing.set(n.key, n), n.incoming.set(i.key, i);
  }
  removeNode(e) {
    const t = this._hashFn(e);
    this._nodes.delete(t);
    for (const i of this._nodes.values())
      i.outgoing.delete(t), i.incoming.delete(t);
  }
  lookupOrInsertNode(e) {
    const t = this._hashFn(e);
    let i = this._nodes.get(t);
    return i || (i = new Noe(t, e), this._nodes.set(t, i)), i;
  }
  isEmpty() {
    return this._nodes.size === 0;
  }
  toString() {
    const e = [];
    for (const [t, i] of this._nodes)
      e.push(`${t}
	(-> incoming)[${[...i.incoming.keys()].join(", ")}]
	(outgoing ->)[${[...i.outgoing.keys()].join(",")}]
`);
    return e.join(`
`);
  }
  /**
   * This is brute force and slow and **only** be used
   * to trouble shoot.
   */
  findCycleSlow() {
    for (const [e, t] of this._nodes) {
      const i = /* @__PURE__ */ new Set([e]), n = this._findCycle(t, i);
      if (n)
        return n;
    }
  }
  _findCycle(e, t) {
    for (const [i, n] of e.outgoing) {
      if (t.has(i))
        return [...t, i].join(" -> ");
      t.add(i);
      const s = this._findCycle(n, t);
      if (s)
        return s;
      t.delete(i);
    }
  }
}
const Moe = !1;
class AF extends Error {
  constructor(e) {
    var t;
    super("cyclic dependency between services"), this.message = (t = e.findCycleSlow()) !== null && t !== void 0 ? t : `UNABLE to detect cycle, dumping graph: 
${e.toString()}`;
  }
}
class my {
  constructor(e = new Cb(), t = !1, i, n = Moe) {
    var s;
    this._services = e, this._strict = t, this._parent = i, this._enableTracing = n, this._isDisposed = !1, this._servicesToMaybeDispose = /* @__PURE__ */ new Set(), this._children = /* @__PURE__ */ new Set(), this._activeInstantiations = /* @__PURE__ */ new Set(), this._services.set(be, this), this._globalGraph = n ? (s = i == null ? void 0 : i._globalGraph) !== null && s !== void 0 ? s : new RF((o) => o) : void 0;
  }
  dispose() {
    if (!this._isDisposed) {
      this._isDisposed = !0, zt(this._children), this._children.clear();
      for (const e of this._servicesToMaybeDispose)
        t0(e) && e.dispose();
      this._servicesToMaybeDispose.clear();
    }
  }
  _throwIfDisposed() {
    if (this._isDisposed)
      throw new Error("InstantiationService has been disposed");
  }
  createChild(e, t) {
    this._throwIfDisposed();
    const i = this, n = new class extends my {
      dispose() {
        i._children.delete(n), super.dispose();
      }
    }(e, this._strict, this, this._enableTracing);
    return this._children.add(n), t == null || t.add(n), n;
  }
  invokeFunction(e, ...t) {
    this._throwIfDisposed();
    const i = vs.traceInvocation(this._enableTracing, e);
    let n = !1;
    try {
      return e({
        get: (o) => {
          if (n)
            throw HN("service accessor is only valid during the invocation of its target method");
          const a = this._getOrCreateServiceInstance(o, i);
          if (!a)
            throw new Error(`[invokeFunction] unknown service '${o}'`);
          return a;
        }
      }, ...t);
    } finally {
      n = !0, i.stop();
    }
  }
  createInstance(e, ...t) {
    this._throwIfDisposed();
    let i, n;
    return e instanceof Ia ? (i = vs.traceCreation(this._enableTracing, e.ctor), n = this._createInstance(e.ctor, e.staticArguments.concat(t), i)) : (i = vs.traceCreation(this._enableTracing, e), n = this._createInstance(e, t, i)), i.stop(), n;
  }
  _createInstance(e, t = [], i) {
    const n = Br.getServiceDependencies(e).sort((a, l) => a.index - l.index), s = [];
    for (const a of n) {
      const l = this._getOrCreateServiceInstance(a.id, i);
      l || this._throwIfStrict(`[createInstance] ${e.name} depends on UNKNOWN service ${a.id}.`, !1), s.push(l);
    }
    const o = n.length > 0 ? n[0].index : t.length;
    if (t.length !== o) {
      console.trace(`[createInstance] First service dependency of ${e.name} at position ${o + 1} conflicts with ${t.length} static arguments`);
      const a = o - t.length;
      a > 0 ? t = t.concat(new Array(a)) : t = t.slice(0, o);
    }
    return Reflect.construct(e, t.concat(s));
  }
  _setCreatedServiceInstance(e, t) {
    if (this._services.get(e) instanceof Ia)
      this._services.set(e, t);
    else if (this._parent)
      this._parent._setCreatedServiceInstance(e, t);
    else
      throw new Error("illegalState - setting UNKNOWN service instance");
  }
  _getServiceInstanceOrDescriptor(e) {
    const t = this._services.get(e);
    return !t && this._parent ? this._parent._getServiceInstanceOrDescriptor(e) : t;
  }
  _getOrCreateServiceInstance(e, t) {
    this._globalGraph && this._globalGraphImplicitDependency && this._globalGraph.insertEdge(this._globalGraphImplicitDependency, String(e));
    const i = this._getServiceInstanceOrDescriptor(e);
    return i instanceof Ia ? this._safeCreateAndCacheServiceInstance(e, i, t.branch(e, !0)) : (t.branch(e, !1), i);
  }
  _safeCreateAndCacheServiceInstance(e, t, i) {
    if (this._activeInstantiations.has(e))
      throw new Error(`illegal state - RECURSIVELY instantiating service '${e}'`);
    this._activeInstantiations.add(e);
    try {
      return this._createAndCacheServiceInstance(e, t, i);
    } finally {
      this._activeInstantiations.delete(e);
    }
  }
  _createAndCacheServiceInstance(e, t, i) {
    var n;
    const s = new RF((l) => l.id.toString());
    let o = 0;
    const a = [{ id: e, desc: t, _trace: i }];
    for (; a.length; ) {
      const l = a.pop();
      if (s.lookupOrInsertNode(l), o++ > 1e3)
        throw new AF(s);
      for (const d of Br.getServiceDependencies(l.desc.ctor)) {
        const c = this._getServiceInstanceOrDescriptor(d.id);
        if (c || this._throwIfStrict(`[createInstance] ${e} depends on ${d.id} which is NOT registered.`, !0), (n = this._globalGraph) === null || n === void 0 || n.insertEdge(String(l.id), String(d.id)), c instanceof Ia) {
          const h = { id: d.id, desc: c, _trace: l._trace.branch(d.id, !0) };
          s.insertEdge(l, h), a.push(h);
        }
      }
    }
    for (; ; ) {
      const l = s.roots();
      if (l.length === 0) {
        if (!s.isEmpty())
          throw new AF(s);
        break;
      }
      for (const { data: d } of l) {
        if (this._getServiceInstanceOrDescriptor(d.id) instanceof Ia) {
          const h = this._createServiceInstanceWithOwner(d.id, d.desc.ctor, d.desc.staticArguments, d.desc.supportsDelayedInstantiation, d._trace);
          this._setCreatedServiceInstance(d.id, h);
        }
        s.removeNode(d);
      }
    }
    return this._getServiceInstanceOrDescriptor(e);
  }
  _createServiceInstanceWithOwner(e, t, i = [], n, s) {
    if (this._services.get(e) instanceof Ia)
      return this._createServiceInstance(e, t, i, n, s, this._servicesToMaybeDispose);
    if (this._parent)
      return this._parent._createServiceInstanceWithOwner(e, t, i, n, s);
    throw new Error(`illegalState - creating UNKNOWN service instance ${t.name}`);
  }
  _createServiceInstance(e, t, i = [], n, s, o) {
    if (n) {
      const a = new my(void 0, this._strict, this, this._enableTracing);
      a._globalGraphImplicitDependency = String(e);
      const l = /* @__PURE__ */ new Map(), d = new d8(() => {
        const c = a._createInstance(t, i, s);
        for (const [h, u] of l) {
          const g = c[h];
          if (typeof g == "function")
            for (const f of u)
              f.disposable = g.apply(c, f.listener);
        }
        return l.clear(), o.add(c), c;
      });
      return new Proxy(/* @__PURE__ */ Object.create(null), {
        get(c, h) {
          if (!d.isInitialized && typeof h == "string" && (h.startsWith("onDid") || h.startsWith("onWill"))) {
            let f = l.get(h);
            return f || (f = new Ps(), l.set(h, f)), (_, v, b) => {
              if (d.isInitialized)
                return d.value[h](_, v, b);
              {
                const C = { listener: [_, v, b], disposable: void 0 }, w = f.push(C);
                return Se(() => {
                  var y;
                  w(), (y = C.disposable) === null || y === void 0 || y.dispose();
                });
              }
            };
          }
          if (h in c)
            return c[h];
          const u = d.value;
          let g = u[h];
          return typeof g != "function" || (g = g.bind(u), c[h] = g), g;
        },
        set(c, h, u) {
          return d.value[h] = u, !0;
        },
        getPrototypeOf(c) {
          return t.prototype;
        }
      });
    } else {
      const a = this._createInstance(t, i, s);
      return o.add(a), a;
    }
  }
  _throwIfStrict(e, t) {
    if (t && console.warn(e), this._strict)
      throw new Error(e);
  }
}
class vs {
  static traceInvocation(e, t) {
    return e ? new vs(2, t.name || new Error().stack.split(`
`).slice(3, 4).join(`
`)) : vs._None;
  }
  static traceCreation(e, t) {
    return e ? new vs(1, t.name) : vs._None;
  }
  constructor(e, t) {
    this.type = e, this.name = t, this._start = Date.now(), this._dep = [];
  }
  branch(e, t) {
    const i = new vs(3, e.toString());
    return this._dep.push([e, t, i]), i;
  }
  stop() {
    const e = Date.now() - this._start;
    vs._totals += e;
    let t = !1;
    function i(s, o) {
      const a = [], l = new Array(s + 1).join("	");
      for (const [d, c, h] of o._dep)
        if (c && h) {
          t = !0, a.push(`${l}CREATES -> ${d}`);
          const u = i(s + 1, h);
          u && a.push(u);
        } else
          a.push(`${l}uses -> ${d}`);
      return a.join(`
`);
    }
    const n = [
      `${this.type === 1 ? "CREATE" : "CALL"} ${this.name}`,
      `${i(1, this)}`,
      `DONE, took ${e.toFixed(2)}ms (grand total ${vs._totals.toFixed(2)}ms)`
    ];
    (e > 2 || t) && vs.all.add(n.join(`
`));
  }
}
vs.all = /* @__PURE__ */ new Set();
vs._None = new class extends vs {
  constructor() {
    super(0, null);
  }
  stop() {
  }
  branch() {
    return this;
  }
}();
vs._totals = 0;
const Roe = /* @__PURE__ */ new Set([
  Ne.inMemory,
  Ne.vscodeSourceControl,
  Ne.walkThrough,
  Ne.walkThroughSnippet,
  Ne.vscodeChatCodeBlock,
  Ne.vscodeCopilotBackingChatCodeBlock
]);
class Aoe {
  constructor() {
    this._byResource = new an(), this._byOwner = /* @__PURE__ */ new Map();
  }
  set(e, t, i) {
    let n = this._byResource.get(e);
    n || (n = /* @__PURE__ */ new Map(), this._byResource.set(e, n)), n.set(t, i);
    let s = this._byOwner.get(t);
    s || (s = new an(), this._byOwner.set(t, s)), s.set(e, i);
  }
  get(e, t) {
    const i = this._byResource.get(e);
    return i == null ? void 0 : i.get(t);
  }
  delete(e, t) {
    let i = !1, n = !1;
    const s = this._byResource.get(e);
    s && (i = s.delete(t));
    const o = this._byOwner.get(t);
    if (o && (n = o.delete(e)), i !== n)
      throw new Error("illegal state");
    return i && n;
  }
  values(e) {
    var t, i, n, s;
    return typeof e == "string" ? (i = (t = this._byOwner.get(e)) === null || t === void 0 ? void 0 : t.values()) !== null && i !== void 0 ? i : ut.empty() : Ee.isUri(e) ? (s = (n = this._byResource.get(e)) === null || n === void 0 ? void 0 : n.values()) !== null && s !== void 0 ? s : ut.empty() : ut.map(ut.concat(...this._byOwner.values()), (o) => o[1]);
  }
}
class Poe {
  constructor(e) {
    this.errors = 0, this.infos = 0, this.warnings = 0, this.unknowns = 0, this._data = new an(), this._service = e, this._subscription = e.onMarkerChanged(this._update, this);
  }
  dispose() {
    this._subscription.dispose();
  }
  _update(e) {
    for (const t of e) {
      const i = this._data.get(t);
      i && this._substract(i);
      const n = this._resourceStats(t);
      this._add(n), this._data.set(t, n);
    }
  }
  _resourceStats(e) {
    const t = { errors: 0, warnings: 0, infos: 0, unknowns: 0 };
    if (Roe.has(e.scheme))
      return t;
    for (const { severity: i } of this._service.read({ resource: e }))
      i === di.Error ? t.errors += 1 : i === di.Warning ? t.warnings += 1 : i === di.Info ? t.infos += 1 : t.unknowns += 1;
    return t;
  }
  _substract(e) {
    this.errors -= e.errors, this.warnings -= e.warnings, this.infos -= e.infos, this.unknowns -= e.unknowns;
  }
  _add(e) {
    this.errors += e.errors, this.warnings += e.warnings, this.infos += e.infos, this.unknowns += e.unknowns;
  }
}
class zd {
  constructor() {
    this._onMarkerChanged = new hH({
      delay: 0,
      merge: zd._merge
    }), this.onMarkerChanged = this._onMarkerChanged.event, this._data = new Aoe(), this._stats = new Poe(this);
  }
  dispose() {
    this._stats.dispose(), this._onMarkerChanged.dispose();
  }
  remove(e, t) {
    for (const i of t || [])
      this.changeOne(e, i, []);
  }
  changeOne(e, t, i) {
    if (uH(i))
      this._data.delete(t, e) && this._onMarkerChanged.fire([t]);
    else {
      const n = [];
      for (const s of i) {
        const o = zd._toMarker(e, t, s);
        o && n.push(o);
      }
      this._data.set(t, e, n), this._onMarkerChanged.fire([t]);
    }
  }
  static _toMarker(e, t, i) {
    let { code: n, severity: s, message: o, source: a, startLineNumber: l, startColumn: d, endLineNumber: c, endColumn: h, relatedInformation: u, tags: g } = i;
    if (o)
      return l = l > 0 ? l : 1, d = d > 0 ? d : 1, c = c >= l ? c : l, h = h > 0 ? h : d, {
        resource: t,
        owner: e,
        code: n,
        severity: s,
        message: o,
        source: a,
        startLineNumber: l,
        startColumn: d,
        endLineNumber: c,
        endColumn: h,
        relatedInformation: u,
        tags: g
      };
  }
  changeAll(e, t) {
    const i = [], n = this._data.values(e);
    if (n)
      for (const s of n) {
        const o = ut.first(s);
        o && (i.push(o.resource), this._data.delete(o.resource, e));
      }
    if (Rn(t)) {
      const s = new an();
      for (const { resource: o, marker: a } of t) {
        const l = zd._toMarker(e, o, a);
        if (!l)
          continue;
        const d = s.get(o);
        d ? d.push(l) : (s.set(o, [l]), i.push(o));
      }
      for (const [o, a] of s)
        this._data.set(o, e, a);
    }
    i.length > 0 && this._onMarkerChanged.fire(i);
  }
  read(e = /* @__PURE__ */ Object.create(null)) {
    let { owner: t, resource: i, severities: n, take: s } = e;
    if ((!s || s < 0) && (s = -1), t && i) {
      const o = this._data.get(i, t);
      if (o) {
        const a = [];
        for (const l of o)
          if (zd._accept(l, n)) {
            const d = a.push(l);
            if (s > 0 && d === s)
              break;
          }
        return a;
      } else
        return [];
    } else if (!t && !i) {
      const o = [];
      for (const a of this._data.values())
        for (const l of a)
          if (zd._accept(l, n)) {
            const d = o.push(l);
            if (s > 0 && d === s)
              return o;
          }
      return o;
    } else {
      const o = this._data.values(i ?? t), a = [];
      for (const l of o)
        for (const d of l)
          if (zd._accept(d, n)) {
            const c = a.push(d);
            if (s > 0 && c === s)
              return a;
          }
      return a;
    }
  }
  static _accept(e, t) {
    return t === void 0 || (t & e.severity) === e.severity;
  }
  // --- event debounce logic
  static _merge(e) {
    const t = new an();
    for (const i of e)
      for (const n of i)
        t.set(n, !0);
    return Array.from(t.keys());
  }
}
class Ooe extends P {
  get configurationModel() {
    return this._configurationModel;
  }
  constructor(e) {
    super(), this.logService = e, this._configurationModel = fn.createEmptyModel(this.logService);
  }
  reload() {
    return this.resetConfigurationModel(), this.configurationModel;
  }
  getConfigurationDefaultOverrides() {
    return {};
  }
  resetConfigurationModel() {
    this._configurationModel = fn.createEmptyModel(this.logService);
    const e = si.as(aa.Configuration).getConfigurationProperties();
    this.updateConfigurationModel(Object.keys(e), e);
  }
  updateConfigurationModel(e, t) {
    const i = this.getConfigurationDefaultOverrides();
    for (const n of e) {
      const s = i[n], o = t[n];
      s !== void 0 ? this._configurationModel.addValue(n, s) : o ? this._configurationModel.addValue(n, o.default) : this._configurationModel.removeValue(n);
    }
  }
}
const rh = et("accessibilitySignalService");
class ke {
  static register(e) {
    return new ke(e.fileName);
  }
  constructor(e) {
    this.fileName = e;
  }
}
ke.error = ke.register({ fileName: "error.mp3" });
ke.warning = ke.register({ fileName: "warning.mp3" });
ke.success = ke.register({ fileName: "success.mp3" });
ke.foldedArea = ke.register({ fileName: "foldedAreas.mp3" });
ke.break = ke.register({ fileName: "break.mp3" });
ke.quickFixes = ke.register({ fileName: "quickFixes.mp3" });
ke.taskCompleted = ke.register({ fileName: "taskCompleted.mp3" });
ke.taskFailed = ke.register({ fileName: "taskFailed.mp3" });
ke.terminalBell = ke.register({ fileName: "terminalBell.mp3" });
ke.diffLineInserted = ke.register({ fileName: "diffLineInserted.mp3" });
ke.diffLineDeleted = ke.register({ fileName: "diffLineDeleted.mp3" });
ke.diffLineModified = ke.register({ fileName: "diffLineModified.mp3" });
ke.chatRequestSent = ke.register({ fileName: "chatRequestSent.mp3" });
ke.chatResponseReceived1 = ke.register({ fileName: "chatResponseReceived1.mp3" });
ke.chatResponseReceived2 = ke.register({ fileName: "chatResponseReceived2.mp3" });
ke.chatResponseReceived3 = ke.register({ fileName: "chatResponseReceived3.mp3" });
ke.chatResponseReceived4 = ke.register({ fileName: "chatResponseReceived4.mp3" });
ke.clear = ke.register({ fileName: "clear.mp3" });
ke.save = ke.register({ fileName: "save.mp3" });
ke.format = ke.register({ fileName: "format.mp3" });
ke.voiceRecordingStarted = ke.register({ fileName: "voiceRecordingStarted.mp3" });
ke.voiceRecordingStopped = ke.register({ fileName: "voiceRecordingStopped.mp3" });
ke.progress = ke.register({ fileName: "progress.mp3" });
class Foe {
  constructor(e) {
    this.randomOneOf = e;
  }
}
class Re {
  constructor(e, t, i, n, s, o, a) {
    this.sound = e, this.name = t, this.legacySoundSettingsKey = i, this.settingsKey = n, this.legacyAnnouncementSettingsKey = s, this.announcementMessage = o, this.delaySettingsKey = a;
  }
  static register(e) {
    const t = new Foe("randomOneOf" in e.sound ? e.sound.randomOneOf : [e.sound]), i = new Re(t, e.name, e.legacySoundSettingsKey, e.settingsKey, e.legacyAnnouncementSettingsKey, e.announcementMessage, e.delaySettingsKey);
    return Re._signals.add(i), i;
  }
}
Re._signals = /* @__PURE__ */ new Set();
Re.errorAtPosition = Re.register({
  name: p("accessibilitySignals.positionHasError.name", "Error at Position"),
  sound: ke.error,
  announcementMessage: p("accessibility.signals.positionHasError", "Error"),
  settingsKey: "accessibility.signals.positionHasError",
  delaySettingsKey: "accessibility.signalOptions.delays.errorAtPosition"
});
Re.warningAtPosition = Re.register({
  name: p("accessibilitySignals.positionHasWarning.name", "Warning at Position"),
  sound: ke.warning,
  announcementMessage: p("accessibility.signals.positionHasWarning", "Warning"),
  settingsKey: "accessibility.signals.positionHasWarning",
  delaySettingsKey: "accessibility.signalOptions.delays.warningAtPosition"
});
Re.errorOnLine = Re.register({
  name: p("accessibilitySignals.lineHasError.name", "Error on Line"),
  sound: ke.error,
  legacySoundSettingsKey: "audioCues.lineHasError",
  legacyAnnouncementSettingsKey: "accessibility.alert.error",
  announcementMessage: p("accessibility.signals.lineHasError", "Error on Line"),
  settingsKey: "accessibility.signals.lineHasError"
});
Re.warningOnLine = Re.register({
  name: p("accessibilitySignals.lineHasWarning.name", "Warning on Line"),
  sound: ke.warning,
  legacySoundSettingsKey: "audioCues.lineHasWarning",
  legacyAnnouncementSettingsKey: "accessibility.alert.warning",
  announcementMessage: p("accessibility.signals.lineHasWarning", "Warning on Line"),
  settingsKey: "accessibility.signals.lineHasWarning"
});
Re.foldedArea = Re.register({
  name: p("accessibilitySignals.lineHasFoldedArea.name", "Folded Area on Line"),
  sound: ke.foldedArea,
  legacySoundSettingsKey: "audioCues.lineHasFoldedArea",
  legacyAnnouncementSettingsKey: "accessibility.alert.foldedArea",
  announcementMessage: p("accessibility.signals.lineHasFoldedArea", "Folded"),
  settingsKey: "accessibility.signals.lineHasFoldedArea"
});
Re.break = Re.register({
  name: p("accessibilitySignals.lineHasBreakpoint.name", "Breakpoint on Line"),
  sound: ke.break,
  legacySoundSettingsKey: "audioCues.lineHasBreakpoint",
  legacyAnnouncementSettingsKey: "accessibility.alert.breakpoint",
  announcementMessage: p("accessibility.signals.lineHasBreakpoint", "Breakpoint"),
  settingsKey: "accessibility.signals.lineHasBreakpoint"
});
Re.inlineSuggestion = Re.register({
  name: p("accessibilitySignals.lineHasInlineSuggestion.name", "Inline Suggestion on Line"),
  sound: ke.quickFixes,
  legacySoundSettingsKey: "audioCues.lineHasInlineSuggestion",
  settingsKey: "accessibility.signals.lineHasInlineSuggestion"
});
Re.terminalQuickFix = Re.register({
  name: p("accessibilitySignals.terminalQuickFix.name", "Terminal Quick Fix"),
  sound: ke.quickFixes,
  legacySoundSettingsKey: "audioCues.terminalQuickFix",
  legacyAnnouncementSettingsKey: "accessibility.alert.terminalQuickFix",
  announcementMessage: p("accessibility.signals.terminalQuickFix", "Quick Fix"),
  settingsKey: "accessibility.signals.terminalQuickFix"
});
Re.onDebugBreak = Re.register({
  name: p("accessibilitySignals.onDebugBreak.name", "Debugger Stopped on Breakpoint"),
  sound: ke.break,
  legacySoundSettingsKey: "audioCues.onDebugBreak",
  legacyAnnouncementSettingsKey: "accessibility.alert.onDebugBreak",
  announcementMessage: p("accessibility.signals.onDebugBreak", "Breakpoint"),
  settingsKey: "accessibility.signals.onDebugBreak"
});
Re.noInlayHints = Re.register({
  name: p("accessibilitySignals.noInlayHints", "No Inlay Hints on Line"),
  sound: ke.error,
  legacySoundSettingsKey: "audioCues.noInlayHints",
  legacyAnnouncementSettingsKey: "accessibility.alert.noInlayHints",
  announcementMessage: p("accessibility.signals.noInlayHints", "No Inlay Hints"),
  settingsKey: "accessibility.signals.noInlayHints"
});
Re.taskCompleted = Re.register({
  name: p("accessibilitySignals.taskCompleted", "Task Completed"),
  sound: ke.taskCompleted,
  legacySoundSettingsKey: "audioCues.taskCompleted",
  legacyAnnouncementSettingsKey: "accessibility.alert.taskCompleted",
  announcementMessage: p("accessibility.signals.taskCompleted", "Task Completed"),
  settingsKey: "accessibility.signals.taskCompleted"
});
Re.taskFailed = Re.register({
  name: p("accessibilitySignals.taskFailed", "Task Failed"),
  sound: ke.taskFailed,
  legacySoundSettingsKey: "audioCues.taskFailed",
  legacyAnnouncementSettingsKey: "accessibility.alert.taskFailed",
  announcementMessage: p("accessibility.signals.taskFailed", "Task Failed"),
  settingsKey: "accessibility.signals.taskFailed"
});
Re.terminalCommandFailed = Re.register({
  name: p("accessibilitySignals.terminalCommandFailed", "Terminal Command Failed"),
  sound: ke.error,
  legacySoundSettingsKey: "audioCues.terminalCommandFailed",
  legacyAnnouncementSettingsKey: "accessibility.alert.terminalCommandFailed",
  announcementMessage: p("accessibility.signals.terminalCommandFailed", "Command Failed"),
  settingsKey: "accessibility.signals.terminalCommandFailed"
});
Re.terminalCommandSucceeded = Re.register({
  name: p("accessibilitySignals.terminalCommandSucceeded", "Terminal Command Succeeded"),
  sound: ke.success,
  announcementMessage: p("accessibility.signals.terminalCommandSucceeded", "Command Succeeded"),
  settingsKey: "accessibility.signals.terminalCommandSucceeded"
});
Re.terminalBell = Re.register({
  name: p("accessibilitySignals.terminalBell", "Terminal Bell"),
  sound: ke.terminalBell,
  legacySoundSettingsKey: "audioCues.terminalBell",
  legacyAnnouncementSettingsKey: "accessibility.alert.terminalBell",
  announcementMessage: p("accessibility.signals.terminalBell", "Terminal Bell"),
  settingsKey: "accessibility.signals.terminalBell"
});
Re.notebookCellCompleted = Re.register({
  name: p("accessibilitySignals.notebookCellCompleted", "Notebook Cell Completed"),
  sound: ke.taskCompleted,
  legacySoundSettingsKey: "audioCues.notebookCellCompleted",
  legacyAnnouncementSettingsKey: "accessibility.alert.notebookCellCompleted",
  announcementMessage: p("accessibility.signals.notebookCellCompleted", "Notebook Cell Completed"),
  settingsKey: "accessibility.signals.notebookCellCompleted"
});
Re.notebookCellFailed = Re.register({
  name: p("accessibilitySignals.notebookCellFailed", "Notebook Cell Failed"),
  sound: ke.taskFailed,
  legacySoundSettingsKey: "audioCues.notebookCellFailed",
  legacyAnnouncementSettingsKey: "accessibility.alert.notebookCellFailed",
  announcementMessage: p("accessibility.signals.notebookCellFailed", "Notebook Cell Failed"),
  settingsKey: "accessibility.signals.notebookCellFailed"
});
Re.diffLineInserted = Re.register({
  name: p("accessibilitySignals.diffLineInserted", "Diff Line Inserted"),
  sound: ke.diffLineInserted,
  legacySoundSettingsKey: "audioCues.diffLineInserted",
  settingsKey: "accessibility.signals.diffLineInserted"
});
Re.diffLineDeleted = Re.register({
  name: p("accessibilitySignals.diffLineDeleted", "Diff Line Deleted"),
  sound: ke.diffLineDeleted,
  legacySoundSettingsKey: "audioCues.diffLineDeleted",
  settingsKey: "accessibility.signals.diffLineDeleted"
});
Re.diffLineModified = Re.register({
  name: p("accessibilitySignals.diffLineModified", "Diff Line Modified"),
  sound: ke.diffLineModified,
  legacySoundSettingsKey: "audioCues.diffLineModified",
  settingsKey: "accessibility.signals.diffLineModified"
});
Re.chatRequestSent = Re.register({
  name: p("accessibilitySignals.chatRequestSent", "Chat Request Sent"),
  sound: ke.chatRequestSent,
  legacySoundSettingsKey: "audioCues.chatRequestSent",
  legacyAnnouncementSettingsKey: "accessibility.alert.chatRequestSent",
  announcementMessage: p("accessibility.signals.chatRequestSent", "Chat Request Sent"),
  settingsKey: "accessibility.signals.chatRequestSent"
});
Re.chatResponseReceived = Re.register({
  name: p("accessibilitySignals.chatResponseReceived", "Chat Response Received"),
  legacySoundSettingsKey: "audioCues.chatResponseReceived",
  sound: {
    randomOneOf: [
      ke.chatResponseReceived1,
      ke.chatResponseReceived2,
      ke.chatResponseReceived3,
      ke.chatResponseReceived4
    ]
  },
  settingsKey: "accessibility.signals.chatResponseReceived"
});
Re.progress = Re.register({
  name: p("accessibilitySignals.progress", "Progress"),
  sound: ke.progress,
  legacySoundSettingsKey: "audioCues.chatResponsePending",
  legacyAnnouncementSettingsKey: "accessibility.alert.progress",
  announcementMessage: p("accessibility.signals.progress", "Progress"),
  settingsKey: "accessibility.signals.progress"
});
Re.clear = Re.register({
  name: p("accessibilitySignals.clear", "Clear"),
  sound: ke.clear,
  legacySoundSettingsKey: "audioCues.clear",
  legacyAnnouncementSettingsKey: "accessibility.alert.clear",
  announcementMessage: p("accessibility.signals.clear", "Clear"),
  settingsKey: "accessibility.signals.clear"
});
Re.save = Re.register({
  name: p("accessibilitySignals.save", "Save"),
  sound: ke.save,
  legacySoundSettingsKey: "audioCues.save",
  legacyAnnouncementSettingsKey: "accessibility.alert.save",
  announcementMessage: p("accessibility.signals.save", "Save"),
  settingsKey: "accessibility.signals.save"
});
Re.format = Re.register({
  name: p("accessibilitySignals.format", "Format"),
  sound: ke.format,
  legacySoundSettingsKey: "audioCues.format",
  legacyAnnouncementSettingsKey: "accessibility.alert.format",
  announcementMessage: p("accessibility.signals.format", "Format"),
  settingsKey: "accessibility.signals.format"
});
Re.voiceRecordingStarted = Re.register({
  name: p("accessibilitySignals.voiceRecordingStarted", "Voice Recording Started"),
  sound: ke.voiceRecordingStarted,
  legacySoundSettingsKey: "audioCues.voiceRecordingStarted",
  settingsKey: "accessibility.signals.voiceRecordingStarted"
});
Re.voiceRecordingStopped = Re.register({
  name: p("accessibilitySignals.voiceRecordingStopped", "Voice Recording Stopped"),
  sound: ke.voiceRecordingStopped,
  legacySoundSettingsKey: "audioCues.voiceRecordingStopped",
  settingsKey: "accessibility.signals.voiceRecordingStopped"
});
class Woe extends P {
  constructor(e, t = []) {
    super(), this.logger = new A6([e, ...t]), this._register(e.onDidChangeLogLevel((i) => this.setLevel(i)));
  }
  get onDidChangeLogLevel() {
    return this.logger.onDidChangeLogLevel;
  }
  setLevel(e) {
    this.logger.setLevel(e);
  }
  getLevel() {
    return this.logger.getLevel();
  }
  trace(e, ...t) {
    this.logger.trace(e, ...t);
  }
  debug(e, ...t) {
    this.logger.debug(e, ...t);
  }
  info(e, ...t) {
    this.logger.info(e, ...t);
  }
  warn(e, ...t) {
    this.logger.warn(e, ...t);
  }
  error(e, ...t) {
    this.logger.error(e, ...t);
  }
}
const D3 = [];
function Rb(r) {
  D3.push(r);
}
function Boe() {
  return D3.slice(0);
}
var kd = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, sn = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
class Hoe {
  constructor(e) {
    this.disposed = !1, this.model = e, this._onWillDispose = new R();
  }
  get textEditorModel() {
    return this.model;
  }
  dispose() {
    this.disposed = !0, this._onWillDispose.fire();
  }
}
let xE = class {
  constructor(e) {
    this.modelService = e;
  }
  createModelReference(e) {
    const t = this.modelService.getModel(e);
    return t ? Promise.resolve(new $5(new Hoe(t))) : Promise.reject(new Error("Model not found"));
  }
};
xE = kd([
  sn(0, ii)
], xE);
class gL {
  show() {
    return gL.NULL_PROGRESS_RUNNER;
  }
  async showWhile(e, t) {
    await e;
  }
}
gL.NULL_PROGRESS_RUNNER = {
  done: () => {
  },
  total: () => {
  },
  worked: () => {
  }
};
class Voe {
  withProgress(e, t, i) {
    return t({
      report: () => {
      }
    });
  }
}
class zoe {
  constructor() {
    this.isExtensionDevelopment = !1, this.isBuilt = !1;
  }
}
class Uoe {
  async confirm(e) {
    return {
      confirmed: this.doConfirm(e.message, e.detail),
      checkboxChecked: !1
      // unsupported
    };
  }
  doConfirm(e, t) {
    let i = e;
    return t && (i = i + `

` + t), Dt.confirm(i);
  }
  async prompt(e) {
    var t, i;
    let n;
    if (this.doConfirm(e.message, e.detail)) {
      const o = [...(t = e.buttons) !== null && t !== void 0 ? t : []];
      e.cancelButton && typeof e.cancelButton != "string" && typeof e.cancelButton != "boolean" && o.push(e.cancelButton), n = await ((i = o[0]) === null || i === void 0 ? void 0 : i.run({ checkboxChecked: !1 }));
    }
    return { result: n };
  }
  async error(e, t) {
    await this.prompt({ type: yi.Error, message: e, detail: t });
  }
}
class wv {
  info(e) {
    return this.notify({ severity: yi.Info, message: e });
  }
  warn(e) {
    return this.notify({ severity: yi.Warning, message: e });
  }
  error(e) {
    return this.notify({ severity: yi.Error, message: e });
  }
  notify(e) {
    switch (e.severity) {
      case yi.Error:
        console.error(e.message);
        break;
      case yi.Warning:
        console.warn(e.message);
        break;
      default:
        console.log(e.message);
        break;
    }
    return wv.NO_OP;
  }
  prompt(e, t, i, n) {
    return wv.NO_OP;
  }
  status(e, t) {
    return P.None;
  }
}
wv.NO_OP = new tJ();
let IE = class {
  constructor(e) {
    this._onWillExecuteCommand = new R(), this._onDidExecuteCommand = new R(), this.onDidExecuteCommand = this._onDidExecuteCommand.event, this._instantiationService = e;
  }
  executeCommand(e, ...t) {
    const i = st.getCommand(e);
    if (!i)
      return Promise.reject(new Error(`command '${e}' not found`));
    try {
      this._onWillExecuteCommand.fire({ commandId: e, args: t });
      const n = this._instantiationService.invokeFunction.apply(this._instantiationService, [i.handler, ...t]);
      return this._onDidExecuteCommand.fire({ commandId: e, args: t }), Promise.resolve(n);
    } catch (n) {
      return Promise.reject(n);
    }
  }
};
IE = kd([
  sn(0, be)
], IE);
let dp = class extends bte {
  constructor(e, t, i, n, s, o) {
    super(e, t, i, n, s), this._cachedResolver = null, this._dynamicKeybindings = [], this._domNodeListeners = [];
    const a = (g) => {
      const f = new q();
      f.add(W(g, Q.KEY_DOWN, (m) => {
        const _ = new Mt(m);
        this._dispatch(_, _.target) && (_.preventDefault(), _.stopPropagation());
      })), f.add(W(g, Q.KEY_UP, (m) => {
        const _ = new Mt(m);
        this._singleModifierDispatch(_, _.target) && _.preventDefault();
      })), this._domNodeListeners.push(new $oe(g, f));
    }, l = (g) => {
      for (let f = 0; f < this._domNodeListeners.length; f++) {
        const m = this._domNodeListeners[f];
        m.domNode === g && (this._domNodeListeners.splice(f, 1), m.dispose());
      }
    }, d = (g) => {
      g.getOption(
        61
        /* EditorOption.inDiffEditor */
      ) || a(g.getContainerDomNode());
    }, c = (g) => {
      g.getOption(
        61
        /* EditorOption.inDiffEditor */
      ) || l(g.getContainerDomNode());
    };
    this._register(o.onCodeEditorAdd(d)), this._register(o.onCodeEditorRemove(c)), o.listCodeEditors().forEach(d);
    const h = (g) => {
      a(g.getContainerDomNode());
    }, u = (g) => {
      l(g.getContainerDomNode());
    };
    this._register(o.onDiffEditorAdd(h)), this._register(o.onDiffEditorRemove(u)), o.listDiffEditors().forEach(h);
  }
  addDynamicKeybinding(e, t, i, n) {
    return Ur(st.registerCommand(e, i), this.addDynamicKeybindings([{
      keybinding: t,
      command: e,
      when: n
    }]));
  }
  addDynamicKeybindings(e) {
    const t = e.map((i) => {
      var n;
      return {
        keybinding: yx(i.keybinding, Os),
        command: (n = i.command) !== null && n !== void 0 ? n : null,
        commandArgs: i.commandArgs,
        when: i.when,
        weight1: 1e3,
        weight2: 0,
        extensionId: null,
        isBuiltinExtension: !1
      };
    });
    return this._dynamicKeybindings = this._dynamicKeybindings.concat(t), this.updateResolver(), Se(() => {
      for (let i = 0; i < this._dynamicKeybindings.length; i++)
        if (this._dynamicKeybindings[i] === t[0]) {
          this._dynamicKeybindings.splice(i, t.length), this.updateResolver();
          return;
        }
    });
  }
  updateResolver() {
    this._cachedResolver = null, this._onDidUpdateKeybindings.fire();
  }
  _getResolver() {
    if (!this._cachedResolver) {
      const e = this._toNormalizedKeybindingItems(ls.getDefaultKeybindings(), !0), t = this._toNormalizedKeybindingItems(this._dynamicKeybindings, !1);
      this._cachedResolver = new __(e, t, (i) => this._log(i));
    }
    return this._cachedResolver;
  }
  _documentHasFocus() {
    return Dt.document.hasFocus();
  }
  _toNormalizedKeybindingItems(e, t) {
    const i = [];
    let n = 0;
    for (const s of e) {
      const o = s.when || void 0, a = s.keybinding;
      if (!a)
        i[n++] = new KO(void 0, s.command, s.commandArgs, o, t, null, !1);
      else {
        const l = sv.resolveKeybinding(a, Os);
        for (const d of l)
          i[n++] = new KO(d, s.command, s.commandArgs, o, t, null, !1);
      }
    }
    return i;
  }
  resolveKeyboardEvent(e) {
    const t = new dd(e.ctrlKey, e.shiftKey, e.altKey, e.metaKey, e.keyCode);
    return new sv([t], Os);
  }
};
dp = kd([
  sn(0, De),
  sn(1, $t),
  sn(2, kn),
  sn(3, xi),
  sn(4, Pn),
  sn(5, ht)
], dp);
class $oe extends P {
  constructor(e, t) {
    super(), this.domNode = e, this._register(t);
  }
}
function PF(r) {
  return r && typeof r == "object" && (!r.overrideIdentifier || typeof r.overrideIdentifier == "string") && (!r.resource || r.resource instanceof Ee);
}
let _y = class {
  constructor(e) {
    this.logService = e, this._onDidChangeConfiguration = new R(), this.onDidChangeConfiguration = this._onDidChangeConfiguration.event;
    const t = new Ooe(e);
    this._configuration = new $0(t.reload(), fn.createEmptyModel(e), fn.createEmptyModel(e), fn.createEmptyModel(e), fn.createEmptyModel(e), fn.createEmptyModel(e), new an(), fn.createEmptyModel(e), new an(), e), t.dispose();
  }
  getValue(e, t) {
    const i = typeof e == "string" ? e : void 0, n = PF(e) ? e : PF(t) ? t : {};
    return this._configuration.getValue(i, n, void 0);
  }
  updateValues(e) {
    const t = { data: this._configuration.toData() }, i = [];
    for (const n of e) {
      const [s, o] = n;
      this.getValue(s) !== o && (this._configuration.updateValue(s, o), i.push(s));
    }
    if (i.length > 0) {
      const n = new pte({ keys: i, overrides: [] }, t, this._configuration, void 0, this.logService);
      n.source = 8, this._onDidChangeConfiguration.fire(n);
    }
    return Promise.resolve();
  }
  updateValue(e, t, i, n) {
    return this.updateValues([[e, t]]);
  }
  inspect(e, t = {}) {
    return this._configuration.inspect(e, t, void 0);
  }
};
_y = kd([
  sn(0, Pn)
], _y);
let EE = class {
  constructor(e, t, i) {
    this.configurationService = e, this.modelService = t, this.languageService = i, this._onDidChangeConfiguration = new R(), this.configurationService.onDidChangeConfiguration((n) => {
      this._onDidChangeConfiguration.fire({ affectedKeys: n.affectedKeys, affectsConfiguration: (s, o) => n.affectsConfiguration(o) });
    });
  }
  getValue(e, t, i) {
    const n = A.isIPosition(t) ? t : null, s = n ? typeof i == "string" ? i : void 0 : typeof t == "string" ? t : void 0, o = e ? this.getLanguage(e, n) : void 0;
    return typeof s > "u" ? this.configurationService.getValue({
      resource: e,
      overrideIdentifier: o
    }) : this.configurationService.getValue(s, {
      resource: e,
      overrideIdentifier: o
    });
  }
  getLanguage(e, t) {
    const i = this.modelService.getModel(e);
    return i ? t ? i.getLanguageIdAtPosition(t.lineNumber, t.column) : i.getLanguageId() : this.languageService.guessLanguageIdByFilepathOrFirstLine(e);
  }
};
EE = kd([
  sn(0, Ge),
  sn(1, ii),
  sn(2, Jt)
], EE);
let TE = class {
  constructor(e) {
    this.configurationService = e;
  }
  getEOL(e, t) {
    const i = this.configurationService.getValue("files.eol", { overrideIdentifier: t, resource: e });
    return i && typeof i == "string" && i !== "auto" ? i : os || Je ? `
` : `\r
`;
  }
};
TE = kd([
  sn(0, Ge)
], TE);
class Koe {
  publicLog2() {
  }
}
class Sv {
  constructor() {
    const e = Ee.from({ scheme: Sv.SCHEME, authority: "model", path: "/" });
    this.workspace = { id: fz, folders: [new Rte({ uri: e, name: "", index: 0 })] };
  }
  getWorkspace() {
    return this.workspace;
  }
  getWorkspaceFolder(e) {
    return e && e.scheme === Sv.SCHEME ? this.workspace.folders[0] : null;
  }
}
Sv.SCHEME = "inmemory";
function vy(r, e, t) {
  if (!e || !(r instanceof _y))
    return;
  const i = [];
  Object.keys(e).forEach((n) => {
    cte(n) && i.push([`editor.${n}`, e[n]]), t && hte(n) && i.push([`diffEditor.${n}`, e[n]]);
  }), i.length > 0 && r.updateValues(i);
}
let NE = class {
  constructor(e) {
    this._modelService = e;
  }
  hasPreviewHandler() {
    return !1;
  }
  async apply(e, t) {
    const i = Array.isArray(e) ? e : gM.convert(e), n = /* @__PURE__ */ new Map();
    for (const a of i) {
      if (!(a instanceof vc))
        throw new Error("bad edit - only text edits are supported");
      const l = this._modelService.getModel(a.resource);
      if (!l)
        throw new Error("bad edit - model not found");
      if (typeof a.versionId == "number" && l.getVersionId() !== a.versionId)
        throw new Error("bad state - model changed in the meantime");
      let d = n.get(l);
      d || (d = [], n.set(l, d)), d.push(ti.replaceMove(L.lift(a.textEdit.range), a.textEdit.text));
    }
    let s = 0, o = 0;
    for (const [a, l] of n)
      a.pushStackElement(), a.pushEditOperations([], l, () => []), a.pushStackElement(), o += 1, s += l.length;
    return {
      ariaSummary: vu(zI.bulkEditServiceSummary, s, o),
      isApplied: s > 0
    };
  }
};
NE = kd([
  sn(0, ii)
], NE);
class joe {
  getUriLabel(e, t) {
    return e.scheme === "file" ? e.fsPath : e.path;
  }
  getUriBasenameLabel(e) {
    return Fo(e);
  }
}
let ME = class extends ote {
  constructor(e, t) {
    super(e), this._codeEditorService = t;
  }
  showContextView(e, t, i) {
    if (!t) {
      const n = this._codeEditorService.getFocusedCodeEditor() || this._codeEditorService.getActiveCodeEditor();
      n && (t = n.getContainerDomNode());
    }
    return super.showContextView(e, t, i);
  }
};
ME = kd([
  sn(0, ih),
  sn(1, ht)
], ME);
class qoe {
  constructor() {
    this._neverEmitter = new R(), this.onDidChangeTrust = this._neverEmitter.event;
  }
  isWorkspaceTrusted() {
    return !0;
  }
}
class Goe extends av {
  constructor() {
    super();
  }
}
class Zoe extends Woe {
  constructor() {
    super(new R6());
  }
}
let RE = class extends XI {
  constructor(e, t, i, n, s, o) {
    super(e, t, i, n, s, o), this.configure({ blockMouse: !1 });
  }
};
RE = kd([
  sn(0, kn),
  sn(1, xi),
  sn(2, Sd),
  sn(3, _t),
  sn(4, vo),
  sn(5, De)
], RE);
class Yoe {
  async playSignal(e, t) {
  }
}
ot(
  Pn,
  Zoe,
  0
  /* InstantiationType.Eager */
);
ot(
  Ge,
  _y,
  0
  /* InstantiationType.Eager */
);
ot(
  h1,
  EE,
  0
  /* InstantiationType.Eager */
);
ot(
  _V,
  TE,
  0
  /* InstantiationType.Eager */
);
ot(
  ku,
  Sv,
  0
  /* InstantiationType.Eager */
);
ot(
  tp,
  joe,
  0
  /* InstantiationType.Eager */
);
ot(
  kn,
  Koe,
  0
  /* InstantiationType.Eager */
);
ot(
  wb,
  Uoe,
  0
  /* InstantiationType.Eager */
);
ot(
  J1,
  zoe,
  0
  /* InstantiationType.Eager */
);
ot(
  xi,
  wv,
  0
  /* InstantiationType.Eager */
);
ot(
  fl,
  zd,
  0
  /* InstantiationType.Eager */
);
ot(
  Jt,
  Goe,
  0
  /* InstantiationType.Eager */
);
ot(
  wo,
  voe,
  0
  /* InstantiationType.Eager */
);
ot(
  ii,
  ey,
  0
  /* InstantiationType.Eager */
);
ot(
  _1,
  nE,
  0
  /* InstantiationType.Eager */
);
ot(
  De,
  kE,
  0
  /* InstantiationType.Eager */
);
ot(
  gz,
  Voe,
  0
  /* InstantiationType.Eager */
);
ot(
  sh,
  gL,
  0
  /* InstantiationType.Eager */
);
ot(
  br,
  jie,
  0
  /* InstantiationType.Eager */
);
ot(
  Uo,
  Wx,
  0
  /* InstantiationType.Eager */
);
ot(
  yb,
  NE,
  0
  /* InstantiationType.Eager */
);
ot(
  pz,
  qoe,
  0
  /* InstantiationType.Eager */
);
ot(
  xs,
  xE,
  0
  /* InstantiationType.Eager */
);
ot(
  qs,
  wE,
  0
  /* InstantiationType.Eager */
);
ot(
  Ko,
  Nse,
  0
  /* InstantiationType.Eager */
);
ot(
  $t,
  IE,
  0
  /* InstantiationType.Eager */
);
ot(
  _t,
  dp,
  0
  /* InstantiationType.Eager */
);
ot(
  $o,
  bE,
  0
  /* InstantiationType.Eager */
);
ot(
  Sd,
  ME,
  0
  /* InstantiationType.Eager */
);
ot(
  Ys,
  iE,
  0
  /* InstantiationType.Eager */
);
ot(
  Dd,
  py,
  0
  /* InstantiationType.Eager */
);
ot(
  Zs,
  RE,
  0
  /* InstantiationType.Eager */
);
ot(
  vo,
  SE,
  0
  /* InstantiationType.Eager */
);
ot(
  rh,
  Yoe,
  0
  /* InstantiationType.Eager */
);
var xe;
(function(r) {
  const e = new Cb();
  for (const [l, d] of BA())
    e.set(l, d);
  const t = new my(e, !0);
  e.set(be, t);
  function i(l) {
    n || o({});
    const d = e.get(l);
    if (!d)
      throw new Error("Missing service " + l);
    return d instanceof Ia ? t.invokeFunction((c) => c.get(l)) : d;
  }
  r.get = i;
  let n = !1;
  const s = new R();
  function o(l) {
    if (n)
      return t;
    n = !0;
    for (const [c, h] of BA())
      e.get(c) || e.set(c, h);
    for (const c in l)
      if (l.hasOwnProperty(c)) {
        const h = et(c);
        e.get(h) instanceof Ia && e.set(h, l[c]);
      }
    const d = Boe();
    for (const c of d)
      try {
        t.createInstance(c);
      } catch (h) {
        He(h);
      }
    return s.fire(), t;
  }
  r.initialize = o;
  function a(l) {
    if (n)
      return l();
    const d = new q(), c = d.add(s.event(() => {
      c.dispose(), d.add(l());
    }));
    return d;
  }
  r.withServices = a;
})(xe || (xe = {}));
class sa {
  static capture(e) {
    if (e.getScrollTop() === 0 || e.hasPendingScrollAnimation())
      return new sa(e.getScrollTop(), e.getContentHeight(), null, 0, null);
    let t = null, i = 0;
    const n = e.getVisibleRanges();
    if (n.length > 0) {
      t = n[0].getStartPosition();
      const s = e.getTopForPosition(t.lineNumber, t.column);
      i = e.getScrollTop() - s;
    }
    return new sa(e.getScrollTop(), e.getContentHeight(), t, i, e.getPosition());
  }
  constructor(e, t, i, n, s) {
    this._initialScrollTop = e, this._initialContentHeight = t, this._visiblePosition = i, this._visiblePositionScrollDelta = n, this._cursorPosition = s;
  }
  restore(e) {
    if (!(this._initialContentHeight === e.getContentHeight() && this._initialScrollTop === e.getScrollTop()) && this._visiblePosition) {
      const t = e.getTopForPosition(this._visiblePosition.lineNumber, this._visiblePosition.column);
      e.setScrollTop(t + this._visiblePositionScrollDelta);
    }
  }
  restoreRelativeVerticalPositionOfCursor(e) {
    if (this._initialContentHeight === e.getContentHeight() && this._initialScrollTop === e.getScrollTop())
      return;
    const t = e.getPosition();
    if (!this._cursorPosition || !t)
      return;
    const i = e.getTopForLineNumber(t.lineNumber) - e.getTopForLineNumber(this._cursorPosition.lineNumber);
    e.setScrollTop(
      e.getScrollTop() + i,
      1
      /* ScrollType.Immediate */
    );
  }
}
function HM() {
  return lA && !!lA.VSCODE_DEV;
}
function k3(r) {
  if (HM()) {
    const e = Qoe();
    return e.add(r), {
      dispose() {
        e.delete(r);
      }
    };
  } else
    return { dispose() {
    } };
}
function Qoe() {
  $C || ($C = /* @__PURE__ */ new Set());
  const r = globalThis;
  return r.$hotReload_applyNewExports || (r.$hotReload_applyNewExports = (e) => {
    const t = { config: { mode: void 0 }, ...e };
    for (const i of $C) {
      const n = i(t);
      if (n)
        return n;
    }
  }), $C;
}
let $C;
HM() && k3(({ oldExports: r, newSrc: e, config: t }) => {
  if (t.mode === "patch-prototype")
    return (i) => {
      var n, s;
      for (const o in i) {
        const a = i[o];
        if (console.log(`[hot-reload] Patching prototype methods of '${o}'`, { exportedItem: a }), typeof a == "function" && a.prototype) {
          const l = r[o];
          if (l) {
            for (const d of Object.getOwnPropertyNames(a.prototype)) {
              const c = Object.getOwnPropertyDescriptor(a.prototype, d), h = Object.getOwnPropertyDescriptor(l.prototype, d);
              ((n = c == null ? void 0 : c.value) === null || n === void 0 ? void 0 : n.toString()) !== ((s = h == null ? void 0 : h.value) === null || s === void 0 ? void 0 : s.toString()) && console.log(`[hot-reload] Patching prototype method '${o}.${d}'`), Object.defineProperty(l.prototype, d, c);
            }
            i[o] = l;
          }
        }
      }
      return !0;
    };
});
function Xoe(r, e, t, i) {
  if (r.length === 0)
    return e;
  if (e.length === 0)
    return r;
  const n = [];
  let s = 0, o = 0;
  for (; s < r.length && o < e.length; ) {
    const a = r[s], l = e[o], d = t(a), c = t(l);
    d < c ? (n.push(a), s++) : d > c ? (n.push(l), o++) : (n.push(i(a, l)), s++, o++);
  }
  for (; s < r.length; )
    n.push(r[s]), s++;
  for (; o < e.length; )
    n.push(e[o]), o++;
  return n;
}
function by(r, e) {
  const t = new q(), i = r.createDecorationsCollection();
  return t.add(Z0({ debugName: () => `Apply decorations from ${e.debugName}` }, (n) => {
    const s = e.read(n);
    i.set(s);
  })), t.add({
    dispose: () => {
      i.clear();
    }
  }), t;
}
function Hm(r, e) {
  return r.appendChild(e), Se(() => {
    r.removeChild(e);
  });
}
function Joe(r, e) {
  return r.prepend(e), Se(() => {
    r.removeChild(e);
  });
}
class x3 extends P {
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  get automaticLayout() {
    return this._automaticLayout;
  }
  constructor(e, t) {
    super(), this._automaticLayout = !1, this.elementSizeObserver = this._register(new LV(e, t)), this._width = rt(this, this.elementSizeObserver.getWidth()), this._height = rt(this, this.elementSizeObserver.getHeight()), this._register(this.elementSizeObserver.onDidChange((i) => Nt((n) => {
      this._width.set(this.elementSizeObserver.getWidth(), n), this._height.set(this.elementSizeObserver.getHeight(), n);
    })));
  }
  observe(e) {
    this.elementSizeObserver.observe(e);
  }
  setAutomaticLayout(e) {
    this._automaticLayout = e, e ? this.elementSizeObserver.startObserving() : this.elementSizeObserver.stopObserving();
  }
}
function OF(r, e, t) {
  let i = e.get(), n = i, s = i;
  const o = rt("animatedValue", i);
  let a = -1;
  const l = 300;
  let d;
  t.add(kb({
    createEmptyChangeSummary: () => ({ animate: !1 }),
    handleChange: (h, u) => (h.didChange(e) && (u.animate = u.animate || h.change), !0)
  }, (h, u) => {
    d !== void 0 && (r.cancelAnimationFrame(d), d = void 0), n = s, i = e.read(h), a = Date.now() - (u.animate ? 0 : l), c();
  }));
  function c() {
    const h = Date.now() - a;
    s = Math.floor(ere(h, n, i - n, l)), h < l ? d = r.requestAnimationFrame(c) : s = i, o.set(s, void 0);
  }
  return o;
}
function ere(r, e, t, i) {
  return r === i ? e + t : t * (-Math.pow(2, -10 * r / i) + 1) + e;
}
class I3 extends P {
  constructor(e, t, i) {
    super(), this._register(new fL(e, i)), this._register(Vc(i, {
      height: t.actualHeight,
      top: t.actualTop
    }));
  }
}
class Cy {
  get afterLineNumber() {
    return this._afterLineNumber.get();
  }
  constructor(e, t) {
    this._afterLineNumber = e, this.heightInPx = t, this.domNode = document.createElement("div"), this._actualTop = rt(this, void 0), this._actualHeight = rt(this, void 0), this.actualTop = this._actualTop, this.actualHeight = this._actualHeight, this.showInHiddenAreas = !0, this.onChange = this._afterLineNumber, this.onDomNodeTop = (i) => {
      this._actualTop.set(i, void 0);
    }, this.onComputedHeight = (i) => {
      this._actualHeight.set(i, void 0);
    };
  }
}
class fL {
  constructor(e, t) {
    this._editor = e, this._domElement = t, this._overlayWidgetId = `managedOverlayWidget-${fL._counter++}`, this._overlayWidget = {
      getId: () => this._overlayWidgetId,
      getDomNode: () => this._domElement,
      getPosition: () => null
    }, this._editor.addOverlayWidget(this._overlayWidget);
  }
  dispose() {
    this._editor.removeOverlayWidget(this._overlayWidget);
  }
}
fL._counter = 0;
function Vc(r, e) {
  return qe((t) => {
    for (let [i, n] of Object.entries(e))
      n && typeof n == "object" && "read" in n && (n = n.read(t)), typeof n == "number" && (n = `${n}px`), i = i.replace(/[A-Z]/g, (s) => "-" + s.toLowerCase()), r.style[i] = n;
  });
}
function er(r, e) {
  return tre([r], e), r;
}
function tre(r, e) {
  HM() && Mn("reload", (i) => k3(({ oldExports: n }) => {
    if ([...Object.values(n)].some((s) => r.includes(s)))
      return (s) => (i(void 0), !0);
  })).read(e);
}
function wy(r, e, t, i) {
  const n = new q(), s = [];
  return n.add(Wo((o, a) => {
    const l = e.read(o), d = /* @__PURE__ */ new Map(), c = /* @__PURE__ */ new Map();
    t && t(!0), r.changeViewZones((h) => {
      for (const u of s)
        h.removeZone(u), i == null || i.delete(u);
      s.length = 0;
      for (const u of l) {
        const g = h.addZone(u);
        u.setZoneId && u.setZoneId(g), s.push(g), i == null || i.add(g), d.set(u, g);
      }
    }), t && t(!1), a.add(kb({
      createEmptyChangeSummary() {
        return { zoneIds: [] };
      },
      handleChange(h, u) {
        const g = c.get(h.changedObservable);
        return g !== void 0 && u.zoneIds.push(g), !0;
      }
    }, (h, u) => {
      for (const g of l)
        g.onChange && (c.set(g.onChange, d.get(g)), g.onChange.read(h));
      t && t(!0), r.changeViewZones((g) => {
        for (const f of u.zoneIds)
          g.layoutZone(f);
      }), t && t(!1);
    }));
  })), n.add({
    dispose() {
      t && t(!0), r.changeViewZones((o) => {
        for (const a of s)
          o.removeZone(a);
      }), i == null || i.clear(), t && t(!1);
    }
  }), n;
}
class ire extends mi {
  dispose() {
    super.dispose(!0);
  }
}
function FF(r, e) {
  const t = N_(e, (n) => n.original.startLineNumber <= r.lineNumber);
  if (!t)
    return L.fromPositions(r);
  if (t.original.endLineNumberExclusive <= r.lineNumber) {
    const n = r.lineNumber - t.original.endLineNumberExclusive + t.modified.endLineNumberExclusive;
    return L.fromPositions(new A(n, r.column));
  }
  if (!t.innerChanges)
    return L.fromPositions(new A(t.modified.startLineNumber, 1));
  const i = N_(t.innerChanges, (n) => n.originalRange.getStartPosition().isBeforeOrEqual(r));
  if (!i) {
    const n = r.lineNumber - t.original.startLineNumber + t.modified.startLineNumber;
    return L.fromPositions(new A(n, r.column));
  }
  if (i.originalRange.containsPosition(r))
    return i.modifiedRange;
  {
    const n = nre(i.originalRange.getEndPosition(), r);
    return L.fromPositions(n.addToPosition(i.modifiedRange.getEndPosition()));
  }
}
function nre(r, e) {
  return r.lineNumber === e.lineNumber ? new Tc(0, e.column - r.column) : new Tc(e.lineNumber - r.lineNumber, e.column - 1);
}
function sre(r, e) {
  let t;
  return r.filter((i) => {
    const n = e(i, t);
    return t = i, n;
  });
}
var VM = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, zM = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
const ore = hi("diff-review-insert", me.add, p("accessibleDiffViewerInsertIcon", "Icon for 'Insert' in accessible diff viewer.")), rre = hi("diff-review-remove", me.remove, p("accessibleDiffViewerRemoveIcon", "Icon for 'Remove' in accessible diff viewer.")), are = hi("diff-review-close", me.close, p("accessibleDiffViewerCloseIcon", "Icon for 'Close' in accessible diff viewer."));
let lc = class extends P {
  constructor(e, t, i, n, s, o, a, l, d) {
    super(), this._parentNode = e, this._visible = t, this._setVisible = i, this._canClose = n, this._width = s, this._height = o, this._diffs = a, this._models = l, this._instantiationService = d, this._state = ig(this, (c, h) => {
      const u = this._visible.read(c);
      if (this._parentNode.style.visibility = u ? "visible" : "hidden", !u)
        return null;
      const g = h.add(this._instantiationService.createInstance(AE, this._diffs, this._models, this._setVisible, this._canClose)), f = h.add(this._instantiationService.createInstance(PE, this._parentNode, g, this._width, this._height, this._models));
      return { model: g, view: f };
    }).recomputeInitiallyAndOnChange(this._store);
  }
  next() {
    Nt((e) => {
      const t = this._visible.get();
      this._setVisible(!0, e), t && this._state.get().model.nextGroup(e);
    });
  }
  prev() {
    Nt((e) => {
      this._setVisible(!0, e), this._state.get().model.previousGroup(e);
    });
  }
  close() {
    Nt((e) => {
      this._setVisible(!1, e);
    });
  }
};
lc._ttPolicy = wd("diffReview", { createHTML: (r) => r });
lc = VM([
  zM(8, be)
], lc);
let AE = class extends P {
  constructor(e, t, i, n, s) {
    super(), this._diffs = e, this._models = t, this._setVisible = i, this.canClose = n, this._accessibilitySignalService = s, this._groups = rt(this, []), this._currentGroupIdx = rt(this, 0), this._currentElementIdx = rt(this, 0), this.groups = this._groups, this.currentGroup = this._currentGroupIdx.map((o, a) => this._groups.read(a)[o]), this.currentGroupIndex = this._currentGroupIdx, this.currentElement = this._currentElementIdx.map((o, a) => {
      var l;
      return (l = this.currentGroup.read(a)) === null || l === void 0 ? void 0 : l.lines[o];
    }), this._register(qe((o) => {
      const a = this._diffs.read(o);
      if (!a) {
        this._groups.set([], void 0);
        return;
      }
      const l = lre(a, this._models.getOriginalModel().getLineCount(), this._models.getModifiedModel().getLineCount());
      Nt((d) => {
        const c = this._models.getModifiedPosition();
        if (c) {
          const h = l.findIndex((u) => (c == null ? void 0 : c.lineNumber) < u.range.modified.endLineNumberExclusive);
          h !== -1 && this._currentGroupIdx.set(h, d);
        }
        this._groups.set(l, d);
      });
    })), this._register(qe((o) => {
      const a = this.currentElement.read(o);
      (a == null ? void 0 : a.type) === Jn.Deleted ? this._accessibilitySignalService.playSignal(Re.diffLineDeleted, { source: "accessibleDiffViewer.currentElementChanged" }) : (a == null ? void 0 : a.type) === Jn.Added && this._accessibilitySignalService.playSignal(Re.diffLineInserted, { source: "accessibleDiffViewer.currentElementChanged" });
    })), this._register(qe((o) => {
      var a;
      const l = this.currentElement.read(o);
      if (l && l.type !== Jn.Header) {
        const d = (a = l.modifiedLineNumber) !== null && a !== void 0 ? a : l.diff.modified.startLineNumber;
        this._models.modifiedSetSelection(L.fromPositions(new A(d, 1)));
      }
    }));
  }
  _goToGroupDelta(e, t) {
    const i = this.groups.get();
    !i || i.length <= 1 || dv(t, (n) => {
      this._currentGroupIdx.set(tn.ofLength(i.length).clipCyclic(this._currentGroupIdx.get() + e), n), this._currentElementIdx.set(0, n);
    });
  }
  nextGroup(e) {
    this._goToGroupDelta(1, e);
  }
  previousGroup(e) {
    this._goToGroupDelta(-1, e);
  }
  _goToLineDelta(e) {
    const t = this.currentGroup.get();
    !t || t.lines.length <= 1 || Nt((i) => {
      this._currentElementIdx.set(tn.ofLength(t.lines.length).clip(this._currentElementIdx.get() + e), i);
    });
  }
  goToNextLine() {
    this._goToLineDelta(1);
  }
  goToPreviousLine() {
    this._goToLineDelta(-1);
  }
  goToLine(e) {
    const t = this.currentGroup.get();
    if (!t)
      return;
    const i = t.lines.indexOf(e);
    i !== -1 && Nt((n) => {
      this._currentElementIdx.set(i, n);
    });
  }
  revealCurrentElementInEditor() {
    if (!this.canClose.get())
      return;
    this._setVisible(!1, void 0);
    const e = this.currentElement.get();
    e && (e.type === Jn.Deleted ? this._models.originalReveal(L.fromPositions(new A(e.originalLineNumber, 1))) : this._models.modifiedReveal(e.type !== Jn.Header ? L.fromPositions(new A(e.modifiedLineNumber, 1)) : void 0));
  }
  close() {
    this.canClose.get() && (this._setVisible(!1, void 0), this._models.modifiedFocus());
  }
};
AE = VM([
  zM(4, rh)
], AE);
const um = 3;
function lre(r, e, t) {
  const i = [];
  for (const n of gH(r, (s, o) => o.modified.startLineNumber - s.modified.endLineNumberExclusive < 2 * um)) {
    const s = [];
    s.push(new cre());
    const o = new Yt(Math.max(1, n[0].original.startLineNumber - um), Math.min(n[n.length - 1].original.endLineNumberExclusive + um, e + 1)), a = new Yt(Math.max(1, n[0].modified.startLineNumber - um), Math.min(n[n.length - 1].modified.endLineNumberExclusive + um, t + 1));
    K5(n, (c, h) => {
      const u = new Yt(c ? c.original.endLineNumberExclusive : o.startLineNumber, h ? h.original.startLineNumber : o.endLineNumberExclusive), g = new Yt(c ? c.modified.endLineNumberExclusive : a.startLineNumber, h ? h.modified.startLineNumber : a.endLineNumberExclusive);
      u.forEach((f) => {
        s.push(new gre(f, g.startLineNumber + (f - u.startLineNumber)));
      }), h && (h.original.forEach((f) => {
        s.push(new hre(h, f));
      }), h.modified.forEach((f) => {
        s.push(new ure(h, f));
      }));
    });
    const l = n[0].modified.join(n[n.length - 1].modified), d = n[0].original.join(n[n.length - 1].original);
    i.push(new dre(new cf(l, d), s));
  }
  return i;
}
var Jn;
(function(r) {
  r[r.Header = 0] = "Header", r[r.Unchanged = 1] = "Unchanged", r[r.Deleted = 2] = "Deleted", r[r.Added = 3] = "Added";
})(Jn || (Jn = {}));
class dre {
  constructor(e, t) {
    this.range = e, this.lines = t;
  }
}
class cre {
  constructor() {
    this.type = Jn.Header;
  }
}
class hre {
  constructor(e, t) {
    this.diff = e, this.originalLineNumber = t, this.type = Jn.Deleted, this.modifiedLineNumber = void 0;
  }
}
class ure {
  constructor(e, t) {
    this.diff = e, this.modifiedLineNumber = t, this.type = Jn.Added, this.originalLineNumber = void 0;
  }
}
class gre {
  constructor(e, t) {
    this.originalLineNumber = e, this.modifiedLineNumber = t, this.type = Jn.Unchanged;
  }
}
let PE = class extends P {
  constructor(e, t, i, n, s, o) {
    super(), this._element = e, this._model = t, this._width = i, this._height = n, this._models = s, this._languageService = o, this.domNode = this._element, this.domNode.className = "monaco-component diff-review monaco-editor-background";
    const a = document.createElement("div");
    a.className = "diff-review-actions", this._actionBar = this._register(new Bo(a)), this._register(qe((l) => {
      this._actionBar.clear(), this._model.canClose.read(l) && this._actionBar.push(new Bs("diffreview.close", p("label.close", "Close"), "close-diff-review " + Le.asClassName(are), !0, async () => t.close()), { label: !1, icon: !0 });
    })), this._content = document.createElement("div"), this._content.className = "diff-review-content", this._content.setAttribute("role", "code"), this._scrollbar = this._register(new pb(this._content, {})), mn(this.domNode, this._scrollbar.getDomNode(), a), this._register(qe((l) => {
      this._height.read(l), this._width.read(l), this._scrollbar.scanDomNode();
    })), this._register(Se(() => {
      mn(this.domNode);
    })), this._register(Vc(this.domNode, { width: this._width, height: this._height })), this._register(Vc(this._content, { width: this._width, height: this._height })), this._register(Wo((l, d) => {
      this._model.currentGroup.read(l), this._render(d);
    })), this._register(pi(this.domNode, "keydown", (l) => {
      (l.equals(
        18
        /* KeyCode.DownArrow */
      ) || l.equals(
        2066
        /* KeyCode.DownArrow */
      ) || l.equals(
        530
        /* KeyCode.DownArrow */
      )) && (l.preventDefault(), this._model.goToNextLine()), (l.equals(
        16
        /* KeyCode.UpArrow */
      ) || l.equals(
        2064
        /* KeyCode.UpArrow */
      ) || l.equals(
        528
        /* KeyCode.UpArrow */
      )) && (l.preventDefault(), this._model.goToPreviousLine()), (l.equals(
        9
        /* KeyCode.Escape */
      ) || l.equals(
        2057
        /* KeyCode.Escape */
      ) || l.equals(
        521
        /* KeyCode.Escape */
      ) || l.equals(
        1033
        /* KeyCode.Escape */
      )) && (l.preventDefault(), this._model.close()), (l.equals(
        10
        /* KeyCode.Space */
      ) || l.equals(
        3
        /* KeyCode.Enter */
      )) && (l.preventDefault(), this._model.revealCurrentElementInEditor());
    }));
  }
  _render(e) {
    const t = this._models.getOriginalOptions(), i = this._models.getModifiedOptions(), n = document.createElement("div");
    n.className = "diff-review-table", n.setAttribute("role", "list"), n.setAttribute("aria-label", p("ariaLabel", "Accessible Diff Viewer. Use arrow up and down to navigate.")), _n(n, i.get(
      50
      /* EditorOption.fontInfo */
    )), mn(this._content, n);
    const s = this._models.getOriginalModel(), o = this._models.getModifiedModel();
    if (!s || !o)
      return;
    const a = s.getOptions(), l = o.getOptions(), d = i.get(
      67
      /* EditorOption.lineHeight */
    ), c = this._model.currentGroup.get();
    for (const h of (c == null ? void 0 : c.lines) || []) {
      if (!c)
        break;
      let u;
      if (h.type === Jn.Header) {
        const f = document.createElement("div");
        f.className = "diff-review-row", f.setAttribute("role", "listitem");
        const m = c.range, _ = this._model.currentGroupIndex.get(), v = this._model.groups.get().length, b = (y) => y === 0 ? p("no_lines_changed", "no lines changed") : y === 1 ? p("one_line_changed", "1 line changed") : p("more_lines_changed", "{0} lines changed", y), C = b(m.original.length), w = b(m.modified.length);
        f.setAttribute("aria-label", p({
          key: "header",
          comment: [
            "This is the ARIA label for a git diff header.",
            "A git diff header looks like this: @@ -154,12 +159,39 @@.",
            "That encodes that at original line 154 (which is now line 159), 12 lines were removed/changed with 39 lines.",
            "Variables 0 and 1 refer to the diff index out of total number of diffs.",
            "Variables 2 and 4 will be numbers (a line number).",
            'Variables 3 and 5 will be "no lines changed", "1 line changed" or "X lines changed", localized separately.'
          ]
        }, "Difference {0} of {1}: original line {2}, {3}, modified line {4}, {5}", _ + 1, v, m.original.startLineNumber, C, m.modified.startLineNumber, w));
        const S = document.createElement("div");
        S.className = "diff-review-cell diff-review-summary", S.appendChild(document.createTextNode(`${_ + 1}/${v}: @@ -${m.original.startLineNumber},${m.original.length} +${m.modified.startLineNumber},${m.modified.length} @@`)), f.appendChild(S), u = f;
      } else
        u = this._createRow(h, d, this._width.get(), t, s, a, i, o, l);
      n.appendChild(u);
      const g = Pe((f) => (
        /** @description isSelected */
        this._model.currentElement.read(f) === h
      ));
      e.add(qe((f) => {
        const m = g.read(f);
        u.tabIndex = m ? 0 : -1, m && u.focus();
      })), e.add(W(u, "focus", () => {
        this._model.goToLine(h);
      }));
    }
    this._scrollbar.scanDomNode();
  }
  _createRow(e, t, i, n, s, o, a, l, d) {
    const c = n.get(
      145
      /* EditorOption.layoutInfo */
    ), h = c.glyphMarginWidth + c.lineNumbersWidth, u = a.get(
      145
      /* EditorOption.layoutInfo */
    ), g = 10 + u.glyphMarginWidth + u.lineNumbersWidth;
    let f = "diff-review-row", m = "";
    const _ = "diff-review-spacer";
    let v = null;
    switch (e.type) {
      case Jn.Added:
        f = "diff-review-row line-insert", m = " char-insert", v = ore;
        break;
      case Jn.Deleted:
        f = "diff-review-row line-delete", m = " char-delete", v = rre;
        break;
    }
    const b = document.createElement("div");
    b.style.minWidth = i + "px", b.className = f, b.setAttribute("role", "listitem"), b.ariaLevel = "";
    const C = document.createElement("div");
    C.className = "diff-review-cell", C.style.height = `${t}px`, b.appendChild(C);
    const w = document.createElement("span");
    w.style.width = h + "px", w.style.minWidth = h + "px", w.className = "diff-review-line-number" + m, e.originalLineNumber !== void 0 ? w.appendChild(document.createTextNode(String(e.originalLineNumber))) : w.innerText = "", C.appendChild(w);
    const S = document.createElement("span");
    S.style.width = g + "px", S.style.minWidth = g + "px", S.style.paddingRight = "10px", S.className = "diff-review-line-number" + m, e.modifiedLineNumber !== void 0 ? S.appendChild(document.createTextNode(String(e.modifiedLineNumber))) : S.innerText = "", C.appendChild(S);
    const y = document.createElement("span");
    if (y.className = _, v) {
      const N = document.createElement("span");
      N.className = Le.asClassName(v), N.innerText = "", y.appendChild(N);
    } else
      y.innerText = "";
    C.appendChild(y);
    let k;
    if (e.modifiedLineNumber !== void 0) {
      let N = this._getLineHtml(l, a, d.tabSize, e.modifiedLineNumber, this._languageService.languageIdCodec);
      lc._ttPolicy && (N = lc._ttPolicy.createHTML(N)), C.insertAdjacentHTML("beforeend", N), k = l.getLineContent(e.modifiedLineNumber);
    } else {
      let N = this._getLineHtml(s, n, o.tabSize, e.originalLineNumber, this._languageService.languageIdCodec);
      lc._ttPolicy && (N = lc._ttPolicy.createHTML(N)), C.insertAdjacentHTML("beforeend", N), k = s.getLineContent(e.originalLineNumber);
    }
    k.length === 0 && (k = p("blankLine", "blank"));
    let E = "";
    switch (e.type) {
      case Jn.Unchanged:
        e.originalLineNumber === e.modifiedLineNumber ? E = p({ key: "unchangedLine", comment: ["The placeholders are contents of the line and should not be translated."] }, "{0} unchanged line {1}", k, e.originalLineNumber) : E = p("equalLine", "{0} original line {1} modified line {2}", k, e.originalLineNumber, e.modifiedLineNumber);
        break;
      case Jn.Added:
        E = p("insertLine", "+ {0} modified line {1}", k, e.modifiedLineNumber);
        break;
      case Jn.Deleted:
        E = p("deleteLine", "- {0} original line {1}", k, e.originalLineNumber);
        break;
    }
    return b.setAttribute("aria-label", E), b;
  }
  _getLineHtml(e, t, i, n, s) {
    const o = e.getLineContent(n), a = t.get(
      50
      /* EditorOption.fontInfo */
    ), l = Ri.createEmpty(o, s), d = po.isBasicASCII(o, e.mightContainNonBasicASCII()), c = po.containsRTL(o, d, e.mightContainRTL());
    return y0(new th(a.isMonospace && !t.get(
      33
      /* EditorOption.disableMonospaceOptimizations */
    ), a.canUseHalfwidthRightwardsArrow, o, !1, d, c, 0, l, [], i, 0, a.spaceWidth, a.middotWidth, a.wsmiddotWidth, t.get(
      117
      /* EditorOption.stopRenderingLineAfter */
    ), t.get(
      99
      /* EditorOption.renderWhitespace */
    ), t.get(
      94
      /* EditorOption.renderControlCharacters */
    ), t.get(
      51
      /* EditorOption.fontLigatures */
    ) !== ro.OFF, null)).html;
  }
};
PE = VM([
  zM(5, Jt)
], PE);
class fre {
  constructor(e) {
    this.editors = e;
  }
  getOriginalModel() {
    return this.editors.original.getModel();
  }
  getOriginalOptions() {
    return this.editors.original.getOptions();
  }
  originalReveal(e) {
    this.editors.original.revealRange(e), this.editors.original.setSelection(e), this.editors.original.focus();
  }
  getModifiedModel() {
    return this.editors.modified.getModel();
  }
  getModifiedOptions() {
    return this.editors.modified.getOptions();
  }
  modifiedReveal(e) {
    e && (this.editors.modified.revealRange(e), this.editors.modified.setSelection(e)), this.editors.modified.focus();
  }
  modifiedSetSelection(e) {
    this.editors.modified.setSelection(e);
  }
  modifiedFocus() {
    this.editors.modified.focus();
  }
  getModifiedPosition() {
    var e;
    return (e = this.editors.modified.getPosition()) !== null && e !== void 0 ? e : void 0;
  }
}
class wc extends P {
  constructor(e, t, i, n, s) {
    super(), this._rootElement = e, this._diffModel = t, this._originalEditorLayoutInfo = i, this._modifiedEditorLayoutInfo = n, this._editors = s, this._originalScrollTop = Lt(this._editors.original.onDidScrollChange, () => this._editors.original.getScrollTop()), this._modifiedScrollTop = Lt(this._editors.modified.onDidScrollChange, () => this._editors.modified.getScrollTop()), this._viewZonesChanged = Mn("onDidChangeViewZones", this._editors.modified.onDidChangeViewZones), this.width = rt(this, 0), this._modifiedViewZonesChangedSignal = Mn("modified.onDidChangeViewZones", this._editors.modified.onDidChangeViewZones), this._originalViewZonesChangedSignal = Mn("original.onDidChangeViewZones", this._editors.original.onDidChangeViewZones), this._state = ig(this, (c, h) => {
      var u;
      this._element.replaceChildren();
      const g = this._diffModel.read(c), f = (u = g == null ? void 0 : g.diff.read(c)) === null || u === void 0 ? void 0 : u.movedTexts;
      if (!f || f.length === 0) {
        this.width.set(0, void 0);
        return;
      }
      this._viewZonesChanged.read(c);
      const m = this._originalEditorLayoutInfo.read(c), _ = this._modifiedEditorLayoutInfo.read(c);
      if (!m || !_) {
        this.width.set(0, void 0);
        return;
      }
      this._modifiedViewZonesChangedSignal.read(c), this._originalViewZonesChangedSignal.read(c);
      const v = f.map((E) => {
        function N(ze, pe) {
          const $e = pe.getTopForLineNumber(ze.startLineNumber, !0), Be = pe.getTopForLineNumber(ze.endLineNumberExclusive, !0);
          return ($e + Be) / 2;
        }
        const F = N(E.lineRangeMapping.original, this._editors.original), V = this._originalScrollTop.read(c), Z = N(E.lineRangeMapping.modified, this._editors.modified), H = this._modifiedScrollTop.read(c), re = F - V, ue = Z - H, Ve = Math.min(F, Z), Ye = Math.max(F, Z);
        return { range: new tn(Ve, Ye), from: re, to: ue, fromWithoutScroll: F, toWithoutScroll: Z, move: E };
      });
      v.sort(j5(cr((E) => E.fromWithoutScroll > E.toWithoutScroll, Z5), cr((E) => E.fromWithoutScroll > E.toWithoutScroll ? E.fromWithoutScroll : -E.toWithoutScroll, Zu)));
      const b = UM.compute(v.map((E) => E.range)), C = 10, w = m.verticalScrollbarWidth, S = (b.getTrackCount() - 1) * 10 + C * 2, y = w + S + (_.contentLeft - wc.movedCodeBlockPadding);
      let k = 0;
      for (const E of v) {
        const N = b.getTrack(k), F = w + C + N * 10, V = 15, Z = 15, H = y, re = _.glyphMarginWidth + _.lineNumbersWidth, ue = 18, Ve = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        Ve.classList.add("arrow-rectangle"), Ve.setAttribute("x", `${H - re}`), Ve.setAttribute("y", `${E.to - ue / 2}`), Ve.setAttribute("width", `${re}`), Ve.setAttribute("height", `${ue}`), this._element.appendChild(Ve);
        const Ye = document.createElementNS("http://www.w3.org/2000/svg", "g"), ze = document.createElementNS("http://www.w3.org/2000/svg", "path");
        ze.setAttribute("d", `M 0 ${E.from} L ${F} ${E.from} L ${F} ${E.to} L ${H - Z} ${E.to}`), ze.setAttribute("fill", "none"), Ye.appendChild(ze);
        const pe = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
        pe.classList.add("arrow"), h.add(qe(($e) => {
          ze.classList.toggle("currentMove", E.move === g.activeMovedText.read($e)), pe.classList.toggle("currentMove", E.move === g.activeMovedText.read($e));
        })), pe.setAttribute("points", `${H - Z},${E.to - V / 2} ${H},${E.to} ${H - Z},${E.to + V / 2}`), Ye.appendChild(pe), this._element.appendChild(Ye), k++;
      }
      this.width.set(S, void 0);
    }), this._element = document.createElementNS("http://www.w3.org/2000/svg", "svg"), this._element.setAttribute("class", "moved-blocks-lines"), this._rootElement.appendChild(this._element), this._register(Se(() => this._element.remove())), this._register(qe((c) => {
      const h = this._originalEditorLayoutInfo.read(c), u = this._modifiedEditorLayoutInfo.read(c);
      !h || !u || (this._element.style.left = `${h.width - h.verticalScrollbarWidth}px`, this._element.style.height = `${h.height}px`, this._element.style.width = `${h.verticalScrollbarWidth + h.contentLeft - wc.movedCodeBlockPadding + this.width.read(c)}px`);
    })), this._register(xb(this._state));
    const o = Pe((c) => {
      const h = this._diffModel.read(c), u = h == null ? void 0 : h.diff.read(c);
      return u ? u.movedTexts.map((g) => ({
        move: g,
        original: new Cy(Hr(g.lineRangeMapping.original.startLineNumber - 1), 18),
        modified: new Cy(Hr(g.lineRangeMapping.modified.startLineNumber - 1), 18)
      })) : [];
    });
    this._register(wy(this._editors.original, o.map((c) => (
      /** @description movedBlockViewZones.original */
      c.map((h) => h.original)
    )))), this._register(wy(this._editors.modified, o.map((c) => (
      /** @description movedBlockViewZones.modified */
      c.map((h) => h.modified)
    )))), this._register(Wo((c, h) => {
      const u = o.read(c);
      for (const g of u)
        h.add(new WF(this._editors.original, g.original, g.move, "original", this._diffModel.get())), h.add(new WF(this._editors.modified, g.modified, g.move, "modified", this._diffModel.get()));
    }));
    const a = Mn("original.onDidFocusEditorWidget", (c) => this._editors.original.onDidFocusEditorWidget(() => setTimeout(() => c(void 0), 0))), l = Mn("modified.onDidFocusEditorWidget", (c) => this._editors.modified.onDidFocusEditorWidget(() => setTimeout(() => c(void 0), 0)));
    let d = "modified";
    this._register(kb({
      createEmptyChangeSummary: () => {
      },
      handleChange: (c, h) => (c.didChange(a) && (d = "original"), c.didChange(l) && (d = "modified"), !0)
    }, (c) => {
      a.read(c), l.read(c);
      const h = this._diffModel.read(c);
      if (!h)
        return;
      const u = h.diff.read(c);
      let g;
      if (u && d === "original") {
        const f = this._editors.originalCursor.read(c);
        f && (g = u.movedTexts.find((m) => m.lineRangeMapping.original.contains(f.lineNumber)));
      }
      if (u && d === "modified") {
        const f = this._editors.modifiedCursor.read(c);
        f && (g = u.movedTexts.find((m) => m.lineRangeMapping.modified.contains(f.lineNumber)));
      }
      g !== h.movedTextToCompare.get() && h.movedTextToCompare.set(void 0, void 0), h.setActiveMovedText(g);
    }));
  }
}
wc.movedCodeBlockPadding = 4;
class UM {
  static compute(e) {
    const t = [], i = [];
    for (const n of e) {
      let s = t.findIndex((o) => !o.intersectsStrict(n));
      s === -1 && (t.length >= 6 ? s = q5(t, cr((a) => a.intersectWithRangeLength(n), Zu)) : (s = t.length, t.push(new G5()))), t[s].addRange(n), i.push(s);
    }
    return new UM(t.length, i);
  }
  constructor(e, t) {
    this._trackCount = e, this.trackPerLineIdx = t;
  }
  getTrack(e) {
    return this.trackPerLineIdx[e];
  }
  getTrackCount() {
    return this._trackCount;
  }
}
class WF extends I3 {
  constructor(e, t, i, n, s) {
    const o = ft("div.diff-hidden-lines-widget");
    super(e, t, o.root), this._editor = e, this._move = i, this._kind = n, this._diffModel = s, this._nodes = ft("div.diff-moved-code-block", { style: { marginRight: "4px" } }, [
      ft("div.text-content@textContent"),
      ft("div.action-bar@actionBar")
    ]), o.root.appendChild(this._nodes.root);
    const a = Lt(this._editor.onDidLayoutChange, () => this._editor.getLayoutInfo());
    this._register(Vc(this._nodes.root, {
      paddingRight: a.map((u) => u.verticalScrollbarWidth)
    }));
    let l;
    i.changes.length > 0 ? l = this._kind === "original" ? p("codeMovedToWithChanges", "Code moved with changes to line {0}-{1}", this._move.lineRangeMapping.modified.startLineNumber, this._move.lineRangeMapping.modified.endLineNumberExclusive - 1) : p("codeMovedFromWithChanges", "Code moved with changes from line {0}-{1}", this._move.lineRangeMapping.original.startLineNumber, this._move.lineRangeMapping.original.endLineNumberExclusive - 1) : l = this._kind === "original" ? p("codeMovedTo", "Code moved to line {0}-{1}", this._move.lineRangeMapping.modified.startLineNumber, this._move.lineRangeMapping.modified.endLineNumberExclusive - 1) : p("codeMovedFrom", "Code moved from line {0}-{1}", this._move.lineRangeMapping.original.startLineNumber, this._move.lineRangeMapping.original.endLineNumberExclusive - 1);
    const d = this._register(new Bo(this._nodes.actionBar, {
      highlightToggledItems: !0
    })), c = new Bs("", l, "", !1);
    d.push(c, { icon: !1, label: !0 });
    const h = new Bs("", "Compare", Le.asClassName(me.compareChanges), !0, () => {
      this._editor.focus(), this._diffModel.movedTextToCompare.set(this._diffModel.movedTextToCompare.get() === i ? void 0 : this._move, void 0);
    });
    this._register(qe((u) => {
      const g = this._diffModel.movedTextToCompare.read(u) === i;
      h.checked = g;
    })), d.push(h, { icon: !1, label: !0 });
  }
}
I("diffEditor.move.border", { dark: "#8b8b8b9c", light: "#8b8b8b9c", hcDark: "#8b8b8b9c", hcLight: "#8b8b8b9c" }, p("diffEditor.move.border", "The border color for text that got moved in the diff editor."));
I("diffEditor.moveActive.border", { dark: "#FFA500", light: "#FFA500", hcDark: "#FFA500", hcLight: "#FFA500" }, p("diffEditor.moveActive.border", "The active border color for text that got moved in the diff editor."));
I("diffEditor.unchangedRegionShadow", { dark: "#000000", light: "#737373BF", hcDark: "#000000", hcLight: "#737373BF" }, p("diffEditor.unchangedRegionShadow", "The color of the shadow around unchanged region widgets."));
const pre = hi("diff-insert", me.add, p("diffInsertIcon", "Line decoration for inserts in the diff editor.")), E3 = hi("diff-remove", me.remove, p("diffRemoveIcon", "Line decoration for removals in the diff editor.")), BF = Fe.register({
  className: "line-insert",
  description: "line-insert",
  isWholeLine: !0,
  linesDecorationsClassName: "insert-sign " + Le.asClassName(pre),
  marginClassName: "gutter-insert"
}), HF = Fe.register({
  className: "line-delete",
  description: "line-delete",
  isWholeLine: !0,
  linesDecorationsClassName: "delete-sign " + Le.asClassName(E3),
  marginClassName: "gutter-delete"
}), VF = Fe.register({
  className: "line-insert",
  description: "line-insert",
  isWholeLine: !0,
  marginClassName: "gutter-insert"
}), zF = Fe.register({
  className: "line-delete",
  description: "line-delete",
  isWholeLine: !0,
  marginClassName: "gutter-delete"
}), UF = Fe.register({
  className: "char-insert",
  description: "char-insert",
  shouldFillLineOnLineBreak: !0
}), mre = Fe.register({
  className: "char-insert",
  description: "char-insert",
  isWholeLine: !0
}), _re = Fe.register({
  className: "char-insert diff-range-empty",
  description: "char-insert diff-range-empty"
}), OE = Fe.register({
  className: "char-delete",
  description: "char-delete",
  shouldFillLineOnLineBreak: !0
}), vre = Fe.register({
  className: "char-delete",
  description: "char-delete",
  isWholeLine: !0
}), bre = Fe.register({
  className: "char-delete diff-range-empty",
  description: "char-delete diff-range-empty"
});
class Cre extends P {
  constructor(e, t, i, n) {
    super(), this._editors = e, this._diffModel = t, this._options = i, this._decorations = Pe(this, (s) => {
      var o;
      const a = (o = this._diffModel.read(s)) === null || o === void 0 ? void 0 : o.diff.read(s);
      if (!a)
        return null;
      const l = this._diffModel.read(s).movedTextToCompare.read(s), d = this._options.renderIndicators.read(s), c = this._options.showEmptyDecorations.read(s), h = [], u = [];
      if (!l)
        for (const f of a.mappings)
          if (f.lineRangeMapping.original.isEmpty || h.push({ range: f.lineRangeMapping.original.toInclusiveRange(), options: d ? HF : zF }), f.lineRangeMapping.modified.isEmpty || u.push({ range: f.lineRangeMapping.modified.toInclusiveRange(), options: d ? BF : VF }), f.lineRangeMapping.modified.isEmpty || f.lineRangeMapping.original.isEmpty)
            f.lineRangeMapping.original.isEmpty || h.push({ range: f.lineRangeMapping.original.toInclusiveRange(), options: vre }), f.lineRangeMapping.modified.isEmpty || u.push({ range: f.lineRangeMapping.modified.toInclusiveRange(), options: mre });
          else
            for (const m of f.lineRangeMapping.innerChanges || [])
              f.lineRangeMapping.original.contains(m.originalRange.startLineNumber) && h.push({ range: m.originalRange, options: m.originalRange.isEmpty() && c ? bre : OE }), f.lineRangeMapping.modified.contains(m.modifiedRange.startLineNumber) && u.push({ range: m.modifiedRange, options: m.modifiedRange.isEmpty() && c ? _re : UF });
      if (l)
        for (const f of l.changes) {
          const m = f.original.toInclusiveRange();
          m && h.push({ range: m, options: d ? HF : zF });
          const _ = f.modified.toInclusiveRange();
          _ && u.push({ range: _, options: d ? BF : VF });
          for (const v of f.innerChanges || [])
            h.push({ range: v.originalRange, options: OE }), u.push({ range: v.modifiedRange, options: UF });
        }
      const g = this._diffModel.read(s).activeMovedText.read(s);
      for (const f of a.movedTexts)
        h.push({
          range: f.lineRangeMapping.original.toInclusiveRange(),
          options: {
            description: "moved",
            blockClassName: "movedOriginal" + (f === g ? " currentMove" : ""),
            blockPadding: [wc.movedCodeBlockPadding, 0, wc.movedCodeBlockPadding, wc.movedCodeBlockPadding]
          }
        }), u.push({
          range: f.lineRangeMapping.modified.toInclusiveRange(),
          options: {
            description: "moved",
            blockClassName: "movedModified" + (f === g ? " currentMove" : ""),
            blockPadding: [4, 0, 4, 4]
          }
        });
      return { originalDecorations: h, modifiedDecorations: u };
    }), this._register(by(this._editors.original, this._decorations.map((s) => (s == null ? void 0 : s.originalDecorations) || []))), this._register(by(this._editors.modified, this._decorations.map((s) => (s == null ? void 0 : s.modifiedDecorations) || [])));
  }
}
class wre {
  resetSash() {
    this._sashRatio.set(void 0, void 0);
  }
  constructor(e, t) {
    this._options = e, this.dimensions = t, this.sashLeft = Sz(this, (i) => {
      var n;
      const s = (n = this._sashRatio.read(i)) !== null && n !== void 0 ? n : this._options.splitViewDefaultRatio.read(i);
      return this._computeSashLeft(s, i);
    }, (i, n) => {
      const s = this.dimensions.width.get();
      this._sashRatio.set(i / s, n);
    }), this._sashRatio = rt(this, void 0);
  }
  /** @pure */
  _computeSashLeft(e, t) {
    const i = this.dimensions.width.read(t), n = Math.floor(this._options.splitViewDefaultRatio.read(t) * i), s = this._options.enableSplitViewResizing.read(t) ? Math.floor(e * i) : n, o = 100;
    return i <= o * 2 ? n : s < o ? o : s > i - o ? i - o : s;
  }
}
class T3 extends P {
  constructor(e, t, i, n, s, o) {
    super(), this._domNode = e, this._dimensions = t, this._enabled = i, this._boundarySashes = n, this.sashLeft = s, this._resetSash = o, this._sash = this._register(new En(this._domNode, {
      getVerticalSashTop: (a) => 0,
      getVerticalSashLeft: (a) => this.sashLeft.get(),
      getVerticalSashHeight: (a) => this._dimensions.height.get()
    }, {
      orientation: 0
      /* Orientation.VERTICAL */
    })), this._startSashPosition = void 0, this._register(this._sash.onDidStart(() => {
      this._startSashPosition = this.sashLeft.get();
    })), this._register(this._sash.onDidChange((a) => {
      this.sashLeft.set(this._startSashPosition + (a.currentX - a.startX), void 0);
    })), this._register(this._sash.onDidEnd(() => this._sash.layout())), this._register(this._sash.onDidReset(() => this._resetSash())), this._register(qe((a) => {
      const l = this._boundarySashes.read(a);
      l && (this._sash.orthogonalEndSash = l.bottom);
    })), this._register(qe((a) => {
      const l = this._enabled.read(a);
      this._sash.state = l ? 3 : 0, this.sashLeft.read(a), this._dimensions.height.read(a), this._sash.layout();
    }));
  }
}
var N3 = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, FE = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, Mh;
const M3 = et("diffProviderFactoryService");
let WE = class {
  constructor(e) {
    this.instantiationService = e;
  }
  createDiffProvider(e) {
    return this.instantiationService.createInstance(Sy, e);
  }
};
WE = N3([
  FE(0, be)
], WE);
ot(
  M3,
  WE,
  1
  /* InstantiationType.Delayed */
);
let Sy = Mh = class {
  constructor(e, t, i) {
    this.editorWorkerService = t, this.telemetryService = i, this.onDidChangeEventEmitter = new R(), this.onDidChange = this.onDidChangeEventEmitter.event, this.diffAlgorithm = "advanced", this.diffAlgorithmOnDidChangeSubscription = void 0, this.setOptions(e);
  }
  dispose() {
    var e;
    (e = this.diffAlgorithmOnDidChangeSubscription) === null || e === void 0 || e.dispose();
  }
  async computeDiff(e, t, i, n) {
    var s, o;
    if (typeof this.diffAlgorithm != "string")
      return this.diffAlgorithm.computeDiff(e, t, i, n);
    if (e.isDisposed() || t.isDisposed())
      return {
        changes: [],
        identical: !0,
        quitEarly: !1,
        moves: []
      };
    if (e.getLineCount() === 1 && e.getLineMaxColumn(1) === 1)
      return t.getLineCount() === 1 && t.getLineMaxColumn(1) === 1 ? {
        changes: [],
        identical: !0,
        quitEarly: !1,
        moves: []
      } : {
        changes: [
          new nb(new Yt(1, 2), new Yt(1, t.getLineCount() + 1), [
            new VN(e.getFullModelRange(), t.getFullModelRange())
          ])
        ],
        identical: !1,
        quitEarly: !1,
        moves: []
      };
    const a = JSON.stringify([e.uri.toString(), t.uri.toString()]), l = JSON.stringify([e.id, t.id, e.getAlternativeVersionId(), t.getAlternativeVersionId(), JSON.stringify(i)]), d = Mh.diffCache.get(a);
    if (d && d.context === l)
      return d.result;
    const c = rs.create(), h = await this.editorWorkerService.computeDiff(e.uri, t.uri, i, this.diffAlgorithm), u = c.elapsed();
    if (this.telemetryService.publicLog2("diffEditor.computeDiff", {
      timeMs: u,
      timedOut: (s = h == null ? void 0 : h.quitEarly) !== null && s !== void 0 ? s : !0,
      detectedMoves: i.computeMoves ? (o = h == null ? void 0 : h.moves.length) !== null && o !== void 0 ? o : 0 : -1
    }), n.isCancellationRequested)
      return {
        changes: [],
        identical: !1,
        quitEarly: !0,
        moves: []
      };
    if (!h)
      throw new Error("no diff result available");
    return Mh.diffCache.size > 10 && Mh.diffCache.delete(Mh.diffCache.keys().next().value), Mh.diffCache.set(a, { result: h, context: l }), h;
  }
  setOptions(e) {
    var t;
    let i = !1;
    e.diffAlgorithm && this.diffAlgorithm !== e.diffAlgorithm && ((t = this.diffAlgorithmOnDidChangeSubscription) === null || t === void 0 || t.dispose(), this.diffAlgorithmOnDidChangeSubscription = void 0, this.diffAlgorithm = e.diffAlgorithm, typeof e.diffAlgorithm != "string" && (this.diffAlgorithmOnDidChangeSubscription = e.diffAlgorithm.onDidChange(() => this.onDidChangeEventEmitter.fire())), i = !0), i && this.onDidChangeEventEmitter.fire();
  }
};
Sy.diffCache = /* @__PURE__ */ new Map();
Sy = Mh = N3([
  FE(1, Uo),
  FE(2, kn)
], Sy);
var Sre = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, yre = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
let BE = class extends P {
  setActiveMovedText(e) {
    this._activeMovedText.set(e, void 0);
  }
  constructor(e, t, i) {
    super(), this.model = e, this._options = t, this._diffProviderFactoryService = i, this._isDiffUpToDate = rt(this, !1), this.isDiffUpToDate = this._isDiffUpToDate, this._diff = rt(this, void 0), this.diff = this._diff, this._unchangedRegions = rt(this, void 0), this.unchangedRegions = Pe(this, (a) => {
      var l, d;
      return this._options.hideUnchangedRegions.read(a) ? (d = (l = this._unchangedRegions.read(a)) === null || l === void 0 ? void 0 : l.regions) !== null && d !== void 0 ? d : [] : (Nt((c) => {
        var h;
        for (const u of ((h = this._unchangedRegions.get()) === null || h === void 0 ? void 0 : h.regions) || [])
          u.collapseAll(c);
      }), []);
    }), this.movedTextToCompare = rt(this, void 0), this._activeMovedText = rt(this, void 0), this._hoveredMovedText = rt(this, void 0), this.activeMovedText = Pe(this, (a) => {
      var l, d;
      return (d = (l = this.movedTextToCompare.read(a)) !== null && l !== void 0 ? l : this._hoveredMovedText.read(a)) !== null && d !== void 0 ? d : this._activeMovedText.read(a);
    }), this._cancellationTokenSource = new mi(), this._diffProvider = Pe(this, (a) => {
      const l = this._diffProviderFactoryService.createDiffProvider({
        diffAlgorithm: this._options.diffAlgorithm.read(a)
      }), d = Mn("onDidChange", l.onDidChange);
      return {
        diffProvider: l,
        onChangeSignal: d
      };
    }), this._register(Se(() => this._cancellationTokenSource.cancel()));
    const n = Q0("contentChangedSignal"), s = this._register(new xt(() => n.trigger(void 0), 200));
    this._register(qe((a) => {
      const l = this._unchangedRegions.read(a);
      if (!l || l.regions.some((f) => f.isDragged.read(a)))
        return;
      const d = l.originalDecorationIds.map((f) => e.original.getDecorationRange(f)).map((f) => f ? Yt.fromRangeInclusive(f) : void 0), c = l.modifiedDecorationIds.map((f) => e.modified.getDecorationRange(f)).map((f) => f ? Yt.fromRangeInclusive(f) : void 0), h = l.regions.map((f, m) => !d[m] || !c[m] ? void 0 : new dc(d[m].startLineNumber, c[m].startLineNumber, d[m].length, f.visibleLineCountTop.read(a), f.visibleLineCountBottom.read(a))).filter(qa), u = [];
      let g = !1;
      for (const f of gH(h, (m, _) => m.getHiddenModifiedRange(a).endLineNumberExclusive === _.getHiddenModifiedRange(a).startLineNumber))
        if (f.length > 1) {
          g = !0;
          const m = f.reduce((v, b) => v + b.lineCount, 0), _ = new dc(f[0].originalLineNumber, f[0].modifiedLineNumber, m, f[0].visibleLineCountTop.get(), f[f.length - 1].visibleLineCountBottom.get());
          u.push(_);
        } else
          u.push(f[0]);
      if (g) {
        const f = e.original.deltaDecorations(l.originalDecorationIds, u.map((_) => ({ range: _.originalUnchangedRange.toInclusiveRange(), options: { description: "unchanged" } }))), m = e.modified.deltaDecorations(l.modifiedDecorationIds, u.map((_) => ({ range: _.modifiedUnchangedRange.toInclusiveRange(), options: { description: "unchanged" } })));
        Nt((_) => {
          this._unchangedRegions.set({
            regions: u,
            originalDecorationIds: f,
            modifiedDecorationIds: m
          }, _);
        });
      }
    }));
    const o = (a, l, d) => {
      const c = dc.fromDiffs(a.changes, e.original.getLineCount(), e.modified.getLineCount(), this._options.hideUnchangedRegionsMinimumLineCount.read(d), this._options.hideUnchangedRegionsContextLineCount.read(d));
      let h;
      const u = this._unchangedRegions.get();
      if (u) {
        const _ = u.originalDecorationIds.map((w) => e.original.getDecorationRange(w)).map((w) => w ? Yt.fromRangeInclusive(w) : void 0), v = u.modifiedDecorationIds.map((w) => e.modified.getDecorationRange(w)).map((w) => w ? Yt.fromRangeInclusive(w) : void 0);
        let C = sre(u.regions.map((w, S) => {
          if (!_[S] || !v[S])
            return;
          const y = _[S].length;
          return new dc(
            _[S].startLineNumber,
            v[S].startLineNumber,
            y,
            // The visible area can shrink by edits -> we have to account for this
            Math.min(w.visibleLineCountTop.get(), y),
            Math.min(w.visibleLineCountBottom.get(), y - w.visibleLineCountTop.get())
          );
        }).filter(qa), (w, S) => !S || w.modifiedLineNumber >= S.modifiedLineNumber + S.lineCount && w.originalLineNumber >= S.originalLineNumber + S.lineCount).map((w) => new cf(w.getHiddenOriginalRange(d), w.getHiddenModifiedRange(d)));
        C = cf.clip(C, Yt.ofLength(1, e.original.getLineCount()), Yt.ofLength(1, e.modified.getLineCount())), h = cf.inverse(C, e.original.getLineCount(), e.modified.getLineCount());
      }
      const g = [];
      if (h)
        for (const _ of c) {
          const v = h.filter((b) => b.original.intersectsStrict(_.originalUnchangedRange) && b.modified.intersectsStrict(_.modifiedUnchangedRange));
          g.push(..._.setVisibleRanges(v, l));
        }
      else
        g.push(...c);
      const f = e.original.deltaDecorations((u == null ? void 0 : u.originalDecorationIds) || [], g.map((_) => ({ range: _.originalUnchangedRange.toInclusiveRange(), options: { description: "unchanged" } }))), m = e.modified.deltaDecorations((u == null ? void 0 : u.modifiedDecorationIds) || [], g.map((_) => ({ range: _.modifiedUnchangedRange.toInclusiveRange(), options: { description: "unchanged" } })));
      this._unchangedRegions.set({
        regions: g,
        originalDecorationIds: f,
        modifiedDecorationIds: m
      }, l);
    };
    this._register(e.modified.onDidChangeContent((a) => {
      if (this._diff.get()) {
        const d = Xl.fromModelContentChanges(a.changes);
        this._lastDiff, e.original, e.modified;
      }
      this._isDiffUpToDate.set(!1, void 0), s.schedule();
    })), this._register(e.original.onDidChangeContent((a) => {
      if (this._diff.get()) {
        const d = Xl.fromModelContentChanges(a.changes);
        this._lastDiff, e.original, e.modified;
      }
      this._isDiffUpToDate.set(!1, void 0), s.schedule();
    })), this._register(Wo(async (a, l) => {
      var d, c;
      this._options.hideUnchangedRegionsMinimumLineCount.read(a), this._options.hideUnchangedRegionsContextLineCount.read(a), s.cancel(), n.read(a);
      const h = this._diffProvider.read(a);
      h.onChangeSignal.read(a), er(Y5, a), er(Q5, a), this._isDiffUpToDate.set(!1, void 0);
      let u = [];
      l.add(e.original.onDidChangeContent((m) => {
        const _ = Xl.fromModelContentChanges(m.changes);
        u = ES(u, _);
      }));
      let g = [];
      l.add(e.modified.onDidChangeContent((m) => {
        const _ = Xl.fromModelContentChanges(m.changes);
        g = ES(g, _);
      }));
      let f = await h.diffProvider.computeDiff(e.original, e.modified, {
        ignoreTrimWhitespace: this._options.ignoreTrimWhitespace.read(a),
        maxComputationTimeMs: this._options.maxComputationTimeMs.read(a),
        computeMoves: this._options.showMoves.read(a)
      }, this._cancellationTokenSource.token);
      this._cancellationTokenSource.token.isCancellationRequested || e.original.isDisposed() || e.modified.isDisposed() || (f = Lre(f, e.original, e.modified), f = (d = (e.original, e.modified, void 0)) !== null && d !== void 0 ? d : f, f = (c = (e.original, e.modified, void 0)) !== null && c !== void 0 ? c : f, Nt((m) => {
        o(f, m), this._lastDiff = f;
        const _ = $M.fromDiffResult(f);
        this._diff.set(_, m), this._isDiffUpToDate.set(!0, m);
        const v = this.movedTextToCompare.get();
        this.movedTextToCompare.set(v ? this._lastDiff.moves.find((b) => b.lineRangeMapping.modified.intersect(v.lineRangeMapping.modified)) : void 0, m);
      }));
    }));
  }
  ensureModifiedLineIsVisible(e, t, i) {
    var n, s;
    if (((n = this.diff.get()) === null || n === void 0 ? void 0 : n.mappings.length) === 0)
      return;
    const o = ((s = this._unchangedRegions.get()) === null || s === void 0 ? void 0 : s.regions) || [];
    for (const a of o)
      if (a.getHiddenModifiedRange(void 0).contains(e)) {
        a.showModifiedLine(e, t, i);
        return;
      }
  }
  ensureOriginalLineIsVisible(e, t, i) {
    var n, s;
    if (((n = this.diff.get()) === null || n === void 0 ? void 0 : n.mappings.length) === 0)
      return;
    const o = ((s = this._unchangedRegions.get()) === null || s === void 0 ? void 0 : s.regions) || [];
    for (const a of o)
      if (a.getHiddenOriginalRange(void 0).contains(e)) {
        a.showOriginalLine(e, t, i);
        return;
      }
  }
  async waitForDiff() {
    await yz(this.isDiffUpToDate, (e) => e);
  }
  serializeState() {
    const e = this._unchangedRegions.get();
    return {
      collapsedRegions: e == null ? void 0 : e.regions.map((t) => ({ range: t.getHiddenModifiedRange(void 0).serialize() }))
    };
  }
  restoreSerializedState(e) {
    var t;
    const i = (t = e.collapsedRegions) === null || t === void 0 ? void 0 : t.map((s) => Yt.deserialize(s.range)), n = this._unchangedRegions.get();
    !n || !i || Nt((s) => {
      for (const o of n.regions)
        for (const a of i)
          if (o.modifiedUnchangedRange.intersect(a)) {
            o.setHiddenModifiedRange(a, s);
            break;
          }
    });
  }
};
BE = Sre([
  yre(2, M3)
], BE);
function Lre(r, e, t) {
  return {
    changes: r.changes.map((i) => new nb(i.original, i.modified, i.innerChanges ? i.innerChanges.map((n) => Dre(n, e, t)) : void 0)),
    moves: r.moves,
    identical: r.identical,
    quitEarly: r.quitEarly
  };
}
function Dre(r, e, t) {
  let i = r.originalRange, n = r.modifiedRange;
  return (i.endColumn !== 1 || n.endColumn !== 1) && i.endColumn === e.getLineMaxColumn(i.endLineNumber) && n.endColumn === t.getLineMaxColumn(n.endLineNumber) && i.endLineNumber < e.getLineCount() && n.endLineNumber < t.getLineCount() && (i = i.setEndPosition(i.endLineNumber + 1, 1), n = n.setEndPosition(n.endLineNumber + 1, 1)), new VN(i, n);
}
class $M {
  static fromDiffResult(e) {
    return new $M(e.changes.map((t) => new R3(t)), e.moves || [], e.identical, e.quitEarly);
  }
  constructor(e, t, i, n) {
    this.mappings = e, this.movedTexts = t, this.identical = i, this.quitEarly = n;
  }
}
class R3 {
  constructor(e) {
    this.lineRangeMapping = e;
  }
}
class dc {
  static fromDiffs(e, t, i, n, s) {
    const o = nb.inverse(e, t, i), a = [];
    for (const l of o) {
      let d = l.original.startLineNumber, c = l.modified.startLineNumber, h = l.original.length;
      const u = d === 1 && c === 1, g = d + h === t + 1 && c + h === i + 1;
      (u || g) && h >= s + n ? (u && !g && (h -= s), g && !u && (d += s, c += s, h -= s), a.push(new dc(d, c, h, 0, 0))) : h >= s * 2 + n && (d += s, c += s, h -= s * 2, a.push(new dc(d, c, h, 0, 0)));
    }
    return a;
  }
  get originalUnchangedRange() {
    return Yt.ofLength(this.originalLineNumber, this.lineCount);
  }
  get modifiedUnchangedRange() {
    return Yt.ofLength(this.modifiedLineNumber, this.lineCount);
  }
  constructor(e, t, i, n, s) {
    this.originalLineNumber = e, this.modifiedLineNumber = t, this.lineCount = i, this._visibleLineCountTop = rt(this, 0), this.visibleLineCountTop = this._visibleLineCountTop, this._visibleLineCountBottom = rt(this, 0), this.visibleLineCountBottom = this._visibleLineCountBottom, this._shouldHideControls = Pe(this, (l) => (
      /** @description isVisible */
      this.visibleLineCountTop.read(l) + this.visibleLineCountBottom.read(l) === this.lineCount && !this.isDragged.read(l)
    )), this.isDragged = rt(this, void 0);
    const o = Math.max(Math.min(n, this.lineCount), 0), a = Math.max(Math.min(s, this.lineCount - n), 0);
    dA(n === o), dA(s === a), this._visibleLineCountTop.set(o, void 0), this._visibleLineCountBottom.set(a, void 0);
  }
  setVisibleRanges(e, t) {
    const i = [], n = new GN(e.map((l) => l.modified)).subtractFrom(this.modifiedUnchangedRange);
    let s = this.originalLineNumber, o = this.modifiedLineNumber;
    const a = this.modifiedLineNumber + this.lineCount;
    if (n.ranges.length === 0)
      this.showAll(t), i.push(this);
    else {
      let l = 0;
      for (const d of n.ranges) {
        const c = l === n.ranges.length - 1;
        l++;
        const h = (c ? a : d.endLineNumberExclusive) - o, u = new dc(s, o, h, 0, 0);
        u.setHiddenModifiedRange(d, t), i.push(u), s = u.originalUnchangedRange.endLineNumberExclusive, o = u.modifiedUnchangedRange.endLineNumberExclusive;
      }
    }
    return i;
  }
  shouldHideControls(e) {
    return this._shouldHideControls.read(e);
  }
  getHiddenOriginalRange(e) {
    return Yt.ofLength(this.originalLineNumber + this._visibleLineCountTop.read(e), this.lineCount - this._visibleLineCountTop.read(e) - this._visibleLineCountBottom.read(e));
  }
  getHiddenModifiedRange(e) {
    return Yt.ofLength(this.modifiedLineNumber + this._visibleLineCountTop.read(e), this.lineCount - this._visibleLineCountTop.read(e) - this._visibleLineCountBottom.read(e));
  }
  setHiddenModifiedRange(e, t) {
    const i = e.startLineNumber - this.modifiedLineNumber, n = this.modifiedLineNumber + this.lineCount - e.endLineNumberExclusive;
    this.setState(i, n, t);
  }
  getMaxVisibleLineCountTop() {
    return this.lineCount - this._visibleLineCountBottom.get();
  }
  getMaxVisibleLineCountBottom() {
    return this.lineCount - this._visibleLineCountTop.get();
  }
  showMoreAbove(e = 10, t) {
    const i = this.getMaxVisibleLineCountTop();
    this._visibleLineCountTop.set(Math.min(this._visibleLineCountTop.get() + e, i), t);
  }
  showMoreBelow(e = 10, t) {
    const i = this.lineCount - this._visibleLineCountTop.get();
    this._visibleLineCountBottom.set(Math.min(this._visibleLineCountBottom.get() + e, i), t);
  }
  showAll(e) {
    this._visibleLineCountBottom.set(this.lineCount - this._visibleLineCountTop.get(), e);
  }
  showModifiedLine(e, t, i) {
    const n = e + 1 - (this.modifiedLineNumber + this._visibleLineCountTop.get()), s = this.modifiedLineNumber - this._visibleLineCountBottom.get() + this.lineCount - e;
    t === 0 && n < s || t === 1 ? this._visibleLineCountTop.set(this._visibleLineCountTop.get() + n, i) : this._visibleLineCountBottom.set(this._visibleLineCountBottom.get() + s, i);
  }
  showOriginalLine(e, t, i) {
    const n = e - this.originalLineNumber, s = this.originalLineNumber + this.lineCount - e;
    t === 0 && n < s || t === 1 ? this._visibleLineCountTop.set(Math.min(this._visibleLineCountTop.get() + s - n, this.getMaxVisibleLineCountTop()), i) : this._visibleLineCountBottom.set(Math.min(this._visibleLineCountBottom.get() + n - s, this.getMaxVisibleLineCountBottom()), i);
  }
  collapseAll(e) {
    this._visibleLineCountTop.set(0, e), this._visibleLineCountBottom.set(0, e);
  }
  setState(e, t, i) {
    e = Math.max(Math.min(e, this.lineCount), 0), t = Math.max(Math.min(t, this.lineCount - e), 0), this._visibleLineCountTop.set(e, i), this._visibleLineCountBottom.set(t, i);
  }
}
class kre extends P {
  get visibility() {
    return this._visibility;
  }
  set visibility(e) {
    this._visibility !== e && (this._visibility = e, this._diffActions.style.visibility = e ? "visible" : "hidden");
  }
  constructor(e, t, i, n, s, o, a, l, d) {
    super(), this._getViewZoneId = e, this._marginDomNode = t, this._modifiedEditor = i, this._diff = n, this._editor = s, this._viewLineCounts = o, this._originalTextModel = a, this._contextMenuService = l, this._clipboardService = d, this._visibility = !1, this._marginDomNode.style.zIndex = "10", this._diffActions = document.createElement("div"), this._diffActions.className = Le.asClassName(me.lightBulb) + " lightbulb-glyph", this._diffActions.style.position = "absolute";
    const c = this._modifiedEditor.getOption(
      67
      /* EditorOption.lineHeight */
    );
    this._diffActions.style.right = "0px", this._diffActions.style.visibility = "hidden", this._diffActions.style.height = `${c}px`, this._diffActions.style.lineHeight = `${c}px`, this._marginDomNode.appendChild(this._diffActions);
    let h = 0;
    const u = i.getOption(
      127
      /* EditorOption.useShadowDOM */
    ) && !Zr, g = (f, m) => {
      var _;
      this._contextMenuService.showContextMenu({
        domForShadowRoot: u && (_ = i.getDomNode()) !== null && _ !== void 0 ? _ : void 0,
        getAnchor: () => ({ x: f, y: m }),
        getActions: () => {
          const v = [], b = n.modified.isEmpty;
          return v.push(new Bs("diff.clipboard.copyDeletedContent", b ? n.original.length > 1 ? p("diff.clipboard.copyDeletedLinesContent.label", "Copy deleted lines") : p("diff.clipboard.copyDeletedLinesContent.single.label", "Copy deleted line") : n.original.length > 1 ? p("diff.clipboard.copyChangedLinesContent.label", "Copy changed lines") : p("diff.clipboard.copyChangedLinesContent.single.label", "Copy changed line"), void 0, !0, async () => {
            const w = this._originalTextModel.getValueInRange(n.original.toExclusiveRange());
            await this._clipboardService.writeText(w);
          })), n.original.length > 1 && v.push(new Bs("diff.clipboard.copyDeletedLineContent", b ? p("diff.clipboard.copyDeletedLineContent.label", "Copy deleted line ({0})", n.original.startLineNumber + h) : p("diff.clipboard.copyChangedLineContent.label", "Copy changed line ({0})", n.original.startLineNumber + h), void 0, !0, async () => {
            let w = this._originalTextModel.getLineContent(n.original.startLineNumber + h);
            w === "" && (w = this._originalTextModel.getEndOfLineSequence() === 0 ? `
` : `\r
`), await this._clipboardService.writeText(w);
          })), i.getOption(
            91
            /* EditorOption.readOnly */
          ) || v.push(new Bs("diff.inline.revertChange", p("diff.inline.revertChange.label", "Revert this change"), void 0, !0, async () => {
            this._editor.revert(this._diff);
          })), v;
        },
        autoSelectFirstItem: !0
      });
    };
    this._register(pi(this._diffActions, "mousedown", (f) => {
      if (!f.leftButton)
        return;
      const { top: m, height: _ } = Ei(this._diffActions), v = Math.floor(c / 3);
      f.preventDefault(), g(f.posx, m + _ + v);
    })), this._register(i.onMouseMove((f) => {
      (f.target.type === 8 || f.target.type === 5) && f.target.detail.viewZoneId === this._getViewZoneId() ? (h = this._updateLightBulbPosition(this._marginDomNode, f.event.browserEvent.y, c), this.visibility = !0) : this.visibility = !1;
    })), this._register(i.onMouseDown((f) => {
      f.event.leftButton && (f.target.type === 8 || f.target.type === 5) && f.target.detail.viewZoneId === this._getViewZoneId() && (f.event.preventDefault(), h = this._updateLightBulbPosition(this._marginDomNode, f.event.browserEvent.y, c), g(f.event.posx, f.event.posy + c));
    }));
  }
  _updateLightBulbPosition(e, t, i) {
    const { top: n } = Ei(e), s = t - n, o = Math.floor(s / i), a = o * i;
    if (this._diffActions.style.top = `${a}px`, this._viewLineCounts) {
      let l = 0;
      for (let d = 0; d < this._viewLineCounts.length; d++)
        if (l += this._viewLineCounts[d], o < l)
          return d;
    }
    return o;
  }
}
const $F = wd("diffEditorWidget", { createHTML: (r) => r });
function xre(r, e, t, i) {
  _n(i, e.fontInfo);
  const n = t.length > 0, s = new Tp(1e4);
  let o = 0, a = 0;
  const l = [];
  for (let u = 0; u < r.lineTokens.length; u++) {
    const g = u + 1, f = r.lineTokens[u], m = r.lineBreakData[u], _ = ts.filter(t, g, 1, Number.MAX_SAFE_INTEGER);
    if (m) {
      let v = 0;
      for (const b of m.breakOffsets) {
        const C = f.sliceAndInflate(v, b, 0);
        o = Math.max(o, KF(a, C, ts.extractWrapped(_, v, b), n, r.mightContainNonBasicASCII, r.mightContainRTL, e, s)), a++, v = b;
      }
      l.push(m.breakOffsets.length);
    } else
      l.push(1), o = Math.max(o, KF(a, f, _, n, r.mightContainNonBasicASCII, r.mightContainRTL, e, s)), a++;
  }
  o += e.scrollBeyondLastColumn;
  const d = s.build(), c = $F ? $F.createHTML(d) : d;
  i.innerHTML = c;
  const h = o * e.typicalHalfwidthCharacterWidth;
  return {
    heightInLines: a,
    minWidthInPx: h,
    viewLineCounts: l
  };
}
class Ire {
  constructor(e, t, i, n) {
    this.lineTokens = e, this.lineBreakData = t, this.mightContainNonBasicASCII = i, this.mightContainRTL = n;
  }
}
class KM {
  static fromEditor(e) {
    var t;
    const i = e.getOptions(), n = i.get(
      50
      /* EditorOption.fontInfo */
    ), s = i.get(
      145
      /* EditorOption.layoutInfo */
    );
    return new KM(((t = e.getModel()) === null || t === void 0 ? void 0 : t.getOptions().tabSize) || 0, n, i.get(
      33
      /* EditorOption.disableMonospaceOptimizations */
    ), n.typicalHalfwidthCharacterWidth, i.get(
      104
      /* EditorOption.scrollBeyondLastColumn */
    ), i.get(
      67
      /* EditorOption.lineHeight */
    ), s.decorationsWidth, i.get(
      117
      /* EditorOption.stopRenderingLineAfter */
    ), i.get(
      99
      /* EditorOption.renderWhitespace */
    ), i.get(
      94
      /* EditorOption.renderControlCharacters */
    ), i.get(
      51
      /* EditorOption.fontLigatures */
    ));
  }
  constructor(e, t, i, n, s, o, a, l, d, c, h) {
    this.tabSize = e, this.fontInfo = t, this.disableMonospaceOptimizations = i, this.typicalHalfwidthCharacterWidth = n, this.scrollBeyondLastColumn = s, this.lineHeight = o, this.lineDecorationsWidth = a, this.stopRenderingLineAfter = l, this.renderWhitespace = d, this.renderControlCharacters = c, this.fontLigatures = h;
  }
}
function KF(r, e, t, i, n, s, o, a) {
  a.appendString('<div class="view-line'), i || a.appendString(" char-delete"), a.appendString('" style="top:'), a.appendString(String(r * o.lineHeight)), a.appendString('px;width:1000000px;">');
  const l = e.getLineContent(), d = po.isBasicASCII(l, n), c = po.containsRTL(l, d, s), h = hb(new th(
    o.fontInfo.isMonospace && !o.disableMonospaceOptimizations,
    o.fontInfo.canUseHalfwidthRightwardsArrow,
    l,
    !1,
    d,
    c,
    0,
    e,
    t,
    o.tabSize,
    0,
    o.fontInfo.spaceWidth,
    o.fontInfo.middotWidth,
    o.fontInfo.wsmiddotWidth,
    o.stopRenderingLineAfter,
    o.renderWhitespace,
    o.renderControlCharacters,
    o.fontLigatures !== ro.OFF,
    null
    // Send no selections, original line cannot be selected
  ), a);
  return a.appendString("</div>"), h.characterMapping.getHorizontalOffset(h.characterMapping.length);
}
var Ere = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, jF = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
let HE = class extends P {
  constructor(e, t, i, n, s, o, a, l, d, c) {
    super(), this._targetWindow = e, this._editors = t, this._diffModel = i, this._options = n, this._diffEditorWidget = s, this._canIgnoreViewZoneUpdateEvent = o, this._origViewZonesToIgnore = a, this._modViewZonesToIgnore = l, this._clipboardService = d, this._contextMenuService = c, this._originalTopPadding = rt(this, 0), this._originalScrollOffset = rt(this, 0), this._originalScrollOffsetAnimated = OF(this._targetWindow, this._originalScrollOffset, this._store), this._modifiedTopPadding = rt(this, 0), this._modifiedScrollOffset = rt(this, 0), this._modifiedScrollOffsetAnimated = OF(this._targetWindow, this._modifiedScrollOffset, this._store);
    const h = rt("invalidateAlignmentsState", 0), u = this._register(new xt(() => {
      h.set(h.get() + 1, void 0);
    }, 0));
    this._register(this._editors.original.onDidChangeViewZones((C) => {
      this._canIgnoreViewZoneUpdateEvent() || u.schedule();
    })), this._register(this._editors.modified.onDidChangeViewZones((C) => {
      this._canIgnoreViewZoneUpdateEvent() || u.schedule();
    })), this._register(this._editors.original.onDidChangeConfiguration((C) => {
      (C.hasChanged(
        146
        /* EditorOption.wrappingInfo */
      ) || C.hasChanged(
        67
        /* EditorOption.lineHeight */
      )) && u.schedule();
    })), this._register(this._editors.modified.onDidChangeConfiguration((C) => {
      (C.hasChanged(
        146
        /* EditorOption.wrappingInfo */
      ) || C.hasChanged(
        67
        /* EditorOption.lineHeight */
      )) && u.schedule();
    }));
    const g = this._diffModel.map((C) => C ? Lt(
      C.model.original.onDidChangeTokens,
      () => C.model.original.tokenization.backgroundTokenizationState === 2
      /* BackgroundTokenizationState.Completed */
    ) : void 0).map((C, w) => C == null ? void 0 : C.read(w)), f = Pe((C) => {
      const w = this._diffModel.read(C), S = w == null ? void 0 : w.diff.read(C);
      if (!w || !S)
        return null;
      h.read(C);
      const k = this._options.renderSideBySide.read(C);
      return qF(this._editors.original, this._editors.modified, S.mappings, this._origViewZonesToIgnore, this._modViewZonesToIgnore, k);
    }), m = Pe((C) => {
      var w;
      const S = (w = this._diffModel.read(C)) === null || w === void 0 ? void 0 : w.movedTextToCompare.read(C);
      if (!S)
        return null;
      h.read(C);
      const y = S.changes.map((k) => new R3(k));
      return qF(this._editors.original, this._editors.modified, y, this._origViewZonesToIgnore, this._modViewZonesToIgnore, !0);
    });
    function _() {
      const C = document.createElement("div");
      return C.className = "diagonal-fill", C;
    }
    const v = this._register(new q());
    this.viewZones = ig(this, (C, w) => {
      var S, y, k, E, N, F, V, Z;
      v.clear();
      const H = f.read(C) || [], re = [], ue = [], Ve = this._modifiedTopPadding.read(C);
      Ve > 0 && ue.push({
        afterLineNumber: 0,
        domNode: document.createElement("div"),
        heightInPx: Ve,
        showInHiddenAreas: !0,
        suppressMouseDown: !0
      });
      const Ye = this._originalTopPadding.read(C);
      Ye > 0 && re.push({
        afterLineNumber: 0,
        domNode: document.createElement("div"),
        heightInPx: Ye,
        showInHiddenAreas: !0,
        suppressMouseDown: !0
      });
      const ze = this._options.renderSideBySide.read(C), pe = ze || (S = this._editors.modified._getViewModel()) === null || S === void 0 ? void 0 : S.createLineBreaksComputer();
      if (pe) {
        const Ct = this._editors.original.getModel();
        for (const Ki of H)
          if (Ki.diff)
            for (let Gn = Ki.originalRange.startLineNumber; Gn < Ki.originalRange.endLineNumberExclusive; Gn++) {
              if (Gn > Ct.getLineCount())
                return { orig: re, mod: ue };
              pe == null || pe.addRequest(Ct.getLineContent(Gn), null, null);
            }
      }
      const $e = (y = pe == null ? void 0 : pe.finalize()) !== null && y !== void 0 ? y : [];
      let Be = 0;
      const Te = this._editors.modified.getOption(
        67
        /* EditorOption.lineHeight */
      ), ce = (k = this._diffModel.read(C)) === null || k === void 0 ? void 0 : k.movedTextToCompare.read(C), Fi = (N = (E = this._editors.original.getModel()) === null || E === void 0 ? void 0 : E.mightContainNonBasicASCII()) !== null && N !== void 0 ? N : !1, Is = (V = (F = this._editors.original.getModel()) === null || F === void 0 ? void 0 : F.mightContainRTL()) !== null && V !== void 0 ? V : !1, Qi = KM.fromEditor(this._editors.modified);
      for (const Ct of H)
        if (Ct.diff && !ze) {
          if (!Ct.originalRange.isEmpty) {
            g.read(C);
            const Gn = document.createElement("div");
            Gn.classList.add("view-lines", "line-delete", "monaco-mouse-cursor-text");
            const dn = this._editors.original.getModel();
            if (Ct.originalRange.endLineNumberExclusive - 1 > dn.getLineCount())
              return { orig: re, mod: ue };
            const Ue = new Ire(Ct.originalRange.mapToLineArray((Xi) => dn.tokenization.getLineTokens(Xi)), Ct.originalRange.mapToLineArray((Xi) => $e[Be++]), Fi, Is), jo = [];
            for (const Xi of Ct.diff.innerChanges || [])
              jo.push(new e_(
                Xi.originalRange.delta(-(Ct.diff.original.startLineNumber - 1)),
                OE.className,
                0
                /* InlineDecorationType.Regular */
              ));
            const qo = xre(Ue, Qi, jo, Gn), Qs = document.createElement("div");
            if (Qs.className = "inline-deleted-margin-view-zone", _n(Qs, Qi.fontInfo), this._options.renderIndicators.read(C))
              for (let Xi = 0; Xi < qo.heightInLines; Xi++) {
                const Cr = document.createElement("div");
                Cr.className = `delete-sign ${Le.asClassName(E3)}`, Cr.setAttribute("style", `position:absolute;top:${Xi * Te}px;width:${Qi.lineDecorationsWidth}px;height:${Te}px;right:0;`), Qs.appendChild(Cr);
              }
            let pl;
            v.add(new kre(() => Xd(pl), Qs, this._editors.modified, Ct.diff, this._diffEditorWidget, qo.viewLineCounts, this._editors.original.getModel(), this._contextMenuService, this._clipboardService));
            for (let Xi = 0; Xi < qo.viewLineCounts.length; Xi++) {
              const Cr = qo.viewLineCounts[Xi];
              Cr > 1 && re.push({
                afterLineNumber: Ct.originalRange.startLineNumber + Xi,
                domNode: _(),
                heightInPx: (Cr - 1) * Te,
                showInHiddenAreas: !0,
                suppressMouseDown: !0
              });
            }
            ue.push({
              afterLineNumber: Ct.modifiedRange.startLineNumber - 1,
              domNode: Gn,
              heightInPx: qo.heightInLines * Te,
              minWidthInPx: qo.minWidthInPx,
              marginDomNode: Qs,
              setZoneId(Xi) {
                pl = Xi;
              },
              showInHiddenAreas: !0,
              suppressMouseDown: !0
            });
          }
          const Ki = document.createElement("div");
          Ki.className = "gutter-delete", re.push({
            afterLineNumber: Ct.originalRange.endLineNumberExclusive - 1,
            domNode: _(),
            heightInPx: Ct.modifiedHeightInPx,
            marginDomNode: Ki,
            showInHiddenAreas: !0,
            suppressMouseDown: !0
          });
        } else {
          const Ki = Ct.modifiedHeightInPx - Ct.originalHeightInPx;
          if (Ki > 0) {
            if (ce != null && ce.lineRangeMapping.original.delta(-1).deltaLength(2).contains(Ct.originalRange.endLineNumberExclusive - 1))
              continue;
            re.push({
              afterLineNumber: Ct.originalRange.endLineNumberExclusive - 1,
              domNode: _(),
              heightInPx: Ki,
              showInHiddenAreas: !0,
              suppressMouseDown: !0
            });
          } else {
            let Gn = function() {
              const Ue = document.createElement("div");
              return Ue.className = "arrow-revert-change " + Le.asClassName(me.arrowRight), w.add(W(Ue, "mousedown", (jo) => jo.stopPropagation())), w.add(W(Ue, "click", (jo) => {
                jo.stopPropagation(), s.revert(Ct.diff);
              })), X("div", {}, Ue);
            };
            if (ce != null && ce.lineRangeMapping.modified.delta(-1).deltaLength(2).contains(Ct.modifiedRange.endLineNumberExclusive - 1))
              continue;
            let dn;
            Ct.diff && Ct.diff.modified.isEmpty && this._options.shouldRenderOldRevertArrows.read(C) && (dn = Gn()), ue.push({
              afterLineNumber: Ct.modifiedRange.endLineNumberExclusive - 1,
              domNode: _(),
              heightInPx: -Ki,
              marginDomNode: dn,
              showInHiddenAreas: !0,
              suppressMouseDown: !0
            });
          }
        }
      for (const Ct of (Z = m.read(C)) !== null && Z !== void 0 ? Z : []) {
        if (!(ce != null && ce.lineRangeMapping.original.intersect(Ct.originalRange)) || !(ce != null && ce.lineRangeMapping.modified.intersect(Ct.modifiedRange)))
          continue;
        const Ki = Ct.modifiedHeightInPx - Ct.originalHeightInPx;
        Ki > 0 ? re.push({
          afterLineNumber: Ct.originalRange.endLineNumberExclusive - 1,
          domNode: _(),
          heightInPx: Ki,
          showInHiddenAreas: !0,
          suppressMouseDown: !0
        }) : ue.push({
          afterLineNumber: Ct.modifiedRange.endLineNumberExclusive - 1,
          domNode: _(),
          heightInPx: -Ki,
          showInHiddenAreas: !0,
          suppressMouseDown: !0
        });
      }
      return { orig: re, mod: ue };
    });
    let b = !1;
    this._register(this._editors.original.onDidScrollChange((C) => {
      C.scrollLeftChanged && !b && (b = !0, this._editors.modified.setScrollLeft(C.scrollLeft), b = !1);
    })), this._register(this._editors.modified.onDidScrollChange((C) => {
      C.scrollLeftChanged && !b && (b = !0, this._editors.original.setScrollLeft(C.scrollLeft), b = !1);
    })), this._originalScrollTop = Lt(this._editors.original.onDidScrollChange, () => (
      /** @description original.getScrollTop */
      this._editors.original.getScrollTop()
    )), this._modifiedScrollTop = Lt(this._editors.modified.onDidScrollChange, () => (
      /** @description modified.getScrollTop */
      this._editors.modified.getScrollTop()
    )), this._register(qe((C) => {
      const w = this._originalScrollTop.read(C) - (this._originalScrollOffsetAnimated.get() - this._modifiedScrollOffsetAnimated.read(C)) - (this._originalTopPadding.get() - this._modifiedTopPadding.read(C));
      w !== this._editors.modified.getScrollTop() && this._editors.modified.setScrollTop(
        w,
        1
        /* ScrollType.Immediate */
      );
    })), this._register(qe((C) => {
      const w = this._modifiedScrollTop.read(C) - (this._modifiedScrollOffsetAnimated.get() - this._originalScrollOffsetAnimated.read(C)) - (this._modifiedTopPadding.get() - this._originalTopPadding.read(C));
      w !== this._editors.original.getScrollTop() && this._editors.original.setScrollTop(
        w,
        1
        /* ScrollType.Immediate */
      );
    })), this._register(qe((C) => {
      var w;
      const S = (w = this._diffModel.read(C)) === null || w === void 0 ? void 0 : w.movedTextToCompare.read(C);
      let y = 0;
      if (S) {
        const k = this._editors.original.getTopForLineNumber(S.lineRangeMapping.original.startLineNumber, !0) - this._originalTopPadding.get();
        y = this._editors.modified.getTopForLineNumber(S.lineRangeMapping.modified.startLineNumber, !0) - this._modifiedTopPadding.get() - k;
      }
      y > 0 ? (this._modifiedTopPadding.set(0, void 0), this._originalTopPadding.set(y, void 0)) : y < 0 ? (this._modifiedTopPadding.set(-y, void 0), this._originalTopPadding.set(0, void 0)) : setTimeout(() => {
        this._modifiedTopPadding.set(0, void 0), this._originalTopPadding.set(0, void 0);
      }, 400), this._editors.modified.hasTextFocus() ? this._originalScrollOffset.set(this._modifiedScrollOffset.get() - y, void 0, !0) : this._modifiedScrollOffset.set(this._originalScrollOffset.get() + y, void 0, !0);
    }));
  }
};
HE = Ere([
  jF(8, Dd),
  jF(9, Zs)
], HE);
function qF(r, e, t, i, n, s) {
  const o = new ad(GF(r, i)), a = new ad(GF(e, n)), l = r.getOption(
    67
    /* EditorOption.lineHeight */
  ), d = e.getOption(
    67
    /* EditorOption.lineHeight */
  ), c = [];
  let h = 0, u = 0;
  function g(f, m) {
    for (; ; ) {
      let _ = o.peek(), v = a.peek();
      if (_ && _.lineNumber >= f && (_ = void 0), v && v.lineNumber >= m && (v = void 0), !_ && !v)
        break;
      const b = _ ? _.lineNumber - h : Number.MAX_VALUE, C = v ? v.lineNumber - u : Number.MAX_VALUE;
      b < C ? (o.dequeue(), v = {
        lineNumber: _.lineNumber - h + u,
        heightInPx: 0
      }) : b > C ? (a.dequeue(), _ = {
        lineNumber: v.lineNumber - u + h,
        heightInPx: 0
      }) : (o.dequeue(), a.dequeue()), c.push({
        originalRange: Yt.ofLength(_.lineNumber, 1),
        modifiedRange: Yt.ofLength(v.lineNumber, 1),
        originalHeightInPx: l + _.heightInPx,
        modifiedHeightInPx: d + v.heightInPx,
        diff: void 0
      });
    }
  }
  for (const f of t) {
    let C = function(w, S) {
      var y, k, E, N;
      if (w < b || S < v)
        return;
      if (_)
        _ = !1;
      else if (w === b || S === v)
        return;
      const F = new Yt(b, w), V = new Yt(v, S);
      if (F.isEmpty && V.isEmpty)
        return;
      const Z = (k = (y = o.takeWhile((re) => re.lineNumber < w)) === null || y === void 0 ? void 0 : y.reduce((re, ue) => re + ue.heightInPx, 0)) !== null && k !== void 0 ? k : 0, H = (N = (E = a.takeWhile((re) => re.lineNumber < S)) === null || E === void 0 ? void 0 : E.reduce((re, ue) => re + ue.heightInPx, 0)) !== null && N !== void 0 ? N : 0;
      c.push({
        originalRange: F,
        modifiedRange: V,
        originalHeightInPx: F.length * l + Z,
        modifiedHeightInPx: V.length * d + H,
        diff: f.lineRangeMapping
      }), b = w, v = S;
    };
    const m = f.lineRangeMapping;
    g(m.original.startLineNumber, m.modified.startLineNumber);
    let _ = !0, v = m.modified.startLineNumber, b = m.original.startLineNumber;
    if (s)
      for (const w of m.innerChanges || []) {
        w.originalRange.startColumn > 1 && w.modifiedRange.startColumn > 1 && C(w.originalRange.startLineNumber, w.modifiedRange.startLineNumber);
        const S = r.getModel(), y = w.originalRange.endLineNumber <= S.getLineCount() ? S.getLineMaxColumn(w.originalRange.endLineNumber) : Number.MAX_SAFE_INTEGER;
        w.originalRange.endColumn < y && C(w.originalRange.endLineNumber, w.modifiedRange.endLineNumber);
      }
    C(m.original.endLineNumberExclusive, m.modified.endLineNumberExclusive), h = m.original.endLineNumberExclusive, u = m.modified.endLineNumberExclusive;
  }
  return g(Number.MAX_VALUE, Number.MAX_VALUE), c;
}
function GF(r, e) {
  const t = [], i = [], n = r.getOption(
    146
    /* EditorOption.wrappingInfo */
  ).wrappingColumn !== -1, s = r._getViewModel().coordinatesConverter, o = r.getOption(
    67
    /* EditorOption.lineHeight */
  );
  if (n)
    for (let l = 1; l <= r.getModel().getLineCount(); l++) {
      const d = s.getModelLineViewLineCount(l);
      d > 1 && i.push({ lineNumber: l, heightInPx: o * (d - 1) });
    }
  for (const l of r.getWhitespaces()) {
    if (e.has(l.id))
      continue;
    const d = l.afterLineNumber === 0 ? 0 : s.convertViewPositionToModelPosition(new A(l.afterLineNumber, 1)).lineNumber;
    t.push({ lineNumber: d, heightInPx: l.height });
  }
  return Xoe(t, i, (l) => l.lineNumber, (l, d) => ({ lineNumber: l.lineNumber, heightInPx: l.heightInPx + d.heightInPx }));
}
class Tre extends P {
  constructor(e, t, i) {
    super(), this._editor = e, this._domNode = t, this.itemProvider = i, this.scrollTop = Lt(this._editor.onDidScrollChange, (o) => (
      /** @description editor.onDidScrollChange */
      this._editor.getScrollTop()
    )), this.isScrollTopZero = this.scrollTop.map((o) => (
      /** @description isScrollTopZero */
      o === 0
    )), this.modelAttached = Lt(this._editor.onDidChangeModel, (o) => (
      /** @description editor.onDidChangeModel */
      this._editor.hasModel()
    )), this.editorOnDidChangeViewZones = Mn("onDidChangeViewZones", this._editor.onDidChangeViewZones), this.editorOnDidContentSizeChange = Mn("onDidContentSizeChange", this._editor.onDidContentSizeChange), this.domNodeSizeChanged = Q0("domNodeSizeChanged"), this.views = /* @__PURE__ */ new Map(), this._domNode.className = "gutter monaco-editor";
    const n = this._domNode.appendChild(ft("div.scroll-decoration", { role: "presentation", ariaHidden: "true", style: { width: "100%" } }).root), s = new ResizeObserver(() => {
      Nt((o) => {
        this.domNodeSizeChanged.trigger(o);
      });
    });
    s.observe(this._domNode), this._register(Se(() => s.disconnect())), this._register(qe((o) => {
      n.className = this.isScrollTopZero.read(o) ? "" : "scroll-decoration";
    })), this._register(qe((o) => (
      /** @description EditorGutter.Render */
      this.render(o)
    )));
  }
  dispose() {
    super.dispose(), mn(this._domNode);
  }
  render(e) {
    if (!this.modelAttached.read(e))
      return;
    this.domNodeSizeChanged.read(e), this.editorOnDidChangeViewZones.read(e), this.editorOnDidContentSizeChange.read(e);
    const t = this.scrollTop.read(e), i = this._editor.getVisibleRanges(), n = new Set(this.views.keys()), s = tn.ofStartAndLength(0, this._domNode.clientHeight);
    if (!s.isEmpty)
      for (const o of i) {
        const a = new Yt(o.startLineNumber, o.endLineNumber + 1), l = this.itemProvider.getIntersectingGutterItems(a, e);
        Nt((d) => {
          for (const c of l) {
            if (!c.range.intersect(a))
              continue;
            n.delete(c.id);
            let h = this.views.get(c.id);
            if (h)
              h.item.set(c, d);
            else {
              const m = document.createElement("div");
              this._domNode.appendChild(m);
              const _ = rt("item", c), v = this.itemProvider.createView(_, m);
              h = new Nre(_, v, m), this.views.set(c.id, h);
            }
            const u = c.range.startLineNumber <= this._editor.getModel().getLineCount() ? this._editor.getTopForLineNumber(c.range.startLineNumber, !0) - t : this._editor.getBottomForLineNumber(c.range.startLineNumber - 1, !1) - t, f = (c.range.isEmpty ? u : this._editor.getBottomForLineNumber(c.range.endLineNumberExclusive - 1, !0) - t) - u;
            h.domNode.style.top = `${u}px`, h.domNode.style.height = `${f}px`, h.gutterItemView.layout(tn.ofStartAndLength(u, f), s);
          }
        });
      }
    for (const o of n) {
      const a = this.views.get(o);
      a.gutterItemView.dispose(), this._domNode.removeChild(a.domNode), this.views.delete(o);
    }
  }
}
class Nre {
  constructor(e, t, i) {
    this.item = e, this.gutterItemView = t, this.domNode = i;
  }
}
class A3 extends wu {
  constructor(e) {
    super(), this._getContext = e;
  }
  runAction(e, t) {
    const i = this._getContext();
    return super.runAction(e, i);
  }
}
class ZF extends X5 {
  constructor(e) {
    super(), this._textModel = e;
  }
  getValueOfRange(e) {
    return this._textModel.getValueInRange(e);
  }
  get length() {
    const e = this._textModel.getLineCount(), t = this._textModel.getLineLength(e);
    return new Tc(e - 1, t);
  }
}
class Mre extends P {
  constructor(e, t, i = {
    orientation: 0
    /* ActionsOrientation.HORIZONTAL */
  }) {
    var n;
    super(), this.submenuActionViewItems = [], this.hasSecondaryActions = !1, this._onDidChangeDropdownVisibility = this._register(new J5()), this.onDidChangeDropdownVisibility = this._onDidChangeDropdownVisibility.event, this.disposables = this._register(new q()), i.hoverDelegate = (n = i.hoverDelegate) !== null && n !== void 0 ? n : this._register(np()), this.options = i, this.lookupKeybindings = typeof this.options.getKeyBinding == "function", this.toggleMenuAction = this._register(new cp(() => {
      var s;
      return (s = this.toggleMenuActionViewItem) === null || s === void 0 ? void 0 : s.show();
    }, i.toggleMenuTitle)), this.element = document.createElement("div"), this.element.className = "monaco-toolbar", e.appendChild(this.element), this.actionBar = this._register(new Bo(this.element, {
      orientation: i.orientation,
      ariaLabel: i.ariaLabel,
      actionRunner: i.actionRunner,
      allowContextMenu: i.allowContextMenu,
      highlightToggledItems: i.highlightToggledItems,
      hoverDelegate: i.hoverDelegate,
      actionViewItemProvider: (s, o) => {
        var a;
        if (s.id === cp.ID)
          return this.toggleMenuActionViewItem = new qS(s, s.menuActions, t, {
            actionViewItemProvider: this.options.actionViewItemProvider,
            actionRunner: this.actionRunner,
            keybindingProvider: this.options.getKeyBinding,
            classNames: Le.asClassNameArray((a = i.moreIcon) !== null && a !== void 0 ? a : me.toolBarMore),
            anchorAlignmentProvider: this.options.anchorAlignmentProvider,
            menuAsChild: !!this.options.renderDropdownAsChildElement,
            skipTelemetry: this.options.skipTelemetry,
            isMenu: !0,
            hoverDelegate: this.options.hoverDelegate
          }), this.toggleMenuActionViewItem.setActionContext(this.actionBar.context), this.disposables.add(this._onDidChangeDropdownVisibility.add(this.toggleMenuActionViewItem.onDidChangeVisibility)), this.toggleMenuActionViewItem;
        if (i.actionViewItemProvider) {
          const l = i.actionViewItemProvider(s, o);
          if (l)
            return l;
        }
        if (s instanceof Bf) {
          const l = new qS(s, s.actions, t, {
            actionViewItemProvider: this.options.actionViewItemProvider,
            actionRunner: this.actionRunner,
            keybindingProvider: this.options.getKeyBinding,
            classNames: s.class,
            anchorAlignmentProvider: this.options.anchorAlignmentProvider,
            menuAsChild: !!this.options.renderDropdownAsChildElement,
            skipTelemetry: this.options.skipTelemetry,
            hoverDelegate: this.options.hoverDelegate
          });
          return l.setActionContext(this.actionBar.context), this.submenuActionViewItems.push(l), this.disposables.add(this._onDidChangeDropdownVisibility.add(l.onDidChangeVisibility)), l;
        }
      }
    }));
  }
  set actionRunner(e) {
    this.actionBar.actionRunner = e;
  }
  get actionRunner() {
    return this.actionBar.actionRunner;
  }
  getElement() {
    return this.element;
  }
  getItemAction(e) {
    return this.actionBar.getAction(e);
  }
  setActions(e, t) {
    this.clear();
    const i = e ? e.slice(0) : [];
    this.hasSecondaryActions = !!(t && t.length > 0), this.hasSecondaryActions && t && (this.toggleMenuAction.menuActions = t.slice(0), i.push(this.toggleMenuAction)), i.forEach((n) => {
      this.actionBar.push(n, { icon: !0, label: !1, keybinding: this.getKeybindingLabel(n) });
    });
  }
  getKeybindingLabel(e) {
    var t, i, n;
    const s = this.lookupKeybindings ? (i = (t = this.options).getKeyBinding) === null || i === void 0 ? void 0 : i.call(t, e) : void 0;
    return (n = s == null ? void 0 : s.getLabel()) !== null && n !== void 0 ? n : void 0;
  }
  clear() {
    this.submenuActionViewItems = [], this.disposables.clear(), this.actionBar.clear();
  }
  dispose() {
    this.clear(), this.disposables.dispose(), super.dispose();
  }
}
class cp extends Bs {
  constructor(e, t) {
    t = t || p("moreActions", "More Actions..."), super(cp.ID, t, void 0, !0), this._menuActions = [], this.toggleDropdownMenu = e;
  }
  async run() {
    this.toggleDropdownMenu();
  }
  get menuActions() {
    return this._menuActions;
  }
  set menuActions(e) {
    this._menuActions = e;
  }
}
cp.ID = "toolbar.toggle.more";
var P3 = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, sr = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
let yv = class extends Mre {
  constructor(e, t, i, n, s, o, a, l) {
    super(e, s, {
      // defaults
      getKeyBinding: (c) => {
        var h;
        return (h = o.lookupKeybinding(c.id)) !== null && h !== void 0 ? h : void 0;
      },
      // options (override defaults)
      ...t,
      // mandatory (overide options)
      allowContextMenu: !0,
      skipTelemetry: typeof (t == null ? void 0 : t.telemetrySource) == "string"
    }), this._options = t, this._menuService = i, this._contextKeyService = n, this._contextMenuService = s, this._keybindingService = o, this._commandService = a, this._sessionDisposables = this._store.add(new q());
    const d = t == null ? void 0 : t.telemetrySource;
    d && this._store.add(this.actionBar.onDidRun((c) => l.publicLog2("workbenchActionExecuted", { id: c.action.id, from: d })));
  }
  setActions(e, t = [], i) {
    var n, s, o;
    this._sessionDisposables.clear();
    const a = e.slice(), l = t.slice(), d = [];
    let c = 0;
    const h = [];
    let u = !1;
    if (((n = this._options) === null || n === void 0 ? void 0 : n.hiddenItemStrategy) !== -1)
      for (let g = 0; g < a.length; g++) {
        const f = a[g];
        !(f instanceof Hs) && !(f instanceof gf) || f.hideActions && (d.push(f.hideActions.toggle), f.hideActions.toggle.checked && c++, f.hideActions.isHidden && (u = !0, a[g] = void 0, ((s = this._options) === null || s === void 0 ? void 0 : s.hiddenItemStrategy) !== 0 && (h[g] = f)));
      }
    if (((o = this._options) === null || o === void 0 ? void 0 : o.overflowBehavior) !== void 0) {
      const g = rne(new Set(this._options.overflowBehavior.exempted), ut.map(a, (_) => _ == null ? void 0 : _.id)), f = this._options.overflowBehavior.maxItems - g.size;
      let m = 0;
      for (let _ = 0; _ < a.length; _++) {
        const v = a[_];
        v && (m++, !g.has(v.id) && m >= f && (a[_] = void 0, h[_] = v));
      }
    }
    cA(a), cA(h), super.setActions(a, Oi.join(h, l)), (d.length > 0 || a.length > 0) && this._sessionDisposables.add(W(this.getElement(), "contextmenu", (g) => {
      var f, m, _, v, b;
      const C = new rr(we(this.getElement()), g), w = this.getItemAction(C.target);
      if (!w)
        return;
      C.preventDefault(), C.stopPropagation();
      const S = [];
      if (w instanceof Hs && w.menuKeybinding ? S.push(w.menuKeybinding) : w instanceof gf || w instanceof cp || S.push(y3(w.id, void 0, this._commandService, this._keybindingService)), d.length > 0) {
        let k = !1;
        if (c === 1 && ((f = this._options) === null || f === void 0 ? void 0 : f.hiddenItemStrategy) === 0) {
          k = !0;
          for (let E = 0; E < d.length; E++)
            if (d[E].checked) {
              d[E] = ru({
                id: w.id,
                label: w.label,
                checked: !0,
                enabled: !1,
                run() {
                }
              });
              break;
            }
        }
        if (!k && (w instanceof Hs || w instanceof gf)) {
          if (!w.hideActions)
            return;
          S.push(w.hideActions.hide);
        } else
          S.push(ru({
            id: "label",
            label: p("hide", "Hide"),
            enabled: !1,
            run() {
            }
          }));
      }
      const y = Oi.join(S, d);
      !((m = this._options) === null || m === void 0) && m.resetMenu && !i && (i = [this._options.resetMenu]), u && i && (y.push(new Oi()), y.push(ru({
        id: "resetThisMenu",
        label: p("resetThisMenu", "Reset Menu"),
        run: () => this._menuService.resetHiddenStates(i)
      }))), y.length !== 0 && this._contextMenuService.showContextMenu({
        getAnchor: () => C,
        getActions: () => y,
        // add context menu actions (iff appicable)
        menuId: (_ = this._options) === null || _ === void 0 ? void 0 : _.contextMenu,
        menuActionOptions: { renderShortTitle: !0, ...(v = this._options) === null || v === void 0 ? void 0 : v.menuOptions },
        skipTelemetry: typeof ((b = this._options) === null || b === void 0 ? void 0 : b.telemetrySource) == "string",
        contextKeyService: this._contextKeyService
      });
    }));
  }
};
yv = P3([
  sr(2, vo),
  sr(3, De),
  sr(4, Zs),
  sr(5, _t),
  sr(6, $t),
  sr(7, kn)
], yv);
let yy = class extends yv {
  constructor(e, t, i, n, s, o, a, l, d) {
    super(e, { resetMenu: t, ...i }, n, s, o, a, l, d), this._onDidChangeMenuItems = this._store.add(new R()), this.onDidChangeMenuItems = this._onDidChangeMenuItems.event;
    const c = this._store.add(n.createMenu(t, s, { emitEventsForSubmenuChanges: !0 })), h = () => {
      var u, g, f;
      const m = [], _ = [];
      eL(c, i == null ? void 0 : i.menuOptions, { primary: m, secondary: _ }, (u = i == null ? void 0 : i.toolbarOptions) === null || u === void 0 ? void 0 : u.primaryGroup, (g = i == null ? void 0 : i.toolbarOptions) === null || g === void 0 ? void 0 : g.shouldInlineSubmenu, (f = i == null ? void 0 : i.toolbarOptions) === null || f === void 0 ? void 0 : f.useSeparatorsInPrimaryActions), e.classList.toggle("has-no-actions", m.length === 0 && _.length === 0), super.setActions(m, _);
    };
    this._store.add(c.onDidChange(() => {
      h(), this._onDidChangeMenuItems.fire(this);
    })), h();
  }
  /**
   * @deprecated The WorkbenchToolBar does not support this method because it works with menus.
   */
  setActions() {
    throw new Li("This toolbar is populated from a menu.");
  }
};
yy = P3([
  sr(3, vo),
  sr(4, De),
  sr(5, Zs),
  sr(6, _t),
  sr(7, $t),
  sr(8, kn)
], yy);
var O3 = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, qw = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
const Fk = [], KC = 35;
let VE = class extends P {
  constructor(e, t, i, n, s, o, a, l, d) {
    super(), this._diffModel = t, this._editors = i, this._options = n, this._sashLayout = s, this._boundarySashes = o, this._instantiationService = a, this._contextKeyService = l, this._menuService = d, this._menu = this._register(this._menuService.createMenu(D.DiffEditorHunkToolbar, this._contextKeyService)), this._actions = Lt(this._menu.onDidChange, () => this._menu.getActions()), this._hasActions = this._actions.map((c) => c.length > 0), this._showSash = Pe(this, (c) => this._options.renderSideBySide.read(c) && this._hasActions.read(c)), this.width = Pe(this, (c) => this._hasActions.read(c) ? KC : 0), this.elements = ft("div.gutter@gutter", { style: { position: "absolute", height: "100%", width: KC + "px" } }, []), this._currentDiff = Pe(this, (c) => {
      var h;
      const u = this._diffModel.read(c);
      if (!u)
        return;
      const g = (h = u.diff.read(c)) === null || h === void 0 ? void 0 : h.mappings, f = this._editors.modifiedCursor.read(c);
      if (f)
        return g == null ? void 0 : g.find((m) => m.lineRangeMapping.modified.contains(f.lineNumber));
    }), this._selectedDiffs = Pe(this, (c) => {
      const h = this._diffModel.read(c), u = h == null ? void 0 : h.diff.read(c);
      if (!u)
        return Fk;
      const g = this._editors.modifiedSelections.read(c);
      if (g.every((v) => v.isEmpty()))
        return Fk;
      const f = new GN(g.map((v) => Yt.fromRangeInclusive(v))), _ = u.mappings.filter((v) => v.lineRangeMapping.innerChanges && f.intersects(v.lineRangeMapping.modified)).map((v) => ({
        mapping: v,
        rangeMappings: v.lineRangeMapping.innerChanges.filter((b) => g.some((C) => L.areIntersecting(b.modifiedRange, C)))
      }));
      return _.length === 0 || _.every((v) => v.rangeMappings.length === 0) ? Fk : _;
    }), this._register(Joe(e, this.elements.root)), this._register(W(this.elements.root, "click", () => {
      this._editors.modified.focus();
    })), this._register(Vc(this.elements.root, { display: this._hasActions.map((c) => c ? "block" : "none") })), Da(this, (c) => this._showSash.read(c) ? new T3(e, this._sashLayout.dimensions, this._options.enableSplitViewResizing, this._boundarySashes, Sz(this, (u) => this._sashLayout.sashLeft.read(u) - KC, (u, g) => this._sashLayout.sashLeft.set(u + KC, g)), () => this._sashLayout.resetSash()) : void 0).recomputeInitiallyAndOnChange(this._store), this._register(new Tre(this._editors.modified, this.elements.root, {
      getIntersectingGutterItems: (c, h) => {
        const u = this._diffModel.read(h);
        if (!u)
          return [];
        const g = u.diff.read(h);
        if (!g)
          return [];
        const f = this._selectedDiffs.read(h);
        if (f.length > 0) {
          const _ = nb.fromRangeMappings(f.flatMap((v) => v.rangeMappings));
          return [
            new YF(_, !0, D.DiffEditorSelectionToolbar, void 0, u.model.original.uri, u.model.modified.uri)
          ];
        }
        const m = this._currentDiff.read(h);
        return g.mappings.map((_) => new YF(_.lineRangeMapping.withInnerChangesFromLineRanges(), _.lineRangeMapping === (m == null ? void 0 : m.lineRangeMapping), D.DiffEditorHunkToolbar, void 0, u.model.original.uri, u.model.modified.uri));
      },
      createView: (c, h) => this._instantiationService.createInstance(zE, c, h, this)
    })), this._register(W(this.elements.gutter, Q.MOUSE_WHEEL, (c) => {
      this._editors.modified.getOption(
        103
        /* EditorOption.scrollbar */
      ).handleMouseWheel && this._editors.modified.delegateScrollFromMouseWheelEvent(c);
    }, { passive: !1 }));
  }
  computeStagedValue(e) {
    var t;
    const i = (t = e.innerChanges) !== null && t !== void 0 ? t : [], n = new ZF(this._editors.modifiedModel.get()), s = new ZF(this._editors.original.getModel());
    return new ZN(i.map((l) => l.toTextEdit(n))).apply(s);
  }
  layout(e) {
    this.elements.gutter.style.left = e + "px";
  }
};
VE = O3([
  qw(6, be),
  qw(7, De),
  qw(8, vo)
], VE);
class YF {
  constructor(e, t, i, n, s, o) {
    this.mapping = e, this.showAlways = t, this.menuId = i, this.rangeOverride = n, this.originalUri = s, this.modifiedUri = o;
  }
  get id() {
    return this.mapping.modified.toString();
  }
  get range() {
    var e;
    return (e = this.rangeOverride) !== null && e !== void 0 ? e : this.mapping.modified;
  }
}
let zE = class extends P {
  constructor(e, t, i, n) {
    super(), this._item = e, this._elements = ft("div.gutterItem", { style: { height: "20px", width: "34px" } }, [
      ft("div.background@background", {}, []),
      ft("div.buttons@buttons", {}, [])
    ]), this._showAlways = this._item.map(this, (o) => o.showAlways), this._menuId = this._item.map(this, (o) => o.menuId), this._isSmall = rt(this, !1), this._lastItemRange = void 0, this._lastViewRange = void 0;
    const s = this._register(n.createInstance(Xf, "element", !0, { position: {
      hoverPosition: 1
      /* HoverPosition.RIGHT */
    } }));
    this._register(Hm(t, this._elements.root)), this._register(qe((o) => {
      const a = this._showAlways.read(o);
      this._elements.root.classList.toggle("noTransition", !0), this._elements.root.classList.toggle("showAlways", a), setTimeout(() => {
        this._elements.root.classList.toggle("noTransition", !1);
      }, 0);
    })), this._register(Wo((o, a) => {
      this._elements.buttons.replaceChildren();
      const l = a.add(n.createInstance(yy, this._elements.buttons, this._menuId.read(o), {
        orientation: 1,
        hoverDelegate: s,
        toolbarOptions: {
          primaryGroup: (d) => d.startsWith("primary")
        },
        overflowBehavior: { maxItems: this._isSmall.read(o) ? 1 : 3 },
        hiddenItemStrategy: 0,
        actionRunner: new A3(() => {
          const d = this._item.get(), c = d.mapping;
          return {
            mapping: c,
            originalWithModifiedChanges: i.computeStagedValue(c),
            originalUri: d.originalUri,
            modifiedUri: d.modifiedUri
          };
        }),
        menuOptions: {
          shouldForwardArgs: !0
        }
      }));
      a.add(l.onDidChangeMenuItems(() => {
        this._lastItemRange && this.layout(this._lastItemRange, this._lastViewRange);
      }));
    }));
  }
  layout(e, t) {
    this._lastItemRange = e, this._lastViewRange = t;
    let i = this._elements.buttons.clientHeight;
    this._isSmall.set(this._item.get().mapping.original.startLineNumber === 1 && e.length < 30, void 0), i = this._elements.buttons.clientHeight;
    const n = e.length / 2 - i / 2, s = i;
    let o = e.start + n;
    const a = tn.tryCreate(s, t.endExclusive - s - i), l = tn.tryCreate(e.start + s, e.endExclusive - i - s);
    l && a && l.start < l.endExclusive && (o = a.clip(o), o = l.clip(o)), this._elements.buttons.style.top = `${o - e.start}px`;
  }
};
zE = O3([
  qw(3, be)
], zE);
var Rre = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Are = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, UE;
let Lv = UE = class extends P {
  static setBreadcrumbsSourceFactory(e) {
    this._breadcrumbsSourceFactory.set(e, void 0);
  }
  get isUpdatingHiddenAreas() {
    return this._isUpdatingHiddenAreas;
  }
  constructor(e, t, i, n) {
    super(), this._editors = e, this._diffModel = t, this._options = i, this._instantiationService = n, this._modifiedOutlineSource = Da(this, (l) => {
      const d = this._editors.modifiedModel.read(l), c = UE._breadcrumbsSourceFactory.read(l);
      return !d || !c ? void 0 : c(d, this._instantiationService);
    }), this._isUpdatingHiddenAreas = !1, this._register(this._editors.original.onDidChangeCursorPosition((l) => {
      if (l.reason === 1)
        return;
      const d = this._diffModel.get();
      Nt((c) => {
        for (const h of this._editors.original.getSelections() || [])
          d == null || d.ensureOriginalLineIsVisible(h.getStartPosition().lineNumber, 0, c), d == null || d.ensureOriginalLineIsVisible(h.getEndPosition().lineNumber, 0, c);
      });
    })), this._register(this._editors.modified.onDidChangeCursorPosition((l) => {
      if (l.reason === 1)
        return;
      const d = this._diffModel.get();
      Nt((c) => {
        for (const h of this._editors.modified.getSelections() || [])
          d == null || d.ensureModifiedLineIsVisible(h.getStartPosition().lineNumber, 0, c), d == null || d.ensureModifiedLineIsVisible(h.getEndPosition().lineNumber, 0, c);
      });
    }));
    const s = this._diffModel.map((l, d) => {
      var c, h;
      const u = (c = l == null ? void 0 : l.unchangedRegions.read(d)) !== null && c !== void 0 ? c : [];
      return u.length === 1 && u[0].modifiedLineNumber === 1 && u[0].lineCount === ((h = this._editors.modifiedModel.read(d)) === null || h === void 0 ? void 0 : h.getLineCount()) ? [] : u;
    });
    this.viewZones = ig(this, (l, d) => {
      const c = this._modifiedOutlineSource.read(l);
      if (!c)
        return { origViewZones: [], modViewZones: [] };
      const h = [], u = [], g = this._options.renderSideBySide.read(l), f = s.read(l);
      for (const m of f)
        if (!m.shouldHideControls(l)) {
          {
            const _ = Pe(this, (b) => (
              /** @description hiddenOriginalRangeStart */
              m.getHiddenOriginalRange(b).startLineNumber - 1
            )), v = new Cy(_, 24);
            h.push(v), d.add(new QF(this._editors.original, v, m, m.originalUnchangedRange, !g, c, (b) => this._diffModel.get().ensureModifiedLineIsVisible(b, 2, void 0), this._options));
          }
          {
            const _ = Pe(this, (b) => (
              /** @description hiddenModifiedRangeStart */
              m.getHiddenModifiedRange(b).startLineNumber - 1
            )), v = new Cy(_, 24);
            u.push(v), d.add(new QF(this._editors.modified, v, m, m.modifiedUnchangedRange, !1, c, (b) => this._diffModel.get().ensureModifiedLineIsVisible(b, 2, void 0), this._options));
          }
        }
      return { origViewZones: h, modViewZones: u };
    });
    const o = {
      description: "unchanged lines",
      className: "diff-unchanged-lines",
      isWholeLine: !0
    }, a = {
      description: "Fold Unchanged",
      glyphMarginHoverMessage: new Nn(void 0, { isTrusted: !0, supportThemeIcons: !0 }).appendMarkdown(p("foldUnchanged", "Fold Unchanged Region")),
      glyphMarginClassName: "fold-unchanged " + Le.asClassName(me.fold),
      zIndex: 10001
    };
    this._register(by(this._editors.original, Pe(this, (l) => {
      const d = s.read(l), c = d.map((h) => ({
        range: h.originalUnchangedRange.toInclusiveRange(),
        options: o
      }));
      for (const h of d)
        h.shouldHideControls(l) && c.push({
          range: L.fromPositions(new A(h.originalLineNumber, 1)),
          options: a
        });
      return c;
    }))), this._register(by(this._editors.modified, Pe(this, (l) => {
      const d = s.read(l), c = d.map((h) => ({
        range: h.modifiedUnchangedRange.toInclusiveRange(),
        options: o
      }));
      for (const h of d)
        h.shouldHideControls(l) && c.push({
          range: Yt.ofLength(h.modifiedLineNumber, 1).toInclusiveRange(),
          options: a
        });
      return c;
    }))), this._register(qe((l) => {
      const d = s.read(l);
      this._isUpdatingHiddenAreas = !0;
      try {
        this._editors.original.setHiddenAreas(d.map((c) => c.getHiddenOriginalRange(l).toInclusiveRange()).filter(qa)), this._editors.modified.setHiddenAreas(d.map((c) => c.getHiddenModifiedRange(l).toInclusiveRange()).filter(qa));
      } finally {
        this._isUpdatingHiddenAreas = !1;
      }
    })), this._register(this._editors.modified.onMouseUp((l) => {
      var d;
      if (!l.event.rightButton && l.target.position && (!((d = l.target.element) === null || d === void 0) && d.className.includes("fold-unchanged"))) {
        const c = l.target.position.lineNumber, h = this._diffModel.get();
        if (!h)
          return;
        const u = h.unchangedRegions.get().find((g) => g.modifiedUnchangedRange.includes(c));
        if (!u)
          return;
        u.collapseAll(void 0), l.event.stopPropagation(), l.event.preventDefault();
      }
    })), this._register(this._editors.original.onMouseUp((l) => {
      var d;
      if (!l.event.rightButton && l.target.position && (!((d = l.target.element) === null || d === void 0) && d.className.includes("fold-unchanged"))) {
        const c = l.target.position.lineNumber, h = this._diffModel.get();
        if (!h)
          return;
        const u = h.unchangedRegions.get().find((g) => g.originalUnchangedRange.includes(c));
        if (!u)
          return;
        u.collapseAll(void 0), l.event.stopPropagation(), l.event.preventDefault();
      }
    }));
  }
};
Lv._breadcrumbsSourceFactory = rt("breadcrumbsSourceFactory", void 0);
Lv = UE = Rre([
  Are(3, be)
], Lv);
class QF extends I3 {
  constructor(e, t, i, n, s, o, a, l) {
    const d = ft("div.diff-hidden-lines-widget");
    super(e, t, d.root), this._editor = e, this._unchangedRegion = i, this._unchangedRegionRange = n, this._hide = s, this._modifiedOutlineSource = o, this._revealModifiedHiddenLine = a, this._options = l, this._nodes = ft("div.diff-hidden-lines", [
      ft("div.top@top", { title: p("diff.hiddenLines.top", "Click or drag to show more above") }),
      ft("div.center@content", { style: { display: "flex" } }, [
        ft("div@first", { style: { display: "flex", justifyContent: "center", alignItems: "center", flexShrink: "0" } }, [X("a", { title: p("showUnchangedRegion", "Show Unchanged Region"), role: "button", onclick: () => {
          this._unchangedRegion.showAll(void 0);
        } }, ..._c("$(unfold)"))]),
        ft("div@others", { style: { display: "flex", justifyContent: "center", alignItems: "center" } })
      ]),
      ft("div.bottom@bottom", { title: p("diff.bottom", "Click or drag to show more below"), role: "button" })
    ]), d.root.appendChild(this._nodes.root);
    const c = Lt(this._editor.onDidLayoutChange, () => this._editor.getLayoutInfo());
    this._hide ? mn(this._nodes.first) : this._register(Vc(this._nodes.first, { width: c.map((u) => u.contentLeft) })), this._register(qe((u) => {
      const g = this._unchangedRegion.visibleLineCountTop.read(u) + this._unchangedRegion.visibleLineCountBottom.read(u) === this._unchangedRegion.lineCount;
      this._nodes.bottom.classList.toggle("canMoveTop", !g), this._nodes.bottom.classList.toggle("canMoveBottom", this._unchangedRegion.visibleLineCountBottom.read(u) > 0), this._nodes.top.classList.toggle("canMoveTop", this._unchangedRegion.visibleLineCountTop.read(u) > 0), this._nodes.top.classList.toggle("canMoveBottom", !g);
      const f = this._unchangedRegion.isDragged.read(u), m = this._editor.getDomNode();
      m && (m.classList.toggle("draggingUnchangedRegion", !!f), f === "top" ? (m.classList.toggle("canMoveTop", this._unchangedRegion.visibleLineCountTop.read(u) > 0), m.classList.toggle("canMoveBottom", !g)) : f === "bottom" ? (m.classList.toggle("canMoveTop", !g), m.classList.toggle("canMoveBottom", this._unchangedRegion.visibleLineCountBottom.read(u) > 0)) : (m.classList.toggle("canMoveTop", !1), m.classList.toggle("canMoveBottom", !1)));
    }));
    const h = this._editor;
    this._register(W(this._nodes.top, "mousedown", (u) => {
      if (u.button !== 0)
        return;
      this._nodes.top.classList.toggle("dragging", !0), this._nodes.root.classList.toggle("dragging", !0), u.preventDefault();
      const g = u.clientY;
      let f = !1;
      const m = this._unchangedRegion.visibleLineCountTop.get();
      this._unchangedRegion.isDragged.set("top", void 0);
      const _ = we(this._nodes.top), v = W(_, "mousemove", (C) => {
        const S = C.clientY - g;
        f = f || Math.abs(S) > 2;
        const y = Math.round(S / h.getOption(
          67
          /* EditorOption.lineHeight */
        )), k = Math.max(0, Math.min(m + y, this._unchangedRegion.getMaxVisibleLineCountTop()));
        this._unchangedRegion.visibleLineCountTop.set(k, void 0);
      }), b = W(_, "mouseup", (C) => {
        f || this._unchangedRegion.showMoreAbove(this._options.hideUnchangedRegionsRevealLineCount.get(), void 0), this._nodes.top.classList.toggle("dragging", !1), this._nodes.root.classList.toggle("dragging", !1), this._unchangedRegion.isDragged.set(void 0, void 0), v.dispose(), b.dispose();
      });
    })), this._register(W(this._nodes.bottom, "mousedown", (u) => {
      if (u.button !== 0)
        return;
      this._nodes.bottom.classList.toggle("dragging", !0), this._nodes.root.classList.toggle("dragging", !0), u.preventDefault();
      const g = u.clientY;
      let f = !1;
      const m = this._unchangedRegion.visibleLineCountBottom.get();
      this._unchangedRegion.isDragged.set("bottom", void 0);
      const _ = we(this._nodes.bottom), v = W(_, "mousemove", (C) => {
        const S = C.clientY - g;
        f = f || Math.abs(S) > 2;
        const y = Math.round(S / h.getOption(
          67
          /* EditorOption.lineHeight */
        )), k = Math.max(0, Math.min(m - y, this._unchangedRegion.getMaxVisibleLineCountBottom())), E = this._unchangedRegionRange.endLineNumberExclusive > h.getModel().getLineCount() ? h.getContentHeight() : h.getTopForLineNumber(this._unchangedRegionRange.endLineNumberExclusive);
        this._unchangedRegion.visibleLineCountBottom.set(k, void 0);
        const N = this._unchangedRegionRange.endLineNumberExclusive > h.getModel().getLineCount() ? h.getContentHeight() : h.getTopForLineNumber(this._unchangedRegionRange.endLineNumberExclusive);
        h.setScrollTop(h.getScrollTop() + (N - E));
      }), b = W(_, "mouseup", (C) => {
        if (this._unchangedRegion.isDragged.set(void 0, void 0), !f) {
          const w = h.getTopForLineNumber(this._unchangedRegionRange.endLineNumberExclusive);
          this._unchangedRegion.showMoreBelow(this._options.hideUnchangedRegionsRevealLineCount.get(), void 0);
          const S = h.getTopForLineNumber(this._unchangedRegionRange.endLineNumberExclusive);
          h.setScrollTop(h.getScrollTop() + (S - w));
        }
        this._nodes.bottom.classList.toggle("dragging", !1), this._nodes.root.classList.toggle("dragging", !1), v.dispose(), b.dispose();
      });
    })), this._register(qe((u) => {
      const g = [];
      if (!this._hide) {
        const f = i.getHiddenModifiedRange(u).length, m = p("hiddenLines", "{0} hidden lines", f), _ = X("span", { title: p("diff.hiddenLines.expandAll", "Double click to unfold") }, m);
        _.addEventListener("dblclick", (C) => {
          C.button === 0 && (C.preventDefault(), this._unchangedRegion.showAll(void 0));
        }), g.push(_);
        const v = this._unchangedRegion.getHiddenModifiedRange(u), b = this._modifiedOutlineSource.getBreadcrumbItems(v, u);
        if (b.length > 0) {
          g.push(X("span", void 0, "|"));
          for (let C = 0; C < b.length; C++) {
            const w = b[C], S = fH.toIcon(w.kind), y = ft("div.breadcrumb-item", {
              style: { display: "flex", alignItems: "center" }
            }, [
              Lu(S),
              "",
              w.name,
              ...C === b.length - 1 ? [] : [Lu(me.chevronRight)]
            ]).root;
            g.push(y), y.onclick = () => {
              this._revealModifiedHiddenLine(w.startLineNumber);
            };
          }
        }
      }
      mn(this._nodes.others, ...g);
    }));
  }
}
var Pre = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Ore = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, Xo;
let Tu = Xo = class extends P {
  constructor(e, t, i, n, s, o, a) {
    super(), this._editors = e, this._rootElement = t, this._diffModel = i, this._rootWidth = n, this._rootHeight = s, this._modifiedEditorLayoutInfo = o, this._themeService = a, this.width = Xo.ENTIRE_DIFF_OVERVIEW_WIDTH;
    const l = Lt(this._themeService.onDidColorThemeChange, () => this._themeService.getColorTheme()), d = Pe((u) => {
      const g = l.read(u), f = g.getColor(AG) || (g.getColor(MG) || $x).transparent(2), m = g.getColor(PG) || (g.getColor(RG) || Kx).transparent(2);
      return { insertColor: f, removeColor: m };
    }), c = bt(document.createElement("div"));
    c.setClassName("diffViewport"), c.setPosition("absolute");
    const h = ft("div.diffOverview", {
      style: { position: "absolute", top: "0px", width: Xo.ENTIRE_DIFF_OVERVIEW_WIDTH + "px" }
    }).root;
    this._register(Hm(h, c.domNode)), this._register(pi(h, Q.POINTER_DOWN, (u) => {
      this._editors.modified.delegateVerticalScrollbarPointerDown(u);
    })), this._register(W(h, Q.MOUSE_WHEEL, (u) => {
      this._editors.modified.delegateScrollFromMouseWheelEvent(u);
    }, { passive: !1 })), this._register(Hm(this._rootElement, h)), this._register(Wo((u, g) => {
      const f = this._diffModel.read(u), m = this._editors.original.createOverviewRuler("original diffOverviewRuler");
      m && (g.add(m), g.add(Hm(h, m.getDomNode())));
      const _ = this._editors.modified.createOverviewRuler("modified diffOverviewRuler");
      if (_ && (g.add(_), g.add(Hm(h, _.getDomNode()))), !m || !_)
        return;
      const v = Mn("viewZoneChanged", this._editors.original.onDidChangeViewZones), b = Mn("viewZoneChanged", this._editors.modified.onDidChangeViewZones), C = Mn("hiddenRangesChanged", this._editors.original.onDidChangeHiddenAreas), w = Mn("hiddenRangesChanged", this._editors.modified.onDidChangeHiddenAreas);
      g.add(qe((S) => {
        var y;
        v.read(S), b.read(S), C.read(S), w.read(S);
        const k = d.read(S), E = (y = f == null ? void 0 : f.diff.read(S)) === null || y === void 0 ? void 0 : y.mappings;
        function N(Z, H, re) {
          const ue = re._getViewModel();
          return ue ? Z.filter((Ve) => Ve.length > 0).map((Ve) => {
            const Ye = ue.coordinatesConverter.convertModelPositionToViewPosition(new A(Ve.startLineNumber, 1)), ze = ue.coordinatesConverter.convertModelPositionToViewPosition(new A(Ve.endLineNumberExclusive, 1)), pe = ze.lineNumber - Ye.lineNumber;
            return new u2(Ye.lineNumber, ze.lineNumber, pe, H.toString());
          }) : [];
        }
        const F = N((E || []).map((Z) => Z.lineRangeMapping.original), k.removeColor, this._editors.original), V = N((E || []).map((Z) => Z.lineRangeMapping.modified), k.insertColor, this._editors.modified);
        m == null || m.setZones(F), _ == null || _.setZones(V);
      })), g.add(qe((S) => {
        const y = this._rootHeight.read(S), k = this._rootWidth.read(S), E = this._modifiedEditorLayoutInfo.read(S);
        if (E) {
          const N = Xo.ENTIRE_DIFF_OVERVIEW_WIDTH - 2 * Xo.ONE_OVERVIEW_WIDTH;
          m.setLayout({
            top: 0,
            height: y,
            right: N + Xo.ONE_OVERVIEW_WIDTH,
            width: Xo.ONE_OVERVIEW_WIDTH
          }), _.setLayout({
            top: 0,
            height: y,
            right: 0,
            width: Xo.ONE_OVERVIEW_WIDTH
          });
          const F = this._editors.modifiedScrollTop.read(S), V = this._editors.modifiedScrollHeight.read(S), Z = this._editors.modified.getOption(
            103
            /* EditorOption.scrollbar */
          ), H = new Zf(Z.verticalHasArrows ? Z.arrowSize : 0, Z.verticalScrollbarSize, 0, E.height, V, F);
          c.setTop(H.getSliderPosition()), c.setHeight(H.getSliderSize());
        } else
          c.setTop(0), c.setHeight(0);
        h.style.height = y + "px", h.style.left = k - Xo.ENTIRE_DIFF_OVERVIEW_WIDTH + "px", c.setWidth(Xo.ENTIRE_DIFF_OVERVIEW_WIDTH);
      }));
    }));
  }
};
Tu.ONE_OVERVIEW_WIDTH = 15;
Tu.ENTIRE_DIFF_OVERVIEW_WIDTH = Xo.ONE_OVERVIEW_WIDTH * 2;
Tu = Xo = Pre([
  Ore(6, $i)
], Tu);
const Wk = [];
class Fre extends P {
  constructor(e, t, i, n) {
    super(), this._editors = e, this._diffModel = t, this._options = i, this._widget = n, this._selectedDiffs = Pe(this, (s) => {
      const o = this._diffModel.read(s), a = o == null ? void 0 : o.diff.read(s);
      if (!a)
        return Wk;
      const l = this._editors.modifiedSelections.read(s);
      if (l.every((u) => u.isEmpty()))
        return Wk;
      const d = new GN(l.map((u) => Yt.fromRangeInclusive(u))), h = a.mappings.filter((u) => u.lineRangeMapping.innerChanges && d.intersects(u.lineRangeMapping.modified)).map((u) => ({
        mapping: u,
        rangeMappings: u.lineRangeMapping.innerChanges.filter((g) => l.some((f) => L.areIntersecting(g.modifiedRange, f)))
      }));
      return h.length === 0 || h.every((u) => u.rangeMappings.length === 0) ? Wk : h;
    }), this._register(Wo((s, o) => {
      if (!this._options.shouldRenderOldRevertArrows.read(s))
        return;
      const a = this._diffModel.read(s), l = a == null ? void 0 : a.diff.read(s);
      if (!a || !l || a.movedTextToCompare.read(s))
        return;
      const d = [], c = this._selectedDiffs.read(s), h = new Set(c.map((u) => u.mapping));
      if (c.length > 0) {
        const u = this._editors.modifiedSelections.read(s), g = o.add(new Dv(u[u.length - 1].positionLineNumber, this._widget, c.flatMap((f) => f.rangeMappings), !0));
        this._editors.modified.addGlyphMarginWidget(g), d.push(g);
      }
      for (const u of l.mappings)
        if (!h.has(u) && !u.lineRangeMapping.modified.isEmpty && u.lineRangeMapping.innerChanges) {
          const g = o.add(new Dv(u.lineRangeMapping.modified.startLineNumber, this._widget, u.lineRangeMapping, !1));
          this._editors.modified.addGlyphMarginWidget(g), d.push(g);
        }
      o.add(Se(() => {
        for (const u of d)
          this._editors.modified.removeGlyphMarginWidget(u);
      }));
    }));
  }
}
class Dv extends P {
  getId() {
    return this._id;
  }
  constructor(e, t, i, n) {
    super(), this._lineNumber = e, this._widget = t, this._diffs = i, this._revertSelection = n, this._id = `revertButton${Dv.counter++}`, this._domNode = ft("div.revertButton", {
      title: this._revertSelection ? p("revertSelectedChanges", "Revert Selected Changes") : p("revertChange", "Revert Change")
    }, [Lu(me.arrowRight)]).root, this._register(W(this._domNode, Q.MOUSE_DOWN, (s) => {
      s.button !== 2 && (s.stopPropagation(), s.preventDefault());
    })), this._register(W(this._domNode, Q.MOUSE_UP, (s) => {
      s.stopPropagation(), s.preventDefault();
    })), this._register(W(this._domNode, Q.CLICK, (s) => {
      this._diffs instanceof cf ? this._widget.revert(this._diffs) : this._widget.revertRangeMappings(this._diffs), s.stopPropagation(), s.preventDefault();
    }));
  }
  /**
   * Get the dom node of the glyph widget.
   */
  getDomNode() {
    return this._domNode;
  }
  /**
   * Get the placement of the glyph widget.
   */
  getPosition() {
    return {
      lane: Ec.Right,
      range: {
        startColumn: 1,
        startLineNumber: this._lineNumber,
        endColumn: 1,
        endLineNumber: this._lineNumber
      },
      zIndex: 10001
    };
  }
}
Dv.counter = 0;
function Cl(r, e, t) {
  const i = r.bindTo(e);
  return Z0({ debugName: () => `Set Context Key "${r.key}"` }, (n) => {
    i.set(t(n));
  });
}
function Wre(r) {
  return eu.get(r);
}
class eu {
  /**
   * Make sure that editor is not disposed yet!
  */
  static get(e) {
    let t = eu._map.get(e);
    if (!t) {
      t = new eu(e), eu._map.set(e, t);
      const i = e.onDidDispose(() => {
        eu._map.delete(e), i.dispose();
      });
    }
    return t;
  }
  constructor(e) {
    this.editor = e, this.model = Lt(this.editor.onDidChangeModel, () => this.editor.getModel());
  }
}
eu._map = /* @__PURE__ */ new Map();
var Bre = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, XF = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
let $E = class extends P {
  get onDidContentSizeChange() {
    return this._onDidContentSizeChange.event;
  }
  constructor(e, t, i, n, s, o, a) {
    super(), this.originalEditorElement = e, this.modifiedEditorElement = t, this._options = i, this._argCodeEditorWidgetOptions = n, this._createInnerEditor = s, this._instantiationService = o, this._keybindingService = a, this.original = this._register(this._createLeftHandSideEditor(this._options.editorOptions.get(), this._argCodeEditorWidgetOptions.originalEditor || {})), this.modified = this._register(this._createRightHandSideEditor(this._options.editorOptions.get(), this._argCodeEditorWidgetOptions.modifiedEditor || {})), this._onDidContentSizeChange = this._register(new R()), this.modifiedScrollTop = Lt(this.modified.onDidScrollChange, () => (
      /** @description modified.getScrollTop */
      this.modified.getScrollTop()
    )), this.modifiedScrollHeight = Lt(this.modified.onDidScrollChange, () => (
      /** @description modified.getScrollHeight */
      this.modified.getScrollHeight()
    )), this.modifiedModel = Wre(this.modified).model, this.modifiedSelections = Lt(this.modified.onDidChangeCursorSelection, () => {
      var l;
      return (l = this.modified.getSelections()) !== null && l !== void 0 ? l : [];
    }), this.modifiedCursor = Fl({ owner: this, equalsFn: A.equals }, (l) => {
      var d, c;
      return (c = (d = this.modifiedSelections.read(l)[0]) === null || d === void 0 ? void 0 : d.getPosition()) !== null && c !== void 0 ? c : new A(1, 1);
    }), this.originalCursor = Lt(this.original.onDidChangeCursorPosition, () => {
      var l;
      return (l = this.original.getPosition()) !== null && l !== void 0 ? l : new A(1, 1);
    }), this._argCodeEditorWidgetOptions = null, this._register(kb({
      createEmptyChangeSummary: () => ({}),
      handleChange: (l, d) => (l.didChange(i.editorOptions) && Object.assign(d, l.change.changedOptions), !0)
    }, (l, d) => {
      i.editorOptions.read(l), this._options.renderSideBySide.read(l), this.modified.updateOptions(this._adjustOptionsForRightHandSide(l, d)), this.original.updateOptions(this._adjustOptionsForLeftHandSide(l, d));
    }));
  }
  _createLeftHandSideEditor(e, t) {
    const i = this._adjustOptionsForLeftHandSide(void 0, e), n = this._constructInnerEditor(this._instantiationService, this.originalEditorElement, i, t);
    return n.setContextValue("isInDiffLeftEditor", !0), n;
  }
  _createRightHandSideEditor(e, t) {
    const i = this._adjustOptionsForRightHandSide(void 0, e), n = this._constructInnerEditor(this._instantiationService, this.modifiedEditorElement, i, t);
    return n.setContextValue("isInDiffRightEditor", !0), n;
  }
  _constructInnerEditor(e, t, i, n) {
    const s = this._createInnerEditor(e, t, i, n);
    return this._register(s.onDidContentSizeChange((o) => {
      const a = this.original.getContentWidth() + this.modified.getContentWidth() + Tu.ENTIRE_DIFF_OVERVIEW_WIDTH, l = Math.max(this.modified.getContentHeight(), this.original.getContentHeight());
      this._onDidContentSizeChange.fire({
        contentHeight: l,
        contentWidth: a,
        contentHeightChanged: o.contentHeightChanged,
        contentWidthChanged: o.contentWidthChanged
      });
    })), s;
  }
  _adjustOptionsForLeftHandSide(e, t) {
    const i = this._adjustOptionsForSubEditor(t);
    return this._options.renderSideBySide.get() ? (i.unicodeHighlight = this._options.editorOptions.get().unicodeHighlight || {}, i.wordWrapOverride1 = this._options.diffWordWrap.get()) : (i.wordWrapOverride1 = "off", i.wordWrapOverride2 = "off", i.stickyScroll = { enabled: !1 }, i.unicodeHighlight = { nonBasicASCII: !1, ambiguousCharacters: !1, invisibleCharacters: !1 }), i.glyphMargin = this._options.renderSideBySide.get(), t.originalAriaLabel && (i.ariaLabel = t.originalAriaLabel), i.ariaLabel = this._updateAriaLabel(i.ariaLabel), i.readOnly = !this._options.originalEditable.get(), i.dropIntoEditor = { enabled: !i.readOnly }, i.extraEditorClassName = "original-in-monaco-diff-editor", i;
  }
  _adjustOptionsForRightHandSide(e, t) {
    const i = this._adjustOptionsForSubEditor(t);
    return t.modifiedAriaLabel && (i.ariaLabel = t.modifiedAriaLabel), i.ariaLabel = this._updateAriaLabel(i.ariaLabel), i.wordWrapOverride1 = this._options.diffWordWrap.get(), i.revealHorizontalRightPadding = oa.revealHorizontalRightPadding.defaultValue + Tu.ENTIRE_DIFF_OVERVIEW_WIDTH, i.scrollbar.verticalHasArrows = !1, i.extraEditorClassName = "modified-in-monaco-diff-editor", i;
  }
  _adjustOptionsForSubEditor(e) {
    const t = {
      ...e,
      dimension: {
        height: 0,
        width: 0
      }
    };
    return t.inDiffEditor = !0, t.automaticLayout = !1, t.scrollbar = { ...t.scrollbar || {} }, t.folding = !1, t.codeLens = this._options.diffCodeLens.get(), t.fixedOverflowWidgets = !0, t.minimap = { ...t.minimap || {} }, t.minimap.enabled = !1, this._options.hideUnchangedRegions.get() ? t.stickyScroll = { enabled: !1 } : t.stickyScroll = this._options.editorOptions.get().stickyScroll, t;
  }
  _updateAriaLabel(e) {
    var t;
    e || (e = "");
    const i = p("diff-aria-navigation-tip", " use {0} to open the accessibility help.", (t = this._keybindingService.lookupKeybinding("editor.action.accessibilityHelp")) === null || t === void 0 ? void 0 : t.getAriaLabel());
    return this._options.accessibilityVerbose.get() ? e + i : e ? e.replaceAll(i, "") : "";
  }
};
$E = Bre([
  XF(5, be),
  XF(6, _t)
], $E);
class pL extends P {
  constructor() {
    super(...arguments), this._id = ++pL.idCounter, this._onDidDispose = this._register(new R()), this.onDidDispose = this._onDidDispose.event;
  }
  getId() {
    return this.getEditorType() + ":v2:" + this._id;
  }
  // #region editorBrowser.IDiffEditor: Delegating to modified Editor
  getVisibleColumnFromPosition(e) {
    return this._targetEditor.getVisibleColumnFromPosition(e);
  }
  getPosition() {
    return this._targetEditor.getPosition();
  }
  setPosition(e, t = "api") {
    this._targetEditor.setPosition(e, t);
  }
  revealLine(e, t = 0) {
    this._targetEditor.revealLine(e, t);
  }
  revealLineInCenter(e, t = 0) {
    this._targetEditor.revealLineInCenter(e, t);
  }
  revealLineInCenterIfOutsideViewport(e, t = 0) {
    this._targetEditor.revealLineInCenterIfOutsideViewport(e, t);
  }
  revealLineNearTop(e, t = 0) {
    this._targetEditor.revealLineNearTop(e, t);
  }
  revealPosition(e, t = 0) {
    this._targetEditor.revealPosition(e, t);
  }
  revealPositionInCenter(e, t = 0) {
    this._targetEditor.revealPositionInCenter(e, t);
  }
  revealPositionInCenterIfOutsideViewport(e, t = 0) {
    this._targetEditor.revealPositionInCenterIfOutsideViewport(e, t);
  }
  revealPositionNearTop(e, t = 0) {
    this._targetEditor.revealPositionNearTop(e, t);
  }
  getSelection() {
    return this._targetEditor.getSelection();
  }
  getSelections() {
    return this._targetEditor.getSelections();
  }
  setSelection(e, t = "api") {
    this._targetEditor.setSelection(e, t);
  }
  setSelections(e, t = "api") {
    this._targetEditor.setSelections(e, t);
  }
  revealLines(e, t, i = 0) {
    this._targetEditor.revealLines(e, t, i);
  }
  revealLinesInCenter(e, t, i = 0) {
    this._targetEditor.revealLinesInCenter(e, t, i);
  }
  revealLinesInCenterIfOutsideViewport(e, t, i = 0) {
    this._targetEditor.revealLinesInCenterIfOutsideViewport(e, t, i);
  }
  revealLinesNearTop(e, t, i = 0) {
    this._targetEditor.revealLinesNearTop(e, t, i);
  }
  revealRange(e, t = 0, i = !1, n = !0) {
    this._targetEditor.revealRange(e, t, i, n);
  }
  revealRangeInCenter(e, t = 0) {
    this._targetEditor.revealRangeInCenter(e, t);
  }
  revealRangeInCenterIfOutsideViewport(e, t = 0) {
    this._targetEditor.revealRangeInCenterIfOutsideViewport(e, t);
  }
  revealRangeNearTop(e, t = 0) {
    this._targetEditor.revealRangeNearTop(e, t);
  }
  revealRangeNearTopIfOutsideViewport(e, t = 0) {
    this._targetEditor.revealRangeNearTopIfOutsideViewport(e, t);
  }
  revealRangeAtTop(e, t = 0) {
    this._targetEditor.revealRangeAtTop(e, t);
  }
  getSupportedActions() {
    return this._targetEditor.getSupportedActions();
  }
  focus() {
    this._targetEditor.focus();
  }
  trigger(e, t, i) {
    this._targetEditor.trigger(e, t, i);
  }
  createDecorationsCollection(e) {
    return this._targetEditor.createDecorationsCollection(e);
  }
  changeDecorations(e) {
    return this._targetEditor.changeDecorations(e);
  }
}
pL.idCounter = 0;
var Hre = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Vre = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
let KE = class {
  get editorOptions() {
    return this._options;
  }
  constructor(e, t) {
    this._accessibilityService = t, this._diffEditorWidth = rt(this, 0), this._screenReaderMode = Lt(this._accessibilityService.onDidChangeScreenReaderOptimized, () => this._accessibilityService.isScreenReaderOptimized()), this.couldShowInlineViewBecauseOfSize = Pe(this, (n) => this._options.read(n).renderSideBySide && this._diffEditorWidth.read(n) <= this._options.read(n).renderSideBySideInlineBreakpoint), this.renderOverviewRuler = Pe(this, (n) => this._options.read(n).renderOverviewRuler), this.renderSideBySide = Pe(this, (n) => this._options.read(n).renderSideBySide && !(this._options.read(n).useInlineViewWhenSpaceIsLimited && this.couldShowInlineViewBecauseOfSize.read(n) && !this._screenReaderMode.read(n))), this.readOnly = Pe(this, (n) => this._options.read(n).readOnly), this.shouldRenderOldRevertArrows = Pe(this, (n) => !(!this._options.read(n).renderMarginRevertIcon || !this.renderSideBySide.read(n) || this.readOnly.read(n) || this.shouldRenderGutterMenu.read(n))), this.shouldRenderGutterMenu = Pe(this, (n) => this._options.read(n).renderGutterMenu), this.renderIndicators = Pe(this, (n) => this._options.read(n).renderIndicators), this.enableSplitViewResizing = Pe(this, (n) => this._options.read(n).enableSplitViewResizing), this.splitViewDefaultRatio = Pe(this, (n) => this._options.read(n).splitViewDefaultRatio), this.ignoreTrimWhitespace = Pe(this, (n) => this._options.read(n).ignoreTrimWhitespace), this.maxComputationTimeMs = Pe(this, (n) => this._options.read(n).maxComputationTime), this.showMoves = Pe(this, (n) => this._options.read(n).experimental.showMoves && this.renderSideBySide.read(n)), this.isInEmbeddedEditor = Pe(this, (n) => this._options.read(n).isInEmbeddedEditor), this.diffWordWrap = Pe(this, (n) => this._options.read(n).diffWordWrap), this.originalEditable = Pe(this, (n) => this._options.read(n).originalEditable), this.diffCodeLens = Pe(this, (n) => this._options.read(n).diffCodeLens), this.accessibilityVerbose = Pe(this, (n) => this._options.read(n).accessibilityVerbose), this.diffAlgorithm = Pe(this, (n) => this._options.read(n).diffAlgorithm), this.showEmptyDecorations = Pe(this, (n) => this._options.read(n).experimental.showEmptyDecorations), this.onlyShowAccessibleDiffViewer = Pe(this, (n) => this._options.read(n).onlyShowAccessibleDiffViewer), this.hideUnchangedRegions = Pe(this, (n) => this._options.read(n).hideUnchangedRegions.enabled), this.hideUnchangedRegionsRevealLineCount = Pe(this, (n) => this._options.read(n).hideUnchangedRegions.revealLineCount), this.hideUnchangedRegionsContextLineCount = Pe(this, (n) => this._options.read(n).hideUnchangedRegions.contextLineCount), this.hideUnchangedRegionsMinimumLineCount = Pe(this, (n) => this._options.read(n).hideUnchangedRegions.minimumLineCount);
    const i = { ...e, ...JF(e, xn) };
    this._options = rt(this, i);
  }
  updateOptions(e) {
    const t = JF(e, this._options.get()), i = { ...this._options.get(), ...e, ...t };
    this._options.set(i, void 0, { changedOptions: e });
  }
  setWidth(e) {
    this._diffEditorWidth.set(e, void 0);
  }
};
KE = Hre([
  Vre(1, qs)
], KE);
function JF(r, e) {
  var t, i, n, s, o, a, l, d;
  return {
    enableSplitViewResizing: fe(r.enableSplitViewResizing, e.enableSplitViewResizing),
    splitViewDefaultRatio: sj(r.splitViewDefaultRatio, 0.5, 0.1, 0.9),
    renderSideBySide: fe(r.renderSideBySide, e.renderSideBySide),
    renderMarginRevertIcon: fe(r.renderMarginRevertIcon, e.renderMarginRevertIcon),
    maxComputationTime: Eh(
      r.maxComputationTime,
      e.maxComputationTime,
      0,
      1073741824
      /* Constants.MAX_SAFE_SMALL_INTEGER */
    ),
    maxFileSize: Eh(
      r.maxFileSize,
      e.maxFileSize,
      0,
      1073741824
      /* Constants.MAX_SAFE_SMALL_INTEGER */
    ),
    ignoreTrimWhitespace: fe(r.ignoreTrimWhitespace, e.ignoreTrimWhitespace),
    renderIndicators: fe(r.renderIndicators, e.renderIndicators),
    originalEditable: fe(r.originalEditable, e.originalEditable),
    diffCodeLens: fe(r.diffCodeLens, e.diffCodeLens),
    renderOverviewRuler: fe(r.renderOverviewRuler, e.renderOverviewRuler),
    diffWordWrap: gi(r.diffWordWrap, e.diffWordWrap, ["off", "on", "inherit"]),
    diffAlgorithm: gi(r.diffAlgorithm, e.diffAlgorithm, ["legacy", "advanced"], { smart: "legacy", experimental: "advanced" }),
    accessibilityVerbose: fe(r.accessibilityVerbose, e.accessibilityVerbose),
    experimental: {
      showMoves: fe((t = r.experimental) === null || t === void 0 ? void 0 : t.showMoves, e.experimental.showMoves),
      showEmptyDecorations: fe((i = r.experimental) === null || i === void 0 ? void 0 : i.showEmptyDecorations, e.experimental.showEmptyDecorations)
    },
    hideUnchangedRegions: {
      enabled: fe((s = (n = r.hideUnchangedRegions) === null || n === void 0 ? void 0 : n.enabled) !== null && s !== void 0 ? s : (o = r.experimental) === null || o === void 0 ? void 0 : o.collapseUnchangedRegions, e.hideUnchangedRegions.enabled),
      contextLineCount: Eh(
        (a = r.hideUnchangedRegions) === null || a === void 0 ? void 0 : a.contextLineCount,
        e.hideUnchangedRegions.contextLineCount,
        0,
        1073741824
        /* Constants.MAX_SAFE_SMALL_INTEGER */
      ),
      minimumLineCount: Eh(
        (l = r.hideUnchangedRegions) === null || l === void 0 ? void 0 : l.minimumLineCount,
        e.hideUnchangedRegions.minimumLineCount,
        0,
        1073741824
        /* Constants.MAX_SAFE_SMALL_INTEGER */
      ),
      revealLineCount: Eh(
        (d = r.hideUnchangedRegions) === null || d === void 0 ? void 0 : d.revealLineCount,
        e.hideUnchangedRegions.revealLineCount,
        0,
        1073741824
        /* Constants.MAX_SAFE_SMALL_INTEGER */
      )
    },
    isInEmbeddedEditor: fe(r.isInEmbeddedEditor, e.isInEmbeddedEditor),
    onlyShowAccessibleDiffViewer: fe(r.onlyShowAccessibleDiffViewer, e.onlyShowAccessibleDiffViewer),
    renderSideBySideInlineBreakpoint: Eh(
      r.renderSideBySideInlineBreakpoint,
      e.renderSideBySideInlineBreakpoint,
      0,
      1073741824
      /* Constants.MAX_SAFE_SMALL_INTEGER */
    ),
    useInlineViewWhenSpaceIsLimited: fe(r.useInlineViewWhenSpaceIsLimited, e.useInlineViewWhenSpaceIsLimited),
    renderGutterMenu: fe(r.renderGutterMenu, e.renderGutterMenu)
  };
}
var zre = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, gm = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
let ud = class extends pL {
  get onDidContentSizeChange() {
    return this._editors.onDidContentSizeChange;
  }
  constructor(e, t, i, n, s, o, a, l) {
    var d;
    super(), this._domElement = e, this._parentContextKeyService = n, this._parentInstantiationService = s, this._accessibilitySignalService = a, this._editorProgressService = l, this.elements = ft("div.monaco-diff-editor.side-by-side", { style: { position: "relative", height: "100%" } }, [
      ft("div.editor.original@original", { style: { position: "absolute", height: "100%" } }),
      ft("div.editor.modified@modified", { style: { position: "absolute", height: "100%" } }),
      ft("div.accessibleDiffViewer@accessibleDiffViewer", { style: { position: "absolute", height: "100%" } })
    ]), this._diffModel = rt(this, void 0), this._shouldDisposeDiffModel = !1, this.onDidChangeModel = ne.fromObservableLight(this._diffModel), this._contextKeyService = this._register(this._parentContextKeyService.createScoped(this._domElement)), this._instantiationService = this._register(this._parentInstantiationService.createChild(new Cb([De, this._contextKeyService]))), this._boundarySashes = rt(this, void 0), this._accessibleDiffViewerShouldBeVisible = rt(this, !1), this._accessibleDiffViewerVisible = Pe(this, (S) => this._options.onlyShowAccessibleDiffViewer.read(S) ? !0 : this._accessibleDiffViewerShouldBeVisible.read(S)), this._movedBlocksLinesPart = rt(this, void 0), this._layoutInfo = Pe(this, (S) => {
      var y, k, E, N, F;
      const V = this._rootSizeObserver.width.read(S), Z = this._rootSizeObserver.height.read(S);
      this._rootSizeObserver.automaticLayout ? this.elements.root.style.height = "100%" : this.elements.root.style.height = Z + "px";
      const H = this._sash.read(S), re = this._gutter.read(S), ue = (y = re == null ? void 0 : re.width.read(S)) !== null && y !== void 0 ? y : 0, Ve = (E = (k = this._overviewRulerPart.read(S)) === null || k === void 0 ? void 0 : k.width) !== null && E !== void 0 ? E : 0;
      let Ye, ze, pe, $e, Be;
      if (!!H) {
        const ce = H.sashLeft.read(S), Fi = (F = (N = this._movedBlocksLinesPart.read(S)) === null || N === void 0 ? void 0 : N.width.read(S)) !== null && F !== void 0 ? F : 0;
        Ye = 0, ze = ce - ue - Fi, Be = ce - ue, pe = ce, $e = V - pe - Ve;
      } else
        Be = 0, Ye = ue, ze = Math.max(5, this._editors.original.getLayoutInfo().decorationsLeft), pe = ue + ze, $e = V - pe - Ve;
      return this.elements.original.style.left = Ye + "px", this.elements.original.style.width = ze + "px", this._editors.original.layout({ width: ze, height: Z }, !0), re == null || re.layout(Be), this.elements.modified.style.left = pe + "px", this.elements.modified.style.width = $e + "px", this._editors.modified.layout({ width: $e, height: Z }, !0), {
        modifiedEditor: this._editors.modified.getLayoutInfo(),
        originalEditor: this._editors.original.getLayoutInfo()
      };
    }), this._diffValue = this._diffModel.map((S, y) => S == null ? void 0 : S.diff.read(y)), this.onDidUpdateDiff = ne.fromObservableLight(this._diffValue), o.willCreateDiffEditor(), this._contextKeyService.createKey("isInDiffEditor", !0), this._domElement.appendChild(this.elements.root), this._register(Se(() => this._domElement.removeChild(this.elements.root))), this._rootSizeObserver = this._register(new x3(this.elements.root, t.dimension)), this._rootSizeObserver.setAutomaticLayout((d = t.automaticLayout) !== null && d !== void 0 ? d : !1), this._options = this._instantiationService.createInstance(KE, t), this._register(qe((S) => {
      this._options.setWidth(this._rootSizeObserver.width.read(S));
    })), this._contextKeyService.createKey(x.isEmbeddedDiffEditor.key, !1), this._register(Cl(x.isEmbeddedDiffEditor, this._contextKeyService, (S) => this._options.isInEmbeddedEditor.read(S))), this._register(Cl(x.comparingMovedCode, this._contextKeyService, (S) => {
      var y;
      return !!(!((y = this._diffModel.read(S)) === null || y === void 0) && y.movedTextToCompare.read(S));
    })), this._register(Cl(x.diffEditorRenderSideBySideInlineBreakpointReached, this._contextKeyService, (S) => this._options.couldShowInlineViewBecauseOfSize.read(S))), this._register(Cl(x.diffEditorInlineMode, this._contextKeyService, (S) => !this._options.renderSideBySide.read(S))), this._register(Cl(x.hasChanges, this._contextKeyService, (S) => {
      var y, k, E;
      return ((E = (k = (y = this._diffModel.read(S)) === null || y === void 0 ? void 0 : y.diff.read(S)) === null || k === void 0 ? void 0 : k.mappings.length) !== null && E !== void 0 ? E : 0) > 0;
    })), this._editors = this._register(this._instantiationService.createInstance($E, this.elements.original, this.elements.modified, this._options, i, (S, y, k, E) => this._createInnerEditor(S, y, k, E))), this._register(Cl(x.diffEditorOriginalWritable, this._contextKeyService, (S) => this._options.originalEditable.read(S))), this._register(Cl(x.diffEditorModifiedWritable, this._contextKeyService, (S) => !this._options.readOnly.read(S))), this._register(Cl(x.diffEditorOriginalUri, this._contextKeyService, (S) => {
      var y, k;
      return (k = (y = this._diffModel.read(S)) === null || y === void 0 ? void 0 : y.model.original.uri.toString()) !== null && k !== void 0 ? k : "";
    })), this._register(Cl(x.diffEditorModifiedUri, this._contextKeyService, (S) => {
      var y, k;
      return (k = (y = this._diffModel.read(S)) === null || y === void 0 ? void 0 : y.model.modified.uri.toString()) !== null && k !== void 0 ? k : "";
    })), this._overviewRulerPart = Da(this, (S) => this._options.renderOverviewRuler.read(S) ? this._instantiationService.createInstance(er(Tu, S), this._editors, this.elements.root, this._diffModel, this._rootSizeObserver.width, this._rootSizeObserver.height, this._layoutInfo.map((y) => y.modifiedEditor)) : void 0).recomputeInitiallyAndOnChange(this._store);
    const c = {
      height: this._rootSizeObserver.height,
      width: this._rootSizeObserver.width.map((S, y) => {
        var k, E;
        return S - ((E = (k = this._overviewRulerPart.read(y)) === null || k === void 0 ? void 0 : k.width) !== null && E !== void 0 ? E : 0);
      })
    };
    this._sashLayout = new wre(this._options, c), this._sash = Da(this, (S) => {
      const y = this._options.renderSideBySide.read(S);
      return this.elements.root.classList.toggle("side-by-side", y), y ? new T3(this.elements.root, c, this._options.enableSplitViewResizing, this._boundarySashes, this._sashLayout.sashLeft, () => this._sashLayout.resetSash()) : void 0;
    }).recomputeInitiallyAndOnChange(this._store);
    const h = Da(this, (S) => (
      /** @description UnchangedRangesFeature */
      this._instantiationService.createInstance(er(Lv, S), this._editors, this._diffModel, this._options)
    )).recomputeInitiallyAndOnChange(this._store);
    Da(this, (S) => (
      /** @description DiffEditorDecorations */
      this._instantiationService.createInstance(er(Cre, S), this._editors, this._diffModel, this._options, this)
    )).recomputeInitiallyAndOnChange(this._store);
    const u = /* @__PURE__ */ new Set(), g = /* @__PURE__ */ new Set();
    let f = !1;
    const m = Da(this, (S) => (
      /** @description ViewZoneManager */
      this._instantiationService.createInstance(er(HE, S), we(this._domElement), this._editors, this._diffModel, this._options, this, () => f || h.get().isUpdatingHiddenAreas, u, g)
    )).recomputeInitiallyAndOnChange(this._store), _ = Pe(this, (S) => {
      const y = m.read(S).viewZones.read(S).orig, k = h.read(S).viewZones.read(S).origViewZones;
      return y.concat(k);
    }), v = Pe(this, (S) => {
      const y = m.read(S).viewZones.read(S).mod, k = h.read(S).viewZones.read(S).modViewZones;
      return y.concat(k);
    });
    this._register(wy(this._editors.original, _, (S) => {
      f = S;
    }, u));
    let b;
    this._register(wy(this._editors.modified, v, (S) => {
      f = S, f ? b = sa.capture(this._editors.modified) : (b == null || b.restore(this._editors.modified), b = void 0);
    }, g)), this._accessibleDiffViewer = Da(this, (S) => this._instantiationService.createInstance(er(lc, S), this.elements.accessibleDiffViewer, this._accessibleDiffViewerVisible, (y, k) => this._accessibleDiffViewerShouldBeVisible.set(y, k), this._options.onlyShowAccessibleDiffViewer.map((y) => !y), this._rootSizeObserver.width, this._rootSizeObserver.height, this._diffModel.map((y, k) => {
      var E;
      return (E = y == null ? void 0 : y.diff.read(k)) === null || E === void 0 ? void 0 : E.mappings.map((N) => N.lineRangeMapping);
    }), new fre(this._editors))).recomputeInitiallyAndOnChange(this._store);
    const C = this._accessibleDiffViewerVisible.map((S) => S ? "hidden" : "visible");
    this._register(Vc(this.elements.modified, { visibility: C })), this._register(Vc(this.elements.original, { visibility: C })), this._createDiffEditorContributions(), o.addDiffEditor(this), this._gutter = Da(this, (S) => this._options.shouldRenderGutterMenu.read(S) ? this._instantiationService.createInstance(er(VE, S), this.elements.root, this._diffModel, this._editors, this._options, this._sashLayout, this._boundarySashes) : void 0), this._register(xb(this._layoutInfo)), Da(this, (S) => (
      /** @description MovedBlocksLinesPart */
      new (er(wc, S))(this.elements.root, this._diffModel, this._layoutInfo.map((y) => y.originalEditor), this._layoutInfo.map((y) => y.modifiedEditor), this._editors)
    )).recomputeInitiallyAndOnChange(this._store, (S) => {
      this._movedBlocksLinesPart.set(S, void 0);
    }), this._register(ne.runAndSubscribe(this._editors.modified.onDidChangeCursorPosition, (S) => this._handleCursorPositionChange(S, !0))), this._register(ne.runAndSubscribe(this._editors.original.onDidChangeCursorPosition, (S) => this._handleCursorPositionChange(S, !1)));
    const w = this._diffModel.map(this, (S, y) => {
      if (S)
        return S.diff.read(y) === void 0 && !S.isDiffUpToDate.read(y);
    });
    this._register(Wo((S, y) => {
      if (w.read(S) === !0) {
        const k = this._editorProgressService.show(!0, 1e3);
        y.add(Se(() => k.done()));
      }
    })), this._register(Se(() => {
      var S;
      this._shouldDisposeDiffModel && ((S = this._diffModel.get()) === null || S === void 0 || S.dispose());
    })), this._register(Wo((S, y) => {
      y.add(new (er(Fre, S))(this._editors, this._diffModel, this._options, this));
    }));
  }
  _createInnerEditor(e, t, i, n) {
    return e.createInstance(Qf, t, i, n);
  }
  _createDiffEditorContributions() {
    const e = ff.getDiffEditorContributions();
    for (const t of e)
      try {
        this._register(this._instantiationService.createInstance(t.ctor, this));
      } catch (i) {
        He(i);
      }
  }
  get _targetEditor() {
    return this._editors.modified;
  }
  getEditorType() {
    return cb.IDiffEditor;
  }
  layout(e) {
    this._rootSizeObserver.observe(e);
  }
  hasTextFocus() {
    return this._editors.original.hasTextFocus() || this._editors.modified.hasTextFocus();
  }
  saveViewState() {
    var e;
    const t = this._editors.original.saveViewState(), i = this._editors.modified.saveViewState();
    return {
      original: t,
      modified: i,
      modelState: (e = this._diffModel.get()) === null || e === void 0 ? void 0 : e.serializeState()
    };
  }
  restoreViewState(e) {
    var t;
    if (e && e.original && e.modified) {
      const i = e;
      this._editors.original.restoreViewState(i.original), this._editors.modified.restoreViewState(i.modified), i.modelState && ((t = this._diffModel.get()) === null || t === void 0 || t.restoreSerializedState(i.modelState));
    }
  }
  handleInitialized() {
    this._editors.original.handleInitialized(), this._editors.modified.handleInitialized();
  }
  createViewModel(e) {
    return this._instantiationService.createInstance(BE, e, this._options);
  }
  getModel() {
    var e, t;
    return (t = (e = this._diffModel.get()) === null || e === void 0 ? void 0 : e.model) !== null && t !== void 0 ? t : null;
  }
  setModel(e, t) {
    !e && this._diffModel.get() && this._accessibleDiffViewer.get().close();
    const i = e ? "model" in e ? { model: e, shouldDispose: !1 } : { model: this.createViewModel(e), shouldDispose: !0 } : void 0;
    this._diffModel.get() !== (i == null ? void 0 : i.model) && dv(t, (n) => {
      var s;
      Lt.batchEventsGlobally(n, () => {
        this._editors.original.setModel(i ? i.model.model.original : null), this._editors.modified.setModel(i ? i.model.model.modified : null);
      });
      const o = this._diffModel.get(), a = this._shouldDisposeDiffModel;
      this._shouldDisposeDiffModel = (s = i == null ? void 0 : i.shouldDispose) !== null && s !== void 0 ? s : !1, this._diffModel.set(i == null ? void 0 : i.model, n), a && (o == null || o.dispose());
    });
  }
  /**
   * @param changedOptions Only has values for top-level options that have actually changed.
   */
  updateOptions(e) {
    this._options.updateOptions(e);
  }
  getContainerDomNode() {
    return this._domElement;
  }
  getOriginalEditor() {
    return this._editors.original;
  }
  getModifiedEditor() {
    return this._editors.modified;
  }
  /**
   * @deprecated Use `this.getDiffComputationResult().changes2` instead.
   */
  getLineChanges() {
    var e;
    const t = (e = this._diffModel.get()) === null || e === void 0 ? void 0 : e.diff.get();
    return t ? Ure(t) : null;
  }
  revert(e) {
    const t = this._diffModel.get();
    !t || !t.isDiffUpToDate.get() || this._editors.modified.executeEdits("diffEditor", [
      {
        range: e.modified.toExclusiveRange(),
        text: t.model.original.getValueInRange(e.original.toExclusiveRange())
      }
    ]);
  }
  revertRangeMappings(e) {
    const t = this._diffModel.get();
    if (!t || !t.isDiffUpToDate.get())
      return;
    const i = e.map((n) => ({
      range: n.modifiedRange,
      text: t.model.original.getValueInRange(n.originalRange)
    }));
    this._editors.modified.executeEdits("diffEditor", i);
  }
  _goTo(e) {
    this._editors.modified.setPosition(new A(e.lineRangeMapping.modified.startLineNumber, 1)), this._editors.modified.revealRangeInCenter(e.lineRangeMapping.modified.toExclusiveRange());
  }
  goToDiff(e) {
    var t, i, n, s;
    const o = (i = (t = this._diffModel.get()) === null || t === void 0 ? void 0 : t.diff.get()) === null || i === void 0 ? void 0 : i.mappings;
    if (!o || o.length === 0)
      return;
    const a = this._editors.modified.getPosition().lineNumber;
    let l;
    e === "next" ? l = (n = o.find((d) => d.lineRangeMapping.modified.startLineNumber > a)) !== null && n !== void 0 ? n : o[0] : l = (s = N_(o, (d) => d.lineRangeMapping.modified.startLineNumber < a)) !== null && s !== void 0 ? s : o[o.length - 1], this._goTo(l), l.lineRangeMapping.modified.isEmpty ? this._accessibilitySignalService.playSignal(Re.diffLineDeleted, { source: "diffEditor.goToDiff" }) : l.lineRangeMapping.original.isEmpty ? this._accessibilitySignalService.playSignal(Re.diffLineInserted, { source: "diffEditor.goToDiff" }) : l && this._accessibilitySignalService.playSignal(Re.diffLineModified, { source: "diffEditor.goToDiff" });
  }
  revealFirstDiff() {
    const e = this._diffModel.get();
    e && this.waitForDiff().then(() => {
      var t;
      const i = (t = e.diff.get()) === null || t === void 0 ? void 0 : t.mappings;
      !i || i.length === 0 || this._goTo(i[0]);
    });
  }
  accessibleDiffViewerNext() {
    this._accessibleDiffViewer.get().next();
  }
  accessibleDiffViewerPrev() {
    this._accessibleDiffViewer.get().prev();
  }
  async waitForDiff() {
    const e = this._diffModel.get();
    e && await e.waitForDiff();
  }
  mapToOtherSide() {
    var e, t;
    const i = this._editors.modified.hasWidgetFocus(), n = i ? this._editors.modified : this._editors.original, s = i ? this._editors.original : this._editors.modified;
    let o;
    const a = n.getSelection();
    if (a) {
      const l = (t = (e = this._diffModel.get()) === null || e === void 0 ? void 0 : e.diff.get()) === null || t === void 0 ? void 0 : t.mappings.map((d) => i ? d.lineRangeMapping.flip() : d.lineRangeMapping);
      if (l) {
        const d = FF(a.getStartPosition(), l), c = FF(a.getEndPosition(), l);
        o = L.plusRange(d, c);
      }
    }
    return { destination: s, destinationSelection: o };
  }
  switchSide() {
    const { destination: e, destinationSelection: t } = this.mapToOtherSide();
    e.focus(), t && e.setSelection(t);
  }
  exitCompareMove() {
    const e = this._diffModel.get();
    e && e.movedTextToCompare.set(void 0, void 0);
  }
  collapseAllUnchangedRegions() {
    var e;
    const t = (e = this._diffModel.get()) === null || e === void 0 ? void 0 : e.unchangedRegions.get();
    t && Nt((i) => {
      for (const n of t)
        n.collapseAll(i);
    });
  }
  showAllUnchangedRegions() {
    var e;
    const t = (e = this._diffModel.get()) === null || e === void 0 ? void 0 : e.unchangedRegions.get();
    t && Nt((i) => {
      for (const n of t)
        n.showAll(i);
    });
  }
  _handleCursorPositionChange(e, t) {
    var i, n;
    if ((e == null ? void 0 : e.reason) === 3) {
      const s = (n = (i = this._diffModel.get()) === null || i === void 0 ? void 0 : i.diff.get()) === null || n === void 0 ? void 0 : n.mappings.find((o) => t ? o.lineRangeMapping.modified.contains(e.position.lineNumber) : o.lineRangeMapping.original.contains(e.position.lineNumber));
      s != null && s.lineRangeMapping.modified.isEmpty ? this._accessibilitySignalService.playSignal(Re.diffLineDeleted, { source: "diffEditor.cursorPositionChanged" }) : s != null && s.lineRangeMapping.original.isEmpty ? this._accessibilitySignalService.playSignal(Re.diffLineInserted, { source: "diffEditor.cursorPositionChanged" }) : s && this._accessibilitySignalService.playSignal(Re.diffLineModified, { source: "diffEditor.cursorPositionChanged" });
    }
  }
};
ud = zre([
  gm(3, De),
  gm(4, be),
  gm(5, ht),
  gm(6, rh),
  gm(7, sh)
], ud);
function Ure(r) {
  return r.mappings.map((e) => {
    const t = e.lineRangeMapping;
    let i, n, s, o, a = t.innerChanges;
    return t.original.isEmpty ? (i = t.original.startLineNumber - 1, n = 0, a = void 0) : (i = t.original.startLineNumber, n = t.original.endLineNumberExclusive - 1), t.modified.isEmpty ? (s = t.modified.startLineNumber - 1, o = 0, a = void 0) : (s = t.modified.startLineNumber, o = t.modified.endLineNumberExclusive - 1), {
      originalStartLineNumber: i,
      originalEndLineNumber: n,
      modifiedStartLineNumber: s,
      modifiedEndLineNumber: o,
      charChanges: a == null ? void 0 : a.map((l) => ({
        originalStartLineNumber: l.originalRange.startLineNumber,
        originalStartColumn: l.originalRange.startColumn,
        originalEndLineNumber: l.originalRange.endLineNumber,
        originalEndColumn: l.originalRange.endColumn,
        modifiedStartLineNumber: l.modifiedRange.startLineNumber,
        modifiedStartColumn: l.modifiedRange.startColumn,
        modifiedEndLineNumber: l.modifiedRange.endLineNumber,
        modifiedEndColumn: l.modifiedRange.endColumn
      }))
    };
  });
}
var jM = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Wt = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
let $re = 0, eW = !1;
function Kre(r) {
  if (!r) {
    if (eW)
      return;
    eW = !0;
  }
  iG(r || Dt.document.body);
}
let Ly = class extends Qf {
  constructor(e, t, i, n, s, o, a, l, d, c, h, u, g) {
    const f = { ...t };
    f.ariaLabel = f.ariaLabel || KS.editorViewAccessibleLabel, f.ariaLabel = f.ariaLabel + ";" + KS.accessibilityHelpMessage, super(e, f, {}, i, n, s, o, d, c, h, u, g), l instanceof dp ? this._standaloneKeybindingService = l : this._standaloneKeybindingService = null, Kre(f.ariaContainerElement), Kte((m, _) => i.createInstance(Xf, m, _, {})), jte(a);
  }
  addCommand(e, t, i) {
    if (!this._standaloneKeybindingService)
      return console.warn("Cannot add command because the editor is configured with an unrecognized KeybindingService"), null;
    const n = "DYNAMIC_" + ++$re, s = U.deserialize(i);
    return this._standaloneKeybindingService.addDynamicKeybinding(n, e, t, s), n;
  }
  createContextKey(e, t) {
    return this._contextKeyService.createKey(e, t);
  }
  addAction(e) {
    if (typeof e.id != "string" || typeof e.label != "string" || typeof e.run != "function")
      throw new Error("Invalid action descriptor, `id`, `label` and `run` are required properties!");
    if (!this._standaloneKeybindingService)
      return console.warn("Cannot add keybinding because the editor is configured with an unrecognized KeybindingService"), P.None;
    const t = e.id, i = e.label, n = U.and(U.equals("editorId", this.getId()), U.deserialize(e.precondition)), s = e.keybindings, o = U.and(n, U.deserialize(e.keybindingContext)), a = e.contextMenuGroupId || null, l = e.contextMenuOrder || 0, d = (g, ...f) => Promise.resolve(e.run(this, ...f)), c = new q(), h = this.getId() + ":" + t;
    if (c.add(st.registerCommand(h, d)), a) {
      const g = {
        command: {
          id: h,
          title: i
        },
        when: n,
        group: a,
        order: l
      };
      c.add(on.appendMenuItem(D.EditorContext, g));
    }
    if (Array.isArray(s))
      for (const g of s)
        c.add(this._standaloneKeybindingService.addDynamicKeybinding(h, g, d, o));
    const u = new f2(h, i, i, void 0, n, (...g) => Promise.resolve(e.run(this, ...g)), this._contextKeyService);
    return this._actions.set(t, u), c.add(Se(() => {
      this._actions.delete(t);
    })), c;
  }
  _triggerCommand(e, t) {
    if (this._codeEditorService instanceof PS)
      try {
        this._codeEditorService.setActiveCodeEditor(this), super._triggerCommand(e, t);
      } finally {
        this._codeEditorService.setActiveCodeEditor(null);
      }
    else
      super._triggerCommand(e, t);
  }
};
Ly = jM([
  Wt(2, be),
  Wt(3, ht),
  Wt(4, $t),
  Wt(5, De),
  Wt(6, gl),
  Wt(7, _t),
  Wt(8, $i),
  Wt(9, xi),
  Wt(10, qs),
  Wt(11, Ot),
  Wt(12, he)
], Ly);
let jE = class extends Ly {
  constructor(e, t, i, n, s, o, a, l, d, c, h, u, g, f, m, _) {
    const v = { ...t };
    vy(h, v, !1);
    const b = d.registerEditorContainer(e);
    typeof v.theme == "string" && d.setTheme(v.theme), typeof v.autoDetectHighContrast < "u" && d.setAutoDetectHighContrast(!!v.autoDetectHighContrast);
    const C = v.model;
    delete v.model, super(e, v, i, n, s, o, a, l, d, c, u, m, _), this._configurationService = h, this._standaloneThemeService = d, this._register(b);
    let w;
    if (typeof C > "u") {
      const S = f.getLanguageIdByMimeType(v.language) || v.language || go;
      w = F3(g, f, v.value || "", S, void 0), this._ownsModel = !0;
    } else
      w = C, this._ownsModel = !1;
    if (this._attachModel(w), w) {
      const S = {
        oldModelUrl: null,
        newModelUrl: w.uri
      };
      this._onDidChangeModel.fire(S);
    }
  }
  dispose() {
    super.dispose();
  }
  updateOptions(e) {
    vy(this._configurationService, e, !1), typeof e.theme == "string" && this._standaloneThemeService.setTheme(e.theme), typeof e.autoDetectHighContrast < "u" && this._standaloneThemeService.setAutoDetectHighContrast(!!e.autoDetectHighContrast), super.updateOptions(e);
  }
  _postDetachModelCleanup(e) {
    super._postDetachModelCleanup(e), e && this._ownsModel && (e.dispose(), this._ownsModel = !1);
  }
};
jE = jM([
  Wt(2, be),
  Wt(3, ht),
  Wt(4, $t),
  Wt(5, De),
  Wt(6, gl),
  Wt(7, _t),
  Wt(8, wo),
  Wt(9, xi),
  Wt(10, Ge),
  Wt(11, qs),
  Wt(12, ii),
  Wt(13, Jt),
  Wt(14, Ot),
  Wt(15, he)
], jE);
let qE = class extends ud {
  constructor(e, t, i, n, s, o, a, l, d, c, h, u) {
    const g = { ...t };
    vy(l, g, !0);
    const f = o.registerEditorContainer(e);
    typeof g.theme == "string" && o.setTheme(g.theme), typeof g.autoDetectHighContrast < "u" && o.setAutoDetectHighContrast(!!g.autoDetectHighContrast), super(e, g, {}, n, i, s, u, c), this._configurationService = l, this._standaloneThemeService = o, this._register(f);
  }
  dispose() {
    super.dispose();
  }
  updateOptions(e) {
    vy(this._configurationService, e, !0), typeof e.theme == "string" && this._standaloneThemeService.setTheme(e.theme), typeof e.autoDetectHighContrast < "u" && this._standaloneThemeService.setAutoDetectHighContrast(!!e.autoDetectHighContrast), super.updateOptions(e);
  }
  _createInnerEditor(e, t, i) {
    return e.createInstance(Ly, t, i);
  }
  getOriginalEditor() {
    return super.getOriginalEditor();
  }
  getModifiedEditor() {
    return super.getModifiedEditor();
  }
  addCommand(e, t, i) {
    return this.getModifiedEditor().addCommand(e, t, i);
  }
  createContextKey(e, t) {
    return this.getModifiedEditor().createContextKey(e, t);
  }
  addAction(e) {
    return this.getModifiedEditor().addAction(e);
  }
};
qE = jM([
  Wt(2, be),
  Wt(3, De),
  Wt(4, ht),
  Wt(5, wo),
  Wt(6, xi),
  Wt(7, Ge),
  Wt(8, Zs),
  Wt(9, sh),
  Wt(10, Dd),
  Wt(11, rh)
], qE);
function F3(r, e, t, i, n) {
  if (t = t || "", !i) {
    const s = t.indexOf(`
`);
    let o = t;
    return s !== -1 && (o = t.substring(0, s)), tW(r, t, e.createByFilepathOrFirstLine(n || null, o), n);
  }
  return tW(r, t, e.createById(i), n);
}
function tW(r, e, t, i) {
  return r.createModel(e, t, i);
}
var jre = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, qre = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
class Gre {
  constructor(e, t) {
    this.viewModel = e, this.deltaScrollVertical = t;
  }
  getId() {
    return this.viewModel;
  }
}
let Dy = class extends P {
  constructor(e, t, i, n) {
    super(), this._container = e, this._overflowWidgetsDomNode = t, this._workbenchUIElementFactory = i, this._instantiationService = n, this._viewModel = rt(this, void 0), this._collapsed = Pe(this, (o) => {
      var a;
      return (a = this._viewModel.read(o)) === null || a === void 0 ? void 0 : a.collapsed.read(o);
    }), this._editorContentHeight = rt(this, 500), this.contentHeight = Pe(this, (o) => (this._collapsed.read(o) ? 0 : this._editorContentHeight.read(o)) + this._outerEditorHeight), this._modifiedContentWidth = rt(this, 0), this._modifiedWidth = rt(this, 0), this._originalContentWidth = rt(this, 0), this._originalWidth = rt(this, 0), this.maxScroll = Pe(this, (o) => {
      const a = this._modifiedContentWidth.read(o) - this._modifiedWidth.read(o), l = this._originalContentWidth.read(o) - this._originalWidth.read(o);
      return a > l ? { maxScroll: a, width: this._modifiedWidth.read(o) } : { maxScroll: l, width: this._originalWidth.read(o) };
    }), this._elements = ft("div.multiDiffEntry", [
      ft("div.header@header", [
        ft("div.header-content", [
          ft("div.collapse-button@collapseButton"),
          ft("div.file-path", [
            ft("div.title.modified.show-file-icons@primaryPath", []),
            ft("div.status.deleted@status", ["R"]),
            ft("div.title.original.show-file-icons@secondaryPath", [])
          ]),
          ft("div.actions@actions")
        ])
      ]),
      ft("div.editorParent", [
        ft("div.editorContainer@editor")
      ])
    ]), this.editor = this._register(this._instantiationService.createInstance(ud, this._elements.editor, {
      overflowWidgetsDomNode: this._overflowWidgetsDomNode
    }, {})), this.isModifedFocused = iW(this.editor.getModifiedEditor()), this.isOriginalFocused = iW(this.editor.getOriginalEditor()), this.isFocused = Pe(this, (o) => this.isModifedFocused.read(o) || this.isOriginalFocused.read(o)), this._resourceLabel = this._workbenchUIElementFactory.createResourceLabel ? this._register(this._workbenchUIElementFactory.createResourceLabel(this._elements.primaryPath)) : void 0, this._resourceLabel2 = this._workbenchUIElementFactory.createResourceLabel ? this._register(this._workbenchUIElementFactory.createResourceLabel(this._elements.secondaryPath)) : void 0, this._dataStore = new q(), this._headerHeight = 40, this._lastScrollTop = -1, this._isSettingScrollTop = !1;
    const s = new iy(this._elements.collapseButton, {});
    this._register(qe((o) => {
      s.element.className = "", s.icon = this._collapsed.read(o) ? me.chevronRight : me.chevronDown;
    })), this._register(s.onDidClick(() => {
      var o;
      (o = this._viewModel.get()) === null || o === void 0 || o.collapsed.set(!this._collapsed.get(), void 0);
    })), this._register(qe((o) => {
      this._elements.editor.style.display = this._collapsed.read(o) ? "none" : "block";
    })), this._register(this.editor.getModifiedEditor().onDidLayoutChange((o) => {
      const a = this.editor.getModifiedEditor().getLayoutInfo().contentWidth;
      this._modifiedWidth.set(a, void 0);
    })), this._register(this.editor.getOriginalEditor().onDidLayoutChange((o) => {
      const a = this.editor.getOriginalEditor().getLayoutInfo().contentWidth;
      this._originalWidth.set(a, void 0);
    })), this._register(this.editor.onDidContentSizeChange((o) => {
      Hw((a) => {
        this._editorContentHeight.set(o.contentHeight, a), this._modifiedContentWidth.set(this.editor.getModifiedEditor().getContentWidth(), a), this._originalContentWidth.set(this.editor.getOriginalEditor().getContentWidth(), a);
      });
    })), this._register(this.editor.getOriginalEditor().onDidScrollChange((o) => {
      if (this._isSettingScrollTop || !o.scrollTopChanged || !this._data)
        return;
      const a = o.scrollTop - this._lastScrollTop;
      this._data.deltaScrollVertical(a);
    })), this._register(qe((o) => {
      var a;
      const l = (a = this._viewModel.read(o)) === null || a === void 0 ? void 0 : a.isActive.read(o);
      this._elements.root.classList.toggle("active", l);
    })), this._container.appendChild(this._elements.root), this._outerEditorHeight = this._headerHeight, this._register(this._instantiationService.createInstance(yy, this._elements.actions, D.MultiDiffEditorFileToolbar, {
      actionRunner: this._register(new A3(() => {
        var o;
        return (o = this._viewModel.get()) === null || o === void 0 ? void 0 : o.modifiedUri;
      })),
      menuOptions: {
        shouldForwardArgs: !0
      },
      toolbarOptions: { primaryGroup: (o) => o.startsWith("navigation") },
      actionViewItemProvider: (o, a) => Rz(n, o, a)
    }));
  }
  setScrollLeft(e) {
    this._modifiedContentWidth.get() - this._modifiedWidth.get() > this._originalContentWidth.get() - this._originalWidth.get() ? this.editor.getModifiedEditor().setScrollLeft(e) : this.editor.getOriginalEditor().setScrollLeft(e);
  }
  setData(e) {
    this._data = e;
    function t(n) {
      return {
        ...n,
        scrollBeyondLastLine: !1,
        hideUnchangedRegions: {
          enabled: !0
        },
        scrollbar: {
          vertical: "hidden",
          horizontal: "hidden",
          handleMouseWheel: !1,
          useShadows: !1
        },
        renderOverviewRuler: !1,
        fixedOverflowWidgets: !0,
        overviewRulerBorder: !1
      };
    }
    const i = e.viewModel.entry.value;
    i.onOptionsDidChange && this._dataStore.add(i.onOptionsDidChange(() => {
      var n;
      this.editor.updateOptions(t((n = i.options) !== null && n !== void 0 ? n : {}));
    })), Hw((n) => {
      var s, o, a, l;
      (s = this._resourceLabel) === null || s === void 0 || s.setUri((o = e.viewModel.modifiedUri) !== null && o !== void 0 ? o : e.viewModel.originalUri, { strikethrough: e.viewModel.modifiedUri === void 0 });
      let d = !1, c = !1, h = !1, u = "";
      e.viewModel.modifiedUri && e.viewModel.originalUri && e.viewModel.modifiedUri.path !== e.viewModel.originalUri.path ? (u = "R", d = !0) : e.viewModel.modifiedUri ? e.viewModel.originalUri || (u = "A", h = !0) : (u = "D", c = !0), this._elements.status.classList.toggle("renamed", d), this._elements.status.classList.toggle("deleted", c), this._elements.status.classList.toggle("added", h), this._elements.status.innerText = u, (a = this._resourceLabel2) === null || a === void 0 || a.setUri(d ? e.viewModel.originalUri : void 0, { strikethrough: !0 }), this._dataStore.clear(), this._viewModel.set(e.viewModel, n), this.editor.setModel(e.viewModel.diffEditorViewModel, n), this.editor.updateOptions(t((l = i.options) !== null && l !== void 0 ? l : {}));
    });
  }
  render(e, t, i, n) {
    this._elements.root.style.visibility = "visible", this._elements.root.style.top = `${e.start}px`, this._elements.root.style.height = `${e.length}px`, this._elements.root.style.width = `${t}px`, this._elements.root.style.position = "absolute";
    const s = e.length - this._headerHeight, o = Math.max(0, Math.min(n.start - e.start, s));
    this._elements.header.style.transform = `translateY(${o}px)`, Hw((a) => {
      this.editor.layout({
        width: t - 2 * 8 - 2 * 1,
        height: e.length - this._outerEditorHeight
      });
    });
    try {
      this._isSettingScrollTop = !0, this._lastScrollTop = i, this.editor.getOriginalEditor().setScrollTop(i);
    } finally {
      this._isSettingScrollTop = !1;
    }
    this._elements.header.classList.toggle("shadow", o > 0 || i > 0), this._elements.header.classList.toggle("collapsed", o === s);
  }
  hide() {
    this._elements.root.style.top = "-100000px", this._elements.root.style.visibility = "hidden";
  }
};
Dy = jre([
  qre(3, be)
], Dy);
function iW(r) {
  return Lt((e) => {
    const t = new q();
    return t.add(r.onDidFocusEditorWidget(() => e(!0))), t.add(r.onDidBlurEditorWidget(() => e(!1))), t;
  }, () => r.hasTextFocus());
}
class Zre {
  constructor(e) {
    this._create = e, this._unused = /* @__PURE__ */ new Set(), this._used = /* @__PURE__ */ new Set(), this._itemData = /* @__PURE__ */ new Map();
  }
  getUnusedObj(e) {
    var t;
    let i;
    if (this._unused.size === 0)
      i = this._create(e), this._itemData.set(i, e);
    else {
      const n = [...this._unused.values()];
      i = (t = n.find((s) => this._itemData.get(s).getId() === e.getId())) !== null && t !== void 0 ? t : n[0], this._unused.delete(i), this._itemData.set(i, e), i.setData(e);
    }
    return this._used.add(i), {
      object: i,
      dispose: () => {
        this._used.delete(i), this._unused.size > 5 ? i.dispose() : this._unused.add(i);
      }
    };
  }
  dispose() {
    for (const e of this._used)
      e.dispose();
    for (const e of this._unused)
      e.dispose();
    this._used.clear(), this._unused.clear();
  }
}
var Yre = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, nW = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
let GE = class extends P {
  constructor(e, t, i, n, s, o) {
    super(), this._element = e, this._dimension = t, this._viewModel = i, this._workbenchUIElementFactory = n, this._parentContextKeyService = s, this._parentInstantiationService = o, this._scrollableElements = ft("div.scrollContent", [
      ft("div@content", {
        style: {
          overflow: "hidden"
        }
      }),
      ft("div.monaco-editor@overflowWidgetsDomNode", {})
    ]), this._scrollable = this._register(new Mp({
      forceIntegerValues: !1,
      scheduleAtNextAnimationFrame: (l) => Us(we(this._element), l),
      smoothScrollDuration: 100
    })), this._scrollableElement = this._register(new I0(this._scrollableElements.root, {
      vertical: 1,
      horizontal: 1,
      useShadows: !1
    }, this._scrollable)), this._elements = ft("div.monaco-component.multiDiffEditor", {}, [
      ft("div", {}, [this._scrollableElement.getDomNode()]),
      ft("div.placeholder@placeholder", {}, [ft("div", [p("noChangedFiles", "No Changed Files")])])
    ]), this._sizeObserver = this._register(new x3(this._element, void 0)), this._objectPool = this._register(new Zre((l) => {
      const d = this._instantiationService.createInstance(Dy, this._scrollableElements.content, this._scrollableElements.overflowWidgetsDomNode, this._workbenchUIElementFactory);
      return d.setData(l), d;
    })), this.scrollTop = Lt(this._scrollableElement.onScroll, () => (
      /** @description scrollTop */
      this._scrollableElement.getScrollPosition().scrollTop
    )), this.scrollLeft = Lt(this._scrollableElement.onScroll, () => (
      /** @description scrollLeft */
      this._scrollableElement.getScrollPosition().scrollLeft
    )), this._viewItemsInfo = ig(this, (l, d) => {
      const c = this._viewModel.read(l);
      if (!c)
        return { items: [], getItem: (f) => {
          throw new Li();
        } };
      const h = c.items.read(l), u = /* @__PURE__ */ new Map();
      return { items: h.map((f) => {
        var m;
        const _ = d.add(new Qre(f, this._objectPool, this.scrollLeft, (b) => {
          this._scrollableElement.setScrollPosition({ scrollTop: this._scrollableElement.getScrollPosition().scrollTop + b });
        })), v = (m = this._lastDocStates) === null || m === void 0 ? void 0 : m[_.getKey()];
        return v && Nt((b) => {
          _.setViewState(v, b);
        }), u.set(f, _), _;
      }), getItem: (f) => u.get(f) };
    }), this._viewItems = this._viewItemsInfo.map(this, (l) => l.items), this._spaceBetweenPx = 0, this._totalHeight = this._viewItems.map(this, (l, d) => l.reduce((c, h) => c + h.contentHeight.read(d) + this._spaceBetweenPx, 0)), this._contextKeyService = this._register(this._parentContextKeyService.createScoped(this._element)), this._instantiationService = this._register(this._parentInstantiationService.createChild(new Cb([De, this._contextKeyService]))), this._lastDocStates = {}, this._contextKeyService.createKey(x.inMultiDiffEditor.key, !0), this._register(Wo((l, d) => {
      const c = this._viewModel.read(l);
      if (c && c.contextKeys)
        for (const [h, u] of Object.entries(c.contextKeys)) {
          const g = this._contextKeyService.createKey(h, void 0);
          g.set(u), d.add(Se(() => g.reset()));
        }
    }));
    const a = this._parentContextKeyService.createKey(x.multiDiffEditorAllCollapsed.key, !1);
    this._register(qe((l) => {
      const d = this._viewModel.read(l);
      if (d) {
        const c = d.items.read(l).every((h) => h.collapsed.read(l));
        a.set(c);
      }
    })), this._register(qe((l) => {
      const d = this._dimension.read(l);
      this._sizeObserver.observe(d);
    })), this._register(qe((l) => {
      const d = this._viewItems.read(l);
      this._elements.placeholder.classList.toggle("visible", d.length === 0);
    })), this._scrollableElements.content.style.position = "relative", this._register(qe((l) => {
      const d = this._sizeObserver.height.read(l);
      this._scrollableElements.root.style.height = `${d}px`;
      const c = this._totalHeight.read(l);
      this._scrollableElements.content.style.height = `${c}px`;
      const h = this._sizeObserver.width.read(l);
      let u = h;
      const g = this._viewItems.read(l), f = pH(g, cr((m) => m.maxScroll.read(l).maxScroll, Zu));
      if (f) {
        const m = f.maxScroll.read(l);
        u = h + m.maxScroll;
      }
      this._scrollableElement.setScrollDimensions({
        width: h,
        height: d,
        scrollHeight: c,
        scrollWidth: u
      });
    })), e.replaceChildren(this._elements.root), this._register(Se(() => {
      e.replaceChildren();
    })), this._register(this._register(qe((l) => {
      Hw((d) => {
        this.render(l);
      });
    })));
  }
  render(e) {
    const t = this.scrollTop.read(e);
    let i = 0, n = 0, s = 0;
    const o = this._sizeObserver.height.read(e), a = tn.ofStartAndLength(t, o), l = this._sizeObserver.width.read(e);
    for (const d of this._viewItems.read(e)) {
      const c = d.contentHeight.read(e), h = Math.min(c, o), u = tn.ofStartAndLength(n, h), g = tn.ofStartAndLength(s, c);
      if (g.isBefore(a))
        i -= c - h, d.hide();
      else if (g.isAfter(a))
        d.hide();
      else {
        const f = Math.max(0, Math.min(a.start - g.start, c - h));
        i -= f;
        const m = tn.ofStartAndLength(t + i, o);
        d.render(u, f, l, m);
      }
      n += h + this._spaceBetweenPx, s += c + this._spaceBetweenPx;
    }
    this._scrollableElements.content.style.transform = `translateY(${-(t + i)}px)`;
  }
};
GE = Yre([
  nW(4, De),
  nW(5, be)
], GE);
class Qre extends P {
  constructor(e, t, i, n) {
    super(), this.viewModel = e, this._objectPool = t, this._scrollLeft = i, this._deltaScrollVertical = n, this._templateRef = this._register(cv(this, void 0)), this.contentHeight = Pe(this, (s) => {
      var o, a, l;
      return (l = (a = (o = this._templateRef.read(s)) === null || o === void 0 ? void 0 : o.object.contentHeight) === null || a === void 0 ? void 0 : a.read(s)) !== null && l !== void 0 ? l : this.viewModel.lastTemplateData.read(s).contentHeight;
    }), this.maxScroll = Pe(this, (s) => {
      var o, a;
      return (a = (o = this._templateRef.read(s)) === null || o === void 0 ? void 0 : o.object.maxScroll.read(s)) !== null && a !== void 0 ? a : { maxScroll: 0, scrollWidth: 0 };
    }), this.template = Pe(this, (s) => {
      var o;
      return (o = this._templateRef.read(s)) === null || o === void 0 ? void 0 : o.object;
    }), this._isHidden = rt(this, !1), this._isFocused = Pe(this, (s) => {
      var o, a;
      return (a = (o = this.template.read(s)) === null || o === void 0 ? void 0 : o.isFocused.read(s)) !== null && a !== void 0 ? a : !1;
    }), this.viewModel.setIsFocused(this._isFocused, void 0), this._register(qe((s) => {
      var o;
      const a = this._scrollLeft.read(s);
      (o = this._templateRef.read(s)) === null || o === void 0 || o.object.setScrollLeft(a);
    })), this._register(qe((s) => {
      const o = this._templateRef.read(s);
      !o || !this._isHidden.read(s) || o.object.isFocused.read(s) || this._clear();
    }));
  }
  dispose() {
    this._clear(), super.dispose();
  }
  toString() {
    var e;
    return `VirtualViewItem(${(e = this.viewModel.entry.value.modified) === null || e === void 0 ? void 0 : e.uri.toString()})`;
  }
  getKey() {
    return this.viewModel.getKey();
  }
  setViewState(e, t) {
    var i;
    this.viewModel.collapsed.set(e.collapsed, t), this._updateTemplateData(t);
    const n = this.viewModel.lastTemplateData.get(), s = (i = e.selections) === null || i === void 0 ? void 0 : i.map(ge.liftSelection);
    this.viewModel.lastTemplateData.set({
      ...n,
      selections: s
    }, t);
    const o = this._templateRef.get();
    o && s && o.object.editor.setSelections(s);
  }
  _updateTemplateData(e) {
    var t;
    const i = this._templateRef.get();
    i && this.viewModel.lastTemplateData.set({
      contentHeight: i.object.contentHeight.get(),
      selections: (t = i.object.editor.getSelections()) !== null && t !== void 0 ? t : void 0
    }, e);
  }
  _clear() {
    const e = this._templateRef.get();
    e && Nt((t) => {
      this._updateTemplateData(t), e.object.hide(), this._templateRef.set(void 0, t);
    });
  }
  hide() {
    this._isHidden.set(!0, void 0);
  }
  render(e, t, i, n) {
    this._isHidden.set(!1, void 0);
    let s = this._templateRef.get();
    if (!s) {
      s = this._objectPool.getUnusedObj(new Gre(this.viewModel, this._deltaScrollVertical)), this._templateRef.set(s, void 0);
      const o = this.viewModel.lastTemplateData.get().selections;
      o && s.object.editor.setSelections(o);
    }
    s.object.render(e, i, t, n);
  }
}
I("multiDiffEditor.headerBackground", { dark: "#262626", light: "tab.inactiveBackground", hcDark: "tab.inactiveBackground", hcLight: "tab.inactiveBackground" }, p("multiDiffEditor.headerBackground", "The background color of the diff editor's header"));
I("multiDiffEditor.background", { dark: "editorBackground", light: "editorBackground", hcDark: "editorBackground", hcLight: "editorBackground" }, p("multiDiffEditor.background", "The background color of the multi file diff editor"));
I("multiDiffEditor.border", { dark: "sideBarSectionHeader.border", light: "#cccccc", hcDark: "sideBarSectionHeader.border", hcLight: "#cccccc" }, p("multiDiffEditor.border", "The border color of the multi file diff editor"));
var Xre = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Jre = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
let ZE = class extends P {
  constructor(e, t, i) {
    super(), this._element = e, this._workbenchUIElementFactory = t, this._instantiationService = i, this._dimension = rt(this, void 0), this._viewModel = rt(this, void 0), this._widgetImpl = ig(this, (n, s) => (er(Dy, n), s.add(this._instantiationService.createInstance(er(GE, n), this._element, this._dimension, this._viewModel, this._workbenchUIElementFactory)))), this._register(xb(this._widgetImpl));
  }
};
ZE = Xre([
  Jre(2, be)
], ZE);
function eae(r, e, t) {
  return xe.initialize(t || {}).createInstance(jE, r, e);
}
function tae(r) {
  return xe.get(ht).onCodeEditorAdd((t) => {
    r(t);
  });
}
function iae(r) {
  return xe.get(ht).onDiffEditorAdd((t) => {
    r(t);
  });
}
function nae() {
  return xe.get(ht).listCodeEditors();
}
function sae() {
  return xe.get(ht).listDiffEditors();
}
function oae(r, e, t) {
  return xe.initialize(t || {}).createInstance(qE, r, e);
}
function rae(r, e) {
  const t = xe.initialize(e || {});
  return new ZE(r, {}, t);
}
function aae(r) {
  if (typeof r.id != "string" || typeof r.run != "function")
    throw new Error("Invalid command descriptor, `id` and `run` are required properties!");
  return st.registerCommand(r.id, r.run);
}
function lae(r) {
  if (typeof r.id != "string" || typeof r.label != "string" || typeof r.run != "function")
    throw new Error("Invalid action descriptor, `id`, `label` and `run` are required properties!");
  const e = U.deserialize(r.precondition), t = (n, ...s) => Ui.runEditorCommand(n, s, e, (o, a, l) => Promise.resolve(r.run(a, ...l))), i = new q();
  if (i.add(st.registerCommand(r.id, t)), r.contextMenuGroupId) {
    const n = {
      command: {
        id: r.id,
        title: r.label
      },
      when: e,
      group: r.contextMenuGroupId,
      order: r.contextMenuOrder || 0
    };
    i.add(on.appendMenuItem(D.EditorContext, n));
  }
  if (Array.isArray(r.keybindings)) {
    const n = xe.get(_t);
    if (!(n instanceof dp))
      console.warn("Cannot add keybinding because the editor is configured with an unrecognized KeybindingService");
    else {
      const s = U.and(e, U.deserialize(r.keybindingContext));
      i.add(n.addDynamicKeybindings(r.keybindings.map((o) => ({
        keybinding: o,
        command: r.id,
        when: s
      }))));
    }
  }
  return i;
}
function dae(r) {
  return W3([r]);
}
function W3(r) {
  const e = xe.get(_t);
  return e instanceof dp ? e.addDynamicKeybindings(r.map((t) => ({
    keybinding: t.keybinding,
    command: t.command,
    commandArgs: t.commandArgs,
    when: U.deserialize(t.when)
  }))) : (console.warn("Cannot add keybinding because the editor is configured with an unrecognized KeybindingService"), P.None);
}
function cae(r, e, t) {
  const i = xe.get(Jt), n = i.getLanguageIdByMimeType(e) || e;
  return F3(xe.get(ii), i, r, n, t);
}
function hae(r, e) {
  const t = xe.get(Jt), i = t.getLanguageIdByMimeType(e) || e || go;
  r.setLanguage(t.createById(i));
}
function uae(r, e, t) {
  r && xe.get(fl).changeOne(e, r.uri, t);
}
function gae(r) {
  xe.get(fl).changeAll(r, []);
}
function fae(r) {
  return xe.get(fl).read(r);
}
function pae(r) {
  return xe.get(fl).onMarkerChanged(r);
}
function mae(r) {
  return xe.get(ii).getModel(r);
}
function _ae() {
  return xe.get(ii).getModels();
}
function vae(r) {
  return xe.get(ii).onModelAdded(r);
}
function bae(r) {
  return xe.get(ii).onModelRemoved(r);
}
function Cae(r) {
  return xe.get(ii).onModelLanguageChanged((t) => {
    r({
      model: t.model,
      oldLanguage: t.oldLanguageId
    });
  });
}
function wae(r) {
  return Iq(xe.get(ii), xe.get(Ot), r);
}
function Sae(r, e) {
  const t = xe.get(Jt), i = xe.get(wo);
  return m1.colorizeElement(i, t, r, e).then(() => {
    i.registerEditorContainer(r);
  });
}
function yae(r, e, t) {
  const i = xe.get(Jt);
  return xe.get(wo).registerEditorContainer(Dt.document.body), m1.colorize(i, r, e, t);
}
function Lae(r, e, t = 4) {
  return xe.get(wo).registerEditorContainer(Dt.document.body), m1.colorizeModelLine(r, e, t);
}
function Dae(r) {
  const e = ri.get(r);
  return e || {
    getInitialState: () => zf,
    tokenize: (t, i, n) => g1(r, n)
  };
}
function kae(r, e) {
  ri.getOrCreate(e);
  const t = Dae(e), i = vd(r), n = [];
  let s = t.getInitialState();
  for (let o = 0, a = i.length; o < a; o++) {
    const l = i[o], d = t.tokenize(l, !0, s);
    n[o] = d.tokens, s = d.endState;
  }
  return n;
}
function xae(r, e) {
  xe.get(wo).defineTheme(r, e);
}
function Iae(r) {
  xe.get(wo).setTheme(r);
}
function Eae() {
  Nx.clearAllFontInfos();
}
function Tae(r, e) {
  return st.registerCommand({ id: r, handler: e });
}
function Nae(r) {
  return xe.get(Ys).registerOpener({
    async open(t) {
      return typeof t == "string" && (t = Ee.parse(t)), r.open(t);
    }
  });
}
function Mae(r) {
  return xe.get(ht).registerCodeEditorOpenHandler(async (t, i, n) => {
    var s;
    if (!i)
      return null;
    const o = (s = t.options) === null || s === void 0 ? void 0 : s.selection;
    let a;
    return o && typeof o.endLineNumber == "number" && typeof o.endColumn == "number" ? a = o : o && (a = { lineNumber: o.startLineNumber, column: o.startColumn }), await r.openCodeEditor(i, t.resource, a) ? i : null;
  });
}
function Rae() {
  return {
    // methods
    create: eae,
    getEditors: nae,
    getDiffEditors: sae,
    onDidCreateEditor: tae,
    onDidCreateDiffEditor: iae,
    createDiffEditor: oae,
    addCommand: aae,
    addEditorAction: lae,
    addKeybindingRule: dae,
    addKeybindingRules: W3,
    createModel: cae,
    setModelLanguage: hae,
    setModelMarkers: uae,
    getModelMarkers: fae,
    removeAllMarkers: gae,
    onDidChangeMarkers: pae,
    getModels: _ae,
    getModel: mae,
    onDidCreateModel: vae,
    onWillDisposeModel: bae,
    onDidChangeModelLanguage: Cae,
    createWebWorker: wae,
    colorizeElement: Sae,
    colorize: yae,
    colorizeModelLine: Lae,
    tokenize: kae,
    defineTheme: xae,
    setTheme: Iae,
    remeasureFonts: Eae,
    registerCommand: Tae,
    registerLinkOpener: Nae,
    registerEditorOpener: Mae,
    // enums
    AccessibilitySupport: eK,
    ContentWidgetPositionPreference: tK,
    CursorChangeReason: iK,
    DefaultEndOfLine: nK,
    EditorAutoIndentStrategy: sK,
    EditorOption: oK,
    EndOfLinePreference: rK,
    EndOfLineSequence: aK,
    MinimapPosition: lK,
    MinimapSectionHeaderStyle: dK,
    MouseTargetType: cK,
    OverlayWidgetPositionPreference: hK,
    OverviewRulerLane: uK,
    GlyphMarginLane: gK,
    RenderLineNumbersType: fK,
    RenderMinimap: pK,
    ScrollbarVisibility: mK,
    ScrollType: _K,
    TextEditorCursorBlinkingStyle: vK,
    TextEditorCursorStyle: bK,
    TrackedRangeStickiness: CK,
    WrappingIndent: wK,
    InjectedTextCursorStops: SK,
    PositionAffinity: yK,
    ShowLightbulbIconMode: LK,
    // classes
    ConfigurationChangedEvent: wH,
    BareFontInfo: ou,
    FontInfo: Tx,
    TextModelResolvedOptions: Sw,
    FindMatch: JB,
    ApplyUpdateResult: Qm,
    EditorZoom: xo,
    createMultiFileDiffEditor: rae,
    // vars
    EditorType: cb,
    EditorOptions: oa
  };
}
function Aae(r, e) {
  if (!e || !Array.isArray(e))
    return !1;
  for (const t of e)
    if (!r(t))
      return !1;
  return !0;
}
function jC(r, e) {
  return typeof r == "boolean" ? r : e;
}
function sW(r, e) {
  return typeof r == "string" ? r : e;
}
function Pae(r) {
  const e = {};
  for (const t of r)
    e[t] = !0;
  return e;
}
function oW(r, e = !1) {
  e && (r = r.map(function(i) {
    return i.toLowerCase();
  }));
  const t = Pae(r);
  return e ? function(i) {
    return t[i.toLowerCase()] !== void 0 && t.hasOwnProperty(i.toLowerCase());
  } : function(i) {
    return t[i] !== void 0 && t.hasOwnProperty(i);
  };
}
function YE(r, e, t) {
  e = e.replace(/@@/g, "");
  let i = 0, n;
  do
    n = !1, e = e.replace(/@(\w+)/g, function(o, a) {
      n = !0;
      let l = "";
      if (typeof r[a] == "string")
        l = r[a];
      else if (r[a] && r[a] instanceof RegExp)
        l = r[a].source;
      else
        throw r[a] === void 0 ? jt(r, "language definition does not contain attribute '" + a + "', used at: " + e) : jt(r, "attribute reference '" + a + "' must be a string, used at: " + e);
      return Wh(l) ? "" : "(?:" + l + ")";
    }), i++;
  while (n && i < 5);
  e = e.replace(/\x01/g, "@");
  const s = (r.ignoreCase ? "i" : "") + (r.unicode ? "u" : "");
  if (t && e.match(/\$[sS](\d\d?)/g)) {
    let a = null, l = null;
    return (d) => (l && a === d || (a = d, l = new RegExp(Gq(r, e, d), s)), l);
  }
  return new RegExp(e, s);
}
function Oae(r, e, t, i) {
  if (i < 0)
    return r;
  if (i < e.length)
    return e[i];
  if (i >= 100) {
    i = i - 100;
    const n = t.split(".");
    if (n.unshift(t), i < n.length)
      return n[i];
  }
  return null;
}
function Fae(r, e, t, i) {
  let n = -1, s = t, o = t.match(/^\$(([sS]?)(\d\d?)|#)(.*)$/);
  o && (o[3] && (n = parseInt(o[3]), o[2] && (n = n + 100)), s = o[4]);
  let a = "~", l = s;
  !s || s.length === 0 ? (a = "!=", l = "") : /^\w*$/.test(l) ? a = "==" : (o = s.match(/^(@|!@|~|!~|==|!=)(.*)$/), o && (a = o[1], l = o[2]));
  let d;
  if ((a === "~" || a === "!~") && /^(\w|\|)*$/.test(l)) {
    const c = oW(l.split("|"), r.ignoreCase);
    d = function(h) {
      return a === "~" ? c(h) : !c(h);
    };
  } else if (a === "@" || a === "!@") {
    const c = r[l];
    if (!c)
      throw jt(r, "the @ match target '" + l + "' is not defined, in rule: " + e);
    if (!Aae(function(u) {
      return typeof u == "string";
    }, c))
      throw jt(r, "the @ match target '" + l + "' must be an array of strings, in rule: " + e);
    const h = oW(c, r.ignoreCase);
    d = function(u) {
      return a === "@" ? h(u) : !h(u);
    };
  } else if (a === "~" || a === "!~")
    if (l.indexOf("$") < 0) {
      const c = YE(r, "^" + l + "$", !1);
      d = function(h) {
        return a === "~" ? c.test(h) : !c.test(h);
      };
    } else
      d = function(c, h, u, g) {
        return YE(r, "^" + Kd(r, l, h, u, g) + "$", !1).test(c);
      };
  else if (l.indexOf("$") < 0) {
    const c = td(r, l);
    d = function(h) {
      return a === "==" ? h === c : h !== c;
    };
  } else {
    const c = td(r, l);
    d = function(h, u, g, f, m) {
      const _ = Kd(r, c, u, g, f);
      return a === "==" ? h === _ : h !== _;
    };
  }
  return n === -1 ? {
    name: t,
    value: i,
    test: function(c, h, u, g) {
      return d(c, c, h, u, g);
    }
  } : {
    name: t,
    value: i,
    test: function(c, h, u, g) {
      const f = Oae(c, h, u, n);
      return d(f || "", c, h, u, g);
    }
  };
}
function QE(r, e, t) {
  if (t) {
    if (typeof t == "string")
      return t;
    if (t.token || t.token === "") {
      if (typeof t.token != "string")
        throw jt(r, "a 'token' attribute must be of type string, in rule: " + e);
      {
        const i = { token: t.token };
        if (t.token.indexOf("$") >= 0 && (i.tokenSubst = !0), typeof t.bracket == "string")
          if (t.bracket === "@open")
            i.bracket = 1;
          else if (t.bracket === "@close")
            i.bracket = -1;
          else
            throw jt(r, "a 'bracket' attribute must be either '@open' or '@close', in rule: " + e);
        if (t.next) {
          if (typeof t.next != "string")
            throw jt(r, "the next state must be a string value in rule: " + e);
          {
            let n = t.next;
            if (!/^(@pop|@push|@popall)$/.test(n) && (n[0] === "@" && (n = n.substr(1)), n.indexOf("$") < 0 && !Zq(r, Kd(r, n, "", [], ""))))
              throw jt(r, "the next state '" + t.next + "' is not defined in rule: " + e);
            i.next = n;
          }
        }
        return typeof t.goBack == "number" && (i.goBack = t.goBack), typeof t.switchTo == "string" && (i.switchTo = t.switchTo), typeof t.log == "string" && (i.log = t.log), typeof t.nextEmbedded == "string" && (i.nextEmbedded = t.nextEmbedded, r.usesEmbedded = !0), i;
      }
    } else if (Array.isArray(t)) {
      const i = [];
      for (let n = 0, s = t.length; n < s; n++)
        i[n] = QE(r, e, t[n]);
      return { group: i };
    } else if (t.cases) {
      const i = [];
      for (const s in t.cases)
        if (t.cases.hasOwnProperty(s)) {
          const o = QE(r, e, t.cases[s]);
          s === "@default" || s === "@" || s === "" ? i.push({ test: void 0, value: o, name: s }) : s === "@eos" ? i.push({ test: function(a, l, d, c) {
            return c;
          }, value: o, name: s }) : i.push(Fae(r, e, s, o));
        }
      const n = r.defaultToken;
      return {
        test: function(s, o, a, l) {
          for (const d of i)
            if (!d.test || d.test(s, o, a, l))
              return d.value;
          return n;
        }
      };
    } else
      throw jt(r, "an action must be a string, an object with a 'token' or 'cases' attribute, or an array of actions; in rule: " + e);
  } else return { token: "" };
}
class Wae {
  constructor(e) {
    this.regex = new RegExp(""), this.action = { token: "" }, this.matchOnlyAtLineStart = !1, this.name = "", this.name = e;
  }
  setRegex(e, t) {
    let i;
    if (typeof t == "string")
      i = t;
    else if (t instanceof RegExp)
      i = t.source;
    else
      throw jt(e, "rules must start with a match string or regular expression: " + this.name);
    this.matchOnlyAtLineStart = i.length > 0 && i[0] === "^", this.name = this.name + ": " + i, this.regex = YE(e, "^(?:" + (this.matchOnlyAtLineStart ? i.substr(1) : i) + ")", !0);
  }
  setAction(e, t) {
    this.action = QE(e, this.name, t);
  }
  resolveRegex(e) {
    return this.regex instanceof RegExp ? this.regex : this.regex(e);
  }
}
function B3(r, e) {
  if (!e || typeof e != "object")
    throw new Error("Monarch: expecting a language definition object");
  const t = {};
  t.languageId = r, t.includeLF = jC(e.includeLF, !1), t.noThrow = !1, t.maxStack = 100, t.start = typeof e.start == "string" ? e.start : null, t.ignoreCase = jC(e.ignoreCase, !1), t.unicode = jC(e.unicode, !1), t.tokenPostfix = sW(e.tokenPostfix, "." + t.languageId), t.defaultToken = sW(e.defaultToken, "source"), t.usesEmbedded = !1;
  const i = e;
  i.languageId = r, i.includeLF = t.includeLF, i.ignoreCase = t.ignoreCase, i.unicode = t.unicode, i.noThrow = t.noThrow, i.usesEmbedded = t.usesEmbedded, i.stateNames = e.tokenizer, i.defaultToken = t.defaultToken;
  function n(o, a, l) {
    for (const d of l) {
      let c = d.include;
      if (c) {
        if (typeof c != "string")
          throw jt(t, "an 'include' attribute must be a string at: " + o);
        if (c[0] === "@" && (c = c.substr(1)), !e.tokenizer[c])
          throw jt(t, "include target '" + c + "' is not defined at: " + o);
        n(o + "." + c, a, e.tokenizer[c]);
      } else {
        const h = new Wae(o);
        if (Array.isArray(d) && d.length >= 1 && d.length <= 3)
          if (h.setRegex(i, d[0]), d.length >= 3)
            if (typeof d[1] == "string")
              h.setAction(i, { token: d[1], next: d[2] });
            else if (typeof d[1] == "object") {
              const u = d[1];
              u.next = d[2], h.setAction(i, u);
            } else
              throw jt(t, "a next state as the last element of a rule can only be given if the action is either an object or a string, at: " + o);
          else
            h.setAction(i, d[1]);
        else {
          if (!d.regex)
            throw jt(t, "a rule must either be an array, or an object with a 'regex' or 'include' field at: " + o);
          d.name && typeof d.name == "string" && (h.name = d.name), d.matchOnlyAtStart && (h.matchOnlyAtLineStart = jC(d.matchOnlyAtLineStart, !1)), h.setRegex(i, d.regex), h.setAction(i, d.action);
        }
        a.push(h);
      }
    }
  }
  if (!e.tokenizer || typeof e.tokenizer != "object")
    throw jt(t, "a language definition must define the 'tokenizer' attribute as an object");
  t.tokenizer = [];
  for (const o in e.tokenizer)
    if (e.tokenizer.hasOwnProperty(o)) {
      t.start || (t.start = o);
      const a = e.tokenizer[o];
      t.tokenizer[o] = new Array(), n("tokenizer." + o, t.tokenizer[o], a);
    }
  if (t.usesEmbedded = i.usesEmbedded, e.brackets) {
    if (!Array.isArray(e.brackets))
      throw jt(t, "the 'brackets' attribute must be defined as an array");
  } else
    e.brackets = [
      { open: "{", close: "}", token: "delimiter.curly" },
      { open: "[", close: "]", token: "delimiter.square" },
      { open: "(", close: ")", token: "delimiter.parenthesis" },
      { open: "<", close: ">", token: "delimiter.angle" }
    ];
  const s = [];
  for (const o of e.brackets) {
    let a = o;
    if (a && Array.isArray(a) && a.length === 3 && (a = { token: a[2], open: a[0], close: a[1] }), a.open === a.close)
      throw jt(t, "open and close brackets in a 'brackets' attribute must be different: " + a.open + `
 hint: use the 'bracket' attribute if matching on equal brackets is required.`);
    if (typeof a.open == "string" && typeof a.token == "string" && typeof a.close == "string")
      s.push({
        token: a.token + t.tokenPostfix,
        open: td(t, a.open),
        close: td(t, a.close)
      });
    else
      throw jt(t, "every element in the 'brackets' array must be a '{open,close,token}' object or array");
  }
  return t.brackets = s, t.noThrow = !0, t;
}
function Bae(r) {
  Vf.registerLanguage(r);
}
function Hae() {
  let r = [];
  return r = r.concat(Vf.getLanguages()), r;
}
function Vae(r) {
  return xe.get(Jt).languageIdCodec.encodeLanguageId(r);
}
function zae(r, e) {
  return xe.withServices(() => {
    const i = xe.get(Jt).onDidRequestRichLanguageFeatures((n) => {
      n === r && (i.dispose(), e());
    });
    return i;
  });
}
function Uae(r, e) {
  return xe.withServices(() => {
    const i = xe.get(Jt).onDidRequestBasicLanguageFeatures((n) => {
      n === r && (i.dispose(), e());
    });
    return i;
  });
}
function $ae(r, e) {
  if (!xe.get(Jt).isRegisteredLanguageId(r))
    throw new Error(`Cannot set configuration for unknown language ${r}`);
  return xe.get(Ot).register(r, e, 100);
}
class Kae {
  constructor(e, t) {
    this._languageId = e, this._actual = t;
  }
  dispose() {
  }
  getInitialState() {
    return this._actual.getInitialState();
  }
  tokenize(e, t, i) {
    if (typeof this._actual.tokenize == "function")
      return kv.adaptTokenize(this._languageId, this._actual, e, i);
    throw new Error("Not supported!");
  }
  tokenizeEncoded(e, t, i) {
    const n = this._actual.tokenizeEncoded(e, i);
    return new Jy(n.tokens, n.endState);
  }
}
class kv {
  constructor(e, t, i, n) {
    this._languageId = e, this._actual = t, this._languageService = i, this._standaloneThemeService = n;
  }
  dispose() {
  }
  getInitialState() {
    return this._actual.getInitialState();
  }
  static _toClassicTokens(e, t) {
    const i = [];
    let n = 0;
    for (let s = 0, o = e.length; s < o; s++) {
      const a = e[s];
      let l = a.startIndex;
      s === 0 ? l = 0 : l < n && (l = n), i[s] = new oS(l, a.scopes, t), n = l;
    }
    return i;
  }
  static adaptTokenize(e, t, i, n) {
    const s = t.tokenize(i, n), o = kv._toClassicTokens(s.tokens, e);
    let a;
    return s.endState.equals(n) ? a = n : a = s.endState, new zN(o, a);
  }
  tokenize(e, t, i) {
    return kv.adaptTokenize(this._languageId, this._actual, e, i);
  }
  _toBinaryTokens(e, t) {
    const i = e.encodeLanguageId(this._languageId), n = this._standaloneThemeService.getColorTheme().tokenTheme, s = [];
    let o = 0, a = 0;
    for (let d = 0, c = t.length; d < c; d++) {
      const h = t[d], u = n.match(i, h.scopes) | 1024;
      if (o > 0 && s[o - 1] === u)
        continue;
      let g = h.startIndex;
      d === 0 ? g = 0 : g < a && (g = a), s[o++] = g, s[o++] = u, a = g;
    }
    const l = new Uint32Array(o);
    for (let d = 0; d < o; d++)
      l[d] = s[d];
    return l;
  }
  tokenizeEncoded(e, t, i) {
    const n = this._actual.tokenize(e, i), s = this._toBinaryTokens(this._languageService.languageIdCodec, n.tokens);
    let o;
    return n.endState.equals(i) ? o = i : o = n.endState, new Jy(s, o);
  }
}
function jae(r) {
  return typeof r.getInitialState == "function";
}
function qae(r) {
  return "tokenizeEncoded" in r;
}
function H3(r) {
  return r && typeof r.then == "function";
}
function Gae(r) {
  const e = xe.get(wo);
  if (r) {
    const t = [null];
    for (let i = 1, n = r.length; i < n; i++)
      t[i] = z.fromHex(r[i]);
    e.setColorMapOverride(t);
  } else
    e.setColorMapOverride(null);
}
function V3(r, e) {
  return qae(e) ? new Kae(r, e) : new kv(r, e, xe.get(Jt), xe.get(wo));
}
function qM(r, e) {
  const t = new zK(async () => {
    const i = await Promise.resolve(e.create());
    return i ? jae(i) ? V3(r, i) : new H_(xe.get(Jt), xe.get(wo), r, B3(r, i), xe.get(Ge)) : null;
  });
  return ri.registerFactory(r, t);
}
function Zae(r, e) {
  if (!xe.get(Jt).isRegisteredLanguageId(r))
    throw new Error(`Cannot set tokens provider for unknown language ${r}`);
  return H3(e) ? qM(r, { create: () => e }) : ri.register(r, V3(r, e));
}
function Yae(r, e) {
  const t = (i) => new H_(xe.get(Jt), xe.get(wo), r, B3(r, i), xe.get(Ge));
  return H3(e) ? qM(r, { create: () => e }) : ri.register(r, t(e));
}
function Qae(r, e) {
  return xe.get(he).referenceProvider.register(r, e);
}
function Xae(r, e) {
  return xe.get(he).renameProvider.register(r, e);
}
function Jae(r, e) {
  return xe.get(he).newSymbolNamesProvider.register(r, e);
}
function ele(r, e) {
  return xe.get(he).signatureHelpProvider.register(r, e);
}
function tle(r, e) {
  return xe.get(he).hoverProvider.register(r, {
    provideHover: async (i, n, s, o) => {
      const a = i.getWordAtPosition(n);
      return Promise.resolve(e.provideHover(i, n, s, o)).then((l) => {
        if (l)
          return !l.range && a && (l.range = new L(n.lineNumber, a.startColumn, n.lineNumber, a.endColumn)), l.range || (l.range = new L(n.lineNumber, n.column, n.lineNumber, n.column)), l;
      });
    }
  });
}
function ile(r, e) {
  return xe.get(he).documentSymbolProvider.register(r, e);
}
function nle(r, e) {
  return xe.get(he).documentHighlightProvider.register(r, e);
}
function sle(r, e) {
  return xe.get(he).linkedEditingRangeProvider.register(r, e);
}
function ole(r, e) {
  return xe.get(he).definitionProvider.register(r, e);
}
function rle(r, e) {
  return xe.get(he).implementationProvider.register(r, e);
}
function ale(r, e) {
  return xe.get(he).typeDefinitionProvider.register(r, e);
}
function lle(r, e) {
  return xe.get(he).codeLensProvider.register(r, e);
}
function dle(r, e, t) {
  return xe.get(he).codeActionProvider.register(r, {
    providedCodeActionKinds: t == null ? void 0 : t.providedCodeActionKinds,
    documentation: t == null ? void 0 : t.documentation,
    provideCodeActions: (n, s, o, a) => {
      const d = xe.get(fl).read({ resource: n.uri }).filter((c) => L.areIntersectingOrTouching(c, s));
      return e.provideCodeActions(n, s, { markers: d, only: o.only, trigger: o.trigger }, a);
    },
    resolveCodeAction: e.resolveCodeAction
  });
}
function cle(r, e) {
  return xe.get(he).documentFormattingEditProvider.register(r, e);
}
function hle(r, e) {
  return xe.get(he).documentRangeFormattingEditProvider.register(r, e);
}
function ule(r, e) {
  return xe.get(he).onTypeFormattingEditProvider.register(r, e);
}
function gle(r, e) {
  return xe.get(he).linkProvider.register(r, e);
}
function fle(r, e) {
  return xe.get(he).completionProvider.register(r, e);
}
function ple(r, e) {
  return xe.get(he).colorProvider.register(r, e);
}
function mle(r, e) {
  return xe.get(he).foldingRangeProvider.register(r, e);
}
function _le(r, e) {
  return xe.get(he).declarationProvider.register(r, e);
}
function vle(r, e) {
  return xe.get(he).selectionRangeProvider.register(r, e);
}
function ble(r, e) {
  return xe.get(he).documentSemanticTokensProvider.register(r, e);
}
function Cle(r, e) {
  return xe.get(he).documentRangeSemanticTokensProvider.register(r, e);
}
function wle(r, e) {
  return xe.get(he).inlineCompletionsProvider.register(r, e);
}
function Sle(r, e) {
  return xe.get(he).inlineEditProvider.register(r, e);
}
function yle(r, e) {
  return xe.get(he).inlayHintsProvider.register(r, e);
}
function Lle() {
  return {
    register: Bae,
    getLanguages: Hae,
    onLanguage: zae,
    onLanguageEncountered: Uae,
    getEncodedLanguageId: Vae,
    // provider methods
    setLanguageConfiguration: $ae,
    setColorMap: Gae,
    registerTokensProviderFactory: qM,
    setTokensProvider: Zae,
    setMonarchTokensProvider: Yae,
    registerReferenceProvider: Qae,
    registerRenameProvider: Xae,
    registerNewSymbolNameProvider: Jae,
    registerCompletionItemProvider: fle,
    registerSignatureHelpProvider: ele,
    registerHoverProvider: tle,
    registerDocumentSymbolProvider: ile,
    registerDocumentHighlightProvider: nle,
    registerLinkedEditingRangeProvider: sle,
    registerDefinitionProvider: ole,
    registerImplementationProvider: rle,
    registerTypeDefinitionProvider: ale,
    registerCodeLensProvider: lle,
    registerCodeActionProvider: dle,
    registerDocumentFormattingEditProvider: cle,
    registerDocumentRangeFormattingEditProvider: hle,
    registerOnTypeFormattingEditProvider: ule,
    registerLinkProvider: gle,
    registerColorProvider: ple,
    registerFoldingRangeProvider: mle,
    registerDeclarationProvider: _le,
    registerSelectionRangeProvider: vle,
    registerDocumentSemanticTokensProvider: ble,
    registerDocumentRangeSemanticTokensProvider: Cle,
    registerInlineCompletionsProvider: wle,
    registerInlineEditProvider: Sle,
    registerInlayHintsProvider: yle,
    // enums
    DocumentHighlightKind: DK,
    CompletionItemKind: kK,
    CompletionItemTag: xK,
    CompletionItemInsertTextRule: IK,
    SymbolKind: EK,
    SymbolTag: TK,
    IndentAction: NK,
    CompletionTriggerKind: MK,
    SignatureHelpTriggerKind: RK,
    InlayHintKind: AK,
    InlineCompletionTriggerKind: PK,
    InlineEditTriggerKind: OK,
    CodeActionTriggerType: FK,
    NewSymbolNameTag: WK,
    NewSymbolNameTriggerKind: BK,
    PartialAcceptTriggerKind: HK,
    HoverVerbosityAction: VK,
    // classes
    FoldingRangeKind: Lp,
    SelectedSuggestionInfo: mH
  };
}
const GM = et("IEditorCancelService"), z3 = new oe("cancellableOperation", !1, p("cancellableOperation", "Whether the editor runs a cancellable operation, e.g. like 'Peek References'"));
ot(
  GM,
  class {
    constructor() {
      this._tokens = /* @__PURE__ */ new WeakMap();
    }
    add(r, e) {
      let t = this._tokens.get(r);
      t || (t = r.invokeWithinContext((n) => {
        const s = z3.bindTo(n.get(De)), o = new Ps();
        return { key: s, tokens: o };
      }), this._tokens.set(r, t));
      let i;
      return t.key.set(!0), i = t.tokens.push(e), () => {
        i && (i(), t.key.set(!t.tokens.isEmpty()), i = void 0);
      };
    }
    cancel(r) {
      const e = this._tokens.get(r);
      if (!e)
        return;
      const t = e.tokens.pop();
      t && (t.cancel(), e.key.set(!e.tokens.isEmpty()));
    }
  },
  1
  /* InstantiationType.Delayed */
);
class Dle extends mi {
  constructor(e, t) {
    super(t), this.editor = e, this._unregister = e.invokeWithinContext((i) => i.get(GM).add(e, this));
  }
  dispose() {
    this._unregister(), super.dispose();
  }
}
se(new class extends Ui {
  constructor() {
    super({
      id: "editor.cancelOperation",
      kbOpts: {
        weight: 100,
        primary: 9
        /* KeyCode.Escape */
      },
      precondition: z3
    });
  }
  runEditorCommand(r, e) {
    r.get(GM).cancel(e);
  }
}());
let U3 = class XE {
  constructor(e, t) {
    if (this.flags = t, this.flags & 1) {
      const i = e.getModel();
      this.modelVersionId = i ? vu("{0}#{1}", i.uri.toString(), i.getVersionId()) : null;
    } else
      this.modelVersionId = null;
    this.flags & 4 ? this.position = e.getPosition() : this.position = null, this.flags & 2 ? this.selection = e.getSelection() : this.selection = null, this.flags & 8 ? (this.scrollLeft = e.getScrollLeft(), this.scrollTop = e.getScrollTop()) : (this.scrollLeft = -1, this.scrollTop = -1);
  }
  _equals(e) {
    if (!(e instanceof XE))
      return !1;
    const t = e;
    return !(this.modelVersionId !== t.modelVersionId || this.scrollLeft !== t.scrollLeft || this.scrollTop !== t.scrollTop || !this.position && t.position || this.position && !t.position || this.position && t.position && !this.position.equals(t.position) || !this.selection && t.selection || this.selection && !t.selection || this.selection && t.selection && !this.selection.equalsRange(t.selection));
  }
  validate(e) {
    return this._equals(new XE(e, this.flags));
  }
};
class zc extends Dle {
  constructor(e, t, i, n) {
    super(e, n), this._listener = new q(), t & 4 && this._listener.add(e.onDidChangeCursorPosition((s) => {
      (!i || !L.containsPosition(i, s.position)) && this.cancel();
    })), t & 2 && this._listener.add(e.onDidChangeCursorSelection((s) => {
      (!i || !L.containsRange(i, s.selection)) && this.cancel();
    })), t & 8 && this._listener.add(e.onDidScrollChange((s) => this.cancel())), t & 1 && (this._listener.add(e.onDidChangeModel((s) => this.cancel())), this._listener.add(e.onDidChangeModelContent((s) => this.cancel())));
  }
  dispose() {
    this._listener.dispose(), super.dispose();
  }
}
class ZM extends mi {
  constructor(e, t) {
    super(t), this._listener = e.onDidChangeContent(() => this.cancel());
  }
  dispose() {
    this._listener.dispose(), super.dispose();
  }
}
function al(r) {
  return r && typeof r.getEditorType == "function" ? r.getEditorType() === cb.ICodeEditor : !1;
}
function YM(r) {
  return r && typeof r.getEditorType == "function" ? r.getEditorType() === cb.IDiffEditor : !1;
}
function kle(r) {
  return !!r && typeof r == "object" && typeof r.onDidChangeActiveEditor == "function";
}
function $3(r) {
  return al(r) ? r : YM(r) ? r.getModifiedEditor() : kle(r) && al(r.activeCodeEditor) ? r.activeCodeEditor : null;
}
class hp {
  static _handleEolEdits(e, t) {
    let i;
    const n = [];
    for (const s of t)
      typeof s.eol == "number" && (i = s.eol), s.range && typeof s.text == "string" && n.push(s);
    return typeof i == "number" && e.hasModel() && e.getModel().pushEOL(i), n;
  }
  static _isFullModelReplaceEdit(e, t) {
    if (!e.hasModel())
      return !1;
    const i = e.getModel(), n = i.validateRange(t.range);
    return i.getFullModelRange().equalsRange(n);
  }
  static execute(e, t, i) {
    i && e.pushUndoStop();
    const n = sa.capture(e), s = hp._handleEolEdits(e, t);
    s.length === 1 && hp._isFullModelReplaceEdit(e, s[0]) ? e.executeEdits("formatEditsCommand", s.map((o) => ti.replace(L.lift(o.range), o.text))) : e.executeEdits("formatEditsCommand", s.map((o) => ti.replaceMove(L.lift(o.range), o.text))), i && e.pushUndoStop(), n.restoreRelativeVerticalPositionOfCursor(e);
  }
}
class rW {
  constructor(e) {
    this.value = e, this._lower = e.toLowerCase();
  }
  /**
   * Gives the value by which to index (for equality).
   */
  static toKey(e) {
    return typeof e == "string" ? e.toLowerCase() : e._lower;
  }
}
class xle {
  constructor(e) {
    if (this._set = /* @__PURE__ */ new Set(), e)
      for (const t of e)
        this.add(t);
  }
  add(e) {
    this._set.add(rW.toKey(e));
  }
  has(e) {
    return this._set.has(rW.toKey(e));
  }
}
function K3(r, e, t) {
  const i = [], n = new xle(), s = r.ordered(t);
  for (const a of s)
    i.push(a), a.extensionId && n.add(a.extensionId);
  const o = e.ordered(t);
  for (const a of o) {
    if (a.extensionId) {
      if (n.has(a.extensionId))
        continue;
      n.add(a.extensionId);
    }
    i.push({
      displayName: a.displayName,
      extensionId: a.extensionId,
      provideDocumentFormattingEdits(l, d, c) {
        return a.provideDocumentRangeFormattingEdits(l, l.getFullModelRange(), d, c);
      }
    });
  }
  return i;
}
class Nu {
  static setFormatterSelector(e) {
    return { dispose: Nu._selectors.unshift(e) };
  }
  static async select(e, t, i, n) {
    if (e.length === 0)
      return;
    const s = ut.first(Nu._selectors);
    if (s)
      return await s(e, t, i, n);
  }
}
Nu._selectors = new Ps();
async function j3(r, e, t, i, n, s, o) {
  const a = r.get(be), { documentRangeFormattingEditProvider: l } = r.get(he), d = al(e) ? e.getModel() : e, c = l.ordered(d), h = await Nu.select(
    c,
    d,
    i,
    2
    /* FormattingKind.Selection */
  );
  h && (n.report(h), await a.invokeFunction(Ile, h, e, t, s, o));
}
async function Ile(r, e, t, i, n, s) {
  var o, a;
  const l = r.get(Uo), d = r.get(Pn), c = r.get(rh);
  let h, u;
  al(t) ? (h = t.getModel(), u = new zc(t, 5, void 0, n)) : (h = t, u = new ZM(t, n));
  const g = [];
  let f = 0;
  for (const C of YN(i).sort(L.compareRangesUsingStarts))
    f > 0 && L.areIntersectingOrTouching(g[f - 1], C) ? g[f - 1] = L.fromPositions(g[f - 1].getStartPosition(), C.getEndPosition()) : f = g.push(C);
  const m = async (C) => {
    var w, S;
    d.trace("[format][provideDocumentRangeFormattingEdits] (request)", (w = e.extensionId) === null || w === void 0 ? void 0 : w.value, C);
    const y = await e.provideDocumentRangeFormattingEdits(h, C, h.getFormattingOptions(), u.token) || [];
    return d.trace("[format][provideDocumentRangeFormattingEdits] (response)", (S = e.extensionId) === null || S === void 0 ? void 0 : S.value, y), y;
  }, _ = (C, w) => {
    if (!C.length || !w.length)
      return !1;
    const S = C.reduce((y, k) => L.plusRange(y, k.range), C[0].range);
    if (!w.some((y) => L.intersectRanges(S, y.range)))
      return !1;
    for (const y of C)
      for (const k of w)
        if (L.intersectRanges(y.range, k.range))
          return !0;
    return !1;
  }, v = [], b = [];
  try {
    if (typeof e.provideDocumentRangesFormattingEdits == "function") {
      d.trace("[format][provideDocumentRangeFormattingEdits] (request)", (o = e.extensionId) === null || o === void 0 ? void 0 : o.value, g);
      const C = await e.provideDocumentRangesFormattingEdits(h, g, h.getFormattingOptions(), u.token) || [];
      d.trace("[format][provideDocumentRangeFormattingEdits] (response)", (a = e.extensionId) === null || a === void 0 ? void 0 : a.value, C), b.push(C);
    } else {
      for (const C of g) {
        if (u.token.isCancellationRequested)
          return !0;
        b.push(await m(C));
      }
      for (let C = 0; C < g.length; ++C)
        for (let w = C + 1; w < g.length; ++w) {
          if (u.token.isCancellationRequested)
            return !0;
          if (_(b[C], b[w])) {
            const S = L.plusRange(g[C], g[w]), y = await m(S);
            g.splice(w, 1), g.splice(C, 1), g.push(S), b.splice(w, 1), b.splice(C, 1), b.push(y), C = 0, w = 0;
          }
        }
    }
    for (const C of b) {
      if (u.token.isCancellationRequested)
        return !0;
      const w = await l.computeMoreMinimalEdits(h.uri, C);
      w && v.push(...w);
    }
  } finally {
    u.dispose();
  }
  if (v.length === 0)
    return !1;
  if (al(t))
    hp.execute(t, v, !0), t.revealPositionInCenterIfOutsideViewport(
      t.getPosition(),
      1
      /* ScrollType.Immediate */
    );
  else {
    const [{ range: C }] = v, w = new ge(C.startLineNumber, C.startColumn, C.endLineNumber, C.endColumn);
    h.pushEditOperations([w], v.map((S) => ({
      text: S.text,
      range: L.lift(S.range),
      forceMoveMarkers: !0
    })), (S) => {
      for (const { range: y } of S)
        if (L.areIntersectingOrTouching(y, w))
          return [new ge(y.startLineNumber, y.startColumn, y.endLineNumber, y.endColumn)];
      return null;
    });
  }
  return c.playSignal(Re.format, { userGesture: s }), !0;
}
async function Ele(r, e, t, i, n, s) {
  const o = r.get(be), a = r.get(he), l = al(e) ? e.getModel() : e, d = K3(a.documentFormattingEditProvider, a.documentRangeFormattingEditProvider, l), c = await Nu.select(
    d,
    l,
    t,
    1
    /* FormattingKind.File */
  );
  c && (i.report(c), await o.invokeFunction(Tle, c, e, t, n, s));
}
async function Tle(r, e, t, i, n, s) {
  const o = r.get(Uo), a = r.get(rh);
  let l, d;
  al(t) ? (l = t.getModel(), d = new zc(t, 5, void 0, n)) : (l = t, d = new ZM(t, n));
  let c;
  try {
    const h = await e.provideDocumentFormattingEdits(l, l.getFormattingOptions(), d.token);
    if (c = await o.computeMoreMinimalEdits(l.uri, h), d.token.isCancellationRequested)
      return !0;
  } finally {
    d.dispose();
  }
  if (!c || c.length === 0)
    return !1;
  if (al(t))
    hp.execute(
      t,
      c,
      i !== 2
      /* FormattingMode.Silent */
    ), i !== 2 && t.revealPositionInCenterIfOutsideViewport(
      t.getPosition(),
      1
      /* ScrollType.Immediate */
    );
  else {
    const [{ range: h }] = c, u = new ge(h.startLineNumber, h.startColumn, h.endLineNumber, h.endColumn);
    l.pushEditOperations([u], c.map((g) => ({
      text: g.text,
      range: L.lift(g.range),
      forceMoveMarkers: !0
    })), (g) => {
      for (const { range: f } of g)
        if (L.areIntersectingOrTouching(f, u))
          return [new ge(f.startLineNumber, f.startColumn, f.endLineNumber, f.endColumn)];
      return null;
    });
  }
  return a.playSignal(Re.format, { userGesture: s }), !0;
}
async function Nle(r, e, t, i, n, s) {
  const o = e.documentRangeFormattingEditProvider.ordered(t);
  for (const a of o) {
    const l = await Promise.resolve(a.provideDocumentRangeFormattingEdits(t, i, n, s)).catch(_i);
    if (Rn(l))
      return await r.computeMoreMinimalEdits(t.uri, l);
  }
}
async function Mle(r, e, t, i, n) {
  const s = K3(e.documentFormattingEditProvider, e.documentRangeFormattingEditProvider, t);
  for (const o of s) {
    const a = await Promise.resolve(o.provideDocumentFormattingEdits(t, i, n)).catch(_i);
    if (Rn(a))
      return await r.computeMoreMinimalEdits(t.uri, a);
  }
}
function q3(r, e, t, i, n, s, o) {
  const a = e.onTypeFormattingEditProvider.ordered(t);
  return a.length === 0 || a[0].autoFormatTriggerCharacters.indexOf(n) < 0 ? Promise.resolve(void 0) : Promise.resolve(a[0].provideOnTypeFormattingEdits(t, i, n, s, o)).catch(_i).then((l) => r.computeMoreMinimalEdits(t.uri, l));
}
st.registerCommand("_executeFormatRangeProvider", async function(r, ...e) {
  const [t, i, n] = e;
  ct(Ee.isUri(t)), ct(L.isIRange(i));
  const s = r.get(xs), o = r.get(Uo), a = r.get(he), l = await s.createModelReference(t);
  try {
    return Nle(o, a, l.object.textEditorModel, L.lift(i), n, at.None);
  } finally {
    l.dispose();
  }
});
st.registerCommand("_executeFormatDocumentProvider", async function(r, ...e) {
  const [t, i] = e;
  ct(Ee.isUri(t));
  const n = r.get(xs), s = r.get(Uo), o = r.get(he), a = await n.createModelReference(t);
  try {
    return Mle(s, o, a.object.textEditorModel, i, at.None);
  } finally {
    a.dispose();
  }
});
st.registerCommand("_executeFormatOnTypeProvider", async function(r, ...e) {
  const [t, i, n, s] = e;
  ct(Ee.isUri(t)), ct(A.isIPosition(i)), ct(typeof n == "string");
  const o = r.get(xs), a = r.get(Uo), l = r.get(he), d = await o.createModelReference(t);
  try {
    return q3(a, l, d.object.textEditorModel, A.lift(i), n, s, at.None);
  } finally {
    d.dispose();
  }
});
oa.wrappingIndent.defaultValue = 0;
oa.glyphMargin.defaultValue = !1;
oa.autoIndent.defaultValue = 3;
oa.overviewRulerLanes.defaultValue = 2;
Nu.setFormatterSelector((r, e, t) => Promise.resolve(r[0]));
const gs = UK();
gs.editor = Rae();
gs.languages = Lle();
const Rle = gs.CancellationTokenSource, Ale = gs.Emitter, Ple = gs.KeyCode, Ole = gs.KeyMod, Fle = gs.Position, Wle = gs.Range, Ble = gs.Selection, Hle = gs.SelectionDirection, Vle = gs.MarkerSeverity, zle = gs.MarkerTag, Ule = gs.Uri, $le = gs.Token, G3 = gs.editor, Kle = gs.languages, Bk = globalThis.MonacoEnvironment;
(Bk != null && Bk.globalAPI || typeof define == "function" && define.amd) && (globalThis.monaco = gs);
typeof globalThis.require < "u" && typeof globalThis.require.config == "function" && globalThis.require.config({
  ignoreDuplicateModules: [
    "vscode-languageserver-types",
    "vscode-languageserver-types/main",
    "vscode-languageserver-textdocument",
    "vscode-languageserver-textdocument/main",
    "vscode-nls",
    "vscode-nls/vscode-nls",
    "jsonc-parser",
    "jsonc-parser/main",
    "vscode-uri",
    "vscode-uri/index",
    "vs/basic-languages/typescript/typescript"
  ]
});
const Ab = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CancellationTokenSource: Rle,
  Emitter: Ale,
  KeyCode: Ple,
  KeyMod: Ole,
  MarkerSeverity: Vle,
  MarkerTag: zle,
  Position: Fle,
  Range: Wle,
  Selection: Ble,
  SelectionDirection: Hle,
  Token: $le,
  Uri: Ule,
  editor: G3,
  languages: Kle
}, Symbol.toStringTag, { value: "Module" }));
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
var jle = Object.defineProperty, qle = Object.getOwnPropertyDescriptor, Gle = Object.getOwnPropertyNames, Zle = Object.prototype.hasOwnProperty, Yle = (r, e, t, i) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let n of Gle(e))
      !Zle.call(r, n) && n !== t && jle(r, n, { get: () => e[n], enumerable: !(i = qle(e, n)) || i.enumerable });
  return r;
}, Qle = (r, e, t) => (Yle(r, e, "default"), t), Vm = {};
Qle(Vm, Ab);
var Z3 = {}, Hk = {}, Xle = class Y3 {
  static getOrCreate(e) {
    return Hk[e] || (Hk[e] = new Y3(e)), Hk[e];
  }
  constructor(e) {
    this._languageId = e, this._loadingTriggered = !1, this._lazyLoadPromise = new Promise((t, i) => {
      this._lazyLoadPromiseResolve = t, this._lazyLoadPromiseReject = i;
    });
  }
  load() {
    return this._loadingTriggered || (this._loadingTriggered = !0, Z3[this._languageId].loader().then(
      (e) => this._lazyLoadPromiseResolve(e),
      (e) => this._lazyLoadPromiseReject(e)
    )), this._lazyLoadPromise;
  }
};
function Ce(r) {
  const e = r.id;
  Z3[e] = r, Vm.languages.register(r);
  const t = Xle.getOrCreate(e);
  Vm.languages.registerTokensProviderFactory(e, {
    create: async () => (await t.load()).language
  }), Vm.languages.onLanguageEncountered(e, async () => {
    const i = await t.load();
    Vm.languages.setLanguageConfiguration(e, i.conf);
  });
}
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "abap",
  extensions: [".abap"],
  aliases: ["abap", "ABAP"],
  loader: () => import("./abap-Ck4GwL0j.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "apex",
  extensions: [".cls"],
  aliases: ["Apex", "apex"],
  mimetypes: ["text/x-apex-source", "text/x-apex"],
  loader: () => import("./apex-ODA7HKAJ.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "azcli",
  extensions: [".azcli"],
  aliases: ["Azure CLI", "azcli"],
  loader: () => import("./azcli-Cb6cb8s9.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "bat",
  extensions: [".bat", ".cmd"],
  aliases: ["Batch", "bat"],
  loader: () => import("./bat-DTzY2NZq.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "bicep",
  extensions: [".bicep"],
  aliases: ["Bicep"],
  loader: () => import("./bicep-BMFU7f1t.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "cameligo",
  extensions: [".mligo"],
  aliases: ["Cameligo"],
  loader: () => import("./cameligo-NLSSnjLV.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "clojure",
  extensions: [".clj", ".cljs", ".cljc", ".edn"],
  aliases: ["clojure", "Clojure"],
  loader: () => import("./clojure-Du0upEOV.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "coffeescript",
  extensions: [".coffee"],
  aliases: ["CoffeeScript", "coffeescript", "coffee"],
  mimetypes: ["text/x-coffeescript", "text/coffeescript"],
  loader: () => import("./coffee-v4uQlkM7.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "c",
  extensions: [".c", ".h"],
  aliases: ["C", "c"],
  loader: () => import("./cpp-D8cWT5D_.mjs")
});
Ce({
  id: "cpp",
  extensions: [".cpp", ".cc", ".cxx", ".hpp", ".hh", ".hxx"],
  aliases: ["C++", "Cpp", "cpp"],
  loader: () => import("./cpp-D8cWT5D_.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "csharp",
  extensions: [".cs", ".csx", ".cake"],
  aliases: ["C#", "csharp"],
  loader: () => import("./csharp-Czug7i7m.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "csp",
  extensions: [".csp"],
  aliases: ["CSP", "csp"],
  loader: () => import("./csp-C8fx6eO8.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "css",
  extensions: [".css"],
  aliases: ["CSS", "css"],
  mimetypes: ["text/css"],
  loader: () => import("./css-BpNIi06k.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "cypher",
  extensions: [".cypher", ".cyp"],
  aliases: ["Cypher", "OpenCypher"],
  loader: () => import("./cypher-C17znEzs.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "dart",
  extensions: [".dart"],
  aliases: ["Dart", "dart"],
  mimetypes: ["text/x-dart-source", "text/x-dart"],
  loader: () => import("./dart-CYyrqmCr.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "dockerfile",
  extensions: [".dockerfile"],
  filenames: ["Dockerfile"],
  aliases: ["Dockerfile"],
  loader: () => import("./dockerfile-BQUsBUh7.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "ecl",
  extensions: [".ecl"],
  aliases: ["ECL", "Ecl", "ecl"],
  loader: () => import("./ecl-CJB68izO.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "elixir",
  extensions: [".ex", ".exs"],
  aliases: ["Elixir", "elixir", "ex"],
  loader: () => import("./elixir-DljgmHqx.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "flow9",
  extensions: [".flow"],
  aliases: ["Flow9", "Flow", "flow9", "flow"],
  loader: () => import("./flow9-0BfLJTIY.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "fsharp",
  extensions: [".fs", ".fsi", ".ml", ".mli", ".fsx", ".fsscript"],
  aliases: ["F#", "FSharp", "fsharp"],
  loader: () => import("./fsharp-lmsaS1LJ.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "freemarker2",
  extensions: [".ftl", ".ftlh", ".ftlx"],
  aliases: ["FreeMarker2", "Apache FreeMarker2"],
  loader: () => import("./freemarker2-CGNg5g5G.mjs").then((r) => r.TagAutoInterpolationDollar)
});
Ce({
  id: "freemarker2.tag-angle.interpolation-dollar",
  aliases: ["FreeMarker2 (Angle/Dollar)", "Apache FreeMarker2 (Angle/Dollar)"],
  loader: () => import("./freemarker2-CGNg5g5G.mjs").then((r) => r.TagAngleInterpolationDollar)
});
Ce({
  id: "freemarker2.tag-bracket.interpolation-dollar",
  aliases: ["FreeMarker2 (Bracket/Dollar)", "Apache FreeMarker2 (Bracket/Dollar)"],
  loader: () => import("./freemarker2-CGNg5g5G.mjs").then((r) => r.TagBracketInterpolationDollar)
});
Ce({
  id: "freemarker2.tag-angle.interpolation-bracket",
  aliases: ["FreeMarker2 (Angle/Bracket)", "Apache FreeMarker2 (Angle/Bracket)"],
  loader: () => import("./freemarker2-CGNg5g5G.mjs").then((r) => r.TagAngleInterpolationBracket)
});
Ce({
  id: "freemarker2.tag-bracket.interpolation-bracket",
  aliases: ["FreeMarker2 (Bracket/Bracket)", "Apache FreeMarker2 (Bracket/Bracket)"],
  loader: () => import("./freemarker2-CGNg5g5G.mjs").then((r) => r.TagBracketInterpolationBracket)
});
Ce({
  id: "freemarker2.tag-auto.interpolation-dollar",
  aliases: ["FreeMarker2 (Auto/Dollar)", "Apache FreeMarker2 (Auto/Dollar)"],
  loader: () => import("./freemarker2-CGNg5g5G.mjs").then((r) => r.TagAutoInterpolationDollar)
});
Ce({
  id: "freemarker2.tag-auto.interpolation-bracket",
  aliases: ["FreeMarker2 (Auto/Bracket)", "Apache FreeMarker2 (Auto/Bracket)"],
  loader: () => import("./freemarker2-CGNg5g5G.mjs").then((r) => r.TagAutoInterpolationBracket)
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "go",
  extensions: [".go"],
  aliases: ["Go"],
  loader: () => import("./go-Tv83ayL9.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "graphql",
  extensions: [".graphql", ".gql"],
  aliases: ["GraphQL", "graphql", "gql"],
  mimetypes: ["application/graphql"],
  loader: () => import("./graphql-BH1G4Uv8.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "handlebars",
  extensions: [".handlebars", ".hbs"],
  aliases: ["Handlebars", "handlebars", "hbs"],
  mimetypes: ["text/x-handlebars-template"],
  loader: () => import("./handlebars-1aVmlPIY.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "hcl",
  extensions: [".tf", ".tfvars", ".hcl"],
  aliases: ["Terraform", "tf", "HCL", "hcl"],
  loader: () => import("./hcl-9tXVo0Oo.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "html",
  extensions: [".html", ".htm", ".shtml", ".xhtml", ".mdoc", ".jsp", ".asp", ".aspx", ".jshtm"],
  aliases: ["HTML", "htm", "html", "xhtml"],
  mimetypes: ["text/html", "text/x-jshtm", "text/template", "text/ng-template"],
  loader: () => import("./html-Cm_7QaiO.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "ini",
  extensions: [".ini", ".properties", ".gitconfig"],
  filenames: ["config", ".gitattributes", ".gitconfig", ".editorconfig"],
  aliases: ["Ini", "ini"],
  loader: () => import("./ini-DZX3aW6M.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "java",
  extensions: [".java", ".jav"],
  aliases: ["Java", "java"],
  mimetypes: ["text/x-java-source", "text/x-java"],
  loader: () => import("./java-Q9NjwWso.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "javascript",
  extensions: [".js", ".es6", ".jsx", ".mjs", ".cjs"],
  firstLine: "^#!.*\\bnode",
  filenames: ["jakefile"],
  aliases: ["JavaScript", "javascript", "js"],
  mimetypes: ["text/javascript"],
  loader: () => import("./javascript-0qBHo1rI.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "julia",
  extensions: [".jl"],
  aliases: ["julia", "Julia"],
  loader: () => import("./julia-QQBeypPo.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "kotlin",
  extensions: [".kt", ".kts"],
  aliases: ["Kotlin", "kotlin"],
  mimetypes: ["text/x-kotlin-source", "text/x-kotlin"],
  loader: () => import("./kotlin-2AnhId0p.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "less",
  extensions: [".less"],
  aliases: ["Less", "less"],
  mimetypes: ["text/x-less", "text/less"],
  loader: () => import("./less-Daawp9Qu.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "lexon",
  extensions: [".lex"],
  aliases: ["Lexon"],
  loader: () => import("./lexon-CqxA-4g1.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "lua",
  extensions: [".lua"],
  aliases: ["Lua", "lua"],
  loader: () => import("./lua-C9DR8JqQ.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "liquid",
  extensions: [".liquid", ".html.liquid"],
  aliases: ["Liquid", "liquid"],
  mimetypes: ["application/liquid"],
  loader: () => import("./liquid-ChI7uqbr.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "m3",
  extensions: [".m3", ".i3", ".mg", ".ig"],
  aliases: ["Modula-3", "Modula3", "modula3", "m3"],
  loader: () => import("./m3-ChoO2Aeo.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "markdown",
  extensions: [".md", ".markdown", ".mdown", ".mkdn", ".mkd", ".mdwn", ".mdtxt", ".mdtext"],
  aliases: ["Markdown", "markdown"],
  loader: () => import("./markdown-vGe7N__p.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "mdx",
  extensions: [".mdx"],
  aliases: ["MDX", "mdx"],
  loader: () => import("./mdx-Cgqb5eKD.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "mips",
  extensions: [".s"],
  aliases: ["MIPS", "MIPS-V"],
  mimetypes: ["text/x-mips", "text/mips", "text/plaintext"],
  loader: () => import("./mips-B35Tctk9.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "msdax",
  extensions: [".dax", ".msdax"],
  aliases: ["DAX", "MSDAX"],
  loader: () => import("./msdax-CKduWRE-.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "mysql",
  extensions: [],
  aliases: ["MySQL", "mysql"],
  loader: () => import("./mysql-D4V3ltpC.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "objective-c",
  extensions: [".m"],
  aliases: ["Objective-C"],
  loader: () => import("./objective-c-CaS419yz.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "pascal",
  extensions: [".pas", ".p", ".pp"],
  aliases: ["Pascal", "pas"],
  mimetypes: ["text/x-pascal-source", "text/x-pascal"],
  loader: () => import("./pascal-CzzqMa-q.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "pascaligo",
  extensions: [".ligo"],
  aliases: ["Pascaligo", "ligo"],
  loader: () => import("./pascaligo-DPbJfhBm.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "perl",
  extensions: [".pl", ".pm"],
  aliases: ["Perl", "pl"],
  loader: () => import("./perl-DiakDHGa.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "pgsql",
  extensions: [],
  aliases: ["PostgreSQL", "postgres", "pg", "postgre"],
  loader: () => import("./pgsql-FgzHGfbe.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "php",
  extensions: [".php", ".php4", ".php5", ".phtml", ".ctp"],
  aliases: ["PHP", "php"],
  mimetypes: ["application/x-php"],
  loader: () => import("./php-DeEgUIDo.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "pla",
  extensions: [".pla"],
  loader: () => import("./pla-BtA__bSx.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "postiats",
  extensions: [".dats", ".sats", ".hats"],
  aliases: ["ATS", "ATS/Postiats"],
  loader: () => import("./postiats-CDpKZOjz.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "powerquery",
  extensions: [".pq", ".pqm"],
  aliases: ["PQ", "M", "Power Query", "Power Query M"],
  loader: () => import("./powerquery-C4wMFtve.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "powershell",
  extensions: [".ps1", ".psm1", ".psd1"],
  aliases: ["PowerShell", "powershell", "ps", "ps1"],
  loader: () => import("./powershell-BIXcUAIq.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "proto",
  extensions: [".proto"],
  aliases: ["protobuf", "Protocol Buffers"],
  loader: () => import("./protobuf-BHrBiKx5.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "pug",
  extensions: [".jade", ".pug"],
  aliases: ["Pug", "Jade", "jade"],
  loader: () => import("./pug-D_c6Bxex.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "python",
  extensions: [".py", ".rpy", ".pyw", ".cpy", ".gyp", ".gypi"],
  aliases: ["Python", "py"],
  firstLine: "^#!/.*\\bpython[0-9.-]*\\b",
  loader: () => import("./python-BtIoHI3v.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "qsharp",
  extensions: [".qs"],
  aliases: ["Q#", "qsharp"],
  loader: () => import("./qsharp-Bmp6Uoth.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "r",
  extensions: [".r", ".rhistory", ".rmd", ".rprofile", ".rt"],
  aliases: ["R", "r"],
  loader: () => import("./r-Cw-pZRR6.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "razor",
  extensions: [".cshtml"],
  aliases: ["Razor", "razor"],
  mimetypes: ["text/x-cshtml"],
  loader: () => import("./razor-BRwqTifR.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "redis",
  extensions: [".redis"],
  aliases: ["redis"],
  loader: () => import("./redis-DSkWtKTU.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "redshift",
  extensions: [],
  aliases: ["Redshift", "redshift"],
  loader: () => import("./redshift-G3V-UH7H.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "restructuredtext",
  extensions: [".rst"],
  aliases: ["reStructuredText", "restructuredtext"],
  loader: () => import("./restructuredtext-C3HS0Vuf.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "ruby",
  extensions: [".rb", ".rbx", ".rjs", ".gemspec", ".pp"],
  filenames: ["rakefile", "Gemfile"],
  aliases: ["Ruby", "rb"],
  loader: () => import("./ruby-DdxOY_t-.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "rust",
  extensions: [".rs", ".rlib"],
  aliases: ["Rust", "rust"],
  loader: () => import("./rust-CHLNe-uh.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "sb",
  extensions: [".sb"],
  aliases: ["Small Basic", "sb"],
  loader: () => import("./sb-VgZvRVjv.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "scala",
  extensions: [".scala", ".sc", ".sbt"],
  aliases: ["Scala", "scala", "SBT", "Sbt", "sbt", "Dotty", "dotty"],
  mimetypes: ["text/x-scala-source", "text/x-scala", "text/x-sbt", "text/x-dotty"],
  loader: () => import("./scala-BEo281v6.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "scheme",
  extensions: [".scm", ".ss", ".sch", ".rkt"],
  aliases: ["scheme", "Scheme"],
  loader: () => import("./scheme-BwtlTEx9.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "scss",
  extensions: [".scss"],
  aliases: ["Sass", "sass", "scss"],
  mimetypes: ["text/x-scss", "text/scss"],
  loader: () => import("./scss-DNHJcE5b.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "shell",
  extensions: [".sh", ".bash"],
  aliases: ["Shell", "sh"],
  loader: () => import("./shell-CYXbUHt6.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "sol",
  extensions: [".sol"],
  aliases: ["sol", "solidity", "Solidity"],
  loader: () => import("./solidity-B94td9D0.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "aes",
  extensions: [".aes"],
  aliases: ["aes", "sophia", "Sophia"],
  loader: () => import("./sophia-CgOMMImk.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "sparql",
  extensions: [".rq"],
  aliases: ["sparql", "SPARQL"],
  loader: () => import("./sparql-CmRbqkGW.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "sql",
  extensions: [".sql"],
  aliases: ["SQL"],
  loader: () => import("./sql-DVsVTphc.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "st",
  extensions: [".st", ".iecst", ".iecplc", ".lc3lib", ".TcPOU", ".TcDUT", ".TcGVL", ".TcIO"],
  aliases: ["StructuredText", "scl", "stl"],
  loader: () => import("./st-ATFa4Vu3.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "swift",
  aliases: ["Swift", "swift"],
  extensions: [".swift"],
  mimetypes: ["text/swift"],
  loader: () => import("./swift-K4rp2L0u.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "systemverilog",
  extensions: [".sv", ".svh"],
  aliases: ["SV", "sv", "SystemVerilog", "systemverilog"],
  loader: () => import("./systemverilog-YgLuECrg.mjs")
});
Ce({
  id: "verilog",
  extensions: [".v", ".vh"],
  aliases: ["V", "v", "Verilog", "verilog"],
  loader: () => import("./systemverilog-YgLuECrg.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "tcl",
  extensions: [".tcl"],
  aliases: ["tcl", "Tcl", "tcltk", "TclTk", "tcl/tk", "Tcl/Tk"],
  loader: () => import("./tcl-BHcJGOmo.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "twig",
  extensions: [".twig"],
  aliases: ["Twig", "twig"],
  mimetypes: ["text/x-twig"],
  loader: () => import("./twig-sVb_x968.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "typescript",
  extensions: [".ts", ".tsx", ".cts", ".mts"],
  aliases: ["TypeScript", "ts", "typescript"],
  mimetypes: ["text/typescript"],
  loader: () => import("./typescript-BcuA9j7b.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "typespec",
  extensions: [".tsp"],
  aliases: ["TypeSpec"],
  loader: () => import("./typespec-BSdcQAUL.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "vb",
  extensions: [".vb"],
  aliases: ["Visual Basic", "vb"],
  loader: () => import("./vb-BZywMj6s.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "wgsl",
  extensions: [".wgsl"],
  aliases: ["WebGPU Shading Language", "WGSL", "wgsl"],
  loader: () => import("./wgsl-eG2bS915.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "xml",
  extensions: [
    ".xml",
    ".xsd",
    ".dtd",
    ".ascx",
    ".csproj",
    ".config",
    ".props",
    ".targets",
    ".wxi",
    ".wxl",
    ".wxs",
    ".xaml",
    ".svg",
    ".svgz",
    ".opf",
    ".xslt",
    ".xsl"
  ],
  firstLine: "(\\<\\?xml.*)|(\\<svg)|(\\<\\!doctype\\s+svg)",
  aliases: ["XML", "xml"],
  mimetypes: ["text/xml", "application/xml", "application/xaml+xml", "application/xml-dtd"],
  loader: () => import("./xml-DjY7gsWT.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
Ce({
  id: "yaml",
  extensions: [".yaml", ".yml"],
  aliases: ["YAML", "yaml", "YML", "yml"],
  mimetypes: ["application/x-yaml", "text/x-yaml"],
  loader: () => import("./yaml-VKfm-nWF.mjs")
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
var Jle = Object.defineProperty, ede = Object.getOwnPropertyDescriptor, tde = Object.getOwnPropertyNames, ide = Object.prototype.hasOwnProperty, nde = (r, e, t, i) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let n of tde(e))
      !ide.call(r, n) && n !== t && Jle(r, n, { get: () => e[n], enumerable: !(i = ede(e, n)) || i.enumerable });
  return r;
}, sde = (r, e, t) => (nde(r, e, "default"), t), Fp = {};
sde(Fp, Ab);
var QM = class {
  constructor(e, t, i) {
    this._onDidChange = new Fp.Emitter(), this._languageId = e, this.setOptions(t), this.setModeConfiguration(i);
  }
  get onDidChange() {
    return this._onDidChange.event;
  }
  get languageId() {
    return this._languageId;
  }
  get modeConfiguration() {
    return this._modeConfiguration;
  }
  get diagnosticsOptions() {
    return this.options;
  }
  get options() {
    return this._options;
  }
  setOptions(e) {
    this._options = e || /* @__PURE__ */ Object.create(null), this._onDidChange.fire(this);
  }
  setDiagnosticsOptions(e) {
    this.setOptions(e);
  }
  setModeConfiguration(e) {
    this._modeConfiguration = e || /* @__PURE__ */ Object.create(null), this._onDidChange.fire(this);
  }
}, XM = {
  validate: !0,
  lint: {
    compatibleVendorPrefixes: "ignore",
    vendorPrefix: "warning",
    duplicateProperties: "warning",
    emptyRules: "warning",
    importStatement: "ignore",
    boxModel: "ignore",
    universalSelector: "ignore",
    zeroUnits: "ignore",
    fontFaceProperties: "warning",
    hexColorLength: "error",
    argumentsInColorFunction: "error",
    unknownProperties: "warning",
    ieHack: "ignore",
    unknownVendorSpecificProperties: "ignore",
    propertyIgnoredDueToDisplay: "warning",
    important: "ignore",
    float: "ignore",
    idSelector: "ignore"
  },
  data: { useDefaultDataProvider: !0 },
  format: {
    newlineBetweenSelectors: !0,
    newlineBetweenRules: !0,
    spaceAroundSelectorSeparator: !1,
    braceStyle: "collapse",
    maxPreserveNewLines: void 0,
    preserveNewLines: !0
  }
}, JM = {
  completionItems: !0,
  hovers: !0,
  documentSymbols: !0,
  definitions: !0,
  references: !0,
  documentHighlights: !0,
  rename: !0,
  colors: !0,
  foldingRanges: !0,
  diagnostics: !0,
  selectionRanges: !0,
  documentFormattingEdits: !0,
  documentRangeFormattingEdits: !0
}, Q3 = new QM(
  "css",
  XM,
  JM
), X3 = new QM(
  "scss",
  XM,
  JM
), J3 = new QM(
  "less",
  XM,
  JM
);
Fp.languages.css = { cssDefaults: Q3, lessDefaults: J3, scssDefaults: X3 };
function eR() {
  return import("./cssMode-DeymYl4z.mjs");
}
Fp.languages.onLanguage("less", () => {
  eR().then((r) => r.setupMode(J3));
});
Fp.languages.onLanguage("scss", () => {
  eR().then((r) => r.setupMode(X3));
});
Fp.languages.onLanguage("css", () => {
  eR().then((r) => r.setupMode(Q3));
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
var ode = Object.defineProperty, rde = Object.getOwnPropertyDescriptor, ade = Object.getOwnPropertyNames, lde = Object.prototype.hasOwnProperty, dde = (r, e, t, i) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let n of ade(e))
      !lde.call(r, n) && n !== t && ode(r, n, { get: () => e[n], enumerable: !(i = rde(e, n)) || i.enumerable });
  return r;
}, cde = (r, e, t) => (dde(r, e, "default"), t), mL = {};
cde(mL, Ab);
var hde = class {
  constructor(e, t, i) {
    this._onDidChange = new mL.Emitter(), this._languageId = e, this.setOptions(t), this.setModeConfiguration(i);
  }
  get onDidChange() {
    return this._onDidChange.event;
  }
  get languageId() {
    return this._languageId;
  }
  get options() {
    return this._options;
  }
  get modeConfiguration() {
    return this._modeConfiguration;
  }
  setOptions(e) {
    this._options = e || /* @__PURE__ */ Object.create(null), this._onDidChange.fire(this);
  }
  setModeConfiguration(e) {
    this._modeConfiguration = e || /* @__PURE__ */ Object.create(null), this._onDidChange.fire(this);
  }
}, ude = {
  tabSize: 4,
  insertSpaces: !1,
  wrapLineLength: 120,
  unformatted: 'default": "a, abbr, acronym, b, bdo, big, br, button, cite, code, dfn, em, i, img, input, kbd, label, map, object, q, samp, select, small, span, strong, sub, sup, textarea, tt, var',
  contentUnformatted: "pre",
  indentInnerHtml: !1,
  preserveNewLines: !0,
  maxPreserveNewLines: void 0,
  indentHandlebars: !1,
  endWithNewline: !1,
  extraLiners: "head, body, /html",
  wrapAttributes: "auto"
}, _L = {
  format: ude,
  suggest: {},
  data: { useDefaultDataProvider: !0 }
};
function vL(r) {
  return {
    completionItems: !0,
    hovers: !0,
    documentSymbols: !0,
    links: !0,
    documentHighlights: !0,
    rename: !0,
    colors: !0,
    foldingRanges: !0,
    selectionRanges: !0,
    diagnostics: r === C_,
    // turned off for Razor and Handlebar
    documentFormattingEdits: r === C_,
    // turned off for Razor and Handlebar
    documentRangeFormattingEdits: r === C_
    // turned off for Razor and Handlebar
  };
}
var C_ = "html", aW = "handlebars", lW = "razor", eU = bL(
  C_,
  _L,
  vL(C_)
), gde = eU.defaults, tU = bL(
  aW,
  _L,
  vL(aW)
), fde = tU.defaults, iU = bL(
  lW,
  _L,
  vL(lW)
), pde = iU.defaults;
mL.languages.html = {
  htmlDefaults: gde,
  razorDefaults: pde,
  handlebarDefaults: fde,
  htmlLanguageService: eU,
  handlebarLanguageService: tU,
  razorLanguageService: iU,
  registerHTMLLanguageService: bL
};
function mde() {
  return import("./htmlMode-BBtIFuPu.mjs");
}
function bL(r, e = _L, t = vL(r)) {
  const i = new hde(r, e, t);
  let n;
  const s = mL.languages.onLanguage(r, async () => {
    n = (await mde()).setupMode(i);
  });
  return {
    defaults: i,
    dispose() {
      s.dispose(), n == null || n.dispose(), n = void 0;
    }
  };
}
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
var _de = Object.defineProperty, vde = Object.getOwnPropertyDescriptor, bde = Object.getOwnPropertyNames, Cde = Object.prototype.hasOwnProperty, wde = (r, e, t, i) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let n of bde(e))
      !Cde.call(r, n) && n !== t && _de(r, n, { get: () => e[n], enumerable: !(i = vde(e, n)) || i.enumerable });
  return r;
}, Sde = (r, e, t) => (wde(r, e, "default"), t), Pb = {};
Sde(Pb, Ab);
var yde = class {
  constructor(e, t, i) {
    this._onDidChange = new Pb.Emitter(), this._languageId = e, this.setDiagnosticsOptions(t), this.setModeConfiguration(i);
  }
  get onDidChange() {
    return this._onDidChange.event;
  }
  get languageId() {
    return this._languageId;
  }
  get modeConfiguration() {
    return this._modeConfiguration;
  }
  get diagnosticsOptions() {
    return this._diagnosticsOptions;
  }
  setDiagnosticsOptions(e) {
    this._diagnosticsOptions = e || /* @__PURE__ */ Object.create(null), this._onDidChange.fire(this);
  }
  setModeConfiguration(e) {
    this._modeConfiguration = e || /* @__PURE__ */ Object.create(null), this._onDidChange.fire(this);
  }
}, Lde = {
  validate: !0,
  allowComments: !0,
  schemas: [],
  enableSchemaRequest: !1,
  schemaRequest: "warning",
  schemaValidation: "warning",
  comments: "error",
  trailingCommas: "error"
}, Dde = {
  documentFormattingEdits: !0,
  documentRangeFormattingEdits: !0,
  completionItems: !0,
  hovers: !0,
  documentSymbols: !0,
  tokens: !0,
  colors: !0,
  foldingRanges: !0,
  diagnostics: !0,
  selectionRanges: !0
}, nU = new yde(
  "json",
  Lde,
  Dde
), kde = () => sU().then((r) => r.getWorker());
Pb.languages.json = { jsonDefaults: nU, getWorker: kde };
function sU() {
  return import("./jsonMode-BO8a7D6B.mjs");
}
Pb.languages.register({
  id: "json",
  extensions: [".json", ".bowerrc", ".jshintrc", ".jscsrc", ".eslintrc", ".babelrc", ".har"],
  aliases: ["JSON", "json"],
  mimetypes: ["application/json"]
});
Pb.languages.onLanguage("json", () => {
  sU().then((r) => r.setupMode(nU));
});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
var xde = Object.defineProperty, Ide = Object.getOwnPropertyDescriptor, Ede = Object.getOwnPropertyNames, Tde = Object.prototype.hasOwnProperty, Nde = (r, e, t, i) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let n of Ede(e))
      !Tde.call(r, n) && n !== t && xde(r, n, { get: () => e[n], enumerable: !(i = Ide(e, n)) || i.enumerable });
  return r;
}, Mde = (r, e, t) => (Nde(r, e, "default"), t), Rde = "5.4.5", up = {};
Mde(up, Ab);
var oU = /* @__PURE__ */ ((r) => (r[r.None = 0] = "None", r[r.CommonJS = 1] = "CommonJS", r[r.AMD = 2] = "AMD", r[r.UMD = 3] = "UMD", r[r.System = 4] = "System", r[r.ES2015 = 5] = "ES2015", r[r.ESNext = 99] = "ESNext", r))(oU || {}), rU = /* @__PURE__ */ ((r) => (r[r.None = 0] = "None", r[r.Preserve = 1] = "Preserve", r[r.React = 2] = "React", r[r.ReactNative = 3] = "ReactNative", r[r.ReactJSX = 4] = "ReactJSX", r[r.ReactJSXDev = 5] = "ReactJSXDev", r))(rU || {}), aU = /* @__PURE__ */ ((r) => (r[r.CarriageReturnLineFeed = 0] = "CarriageReturnLineFeed", r[r.LineFeed = 1] = "LineFeed", r))(aU || {}), lU = /* @__PURE__ */ ((r) => (r[r.ES3 = 0] = "ES3", r[r.ES5 = 1] = "ES5", r[r.ES2015 = 2] = "ES2015", r[r.ES2016 = 3] = "ES2016", r[r.ES2017 = 4] = "ES2017", r[r.ES2018 = 5] = "ES2018", r[r.ES2019 = 6] = "ES2019", r[r.ES2020 = 7] = "ES2020", r[r.ESNext = 99] = "ESNext", r[r.JSON = 100] = "JSON", r[
  r.Latest = 99
  /* ESNext */
] = "Latest", r))(lU || {}), dU = /* @__PURE__ */ ((r) => (r[r.Classic = 1] = "Classic", r[r.NodeJs = 2] = "NodeJs", r))(dU || {}), cU = class {
  constructor(r, e, t, i, n) {
    this._onDidChange = new up.Emitter(), this._onDidExtraLibsChange = new up.Emitter(), this._extraLibs = /* @__PURE__ */ Object.create(null), this._removedExtraLibs = /* @__PURE__ */ Object.create(null), this._eagerModelSync = !1, this.setCompilerOptions(r), this.setDiagnosticsOptions(e), this.setWorkerOptions(t), this.setInlayHintsOptions(i), this.setModeConfiguration(n), this._onDidExtraLibsChangeTimeout = -1;
  }
  get onDidChange() {
    return this._onDidChange.event;
  }
  get onDidExtraLibsChange() {
    return this._onDidExtraLibsChange.event;
  }
  get modeConfiguration() {
    return this._modeConfiguration;
  }
  get workerOptions() {
    return this._workerOptions;
  }
  get inlayHintsOptions() {
    return this._inlayHintsOptions;
  }
  getExtraLibs() {
    return this._extraLibs;
  }
  addExtraLib(r, e) {
    let t;
    if (typeof e > "u" ? t = `ts:extralib-${Math.random().toString(36).substring(2, 15)}` : t = e, this._extraLibs[t] && this._extraLibs[t].content === r)
      return {
        dispose: () => {
        }
      };
    let i = 1;
    return this._removedExtraLibs[t] && (i = this._removedExtraLibs[t] + 1), this._extraLibs[t] && (i = this._extraLibs[t].version + 1), this._extraLibs[t] = {
      content: r,
      version: i
    }, this._fireOnDidExtraLibsChangeSoon(), {
      dispose: () => {
        let n = this._extraLibs[t];
        n && n.version === i && (delete this._extraLibs[t], this._removedExtraLibs[t] = i, this._fireOnDidExtraLibsChangeSoon());
      }
    };
  }
  setExtraLibs(r) {
    for (const e in this._extraLibs)
      this._removedExtraLibs[e] = this._extraLibs[e].version;
    if (this._extraLibs = /* @__PURE__ */ Object.create(null), r && r.length > 0)
      for (const e of r) {
        const t = e.filePath || `ts:extralib-${Math.random().toString(36).substring(2, 15)}`, i = e.content;
        let n = 1;
        this._removedExtraLibs[t] && (n = this._removedExtraLibs[t] + 1), this._extraLibs[t] = {
          content: i,
          version: n
        };
      }
    this._fireOnDidExtraLibsChangeSoon();
  }
  _fireOnDidExtraLibsChangeSoon() {
    this._onDidExtraLibsChangeTimeout === -1 && (this._onDidExtraLibsChangeTimeout = window.setTimeout(() => {
      this._onDidExtraLibsChangeTimeout = -1, this._onDidExtraLibsChange.fire(void 0);
    }, 0));
  }
  getCompilerOptions() {
    return this._compilerOptions;
  }
  setCompilerOptions(r) {
    this._compilerOptions = r || /* @__PURE__ */ Object.create(null), this._onDidChange.fire(void 0);
  }
  getDiagnosticsOptions() {
    return this._diagnosticsOptions;
  }
  setDiagnosticsOptions(r) {
    this._diagnosticsOptions = r || /* @__PURE__ */ Object.create(null), this._onDidChange.fire(void 0);
  }
  setWorkerOptions(r) {
    this._workerOptions = r || /* @__PURE__ */ Object.create(null), this._onDidChange.fire(void 0);
  }
  setInlayHintsOptions(r) {
    this._inlayHintsOptions = r || /* @__PURE__ */ Object.create(null), this._onDidChange.fire(void 0);
  }
  setMaximumWorkerIdleTime(r) {
  }
  setEagerModelSync(r) {
    this._eagerModelSync = r;
  }
  getEagerModelSync() {
    return this._eagerModelSync;
  }
  setModeConfiguration(r) {
    this._modeConfiguration = r || /* @__PURE__ */ Object.create(null), this._onDidChange.fire(void 0);
  }
}, Ade = Rde, hU = {
  completionItems: !0,
  hovers: !0,
  documentSymbols: !0,
  definitions: !0,
  references: !0,
  documentHighlights: !0,
  rename: !0,
  diagnostics: !0,
  documentRangeFormattingEdits: !0,
  signatureHelp: !0,
  onTypeFormattingEdits: !0,
  codeActions: !0,
  inlayHints: !0
}, uU = new cU(
  {
    allowNonTsExtensions: !0,
    target: 99
    /* Latest */
  },
  { noSemanticValidation: !1, noSyntaxValidation: !1, onlyVisible: !1 },
  {},
  {},
  hU
), gU = new cU(
  {
    allowNonTsExtensions: !0,
    allowJs: !0,
    target: 99
    /* Latest */
  },
  { noSemanticValidation: !0, noSyntaxValidation: !1, onlyVisible: !1 },
  {},
  {},
  hU
), Pde = () => CL().then((r) => r.getTypeScriptWorker()), Ode = () => CL().then((r) => r.getJavaScriptWorker());
up.languages.typescript = {
  ModuleKind: oU,
  JsxEmit: rU,
  NewLineKind: aU,
  ScriptTarget: lU,
  ModuleResolutionKind: dU,
  typescriptVersion: Ade,
  typescriptDefaults: uU,
  javascriptDefaults: gU,
  getTypeScriptWorker: Pde,
  getJavaScriptWorker: Ode
};
function CL() {
  return import("./tsMode-D51JSBe9.mjs");
}
up.languages.onLanguage("typescript", () => CL().then((r) => r.setupTypeScript(uU)));
up.languages.onLanguage("javascript", () => CL().then((r) => r.setupJavaScript(gU)));
class Fde extends cs {
  constructor() {
    super({
      id: "diffEditor.toggleCollapseUnchangedRegions",
      title: Me("toggleCollapseUnchangedRegions", "Toggle Collapse Unchanged Regions"),
      icon: me.map,
      toggled: U.has("config.diffEditor.hideUnchangedRegions.enabled"),
      precondition: U.has("isInDiffEditor"),
      menu: {
        when: U.has("isInDiffEditor"),
        id: D.EditorTitle,
        order: 22,
        group: "navigation"
      }
    });
  }
  run(e, ...t) {
    const i = e.get(Ge), n = !i.getValue("diffEditor.hideUnchangedRegions.enabled");
    i.updateValue("diffEditor.hideUnchangedRegions.enabled", n);
  }
}
class fU extends cs {
  constructor() {
    super({
      id: "diffEditor.toggleShowMovedCodeBlocks",
      title: Me("toggleShowMovedCodeBlocks", "Toggle Show Moved Code Blocks"),
      precondition: U.has("isInDiffEditor")
    });
  }
  run(e, ...t) {
    const i = e.get(Ge), n = !i.getValue("diffEditor.experimental.showMoves");
    i.updateValue("diffEditor.experimental.showMoves", n);
  }
}
class pU extends cs {
  constructor() {
    super({
      id: "diffEditor.toggleUseInlineViewWhenSpaceIsLimited",
      title: Me("toggleUseInlineViewWhenSpaceIsLimited", "Toggle Use Inline View When Space Is Limited"),
      precondition: U.has("isInDiffEditor")
    });
  }
  run(e, ...t) {
    const i = e.get(Ge), n = !i.getValue("diffEditor.useInlineViewWhenSpaceIsLimited");
    i.updateValue("diffEditor.useInlineViewWhenSpaceIsLimited", n);
  }
}
const Ob = Me("diffEditor", "Diff Editor");
class Wde extends ra {
  constructor() {
    super({
      id: "diffEditor.switchSide",
      title: Me("switchSide", "Switch Side"),
      icon: me.arrowSwap,
      precondition: U.has("isInDiffEditor"),
      f1: !0,
      category: Ob
    });
  }
  runEditorCommand(e, t, i) {
    const n = Bp(e);
    if (n instanceof ud) {
      if (i && i.dryRun)
        return { destinationSelection: n.mapToOtherSide().destinationSelection };
      n.switchSide();
    }
  }
}
class Bde extends ra {
  constructor() {
    super({
      id: "diffEditor.exitCompareMove",
      title: Me("exitCompareMove", "Exit Compare Move"),
      icon: me.close,
      precondition: x.comparingMovedCode,
      f1: !1,
      category: Ob,
      keybinding: {
        weight: 1e4,
        primary: 9
      }
    });
  }
  runEditorCommand(e, t, ...i) {
    const n = Bp(e);
    n instanceof ud && n.exitCompareMove();
  }
}
class Hde extends ra {
  constructor() {
    super({
      id: "diffEditor.collapseAllUnchangedRegions",
      title: Me("collapseAllUnchangedRegions", "Collapse All Unchanged Regions"),
      icon: me.fold,
      precondition: U.has("isInDiffEditor"),
      f1: !0,
      category: Ob
    });
  }
  runEditorCommand(e, t, ...i) {
    const n = Bp(e);
    n instanceof ud && n.collapseAllUnchangedRegions();
  }
}
class Vde extends ra {
  constructor() {
    super({
      id: "diffEditor.showAllUnchangedRegions",
      title: Me("showAllUnchangedRegions", "Show All Unchanged Regions"),
      icon: me.unfold,
      precondition: U.has("isInDiffEditor"),
      f1: !0,
      category: Ob
    });
  }
  runEditorCommand(e, t, ...i) {
    const n = Bp(e);
    n instanceof ud && n.showAllUnchangedRegions();
  }
}
class JE extends cs {
  constructor() {
    super({
      id: "diffEditor.revert",
      title: Me("revert", "Revert"),
      f1: !1,
      category: Ob
    });
  }
  run(e, t) {
    var i;
    const n = zde(e, t.originalUri, t.modifiedUri);
    n instanceof ud && n.revertRangeMappings((i = t.mapping.innerChanges) !== null && i !== void 0 ? i : []);
  }
}
const mU = Me("accessibleDiffViewer", "Accessible Diff Viewer");
class Wp extends cs {
  constructor() {
    super({
      id: Wp.id,
      title: Me("editor.action.accessibleDiffViewer.next", "Go to Next Difference"),
      category: mU,
      precondition: U.has("isInDiffEditor"),
      keybinding: {
        primary: 65,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      f1: !0
    });
  }
  run(e) {
    const t = Bp(e);
    t == null || t.accessibleDiffViewerNext();
  }
}
Wp.id = "editor.action.accessibleDiffViewer.next";
class Fb extends cs {
  constructor() {
    super({
      id: Fb.id,
      title: Me("editor.action.accessibleDiffViewer.prev", "Go to Previous Difference"),
      category: mU,
      precondition: U.has("isInDiffEditor"),
      keybinding: {
        primary: 1089,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      f1: !0
    });
  }
  run(e) {
    const t = Bp(e);
    t == null || t.accessibleDiffViewerPrev();
  }
}
Fb.id = "editor.action.accessibleDiffViewer.prev";
function zde(r, e, t) {
  return r.get(ht).listDiffEditors().find((s) => {
    var o, a;
    const l = s.getModifiedEditor(), d = s.getOriginalEditor();
    return l && ((o = l.getModel()) === null || o === void 0 ? void 0 : o.uri.toString()) === t.toString() && d && ((a = d.getModel()) === null || a === void 0 ? void 0 : a.uri.toString()) === e.toString();
  }) || null;
}
function Bp(r) {
  const t = r.get(ht).listDiffEditors(), i = Ln();
  if (i)
    for (const n of t) {
      const s = n.getContainerDomNode();
      if (Ude(s, i))
        return n;
    }
  return null;
}
function Ude(r, e) {
  let t = e;
  for (; t; ) {
    if (t === r)
      return !0;
    t = t.parentElement;
  }
  return !1;
}
Rt(Fde);
Rt(fU);
Rt(pU);
on.appendMenuItem(D.EditorTitle, {
  command: {
    id: new pU().desc.id,
    title: p("useInlineViewWhenSpaceIsLimited", "Use Inline View When Space Is Limited"),
    toggled: U.has("config.diffEditor.useInlineViewWhenSpaceIsLimited"),
    precondition: U.has("isInDiffEditor")
  },
  order: 11,
  group: "1_diff",
  when: U.and(x.diffEditorRenderSideBySideInlineBreakpointReached, U.has("isInDiffEditor"))
});
on.appendMenuItem(D.EditorTitle, {
  command: {
    id: new fU().desc.id,
    title: p("showMoves", "Show Moved Code Blocks"),
    icon: me.move,
    toggled: Ip.create("config.diffEditor.experimental.showMoves", !0),
    precondition: U.has("isInDiffEditor")
  },
  order: 10,
  group: "1_diff",
  when: U.has("isInDiffEditor")
});
Rt(JE);
for (const r of [
  { icon: me.arrowRight, key: x.diffEditorInlineMode.toNegated() },
  { icon: me.discard, key: x.diffEditorInlineMode }
])
  on.appendMenuItem(D.DiffEditorHunkToolbar, {
    command: {
      id: new JE().desc.id,
      title: p("revertHunk", "Revert Block"),
      icon: r.icon
    },
    when: U.and(x.diffEditorModifiedWritable, r.key),
    order: 5,
    group: "primary"
  }), on.appendMenuItem(D.DiffEditorSelectionToolbar, {
    command: {
      id: new JE().desc.id,
      title: p("revertSelection", "Revert Selection"),
      icon: r.icon
    },
    when: U.and(x.diffEditorModifiedWritable, r.key),
    order: 5,
    group: "primary"
  });
Rt(Wde);
Rt(Bde);
Rt(Hde);
Rt(Vde);
on.appendMenuItem(D.EditorTitle, {
  command: {
    id: Wp.id,
    title: p("Open Accessible Diff Viewer", "Open Accessible Diff Viewer"),
    precondition: U.has("isInDiffEditor")
  },
  order: 10,
  group: "2_diff",
  when: U.and(x.accessibleDiffViewerVisible.negate(), U.has("isInDiffEditor"))
});
st.registerCommandAlias("editor.action.diffReview.next", Wp.id);
Rt(Wp);
st.registerCommandAlias("editor.action.diffReview.prev", Fb.id);
Rt(Fb);
var $de = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Kde = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, eT;
const wL = new oe("selectionAnchorSet", !1);
let gd = eT = class {
  static get(e) {
    return e.getContribution(eT.ID);
  }
  constructor(e, t) {
    this.editor = e, this.selectionAnchorSetContextKey = wL.bindTo(t), this.modelChangeListener = e.onDidChangeModel(() => this.selectionAnchorSetContextKey.reset());
  }
  setSelectionAnchor() {
    if (this.editor.hasModel()) {
      const e = this.editor.getPosition();
      this.editor.changeDecorations((t) => {
        this.decorationId && t.removeDecoration(this.decorationId), this.decorationId = t.addDecoration(ge.fromPositions(e, e), {
          description: "selection-anchor",
          stickiness: 1,
          hoverMessage: new Nn().appendText(p("selectionAnchor", "Selection Anchor")),
          className: "selection-anchor"
        });
      }), this.selectionAnchorSetContextKey.set(!!this.decorationId), Ls(p("anchorSet", "Anchor set at {0}:{1}", e.lineNumber, e.column));
    }
  }
  goToSelectionAnchor() {
    if (this.editor.hasModel() && this.decorationId) {
      const e = this.editor.getModel().getDecorationRange(this.decorationId);
      e && this.editor.setPosition(e.getStartPosition());
    }
  }
  selectFromAnchorToCursor() {
    if (this.editor.hasModel() && this.decorationId) {
      const e = this.editor.getModel().getDecorationRange(this.decorationId);
      if (e) {
        const t = this.editor.getPosition();
        this.editor.setSelection(ge.fromPositions(e.getStartPosition(), t)), this.cancelSelectionAnchor();
      }
    }
  }
  cancelSelectionAnchor() {
    if (this.decorationId) {
      const e = this.decorationId;
      this.editor.changeDecorations((t) => {
        t.removeDecoration(e), this.decorationId = void 0;
      }), this.selectionAnchorSetContextKey.set(!1);
    }
  }
  dispose() {
    this.cancelSelectionAnchor(), this.modelChangeListener.dispose();
  }
};
gd.ID = "editor.contrib.selectionAnchorController";
gd = eT = $de([
  Kde(1, De)
], gd);
class jde extends ae {
  constructor() {
    super({
      id: "editor.action.setSelectionAnchor",
      label: p("setSelectionAnchor", "Set Selection Anchor"),
      alias: "Set Selection Anchor",
      precondition: void 0,
      kbOpts: {
        kbExpr: x.editorTextFocus,
        primary: zi(
          2089,
          2080
          /* KeyCode.KeyB */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  async run(e, t) {
    var i;
    (i = gd.get(t)) === null || i === void 0 || i.setSelectionAnchor();
  }
}
class qde extends ae {
  constructor() {
    super({
      id: "editor.action.goToSelectionAnchor",
      label: p("goToSelectionAnchor", "Go to Selection Anchor"),
      alias: "Go to Selection Anchor",
      precondition: wL
    });
  }
  async run(e, t) {
    var i;
    (i = gd.get(t)) === null || i === void 0 || i.goToSelectionAnchor();
  }
}
class Gde extends ae {
  constructor() {
    super({
      id: "editor.action.selectFromAnchorToCursor",
      label: p("selectFromAnchorToCursor", "Select from Anchor to Cursor"),
      alias: "Select from Anchor to Cursor",
      precondition: wL,
      kbOpts: {
        kbExpr: x.editorTextFocus,
        primary: zi(
          2089,
          2089
          /* KeyCode.KeyK */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  async run(e, t) {
    var i;
    (i = gd.get(t)) === null || i === void 0 || i.selectFromAnchorToCursor();
  }
}
class Zde extends ae {
  constructor() {
    super({
      id: "editor.action.cancelSelectionAnchor",
      label: p("cancelSelectionAnchor", "Cancel Selection Anchor"),
      alias: "Cancel Selection Anchor",
      precondition: wL,
      kbOpts: {
        kbExpr: x.editorTextFocus,
        primary: 9,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  async run(e, t) {
    var i;
    (i = gd.get(t)) === null || i === void 0 || i.cancelSelectionAnchor();
  }
}
gt(
  gd.ID,
  gd,
  4
  /* EditorContributionInstantiation.Lazy */
);
Y(jde);
Y(qde);
Y(Gde);
Y(Zde);
const Yde = I("editorOverviewRuler.bracketMatchForeground", { dark: "#A0A0A0", light: "#A0A0A0", hcDark: "#A0A0A0", hcLight: "#A0A0A0" }, p("overviewRulerBracketMatchForeground", "Overview ruler marker color for matching brackets."));
class Qde extends ae {
  constructor() {
    super({
      id: "editor.action.jumpToBracket",
      label: p("smartSelect.jumpBracket", "Go to Bracket"),
      alias: "Go to Bracket",
      precondition: void 0,
      kbOpts: {
        kbExpr: x.editorTextFocus,
        primary: 3165,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(e, t) {
    var i;
    (i = hr.get(t)) === null || i === void 0 || i.jumpToBracket();
  }
}
class Xde extends ae {
  constructor() {
    super({
      id: "editor.action.selectToBracket",
      label: p("smartSelect.selectToBracket", "Select to Bracket"),
      alias: "Select to Bracket",
      precondition: void 0,
      metadata: {
        description: Me("smartSelect.selectToBracketDescription", "Select the text inside and including the brackets or curly braces"),
        args: [{
          name: "args",
          schema: {
            type: "object",
            properties: {
              selectBrackets: {
                type: "boolean",
                default: !0
              }
            }
          }
        }]
      }
    });
  }
  run(e, t, i) {
    var n;
    let s = !0;
    i && i.selectBrackets === !1 && (s = !1), (n = hr.get(t)) === null || n === void 0 || n.selectToBracket(s);
  }
}
class Jde extends ae {
  constructor() {
    super({
      id: "editor.action.removeBrackets",
      label: p("smartSelect.removeBrackets", "Remove Brackets"),
      alias: "Remove Brackets",
      precondition: void 0,
      kbOpts: {
        kbExpr: x.editorTextFocus,
        primary: 2561,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(e, t) {
    var i;
    (i = hr.get(t)) === null || i === void 0 || i.removeBrackets(this.id);
  }
}
class ece {
  constructor(e, t, i) {
    this.position = e, this.brackets = t, this.options = i;
  }
}
class hr extends P {
  static get(e) {
    return e.getContribution(hr.ID);
  }
  constructor(e) {
    super(), this._editor = e, this._lastBracketsData = [], this._lastVersionId = 0, this._decorations = this._editor.createDecorationsCollection(), this._updateBracketsSoon = this._register(new xt(() => this._updateBrackets(), 50)), this._matchBrackets = this._editor.getOption(
      72
      /* EditorOption.matchBrackets */
    ), this._updateBracketsSoon.schedule(), this._register(e.onDidChangeCursorPosition((t) => {
      this._matchBrackets !== "never" && this._updateBracketsSoon.schedule();
    })), this._register(e.onDidChangeModelContent((t) => {
      this._updateBracketsSoon.schedule();
    })), this._register(e.onDidChangeModel((t) => {
      this._lastBracketsData = [], this._updateBracketsSoon.schedule();
    })), this._register(e.onDidChangeModelLanguageConfiguration((t) => {
      this._lastBracketsData = [], this._updateBracketsSoon.schedule();
    })), this._register(e.onDidChangeConfiguration((t) => {
      t.hasChanged(
        72
        /* EditorOption.matchBrackets */
      ) && (this._matchBrackets = this._editor.getOption(
        72
        /* EditorOption.matchBrackets */
      ), this._decorations.clear(), this._lastBracketsData = [], this._lastVersionId = 0, this._updateBracketsSoon.schedule());
    })), this._register(e.onDidBlurEditorWidget(() => {
      this._updateBracketsSoon.schedule();
    })), this._register(e.onDidFocusEditorWidget(() => {
      this._updateBracketsSoon.schedule();
    }));
  }
  jumpToBracket() {
    if (!this._editor.hasModel())
      return;
    const e = this._editor.getModel(), t = this._editor.getSelections().map((i) => {
      const n = i.getStartPosition(), s = e.bracketPairs.matchBracket(n);
      let o = null;
      if (s)
        s[0].containsPosition(n) && !s[1].containsPosition(n) ? o = s[1].getStartPosition() : s[1].containsPosition(n) && (o = s[0].getStartPosition());
      else {
        const a = e.bracketPairs.findEnclosingBrackets(n);
        if (a)
          o = a[1].getStartPosition();
        else {
          const l = e.bracketPairs.findNextBracket(n);
          l && l.range && (o = l.range.getStartPosition());
        }
      }
      return o ? new ge(o.lineNumber, o.column, o.lineNumber, o.column) : new ge(n.lineNumber, n.column, n.lineNumber, n.column);
    });
    this._editor.setSelections(t), this._editor.revealRange(t[0]);
  }
  selectToBracket(e) {
    if (!this._editor.hasModel())
      return;
    const t = this._editor.getModel(), i = [];
    this._editor.getSelections().forEach((n) => {
      const s = n.getStartPosition();
      let o = t.bracketPairs.matchBracket(s);
      if (!o && (o = t.bracketPairs.findEnclosingBrackets(s), !o)) {
        const d = t.bracketPairs.findNextBracket(s);
        d && d.range && (o = t.bracketPairs.matchBracket(d.range.getStartPosition()));
      }
      let a = null, l = null;
      if (o) {
        o.sort(L.compareRangesUsingStarts);
        const [d, c] = o;
        if (a = e ? d.getStartPosition() : d.getEndPosition(), l = e ? c.getEndPosition() : c.getStartPosition(), c.containsPosition(s)) {
          const h = a;
          a = l, l = h;
        }
      }
      a && l && i.push(new ge(a.lineNumber, a.column, l.lineNumber, l.column));
    }), i.length > 0 && (this._editor.setSelections(i), this._editor.revealRange(i[0]));
  }
  removeBrackets(e) {
    if (!this._editor.hasModel())
      return;
    const t = this._editor.getModel();
    this._editor.getSelections().forEach((i) => {
      const n = i.getPosition();
      let s = t.bracketPairs.matchBracket(n);
      s || (s = t.bracketPairs.findEnclosingBrackets(n)), s && (this._editor.pushUndoStop(), this._editor.executeEdits(e, [
        { range: s[0], text: "" },
        { range: s[1], text: "" }
      ]), this._editor.pushUndoStop());
    });
  }
  _updateBrackets() {
    if (this._matchBrackets === "never")
      return;
    this._recomputeBrackets();
    const e = [];
    let t = 0;
    for (const i of this._lastBracketsData) {
      const n = i.brackets;
      n && (e[t++] = { range: n[0], options: i.options }, e[t++] = { range: n[1], options: i.options });
    }
    this._decorations.set(e);
  }
  _recomputeBrackets() {
    if (!this._editor.hasModel() || !this._editor.hasWidgetFocus()) {
      this._lastBracketsData = [], this._lastVersionId = 0;
      return;
    }
    const e = this._editor.getSelections();
    if (e.length > 100) {
      this._lastBracketsData = [], this._lastVersionId = 0;
      return;
    }
    const t = this._editor.getModel(), i = t.getVersionId();
    let n = [];
    this._lastVersionId === i && (n = this._lastBracketsData);
    const s = [];
    let o = 0;
    for (let h = 0, u = e.length; h < u; h++) {
      const g = e[h];
      g.isEmpty() && (s[o++] = g.getStartPosition());
    }
    s.length > 1 && s.sort(A.compare);
    const a = [];
    let l = 0, d = 0;
    const c = n.length;
    for (let h = 0, u = s.length; h < u; h++) {
      const g = s[h];
      for (; d < c && n[d].position.isBefore(g); )
        d++;
      if (d < c && n[d].position.equals(g))
        a[l++] = n[d];
      else {
        let f = t.bracketPairs.matchBracket(
          g,
          20
          /* give at most 20ms to compute */
        ), m = hr._DECORATION_OPTIONS_WITH_OVERVIEW_RULER;
        !f && this._matchBrackets === "always" && (f = t.bracketPairs.findEnclosingBrackets(
          g,
          20
          /* give at most 20ms to compute */
        ), m = hr._DECORATION_OPTIONS_WITHOUT_OVERVIEW_RULER), a[l++] = new ece(g, f, m);
      }
    }
    this._lastBracketsData = a, this._lastVersionId = i;
  }
}
hr.ID = "editor.contrib.bracketMatchingController";
hr._DECORATION_OPTIONS_WITH_OVERVIEW_RULER = Fe.register({
  description: "bracket-match-overview",
  stickiness: 1,
  className: "bracket-match",
  overviewRuler: {
    color: ai(Yde),
    position: _r.Center
  }
});
hr._DECORATION_OPTIONS_WITHOUT_OVERVIEW_RULER = Fe.register({
  description: "bracket-match-no-overview",
  stickiness: 1,
  className: "bracket-match"
});
gt(
  hr.ID,
  hr,
  1
  /* EditorContributionInstantiation.AfterFirstRender */
);
Y(Xde);
Y(Qde);
Y(Jde);
on.appendMenuItem(D.MenubarGoMenu, {
  group: "5_infile_nav",
  command: {
    id: "editor.action.jumpToBracket",
    title: p({ key: "miGoToBracket", comment: ["&& denotes a mnemonic"] }, "Go to &&Bracket")
  },
  order: 2
});
class tce {
  constructor(e, t) {
    this._selection = e, this._isMovingLeft = t;
  }
  getEditOperations(e, t) {
    if (this._selection.startLineNumber !== this._selection.endLineNumber || this._selection.isEmpty())
      return;
    const i = this._selection.startLineNumber, n = this._selection.startColumn, s = this._selection.endColumn;
    if (!(this._isMovingLeft && n === 1) && !(!this._isMovingLeft && s === e.getLineMaxColumn(i)))
      if (this._isMovingLeft) {
        const o = new L(i, n - 1, i, n), a = e.getValueInRange(o);
        t.addEditOperation(o, null), t.addEditOperation(new L(i, s, i, s), a);
      } else {
        const o = new L(i, s, i, s + 1), a = e.getValueInRange(o);
        t.addEditOperation(o, null), t.addEditOperation(new L(i, n, i, n), a);
      }
  }
  computeCursorState(e, t) {
    return this._isMovingLeft ? new ge(this._selection.startLineNumber, this._selection.startColumn - 1, this._selection.endLineNumber, this._selection.endColumn - 1) : new ge(this._selection.startLineNumber, this._selection.startColumn + 1, this._selection.endLineNumber, this._selection.endColumn + 1);
  }
}
class _U extends ae {
  constructor(e, t) {
    super(t), this.left = e;
  }
  run(e, t) {
    if (!t.hasModel())
      return;
    const i = [], n = t.getSelections();
    for (const s of n)
      i.push(new tce(s, this.left));
    t.pushUndoStop(), t.executeCommands(this.id, i), t.pushUndoStop();
  }
}
class ice extends _U {
  constructor() {
    super(!0, {
      id: "editor.action.moveCarretLeftAction",
      label: p("caret.moveLeft", "Move Selected Text Left"),
      alias: "Move Selected Text Left",
      precondition: x.writable
    });
  }
}
class nce extends _U {
  constructor() {
    super(!1, {
      id: "editor.action.moveCarretRightAction",
      label: p("caret.moveRight", "Move Selected Text Right"),
      alias: "Move Selected Text Right",
      precondition: x.writable
    });
  }
}
Y(ice);
Y(nce);
class sce extends ae {
  constructor() {
    super({
      id: "editor.action.transposeLetters",
      label: p("transposeLetters.label", "Transpose Letters"),
      alias: "Transpose Letters",
      precondition: x.writable,
      kbOpts: {
        kbExpr: x.textInputFocus,
        primary: 0,
        mac: {
          primary: 306
          /* KeyCode.KeyT */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(e, t) {
    if (!t.hasModel())
      return;
    const i = t.getModel(), n = [], s = t.getSelections();
    for (const o of s) {
      if (!o.isEmpty())
        continue;
      const a = o.startLineNumber, l = o.startColumn, d = i.getLineMaxColumn(a);
      if (a === 1 && (l === 1 || l === 2 && d === 2))
        continue;
      const c = l === d ? o.getPosition() : wt.rightPosition(i, o.getPosition().lineNumber, o.getPosition().column), h = wt.leftPosition(i, c), u = wt.leftPosition(i, h), g = i.getValueInRange(L.fromPositions(u, h)), f = i.getValueInRange(L.fromPositions(h, c)), m = L.fromPositions(u, c);
      n.push(new Cn(m, f + g));
    }
    n.length > 0 && (t.pushUndoStop(), t.executeCommands(this.id, n), t.pushUndoStop());
  }
}
Y(sce);
const SL = function() {
  if (typeof crypto == "object" && typeof crypto.randomUUID == "function")
    return crypto.randomUUID.bind(crypto);
  let r;
  typeof crypto == "object" && typeof crypto.getRandomValues == "function" ? r = crypto.getRandomValues.bind(crypto) : r = function(i) {
    for (let n = 0; n < i.length; n++)
      i[n] = Math.floor(Math.random() * 256);
    return i;
  };
  const e = new Uint8Array(16), t = [];
  for (let i = 0; i < 256; i++)
    t.push(i.toString(16).padStart(2, "0"));
  return function() {
    r(e), e[6] = e[6] & 15 | 64, e[8] = e[8] & 63 | 128;
    let n = 0, s = "";
    return s += t[e[n++]], s += t[e[n++]], s += t[e[n++]], s += t[e[n++]], s += "-", s += t[e[n++]], s += t[e[n++]], s += "-", s += t[e[n++]], s += t[e[n++]], s += "-", s += t[e[n++]], s += t[e[n++]], s += "-", s += t[e[n++]], s += t[e[n++]], s += t[e[n++]], s += t[e[n++]], s += t[e[n++]], s += t[e[n++]], s;
  };
}();
function tR(r) {
  return {
    asString: async () => r,
    asFile: () => {
    },
    value: typeof r == "string" ? r : void 0
  };
}
function oce(r, e, t) {
  const i = { id: SL(), name: r, uri: e, data: t };
  return {
    asString: async () => "",
    asFile: () => i,
    value: void 0
  };
}
class vU {
  constructor() {
    this._entries = /* @__PURE__ */ new Map();
  }
  get size() {
    let e = 0;
    for (const t of this._entries)
      e++;
    return e;
  }
  has(e) {
    return this._entries.has(this.toKey(e));
  }
  matches(e) {
    const t = [...this._entries.keys()];
    return ut.some(this, ([i, n]) => n.asFile()) && t.push("files"), CU(ky(e), t);
  }
  get(e) {
    var t;
    return (t = this._entries.get(this.toKey(e))) === null || t === void 0 ? void 0 : t[0];
  }
  /**
   * Add a new entry to this data transfer.
   *
   * This does not replace existing entries for `mimeType`.
   */
  append(e, t) {
    const i = this._entries.get(e);
    i ? i.push(t) : this._entries.set(this.toKey(e), [t]);
  }
  /**
   * Set the entry for a given mime type.
   *
   * This replaces all existing entries for `mimeType`.
   */
  replace(e, t) {
    this._entries.set(this.toKey(e), [t]);
  }
  /**
   * Remove all entries for `mimeType`.
   */
  delete(e) {
    this._entries.delete(this.toKey(e));
  }
  /**
   * Iterate over all `[mime, item]` pairs in this data transfer.
   *
   * There may be multiple entries for each mime type.
   */
  *[Symbol.iterator]() {
    for (const [e, t] of this._entries)
      for (const i of t)
        yield [e, i];
  }
  toKey(e) {
    return ky(e);
  }
}
function ky(r) {
  return r.toLowerCase();
}
function bU(r, e) {
  return CU(ky(r), e.map(ky));
}
function CU(r, e) {
  if (r === "*/*")
    return e.length > 0;
  if (e.includes(r))
    return !0;
  const t = r.match(/^([a-z]+)\/([a-z]+|\*)$/i);
  if (!t)
    return !1;
  const [i, n, s] = t;
  return s === "*" ? e.some((o) => o.startsWith(n + "/")) : !1;
}
const yL = Object.freeze({
  // http://amundsen.com/hypermedia/urilist/
  create: (r) => rd(r.map((e) => e.toString())).join(`\r
`),
  split: (r) => r.split(`\r
`),
  parse: (r) => yL.split(r).filter((e) => !e.startsWith("#"))
});
class kt {
  constructor(e) {
    this.value = e;
  }
  equals(e) {
    return this.value === e.value;
  }
  contains(e) {
    return this.equals(e) || this.value === "" || e.value.startsWith(this.value + kt.sep);
  }
  intersects(e) {
    return this.contains(e) || e.contains(this);
  }
  append(...e) {
    return new kt((this.value ? [this.value, ...e] : e).join(kt.sep));
  }
}
kt.sep = ".";
kt.None = new kt("@@none@@");
kt.Empty = new kt("");
const dW = {
  EDITORS: "CodeEditors",
  FILES: "CodeFiles"
};
class rce {
}
const ace = {
  DragAndDropContribution: "workbench.contributions.dragAndDrop"
};
si.add(ace.DragAndDropContribution, new rce());
class xv {
  constructor() {
  }
  static getInstance() {
    return xv.INSTANCE;
  }
  hasData(e) {
    return e && e === this.proto;
  }
  getData(e) {
    if (this.hasData(e))
      return this.data;
  }
}
xv.INSTANCE = new xv();
function wU(r) {
  const e = new vU();
  for (const t of r.items) {
    const i = t.type;
    if (t.kind === "string") {
      const n = new Promise((s) => t.getAsString(s));
      e.append(i, tR(n));
    } else if (t.kind === "file") {
      const n = t.getAsFile();
      n && e.append(i, lce(n));
    }
  }
  return e;
}
function lce(r) {
  const e = r.path ? Ee.parse(r.path) : void 0;
  return oce(r.name, e, async () => new Uint8Array(await r.arrayBuffer()));
}
const dce = Object.freeze([
  dW.EDITORS,
  dW.FILES,
  lv.RESOURCES,
  lv.INTERNAL_URI_LIST
]);
function SU(r, e = !1) {
  const t = wU(r), i = t.get(lv.INTERNAL_URI_LIST);
  if (i)
    t.replace(fi.uriList, i);
  else if (e || !t.has(fi.uriList)) {
    const n = [];
    for (const s of r.items) {
      const o = s.getAsFile();
      if (o) {
        const a = o.path;
        try {
          a ? n.push(Ee.file(a).toString()) : n.push(Ee.parse(o.name, !0).toString());
        } catch {
        }
      }
    }
    n.length && t.replace(fi.uriList, tR(yL.create(n)));
  }
  for (const n of dce)
    t.delete(n);
  return t;
}
var iR = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Iv = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
class nR {
  async provideDocumentPasteEdits(e, t, i, n, s) {
    const o = await this.getEdit(i, s);
    if (o)
      return {
        dispose() {
        },
        edits: [{ insertText: o.insertText, title: o.title, kind: o.kind, handledMimeType: o.handledMimeType, yieldTo: o.yieldTo }]
      };
  }
  async provideDocumentDropEdits(e, t, i, n) {
    const s = await this.getEdit(i, n);
    return s ? [{ insertText: s.insertText, title: s.title, kind: s.kind, handledMimeType: s.handledMimeType, yieldTo: s.yieldTo }] : void 0;
  }
}
class fd extends nR {
  constructor() {
    super(...arguments), this.kind = fd.kind, this.dropMimeTypes = [fi.text], this.pasteMimeTypes = [fi.text];
  }
  async getEdit(e, t) {
    const i = e.get(fi.text);
    if (!i || e.has(fi.uriList))
      return;
    const n = await i.asString();
    return {
      handledMimeType: fi.text,
      title: p("text.label", "Insert Plain Text"),
      insertText: n,
      kind: this.kind
    };
  }
}
fd.id = "text";
fd.kind = new kt("text.plain");
class yU extends nR {
  constructor() {
    super(...arguments), this.kind = new kt("uri.absolute"), this.dropMimeTypes = [fi.uriList], this.pasteMimeTypes = [fi.uriList];
  }
  async getEdit(e, t) {
    const i = await LU(e);
    if (!i.length || t.isCancellationRequested)
      return;
    let n = 0;
    const s = i.map(({ uri: a, originalText: l }) => a.scheme === Ne.file ? a.fsPath : (n++, l)).join(" ");
    let o;
    return n > 0 ? o = i.length > 1 ? p("defaultDropProvider.uriList.uris", "Insert Uris") : p("defaultDropProvider.uriList.uri", "Insert Uri") : o = i.length > 1 ? p("defaultDropProvider.uriList.paths", "Insert Paths") : p("defaultDropProvider.uriList.path", "Insert Path"), {
      handledMimeType: fi.uriList,
      insertText: s,
      title: o,
      kind: this.kind
    };
  }
}
let xy = class extends nR {
  constructor(e) {
    super(), this._workspaceContextService = e, this.kind = new kt("uri.relative"), this.dropMimeTypes = [fi.uriList], this.pasteMimeTypes = [fi.uriList];
  }
  async getEdit(e, t) {
    const i = await LU(e);
    if (!i.length || t.isCancellationRequested)
      return;
    const n = Yr(i.map(({ uri: s }) => {
      const o = this._workspaceContextService.getWorkspaceFolder(s);
      return o ? gQ(o.uri, s) : void 0;
    }));
    if (n.length)
      return {
        handledMimeType: fi.uriList,
        insertText: n.join(" "),
        title: i.length > 1 ? p("defaultDropProvider.uriList.relativePaths", "Insert Relative Paths") : p("defaultDropProvider.uriList.relativePath", "Insert Relative Path"),
        kind: this.kind
      };
  }
};
xy = iR([
  Iv(0, ku)
], xy);
class cce {
  constructor() {
    this.kind = new kt("html"), this.pasteMimeTypes = ["text/html"], this._yieldTo = [{ mimeType: fi.text }];
  }
  async provideDocumentPasteEdits(e, t, i, n, s) {
    var o;
    if (n.triggerKind !== bx.PasteAs && !(!((o = n.only) === null || o === void 0) && o.contains(this.kind)))
      return;
    const a = i.get("text/html"), l = await (a == null ? void 0 : a.asString());
    if (!(!l || s.isCancellationRequested))
      return {
        dispose() {
        },
        edits: [{
          insertText: l,
          yieldTo: this._yieldTo,
          title: p("pasteHtmlLabel", "Insert HTML"),
          kind: this.kind
        }]
      };
  }
}
async function LU(r) {
  const e = r.get(fi.uriList);
  if (!e)
    return [];
  const t = await e.asString(), i = [];
  for (const n of yL.parse(t))
    try {
      i.push({ uri: Ee.parse(n), originalText: n });
    } catch {
    }
  return i;
}
let tT = class extends P {
  constructor(e, t) {
    super(), this._register(e.documentDropEditProvider.register("*", new fd())), this._register(e.documentDropEditProvider.register("*", new yU())), this._register(e.documentDropEditProvider.register("*", new xy(t)));
  }
};
tT = iR([
  Iv(0, he),
  Iv(1, ku)
], tT);
let iT = class extends P {
  constructor(e, t) {
    super(), this._register(e.documentPasteEditProvider.register("*", new fd())), this._register(e.documentPasteEditProvider.register("*", new yU())), this._register(e.documentPasteEditProvider.register("*", new xy(t))), this._register(e.documentPasteEditProvider.register("*", new cce()));
  }
};
iT = iR([
  Iv(0, he),
  Iv(1, ku)
], iT);
class Jo {
  constructor() {
    this.value = "", this.pos = 0;
  }
  static isDigitCharacter(e) {
    return e >= 48 && e <= 57;
  }
  static isVariableCharacter(e) {
    return e === 95 || e >= 97 && e <= 122 || e >= 65 && e <= 90;
  }
  text(e) {
    this.value = e, this.pos = 0;
  }
  tokenText(e) {
    return this.value.substr(e.pos, e.len);
  }
  next() {
    if (this.pos >= this.value.length)
      return { type: 14, pos: this.pos, len: 0 };
    const e = this.pos;
    let t = 0, i = this.value.charCodeAt(e), n;
    if (n = Jo._table[i], typeof n == "number")
      return this.pos += 1, { type: n, pos: e, len: 1 };
    if (Jo.isDigitCharacter(i)) {
      n = 8;
      do
        t += 1, i = this.value.charCodeAt(e + t);
      while (Jo.isDigitCharacter(i));
      return this.pos += t, { type: n, pos: e, len: t };
    }
    if (Jo.isVariableCharacter(i)) {
      n = 9;
      do
        i = this.value.charCodeAt(e + ++t);
      while (Jo.isVariableCharacter(i) || Jo.isDigitCharacter(i));
      return this.pos += t, { type: n, pos: e, len: t };
    }
    n = 10;
    do
      t += 1, i = this.value.charCodeAt(e + t);
    while (!isNaN(i) && typeof Jo._table[i] > "u" && !Jo.isDigitCharacter(i) && !Jo.isVariableCharacter(i));
    return this.pos += t, { type: n, pos: e, len: t };
  }
}
Jo._table = {
  36: 0,
  58: 1,
  44: 2,
  123: 3,
  125: 4,
  92: 5,
  47: 6,
  124: 7,
  43: 11,
  45: 12,
  63: 13
};
class Hp {
  constructor() {
    this._children = [];
  }
  appendChild(e) {
    return e instanceof es && this._children[this._children.length - 1] instanceof es ? this._children[this._children.length - 1].value += e.value : (e.parent = this, this._children.push(e)), this;
  }
  replace(e, t) {
    const { parent: i } = e, n = i.children.indexOf(e), s = i.children.slice(0);
    s.splice(n, 1, ...t), i._children = s, function o(a, l) {
      for (const d of a)
        d.parent = l, o(d.children, d);
    }(t, i);
  }
  get children() {
    return this._children;
  }
  get rightMostDescendant() {
    return this._children.length > 0 ? this._children[this._children.length - 1].rightMostDescendant : this;
  }
  get snippet() {
    let e = this;
    for (; ; ) {
      if (!e)
        return;
      if (e instanceof Wb)
        return e;
      e = e.parent;
    }
  }
  toString() {
    return this.children.reduce((e, t) => e + t.toString(), "");
  }
  len() {
    return 0;
  }
}
class es extends Hp {
  constructor(e) {
    super(), this.value = e;
  }
  toString() {
    return this.value;
  }
  len() {
    return this.value.length;
  }
  clone() {
    return new es(this.value);
  }
}
class DU extends Hp {
}
class ko extends DU {
  static compareByIndex(e, t) {
    return e.index === t.index ? 0 : e.isFinalTabstop ? 1 : t.isFinalTabstop || e.index < t.index ? -1 : e.index > t.index ? 1 : 0;
  }
  constructor(e) {
    super(), this.index = e;
  }
  get isFinalTabstop() {
    return this.index === 0;
  }
  get choice() {
    return this._children.length === 1 && this._children[0] instanceof Vp ? this._children[0] : void 0;
  }
  clone() {
    const e = new ko(this.index);
    return this.transform && (e.transform = this.transform.clone()), e._children = this.children.map((t) => t.clone()), e;
  }
}
class Vp extends Hp {
  constructor() {
    super(...arguments), this.options = [];
  }
  appendChild(e) {
    return e instanceof es && (e.parent = this, this.options.push(e)), this;
  }
  toString() {
    return this.options[0].value;
  }
  len() {
    return this.options[0].len();
  }
  clone() {
    const e = new Vp();
    return this.options.forEach(e.appendChild, e), e;
  }
}
class sR extends Hp {
  constructor() {
    super(...arguments), this.regexp = new RegExp("");
  }
  resolve(e) {
    const t = this;
    let i = !1, n = e.replace(this.regexp, function() {
      return i = !0, t._replace(Array.prototype.slice.call(arguments, 0, -2));
    });
    return !i && this._children.some((s) => s instanceof Nr && !!s.elseValue) && (n = this._replace([])), n;
  }
  _replace(e) {
    let t = "";
    for (const i of this._children)
      if (i instanceof Nr) {
        let n = e[i.index] || "";
        n = i.resolve(n), t += n;
      } else
        t += i.toString();
    return t;
  }
  toString() {
    return "";
  }
  clone() {
    const e = new sR();
    return e.regexp = new RegExp(this.regexp.source, (this.regexp.ignoreCase ? "i" : "") + (this.regexp.global ? "g" : "")), e._children = this.children.map((t) => t.clone()), e;
  }
}
class Nr extends Hp {
  constructor(e, t, i, n) {
    super(), this.index = e, this.shorthandName = t, this.ifValue = i, this.elseValue = n;
  }
  resolve(e) {
    return this.shorthandName === "upcase" ? e ? e.toLocaleUpperCase() : "" : this.shorthandName === "downcase" ? e ? e.toLocaleLowerCase() : "" : this.shorthandName === "capitalize" ? e ? e[0].toLocaleUpperCase() + e.substr(1) : "" : this.shorthandName === "pascalcase" ? e ? this._toPascalCase(e) : "" : this.shorthandName === "camelcase" ? e ? this._toCamelCase(e) : "" : e && typeof this.ifValue == "string" ? this.ifValue : !e && typeof this.elseValue == "string" ? this.elseValue : e || "";
  }
  _toPascalCase(e) {
    const t = e.match(/[a-z0-9]+/gi);
    return t ? t.map((i) => i.charAt(0).toUpperCase() + i.substr(1)).join("") : e;
  }
  _toCamelCase(e) {
    const t = e.match(/[a-z0-9]+/gi);
    return t ? t.map((i, n) => n === 0 ? i.charAt(0).toLowerCase() + i.substr(1) : i.charAt(0).toUpperCase() + i.substr(1)).join("") : e;
  }
  clone() {
    return new Nr(this.index, this.shorthandName, this.ifValue, this.elseValue);
  }
}
class Ev extends DU {
  constructor(e) {
    super(), this.name = e;
  }
  resolve(e) {
    let t = e.resolve(this);
    return this.transform && (t = this.transform.resolve(t || "")), t !== void 0 ? (this._children = [new es(t)], !0) : !1;
  }
  clone() {
    const e = new Ev(this.name);
    return this.transform && (e.transform = this.transform.clone()), e._children = this.children.map((t) => t.clone()), e;
  }
}
function cW(r, e) {
  const t = [...r];
  for (; t.length > 0; ) {
    const i = t.shift();
    if (!e(i))
      break;
    t.unshift(...i.children);
  }
}
class Wb extends Hp {
  get placeholderInfo() {
    if (!this._placeholders) {
      const e = [];
      let t;
      this.walk(function(i) {
        return i instanceof ko && (e.push(i), t = !t || t.index < i.index ? i : t), !0;
      }), this._placeholders = { all: e, last: t };
    }
    return this._placeholders;
  }
  get placeholders() {
    const { all: e } = this.placeholderInfo;
    return e;
  }
  offset(e) {
    let t = 0, i = !1;
    return this.walk((n) => n === e ? (i = !0, !1) : (t += n.len(), !0)), i ? t : -1;
  }
  fullLen(e) {
    let t = 0;
    return cW([e], (i) => (t += i.len(), !0)), t;
  }
  enclosingPlaceholders(e) {
    const t = [];
    let { parent: i } = e;
    for (; i; )
      i instanceof ko && t.push(i), i = i.parent;
    return t;
  }
  resolveVariables(e) {
    return this.walk((t) => (t instanceof Ev && t.resolve(e) && (this._placeholders = void 0), !0)), this;
  }
  appendChild(e) {
    return this._placeholders = void 0, super.appendChild(e);
  }
  replace(e, t) {
    return this._placeholders = void 0, super.replace(e, t);
  }
  clone() {
    const e = new Wb();
    return this._children = this.children.map((t) => t.clone()), e;
  }
  walk(e) {
    cW(this.children, e);
  }
}
class Mu {
  constructor() {
    this._scanner = new Jo(), this._token = { type: 14, pos: 0, len: 0 };
  }
  static escape(e) {
    return e.replace(/\$|}|\\/g, "\\$&");
  }
  static guessNeedsClipboard(e) {
    return /\${?CLIPBOARD/.test(e);
  }
  parse(e, t, i) {
    const n = new Wb();
    return this.parseFragment(e, n), this.ensureFinalTabstop(n, i ?? !1, t ?? !1), n;
  }
  parseFragment(e, t) {
    const i = t.children.length;
    for (this._scanner.text(e), this._token = this._scanner.next(); this._parse(t); )
      ;
    const n = /* @__PURE__ */ new Map(), s = [];
    t.walk((l) => (l instanceof ko && (l.isFinalTabstop ? n.set(0, void 0) : !n.has(l.index) && l.children.length > 0 ? n.set(l.index, l.children) : s.push(l)), !0));
    const o = (l, d) => {
      const c = n.get(l.index);
      if (!c)
        return;
      const h = new ko(l.index);
      h.transform = l.transform;
      for (const u of c) {
        const g = u.clone();
        h.appendChild(g), g instanceof ko && n.has(g.index) && !d.has(g.index) && (d.add(g.index), o(g, d), d.delete(g.index));
      }
      t.replace(l, [h]);
    }, a = /* @__PURE__ */ new Set();
    for (const l of s)
      o(l, a);
    return t.children.slice(i);
  }
  ensureFinalTabstop(e, t, i) {
    (t || i && e.placeholders.length > 0) && (e.placeholders.find((s) => s.index === 0) || e.appendChild(new ko(0)));
  }
  _accept(e, t) {
    if (e === void 0 || this._token.type === e) {
      const i = t ? this._scanner.tokenText(this._token) : !0;
      return this._token = this._scanner.next(), i;
    }
    return !1;
  }
  _backTo(e) {
    return this._scanner.pos = e.pos + e.len, this._token = e, !1;
  }
  _until(e) {
    const t = this._token;
    for (; this._token.type !== e; ) {
      if (this._token.type === 14)
        return !1;
      if (this._token.type === 5) {
        const n = this._scanner.next();
        if (n.type !== 0 && n.type !== 4 && n.type !== 5)
          return !1;
      }
      this._token = this._scanner.next();
    }
    const i = this._scanner.value.substring(t.pos, this._token.pos).replace(/\\(\$|}|\\)/g, "$1");
    return this._token = this._scanner.next(), i;
  }
  _parse(e) {
    return this._parseEscaped(e) || this._parseTabstopOrVariableName(e) || this._parseComplexPlaceholder(e) || this._parseComplexVariable(e) || this._parseAnything(e);
  }
  // \$, \\, \} -> just text
  _parseEscaped(e) {
    let t;
    return (t = this._accept(5, !0)) ? (t = this._accept(0, !0) || this._accept(4, !0) || this._accept(5, !0) || t, e.appendChild(new es(t)), !0) : !1;
  }
  // $foo -> variable, $1 -> tabstop
  _parseTabstopOrVariableName(e) {
    let t;
    const i = this._token;
    return this._accept(
      0
      /* TokenType.Dollar */
    ) && (t = this._accept(9, !0) || this._accept(8, !0)) ? (e.appendChild(/^\d+$/.test(t) ? new ko(Number(t)) : new Ev(t)), !0) : this._backTo(i);
  }
  // ${1:<children>}, ${1} -> placeholder
  _parseComplexPlaceholder(e) {
    let t;
    const i = this._token;
    if (!(this._accept(
      0
      /* TokenType.Dollar */
    ) && this._accept(
      3
      /* TokenType.CurlyOpen */
    ) && (t = this._accept(8, !0))))
      return this._backTo(i);
    const s = new ko(Number(t));
    if (this._accept(
      1
      /* TokenType.Colon */
    ))
      for (; ; ) {
        if (this._accept(
          4
          /* TokenType.CurlyClose */
        ))
          return e.appendChild(s), !0;
        if (!this._parse(s))
          return e.appendChild(new es("${" + t + ":")), s.children.forEach(e.appendChild, e), !0;
      }
    else if (s.index > 0 && this._accept(
      7
      /* TokenType.Pipe */
    )) {
      const o = new Vp();
      for (; ; ) {
        if (this._parseChoiceElement(o)) {
          if (this._accept(
            2
            /* TokenType.Comma */
          ))
            continue;
          if (this._accept(
            7
            /* TokenType.Pipe */
          ) && (s.appendChild(o), this._accept(
            4
            /* TokenType.CurlyClose */
          )))
            return e.appendChild(s), !0;
        }
        return this._backTo(i), !1;
      }
    } else return this._accept(
      6
      /* TokenType.Forwardslash */
    ) ? this._parseTransform(s) ? (e.appendChild(s), !0) : (this._backTo(i), !1) : this._accept(
      4
      /* TokenType.CurlyClose */
    ) ? (e.appendChild(s), !0) : this._backTo(i);
  }
  _parseChoiceElement(e) {
    const t = this._token, i = [];
    for (; !(this._token.type === 2 || this._token.type === 7); ) {
      let n;
      if ((n = this._accept(5, !0)) ? n = this._accept(2, !0) || this._accept(7, !0) || this._accept(5, !0) || n : n = this._accept(void 0, !0), !n)
        return this._backTo(t), !1;
      i.push(n);
    }
    return i.length === 0 ? (this._backTo(t), !1) : (e.appendChild(new es(i.join(""))), !0);
  }
  // ${foo:<children>}, ${foo} -> variable
  _parseComplexVariable(e) {
    let t;
    const i = this._token;
    if (!(this._accept(
      0
      /* TokenType.Dollar */
    ) && this._accept(
      3
      /* TokenType.CurlyOpen */
    ) && (t = this._accept(9, !0))))
      return this._backTo(i);
    const s = new Ev(t);
    if (this._accept(
      1
      /* TokenType.Colon */
    ))
      for (; ; ) {
        if (this._accept(
          4
          /* TokenType.CurlyClose */
        ))
          return e.appendChild(s), !0;
        if (!this._parse(s))
          return e.appendChild(new es("${" + t + ":")), s.children.forEach(e.appendChild, e), !0;
      }
    else return this._accept(
      6
      /* TokenType.Forwardslash */
    ) ? this._parseTransform(s) ? (e.appendChild(s), !0) : (this._backTo(i), !1) : this._accept(
      4
      /* TokenType.CurlyClose */
    ) ? (e.appendChild(s), !0) : this._backTo(i);
  }
  _parseTransform(e) {
    const t = new sR();
    let i = "", n = "";
    for (; !this._accept(
      6
      /* TokenType.Forwardslash */
    ); ) {
      let s;
      if (s = this._accept(5, !0)) {
        s = this._accept(6, !0) || s, i += s;
        continue;
      }
      if (this._token.type !== 14) {
        i += this._accept(void 0, !0);
        continue;
      }
      return !1;
    }
    for (; !this._accept(
      6
      /* TokenType.Forwardslash */
    ); ) {
      let s;
      if (s = this._accept(5, !0)) {
        s = this._accept(5, !0) || this._accept(6, !0) || s, t.appendChild(new es(s));
        continue;
      }
      if (!(this._parseFormatString(t) || this._parseAnything(t)))
        return !1;
    }
    for (; !this._accept(
      4
      /* TokenType.CurlyClose */
    ); ) {
      if (this._token.type !== 14) {
        n += this._accept(void 0, !0);
        continue;
      }
      return !1;
    }
    try {
      t.regexp = new RegExp(i, n);
    } catch {
      return !1;
    }
    return e.transform = t, !0;
  }
  _parseFormatString(e) {
    const t = this._token;
    if (!this._accept(
      0
      /* TokenType.Dollar */
    ))
      return !1;
    let i = !1;
    this._accept(
      3
      /* TokenType.CurlyOpen */
    ) && (i = !0);
    const n = this._accept(8, !0);
    if (n)
      if (i) {
        if (this._accept(
          4
          /* TokenType.CurlyClose */
        ))
          return e.appendChild(new Nr(Number(n))), !0;
        if (!this._accept(
          1
          /* TokenType.Colon */
        ))
          return this._backTo(t), !1;
      } else return e.appendChild(new Nr(Number(n))), !0;
    else return this._backTo(t), !1;
    if (this._accept(
      6
      /* TokenType.Forwardslash */
    )) {
      const s = this._accept(9, !0);
      return !s || !this._accept(
        4
        /* TokenType.CurlyClose */
      ) ? (this._backTo(t), !1) : (e.appendChild(new Nr(Number(n), s)), !0);
    } else if (this._accept(
      11
      /* TokenType.Plus */
    )) {
      const s = this._until(
        4
        /* TokenType.CurlyClose */
      );
      if (s)
        return e.appendChild(new Nr(Number(n), void 0, s, void 0)), !0;
    } else if (this._accept(
      12
      /* TokenType.Dash */
    )) {
      const s = this._until(
        4
        /* TokenType.CurlyClose */
      );
      if (s)
        return e.appendChild(new Nr(Number(n), void 0, void 0, s)), !0;
    } else if (this._accept(
      13
      /* TokenType.QuestionMark */
    )) {
      const s = this._until(
        1
        /* TokenType.Colon */
      );
      if (s) {
        const o = this._until(
          4
          /* TokenType.CurlyClose */
        );
        if (o)
          return e.appendChild(new Nr(Number(n), void 0, s, o)), !0;
      }
    } else {
      const s = this._until(
        4
        /* TokenType.CurlyClose */
      );
      if (s)
        return e.appendChild(new Nr(Number(n), void 0, void 0, s)), !0;
    }
    return this._backTo(t), !1;
  }
  _parseAnything(e) {
    return this._token.type !== 14 ? (e.appendChild(new es(this._scanner.tokenText(this._token))), this._accept(void 0), !0) : !1;
  }
}
function kU(r, e, t) {
  var i, n, s, o;
  return (typeof t.insertText == "string" ? t.insertText === "" : t.insertText.snippet === "") ? {
    edits: (n = (i = t.additionalEdit) === null || i === void 0 ? void 0 : i.edits) !== null && n !== void 0 ? n : []
  } : {
    edits: [
      ...e.map((a) => new vc(r, { range: a, text: typeof t.insertText == "string" ? Mu.escape(t.insertText) + "$0" : t.insertText.snippet, insertAsSnippet: !0 })),
      ...(o = (s = t.additionalEdit) === null || s === void 0 ? void 0 : s.edits) !== null && o !== void 0 ? o : []
    ]
  };
}
function xU(r) {
  var e;
  function t(a, l) {
    return "mimeType" in a ? a.mimeType === l.handledMimeType : !!l.kind && a.kind.contains(l.kind);
  }
  const i = /* @__PURE__ */ new Map();
  for (const a of r)
    for (const l of (e = a.yieldTo) !== null && e !== void 0 ? e : [])
      for (const d of r)
        if (d !== a && t(l, d)) {
          let c = i.get(a);
          c || (c = [], i.set(a, c)), c.push(d);
        }
  if (!i.size)
    return Array.from(r);
  const n = /* @__PURE__ */ new Set(), s = [];
  function o(a) {
    if (!a.length)
      return [];
    const l = a[0];
    if (s.includes(l))
      return console.warn("Yield to cycle detected", l), a;
    if (n.has(l))
      return o(a.slice(1));
    let d = [];
    const c = i.get(l);
    return c && (s.push(l), d = o(c), s.pop()), n.add(l), [...d, l, ...o(a.slice(1))];
  }
  return o(Array.from(r));
}
var hce = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, uce = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
const gce = Fe.register({
  description: "inline-progress-widget",
  stickiness: 1,
  showIfCollapsed: !0,
  after: {
    content: _H,
    inlineClassName: "inline-editor-progress-decoration",
    inlineClassNameAffectsLetterSpacing: !0
  }
});
class LL extends P {
  constructor(e, t, i, n, s) {
    super(), this.typeId = e, this.editor = t, this.range = i, this.delegate = s, this.allowEditorOverflow = !1, this.suppressMouseDown = !0, this.create(n), this.editor.addContentWidget(this), this.editor.layoutContentWidget(this);
  }
  create(e) {
    this.domNode = X(".inline-progress-widget"), this.domNode.role = "button", this.domNode.title = e;
    const t = X("span.icon");
    this.domNode.append(t), t.classList.add(...Le.asClassNameArray(me.loading), "codicon-modifier-spin");
    const i = () => {
      const n = this.editor.getOption(
        67
        /* EditorOption.lineHeight */
      );
      this.domNode.style.height = `${n}px`, this.domNode.style.width = `${Math.ceil(0.8 * n)}px`;
    };
    i(), this._register(this.editor.onDidChangeConfiguration((n) => {
      (n.hasChanged(
        52
        /* EditorOption.fontSize */
      ) || n.hasChanged(
        67
        /* EditorOption.lineHeight */
      )) && i();
    })), this._register(W(this.domNode, Q.CLICK, (n) => {
      this.delegate.cancel();
    }));
  }
  getId() {
    return LL.baseId + "." + this.typeId;
  }
  getDomNode() {
    return this.domNode;
  }
  getPosition() {
    return {
      position: { lineNumber: this.range.startLineNumber, column: this.range.startColumn },
      preference: [
        0
        /* ContentWidgetPositionPreference.EXACT */
      ]
    };
  }
  dispose() {
    super.dispose(), this.editor.removeContentWidget(this);
  }
}
LL.baseId = "editor.widget.inlineProgressWidget";
let Iy = class extends P {
  constructor(e, t, i) {
    super(), this.id = e, this._editor = t, this._instantiationService = i, this._showDelay = 500, this._showPromise = this._register(new Yi()), this._currentWidget = new Yi(), this._operationIdPool = 0, this._currentDecorations = t.createDecorationsCollection();
  }
  async showWhile(e, t, i) {
    const n = this._operationIdPool++;
    this._currentOperation = n, this.clear(), this._showPromise.value = Mc(() => {
      const s = L.fromPositions(e);
      this._currentDecorations.set([{
        range: s,
        options: gce
      }]).length > 0 && (this._currentWidget.value = this._instantiationService.createInstance(LL, this.id, this._editor, s, t, i));
    }, this._showDelay);
    try {
      return await i;
    } finally {
      this._currentOperation === n && (this.clear(), this._currentOperation = void 0);
    }
  }
  clear() {
    this._showPromise.clear(), this._currentDecorations.clear(), this._currentWidget.clear();
  }
};
Iy = hce([
  uce(2, be)
], Iy);
var fce = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, hW = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, Gw;
let ss = Gw = class {
  static get(e) {
    return e.getContribution(Gw.ID);
  }
  constructor(e, t, i) {
    this._openerService = i, this._messageWidget = new Yi(), this._messageListeners = new q(), this._mouseOverMessage = !1, this._editor = e, this._visible = Gw.MESSAGE_VISIBLE.bindTo(t);
  }
  dispose() {
    var e;
    (e = this._message) === null || e === void 0 || e.dispose(), this._messageListeners.dispose(), this._messageWidget.dispose(), this._visible.reset();
  }
  showMessage(e, t) {
    Ls(Gr(e) ? e.value : e), this._visible.set(!0), this._messageWidget.clear(), this._messageListeners.clear(), this._message = Gr(e) ? z0(e, {
      actionHandler: {
        callback: (n) => {
          this.closeMessage(), uM(this._openerService, n, Gr(e) ? e.isTrusted : void 0);
        },
        disposables: this._messageListeners
      }
    }) : void 0, this._messageWidget.value = new uW(this._editor, t, typeof e == "string" ? e : this._message.element), this._messageListeners.add(ne.debounce(this._editor.onDidBlurEditorText, (n, s) => s, 0)(() => {
      this._mouseOverMessage || this._messageWidget.value && qi(Ln(), this._messageWidget.value.getDomNode()) || this.closeMessage();
    })), this._messageListeners.add(this._editor.onDidChangeCursorPosition(() => this.closeMessage())), this._messageListeners.add(this._editor.onDidDispose(() => this.closeMessage())), this._messageListeners.add(this._editor.onDidChangeModel(() => this.closeMessage())), this._messageListeners.add(W(this._messageWidget.value.getDomNode(), Q.MOUSE_ENTER, () => this._mouseOverMessage = !0, !0)), this._messageListeners.add(W(this._messageWidget.value.getDomNode(), Q.MOUSE_LEAVE, () => this._mouseOverMessage = !1, !0));
    let i;
    this._messageListeners.add(this._editor.onMouseMove((n) => {
      n.target.position && (i ? i.containsPosition(n.target.position) || this.closeMessage() : i = new L(t.lineNumber - 3, 1, n.target.position.lineNumber + 3, 1));
    }));
  }
  closeMessage() {
    this._visible.reset(), this._messageListeners.clear(), this._messageWidget.value && this._messageListeners.add(uW.fadeOut(this._messageWidget.value));
  }
};
ss.ID = "editor.contrib.messageController";
ss.MESSAGE_VISIBLE = new oe("messageVisible", !1, p("messageVisible", "Whether the editor is currently showing an inline message"));
ss = Gw = fce([
  hW(1, De),
  hW(2, Ys)
], ss);
const pce = Ui.bindToContribution(ss.get);
se(new pce({
  id: "leaveEditorMessage",
  precondition: ss.MESSAGE_VISIBLE,
  handler: (r) => r.closeMessage(),
  kbOpts: {
    weight: 130,
    primary: 9
    /* KeyCode.Escape */
  }
}));
let uW = class {
  static fadeOut(e) {
    const t = () => {
      e.dispose(), clearTimeout(i), e.getDomNode().removeEventListener("animationend", t);
    }, i = setTimeout(t, 110);
    return e.getDomNode().addEventListener("animationend", t), e.getDomNode().classList.add("fadeOut"), { dispose: t };
  }
  constructor(e, { lineNumber: t, column: i }, n) {
    this.allowEditorOverflow = !0, this.suppressMouseDown = !1, this._editor = e, this._editor.revealLinesInCenterIfOutsideViewport(
      t,
      t,
      0
      /* ScrollType.Smooth */
    ), this._position = { lineNumber: t, column: i }, this._domNode = document.createElement("div"), this._domNode.classList.add("monaco-editor-overlaymessage"), this._domNode.style.marginLeft = "-6px";
    const s = document.createElement("div");
    s.classList.add("anchor", "top"), this._domNode.appendChild(s);
    const o = document.createElement("div");
    typeof n == "string" ? (o.classList.add("message"), o.textContent = n) : (n.classList.add("message"), o.appendChild(n)), this._domNode.appendChild(o);
    const a = document.createElement("div");
    a.classList.add("anchor", "below"), this._domNode.appendChild(a), this._editor.addContentWidget(this), this._domNode.classList.add("fadeIn");
  }
  dispose() {
    this._editor.removeContentWidget(this);
  }
  getId() {
    return "messageoverlay";
  }
  getDomNode() {
    return this._domNode;
  }
  getPosition() {
    return {
      position: this._position,
      preference: [
        1,
        2
      ],
      positionAffinity: 1
    };
  }
  afterRender(e) {
    this._domNode.classList.toggle(
      "below",
      e === 2
      /* ContentWidgetPositionPreference.BELOW */
    );
  }
};
gt(
  ss.ID,
  ss,
  4
  /* EditorContributionInstantiation.Lazy */
);
function Vk(r, e) {
  return e && (r.stack || r.stacktrace) ? p("stackTrace.format", "{0}: {1}", fW(r), gW(r.stack) || gW(r.stacktrace)) : fW(r);
}
function gW(r) {
  return Array.isArray(r) ? r.join(`
`) : r;
}
function fW(r) {
  return r.code === "ERR_UNC_HOST_NOT_ALLOWED" ? `${r.message}. Please update the 'security.allowedUNCHosts' setting if you want to allow this host.` : typeof r.code == "string" && typeof r.errno == "number" && typeof r.syscall == "string" ? p("nodeExceptionMessage", "A system error occurred ({0})", r.message) : r.message || p("error.defaultMessage", "An unknown error occurred. Please consult the log for more details.");
}
function Ey(r = null, e = !1) {
  if (!r)
    return p("error.defaultMessage", "An unknown error occurred. Please consult the log for more details.");
  if (Array.isArray(r)) {
    const t = Yr(r), i = Ey(t[0], e);
    return t.length > 1 ? p("error.moreErrors", "{0} ({1} errors in total)", i, t.length) : i;
  }
  if (Ws(r))
    return r;
  if (r.detail) {
    const t = r.detail;
    if (t.error)
      return Vk(t.error, e);
    if (t.exception)
      return Vk(t.exception, e);
  }
  return r.stack ? Vk(r, e) : r.message ? r.message : p("error.defaultMessage", "An unknown error occurred. Please consult the log for more details.");
}
var IU = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Mf = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, nT;
let Ty = nT = class extends P {
  constructor(e, t, i, n, s, o, a, l, d, c) {
    super(), this.typeId = e, this.editor = t, this.showCommand = n, this.range = s, this.edits = o, this.onSelectNewEdit = a, this._contextMenuService = l, this._keybindingService = c, this.allowEditorOverflow = !0, this.suppressMouseDown = !0, this.create(), this.visibleContext = i.bindTo(d), this.visibleContext.set(!0), this._register(Se(() => this.visibleContext.reset())), this.editor.addContentWidget(this), this.editor.layoutContentWidget(this), this._register(Se(() => this.editor.removeContentWidget(this))), this._register(this.editor.onDidChangeCursorPosition((h) => {
      s.containsPosition(h.position) || this.dispose();
    })), this._register(ne.runAndSubscribe(c.onDidUpdateKeybindings, () => {
      this._updateButtonTitle();
    }));
  }
  _updateButtonTitle() {
    var e;
    const t = (e = this._keybindingService.lookupKeybinding(this.showCommand.id)) === null || e === void 0 ? void 0 : e.getLabel();
    this.button.element.title = this.showCommand.label + (t ? ` (${t})` : "");
  }
  create() {
    this.domNode = X(".post-edit-widget"), this.button = this._register(new iy(this.domNode, {
      supportIcons: !0
    })), this.button.label = "$(insert)", this._register(W(this.domNode, Q.CLICK, () => this.showSelector()));
  }
  getId() {
    return nT.baseId + "." + this.typeId;
  }
  getDomNode() {
    return this.domNode;
  }
  getPosition() {
    return {
      position: this.range.getEndPosition(),
      preference: [
        2
        /* ContentWidgetPositionPreference.BELOW */
      ]
    };
  }
  showSelector() {
    this._contextMenuService.showContextMenu({
      getAnchor: () => {
        const e = Ei(this.button.element);
        return { x: e.left + e.width, y: e.top + e.height };
      },
      getActions: () => this.edits.allEdits.map((e, t) => ru({
        id: "",
        label: e.title,
        checked: t === this.edits.activeEditIndex,
        run: () => {
          if (t !== this.edits.activeEditIndex)
            return this.onSelectNewEdit(t);
        }
      }))
    });
  }
};
Ty.baseId = "editor.widget.postEditWidget";
Ty = nT = IU([
  Mf(7, Zs),
  Mf(8, De),
  Mf(9, _t)
], Ty);
let Ny = class extends P {
  constructor(e, t, i, n, s, o, a) {
    super(), this._id = e, this._editor = t, this._visibleContext = i, this._showCommand = n, this._instantiationService = s, this._bulkEditService = o, this._notificationService = a, this._currentWidget = this._register(new Yi()), this._register(ne.any(t.onDidChangeModel, t.onDidChangeModelContent)(() => this.clear()));
  }
  async applyEditAndShowIfNeeded(e, t, i, n, s) {
    const o = this._editor.getModel();
    if (!o || !e.length)
      return;
    const a = t.allEdits.at(t.activeEditIndex);
    if (!a)
      return;
    const l = async (_) => {
      const v = this._editor.getModel();
      v && (await v.undo(), this.applyEditAndShowIfNeeded(e, { activeEditIndex: _, allEdits: t.allEdits }, i, n, s));
    }, d = (_, v) => {
      cl(_) || (this._notificationService.error(v), i && this.show(e[0], t, l));
    };
    let c;
    try {
      c = await n(a, s);
    } catch (_) {
      return d(_, p("resolveError", `Error resolving edit '{0}':
{1}`, a.title, Ey(_)));
    }
    if (s.isCancellationRequested)
      return;
    const h = kU(o.uri, e, c), u = e[0], g = o.deltaDecorations([], [{
      range: u,
      options: {
        description: "paste-line-suffix",
        stickiness: 0
        /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */
      }
    }]);
    this._editor.focus();
    let f, m;
    try {
      f = await this._bulkEditService.apply(h, { editor: this._editor, token: s }), m = o.getDecorationRange(g[0]);
    } catch (_) {
      return d(_, p("applyError", `Error applying edit '{0}':
{1}`, a.title, Ey(_)));
    } finally {
      o.deltaDecorations(g, []);
    }
    s.isCancellationRequested || i && f.isApplied && t.allEdits.length > 1 && this.show(m ?? u, t, l);
  }
  show(e, t, i) {
    this.clear(), this._editor.hasModel() && (this._currentWidget.value = this._instantiationService.createInstance(Ty, this._id, this._editor, this._visibleContext, this._showCommand, e, t, i));
  }
  clear() {
    this._currentWidget.clear();
  }
  tryShowSelector() {
    var e;
    (e = this._currentWidget.value) === null || e === void 0 || e.showSelector();
  }
};
Ny = IU([
  Mf(4, be),
  Mf(5, yb),
  Mf(6, xi)
], Ny);
var mce = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Cg = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, Rh;
const EU = "editor.changePasteType", oR = new oe("pasteWidgetVisible", !1, p("pasteWidgetVisible", "Whether the paste widget is showing")), zk = "application/vnd.code.copyMetadata";
let ll = Rh = class extends P {
  static get(e) {
    return e.getContribution(Rh.ID);
  }
  constructor(e, t, i, n, s, o, a) {
    super(), this._bulkEditService = i, this._clipboardService = n, this._languageFeaturesService = s, this._quickInputService = o, this._progressService = a, this._editor = e;
    const l = e.getContainerDomNode();
    this._register(W(l, "copy", (d) => this.handleCopy(d))), this._register(W(l, "cut", (d) => this.handleCopy(d))), this._register(W(l, "paste", (d) => this.handlePaste(d), !0)), this._pasteProgressManager = this._register(new Iy("pasteIntoEditor", e, t)), this._postPasteWidgetManager = this._register(t.createInstance(Ny, "pasteIntoEditor", e, oR, { id: EU, label: p("postPasteWidgetTitle", "Show paste options...") }));
  }
  changePasteType() {
    this._postPasteWidgetManager.tryShowSelector();
  }
  pasteAs(e) {
    this._editor.focus();
    try {
      this._pasteAsActionContext = { preferred: e }, xp().execCommand("paste");
    } finally {
      this._pasteAsActionContext = void 0;
    }
  }
  clearWidgets() {
    this._postPasteWidgetManager.clear();
  }
  isPasteAsEnabled() {
    return this._editor.getOption(
      85
      /* EditorOption.pasteAs */
    ).enabled && !this._editor.getOption(
      91
      /* EditorOption.readOnly */
    );
  }
  async finishedPaste() {
    await this._currentPasteOperation;
  }
  handleCopy(e) {
    var t, i;
    if (!this._editor.hasTextFocus() || (Gu && this._clipboardService.writeResources([]), !e.clipboardData || !this.isPasteAsEnabled()))
      return;
    const n = this._editor.getModel(), s = this._editor.getSelections();
    if (!n || !(s != null && s.length))
      return;
    const o = this._editor.getOption(
      37
      /* EditorOption.emptySelectionClipboard */
    );
    let a = s;
    const l = s.length === 1 && s[0].isEmpty();
    if (l) {
      if (!o)
        return;
      a = [new L(a[0].startLineNumber, 1, a[0].startLineNumber, 1 + n.getLineLength(a[0].startLineNumber))];
    }
    const d = (t = this._editor._getViewModel()) === null || t === void 0 ? void 0 : t.getPlainTextToCopy(s, o, Ks), h = {
      multicursorText: Array.isArray(d) ? d : null,
      pasteOnNewLine: l,
      mode: null
    }, u = this._languageFeaturesService.documentPasteEditProvider.ordered(n).filter((v) => !!v.prepareDocumentPaste);
    if (!u.length) {
      this.setCopyMetadata(e.clipboardData, { defaultPastePayload: h });
      return;
    }
    const g = wU(e.clipboardData), f = u.flatMap((v) => {
      var b;
      return (b = v.copyMimeTypes) !== null && b !== void 0 ? b : [];
    }), m = SL();
    this.setCopyMetadata(e.clipboardData, {
      id: m,
      providerCopyMimeTypes: f,
      defaultPastePayload: h
    });
    const _ = Zi(async (v) => {
      const b = Yr(await Promise.all(u.map(async (C) => {
        try {
          return await C.prepareDocumentPaste(n, a, g, v);
        } catch (w) {
          console.error(w);
          return;
        }
      })));
      b.reverse();
      for (const C of b)
        for (const [w, S] of C)
          g.replace(w, S);
      return g;
    });
    (i = Rh._currentCopyOperation) === null || i === void 0 || i.dataTransferPromise.cancel(), Rh._currentCopyOperation = { handle: m, dataTransferPromise: _ };
  }
  async handlePaste(e) {
    var t, i, n, s;
    if (!e.clipboardData || !this._editor.hasTextFocus())
      return;
    (t = ss.get(this._editor)) === null || t === void 0 || t.closeMessage(), (i = this._currentPasteOperation) === null || i === void 0 || i.cancel(), this._currentPasteOperation = void 0;
    const o = this._editor.getModel(), a = this._editor.getSelections();
    if (!(a != null && a.length) || !o || !this.isPasteAsEnabled() && !this._pasteAsActionContext)
      return;
    const l = this.fetchCopyMetadata(e), d = SU(e.clipboardData);
    d.delete(zk);
    const c = [
      ...e.clipboardData.types,
      ...(n = l == null ? void 0 : l.providerCopyMimeTypes) !== null && n !== void 0 ? n : [],
      // TODO: always adds `uri-list` because this get set if there are resources in the system clipboard.
      // However we can only check the system clipboard async. For this early check, just add it in.
      // We filter providers again once we have the final dataTransfer we will use.
      fi.uriList
    ], h = this._languageFeaturesService.documentPasteEditProvider.ordered(o).filter((u) => {
      var g, f;
      const m = (g = this._pasteAsActionContext) === null || g === void 0 ? void 0 : g.preferred;
      return m && u.providedPasteEditKinds && !this.providerMatchesPreference(u, m) ? !1 : (f = u.pasteMimeTypes) === null || f === void 0 ? void 0 : f.some((_) => bU(_, c));
    });
    if (!h.length) {
      !((s = this._pasteAsActionContext) === null || s === void 0) && s.preferred && this.showPasteAsNoEditMessage(a, this._pasteAsActionContext.preferred);
      return;
    }
    e.preventDefault(), e.stopImmediatePropagation(), this._pasteAsActionContext ? this.showPasteAsPick(this._pasteAsActionContext.preferred, h, a, d, l) : this.doPasteInline(h, a, d, l, e);
  }
  showPasteAsNoEditMessage(e, t) {
    var i;
    (i = ss.get(this._editor)) === null || i === void 0 || i.showMessage(p("pasteAsError", "No paste edits for '{0}' found", t instanceof kt ? t.value : t.providerId), e[0].getStartPosition());
  }
  doPasteInline(e, t, i, n, s) {
    const o = Zi(async (a) => {
      const l = this._editor;
      if (!l.hasModel())
        return;
      const d = l.getModel(), c = new zc(l, 3, void 0, a);
      try {
        if (await this.mergeInDataFromCopy(i, n, c.token), c.token.isCancellationRequested)
          return;
        const h = e.filter((f) => this.isSupportedPasteProvider(f, i));
        if (!h.length || h.length === 1 && h[0] instanceof fd)
          return this.applyDefaultPasteHandler(i, n, c.token, s);
        const u = {
          triggerKind: bx.Automatic
        }, g = await this.getPasteEdits(h, i, d, t, u, c.token);
        if (c.token.isCancellationRequested)
          return;
        if (g.length === 1 && g[0].provider instanceof fd)
          return this.applyDefaultPasteHandler(i, n, c.token, s);
        if (g.length) {
          const f = l.getOption(
            85
            /* EditorOption.pasteAs */
          ).showPasteSelector === "afterPaste";
          return this._postPasteWidgetManager.applyEditAndShowIfNeeded(t, { activeEditIndex: 0, allEdits: g }, f, async (m, _) => {
            var v, b;
            const C = await ((b = (v = m.provider).resolveDocumentPasteEdit) === null || b === void 0 ? void 0 : b.call(v, m, _));
            return C && (m.additionalEdit = C.additionalEdit), m;
          }, c.token);
        }
        await this.applyDefaultPasteHandler(i, n, c.token, s);
      } finally {
        c.dispose(), this._currentPasteOperation === o && (this._currentPasteOperation = void 0);
      }
    });
    this._pasteProgressManager.showWhile(t[0].getEndPosition(), p("pasteIntoEditorProgress", "Running paste handlers. Click to cancel"), o), this._currentPasteOperation = o;
  }
  showPasteAsPick(e, t, i, n, s) {
    const o = Zi(async (a) => {
      const l = this._editor;
      if (!l.hasModel())
        return;
      const d = l.getModel(), c = new zc(l, 3, void 0, a);
      try {
        if (await this.mergeInDataFromCopy(n, s, c.token), c.token.isCancellationRequested)
          return;
        let h = t.filter((_) => this.isSupportedPasteProvider(_, n, e));
        e && (h = h.filter((_) => this.providerMatchesPreference(_, e)));
        const u = {
          triggerKind: bx.PasteAs,
          only: e && e instanceof kt ? e : void 0
        };
        let g = await this.getPasteEdits(h, n, d, i, u, c.token);
        if (c.token.isCancellationRequested)
          return;
        if (e && (g = g.filter((_) => e instanceof kt ? e.contains(_.kind) : e.providerId === _.provider.id)), !g.length) {
          u.only && this.showPasteAsNoEditMessage(i, u.only);
          return;
        }
        let f;
        if (e)
          f = g.at(0);
        else {
          const _ = await this._quickInputService.pick(g.map((v) => {
            var b;
            return {
              label: v.title,
              description: (b = v.kind) === null || b === void 0 ? void 0 : b.value,
              edit: v
            };
          }), {
            placeHolder: p("pasteAsPickerPlaceholder", "Select Paste Action")
          });
          f = _ == null ? void 0 : _.edit;
        }
        if (!f)
          return;
        const m = kU(d.uri, i, f);
        await this._bulkEditService.apply(m, { editor: this._editor });
      } finally {
        c.dispose(), this._currentPasteOperation === o && (this._currentPasteOperation = void 0);
      }
    });
    this._progressService.withProgress({
      location: 10,
      title: p("pasteAsProgress", "Running paste handlers")
    }, () => o);
  }
  setCopyMetadata(e, t) {
    e.setData(zk, JSON.stringify(t));
  }
  fetchCopyMetadata(e) {
    var t;
    if (!e.clipboardData)
      return;
    const i = e.clipboardData.getData(zk);
    if (i)
      try {
        return JSON.parse(i);
      } catch {
        return;
      }
    const [n, s] = Yx.getTextData(e.clipboardData);
    if (s)
      return {
        defaultPastePayload: {
          mode: s.mode,
          multicursorText: (t = s.multicursorText) !== null && t !== void 0 ? t : null,
          pasteOnNewLine: !!s.isFromEmptySelection
        }
      };
  }
  async mergeInDataFromCopy(e, t, i) {
    var n;
    if (t != null && t.id && ((n = Rh._currentCopyOperation) === null || n === void 0 ? void 0 : n.handle) === t.id) {
      const s = await Rh._currentCopyOperation.dataTransferPromise;
      if (i.isCancellationRequested)
        return;
      for (const [o, a] of s)
        e.replace(o, a);
    }
    if (!e.has(fi.uriList)) {
      const s = await this._clipboardService.readResources();
      if (i.isCancellationRequested)
        return;
      s.length && e.append(fi.uriList, tR(yL.create(s)));
    }
  }
  async getPasteEdits(e, t, i, n, s, o) {
    const a = await rb(Promise.all(e.map(async (d) => {
      var c, h;
      try {
        const u = await ((c = d.provideDocumentPasteEdits) === null || c === void 0 ? void 0 : c.call(d, i, n, t, s, o));
        return (h = u == null ? void 0 : u.edits) === null || h === void 0 ? void 0 : h.map((g) => ({ ...g, provider: d }));
      } catch (u) {
        console.error(u);
      }
    })), o), l = Yr(a ?? []).flat().filter((d) => !s.only || s.only.contains(d.kind));
    return xU(l);
  }
  async applyDefaultPasteHandler(e, t, i, n) {
    var s, o, a, l;
    const d = (s = e.get(fi.text)) !== null && s !== void 0 ? s : e.get("text"), c = (o = await (d == null ? void 0 : d.asString())) !== null && o !== void 0 ? o : "";
    if (i.isCancellationRequested)
      return;
    const h = {
      clipboardEvent: n,
      text: c,
      pasteOnNewLine: (a = t == null ? void 0 : t.defaultPastePayload.pasteOnNewLine) !== null && a !== void 0 ? a : !1,
      multicursorText: (l = t == null ? void 0 : t.defaultPastePayload.multicursorText) !== null && l !== void 0 ? l : null,
      mode: null
    };
    this._editor.trigger("keyboard", "paste", h);
  }
  /**
   * Filter out providers if they:
   * - Don't handle any of the data transfer types we have
   * - Don't match the preferred paste kind
   */
  isSupportedPasteProvider(e, t, i) {
    var n;
    return !((n = e.pasteMimeTypes) === null || n === void 0) && n.some((s) => t.matches(s)) ? !i || this.providerMatchesPreference(e, i) : !1;
  }
  providerMatchesPreference(e, t) {
    return t instanceof kt ? e.providedPasteEditKinds ? e.providedPasteEditKinds.some((i) => t.contains(i)) : !0 : e.id === t.providerId;
  }
};
ll.ID = "editor.contrib.copyPasteActionController";
ll = Rh = mce([
  Cg(1, be),
  Cg(2, yb),
  Cg(3, Dd),
  Cg(4, he),
  Cg(5, $o),
  Cg(6, gz)
], ll);
const Ru = "9_cutcopypaste", _ce = zr || document.queryCommandSupported("cut"), TU = zr || document.queryCommandSupported("copy"), vce = typeof navigator.clipboard > "u" || Oo ? document.queryCommandSupported("paste") : !0;
function rR(r) {
  return r.register(), r;
}
const bce = _ce ? rR(new Ep({
  id: "editor.action.clipboardCutAction",
  precondition: void 0,
  kbOpts: (
    // Do not bind cut keybindings in the browser,
    // since browsers do that for us and it avoids security prompts
    zr ? {
      primary: 2102,
      win: { primary: 2102, secondary: [
        1044
        /* KeyCode.Delete */
      ] },
      weight: 100
      /* KeybindingWeight.EditorContrib */
    } : void 0
  ),
  menuOpts: [{
    menuId: D.MenubarEditMenu,
    group: "2_ccp",
    title: p({ key: "miCut", comment: ["&& denotes a mnemonic"] }, "Cu&&t"),
    order: 1
  }, {
    menuId: D.EditorContext,
    group: Ru,
    title: p("actions.clipboard.cutLabel", "Cut"),
    when: x.writable,
    order: 1
  }, {
    menuId: D.CommandPalette,
    group: "",
    title: p("actions.clipboard.cutLabel", "Cut"),
    order: 1
  }, {
    menuId: D.SimpleEditorContext,
    group: Ru,
    title: p("actions.clipboard.cutLabel", "Cut"),
    when: x.writable,
    order: 1
  }]
})) : void 0, Cce = TU ? rR(new Ep({
  id: "editor.action.clipboardCopyAction",
  precondition: void 0,
  kbOpts: (
    // Do not bind copy keybindings in the browser,
    // since browsers do that for us and it avoids security prompts
    zr ? {
      primary: 2081,
      win: { primary: 2081, secondary: [
        2067
        /* KeyCode.Insert */
      ] },
      weight: 100
      /* KeybindingWeight.EditorContrib */
    } : void 0
  ),
  menuOpts: [{
    menuId: D.MenubarEditMenu,
    group: "2_ccp",
    title: p({ key: "miCopy", comment: ["&& denotes a mnemonic"] }, "&&Copy"),
    order: 2
  }, {
    menuId: D.EditorContext,
    group: Ru,
    title: p("actions.clipboard.copyLabel", "Copy"),
    order: 2
  }, {
    menuId: D.CommandPalette,
    group: "",
    title: p("actions.clipboard.copyLabel", "Copy"),
    order: 1
  }, {
    menuId: D.SimpleEditorContext,
    group: Ru,
    title: p("actions.clipboard.copyLabel", "Copy"),
    order: 2
  }]
})) : void 0;
on.appendMenuItem(D.MenubarEditMenu, { submenu: D.MenubarCopy, title: Me("copy as", "Copy As"), group: "2_ccp", order: 3 });
on.appendMenuItem(D.EditorContext, { submenu: D.EditorContextCopy, title: Me("copy as", "Copy As"), group: Ru, order: 3 });
on.appendMenuItem(D.EditorContext, { submenu: D.EditorContextShare, title: Me("share", "Share"), group: "11_share", order: -1, when: U.and(U.notEquals("resourceScheme", "output"), x.editorTextFocus) });
on.appendMenuItem(D.ExplorerContext, { submenu: D.ExplorerContextShare, title: Me("share", "Share"), group: "11_share", order: -1 });
const Uk = vce ? rR(new Ep({
  id: "editor.action.clipboardPasteAction",
  precondition: void 0,
  kbOpts: (
    // Do not bind paste keybindings in the browser,
    // since browsers do that for us and it avoids security prompts
    zr ? {
      primary: 2100,
      win: { primary: 2100, secondary: [
        1043
        /* KeyCode.Insert */
      ] },
      linux: { primary: 2100, secondary: [
        1043
        /* KeyCode.Insert */
      ] },
      weight: 100
      /* KeybindingWeight.EditorContrib */
    } : void 0
  ),
  menuOpts: [{
    menuId: D.MenubarEditMenu,
    group: "2_ccp",
    title: p({ key: "miPaste", comment: ["&& denotes a mnemonic"] }, "&&Paste"),
    order: 4
  }, {
    menuId: D.EditorContext,
    group: Ru,
    title: p("actions.clipboard.pasteLabel", "Paste"),
    when: x.writable,
    order: 4
  }, {
    menuId: D.CommandPalette,
    group: "",
    title: p("actions.clipboard.pasteLabel", "Paste"),
    order: 1
  }, {
    menuId: D.SimpleEditorContext,
    group: Ru,
    title: p("actions.clipboard.pasteLabel", "Paste"),
    when: x.writable,
    order: 4
  }]
})) : void 0;
class wce extends ae {
  constructor() {
    super({
      id: "editor.action.clipboardCopyWithSyntaxHighlightingAction",
      label: p("actions.clipboard.copyWithSyntaxHighlightingLabel", "Copy With Syntax Highlighting"),
      alias: "Copy With Syntax Highlighting",
      precondition: void 0,
      kbOpts: {
        kbExpr: x.textInputFocus,
        primary: 0,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(e, t) {
    !t.hasModel() || !t.getOption(
      37
      /* EditorOption.emptySelectionClipboard */
    ) && t.getSelection().isEmpty() || (Gx.forceCopyWithSyntaxHighlighting = !0, t.focus(), t.getContainerDomNode().ownerDocument.execCommand("copy"), Gx.forceCopyWithSyntaxHighlighting = !1);
  }
}
function NU(r, e) {
  r && (r.addImplementation(1e4, "code-editor", (t, i) => {
    const n = t.get(ht).getFocusedCodeEditor();
    if (n && n.hasTextFocus()) {
      const s = n.getOption(
        37
        /* EditorOption.emptySelectionClipboard */
      ), o = n.getSelection();
      return o && o.isEmpty() && !s || n.getContainerDomNode().ownerDocument.execCommand(e), !0;
    }
    return !1;
  }), r.addImplementation(0, "generic-dom", (t, i) => (xp().execCommand(e), !0)));
}
NU(bce, "cut");
NU(Cce, "copy");
Uk && (Uk.addImplementation(1e4, "code-editor", (r, e) => {
  var t, i;
  const n = r.get(ht), s = r.get(Dd), o = n.getFocusedCodeEditor();
  return o && o.hasTextFocus() ? o.getContainerDomNode().ownerDocument.execCommand("paste") ? (i = (t = ll.get(o)) === null || t === void 0 ? void 0 : t.finishedPaste()) !== null && i !== void 0 ? i : Promise.resolve() : Gu ? (async () => {
    const l = await s.readText();
    if (l !== "") {
      const d = q_.INSTANCE.get(l);
      let c = !1, h = null, u = null;
      d && (c = o.getOption(
        37
        /* EditorOption.emptySelectionClipboard */
      ) && !!d.isFromEmptySelection, h = typeof d.multicursorText < "u" ? d.multicursorText : null, u = d.mode), o.trigger("keyboard", "paste", {
        text: l,
        pasteOnNewLine: c,
        multicursorText: h,
        mode: u
      });
    }
  })() : !0 : !1;
}), Uk.addImplementation(0, "generic-dom", (r, e) => (xp().execCommand("paste"), !0)));
TU && Y(wce);
const qt = new class {
  constructor() {
    this.QuickFix = new kt("quickfix"), this.Refactor = new kt("refactor"), this.RefactorExtract = this.Refactor.append("extract"), this.RefactorInline = this.Refactor.append("inline"), this.RefactorMove = this.Refactor.append("move"), this.RefactorRewrite = this.Refactor.append("rewrite"), this.Notebook = new kt("notebook"), this.Source = new kt("source"), this.SourceOrganizeImports = this.Source.append("organizeImports"), this.SourceFixAll = this.Source.append("fixAll"), this.SurroundWith = this.Refactor.append("surround");
  }
}();
var $s;
(function(r) {
  r.Refactor = "refactor", r.RefactorPreview = "refactor preview", r.Lightbulb = "lightbulb", r.Default = "other (default)", r.SourceAction = "source action", r.QuickFix = "quick fix action", r.FixAll = "fix all", r.OrganizeImports = "organize imports", r.AutoFix = "auto fix", r.QuickFixHover = "quick fix hover window", r.OnSave = "save participants", r.ProblemsView = "problems view";
})($s || ($s = {}));
function Sce(r, e) {
  return !(r.include && !r.include.intersects(e) || r.excludes && r.excludes.some((t) => MU(e, t, r.include)) || !r.includeSourceActions && qt.Source.contains(e));
}
function yce(r, e) {
  const t = e.kind ? new kt(e.kind) : void 0;
  return !(r.include && (!t || !r.include.contains(t)) || r.excludes && t && r.excludes.some((i) => MU(t, i, r.include)) || !r.includeSourceActions && t && qt.Source.contains(t) || r.onlyIncludePreferredActions && !e.isPreferred);
}
function MU(r, e, t) {
  return !(!e.contains(r) || t && e.contains(t));
}
class Wa {
  static fromUser(e, t) {
    return !e || typeof e != "object" ? new Wa(t.kind, t.apply, !1) : new Wa(Wa.getKindFromUser(e, t.kind), Wa.getApplyFromUser(e, t.apply), Wa.getPreferredUser(e));
  }
  static getApplyFromUser(e, t) {
    switch (typeof e.apply == "string" ? e.apply.toLowerCase() : "") {
      case "first":
        return "first";
      case "never":
        return "never";
      case "ifsingle":
        return "ifSingle";
      default:
        return t;
    }
  }
  static getKindFromUser(e, t) {
    return typeof e.kind == "string" ? new kt(e.kind) : t;
  }
  static getPreferredUser(e) {
    return typeof e.preferred == "boolean" ? e.preferred : !1;
  }
  constructor(e, t, i) {
    this.kind = e, this.apply = t, this.preferred = i;
  }
}
class Lce {
  constructor(e, t, i) {
    this.action = e, this.provider = t, this.highlightRange = i;
  }
  async resolve(e) {
    var t;
    if (!((t = this.provider) === null || t === void 0) && t.resolveCodeAction && !this.action.edit) {
      let i;
      try {
        i = await this.provider.resolveCodeAction(this.action, e);
      } catch (n) {
        _i(n);
      }
      i && (this.action.edit = i.edit);
    }
    return this;
  }
}
const RU = "editor.action.codeAction", aR = "editor.action.quickFix", AU = "editor.action.autoFix", PU = "editor.action.refactor", OU = "editor.action.sourceAction", lR = "editor.action.organizeImports", dR = "editor.action.fixAll";
class w_ extends P {
  static codeActionsPreferredComparator(e, t) {
    return e.isPreferred && !t.isPreferred ? -1 : !e.isPreferred && t.isPreferred ? 1 : 0;
  }
  static codeActionsComparator({ action: e }, { action: t }) {
    return e.isAI && !t.isAI ? 1 : !e.isAI && t.isAI ? -1 : Rn(e.diagnostics) ? Rn(t.diagnostics) ? w_.codeActionsPreferredComparator(e, t) : -1 : Rn(t.diagnostics) ? 1 : w_.codeActionsPreferredComparator(e, t);
  }
  constructor(e, t, i) {
    super(), this.documentation = t, this._register(i), this.allActions = [...e].sort(w_.codeActionsComparator), this.validActions = this.allActions.filter(({ action: n }) => !n.disabled);
  }
  get hasAutoFix() {
    return this.validActions.some(({ action: e }) => !!e.kind && qt.QuickFix.contains(new kt(e.kind)) && !!e.isPreferred);
  }
  get hasAIFix() {
    return this.validActions.some(({ action: e }) => !!e.isAI);
  }
  get allAIFixes() {
    return this.validActions.every(({ action: e }) => !!e.isAI);
  }
}
const pW = { actions: [], documentation: void 0 };
async function S_(r, e, t, i, n, s) {
  var o;
  const a = i.filter || {}, l = {
    ...a,
    excludes: [...a.excludes || [], qt.Notebook]
  }, d = {
    only: (o = a.include) === null || o === void 0 ? void 0 : o.value,
    trigger: i.type
  }, c = new ZM(e, s), h = i.type === 2, u = Dce(r, e, h ? l : a), g = new q(), f = u.map(async (_) => {
    try {
      n.report(_);
      const v = await _.provideCodeActions(e, t, d, c.token);
      if (v && g.add(v), c.token.isCancellationRequested)
        return pW;
      const b = ((v == null ? void 0 : v.actions) || []).filter((w) => w && yce(a, w)), C = xce(_, b, a.include);
      return {
        actions: b.map((w) => new Lce(w, _)),
        documentation: C
      };
    } catch (v) {
      if (cl(v))
        throw v;
      return _i(v), pW;
    }
  }), m = r.onDidChange(() => {
    const _ = r.all(e);
    ci(_, u) || c.cancel();
  });
  try {
    const _ = await Promise.all(f), v = _.map((C) => C.actions).flat(), b = [
      ...Yr(_.map((C) => C.documentation)),
      ...kce(r, e, i, v)
    ];
    return new w_(v, b, g);
  } finally {
    m.dispose(), c.dispose();
  }
}
function Dce(r, e, t) {
  return r.all(e).filter((i) => i.providedCodeActionKinds ? i.providedCodeActionKinds.some((n) => Sce(t, new kt(n))) : !0);
}
function* kce(r, e, t, i) {
  var n, s, o;
  if (e && i.length)
    for (const a of r.all(e))
      a._getAdditionalMenuItems && (yield* (n = a._getAdditionalMenuItems) === null || n === void 0 ? void 0 : n.call(a, { trigger: t.type, only: (o = (s = t.filter) === null || s === void 0 ? void 0 : s.include) === null || o === void 0 ? void 0 : o.value }, i.map((l) => l.action)));
}
function xce(r, e, t) {
  if (!r.documentation)
    return;
  const i = r.documentation.map((n) => ({ kind: new kt(n.kind), command: n.command }));
  if (t) {
    let n;
    for (const s of i)
      s.kind.contains(t) && (n ? n.kind.contains(s.kind) && (n = s) : n = s);
    if (n)
      return n == null ? void 0 : n.command;
  }
  for (const n of e)
    if (n.kind) {
      for (const s of i)
        if (s.kind.contains(new kt(n.kind)))
          return s.command;
    }
}
var tu;
(function(r) {
  r.OnSave = "onSave", r.FromProblemsView = "fromProblemsView", r.FromCodeActions = "fromCodeActions", r.FromAILightbulb = "fromAILightbulb";
})(tu || (tu = {}));
async function Ice(r, e, t, i, n = at.None) {
  var s;
  const o = r.get(yb), a = r.get($t), l = r.get(kn), d = r.get(xi);
  if (l.publicLog2("codeAction.applyCodeAction", {
    codeActionTitle: e.action.title,
    codeActionKind: e.action.kind,
    codeActionIsPreferred: !!e.action.isPreferred,
    reason: t
  }), await e.resolve(n), !n.isCancellationRequested && !(!((s = e.action.edit) === null || s === void 0) && s.edits.length && !(await o.apply(e.action.edit, {
    editor: i == null ? void 0 : i.editor,
    label: e.action.title,
    quotableLabel: e.action.title,
    code: "undoredo.codeAction",
    respectAutoSaveConfig: t !== tu.OnSave,
    showPreview: i == null ? void 0 : i.preview
  })).isApplied) && e.action.command)
    try {
      await a.executeCommand(e.action.command.id, ...e.action.command.arguments || []);
    } catch (c) {
      const h = Ece(c);
      d.error(typeof h == "string" ? h : p("applyCodeActionFailed", "An unknown error occurred while applying the code action"));
    }
}
function Ece(r) {
  return typeof r == "string" ? r : r instanceof Error && typeof r.message == "string" ? r.message : void 0;
}
st.registerCommand("_executeCodeActionProvider", async function(r, e, t, i, n) {
  if (!(e instanceof Ee))
    throw Ro();
  const { codeActionProvider: s } = r.get(he), o = r.get(ii).getModel(e);
  if (!o)
    throw Ro();
  const a = ge.isISelection(t) ? ge.liftSelection(t) : L.isIRange(t) ? o.validateRange(t) : void 0;
  if (!a)
    throw Ro();
  const l = typeof i == "string" ? new kt(i) : void 0, d = await S_(s, o, a, { type: 1, triggerAction: $s.Default, filter: { includeSourceActions: !0, include: l } }, id.None, at.None), c = [], h = Math.min(d.validActions.length, typeof n == "number" ? n : 0);
  for (let u = 0; u < h; u++)
    c.push(d.validActions[u].resolve(at.None));
  try {
    return await Promise.all(c), d.validActions.map((u) => u.action);
  } finally {
    setTimeout(() => d.dispose(), 100);
  }
});
var Tce = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Nce = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, sT;
let My = sT = class {
  constructor(e) {
    this.keybindingService = e;
  }
  getResolver() {
    const e = new bd(() => this.keybindingService.getKeybindings().filter((t) => sT.codeActionCommands.indexOf(t.command) >= 0).filter((t) => t.resolvedKeybinding).map((t) => {
      let i = t.commandArgs;
      return t.command === lR ? i = { kind: qt.SourceOrganizeImports.value } : t.command === dR && (i = { kind: qt.SourceFixAll.value }), {
        resolvedKeybinding: t.resolvedKeybinding,
        ...Wa.fromUser(i, {
          kind: kt.None,
          apply: "never"
          /* CodeActionAutoApply.Never */
        })
      };
    }));
    return (t) => {
      if (t.kind) {
        const i = this.bestKeybindingForCodeAction(t, e.value);
        return i == null ? void 0 : i.resolvedKeybinding;
      }
    };
  }
  bestKeybindingForCodeAction(e, t) {
    if (!e.kind)
      return;
    const i = new kt(e.kind);
    return t.filter((n) => n.kind.contains(i)).filter((n) => n.preferred ? e.isPreferred : !0).reduceRight((n, s) => n ? n.kind.contains(s.kind) ? s : n : s, void 0);
  }
};
My.codeActionCommands = [
  PU,
  RU,
  OU,
  lR,
  dR
];
My = sT = Tce([
  Nce(0, _t)
], My);
I("symbolIcon.arrayForeground", {
  dark: ie,
  light: ie,
  hcDark: ie,
  hcLight: ie
}, p("symbolIcon.arrayForeground", "The foreground color for array symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
I("symbolIcon.booleanForeground", {
  dark: ie,
  light: ie,
  hcDark: ie,
  hcLight: ie
}, p("symbolIcon.booleanForeground", "The foreground color for boolean symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
I("symbolIcon.classForeground", {
  dark: "#EE9D28",
  light: "#D67E00",
  hcDark: "#EE9D28",
  hcLight: "#D67E00"
}, p("symbolIcon.classForeground", "The foreground color for class symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
I("symbolIcon.colorForeground", {
  dark: ie,
  light: ie,
  hcDark: ie,
  hcLight: ie
}, p("symbolIcon.colorForeground", "The foreground color for color symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
I("symbolIcon.constantForeground", {
  dark: ie,
  light: ie,
  hcDark: ie,
  hcLight: ie
}, p("symbolIcon.constantForeground", "The foreground color for constant symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
I("symbolIcon.constructorForeground", {
  dark: "#B180D7",
  light: "#652D90",
  hcDark: "#B180D7",
  hcLight: "#652D90"
}, p("symbolIcon.constructorForeground", "The foreground color for constructor symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
I("symbolIcon.enumeratorForeground", {
  dark: "#EE9D28",
  light: "#D67E00",
  hcDark: "#EE9D28",
  hcLight: "#D67E00"
}, p("symbolIcon.enumeratorForeground", "The foreground color for enumerator symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
I("symbolIcon.enumeratorMemberForeground", {
  dark: "#75BEFF",
  light: "#007ACC",
  hcDark: "#75BEFF",
  hcLight: "#007ACC"
}, p("symbolIcon.enumeratorMemberForeground", "The foreground color for enumerator member symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
I("symbolIcon.eventForeground", {
  dark: "#EE9D28",
  light: "#D67E00",
  hcDark: "#EE9D28",
  hcLight: "#D67E00"
}, p("symbolIcon.eventForeground", "The foreground color for event symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
I("symbolIcon.fieldForeground", {
  dark: "#75BEFF",
  light: "#007ACC",
  hcDark: "#75BEFF",
  hcLight: "#007ACC"
}, p("symbolIcon.fieldForeground", "The foreground color for field symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
I("symbolIcon.fileForeground", {
  dark: ie,
  light: ie,
  hcDark: ie,
  hcLight: ie
}, p("symbolIcon.fileForeground", "The foreground color for file symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
I("symbolIcon.folderForeground", {
  dark: ie,
  light: ie,
  hcDark: ie,
  hcLight: ie
}, p("symbolIcon.folderForeground", "The foreground color for folder symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
I("symbolIcon.functionForeground", {
  dark: "#B180D7",
  light: "#652D90",
  hcDark: "#B180D7",
  hcLight: "#652D90"
}, p("symbolIcon.functionForeground", "The foreground color for function symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
I("symbolIcon.interfaceForeground", {
  dark: "#75BEFF",
  light: "#007ACC",
  hcDark: "#75BEFF",
  hcLight: "#007ACC"
}, p("symbolIcon.interfaceForeground", "The foreground color for interface symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
I("symbolIcon.keyForeground", {
  dark: ie,
  light: ie,
  hcDark: ie,
  hcLight: ie
}, p("symbolIcon.keyForeground", "The foreground color for key symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
I("symbolIcon.keywordForeground", {
  dark: ie,
  light: ie,
  hcDark: ie,
  hcLight: ie
}, p("symbolIcon.keywordForeground", "The foreground color for keyword symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
I("symbolIcon.methodForeground", {
  dark: "#B180D7",
  light: "#652D90",
  hcDark: "#B180D7",
  hcLight: "#652D90"
}, p("symbolIcon.methodForeground", "The foreground color for method symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
I("symbolIcon.moduleForeground", {
  dark: ie,
  light: ie,
  hcDark: ie,
  hcLight: ie
}, p("symbolIcon.moduleForeground", "The foreground color for module symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
I("symbolIcon.namespaceForeground", {
  dark: ie,
  light: ie,
  hcDark: ie,
  hcLight: ie
}, p("symbolIcon.namespaceForeground", "The foreground color for namespace symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
I("symbolIcon.nullForeground", {
  dark: ie,
  light: ie,
  hcDark: ie,
  hcLight: ie
}, p("symbolIcon.nullForeground", "The foreground color for null symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
I("symbolIcon.numberForeground", {
  dark: ie,
  light: ie,
  hcDark: ie,
  hcLight: ie
}, p("symbolIcon.numberForeground", "The foreground color for number symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
I("symbolIcon.objectForeground", {
  dark: ie,
  light: ie,
  hcDark: ie,
  hcLight: ie
}, p("symbolIcon.objectForeground", "The foreground color for object symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
I("symbolIcon.operatorForeground", {
  dark: ie,
  light: ie,
  hcDark: ie,
  hcLight: ie
}, p("symbolIcon.operatorForeground", "The foreground color for operator symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
I("symbolIcon.packageForeground", {
  dark: ie,
  light: ie,
  hcDark: ie,
  hcLight: ie
}, p("symbolIcon.packageForeground", "The foreground color for package symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
I("symbolIcon.propertyForeground", {
  dark: ie,
  light: ie,
  hcDark: ie,
  hcLight: ie
}, p("symbolIcon.propertyForeground", "The foreground color for property symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
I("symbolIcon.referenceForeground", {
  dark: ie,
  light: ie,
  hcDark: ie,
  hcLight: ie
}, p("symbolIcon.referenceForeground", "The foreground color for reference symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
I("symbolIcon.snippetForeground", {
  dark: ie,
  light: ie,
  hcDark: ie,
  hcLight: ie
}, p("symbolIcon.snippetForeground", "The foreground color for snippet symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
I("symbolIcon.stringForeground", {
  dark: ie,
  light: ie,
  hcDark: ie,
  hcLight: ie
}, p("symbolIcon.stringForeground", "The foreground color for string symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
I("symbolIcon.structForeground", {
  dark: ie,
  light: ie,
  hcDark: ie,
  hcLight: ie
}, p("symbolIcon.structForeground", "The foreground color for struct symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
I("symbolIcon.textForeground", {
  dark: ie,
  light: ie,
  hcDark: ie,
  hcLight: ie
}, p("symbolIcon.textForeground", "The foreground color for text symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
I("symbolIcon.typeParameterForeground", {
  dark: ie,
  light: ie,
  hcDark: ie,
  hcLight: ie
}, p("symbolIcon.typeParameterForeground", "The foreground color for type parameter symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
I("symbolIcon.unitForeground", {
  dark: ie,
  light: ie,
  hcDark: ie,
  hcLight: ie
}, p("symbolIcon.unitForeground", "The foreground color for unit symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
I("symbolIcon.variableForeground", {
  dark: "#75BEFF",
  light: "#007ACC",
  hcDark: "#75BEFF",
  hcLight: "#007ACC"
}, p("symbolIcon.variableForeground", "The foreground color for variable symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
const FU = Object.freeze({ kind: kt.Empty, title: p("codeAction.widget.id.more", "More Actions...") }), Mce = Object.freeze([
  { kind: qt.QuickFix, title: p("codeAction.widget.id.quickfix", "Quick Fix") },
  { kind: qt.RefactorExtract, title: p("codeAction.widget.id.extract", "Extract"), icon: me.wrench },
  { kind: qt.RefactorInline, title: p("codeAction.widget.id.inline", "Inline"), icon: me.wrench },
  { kind: qt.RefactorRewrite, title: p("codeAction.widget.id.convert", "Rewrite"), icon: me.wrench },
  { kind: qt.RefactorMove, title: p("codeAction.widget.id.move", "Move"), icon: me.wrench },
  { kind: qt.SurroundWith, title: p("codeAction.widget.id.surround", "Surround With"), icon: me.surroundWith },
  { kind: qt.Source, title: p("codeAction.widget.id.source", "Source Action"), icon: me.symbolFile },
  FU
]);
function Rce(r, e, t) {
  if (!e)
    return r.map((s) => {
      var o;
      return {
        kind: "action",
        item: s,
        group: FU,
        disabled: !!s.action.disabled,
        label: s.action.disabled || s.action.title,
        canPreview: !!(!((o = s.action.edit) === null || o === void 0) && o.edits.length)
      };
    });
  const i = Mce.map((s) => ({ group: s, actions: [] }));
  for (const s of r) {
    const o = s.action.kind ? new kt(s.action.kind) : kt.None;
    for (const a of i)
      if (a.group.kind.contains(o)) {
        a.actions.push(s);
        break;
      }
  }
  const n = [];
  for (const s of i)
    if (s.actions.length) {
      n.push({ kind: "header", group: s.group });
      for (const o of s.actions) {
        const a = s.group;
        n.push({
          kind: "action",
          item: o,
          group: o.action.isAI ? { title: a.title, kind: a.kind, icon: me.sparkle } : a,
          label: o.action.title,
          disabled: !!o.action.disabled,
          keybinding: t(o.action)
        });
      }
    }
  return n;
}
var Ace = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, mW = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, oT, of;
(function(r) {
  r.Hidden = {
    type: 0
    /* Type.Hidden */
  };
  class e {
    constructor(i, n, s, o) {
      this.actions = i, this.trigger = n, this.editorPosition = s, this.widgetPosition = o, this.type = 1;
    }
  }
  r.Showing = e;
})(of || (of = {}));
let Au = oT = class extends P {
  constructor(e, t, i) {
    super(), this._editor = e, this._keybindingService = t, this._onClick = this._register(new R()), this.onClick = this._onClick.event, this._state = of.Hidden, this._iconClasses = [], this._domNode = X("div.lightBulbWidget"), this._domNode.role = "listbox", this._register(At.ignoreTarget(this._domNode)), this._editor.addContentWidget(this), this._register(this._editor.onDidChangeModelContent((n) => {
      const s = this._editor.getModel();
      (this.state.type !== 1 || !s || this.state.editorPosition.lineNumber >= s.getLineCount()) && this.hide();
    })), this._register(H8(this._domNode, (n) => {
      if (this.state.type !== 1)
        return;
      this._editor.focus(), n.preventDefault();
      const { top: s, height: o } = Ei(this._domNode), a = this._editor.getOption(
        67
        /* EditorOption.lineHeight */
      );
      let l = Math.floor(a / 3);
      this.state.widgetPosition.position !== null && this.state.widgetPosition.position.lineNumber < this.state.editorPosition.lineNumber && (l += a), this._onClick.fire({
        x: n.posx,
        y: s + o + l,
        actions: this.state.actions,
        trigger: this.state.trigger
      });
    })), this._register(W(this._domNode, "mouseenter", (n) => {
      (n.buttons & 1) === 1 && this.hide();
    })), this._register(ne.runAndSubscribe(this._keybindingService.onDidUpdateKeybindings, () => {
      var n, s, o, a;
      this._preferredKbLabel = (s = (n = this._keybindingService.lookupKeybinding(AU)) === null || n === void 0 ? void 0 : n.getLabel()) !== null && s !== void 0 ? s : void 0, this._quickFixKbLabel = (a = (o = this._keybindingService.lookupKeybinding(aR)) === null || o === void 0 ? void 0 : o.getLabel()) !== null && a !== void 0 ? a : void 0, this._updateLightBulbTitleAndIcon();
    }));
  }
  dispose() {
    super.dispose(), this._editor.removeContentWidget(this);
  }
  getId() {
    return "LightBulbWidget";
  }
  getDomNode() {
    return this._domNode;
  }
  getPosition() {
    return this._state.type === 1 ? this._state.widgetPosition : null;
  }
  update(e, t, i) {
    if (e.validActions.length <= 0)
      return this.hide();
    if (!this._editor.getOptions().get(
      65
      /* EditorOption.lightbulb */
    ).enabled)
      return this.hide();
    const s = this._editor.getModel();
    if (!s)
      return this.hide();
    const { lineNumber: o, column: a } = s.validatePosition(i), l = s.getOptions().tabSize, d = this._editor.getOptions().get(
      50
      /* EditorOption.fontInfo */
    ), c = s.getLineContent(o), h = R0(c, l), u = d.spaceWidth * h > 22, g = (b) => b > 2 && this._editor.getTopForLineNumber(b) === this._editor.getTopForLineNumber(b - 1);
    let f = o, m = 1;
    if (!u) {
      if (o > 1 && !g(o - 1))
        f -= 1;
      else if (o < s.getLineCount() && !g(o + 1))
        f += 1;
      else if (a * d.spaceWidth < 22)
        return this.hide();
      m = /^\S\s*$/.test(s.getLineContent(f)) ? 2 : 1;
    }
    this.state = new of.Showing(e, t, i, {
      position: { lineNumber: f, column: m },
      preference: oT._posPref
    });
    const _ = e.validActions, v = e.validActions[0].action.kind;
    if (_.length !== 1 || !v) {
      this._editor.layoutContentWidget(this);
      return;
    }
    this._editor.layoutContentWidget(this);
  }
  hide() {
    this.state !== of.Hidden && (this.state = of.Hidden, this._editor.layoutContentWidget(this));
  }
  get state() {
    return this._state;
  }
  set state(e) {
    this._state = e, this._updateLightBulbTitleAndIcon();
  }
  _updateLightBulbTitleAndIcon() {
    if (this._domNode.classList.remove(...this._iconClasses), this._iconClasses = [], this.state.type !== 1)
      return;
    let e, t = !1;
    this.state.actions.allAIFixes ? (e = me.sparkleFilled, this.state.actions.validActions.length === 1 && (t = !0)) : this.state.actions.hasAutoFix ? this.state.actions.hasAIFix ? e = me.lightbulbSparkleAutofix : e = me.lightbulbAutofix : this.state.actions.hasAIFix ? e = me.lightbulbSparkle : e = me.lightBulb, this._updateLightbulbTitle(this.state.actions.hasAutoFix, t), this._iconClasses = Le.asClassNameArray(e), this._domNode.classList.add(...this._iconClasses);
  }
  _updateLightbulbTitle(e, t) {
    this.state.type === 1 && (t ? this.title = p("codeActionAutoRun", "Run: {0}", this.state.actions.validActions[0].action.title) : e && this._preferredKbLabel ? this.title = p("preferredcodeActionWithKb", "Show Code Actions. Preferred Quick Fix Available ({0})", this._preferredKbLabel) : !e && this._quickFixKbLabel ? this.title = p("codeActionWithKb", "Show Code Actions ({0})", this._quickFixKbLabel) : e || (this.title = p("codeAction", "Show Code Actions")));
  }
  set title(e) {
    this._domNode.title = e;
  }
};
Au.ID = "editor.contrib.lightbulbWidget";
Au._posPref = [
  0
  /* ContentWidgetPositionPreference.EXACT */
];
Au = oT = Ace([
  mW(1, _t),
  mW(2, $t)
], Au);
var WU = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, rT = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
const BU = "acceptSelectedCodeAction", HU = "previewSelectedCodeAction";
class Pce {
  get templateId() {
    return "header";
  }
  renderTemplate(e) {
    e.classList.add("group-header");
    const t = document.createElement("span");
    return e.append(t), { container: e, text: t };
  }
  renderElement(e, t, i) {
    var n, s;
    i.text.textContent = (s = (n = e.group) === null || n === void 0 ? void 0 : n.title) !== null && s !== void 0 ? s : "";
  }
  disposeTemplate(e) {
  }
}
let aT = class {
  get templateId() {
    return "action";
  }
  constructor(e, t) {
    this._supportsPreview = e, this._keybindingService = t;
  }
  renderTemplate(e) {
    e.classList.add(this.templateId);
    const t = document.createElement("div");
    t.className = "icon", e.append(t);
    const i = document.createElement("span");
    i.className = "title", e.append(i);
    const n = new Op(e, Os);
    return { container: e, icon: t, text: i, keybinding: n };
  }
  renderElement(e, t, i) {
    var n, s, o;
    if (!((n = e.group) === null || n === void 0) && n.icon ? (i.icon.className = Le.asClassName(e.group.icon), e.group.icon.color && (i.icon.style.color = le(e.group.icon.color.id))) : (i.icon.className = Le.asClassName(me.lightBulb), i.icon.style.color = "var(--vscode-editorLightBulb-foreground)"), !e.item || !e.label)
      return;
    i.text.textContent = VU(e.label), i.keybinding.set(e.keybinding), e6(!!e.keybinding, i.keybinding.element);
    const a = (s = this._keybindingService.lookupKeybinding(BU)) === null || s === void 0 ? void 0 : s.getLabel(), l = (o = this._keybindingService.lookupKeybinding(HU)) === null || o === void 0 ? void 0 : o.getLabel();
    i.container.classList.toggle("option-disabled", e.disabled), e.disabled ? i.container.title = e.label : a && l ? this._supportsPreview && e.canPreview ? i.container.title = p({ key: "label-preview", comment: ['placeholders are keybindings, e.g "F2 to Apply, Shift+F2 to Preview"'] }, "{0} to Apply, {1} to Preview", a, l) : i.container.title = p({ key: "label", comment: ['placeholder is a keybinding, e.g "F2 to Apply"'] }, "{0} to Apply", a) : i.container.title = "";
  }
  disposeTemplate(e) {
    e.keybinding.dispose();
  }
};
aT = WU([
  rT(1, _t)
], aT);
class Oce extends UIEvent {
  constructor() {
    super("acceptSelectedAction");
  }
}
class _W extends UIEvent {
  constructor() {
    super("previewSelectedAction");
  }
}
function Fce(r) {
  if (r.kind === "action")
    return r.label;
}
let lT = class extends P {
  constructor(e, t, i, n, s, o) {
    super(), this._delegate = n, this._contextViewService = s, this._keybindingService = o, this._actionLineHeight = 24, this._headerLineHeight = 26, this.cts = this._register(new mi()), this.domNode = document.createElement("div"), this.domNode.classList.add("actionList");
    const a = {
      getHeight: (l) => l.kind === "header" ? this._headerLineHeight : this._actionLineHeight,
      getTemplateId: (l) => l.kind
    };
    this._list = this._register(new Co(e, this.domNode, a, [
      new aT(t, this._keybindingService),
      new Pce()
    ], {
      keyboardSupport: !1,
      typeNavigationEnabled: !0,
      keyboardNavigationLabelProvider: { getKeyboardNavigationLabel: Fce },
      accessibilityProvider: {
        getAriaLabel: (l) => {
          if (l.kind === "action") {
            let d = l.label ? VU(l == null ? void 0 : l.label) : "";
            return l.disabled && (d = p({ key: "customQuickFixWidget.labels", comment: ["Action widget labels for accessibility."] }, "{0}, Disabled Reason: {1}", d, l.disabled)), d;
          }
          return null;
        },
        getWidgetAriaLabel: () => p({ key: "customQuickFixWidget", comment: ["An action widget option"] }, "Action Widget"),
        getRole: (l) => l.kind === "action" ? "option" : "separator",
        getWidgetRole: () => "listbox"
      }
    })), this._list.style(ng), this._register(this._list.onMouseClick((l) => this.onListClick(l))), this._register(this._list.onMouseOver((l) => this.onListHover(l))), this._register(this._list.onDidChangeFocus(() => this.onFocus())), this._register(this._list.onDidChangeSelection((l) => this.onListSelection(l))), this._allMenuItems = i, this._list.splice(0, this._list.length, this._allMenuItems), this._list.length && this.focusNext();
  }
  focusCondition(e) {
    return !e.disabled && e.kind === "action";
  }
  hide(e) {
    this._delegate.onHide(e), this.cts.cancel(), this._contextViewService.hideContextView();
  }
  layout(e) {
    const t = this._allMenuItems.filter((l) => l.kind === "header").length, n = this._allMenuItems.length * this._actionLineHeight + t * this._headerLineHeight - t * this._actionLineHeight;
    this._list.layout(n);
    let s = e;
    if (this._allMenuItems.length >= 50)
      s = 380;
    else {
      const l = this._allMenuItems.map((d, c) => {
        const h = this.domNode.ownerDocument.getElementById(this._list.getElementID(c));
        if (h) {
          h.style.width = "auto";
          const u = h.getBoundingClientRect().width;
          return h.style.width = "", u;
        }
        return 0;
      });
      s = Math.max(...l, e);
    }
    const a = Math.min(n, this.domNode.ownerDocument.body.clientHeight * 0.7);
    return this._list.layout(a, s), this.domNode.style.height = `${a}px`, this._list.domFocus(), s;
  }
  focusPrevious() {
    this._list.focusPrevious(1, !0, void 0, this.focusCondition);
  }
  focusNext() {
    this._list.focusNext(1, !0, void 0, this.focusCondition);
  }
  acceptSelected(e) {
    const t = this._list.getFocus();
    if (t.length === 0)
      return;
    const i = t[0], n = this._list.element(i);
    if (!this.focusCondition(n))
      return;
    const s = e ? new _W() : new Oce();
    this._list.setSelection([i], s);
  }
  onListSelection(e) {
    if (!e.elements.length)
      return;
    const t = e.elements[0];
    t.item && this.focusCondition(t) ? this._delegate.onSelect(t.item, e.browserEvent instanceof _W) : this._list.setSelection([]);
  }
  onFocus() {
    var e, t;
    const i = this._list.getFocus();
    if (i.length === 0)
      return;
    const n = i[0], s = this._list.element(n);
    (t = (e = this._delegate).onFocus) === null || t === void 0 || t.call(e, s.item);
  }
  async onListHover(e) {
    const t = e.element;
    if (t && t.item && this.focusCondition(t)) {
      if (this._delegate.onHover && !t.disabled && t.kind === "action") {
        const i = await this._delegate.onHover(t.item, this.cts.token);
        t.canPreview = i ? i.canPreview : void 0;
      }
      e.index && this._list.splice(e.index, 1, [t]);
    }
    this._list.setFocus(typeof e.index == "number" ? [e.index] : []);
  }
  onListClick(e) {
    e.element && this.focusCondition(e.element) && this._list.setFocus([]);
  }
};
lT = WU([
  rT(4, Sd),
  rT(5, _t)
], lT);
function VU(r) {
  return r.replace(/\r\n|\r|\n/g, " ");
}
var Wce = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, $k = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
I("actionBar.toggledBackground", { dark: Gh, light: Gh, hcDark: Gh, hcLight: Gh }, p("actionBar.toggledBackground", "Background color for toggled action items in action bar."));
const Pu = {
  Visible: new oe("codeActionMenuVisible", !1, p("codeActionMenuVisible", "Whether the action widget list is visible"))
}, lg = et("actionWidgetService");
let Ou = class extends P {
  get isVisible() {
    return Pu.Visible.getValue(this._contextKeyService) || !1;
  }
  constructor(e, t, i) {
    super(), this._contextViewService = e, this._contextKeyService = t, this._instantiationService = i, this._list = this._register(new Yi());
  }
  show(e, t, i, n, s, o, a) {
    const l = Pu.Visible.bindTo(this._contextKeyService), d = this._instantiationService.createInstance(lT, e, t, i, n);
    this._contextViewService.showContextView({
      getAnchor: () => s,
      render: (c) => (l.set(!0), this._renderWidget(c, d, a ?? [])),
      onHide: (c) => {
        l.reset(), this._onWidgetClosed(c);
      }
    }, o, !1);
  }
  acceptSelected(e) {
    var t;
    (t = this._list.value) === null || t === void 0 || t.acceptSelected(e);
  }
  focusPrevious() {
    var e, t;
    (t = (e = this._list) === null || e === void 0 ? void 0 : e.value) === null || t === void 0 || t.focusPrevious();
  }
  focusNext() {
    var e, t;
    (t = (e = this._list) === null || e === void 0 ? void 0 : e.value) === null || t === void 0 || t.focusNext();
  }
  hide(e) {
    var t;
    (t = this._list.value) === null || t === void 0 || t.hide(e), this._list.clear();
  }
  _renderWidget(e, t, i) {
    var n;
    const s = document.createElement("div");
    if (s.classList.add("action-widget"), e.appendChild(s), this._list.value = t, this._list.value)
      s.appendChild(this._list.value.domNode);
    else
      throw new Error("List has no value");
    const o = new q(), a = document.createElement("div"), l = e.appendChild(a);
    l.classList.add("context-view-block"), o.add(W(l, Q.MOUSE_DOWN, (f) => f.stopPropagation()));
    const d = document.createElement("div"), c = e.appendChild(d);
    c.classList.add("context-view-pointerBlock"), o.add(W(c, Q.POINTER_MOVE, () => c.remove())), o.add(W(c, Q.MOUSE_DOWN, () => c.remove()));
    let h = 0;
    if (i.length) {
      const f = this._createActionBar(".action-widget-action-bar", i);
      f && (s.appendChild(f.getContainer().parentElement), o.add(f), h = f.getContainer().offsetWidth);
    }
    const u = (n = this._list.value) === null || n === void 0 ? void 0 : n.layout(h);
    s.style.width = `${u}px`;
    const g = o.add(Xr(e));
    return o.add(g.onDidBlur(() => this.hide(!0))), o;
  }
  _createActionBar(e, t) {
    if (!t.length)
      return;
    const i = X(e), n = new Bo(i);
    return n.push(t, { icon: !1, label: !0 }), n;
  }
  _onWidgetClosed(e) {
    var t;
    (t = this._list.value) === null || t === void 0 || t.hide(e);
  }
};
Ou = Wce([
  $k(0, Sd),
  $k(1, De),
  $k(2, be)
], Ou);
ot(
  lg,
  Ou,
  1
  /* InstantiationType.Delayed */
);
const Bb = 1100;
Rt(class extends cs {
  constructor() {
    super({
      id: "hideCodeActionWidget",
      title: Me("hideCodeActionWidget.title", "Hide action widget"),
      precondition: Pu.Visible,
      keybinding: {
        weight: Bb,
        primary: 9,
        secondary: [
          1033
          /* KeyCode.Escape */
        ]
      }
    });
  }
  run(r) {
    r.get(lg).hide(!0);
  }
});
Rt(class extends cs {
  constructor() {
    super({
      id: "selectPrevCodeAction",
      title: Me("selectPrevCodeAction.title", "Select previous action"),
      precondition: Pu.Visible,
      keybinding: {
        weight: Bb,
        primary: 16,
        secondary: [
          2064
          /* KeyCode.UpArrow */
        ],
        mac: { primary: 16, secondary: [
          2064,
          302
          /* KeyCode.KeyP */
        ] }
      }
    });
  }
  run(r) {
    const e = r.get(lg);
    e instanceof Ou && e.focusPrevious();
  }
});
Rt(class extends cs {
  constructor() {
    super({
      id: "selectNextCodeAction",
      title: Me("selectNextCodeAction.title", "Select next action"),
      precondition: Pu.Visible,
      keybinding: {
        weight: Bb,
        primary: 18,
        secondary: [
          2066
          /* KeyCode.DownArrow */
        ],
        mac: { primary: 18, secondary: [
          2066,
          300
          /* KeyCode.KeyN */
        ] }
      }
    });
  }
  run(r) {
    const e = r.get(lg);
    e instanceof Ou && e.focusNext();
  }
});
Rt(class extends cs {
  constructor() {
    super({
      id: BU,
      title: Me("acceptSelected.title", "Accept selected action"),
      precondition: Pu.Visible,
      keybinding: {
        weight: Bb,
        primary: 3,
        secondary: [
          2137
          /* KeyCode.Period */
        ]
      }
    });
  }
  run(r) {
    const e = r.get(lg);
    e instanceof Ou && e.acceptSelected();
  }
});
Rt(class extends cs {
  constructor() {
    super({
      id: HU,
      title: Me("previewSelected.title", "Preview selected action"),
      precondition: Pu.Visible,
      keybinding: {
        weight: Bb,
        primary: 2051
      }
    });
  }
  run(r) {
    const e = r.get(lg);
    e instanceof Ou && e.acceptSelected(!0);
  }
});
const zU = new oe("supportedCodeAction", ""), vW = "_typescript.applyFixAllCodeAction";
class Bce extends P {
  constructor(e, t, i, n = 250) {
    super(), this._editor = e, this._markerService = t, this._signalChange = i, this._delay = n, this._autoTriggerTimer = this._register(new vr()), this._register(this._markerService.onMarkerChanged((s) => this._onMarkerChanges(s))), this._register(this._editor.onDidChangeCursorPosition(() => this._tryAutoTrigger()));
  }
  trigger(e) {
    const t = this._getRangeOfSelectionUnlessWhitespaceEnclosed(e);
    this._signalChange(t ? { trigger: e, selection: t } : void 0);
  }
  _onMarkerChanges(e) {
    const t = this._editor.getModel();
    t && e.some((i) => B1(i, t.uri)) && this._tryAutoTrigger();
  }
  _tryAutoTrigger() {
    this._autoTriggerTimer.cancelAndSet(() => {
      this.trigger({ type: 2, triggerAction: $s.Default });
    }, this._delay);
  }
  _getRangeOfSelectionUnlessWhitespaceEnclosed(e) {
    if (!this._editor.hasModel())
      return;
    const t = this._editor.getSelection();
    if (e.type === 1)
      return t;
    const i = this._editor.getOption(
      65
      /* EditorOption.lightbulb */
    ).enabled;
    if (i !== tr.Off) {
      {
        if (i === tr.On)
          return t;
        if (i === tr.OnCode) {
          if (!t.isEmpty())
            return t;
          const s = this._editor.getModel(), { lineNumber: o, column: a } = t.getPosition(), l = s.getLineContent(o);
          if (l.length === 0)
            return;
          if (a === 1) {
            if (/\s/.test(l[0]))
              return;
          } else if (a === s.getLineMaxColumn(o)) {
            if (/\s/.test(l[l.length - 1]))
              return;
          } else if (/\s/.test(l[a - 2]) && /\s/.test(l[a - 1]))
            return;
        }
      }
      return t;
    }
  }
}
var Kh;
(function(r) {
  r.Empty = {
    type: 0
    /* Type.Empty */
  };
  class e {
    constructor(i, n, s) {
      this.trigger = i, this.position = n, this._cancellablePromise = s, this.type = 1, this.actions = s.catch((o) => {
        if (cl(o))
          return UU;
        throw o;
      });
    }
    cancel() {
      this._cancellablePromise.cancel();
    }
  }
  r.Triggered = e;
})(Kh || (Kh = {}));
const UU = Object.freeze({
  allActions: [],
  validActions: [],
  dispose: () => {
  },
  documentation: [],
  hasAutoFix: !1,
  hasAIFix: !1,
  allAIFixes: !1
});
class Hce extends P {
  constructor(e, t, i, n, s, o) {
    super(), this._editor = e, this._registry = t, this._markerService = i, this._progressService = s, this._configurationService = o, this._codeActionOracle = this._register(new Yi()), this._state = Kh.Empty, this._onDidChangeState = this._register(new R()), this.onDidChangeState = this._onDidChangeState.event, this._disposed = !1, this._supportedCodeActions = zU.bindTo(n), this._register(this._editor.onDidChangeModel(() => this._update())), this._register(this._editor.onDidChangeModelLanguage(() => this._update())), this._register(this._registry.onDidChange(() => this._update())), this._register(this._editor.onDidChangeConfiguration((a) => {
      a.hasChanged(
        65
        /* EditorOption.lightbulb */
      ) && this._update();
    })), this._update();
  }
  dispose() {
    this._disposed || (this._disposed = !0, super.dispose(), this.setState(Kh.Empty, !0));
  }
  _settingEnabledNearbyQuickfixes() {
    var e;
    const t = (e = this._editor) === null || e === void 0 ? void 0 : e.getModel();
    return this._configurationService ? this._configurationService.getValue("editor.codeActionWidget.includeNearbyQuickFixes", { resource: t == null ? void 0 : t.uri }) : !1;
  }
  _update() {
    if (this._disposed)
      return;
    this._codeActionOracle.value = void 0, this.setState(Kh.Empty);
    const e = this._editor.getModel();
    if (e && this._registry.has(e) && !this._editor.getOption(
      91
      /* EditorOption.readOnly */
    )) {
      const t = this._registry.all(e).flatMap((i) => {
        var n;
        return (n = i.providedCodeActionKinds) !== null && n !== void 0 ? n : [];
      });
      this._supportedCodeActions.set(t.join(" ")), this._codeActionOracle.value = new Bce(this._editor, this._markerService, (i) => {
        var n;
        if (!i) {
          this.setState(Kh.Empty);
          return;
        }
        const s = i.selection.getStartPosition(), o = Zi(async (d) => {
          var c, h, u, g, f, m, _, v, b, C;
          if (this._settingEnabledNearbyQuickfixes() && i.trigger.type === 1 && (i.trigger.triggerAction === $s.QuickFix || !((h = (c = i.trigger.filter) === null || c === void 0 ? void 0 : c.include) === null || h === void 0) && h.contains(qt.QuickFix))) {
            const w = await S_(this._registry, e, i.selection, i.trigger, id.None, d), S = [...w.allActions];
            if (d.isCancellationRequested)
              return UU;
            const y = (u = w.validActions) === null || u === void 0 ? void 0 : u.some((E) => E.action.kind ? qt.QuickFix.contains(new kt(E.action.kind)) : !1), k = this._markerService.read({ resource: e.uri });
            if (y) {
              for (const E of w.validActions)
                !((f = (g = E.action.command) === null || g === void 0 ? void 0 : g.arguments) === null || f === void 0) && f.some((N) => typeof N == "string" && N.includes(vW)) && (E.action.diagnostics = [...k.filter((N) => N.relatedInformation)]);
              return { validActions: w.validActions, allActions: S, documentation: w.documentation, hasAutoFix: w.hasAutoFix, hasAIFix: w.hasAIFix, allAIFixes: w.allAIFixes, dispose: () => {
                w.dispose();
              } };
            } else if (!y && k.length > 0) {
              const E = i.selection.getPosition();
              let N = E, F = Number.MAX_VALUE;
              const V = [...w.validActions];
              for (const H of k) {
                const re = H.endColumn, ue = H.endLineNumber, Ve = H.startLineNumber;
                if (ue === E.lineNumber || Ve === E.lineNumber) {
                  N = new A(ue, re);
                  const Ye = {
                    type: i.trigger.type,
                    triggerAction: i.trigger.triggerAction,
                    filter: { include: !((m = i.trigger.filter) === null || m === void 0) && m.include ? (_ = i.trigger.filter) === null || _ === void 0 ? void 0 : _.include : qt.QuickFix },
                    autoApply: i.trigger.autoApply,
                    context: { notAvailableMessage: ((v = i.trigger.context) === null || v === void 0 ? void 0 : v.notAvailableMessage) || "", position: N }
                  }, ze = new ge(N.lineNumber, N.column, N.lineNumber, N.column), pe = await S_(this._registry, e, ze, Ye, id.None, d);
                  if (pe.validActions.length !== 0) {
                    for (const $e of pe.validActions)
                      !((C = (b = $e.action.command) === null || b === void 0 ? void 0 : b.arguments) === null || C === void 0) && C.some((Be) => typeof Be == "string" && Be.includes(vW)) && ($e.action.diagnostics = [...k.filter((Be) => Be.relatedInformation)]);
                    w.allActions.length === 0 && S.push(...pe.allActions), Math.abs(E.column - re) < F ? V.unshift(...pe.validActions) : V.push(...pe.validActions);
                  }
                  F = Math.abs(E.column - re);
                }
              }
              const Z = V.filter((H, re, ue) => ue.findIndex((Ve) => Ve.action.title === H.action.title) === re);
              return Z.sort((H, re) => H.action.isPreferred && !re.action.isPreferred ? -1 : !H.action.isPreferred && re.action.isPreferred || H.action.isAI && !re.action.isAI ? 1 : !H.action.isAI && re.action.isAI ? -1 : 0), { validActions: Z, allActions: S, documentation: w.documentation, hasAutoFix: w.hasAutoFix, hasAIFix: w.hasAIFix, allAIFixes: w.allAIFixes, dispose: () => {
                w.dispose();
              } };
            }
          }
          return S_(this._registry, e, i.selection, i.trigger, id.None, d);
        });
        i.trigger.type === 1 && ((n = this._progressService) === null || n === void 0 || n.showWhile(o, 250));
        const a = new Kh.Triggered(i.trigger, s, o);
        let l = !1;
        this._state.type === 1 && (l = this._state.trigger.type === 1 && a.type === 1 && a.trigger.type === 2 && this._state.position !== a.position), l ? setTimeout(() => {
          this.setState(a);
        }, 500) : this.setState(a);
      }, void 0), this._codeActionOracle.value.trigger({ type: 2, triggerAction: $s.Default });
    } else
      this._supportedCodeActions.reset();
  }
  trigger(e) {
    var t;
    (t = this._codeActionOracle.value) === null || t === void 0 || t.trigger(e);
  }
  setState(e, t) {
    e !== this._state && (this._state.type === 1 && this._state.cancel(), this._state = e, !t && !this._disposed && this._onDidChangeState.fire(e));
  }
}
var Vce = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, _a = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, Rg;
const zce = "quickfix-edit-highlight";
let Uc = Rg = class extends P {
  static get(e) {
    return e.getContribution(Rg.ID);
  }
  constructor(e, t, i, n, s, o, a, l, d, c, h) {
    super(), this._commandService = a, this._configurationService = l, this._actionWidgetService = d, this._instantiationService = c, this._telemetryService = h, this._activeCodeActions = this._register(new Yi()), this._showDisabled = !1, this._disposed = !1, this._editor = e, this._model = this._register(new Hce(this._editor, s.codeActionProvider, t, i, o, l)), this._register(this._model.onDidChangeState((u) => this.update(u))), this._lightBulbWidget = new bd(() => {
      const u = this._editor.getContribution(Au.ID);
      return u && this._register(u.onClick((g) => this.showCodeActionsFromLightbulb(g.actions, g))), u;
    }), this._resolver = n.createInstance(My), this._register(this._editor.onDidLayoutChange(() => this._actionWidgetService.hide()));
  }
  dispose() {
    this._disposed = !0, super.dispose();
  }
  async showCodeActionsFromLightbulb(e, t) {
    if (this._telemetryService.publicLog2("codeAction.showCodeActionsFromLightbulb", {
      codeActionListLength: e.validActions.length,
      codeActions: e.validActions.map((i) => i.action.title),
      codeActionProviders: e.validActions.map((i) => {
        var n, s;
        return (s = (n = i.provider) === null || n === void 0 ? void 0 : n.displayName) !== null && s !== void 0 ? s : "";
      })
    }), e.allAIFixes && e.validActions.length === 1) {
      const i = e.validActions[0], n = i.action.command;
      n && n.id === "inlineChat.start" && n.arguments && n.arguments.length >= 1 && (n.arguments[0] = { ...n.arguments[0], autoSend: !1 }), await this._applyCodeAction(i, !1, !1, tu.FromAILightbulb);
      return;
    }
    await this.showCodeActionList(e, t, { includeDisabledActions: !1, fromLightbulb: !0 });
  }
  showCodeActions(e, t, i) {
    return this.showCodeActionList(t, i, { includeDisabledActions: !1, fromLightbulb: !1 });
  }
  manualTriggerAtCurrentPosition(e, t, i, n) {
    var s;
    if (!this._editor.hasModel())
      return;
    (s = ss.get(this._editor)) === null || s === void 0 || s.closeMessage();
    const o = this._editor.getPosition();
    this._trigger({ type: 1, triggerAction: t, filter: i, autoApply: n, context: { notAvailableMessage: e, position: o } });
  }
  _trigger(e) {
    return this._model.trigger(e);
  }
  async _applyCodeAction(e, t, i, n) {
    try {
      await this._instantiationService.invokeFunction(Ice, e, n, { preview: i, editor: this._editor });
    } finally {
      t && this._trigger({ type: 2, triggerAction: $s.QuickFix, filter: {} });
    }
  }
  async update(e) {
    var t, i, n, s, o, a, l;
    if (e.type !== 1) {
      (t = this._lightBulbWidget.rawValue) === null || t === void 0 || t.hide();
      return;
    }
    let d;
    try {
      d = await e.actions;
    } catch (c) {
      He(c);
      return;
    }
    if (!this._disposed)
      if ((i = this._lightBulbWidget.value) === null || i === void 0 || i.update(d, e.trigger, e.position), e.trigger.type === 1) {
        if (!((n = e.trigger.filter) === null || n === void 0) && n.include) {
          const h = this.tryGetValidActionToApply(e.trigger, d);
          if (h) {
            try {
              (s = this._lightBulbWidget.value) === null || s === void 0 || s.hide(), await this._applyCodeAction(h, !1, !1, tu.FromCodeActions);
            } finally {
              d.dispose();
            }
            return;
          }
          if (e.trigger.context) {
            const u = this.getInvalidActionThatWouldHaveBeenApplied(e.trigger, d);
            if (u && u.action.disabled) {
              (o = ss.get(this._editor)) === null || o === void 0 || o.showMessage(u.action.disabled, e.trigger.context.position), d.dispose();
              return;
            }
          }
        }
        const c = !!(!((a = e.trigger.filter) === null || a === void 0) && a.include);
        if (e.trigger.context && (!d.allActions.length || !c && !d.validActions.length)) {
          (l = ss.get(this._editor)) === null || l === void 0 || l.showMessage(e.trigger.context.notAvailableMessage, e.trigger.context.position), this._activeCodeActions.value = d, d.dispose();
          return;
        }
        this._activeCodeActions.value = d, this.showCodeActionList(d, this.toCoords(e.position), { includeDisabledActions: c, fromLightbulb: !1 });
      } else
        this._actionWidgetService.isVisible ? d.dispose() : this._activeCodeActions.value = d;
  }
  getInvalidActionThatWouldHaveBeenApplied(e, t) {
    if (t.allActions.length && (e.autoApply === "first" && t.validActions.length === 0 || e.autoApply === "ifSingle" && t.allActions.length === 1))
      return t.allActions.find(({ action: i }) => i.disabled);
  }
  tryGetValidActionToApply(e, t) {
    if (t.validActions.length && (e.autoApply === "first" && t.validActions.length > 0 || e.autoApply === "ifSingle" && t.validActions.length === 1))
      return t.validActions[0];
  }
  async showCodeActionList(e, t, i) {
    const n = this._editor.createDecorationsCollection(), s = this._editor.getDomNode();
    if (!s)
      return;
    const o = i.includeDisabledActions && (this._showDisabled || e.validActions.length === 0) ? e.allActions : e.validActions;
    if (!o.length)
      return;
    const a = A.isIPosition(t) ? this.toCoords(t) : t, l = {
      onSelect: async (d, c) => {
        this._applyCodeAction(
          d,
          /* retrigger */
          !0,
          !!c,
          i.fromLightbulb ? tu.FromAILightbulb : tu.FromCodeActions
        ), this._actionWidgetService.hide(!1), n.clear();
      },
      onHide: (d) => {
        var c;
        (c = this._editor) === null || c === void 0 || c.focus(), n.clear(), i.fromLightbulb && d !== void 0 && this._telemetryService.publicLog2("codeAction.showCodeActionList.onHide", {
          codeActionListLength: e.validActions.length,
          didCancel: d,
          codeActions: e.validActions.map((h) => h.action.title)
        });
      },
      onHover: async (d, c) => {
        var h;
        if (c.isCancellationRequested)
          return;
        let u = !1;
        const g = d.action.kind;
        if (g) {
          const f = new kt(g);
          u = [
            qt.RefactorExtract,
            qt.RefactorInline,
            qt.RefactorRewrite,
            qt.RefactorMove,
            qt.Source
          ].some((_) => _.contains(f));
        }
        return { canPreview: u || !!(!((h = d.action.edit) === null || h === void 0) && h.edits.length) };
      },
      onFocus: (d) => {
        var c, h;
        if (d && d.action) {
          const u = d.action.ranges, g = d.action.diagnostics;
          if (n.clear(), u && u.length > 0) {
            const f = g && (g == null ? void 0 : g.length) > 1 ? g.map((m) => ({ range: m, options: Rg.DECORATION })) : u.map((m) => ({ range: m, options: Rg.DECORATION }));
            n.set(f);
          } else if (g && g.length > 0) {
            const f = g.map((_) => ({ range: _, options: Rg.DECORATION }));
            n.set(f);
            const m = g[0];
            if (m.startLineNumber && m.startColumn) {
              const _ = (h = (c = this._editor.getModel()) === null || c === void 0 ? void 0 : c.getWordAtPosition({ lineNumber: m.startLineNumber, column: m.startColumn })) === null || h === void 0 ? void 0 : h.word;
              el(p("editingNewSelection", "Context: {0} at line {1} and column {2}.", _, m.startLineNumber, m.startColumn));
            }
          }
        } else
          n.clear();
      }
    };
    this._actionWidgetService.show("codeActionWidget", !0, Rce(o, this._shouldShowHeaders(), this._resolver.getResolver()), l, a, s, this._getActionBarActions(e, t, i));
  }
  toCoords(e) {
    if (!this._editor.hasModel())
      return { x: 0, y: 0 };
    this._editor.revealPosition(
      e,
      1
      /* ScrollType.Immediate */
    ), this._editor.render();
    const t = this._editor.getScrolledVisiblePosition(e), i = Ei(this._editor.getDomNode()), n = i.left + t.left, s = i.top + t.top + t.height;
    return { x: n, y: s };
  }
  _shouldShowHeaders() {
    var e;
    const t = (e = this._editor) === null || e === void 0 ? void 0 : e.getModel();
    return this._configurationService.getValue("editor.codeActionWidget.showHeaders", { resource: t == null ? void 0 : t.uri });
  }
  _getActionBarActions(e, t, i) {
    if (i.fromLightbulb)
      return [];
    const n = e.documentation.map((s) => {
      var o;
      return {
        id: s.id,
        label: s.title,
        tooltip: (o = s.tooltip) !== null && o !== void 0 ? o : "",
        class: void 0,
        enabled: !0,
        run: () => {
          var a;
          return this._commandService.executeCommand(s.id, ...(a = s.arguments) !== null && a !== void 0 ? a : []);
        }
      };
    });
    return i.includeDisabledActions && e.validActions.length > 0 && e.allActions.length !== e.validActions.length && n.push(this._showDisabled ? {
      id: "hideMoreActions",
      label: p("hideMoreActions", "Hide Disabled"),
      enabled: !0,
      tooltip: "",
      class: void 0,
      run: () => (this._showDisabled = !1, this.showCodeActionList(e, t, i))
    } : {
      id: "showMoreActions",
      label: p("showMoreActions", "Show Disabled"),
      enabled: !0,
      tooltip: "",
      class: void 0,
      run: () => (this._showDisabled = !0, this.showCodeActionList(e, t, i))
    }), n;
  }
};
Uc.ID = "editor.contrib.codeActionController";
Uc.DECORATION = Fe.register({
  description: "quickfix-highlight",
  className: zce
});
Uc = Rg = Vce([
  _a(1, fl),
  _a(2, De),
  _a(3, be),
  _a(4, he),
  _a(5, sh),
  _a(6, $t),
  _a(7, Ge),
  _a(8, lg),
  _a(9, be),
  _a(10, kn)
], Uc);
Ho((r, e) => {
  ((n, s) => {
    s && e.addRule(`.monaco-editor ${n} { background-color: ${s}; }`);
  })(".quickfix-edit-highlight", r.getColor(Ul));
  const i = r.getColor(tc);
  i && e.addRule(`.monaco-editor .quickfix-edit-highlight { border: 1px ${jr(r.type) ? "dotted" : "solid"} ${i}; box-sizing: border-box; }`);
});
function Hb(r) {
  return U.regex(zU.keys()[0], new RegExp("(\\s|^)" + gr(r.value) + "\\b"));
}
const cR = {
  type: "object",
  defaultSnippets: [{ body: { kind: "" } }],
  properties: {
    kind: {
      type: "string",
      description: p("args.schema.kind", "Kind of the code action to run.")
    },
    apply: {
      type: "string",
      description: p("args.schema.apply", "Controls when the returned actions are applied."),
      default: "ifSingle",
      enum: [
        "first",
        "ifSingle",
        "never"
        /* CodeActionAutoApply.Never */
      ],
      enumDescriptions: [
        p("args.schema.apply.first", "Always apply the first returned code action."),
        p("args.schema.apply.ifSingle", "Apply the first returned code action if it is the only one."),
        p("args.schema.apply.never", "Do not apply the returned code actions.")
      ]
    },
    preferred: {
      type: "boolean",
      default: !1,
      description: p("args.schema.preferred", "Controls if only preferred code actions should be returned.")
    }
  }
};
function dg(r, e, t, i, n = $s.Default) {
  if (r.hasModel()) {
    const s = Uc.get(r);
    s == null || s.manualTriggerAtCurrentPosition(e, n, t, i);
  }
}
class Uce extends ae {
  constructor() {
    super({
      id: aR,
      label: p("quickfix.trigger.label", "Quick Fix..."),
      alias: "Quick Fix...",
      precondition: U.and(x.writable, x.hasCodeActionsProvider),
      kbOpts: {
        kbExpr: x.textInputFocus,
        primary: 2137,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(e, t) {
    return dg(t, p("editor.action.quickFix.noneMessage", "No code actions available"), void 0, void 0, $s.QuickFix);
  }
}
class $ce extends Ui {
  constructor() {
    super({
      id: RU,
      precondition: U.and(x.writable, x.hasCodeActionsProvider),
      metadata: {
        description: "Trigger a code action",
        args: [{ name: "args", schema: cR }]
      }
    });
  }
  runEditorCommand(e, t, i) {
    const n = Wa.fromUser(i, {
      kind: kt.Empty,
      apply: "ifSingle"
    });
    return dg(t, typeof (i == null ? void 0 : i.kind) == "string" ? n.preferred ? p("editor.action.codeAction.noneMessage.preferred.kind", "No preferred code actions for '{0}' available", i.kind) : p("editor.action.codeAction.noneMessage.kind", "No code actions for '{0}' available", i.kind) : n.preferred ? p("editor.action.codeAction.noneMessage.preferred", "No preferred code actions available") : p("editor.action.codeAction.noneMessage", "No code actions available"), {
      include: n.kind,
      includeSourceActions: !0,
      onlyIncludePreferredActions: n.preferred
    }, n.apply);
  }
}
class Kce extends ae {
  constructor() {
    super({
      id: PU,
      label: p("refactor.label", "Refactor..."),
      alias: "Refactor...",
      precondition: U.and(x.writable, x.hasCodeActionsProvider),
      kbOpts: {
        kbExpr: x.textInputFocus,
        primary: 3120,
        mac: {
          primary: 1328
          /* KeyCode.KeyR */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      contextMenuOpts: {
        group: "1_modification",
        order: 2,
        when: U.and(x.writable, Hb(qt.Refactor))
      },
      metadata: {
        description: "Refactor...",
        args: [{ name: "args", schema: cR }]
      }
    });
  }
  run(e, t, i) {
    const n = Wa.fromUser(i, {
      kind: qt.Refactor,
      apply: "never"
      /* CodeActionAutoApply.Never */
    });
    return dg(t, typeof (i == null ? void 0 : i.kind) == "string" ? n.preferred ? p("editor.action.refactor.noneMessage.preferred.kind", "No preferred refactorings for '{0}' available", i.kind) : p("editor.action.refactor.noneMessage.kind", "No refactorings for '{0}' available", i.kind) : n.preferred ? p("editor.action.refactor.noneMessage.preferred", "No preferred refactorings available") : p("editor.action.refactor.noneMessage", "No refactorings available"), {
      include: qt.Refactor.contains(n.kind) ? n.kind : kt.None,
      onlyIncludePreferredActions: n.preferred
    }, n.apply, $s.Refactor);
  }
}
class jce extends ae {
  constructor() {
    super({
      id: OU,
      label: p("source.label", "Source Action..."),
      alias: "Source Action...",
      precondition: U.and(x.writable, x.hasCodeActionsProvider),
      contextMenuOpts: {
        group: "1_modification",
        order: 2.1,
        when: U.and(x.writable, Hb(qt.Source))
      },
      metadata: {
        description: "Source Action...",
        args: [{ name: "args", schema: cR }]
      }
    });
  }
  run(e, t, i) {
    const n = Wa.fromUser(i, {
      kind: qt.Source,
      apply: "never"
      /* CodeActionAutoApply.Never */
    });
    return dg(t, typeof (i == null ? void 0 : i.kind) == "string" ? n.preferred ? p("editor.action.source.noneMessage.preferred.kind", "No preferred source actions for '{0}' available", i.kind) : p("editor.action.source.noneMessage.kind", "No source actions for '{0}' available", i.kind) : n.preferred ? p("editor.action.source.noneMessage.preferred", "No preferred source actions available") : p("editor.action.source.noneMessage", "No source actions available"), {
      include: qt.Source.contains(n.kind) ? n.kind : kt.None,
      includeSourceActions: !0,
      onlyIncludePreferredActions: n.preferred
    }, n.apply, $s.SourceAction);
  }
}
class qce extends ae {
  constructor() {
    super({
      id: lR,
      label: p("organizeImports.label", "Organize Imports"),
      alias: "Organize Imports",
      precondition: U.and(x.writable, Hb(qt.SourceOrganizeImports)),
      kbOpts: {
        kbExpr: x.textInputFocus,
        primary: 1581,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(e, t) {
    return dg(t, p("editor.action.organize.noneMessage", "No organize imports action available"), { include: qt.SourceOrganizeImports, includeSourceActions: !0 }, "ifSingle", $s.OrganizeImports);
  }
}
class Gce extends ae {
  constructor() {
    super({
      id: dR,
      label: p("fixAll.label", "Fix All"),
      alias: "Fix All",
      precondition: U.and(x.writable, Hb(qt.SourceFixAll))
    });
  }
  run(e, t) {
    return dg(t, p("fixAll.noneMessage", "No fix all action available"), { include: qt.SourceFixAll, includeSourceActions: !0 }, "ifSingle", $s.FixAll);
  }
}
class Zce extends ae {
  constructor() {
    super({
      id: AU,
      label: p("autoFix.label", "Auto Fix..."),
      alias: "Auto Fix...",
      precondition: U.and(x.writable, Hb(qt.QuickFix)),
      kbOpts: {
        kbExpr: x.textInputFocus,
        primary: 1625,
        mac: {
          primary: 2649
          /* KeyCode.Period */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(e, t) {
    return dg(t, p("editor.action.autoFix.noneMessage", "No auto fixes available"), {
      include: qt.QuickFix,
      onlyIncludePreferredActions: !0
    }, "ifSingle", $s.AutoFix);
  }
}
gt(
  Uc.ID,
  Uc,
  3
  /* EditorContributionInstantiation.Eventually */
);
gt(
  Au.ID,
  Au,
  4
  /* EditorContributionInstantiation.Lazy */
);
Y(Uce);
Y(Kce);
Y(jce);
Y(qce);
Y(Zce);
Y(Gce);
se(new $ce());
si.as(aa.Configuration).registerConfiguration({
  ...U0,
  properties: {
    "editor.codeActionWidget.showHeaders": {
      type: "boolean",
      scope: 5,
      description: p("showCodeActionHeaders", "Enable/disable showing group headers in the Code Action menu."),
      default: !0
    }
  }
});
si.as(aa.Configuration).registerConfiguration({
  ...U0,
  properties: {
    "editor.codeActionWidget.includeNearbyQuickFixes": {
      type: "boolean",
      scope: 5,
      description: p("includeNearbyQuickFixes", "Enable/disable showing nearest Quick Fix within a line when not currently on a diagnostic."),
      default: !0
    }
  }
});
class dT {
  constructor() {
    this.lenses = [], this._disposables = new q();
  }
  dispose() {
    this._disposables.dispose();
  }
  get isDisposed() {
    return this._disposables.isDisposed;
  }
  add(e, t) {
    this._disposables.add(e);
    for (const i of e.lenses)
      this.lenses.push({ symbol: i, provider: t });
  }
}
async function $U(r, e, t) {
  const i = r.ordered(e), n = /* @__PURE__ */ new Map(), s = new dT(), o = i.map(async (a, l) => {
    n.set(a, l);
    try {
      const d = await Promise.resolve(a.provideCodeLenses(e, t));
      d && s.add(d, a);
    } catch (d) {
      _i(d);
    }
  });
  return await Promise.all(o), s.lenses = s.lenses.sort((a, l) => a.symbol.range.startLineNumber < l.symbol.range.startLineNumber ? -1 : a.symbol.range.startLineNumber > l.symbol.range.startLineNumber ? 1 : n.get(a.provider) < n.get(l.provider) ? -1 : n.get(a.provider) > n.get(l.provider) ? 1 : a.symbol.range.startColumn < l.symbol.range.startColumn ? -1 : a.symbol.range.startColumn > l.symbol.range.startColumn ? 1 : 0), s;
}
st.registerCommand("_executeCodeLensProvider", function(r, ...e) {
  let [t, i] = e;
  ct(Ee.isUri(t)), ct(typeof i == "number" || !i);
  const { codeLensProvider: n } = r.get(he), s = r.get(ii).getModel(t);
  if (!s)
    throw Ro();
  const o = [], a = new q();
  return $U(n, s, at.None).then((l) => {
    a.add(l);
    const d = [];
    for (const c of l.lenses)
      i == null || c.symbol.command ? o.push(c.symbol) : i-- > 0 && c.provider.resolveCodeLens && d.push(Promise.resolve(c.provider.resolveCodeLens(s, c.symbol, at.None)).then((h) => o.push(h || c.symbol)));
    return Promise.all(d);
  }).then(() => o).finally(() => {
    setTimeout(() => a.dispose(), 100);
  });
});
var Yce = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Qce = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
const KU = et("ICodeLensCache");
class bW {
  constructor(e, t) {
    this.lineCount = e, this.data = t;
  }
}
let cT = class {
  constructor(e) {
    this._fakeProvider = new class {
      provideCodeLenses() {
        throw new Error("not supported");
      }
    }(), this._cache = new Cd(20, 0.75);
    const t = "codelens/cache";
    ym(Dt, () => e.remove(
      t,
      1
      /* StorageScope.WORKSPACE */
    ));
    const i = "codelens/cache2", n = e.get(i, 1, "{}");
    this._deserialize(n), ne.once(e.onWillSaveState)((s) => {
      s.reason === uv.SHUTDOWN && e.store(
        i,
        this._serialize(),
        1,
        1
        /* StorageTarget.MACHINE */
      );
    });
  }
  put(e, t) {
    const i = t.lenses.map((o) => {
      var a;
      return {
        range: o.symbol.range,
        command: o.symbol.command && { id: "", title: (a = o.symbol.command) === null || a === void 0 ? void 0 : a.title }
      };
    }), n = new dT();
    n.add({ lenses: i, dispose: () => {
    } }, this._fakeProvider);
    const s = new bW(e.getLineCount(), n);
    this._cache.set(e.uri.toString(), s);
  }
  get(e) {
    const t = this._cache.get(e.uri.toString());
    return t && t.lineCount === e.getLineCount() ? t.data : void 0;
  }
  delete(e) {
    this._cache.delete(e.uri.toString());
  }
  // --- persistence
  _serialize() {
    const e = /* @__PURE__ */ Object.create(null);
    for (const [t, i] of this._cache) {
      const n = /* @__PURE__ */ new Set();
      for (const s of i.data.lenses)
        n.add(s.symbol.range.startLineNumber);
      e[t] = {
        lineCount: i.lineCount,
        lines: [...n.values()]
      };
    }
    return JSON.stringify(e);
  }
  _deserialize(e) {
    try {
      const t = JSON.parse(e);
      for (const i in t) {
        const n = t[i], s = [];
        for (const a of n.lines)
          s.push({ range: new L(a, 1, a, 11) });
        const o = new dT();
        o.add({ lenses: s, dispose() {
        } }, this._fakeProvider), this._cache.set(i, new bW(n.lineCount, o));
      }
    } catch {
    }
  }
};
cT = Yce([
  Qce(0, br)
], cT);
ot(
  KU,
  cT,
  1
  /* InstantiationType.Delayed */
);
class Xce {
  constructor(e, t, i) {
    this.afterColumn = 1073741824, this.afterLineNumber = e, this.heightInPx = t, this._onHeight = i, this.suppressMouseDown = !0, this.domNode = document.createElement("div");
  }
  onComputedHeight(e) {
    this._lastHeight === void 0 ? this._lastHeight = e : this._lastHeight !== e && (this._lastHeight = e, this._onHeight());
  }
  isVisible() {
    return this._lastHeight !== 0 && this.domNode.hasAttribute("monaco-visible-view-zone");
  }
}
class Tv {
  constructor(e, t) {
    this.allowEditorOverflow = !1, this.suppressMouseDown = !0, this._commands = /* @__PURE__ */ new Map(), this._isEmpty = !0, this._editor = e, this._id = `codelens.widget-${Tv._idPool++}`, this.updatePosition(t), this._domNode = document.createElement("span"), this._domNode.className = "codelens-decoration";
  }
  withCommands(e, t) {
    this._commands.clear();
    const i = [];
    let n = !1;
    for (let s = 0; s < e.length; s++) {
      const o = e[s];
      if (o && (n = !0, o.command)) {
        const a = _c(o.command.title.trim());
        if (o.command.id) {
          const l = `c${Tv._idPool++}`;
          i.push(X("a", { id: l, title: o.command.tooltip, role: "button" }, ...a)), this._commands.set(l, o.command);
        } else
          i.push(X("span", { title: o.command.tooltip }, ...a));
        s + 1 < e.length && i.push(X("span", void 0, "|"));
      }
    }
    n ? (mn(this._domNode, ...i), this._isEmpty && t && this._domNode.classList.add("fadein"), this._isEmpty = !1) : mn(this._domNode, X("span", void 0, "no commands"));
  }
  getCommand(e) {
    return e.parentElement === this._domNode ? this._commands.get(e.id) : void 0;
  }
  getId() {
    return this._id;
  }
  getDomNode() {
    return this._domNode;
  }
  updatePosition(e) {
    const t = this._editor.getModel().getLineFirstNonWhitespaceColumn(e);
    this._widgetPosition = {
      position: { lineNumber: e, column: t },
      preference: [
        1
        /* ContentWidgetPositionPreference.ABOVE */
      ]
    };
  }
  getPosition() {
    return this._widgetPosition || null;
  }
}
Tv._idPool = 0;
class Kk {
  constructor() {
    this._removeDecorations = [], this._addDecorations = [], this._addDecorationsCallbacks = [];
  }
  addDecoration(e, t) {
    this._addDecorations.push(e), this._addDecorationsCallbacks.push(t);
  }
  removeDecoration(e) {
    this._removeDecorations.push(e);
  }
  commit(e) {
    const t = e.deltaDecorations(this._removeDecorations, this._addDecorations);
    for (let i = 0, n = t.length; i < n; i++)
      this._addDecorationsCallbacks[i](t[i]);
  }
}
const CW = Fe.register({
  collapseOnReplaceEdit: !0,
  description: "codelens"
});
class wW {
  constructor(e, t, i, n, s, o) {
    this._isDisposed = !1, this._editor = t, this._data = e, this._decorationIds = [];
    let a;
    const l = [];
    this._data.forEach((d, c) => {
      d.symbol.command && l.push(d.symbol), i.addDecoration({
        range: d.symbol.range,
        options: CW
      }, (h) => this._decorationIds[c] = h), a ? a = L.plusRange(a, d.symbol.range) : a = L.lift(d.symbol.range);
    }), this._viewZone = new Xce(a.startLineNumber - 1, s, o), this._viewZoneId = n.addZone(this._viewZone), l.length > 0 && (this._createContentWidgetIfNecessary(), this._contentWidget.withCommands(l, !1));
  }
  _createContentWidgetIfNecessary() {
    this._contentWidget ? this._editor.layoutContentWidget(this._contentWidget) : (this._contentWidget = new Tv(this._editor, this._viewZone.afterLineNumber + 1), this._editor.addContentWidget(this._contentWidget));
  }
  dispose(e, t) {
    this._decorationIds.forEach(e.removeDecoration, e), this._decorationIds = [], t == null || t.removeZone(this._viewZoneId), this._contentWidget && (this._editor.removeContentWidget(this._contentWidget), this._contentWidget = void 0), this._isDisposed = !0;
  }
  isDisposed() {
    return this._isDisposed;
  }
  isValid() {
    return this._decorationIds.some((e, t) => {
      const i = this._editor.getModel().getDecorationRange(e), n = this._data[t].symbol;
      return !!(i && L.isEmpty(n.range) === i.isEmpty());
    });
  }
  updateCodeLensSymbols(e, t) {
    this._decorationIds.forEach(t.removeDecoration, t), this._decorationIds = [], this._data = e, this._data.forEach((i, n) => {
      t.addDecoration({
        range: i.symbol.range,
        options: CW
      }, (s) => this._decorationIds[n] = s);
    });
  }
  updateHeight(e, t) {
    this._viewZone.heightInPx = e, t.layoutZone(this._viewZoneId), this._contentWidget && this._editor.layoutContentWidget(this._contentWidget);
  }
  computeIfNecessary(e) {
    if (!this._viewZone.isVisible())
      return null;
    for (let t = 0; t < this._decorationIds.length; t++) {
      const i = e.getDecorationRange(this._decorationIds[t]);
      i && (this._data[t].symbol.range = i);
    }
    return this._data;
  }
  updateCommands(e) {
    this._createContentWidgetIfNecessary(), this._contentWidget.withCommands(e, !0);
    for (let t = 0; t < this._data.length; t++) {
      const i = e[t];
      if (i) {
        const { symbol: n } = this._data[t];
        n.command = i.command || n.command;
      }
    }
  }
  getCommand(e) {
    var t;
    return (t = this._contentWidget) === null || t === void 0 ? void 0 : t.getCommand(e);
  }
  getLineNumber() {
    const e = this._editor.getModel().getDecorationRange(this._decorationIds[0]);
    return e ? e.startLineNumber : -1;
  }
  update(e) {
    if (this.isValid()) {
      const t = this._editor.getModel().getDecorationRange(this._decorationIds[0]);
      t && (this._viewZone.afterLineNumber = t.startLineNumber - 1, e.layoutZone(this._viewZoneId), this._contentWidget && (this._contentWidget.updatePosition(t.startLineNumber), this._editor.layoutContentWidget(this._contentWidget)));
    }
  }
}
var Jce = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, fm = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
let gp = class {
  constructor(e, t, i, n, s, o) {
    this._editor = e, this._languageFeaturesService = t, this._commandService = n, this._notificationService = s, this._codeLensCache = o, this._disposables = new q(), this._localToDispose = new q(), this._lenses = [], this._oldCodeLensModels = new q(), this._provideCodeLensDebounce = i.for(t.codeLensProvider, "CodeLensProvide", { min: 250 }), this._resolveCodeLensesDebounce = i.for(t.codeLensProvider, "CodeLensResolve", { min: 250, salt: "resolve" }), this._resolveCodeLensesScheduler = new xt(() => this._resolveCodeLensesInViewport(), this._resolveCodeLensesDebounce.default()), this._disposables.add(this._editor.onDidChangeModel(() => this._onModelChange())), this._disposables.add(this._editor.onDidChangeModelLanguage(() => this._onModelChange())), this._disposables.add(this._editor.onDidChangeConfiguration((a) => {
      (a.hasChanged(
        50
        /* EditorOption.fontInfo */
      ) || a.hasChanged(
        19
        /* EditorOption.codeLensFontSize */
      ) || a.hasChanged(
        18
        /* EditorOption.codeLensFontFamily */
      )) && this._updateLensStyle(), a.hasChanged(
        17
        /* EditorOption.codeLens */
      ) && this._onModelChange();
    })), this._disposables.add(t.codeLensProvider.onDidChange(this._onModelChange, this)), this._onModelChange(), this._updateLensStyle();
  }
  dispose() {
    var e;
    this._localDispose(), this._disposables.dispose(), this._oldCodeLensModels.dispose(), (e = this._currentCodeLensModel) === null || e === void 0 || e.dispose();
  }
  _getLayoutInfo() {
    const e = Math.max(1.3, this._editor.getOption(
      67
      /* EditorOption.lineHeight */
    ) / this._editor.getOption(
      52
      /* EditorOption.fontSize */
    ));
    let t = this._editor.getOption(
      19
      /* EditorOption.codeLensFontSize */
    );
    return (!t || t < 5) && (t = this._editor.getOption(
      52
      /* EditorOption.fontSize */
    ) * 0.9 | 0), {
      fontSize: t,
      codeLensHeight: t * e | 0
    };
  }
  _updateLensStyle() {
    const { codeLensHeight: e, fontSize: t } = this._getLayoutInfo(), i = this._editor.getOption(
      18
      /* EditorOption.codeLensFontFamily */
    ), n = this._editor.getOption(
      50
      /* EditorOption.fontInfo */
    ), { style: s } = this._editor.getContainerDomNode();
    s.setProperty("--vscode-editorCodeLens-lineHeight", `${e}px`), s.setProperty("--vscode-editorCodeLens-fontSize", `${t}px`), s.setProperty("--vscode-editorCodeLens-fontFeatureSettings", n.fontFeatureSettings), i && (s.setProperty("--vscode-editorCodeLens-fontFamily", i), s.setProperty("--vscode-editorCodeLens-fontFamilyDefault", Ss.fontFamily)), this._editor.changeViewZones((o) => {
      for (const a of this._lenses)
        a.updateHeight(e, o);
    });
  }
  _localDispose() {
    var e, t, i;
    (e = this._getCodeLensModelPromise) === null || e === void 0 || e.cancel(), this._getCodeLensModelPromise = void 0, (t = this._resolveCodeLensesPromise) === null || t === void 0 || t.cancel(), this._resolveCodeLensesPromise = void 0, this._localToDispose.clear(), this._oldCodeLensModels.clear(), (i = this._currentCodeLensModel) === null || i === void 0 || i.dispose();
  }
  _onModelChange() {
    this._localDispose();
    const e = this._editor.getModel();
    if (!e || !this._editor.getOption(
      17
      /* EditorOption.codeLens */
    ) || e.isTooLargeForTokenization())
      return;
    const t = this._codeLensCache.get(e);
    if (t && this._renderCodeLensSymbols(t), !this._languageFeaturesService.codeLensProvider.has(e)) {
      t && Mc(() => {
        const n = this._codeLensCache.get(e);
        t === n && (this._codeLensCache.delete(e), this._onModelChange());
      }, 30 * 1e3, this._localToDispose);
      return;
    }
    for (const n of this._languageFeaturesService.codeLensProvider.all(e))
      if (typeof n.onDidChange == "function") {
        const s = n.onDidChange(() => i.schedule());
        this._localToDispose.add(s);
      }
    const i = new xt(() => {
      var n;
      const s = Date.now();
      (n = this._getCodeLensModelPromise) === null || n === void 0 || n.cancel(), this._getCodeLensModelPromise = Zi((o) => $U(this._languageFeaturesService.codeLensProvider, e, o)), this._getCodeLensModelPromise.then((o) => {
        this._currentCodeLensModel && this._oldCodeLensModels.add(this._currentCodeLensModel), this._currentCodeLensModel = o, this._codeLensCache.put(e, o);
        const a = this._provideCodeLensDebounce.update(e, Date.now() - s);
        i.delay = a, this._renderCodeLensSymbols(o), this._resolveCodeLensesInViewportSoon();
      }, He);
    }, this._provideCodeLensDebounce.get(e));
    this._localToDispose.add(i), this._localToDispose.add(Se(() => this._resolveCodeLensesScheduler.cancel())), this._localToDispose.add(this._editor.onDidChangeModelContent(() => {
      var n;
      this._editor.changeDecorations((s) => {
        this._editor.changeViewZones((o) => {
          const a = [];
          let l = -1;
          this._lenses.forEach((c) => {
            !c.isValid() || l === c.getLineNumber() ? a.push(c) : (c.update(o), l = c.getLineNumber());
          });
          const d = new Kk();
          a.forEach((c) => {
            c.dispose(d, o), this._lenses.splice(this._lenses.indexOf(c), 1);
          }), d.commit(s);
        });
      }), i.schedule(), this._resolveCodeLensesScheduler.cancel(), (n = this._resolveCodeLensesPromise) === null || n === void 0 || n.cancel(), this._resolveCodeLensesPromise = void 0;
    })), this._localToDispose.add(this._editor.onDidFocusEditorText(() => {
      i.schedule();
    })), this._localToDispose.add(this._editor.onDidBlurEditorText(() => {
      i.cancel();
    })), this._localToDispose.add(this._editor.onDidScrollChange((n) => {
      n.scrollTopChanged && this._lenses.length > 0 && this._resolveCodeLensesInViewportSoon();
    })), this._localToDispose.add(this._editor.onDidLayoutChange(() => {
      this._resolveCodeLensesInViewportSoon();
    })), this._localToDispose.add(Se(() => {
      if (this._editor.getModel()) {
        const n = sa.capture(this._editor);
        this._editor.changeDecorations((s) => {
          this._editor.changeViewZones((o) => {
            this._disposeAllLenses(s, o);
          });
        }), n.restore(this._editor);
      } else
        this._disposeAllLenses(void 0, void 0);
    })), this._localToDispose.add(this._editor.onMouseDown((n) => {
      if (n.target.type !== 9)
        return;
      let s = n.target.element;
      if ((s == null ? void 0 : s.tagName) === "SPAN" && (s = s.parentElement), (s == null ? void 0 : s.tagName) === "A")
        for (const o of this._lenses) {
          const a = o.getCommand(s);
          if (a) {
            this._commandService.executeCommand(a.id, ...a.arguments || []).catch((l) => this._notificationService.error(l));
            break;
          }
        }
    })), i.schedule();
  }
  _disposeAllLenses(e, t) {
    const i = new Kk();
    for (const n of this._lenses)
      n.dispose(i, t);
    e && i.commit(e), this._lenses.length = 0;
  }
  _renderCodeLensSymbols(e) {
    if (!this._editor.hasModel())
      return;
    const t = this._editor.getModel().getLineCount(), i = [];
    let n;
    for (const a of e.lenses) {
      const l = a.symbol.range.startLineNumber;
      l < 1 || l > t || (n && n[n.length - 1].symbol.range.startLineNumber === l ? n.push(a) : (n = [a], i.push(n)));
    }
    if (!i.length && !this._lenses.length)
      return;
    const s = sa.capture(this._editor), o = this._getLayoutInfo();
    this._editor.changeDecorations((a) => {
      this._editor.changeViewZones((l) => {
        const d = new Kk();
        let c = 0, h = 0;
        for (; h < i.length && c < this._lenses.length; ) {
          const u = i[h][0].symbol.range.startLineNumber, g = this._lenses[c].getLineNumber();
          g < u ? (this._lenses[c].dispose(d, l), this._lenses.splice(c, 1)) : g === u ? (this._lenses[c].updateCodeLensSymbols(i[h], d), h++, c++) : (this._lenses.splice(c, 0, new wW(i[h], this._editor, d, l, o.codeLensHeight, () => this._resolveCodeLensesInViewportSoon())), c++, h++);
        }
        for (; c < this._lenses.length; )
          this._lenses[c].dispose(d, l), this._lenses.splice(c, 1);
        for (; h < i.length; )
          this._lenses.push(new wW(i[h], this._editor, d, l, o.codeLensHeight, () => this._resolveCodeLensesInViewportSoon())), h++;
        d.commit(a);
      });
    }), s.restore(this._editor);
  }
  _resolveCodeLensesInViewportSoon() {
    this._editor.getModel() && this._resolveCodeLensesScheduler.schedule();
  }
  _resolveCodeLensesInViewport() {
    var e;
    (e = this._resolveCodeLensesPromise) === null || e === void 0 || e.cancel(), this._resolveCodeLensesPromise = void 0;
    const t = this._editor.getModel();
    if (!t)
      return;
    const i = [], n = [];
    if (this._lenses.forEach((a) => {
      const l = a.computeIfNecessary(t);
      l && (i.push(l), n.push(a));
    }), i.length === 0)
      return;
    const s = Date.now(), o = Zi((a) => {
      const l = i.map((d, c) => {
        const h = new Array(d.length), u = d.map((g, f) => !g.symbol.command && typeof g.provider.resolveCodeLens == "function" ? Promise.resolve(g.provider.resolveCodeLens(t, g.symbol, a)).then((m) => {
          h[f] = m;
        }, _i) : (h[f] = g.symbol, Promise.resolve(void 0)));
        return Promise.all(u).then(() => {
          !a.isCancellationRequested && !n[c].isDisposed() && n[c].updateCommands(h);
        });
      });
      return Promise.all(l);
    });
    this._resolveCodeLensesPromise = o, this._resolveCodeLensesPromise.then(() => {
      const a = this._resolveCodeLensesDebounce.update(t, Date.now() - s);
      this._resolveCodeLensesScheduler.delay = a, this._currentCodeLensModel && this._codeLensCache.put(t, this._currentCodeLensModel), this._oldCodeLensModels.clear(), o === this._resolveCodeLensesPromise && (this._resolveCodeLensesPromise = void 0);
    }, (a) => {
      He(a), o === this._resolveCodeLensesPromise && (this._resolveCodeLensesPromise = void 0);
    });
  }
  async getModel() {
    var e;
    return await this._getCodeLensModelPromise, await this._resolveCodeLensesPromise, !((e = this._currentCodeLensModel) === null || e === void 0) && e.isDisposed ? void 0 : this._currentCodeLensModel;
  }
};
gp.ID = "css.editor.codeLens";
gp = Jce([
  fm(1, he),
  fm(2, Vo),
  fm(3, $t),
  fm(4, xi),
  fm(5, KU)
], gp);
gt(
  gp.ID,
  gp,
  1
  /* EditorContributionInstantiation.AfterFirstRender */
);
Y(class extends ae {
  constructor() {
    super({
      id: "codelens.showLensesInCurrentLine",
      precondition: x.hasCodeLensProvider,
      label: p("showLensOnLine", "Show CodeLens Commands For Current Line"),
      alias: "Show CodeLens Commands For Current Line"
    });
  }
  async run(e, t) {
    if (!t.hasModel())
      return;
    const i = e.get($o), n = e.get($t), s = e.get(xi), o = t.getSelection().positionLineNumber, a = t.getContribution(gp.ID);
    if (!a)
      return;
    const l = await a.getModel();
    if (!l)
      return;
    const d = [];
    for (const u of l.lenses)
      u.symbol.command && u.symbol.range.startLineNumber === o && d.push({
        label: u.symbol.command.title,
        command: u.symbol.command
      });
    if (d.length === 0)
      return;
    const c = await i.pick(d, {
      canPickMany: !1,
      placeHolder: p("placeHolder", "Select a command")
    });
    if (!c)
      return;
    let h = c.command;
    if (l.isDisposed) {
      const u = await a.getModel(), g = u == null ? void 0 : u.lenses.find((f) => {
        var m;
        return f.symbol.range.startLineNumber === o && ((m = f.symbol.command) === null || m === void 0 ? void 0 : m.title) === h.title;
      });
      if (!g || !g.symbol.command)
        return;
      h = g.symbol.command;
    }
    try {
      await n.executeCommand(h.id, ...h.arguments || []);
    } catch (u) {
      s.error(u);
    }
  }
});
var ehe = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, jk = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
class hR {
  constructor(e, t) {
    this._editorWorkerClient = new u1(e, !1, "editorWorkerService", t);
  }
  async provideDocumentColors(e, t) {
    return this._editorWorkerClient.computeDefaultDocumentColors(e.uri);
  }
  provideColorPresentations(e, t, i) {
    const n = t.range, s = t.color, o = s.alpha, a = new z(new Qt(Math.round(255 * s.red), Math.round(255 * s.green), Math.round(255 * s.blue), o)), l = o ? z.Format.CSS.formatRGB(a) : z.Format.CSS.formatRGBA(a), d = o ? z.Format.CSS.formatHSL(a) : z.Format.CSS.formatHSLA(a), c = o ? z.Format.CSS.formatHex(a) : z.Format.CSS.formatHexA(a), h = [];
    return h.push({ label: l, textEdit: { range: n, text: l } }), h.push({ label: d, textEdit: { range: n, text: d } }), h.push({ label: c, textEdit: { range: n, text: c } }), h;
  }
}
let hT = class extends P {
  constructor(e, t, i) {
    super(), this._register(i.colorProvider.register("*", new hR(e, t)));
  }
};
hT = ehe([
  jk(0, ii),
  jk(1, Ot),
  jk(2, he)
], hT);
Rb(hT);
async function jU(r, e, t, i = !0) {
  return uR(new the(), r, e, t, i);
}
function qU(r, e, t, i) {
  return Promise.resolve(t.provideColorPresentations(r, e, i));
}
class the {
  constructor() {
  }
  async compute(e, t, i, n) {
    const s = await e.provideDocumentColors(t, i);
    if (Array.isArray(s))
      for (const o of s)
        n.push({ colorInfo: o, provider: e });
    return Array.isArray(s);
  }
}
class ihe {
  constructor() {
  }
  async compute(e, t, i, n) {
    const s = await e.provideDocumentColors(t, i);
    if (Array.isArray(s))
      for (const o of s)
        n.push({ range: o.range, color: [o.color.red, o.color.green, o.color.blue, o.color.alpha] });
    return Array.isArray(s);
  }
}
class nhe {
  constructor(e) {
    this.colorInfo = e;
  }
  async compute(e, t, i, n) {
    const s = await e.provideColorPresentations(t, this.colorInfo, at.None);
    return Array.isArray(s) && n.push(...s), Array.isArray(s);
  }
}
async function uR(r, e, t, i, n) {
  let s = !1, o;
  const a = [], l = e.ordered(t);
  for (let d = l.length - 1; d >= 0; d--) {
    const c = l[d];
    if (c instanceof hR)
      o = c;
    else
      try {
        await r.compute(c, t, i, a) && (s = !0);
      } catch (h) {
        _i(h);
      }
  }
  return s ? a : o && n ? (await r.compute(o, t, i, a), a) : [];
}
function GU(r, e) {
  const { colorProvider: t } = r.get(he), i = r.get(ii).getModel(e);
  if (!i)
    throw Ro();
  const n = r.get(Ge).getValue("editor.defaultColorDecorators", { resource: e });
  return { model: i, colorProviderRegistry: t, isDefaultColorDecoratorsEnabled: n };
}
st.registerCommand("_executeDocumentColorProvider", function(r, ...e) {
  const [t] = e;
  if (!(t instanceof Ee))
    throw Ro();
  const { model: i, colorProviderRegistry: n, isDefaultColorDecoratorsEnabled: s } = GU(r, t);
  return uR(new ihe(), n, i, at.None, s);
});
st.registerCommand("_executeColorPresentationProvider", function(r, ...e) {
  const [t, i] = e, { uri: n, range: s } = i;
  if (!(n instanceof Ee) || !Array.isArray(t) || t.length !== 4 || !L.isIRange(s))
    throw Ro();
  const { model: o, colorProviderRegistry: a, isDefaultColorDecoratorsEnabled: l } = GU(r, n), [d, c, h, u] = t;
  return uR(new nhe({ range: s, color: { red: d, green: c, blue: h, alpha: u } }), a, o, at.None, l);
});
var she = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, qk = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, uT;
const ZU = /* @__PURE__ */ Object.create({});
let $c = uT = class extends P {
  constructor(e, t, i, n) {
    super(), this._editor = e, this._configurationService = t, this._languageFeaturesService = i, this._localToDispose = this._register(new q()), this._decorationsIds = [], this._colorDatas = /* @__PURE__ */ new Map(), this._colorDecoratorIds = this._editor.createDecorationsCollection(), this._ruleFactory = new gb(this._editor), this._decoratorLimitReporter = new ohe(), this._colorDecorationClassRefs = this._register(new q()), this._debounceInformation = n.for(i.colorProvider, "Document Colors", { min: uT.RECOMPUTE_TIME }), this._register(e.onDidChangeModel(() => {
      this._isColorDecoratorsEnabled = this.isEnabled(), this.updateColors();
    })), this._register(e.onDidChangeModelLanguage(() => this.updateColors())), this._register(i.colorProvider.onDidChange(() => this.updateColors())), this._register(e.onDidChangeConfiguration((s) => {
      const o = this._isColorDecoratorsEnabled;
      this._isColorDecoratorsEnabled = this.isEnabled(), this._isDefaultColorDecoratorsEnabled = this._editor.getOption(
        147
        /* EditorOption.defaultColorDecorators */
      );
      const a = o !== this._isColorDecoratorsEnabled || s.hasChanged(
        21
        /* EditorOption.colorDecoratorsLimit */
      ), l = s.hasChanged(
        147
        /* EditorOption.defaultColorDecorators */
      );
      (a || l) && (this._isColorDecoratorsEnabled ? this.updateColors() : this.removeAllDecorations());
    })), this._timeoutTimer = null, this._computePromise = null, this._isColorDecoratorsEnabled = this.isEnabled(), this._isDefaultColorDecoratorsEnabled = this._editor.getOption(
      147
      /* EditorOption.defaultColorDecorators */
    ), this.updateColors();
  }
  isEnabled() {
    const e = this._editor.getModel();
    if (!e)
      return !1;
    const t = e.getLanguageId(), i = this._configurationService.getValue(t);
    if (i && typeof i == "object") {
      const n = i.colorDecorators;
      if (n && n.enable !== void 0 && !n.enable)
        return n.enable;
    }
    return this._editor.getOption(
      20
      /* EditorOption.colorDecorators */
    );
  }
  static get(e) {
    return e.getContribution(this.ID);
  }
  dispose() {
    this.stop(), this.removeAllDecorations(), super.dispose();
  }
  updateColors() {
    if (this.stop(), !this._isColorDecoratorsEnabled)
      return;
    const e = this._editor.getModel();
    !e || !this._languageFeaturesService.colorProvider.has(e) || (this._localToDispose.add(this._editor.onDidChangeModelContent(() => {
      this._timeoutTimer || (this._timeoutTimer = new vr(), this._timeoutTimer.cancelAndSet(() => {
        this._timeoutTimer = null, this.beginCompute();
      }, this._debounceInformation.get(e)));
    })), this.beginCompute());
  }
  async beginCompute() {
    this._computePromise = Zi(async (e) => {
      const t = this._editor.getModel();
      if (!t)
        return [];
      const i = new rs(!1), n = await jU(this._languageFeaturesService.colorProvider, t, e, this._isDefaultColorDecoratorsEnabled);
      return this._debounceInformation.update(t, i.elapsed()), n;
    });
    try {
      const e = await this._computePromise;
      this.updateDecorations(e), this.updateColorDecorators(e), this._computePromise = null;
    } catch (e) {
      He(e);
    }
  }
  stop() {
    this._timeoutTimer && (this._timeoutTimer.cancel(), this._timeoutTimer = null), this._computePromise && (this._computePromise.cancel(), this._computePromise = null), this._localToDispose.clear();
  }
  updateDecorations(e) {
    const t = e.map((i) => ({
      range: {
        startLineNumber: i.colorInfo.range.startLineNumber,
        startColumn: i.colorInfo.range.startColumn,
        endLineNumber: i.colorInfo.range.endLineNumber,
        endColumn: i.colorInfo.range.endColumn
      },
      options: Fe.EMPTY
    }));
    this._editor.changeDecorations((i) => {
      this._decorationsIds = i.deltaDecorations(this._decorationsIds, t), this._colorDatas = /* @__PURE__ */ new Map(), this._decorationsIds.forEach((n, s) => this._colorDatas.set(n, e[s]));
    });
  }
  updateColorDecorators(e) {
    this._colorDecorationClassRefs.clear();
    const t = [], i = this._editor.getOption(
      21
      /* EditorOption.colorDecoratorsLimit */
    );
    for (let s = 0; s < e.length && t.length < i; s++) {
      const { red: o, green: a, blue: l, alpha: d } = e[s].colorInfo.color, c = new Qt(Math.round(o * 255), Math.round(a * 255), Math.round(l * 255), d), h = `rgba(${c.r}, ${c.g}, ${c.b}, ${c.a})`, u = this._colorDecorationClassRefs.add(this._ruleFactory.createClassNameRef({
        backgroundColor: h
      }));
      t.push({
        range: {
          startLineNumber: e[s].colorInfo.range.startLineNumber,
          startColumn: e[s].colorInfo.range.startColumn,
          endLineNumber: e[s].colorInfo.range.endLineNumber,
          endColumn: e[s].colorInfo.range.endColumn
        },
        options: {
          description: "colorDetector",
          before: {
            content: _H,
            inlineClassName: `${u.className} colorpicker-color-decoration`,
            inlineClassNameAffectsLetterSpacing: !0,
            attachedData: ZU
          }
        }
      });
    }
    const n = i < e.length ? i : !1;
    this._decoratorLimitReporter.update(e.length, n), this._colorDecoratorIds.set(t);
  }
  removeAllDecorations() {
    this._editor.removeDecorations(this._decorationsIds), this._decorationsIds = [], this._colorDecoratorIds.clear(), this._colorDecorationClassRefs.clear();
  }
  getColorData(e) {
    const t = this._editor.getModel();
    if (!t)
      return null;
    const i = t.getDecorationsInRange(L.fromPositions(e, e)).filter((n) => this._colorDatas.has(n.id));
    return i.length === 0 ? null : this._colorDatas.get(i[0].id);
  }
  isColorDecoration(e) {
    return this._colorDecoratorIds.has(e);
  }
};
$c.ID = "editor.contrib.colorDetector";
$c.RECOMPUTE_TIME = 1e3;
$c = uT = she([
  qk(1, Ge),
  qk(2, he),
  qk(3, Vo)
], $c);
class ohe {
  constructor() {
    this._onDidChange = new R(), this._computed = 0, this._limited = !1;
  }
  update(e, t) {
    (e !== this._computed || t !== this._limited) && (this._computed = e, this._limited = t, this._onDidChange.fire());
  }
}
gt(
  $c.ID,
  $c,
  1
  /* EditorContributionInstantiation.AfterFirstRender */
);
class rhe {
  get color() {
    return this._color;
  }
  set color(e) {
    this._color.equals(e) || (this._color = e, this._onDidChangeColor.fire(e));
  }
  get presentation() {
    return this.colorPresentations[this.presentationIndex];
  }
  get colorPresentations() {
    return this._colorPresentations;
  }
  set colorPresentations(e) {
    this._colorPresentations = e, this.presentationIndex > e.length - 1 && (this.presentationIndex = 0), this._onDidChangePresentation.fire(this.presentation);
  }
  constructor(e, t, i) {
    this.presentationIndex = i, this._onColorFlushed = new R(), this.onColorFlushed = this._onColorFlushed.event, this._onDidChangeColor = new R(), this.onDidChangeColor = this._onDidChangeColor.event, this._onDidChangePresentation = new R(), this.onDidChangePresentation = this._onDidChangePresentation.event, this.originalColor = e, this._color = e, this._colorPresentations = t;
  }
  selectNextColorPresentation() {
    this.presentationIndex = (this.presentationIndex + 1) % this.colorPresentations.length, this.flushColor(), this._onDidChangePresentation.fire(this.presentation);
  }
  guessColorPresentation(e, t) {
    let i = -1;
    for (let n = 0; n < this.colorPresentations.length; n++)
      if (t.toLowerCase() === this.colorPresentations[n].label) {
        i = n;
        break;
      }
    if (i === -1) {
      const n = t.split("(")[0].toLowerCase();
      for (let s = 0; s < this.colorPresentations.length; s++)
        if (this.colorPresentations[s].label.toLowerCase().startsWith(n)) {
          i = s;
          break;
        }
    }
    i !== -1 && i !== this.presentationIndex && (this.presentationIndex = i, this._onDidChangePresentation.fire(this.presentation));
  }
  flushColor() {
    this._onColorFlushed.fire(this._color);
  }
}
const lo = X;
class ahe extends P {
  constructor(e, t, i, n = !1) {
    super(), this.model = t, this.showingStandaloneColorPicker = n, this._closeButton = null, this._domNode = lo(".colorpicker-header"), G(e, this._domNode), this._pickedColorNode = G(this._domNode, lo(".picked-color")), G(this._pickedColorNode, lo("span.codicon.codicon-color-mode")), this._pickedColorPresentation = G(this._pickedColorNode, document.createElement("span")), this._pickedColorPresentation.classList.add("picked-color-presentation");
    const s = p("clickToToggleColorOptions", "Click to toggle color options (rgb/hsl/hex)");
    this._pickedColorNode.setAttribute("title", s), this._originalColorNode = G(this._domNode, lo(".original-color")), this._originalColorNode.style.backgroundColor = z.Format.CSS.format(this.model.originalColor) || "", this.backgroundColor = i.getColorTheme().getColor(CS) || z.white, this._register(i.onDidColorThemeChange((o) => {
      this.backgroundColor = o.getColor(CS) || z.white;
    })), this._register(W(this._pickedColorNode, Q.CLICK, () => this.model.selectNextColorPresentation())), this._register(W(this._originalColorNode, Q.CLICK, () => {
      this.model.color = this.model.originalColor, this.model.flushColor();
    })), this._register(t.onDidChangeColor(this.onDidChangeColor, this)), this._register(t.onDidChangePresentation(this.onDidChangePresentation, this)), this._pickedColorNode.style.backgroundColor = z.Format.CSS.format(t.color) || "", this._pickedColorNode.classList.toggle("light", t.color.rgba.a < 0.5 ? this.backgroundColor.isLighter() : t.color.isLighter()), this.onDidChangeColor(this.model.color), this.showingStandaloneColorPicker && (this._domNode.classList.add("standalone-colorpicker"), this._closeButton = this._register(new lhe(this._domNode)));
  }
  get closeButton() {
    return this._closeButton;
  }
  get pickedColorNode() {
    return this._pickedColorNode;
  }
  get originalColorNode() {
    return this._originalColorNode;
  }
  onDidChangeColor(e) {
    this._pickedColorNode.style.backgroundColor = z.Format.CSS.format(e) || "", this._pickedColorNode.classList.toggle("light", e.rgba.a < 0.5 ? this.backgroundColor.isLighter() : e.isLighter()), this.onDidChangePresentation();
  }
  onDidChangePresentation() {
    this._pickedColorPresentation.textContent = this.model.presentation ? this.model.presentation.label : "";
  }
}
class lhe extends P {
  constructor(e) {
    super(), this._onClicked = this._register(new R()), this.onClicked = this._onClicked.event, this._button = document.createElement("div"), this._button.classList.add("close-button"), G(e, this._button);
    const t = document.createElement("div");
    t.classList.add("close-button-inner-div"), G(this._button, t), G(t, lo(".button" + Le.asCSSSelector(hi("color-picker-close", me.close, p("closeIcon", "Icon to close the color picker"))))).classList.add("close-icon"), this._register(W(this._button, Q.CLICK, () => {
      this._onClicked.fire();
    }));
  }
}
class dhe extends P {
  constructor(e, t, i, n = !1) {
    super(), this.model = t, this.pixelRatio = i, this._insertButton = null, this._domNode = lo(".colorpicker-body"), G(e, this._domNode), this._saturationBox = new che(this._domNode, this.model, this.pixelRatio), this._register(this._saturationBox), this._register(this._saturationBox.onDidChange(this.onDidSaturationValueChange, this)), this._register(this._saturationBox.onColorFlushed(this.flushColor, this)), this._opacityStrip = new hhe(this._domNode, this.model, n), this._register(this._opacityStrip), this._register(this._opacityStrip.onDidChange(this.onDidOpacityChange, this)), this._register(this._opacityStrip.onColorFlushed(this.flushColor, this)), this._hueStrip = new uhe(this._domNode, this.model, n), this._register(this._hueStrip), this._register(this._hueStrip.onDidChange(this.onDidHueChange, this)), this._register(this._hueStrip.onColorFlushed(this.flushColor, this)), n && (this._insertButton = this._register(new ghe(this._domNode)), this._domNode.classList.add("standalone-colorpicker"));
  }
  flushColor() {
    this.model.flushColor();
  }
  onDidSaturationValueChange({ s: e, v: t }) {
    const i = this.model.color.hsva;
    this.model.color = new z(new yw(i.h, e, t, i.a));
  }
  onDidOpacityChange(e) {
    const t = this.model.color.hsva;
    this.model.color = new z(new yw(t.h, t.s, t.v, e));
  }
  onDidHueChange(e) {
    const t = this.model.color.hsva, i = (1 - e) * 360;
    this.model.color = new z(new yw(i === 360 ? 0 : i, t.s, t.v, t.a));
  }
  get domNode() {
    return this._domNode;
  }
  get saturationBox() {
    return this._saturationBox;
  }
  get enterButton() {
    return this._insertButton;
  }
  layout() {
    this._saturationBox.layout(), this._opacityStrip.layout(), this._hueStrip.layout();
  }
}
class che extends P {
  constructor(e, t, i) {
    super(), this.model = t, this.pixelRatio = i, this._onDidChange = new R(), this.onDidChange = this._onDidChange.event, this._onColorFlushed = new R(), this.onColorFlushed = this._onColorFlushed.event, this._domNode = lo(".saturation-wrap"), G(e, this._domNode), this._canvas = document.createElement("canvas"), this._canvas.className = "saturation-box", G(this._domNode, this._canvas), this.selection = lo(".saturation-selection"), G(this._domNode, this.selection), this.layout(), this._register(W(this._domNode, Q.POINTER_DOWN, (n) => this.onPointerDown(n))), this._register(this.model.onDidChangeColor(this.onDidChangeColor, this)), this.monitor = null;
  }
  get domNode() {
    return this._domNode;
  }
  onPointerDown(e) {
    if (!e.target || !(e.target instanceof Element))
      return;
    this.monitor = this._register(new Np());
    const t = Ei(this._domNode);
    e.target !== this.selection && this.onDidChangePosition(e.offsetX, e.offsetY), this.monitor.startMonitoring(e.target, e.pointerId, e.buttons, (n) => this.onDidChangePosition(n.pageX - t.left, n.pageY - t.top), () => null);
    const i = W(e.target.ownerDocument, Q.POINTER_UP, () => {
      this._onColorFlushed.fire(), i.dispose(), this.monitor && (this.monitor.stopMonitoring(!0), this.monitor = null);
    }, !0);
  }
  onDidChangePosition(e, t) {
    const i = Math.max(0, Math.min(1, e / this.width)), n = Math.max(0, Math.min(1, 1 - t / this.height));
    this.paintSelection(i, n), this._onDidChange.fire({ s: i, v: n });
  }
  layout() {
    this.width = this._domNode.offsetWidth, this.height = this._domNode.offsetHeight, this._canvas.width = this.width * this.pixelRatio, this._canvas.height = this.height * this.pixelRatio, this.paint();
    const e = this.model.color.hsva;
    this.paintSelection(e.s, e.v);
  }
  paint() {
    const e = this.model.color.hsva, t = new z(new yw(e.h, 1, 1, 1)), i = this._canvas.getContext("2d"), n = i.createLinearGradient(0, 0, this._canvas.width, 0);
    n.addColorStop(0, "rgba(255, 255, 255, 1)"), n.addColorStop(0.5, "rgba(255, 255, 255, 0.5)"), n.addColorStop(1, "rgba(255, 255, 255, 0)");
    const s = i.createLinearGradient(0, 0, 0, this._canvas.height);
    s.addColorStop(0, "rgba(0, 0, 0, 0)"), s.addColorStop(1, "rgba(0, 0, 0, 1)"), i.rect(0, 0, this._canvas.width, this._canvas.height), i.fillStyle = z.Format.CSS.format(t), i.fill(), i.fillStyle = n, i.fill(), i.fillStyle = s, i.fill();
  }
  paintSelection(e, t) {
    this.selection.style.left = `${e * this.width}px`, this.selection.style.top = `${this.height - t * this.height}px`;
  }
  onDidChangeColor(e) {
    if (this.monitor && this.monitor.isMonitoring())
      return;
    this.paint();
    const t = e.hsva;
    this.paintSelection(t.s, t.v);
  }
}
class YU extends P {
  constructor(e, t, i = !1) {
    super(), this.model = t, this._onDidChange = new R(), this.onDidChange = this._onDidChange.event, this._onColorFlushed = new R(), this.onColorFlushed = this._onColorFlushed.event, i ? (this.domNode = G(e, lo(".standalone-strip")), this.overlay = G(this.domNode, lo(".standalone-overlay"))) : (this.domNode = G(e, lo(".strip")), this.overlay = G(this.domNode, lo(".overlay"))), this.slider = G(this.domNode, lo(".slider")), this.slider.style.top = "0px", this._register(W(this.domNode, Q.POINTER_DOWN, (n) => this.onPointerDown(n))), this._register(t.onDidChangeColor(this.onDidChangeColor, this)), this.layout();
  }
  layout() {
    this.height = this.domNode.offsetHeight - this.slider.offsetHeight;
    const e = this.getValue(this.model.color);
    this.updateSliderPosition(e);
  }
  onDidChangeColor(e) {
    const t = this.getValue(e);
    this.updateSliderPosition(t);
  }
  onPointerDown(e) {
    if (!e.target || !(e.target instanceof Element))
      return;
    const t = this._register(new Np()), i = Ei(this.domNode);
    this.domNode.classList.add("grabbing"), e.target !== this.slider && this.onDidChangeTop(e.offsetY), t.startMonitoring(e.target, e.pointerId, e.buttons, (s) => this.onDidChangeTop(s.pageY - i.top), () => null);
    const n = W(e.target.ownerDocument, Q.POINTER_UP, () => {
      this._onColorFlushed.fire(), n.dispose(), t.stopMonitoring(!0), this.domNode.classList.remove("grabbing");
    }, !0);
  }
  onDidChangeTop(e) {
    const t = Math.max(0, Math.min(1, 1 - e / this.height));
    this.updateSliderPosition(t), this._onDidChange.fire(t);
  }
  updateSliderPosition(e) {
    this.slider.style.top = `${(1 - e) * this.height}px`;
  }
}
class hhe extends YU {
  constructor(e, t, i = !1) {
    super(e, t, i), this.domNode.classList.add("opacity-strip"), this.onDidChangeColor(this.model.color);
  }
  onDidChangeColor(e) {
    super.onDidChangeColor(e);
    const { r: t, g: i, b: n } = e.rgba, s = new z(new Qt(t, i, n, 1)), o = new z(new Qt(t, i, n, 0));
    this.overlay.style.background = `linear-gradient(to bottom, ${s} 0%, ${o} 100%)`;
  }
  getValue(e) {
    return e.hsva.a;
  }
}
class uhe extends YU {
  constructor(e, t, i = !1) {
    super(e, t, i), this.domNode.classList.add("hue-strip");
  }
  getValue(e) {
    return 1 - e.hsva.h / 360;
  }
}
class ghe extends P {
  constructor(e) {
    super(), this._onClicked = this._register(new R()), this.onClicked = this._onClicked.event, this._button = G(e, document.createElement("button")), this._button.classList.add("insert-button"), this._button.textContent = "Insert", this._register(W(this._button, Q.CLICK, () => {
      this._onClicked.fire();
    }));
  }
  get button() {
    return this._button;
  }
}
class fhe extends bo {
  constructor(e, t, i, n, s = !1) {
    super(), this.model = t, this.pixelRatio = i, this._register(O_.getInstance(we(e)).onDidChange(() => this.layout()));
    const o = lo(".colorpicker-widget");
    e.appendChild(o), this.header = this._register(new ahe(o, this.model, n, s)), this.body = this._register(new dhe(o, this.model, this.pixelRatio, s));
  }
  layout() {
    this.body.layout();
  }
}
var QU = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, XU = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
class phe {
  constructor(e, t, i, n) {
    this.owner = e, this.range = t, this.model = i, this.provider = n, this.forceShowAtRange = !0;
  }
  isValidForHoverAnchor(e) {
    return e.type === 1 && this.range.startColumn <= e.range.startColumn && this.range.endColumn >= e.range.endColumn;
  }
}
let Ry = class {
  constructor(e, t) {
    this._editor = e, this._themeService = t, this.hoverOrdinal = 2;
  }
  computeSync(e, t) {
    return [];
  }
  computeAsync(e, t, i) {
    return Ni.fromPromise(this._computeAsync(e, t, i));
  }
  async _computeAsync(e, t, i) {
    if (!this._editor.hasModel())
      return [];
    const n = $c.get(this._editor);
    if (!n)
      return [];
    for (const s of t) {
      if (!n.isColorDecoration(s))
        continue;
      const o = n.getColorData(s.range.getStartPosition());
      if (o)
        return [await JU(this, this._editor.getModel(), o.colorInfo, o.provider)];
    }
    return [];
  }
  renderHoverParts(e, t) {
    return e4(this, this._editor, this._themeService, t, e);
  }
};
Ry = QU([
  XU(1, $i)
], Ry);
class mhe {
  constructor(e, t, i, n) {
    this.owner = e, this.range = t, this.model = i, this.provider = n;
  }
}
let Nv = class {
  constructor(e, t) {
    this._editor = e, this._themeService = t, this._color = null;
  }
  async createColorHover(e, t, i) {
    if (!this._editor.hasModel() || !$c.get(this._editor))
      return null;
    const s = await jU(i, this._editor.getModel(), at.None);
    let o = null, a = null;
    for (const h of s) {
      const u = h.colorInfo;
      L.containsRange(u.range, e.range) && (o = u, a = h.provider);
    }
    const l = o ?? e, d = a ?? t, c = !!o;
    return { colorHover: await JU(this, this._editor.getModel(), l, d), foundInEditor: c };
  }
  async updateEditorModel(e) {
    if (!this._editor.hasModel())
      return;
    const t = e.model;
    let i = new L(e.range.startLineNumber, e.range.startColumn, e.range.endLineNumber, e.range.endColumn);
    this._color && (await Zw(this._editor.getModel(), t, this._color, i, e), i = t4(this._editor, i, t));
  }
  renderHoverParts(e, t) {
    return e4(this, this._editor, this._themeService, t, e);
  }
  set color(e) {
    this._color = e;
  }
  get color() {
    return this._color;
  }
};
Nv = QU([
  XU(1, $i)
], Nv);
async function JU(r, e, t, i) {
  const n = e.getValueInRange(t.range), { red: s, green: o, blue: a, alpha: l } = t.color, d = new Qt(Math.round(s * 255), Math.round(o * 255), Math.round(a * 255), l), c = new z(d), h = await qU(e, t, i, at.None), u = new rhe(c, [], 0);
  return u.colorPresentations = h || [], u.guessColorPresentation(c, n), r instanceof Ry ? new phe(r, L.lift(t.range), u, i) : new mhe(r, L.lift(t.range), u, i);
}
function e4(r, e, t, i, n) {
  if (i.length === 0 || !e.hasModel())
    return P.None;
  if (n.setMinimumDimensions) {
    const u = e.getOption(
      67
      /* EditorOption.lineHeight */
    ) + 8;
    n.setMinimumDimensions(new pt(302, u));
  }
  const s = new q(), o = i[0], a = e.getModel(), l = o.model, d = s.add(new fhe(n.fragment, l, e.getOption(
    143
    /* EditorOption.pixelRatio */
  ), t, r instanceof Nv));
  n.setColorPicker(d);
  let c = !1, h = new L(o.range.startLineNumber, o.range.startColumn, o.range.endLineNumber, o.range.endColumn);
  if (r instanceof Nv) {
    const u = i[0].model.color;
    r.color = u, Zw(a, l, u, h, o), s.add(l.onColorFlushed((g) => {
      r.color = g;
    }));
  } else
    s.add(l.onColorFlushed(async (u) => {
      await Zw(a, l, u, h, o), c = !0, h = t4(e, h, l);
    }));
  return s.add(l.onDidChangeColor((u) => {
    Zw(a, l, u, h, o);
  })), s.add(e.onDidChangeModelContent((u) => {
    c ? c = !1 : (n.hide(), e.focus());
  })), s;
}
function t4(r, e, t) {
  var i, n;
  const s = [], o = (i = t.presentation.textEdit) !== null && i !== void 0 ? i : { range: e, text: t.presentation.label, forceMoveMarkers: !1 };
  s.push(o), t.presentation.additionalTextEdits && s.push(...t.presentation.additionalTextEdits);
  const a = L.lift(o.range), l = r.getModel()._setTrackedRange(
    null,
    a,
    3
    /* TrackedRangeStickiness.GrowsOnlyWhenTypingAfter */
  );
  return r.executeEdits("colorpicker", s), r.pushUndoStop(), (n = r.getModel()._getTrackedRange(l)) !== null && n !== void 0 ? n : a;
}
async function Zw(r, e, t, i, n) {
  const s = await qU(r, {
    range: i,
    color: {
      red: t.rgba.r / 255,
      green: t.rgba.g / 255,
      blue: t.rgba.b / 255,
      alpha: t.rgba.a
    }
  }, n.provider, at.None);
  e.colorPresentations = s || [];
}
const i4 = "editor.action.showHover", _he = "editor.action.showDefinitionPreviewHover", vhe = "editor.action.scrollUpHover", bhe = "editor.action.scrollDownHover", Che = "editor.action.scrollLeftHover", whe = "editor.action.scrollRightHover", She = "editor.action.pageUpHover", yhe = "editor.action.pageDownHover", Lhe = "editor.action.goToTopHover", Dhe = "editor.action.goToBottomHover", DL = "editor.action.increaseHoverVerbosityLevel", khe = p({ key: "increaseHoverVerbosityLevel", comment: ["Label for action that will increase the hover verbosity level."] }, "Increase Hover Verbosity Level"), kL = "editor.action.decreaseHoverVerbosityLevel", xhe = p({ key: "decreaseHoverVerbosityLevel", comment: ["Label for action that will decrease the hover verbosity level."] }, "Decrease Hover Verbosity Level"), n4 = "editor.action.inlineSuggest.commit", s4 = "editor.action.inlineSuggest.showPrevious", o4 = "editor.action.inlineSuggest.showNext";
var gR = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, or = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, Yw;
let gT = class extends P {
  constructor(e, t, i) {
    super(), this.editor = e, this.model = t, this.instantiationService = i, this.alwaysShowToolbar = Lt(this.editor.onDidChangeConfiguration, () => this.editor.getOption(
      62
      /* EditorOption.inlineSuggest */
    ).showToolbar === "always"), this.sessionPosition = void 0, this.position = Pe(this, (n) => {
      var s, o, a;
      const l = (s = this.model.read(n)) === null || s === void 0 ? void 0 : s.primaryGhostText.read(n);
      if (!this.alwaysShowToolbar.read(n) || !l || l.parts.length === 0)
        return this.sessionPosition = void 0, null;
      const d = l.parts[0].column;
      this.sessionPosition && this.sessionPosition.lineNumber !== l.lineNumber && (this.sessionPosition = void 0);
      const c = new A(l.lineNumber, Math.min(d, (a = (o = this.sessionPosition) === null || o === void 0 ? void 0 : o.column) !== null && a !== void 0 ? a : Number.MAX_SAFE_INTEGER));
      return this.sessionPosition = c, c;
    }), this._register(Wo((n, s) => {
      const o = this.model.read(n);
      if (!o || !this.alwaysShowToolbar.read(n))
        return;
      const a = ig((d, c) => {
        const h = c.add(this.instantiationService.createInstance(Kc, this.editor, !0, this.position, o.selectedInlineCompletionIndex, o.inlineCompletionsCount, o.activeCommands));
        return e.addContentWidget(h), c.add(Se(() => e.removeContentWidget(h))), c.add(qe((u) => {
          this.position.read(u) && o.lastTriggerKind.read(u) !== nu.Explicit && o.triggerExplicitly();
        })), h;
      }), l = Cie(this, (d, c) => !!this.position.read(d) || !!c);
      s.add(qe((d) => {
        l.read(d) && a.read(d);
      }));
    }));
  }
};
gT = gR([
  or(2, be)
], gT);
const Ihe = hi("inline-suggestion-hints-next", me.chevronRight, p("parameterHintsNextIcon", "Icon for show next parameter hint.")), Ehe = hi("inline-suggestion-hints-previous", me.chevronLeft, p("parameterHintsPreviousIcon", "Icon for show previous parameter hint."));
let Kc = Yw = class extends P {
  static get dropDownVisible() {
    return this._dropDownVisible;
  }
  createCommandAction(e, t, i) {
    const n = new Bs(e, t, i, !0, () => this._commandService.executeCommand(e)), s = this.keybindingService.lookupKeybinding(e, this._contextKeyService);
    let o = t;
    return s && (o = p({ key: "content", comment: ["A label", "A keybinding"] }, "{0} ({1})", t, s.getLabel())), n.tooltip = o, n;
  }
  constructor(e, t, i, n, s, o, a, l, d, c, h) {
    super(), this.editor = e, this.withBorder = t, this._position = i, this._currentSuggestionIdx = n, this._suggestionCount = s, this._extraCommands = o, this._commandService = a, this.keybindingService = d, this._contextKeyService = c, this._menuService = h, this.id = `InlineSuggestionHintsContentWidget${Yw.id++}`, this.allowEditorOverflow = !0, this.suppressMouseDown = !1, this.nodes = ft("div.inlineSuggestionsHints", { className: this.withBorder ? ".withBorder" : "" }, [
      ft("div@toolBar")
    ]), this.previousAction = this.createCommandAction(s4, p("previous", "Previous"), Le.asClassName(Ehe)), this.availableSuggestionCountAction = new Bs("inlineSuggestionHints.availableSuggestionCount", "", void 0, !1), this.nextAction = this.createCommandAction(o4, p("next", "Next"), Le.asClassName(Ihe)), this.inlineCompletionsActionsMenus = this._register(this._menuService.createMenu(D.InlineCompletionsActions, this._contextKeyService)), this.clearAvailableSuggestionCountLabelDebounced = this._register(new xt(() => {
      this.availableSuggestionCountAction.label = "";
    }, 100)), this.disableButtonsDebounced = this._register(new xt(() => {
      this.previousAction.enabled = this.nextAction.enabled = !1;
    }, 100)), this.toolBar = this._register(l.createInstance(fT, this.nodes.toolBar, D.InlineSuggestionToolbar, {
      menuOptions: { renderShortTitle: !0 },
      toolbarOptions: { primaryGroup: (u) => u.startsWith("primary") },
      actionViewItemProvider: (u, g) => {
        if (u instanceof Hs)
          return l.createInstance(Nhe, u, void 0);
        if (u === this.availableSuggestionCountAction) {
          const f = new The(void 0, u, { label: !0, icon: !1 });
          return f.setClass("availableSuggestionCount"), f;
        }
      },
      telemetrySource: "InlineSuggestionToolbar"
    })), this.toolBar.setPrependedPrimaryActions([
      this.previousAction,
      this.availableSuggestionCountAction,
      this.nextAction
    ]), this._register(this.toolBar.onDidChangeDropdownVisibility((u) => {
      Yw._dropDownVisible = u;
    })), this._register(qe((u) => {
      this._position.read(u), this.editor.layoutContentWidget(this);
    })), this._register(qe((u) => {
      const g = this._suggestionCount.read(u), f = this._currentSuggestionIdx.read(u);
      g !== void 0 ? (this.clearAvailableSuggestionCountLabelDebounced.cancel(), this.availableSuggestionCountAction.label = `${f + 1}/${g}`) : this.clearAvailableSuggestionCountLabelDebounced.schedule(), g !== void 0 && g > 1 ? (this.disableButtonsDebounced.cancel(), this.previousAction.enabled = this.nextAction.enabled = !0) : this.disableButtonsDebounced.schedule();
    })), this._register(qe((u) => {
      const f = this._extraCommands.read(u).map((m) => ({
        class: void 0,
        id: m.id,
        enabled: !0,
        tooltip: m.tooltip || "",
        label: m.title,
        run: (_) => this._commandService.executeCommand(m.id)
      }));
      for (const [m, _] of this.inlineCompletionsActionsMenus.getActions())
        for (const v of _)
          v instanceof Hs && f.push(v);
      f.length > 0 && f.unshift(new Oi()), this.toolBar.setAdditionalSecondaryActions(f);
    }));
  }
  getId() {
    return this.id;
  }
  getDomNode() {
    return this.nodes.root;
  }
  getPosition() {
    return {
      position: this._position.get(),
      preference: [
        1,
        2
        /* ContentWidgetPositionPreference.BELOW */
      ],
      positionAffinity: 3
    };
  }
};
Kc._dropDownVisible = !1;
Kc.id = 0;
Kc = Yw = gR([
  or(6, $t),
  or(7, be),
  or(8, _t),
  or(9, De),
  or(10, vo)
], Kc);
class The extends sp {
  constructor() {
    super(...arguments), this._className = void 0;
  }
  setClass(e) {
    this._className = e;
  }
  render(e) {
    super.render(e), this._className && e.classList.add(this._className);
  }
  updateTooltip() {
  }
}
let Nhe = class extends Hc {
  updateLabel() {
    const e = this._keybindingService.lookupKeybinding(this._action.id, this._contextKeyService);
    if (!e)
      return super.updateLabel();
    if (this.label) {
      const t = ft("div.keybinding").root;
      this._register(new Op(t, Os, { disableTitle: !0, ...c3 })).set(e), this.label.textContent = this._action.label, this.label.appendChild(t), this.label.classList.add("inlineSuggestionStatusBarItemLabel");
    }
  }
  updateTooltip() {
  }
}, fT = class extends yv {
  constructor(e, t, i, n, s, o, a, l, d) {
    super(e, { resetMenu: t, ...i }, n, s, o, a, l, d), this.menuId = t, this.options2 = i, this.menuService = n, this.contextKeyService = s, this.menu = this._store.add(this.menuService.createMenu(this.menuId, this.contextKeyService, { emitEventsForSubmenuChanges: !0 })), this.additionalActions = [], this.prependedPrimaryActions = [], this._store.add(this.menu.onDidChange(() => this.updateToolbar())), this.updateToolbar();
  }
  updateToolbar() {
    var e, t, i, n, s, o, a;
    const l = [], d = [];
    eL(this.menu, (e = this.options2) === null || e === void 0 ? void 0 : e.menuOptions, { primary: l, secondary: d }, (i = (t = this.options2) === null || t === void 0 ? void 0 : t.toolbarOptions) === null || i === void 0 ? void 0 : i.primaryGroup, (s = (n = this.options2) === null || n === void 0 ? void 0 : n.toolbarOptions) === null || s === void 0 ? void 0 : s.shouldInlineSubmenu, (a = (o = this.options2) === null || o === void 0 ? void 0 : o.toolbarOptions) === null || a === void 0 ? void 0 : a.useSeparatorsInPrimaryActions), d.push(...this.additionalActions), l.unshift(...this.prependedPrimaryActions), this.setActions(l, d);
  }
  setPrependedPrimaryActions(e) {
    ci(this.prependedPrimaryActions, e, (t, i) => t === i) || (this.prependedPrimaryActions = e, this.updateToolbar());
  }
  setAdditionalSecondaryActions(e) {
    ci(this.additionalActions, e, (t, i) => t === i) || (this.additionalActions = e, this.updateToolbar());
  }
};
fT = gR([
  or(3, vo),
  or(4, De),
  or(5, Zs),
  or(6, _t),
  or(7, $t),
  or(8, kn)
], fT);
class fR {
  constructor() {
    this._onDidWillResize = new R(), this.onDidWillResize = this._onDidWillResize.event, this._onDidResize = new R(), this.onDidResize = this._onDidResize.event, this._sashListener = new q(), this._size = new pt(0, 0), this._minSize = new pt(0, 0), this._maxSize = new pt(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER), this.domNode = document.createElement("div"), this._eastSash = new En(this.domNode, { getVerticalSashLeft: () => this._size.width }, {
      orientation: 0
      /* Orientation.VERTICAL */
    }), this._westSash = new En(this.domNode, { getVerticalSashLeft: () => 0 }, {
      orientation: 0
      /* Orientation.VERTICAL */
    }), this._northSash = new En(this.domNode, { getHorizontalSashTop: () => 0 }, { orientation: 1, orthogonalEdge: ny.North }), this._southSash = new En(this.domNode, { getHorizontalSashTop: () => this._size.height }, { orientation: 1, orthogonalEdge: ny.South }), this._northSash.orthogonalStartSash = this._westSash, this._northSash.orthogonalEndSash = this._eastSash, this._southSash.orthogonalStartSash = this._westSash, this._southSash.orthogonalEndSash = this._eastSash;
    let e, t = 0, i = 0;
    this._sashListener.add(ne.any(this._northSash.onDidStart, this._eastSash.onDidStart, this._southSash.onDidStart, this._westSash.onDidStart)(() => {
      e === void 0 && (this._onDidWillResize.fire(), e = this._size, t = 0, i = 0);
    })), this._sashListener.add(ne.any(this._northSash.onDidEnd, this._eastSash.onDidEnd, this._southSash.onDidEnd, this._westSash.onDidEnd)(() => {
      e !== void 0 && (e = void 0, t = 0, i = 0, this._onDidResize.fire({ dimension: this._size, done: !0 }));
    })), this._sashListener.add(this._eastSash.onDidChange((n) => {
      e && (i = n.currentX - n.startX, this.layout(e.height + t, e.width + i), this._onDidResize.fire({ dimension: this._size, done: !1, east: !0 }));
    })), this._sashListener.add(this._westSash.onDidChange((n) => {
      e && (i = -(n.currentX - n.startX), this.layout(e.height + t, e.width + i), this._onDidResize.fire({ dimension: this._size, done: !1, west: !0 }));
    })), this._sashListener.add(this._northSash.onDidChange((n) => {
      e && (t = -(n.currentY - n.startY), this.layout(e.height + t, e.width + i), this._onDidResize.fire({ dimension: this._size, done: !1, north: !0 }));
    })), this._sashListener.add(this._southSash.onDidChange((n) => {
      e && (t = n.currentY - n.startY, this.layout(e.height + t, e.width + i), this._onDidResize.fire({ dimension: this._size, done: !1, south: !0 }));
    })), this._sashListener.add(ne.any(this._eastSash.onDidReset, this._westSash.onDidReset)((n) => {
      this._preferredSize && (this.layout(this._size.height, this._preferredSize.width), this._onDidResize.fire({ dimension: this._size, done: !0 }));
    })), this._sashListener.add(ne.any(this._northSash.onDidReset, this._southSash.onDidReset)((n) => {
      this._preferredSize && (this.layout(this._preferredSize.height, this._size.width), this._onDidResize.fire({ dimension: this._size, done: !0 }));
    }));
  }
  dispose() {
    this._northSash.dispose(), this._southSash.dispose(), this._eastSash.dispose(), this._westSash.dispose(), this._sashListener.dispose(), this._onDidResize.dispose(), this._onDidWillResize.dispose(), this.domNode.remove();
  }
  enableSashes(e, t, i, n) {
    this._northSash.state = e ? 3 : 0, this._eastSash.state = t ? 3 : 0, this._southSash.state = i ? 3 : 0, this._westSash.state = n ? 3 : 0;
  }
  layout(e = this.size.height, t = this.size.width) {
    const { height: i, width: n } = this._minSize, { height: s, width: o } = this._maxSize;
    e = Math.max(i, Math.min(s, e)), t = Math.max(n, Math.min(o, t));
    const a = new pt(t, e);
    pt.equals(a, this._size) || (this.domNode.style.height = e + "px", this.domNode.style.width = t + "px", this._size = a, this._northSash.layout(), this._eastSash.layout(), this._southSash.layout(), this._westSash.layout());
  }
  clearSashHoverState() {
    this._eastSash.clearSashHoverState(), this._westSash.clearSashHoverState(), this._northSash.clearSashHoverState(), this._southSash.clearSashHoverState();
  }
  get size() {
    return this._size;
  }
  set maxSize(e) {
    this._maxSize = e;
  }
  get maxSize() {
    return this._maxSize;
  }
  set minSize(e) {
    this._minSize = e;
  }
  get minSize() {
    return this._minSize;
  }
  set preferredSize(e) {
    this._preferredSize = e;
  }
  get preferredSize() {
    return this._preferredSize;
  }
}
const Mhe = 30, Rhe = 24;
class Ahe extends P {
  constructor(e, t = new pt(10, 10)) {
    super(), this._editor = e, this.allowEditorOverflow = !0, this.suppressMouseDown = !1, this._resizableNode = this._register(new fR()), this._contentPosition = null, this._isResizing = !1, this._resizableNode.domNode.style.position = "absolute", this._resizableNode.minSize = pt.lift(t), this._resizableNode.layout(t.height, t.width), this._resizableNode.enableSashes(!0, !0, !0, !0), this._register(this._resizableNode.onDidResize((i) => {
      this._resize(new pt(i.dimension.width, i.dimension.height)), i.done && (this._isResizing = !1);
    })), this._register(this._resizableNode.onDidWillResize(() => {
      this._isResizing = !0;
    }));
  }
  get isResizing() {
    return this._isResizing;
  }
  getDomNode() {
    return this._resizableNode.domNode;
  }
  getPosition() {
    return this._contentPosition;
  }
  get position() {
    var e;
    return !((e = this._contentPosition) === null || e === void 0) && e.position ? A.lift(this._contentPosition.position) : void 0;
  }
  _availableVerticalSpaceAbove(e) {
    const t = this._editor.getDomNode(), i = this._editor.getScrolledVisiblePosition(e);
    return !t || !i ? void 0 : Ei(t).top + i.top - Mhe;
  }
  _availableVerticalSpaceBelow(e) {
    const t = this._editor.getDomNode(), i = this._editor.getScrolledVisiblePosition(e);
    if (!t || !i)
      return;
    const n = Ei(t), s = Rc(t.ownerDocument.body), o = n.top + i.top + i.height;
    return s.height - o - Rhe;
  }
  _findPositionPreference(e, t) {
    var i, n;
    const s = Math.min((i = this._availableVerticalSpaceBelow(t)) !== null && i !== void 0 ? i : 1 / 0, e), o = Math.min((n = this._availableVerticalSpaceAbove(t)) !== null && n !== void 0 ? n : 1 / 0, e), a = Math.min(Math.max(o, s), e), l = Math.min(e, a);
    let d;
    return this._editor.getOption(
      60
      /* EditorOption.hover */
    ).above ? d = l <= o ? 1 : 2 : d = l <= s ? 2 : 1, d === 1 ? this._resizableNode.enableSashes(!0, !0, !1, !1) : this._resizableNode.enableSashes(!1, !0, !0, !1), d;
  }
  _resize(e) {
    this._resizableNode.layout(e.height, e.width);
  }
}
var Phe = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, qC = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, ya;
const SW = 30, Ohe = 6;
let fp = ya = class extends Ahe {
  get isColorPickerVisible() {
    var e;
    return !!(!((e = this._visibleData) === null || e === void 0) && e.colorPicker);
  }
  get isVisibleFromKeyboard() {
    var e;
    return ((e = this._visibleData) === null || e === void 0 ? void 0 : e.source) === 1;
  }
  get isVisible() {
    var e;
    return (e = this._hoverVisibleKey.get()) !== null && e !== void 0 ? e : !1;
  }
  get isFocused() {
    var e;
    return (e = this._hoverFocusedKey.get()) !== null && e !== void 0 ? e : !1;
  }
  constructor(e, t, i, n, s) {
    const o = e.getOption(
      67
      /* EditorOption.lineHeight */
    ) + 8, a = 150, l = new pt(a, o);
    super(e, l), this._configurationService = i, this._accessibilityService = n, this._keybindingService = s, this._hover = this._register(new iM()), this._minimumSize = l, this._hoverVisibleKey = x.hoverVisible.bindTo(t), this._hoverFocusedKey = x.hoverFocused.bindTo(t), G(this._resizableNode.domNode, this._hover.containerDomNode), this._resizableNode.domNode.style.zIndex = "50", this._register(this._editor.onDidLayoutChange(() => {
      this.isVisible && this._updateMaxDimensions();
    })), this._register(this._editor.onDidChangeConfiguration((c) => {
      c.hasChanged(
        50
        /* EditorOption.fontInfo */
      ) && this._updateFont();
    }));
    const d = this._register(Xr(this._resizableNode.domNode));
    this._register(d.onDidFocus(() => {
      this._hoverFocusedKey.set(!0);
    })), this._register(d.onDidBlur(() => {
      this._hoverFocusedKey.set(!1);
    })), this._setHoverData(void 0), this._editor.addContentWidget(this);
  }
  dispose() {
    var e;
    super.dispose(), (e = this._visibleData) === null || e === void 0 || e.disposables.dispose(), this._editor.removeContentWidget(this);
  }
  getId() {
    return ya.ID;
  }
  static _applyDimensions(e, t, i) {
    const n = typeof t == "number" ? `${t}px` : t, s = typeof i == "number" ? `${i}px` : i;
    e.style.width = n, e.style.height = s;
  }
  _setContentsDomNodeDimensions(e, t) {
    const i = this._hover.contentsDomNode;
    return ya._applyDimensions(i, e, t);
  }
  _setContainerDomNodeDimensions(e, t) {
    const i = this._hover.containerDomNode;
    return ya._applyDimensions(i, e, t);
  }
  _setHoverWidgetDimensions(e, t) {
    this._setContentsDomNodeDimensions(e, t), this._setContainerDomNodeDimensions(e, t), this._layoutContentWidget();
  }
  static _applyMaxDimensions(e, t, i) {
    const n = typeof t == "number" ? `${t}px` : t, s = typeof i == "number" ? `${i}px` : i;
    e.style.maxWidth = n, e.style.maxHeight = s;
  }
  _setHoverWidgetMaxDimensions(e, t) {
    ya._applyMaxDimensions(this._hover.contentsDomNode, e, t), ya._applyMaxDimensions(this._hover.containerDomNode, e, t), this._hover.containerDomNode.style.setProperty("--vscode-hover-maxWidth", typeof e == "number" ? `${e}px` : e), this._layoutContentWidget();
  }
  _setAdjustedHoverWidgetDimensions(e) {
    this._setHoverWidgetMaxDimensions("none", "none");
    const t = e.width, i = e.height;
    this._setHoverWidgetDimensions(t, i);
  }
  _updateResizableNodeMaxDimensions() {
    var e, t;
    const i = (e = this._findMaximumRenderingWidth()) !== null && e !== void 0 ? e : 1 / 0, n = (t = this._findMaximumRenderingHeight()) !== null && t !== void 0 ? t : 1 / 0;
    this._resizableNode.maxSize = new pt(i, n), this._setHoverWidgetMaxDimensions(i, n);
  }
  _resize(e) {
    var t, i;
    ya._lastDimensions = new pt(e.width, e.height), this._setAdjustedHoverWidgetDimensions(e), this._resizableNode.layout(e.height, e.width), this._updateResizableNodeMaxDimensions(), this._hover.scrollbar.scanDomNode(), this._editor.layoutContentWidget(this), (i = (t = this._visibleData) === null || t === void 0 ? void 0 : t.colorPicker) === null || i === void 0 || i.layout();
  }
  _findAvailableSpaceVertically() {
    var e;
    const t = (e = this._visibleData) === null || e === void 0 ? void 0 : e.showAtPosition;
    if (t)
      return this._positionPreference === 1 ? this._availableVerticalSpaceAbove(t) : this._availableVerticalSpaceBelow(t);
  }
  _findMaximumRenderingHeight() {
    const e = this._findAvailableSpaceVertically();
    if (!e)
      return;
    let t = Ohe;
    return Array.from(this._hover.contentsDomNode.children).forEach((i) => {
      t += i.clientHeight;
    }), Math.min(e, t);
  }
  _isHoverTextOverflowing() {
    this._hover.containerDomNode.style.setProperty("--vscode-hover-whiteSpace", "nowrap"), this._hover.containerDomNode.style.setProperty("--vscode-hover-sourceWhiteSpace", "nowrap");
    const e = Array.from(this._hover.contentsDomNode.children).some((t) => t.scrollWidth > t.clientWidth);
    return this._hover.containerDomNode.style.removeProperty("--vscode-hover-whiteSpace"), this._hover.containerDomNode.style.removeProperty("--vscode-hover-sourceWhiteSpace"), e;
  }
  _findMaximumRenderingWidth() {
    if (!this._editor || !this._editor.hasModel())
      return;
    const e = this._isHoverTextOverflowing(), t = typeof this._contentWidth > "u" ? 0 : this._contentWidth - 2;
    return e || this._hover.containerDomNode.clientWidth < t ? Rc(this._hover.containerDomNode.ownerDocument.body).width - 14 : this._hover.containerDomNode.clientWidth + 2;
  }
  isMouseGettingCloser(e, t) {
    if (!this._visibleData)
      return !1;
    if (typeof this._visibleData.initialMousePosX > "u" || typeof this._visibleData.initialMousePosY > "u")
      return this._visibleData.initialMousePosX = e, this._visibleData.initialMousePosY = t, !1;
    const i = Ei(this.getDomNode());
    typeof this._visibleData.closestMouseDistance > "u" && (this._visibleData.closestMouseDistance = yW(this._visibleData.initialMousePosX, this._visibleData.initialMousePosY, i.left, i.top, i.width, i.height));
    const n = yW(e, t, i.left, i.top, i.width, i.height);
    return n > this._visibleData.closestMouseDistance + 4 ? !1 : (this._visibleData.closestMouseDistance = Math.min(this._visibleData.closestMouseDistance, n), !0);
  }
  _setHoverData(e) {
    var t;
    (t = this._visibleData) === null || t === void 0 || t.disposables.dispose(), this._visibleData = e, this._hoverVisibleKey.set(!!e), this._hover.containerDomNode.classList.toggle("hidden", !e);
  }
  _updateFont() {
    const { fontSize: e, lineHeight: t } = this._editor.getOption(
      50
      /* EditorOption.fontInfo */
    ), i = this._hover.contentsDomNode;
    i.style.fontSize = `${e}px`, i.style.lineHeight = `${t / e}`, Array.prototype.slice.call(this._hover.contentsDomNode.getElementsByClassName("code")).forEach((s) => this._editor.applyFontInfo(s));
  }
  _updateContent(e) {
    const t = this._hover.contentsDomNode;
    t.style.paddingBottom = "", t.textContent = "", t.appendChild(e);
  }
  _layoutContentWidget() {
    this._editor.layoutContentWidget(this), this._hover.onContentsChanged();
  }
  _updateMaxDimensions() {
    const e = Math.max(this._editor.getLayoutInfo().height / 4, 250, ya._lastDimensions.height), t = Math.max(this._editor.getLayoutInfo().width * 0.66, 500, ya._lastDimensions.width);
    this._setHoverWidgetMaxDimensions(t, e);
  }
  _render(e, t) {
    this._setHoverData(t), this._updateFont(), this._updateContent(e), this._updateMaxDimensions(), this.onContentsChanged(), this._editor.render();
  }
  getPosition() {
    var e;
    return this._visibleData ? {
      position: this._visibleData.showAtPosition,
      secondaryPosition: this._visibleData.showAtSecondaryPosition,
      positionAffinity: this._visibleData.isBeforeContent ? 3 : void 0,
      preference: [
        (e = this._positionPreference) !== null && e !== void 0 ? e : 1
        /* ContentWidgetPositionPreference.ABOVE */
      ]
    } : null;
  }
  showAt(e, t) {
    var i, n, s, o;
    if (!this._editor || !this._editor.hasModel())
      return;
    this._render(e, t);
    const a = Bl(this._hover.containerDomNode), l = t.showAtPosition;
    this._positionPreference = (i = this._findPositionPreference(a, l)) !== null && i !== void 0 ? i : 1, this.onContentsChanged(), t.stoleFocus && this._hover.containerDomNode.focus(), (n = t.colorPicker) === null || n === void 0 || n.layout();
    const c = this._hover.containerDomNode.ownerDocument.activeElement === this._hover.containerDomNode && Y2(this._configurationService.getValue("accessibility.verbosity.hover") === !0 && this._accessibilityService.isScreenReaderOptimized(), (o = (s = this._keybindingService.lookupKeybinding("editor.action.accessibleView")) === null || s === void 0 ? void 0 : s.getAriaLabel()) !== null && o !== void 0 ? o : "");
    c && (this._hover.contentsDomNode.ariaLabel = this._hover.contentsDomNode.textContent + ", " + c);
  }
  hide() {
    if (!this._visibleData)
      return;
    const e = this._visibleData.stoleFocus || this._hoverFocusedKey.get();
    this._setHoverData(void 0), this._resizableNode.maxSize = new pt(1 / 0, 1 / 0), this._resizableNode.clearSashHoverState(), this._hoverFocusedKey.set(!1), this._editor.layoutContentWidget(this), e && this._editor.focus();
  }
  _removeConstraintsRenderNormally() {
    const e = this._editor.getLayoutInfo();
    this._resizableNode.layout(e.height, e.width), this._setHoverWidgetDimensions("auto", "auto");
  }
  setMinimumDimensions(e) {
    this._minimumSize = new pt(Math.max(this._minimumSize.width, e.width), Math.max(this._minimumSize.height, e.height)), this._updateMinimumWidth();
  }
  _updateMinimumWidth() {
    const e = typeof this._contentWidth > "u" ? this._minimumSize.width : Math.min(this._contentWidth, this._minimumSize.width);
    this._resizableNode.minSize = new pt(e, this._minimumSize.height);
  }
  onContentsChanged() {
    var e;
    this._removeConstraintsRenderNormally();
    const t = this._hover.containerDomNode;
    let i = Bl(t), n = Ms(t);
    if (this._resizableNode.layout(i, n), this._setHoverWidgetDimensions(n, i), i = Bl(t), n = Ms(t), this._contentWidth = n, this._updateMinimumWidth(), this._resizableNode.layout(i, n), !((e = this._visibleData) === null || e === void 0) && e.showAtPosition) {
      const s = Bl(this._hover.containerDomNode);
      this._positionPreference = this._findPositionPreference(s, this._visibleData.showAtPosition);
    }
    this._layoutContentWidget();
  }
  focus() {
    this._hover.containerDomNode.focus();
  }
  scrollUp() {
    const e = this._hover.scrollbar.getScrollPosition().scrollTop, t = this._editor.getOption(
      50
      /* EditorOption.fontInfo */
    );
    this._hover.scrollbar.setScrollPosition({ scrollTop: e - t.lineHeight });
  }
  scrollDown() {
    const e = this._hover.scrollbar.getScrollPosition().scrollTop, t = this._editor.getOption(
      50
      /* EditorOption.fontInfo */
    );
    this._hover.scrollbar.setScrollPosition({ scrollTop: e + t.lineHeight });
  }
  scrollLeft() {
    const e = this._hover.scrollbar.getScrollPosition().scrollLeft;
    this._hover.scrollbar.setScrollPosition({ scrollLeft: e - SW });
  }
  scrollRight() {
    const e = this._hover.scrollbar.getScrollPosition().scrollLeft;
    this._hover.scrollbar.setScrollPosition({ scrollLeft: e + SW });
  }
  pageUp() {
    const e = this._hover.scrollbar.getScrollPosition().scrollTop, t = this._hover.scrollbar.getScrollDimensions().height;
    this._hover.scrollbar.setScrollPosition({ scrollTop: e - t });
  }
  pageDown() {
    const e = this._hover.scrollbar.getScrollPosition().scrollTop, t = this._hover.scrollbar.getScrollDimensions().height;
    this._hover.scrollbar.setScrollPosition({ scrollTop: e + t });
  }
  goToTop() {
    this._hover.scrollbar.setScrollPosition({ scrollTop: 0 });
  }
  goToBottom() {
    this._hover.scrollbar.setScrollPosition({ scrollTop: this._hover.scrollbar.getScrollDimensions().scrollHeight });
  }
};
fp.ID = "editor.contrib.resizableContentHoverWidget";
fp._lastDimensions = new pt(0, 0);
fp = ya = Phe([
  qC(1, De),
  qC(2, Ge),
  qC(3, qs),
  qC(4, _t)
], fp);
function yW(r, e, t, i, n, s) {
  const o = t + n / 2, a = i + s / 2, l = Math.max(Math.abs(r - o) - n / 2, 0), d = Math.max(Math.abs(e - a) - s / 2, 0);
  return Math.sqrt(l * l + d * d);
}
let Fhe = class {
  constructor(e, t, i) {
    this.value = e, this.isComplete = t, this.hasLoadingMessage = i;
  }
};
class r4 extends P {
  constructor(e, t) {
    super(), this._editor = e, this._computer = t, this._onResult = this._register(new R()), this.onResult = this._onResult.event, this._firstWaitScheduler = this._register(new xt(() => this._triggerAsyncComputation(), 0)), this._secondWaitScheduler = this._register(new xt(() => this._triggerSyncComputation(), 0)), this._loadingMessageScheduler = this._register(new xt(() => this._triggerLoadingMessage(), 0)), this._state = 0, this._asyncIterable = null, this._asyncIterableDone = !1, this._result = [];
  }
  dispose() {
    this._asyncIterable && (this._asyncIterable.cancel(), this._asyncIterable = null), super.dispose();
  }
  get _hoverTime() {
    return this._editor.getOption(
      60
      /* EditorOption.hover */
    ).delay;
  }
  get _firstWaitTime() {
    return this._hoverTime / 2;
  }
  get _secondWaitTime() {
    return this._hoverTime - this._firstWaitTime;
  }
  get _loadingMessageTime() {
    return 3 * this._hoverTime;
  }
  _setState(e, t = !0) {
    this._state = e, t && this._fireResult();
  }
  _triggerAsyncComputation() {
    this._setState(
      2
      /* HoverOperationState.SecondWait */
    ), this._secondWaitScheduler.schedule(this._secondWaitTime), this._computer.computeAsync ? (this._asyncIterableDone = !1, this._asyncIterable = h8((e) => this._computer.computeAsync(e)), (async () => {
      try {
        for await (const e of this._asyncIterable)
          e && (this._result.push(e), this._fireResult());
        this._asyncIterableDone = !0, (this._state === 3 || this._state === 4) && this._setState(
          0
          /* HoverOperationState.Idle */
        );
      } catch (e) {
        He(e);
      }
    })()) : this._asyncIterableDone = !0;
  }
  _triggerSyncComputation() {
    this._computer.computeSync && (this._result = this._result.concat(this._computer.computeSync())), this._setState(
      this._asyncIterableDone ? 0 : 3
      /* HoverOperationState.WaitingForAsync */
    );
  }
  _triggerLoadingMessage() {
    this._state === 3 && this._setState(
      4
      /* HoverOperationState.WaitingForAsyncShowingLoading */
    );
  }
  _fireResult() {
    if (this._state === 1 || this._state === 2)
      return;
    const e = this._state === 0, t = this._state === 4;
    this._onResult.fire(new Fhe(this._result.slice(0), e, t));
  }
  start(e) {
    if (e === 0)
      this._state === 0 && (this._setState(
        1
        /* HoverOperationState.FirstWait */
      ), this._firstWaitScheduler.schedule(this._firstWaitTime), this._loadingMessageScheduler.schedule(this._loadingMessageTime));
    else
      switch (this._state) {
        case 0:
          this._triggerAsyncComputation(), this._secondWaitScheduler.cancel(), this._triggerSyncComputation();
          break;
        case 2:
          this._secondWaitScheduler.cancel(), this._triggerSyncComputation();
          break;
      }
  }
  cancel() {
    this._firstWaitScheduler.cancel(), this._secondWaitScheduler.cancel(), this._loadingMessageScheduler.cancel(), this._asyncIterable && (this._asyncIterable.cancel(), this._asyncIterable = null), this._result = [], this._setState(0, !1);
  }
}
class Gk {
  constructor(e, t, i, n) {
    this.priority = e, this.range = t, this.initialMousePosX = i, this.initialMousePosY = n, this.type = 1;
  }
  equals(e) {
    return e.type === 1 && this.range.equalsRange(e.range);
  }
  canAdoptVisibleHover(e, t) {
    return e.type === 1 && t.lineNumber === this.range.startLineNumber;
  }
}
class gu {
  constructor(e, t, i, n, s, o) {
    this.priority = e, this.owner = t, this.range = i, this.initialMousePosX = n, this.initialMousePosY = s, this.supportsMarkerHover = o, this.type = 2;
  }
  equals(e) {
    return e.type === 2 && this.owner === e.owner;
  }
  canAdoptVisibleHover(e, t) {
    return e.type === 2 && this.owner === e.owner;
  }
}
const ah = new class {
  constructor() {
    this._participants = [];
  }
  register(e) {
    this._participants.push(e);
  }
  getAll() {
    return this._participants;
  }
}();
class Whe {
  constructor(e, t, i) {
    this.provider = e, this.hover = t, this.ordinal = i;
  }
}
async function Bhe(r, e, t, i, n) {
  const s = await Promise.resolve(r.provideHover(t, i, n)).catch(_i);
  if (!(!s || !Vhe(s)))
    return new Whe(r, s, e);
}
function pR(r, e, t, i) {
  const s = r.ordered(e).map((o, a) => Bhe(o, a, e, t, i));
  return Ni.fromPromises(s).coalesce();
}
function Hhe(r, e, t, i) {
  return pR(r, e, t, i).map((n) => n.hover).toPromise();
}
ul("_executeHoverProvider", (r, e, t) => {
  const i = r.get(he);
  return Hhe(i.hoverProvider, e, t, at.None);
});
function Vhe(r) {
  const e = typeof r.range < "u", t = typeof r.contents < "u" && r.contents && r.contents.length > 0;
  return e && t;
}
var zhe = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, wg = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
const rf = X, Uhe = hi("hover-increase-verbosity", me.add, p("increaseHoverVerbosity", "Icon for increaseing hover verbosity.")), $he = hi("hover-decrease-verbosity", me.remove, p("decreaseHoverVerbosity", "Icon for decreasing hover verbosity."));
class Wr {
  constructor(e, t, i, n, s, o = void 0) {
    this.owner = e, this.range = t, this.contents = i, this.isBeforeContent = n, this.ordinal = s, this.source = o;
  }
  isValidForHoverAnchor(e) {
    return e.type === 1 && this.range.startColumn <= e.range.startColumn && this.range.endColumn >= e.range.endColumn;
  }
}
class a4 {
  constructor(e, t, i) {
    this.hover = e, this.hoverProvider = t, this.hoverPosition = i;
  }
  supportsVerbosityAction(e) {
    var t, i;
    switch (e) {
      case nr.Increase:
        return (t = this.hover.canIncreaseVerbosity) !== null && t !== void 0 ? t : !1;
      case nr.Decrease:
        return (i = this.hover.canDecreaseVerbosity) !== null && i !== void 0 ? i : !1;
    }
  }
}
let Mv = class {
  constructor(e, t, i, n, s, o, a) {
    this._editor = e, this._languageService = t, this._openerService = i, this._configurationService = n, this._languageFeaturesService = s, this._keybindingService = o, this._hoverService = a, this.hoverOrdinal = 3;
  }
  createLoadingMessage(e) {
    return new Wr(this, e.range, [new Nn().appendText(p("modesContentHover.loading", "Loading..."))], !1, 2e3);
  }
  computeSync(e, t) {
    if (!this._editor.hasModel() || e.type !== 1)
      return [];
    const i = this._editor.getModel(), n = e.range.startLineNumber, s = i.getLineMaxColumn(n), o = [];
    let a = 1e3;
    const l = i.getLineLength(n), d = i.getLanguageIdAtPosition(e.range.startLineNumber, e.range.startColumn), c = this._editor.getOption(
      117
      /* EditorOption.stopRenderingLineAfter */
    ), h = this._configurationService.getValue("editor.maxTokenizationLineLength", {
      overrideIdentifier: d
    });
    let u = !1;
    c >= 0 && l > c && e.range.startColumn >= c && (u = !0, o.push(new Wr(this, e.range, [{
      value: p("stopped rendering", "Rendering paused for long line for performance reasons. This can be configured via `editor.stopRenderingLineAfter`.")
    }], !1, a++))), !u && typeof h == "number" && l >= h && o.push(new Wr(this, e.range, [{
      value: p("too many characters", "Tokenization is skipped for long lines for performance reasons. This can be configured via `editor.maxTokenizationLineLength`.")
    }], !1, a++));
    let g = !1;
    for (const f of t) {
      const m = f.range.startLineNumber === n ? f.range.startColumn : 1, _ = f.range.endLineNumber === n ? f.range.endColumn : s, v = f.options.hoverMessage;
      if (!v || Jf(v))
        continue;
      f.options.beforeContentClassName && (g = !0);
      const b = new L(e.range.startLineNumber, m, e.range.startLineNumber, _);
      o.push(new Wr(this, b, YN(v), g, a++));
    }
    return o;
  }
  computeAsync(e, t, i) {
    if (!this._editor.hasModel() || e.type !== 1)
      return Ni.EMPTY;
    const n = this._editor.getModel(), s = this._languageFeaturesService.hoverProvider;
    return s.has(n) ? this._getMarkdownHovers(s, n, e, i) : Ni.EMPTY;
  }
  _getMarkdownHovers(e, t, i, n) {
    const s = i.range.getStartPosition();
    return pR(e, t, s, n).filter((l) => !Jf(l.hover.contents)).map((l) => {
      const d = l.hover.range ? L.lift(l.hover.range) : i.range, c = new a4(l.hover, l.provider, s);
      return new Wr(this, d, l.hover.contents, !1, l.ordinal, c);
    });
  }
  renderHoverParts(e, t) {
    return this._renderedHoverParts = new Khe(t, e.fragment, this._editor, this._languageService, this._openerService, this._keybindingService, this._hoverService, this._configurationService, e.onContentsChanged), this._renderedHoverParts;
  }
  markdownHoverContentAtIndex(e) {
    var t, i;
    return (i = (t = this._renderedHoverParts) === null || t === void 0 ? void 0 : t.markdownHoverContentAtIndex(e)) !== null && i !== void 0 ? i : "";
  }
  doesMarkdownHoverAtIndexSupportVerbosityAction(e, t) {
    var i, n;
    return (n = (i = this._renderedHoverParts) === null || i === void 0 ? void 0 : i.doesMarkdownHoverAtIndexSupportVerbosityAction(e, t)) !== null && n !== void 0 ? n : !1;
  }
  updateMarkdownHoverVerbosityLevel(e, t, i) {
    var n;
    (n = this._renderedHoverParts) === null || n === void 0 || n.updateMarkdownHoverPartVerbosityLevel(e, t, i);
  }
};
Mv = zhe([
  wg(1, Jt),
  wg(2, Ys),
  wg(3, Ge),
  wg(4, he),
  wg(5, _t),
  wg(6, gl)
], Mv);
class Khe extends P {
  constructor(e, t, i, n, s, o, a, l, d) {
    super(), this._editor = i, this._languageService = n, this._openerService = s, this._keybindingService = o, this._hoverService = a, this._configurationService = l, this._onFinishedRendering = d, this._focusedHoverPartIndex = -1, this._ongoingHoverOperations = /* @__PURE__ */ new Map(), this._renderedHoverParts = this._renderHoverParts(e, t, this._onFinishedRendering), this._register(Se(() => {
      this._renderedHoverParts.forEach((c) => {
        c.disposables.dispose();
      });
    })), this._register(Se(() => {
      this._ongoingHoverOperations.forEach((c) => {
        c.tokenSource.dispose(!0);
      });
    }));
  }
  _renderHoverParts(e, t, i) {
    return e.sort(cr((n) => n.ordinal, Zu)), e.map((n, s) => {
      const o = this._renderHoverPart(s, n.contents, n.source, i);
      return t.appendChild(o.renderedMarkdown), o;
    });
  }
  _renderHoverPart(e, t, i, n) {
    const { renderedMarkdown: s, disposables: o } = this._renderMarkdownContent(t, n);
    if (!i)
      return { renderedMarkdown: s, disposables: o };
    const a = i.supportsVerbosityAction(nr.Increase), l = i.supportsVerbosityAction(nr.Decrease);
    if (!a && !l)
      return { renderedMarkdown: s, disposables: o, hoverSource: i };
    const d = rf("div.verbosity-actions");
    return s.prepend(d), o.add(this._renderHoverExpansionAction(d, nr.Increase, a)), o.add(this._renderHoverExpansionAction(d, nr.Decrease, l)), this._register(W(s, Q.FOCUS_IN, (c) => {
      c.stopPropagation(), this._focusedHoverPartIndex = e;
    })), this._register(W(s, Q.FOCUS_OUT, (c) => {
      c.stopPropagation(), this._focusedHoverPartIndex = -1;
    })), { renderedMarkdown: s, disposables: o, hoverSource: i };
  }
  _renderMarkdownContent(e, t) {
    const i = rf("div.hover-row");
    i.tabIndex = 0;
    const n = rf("div.hover-row-contents");
    i.appendChild(n);
    const s = new q();
    return s.add(l4(this._editor, n, e, this._languageService, this._openerService, t)), { renderedMarkdown: i, disposables: s };
  }
  _renderHoverExpansionAction(e, t, i) {
    const n = new q(), s = t === nr.Increase, o = G(e, rf(Le.asCSSSelector(s ? Uhe : $he)));
    o.tabIndex = 0;
    const a = new Xf("mouse", !1, { target: e, position: {
      hoverPosition: 0
      /* HoverPosition.LEFT */
    } }, this._configurationService, this._hoverService);
    if (n.add(this._hoverService.setupUpdatableHover(a, o, qhe(this._keybindingService, t))), !i)
      return o.classList.add("disabled"), n;
    o.classList.add("enabled");
    const l = () => this.updateMarkdownHoverPartVerbosityLevel(t);
    return n.add(new Q2(o, l)), n.add(new X2(o, l, [
      3,
      10
      /* KeyCode.Space */
    ])), n;
  }
  async updateMarkdownHoverPartVerbosityLevel(e, t = -1, i = !0) {
    var n;
    const s = this._editor.getModel();
    if (!s)
      return;
    const o = t !== -1 ? t : this._focusedHoverPartIndex, a = this._getRenderedHoverPartAtIndex(o);
    if (!a || !(!((n = a.hoverSource) === null || n === void 0) && n.supportsVerbosityAction(e)))
      return;
    const l = a.hoverSource, d = await this._fetchHover(l, s, e);
    if (!d)
      return;
    const c = new a4(d, l.hoverProvider, l.hoverPosition), h = this._renderHoverPart(o, d.contents, c, this._onFinishedRendering);
    this._replaceRenderedHoverPartAtIndex(o, h), i && this._focusOnHoverPartWithIndex(o), this._onFinishedRendering();
  }
  markdownHoverContentAtIndex(e) {
    var t;
    const i = this._getRenderedHoverPartAtIndex(e);
    return (t = i == null ? void 0 : i.renderedMarkdown.innerText) !== null && t !== void 0 ? t : "";
  }
  doesMarkdownHoverAtIndexSupportVerbosityAction(e, t) {
    var i;
    const n = this._getRenderedHoverPartAtIndex(e);
    return !(!n || !(!((i = n.hoverSource) === null || i === void 0) && i.supportsVerbosityAction(t)));
  }
  async _fetchHover(e, t, i) {
    let n = i === nr.Increase ? 1 : -1;
    const s = e.hoverProvider, o = this._ongoingHoverOperations.get(s);
    o && (o.tokenSource.cancel(), n += o.verbosityDelta);
    const a = new mi();
    this._ongoingHoverOperations.set(s, { verbosityDelta: n, tokenSource: a });
    const l = { verbosityRequest: { verbosityDelta: n, previousHover: e.hover } };
    let d;
    try {
      d = await Promise.resolve(s.provideHover(t, e.hoverPosition, a.token, l));
    } catch (c) {
      _i(c);
    }
    return a.dispose(), this._ongoingHoverOperations.delete(s), d;
  }
  _replaceRenderedHoverPartAtIndex(e, t) {
    if (e >= this._renderHoverParts.length || e < 0)
      return;
    const i = this._renderedHoverParts[e];
    i.renderedMarkdown.replaceWith(t.renderedMarkdown), i.disposables.dispose(), this._renderedHoverParts[e] = t;
  }
  _focusOnHoverPartWithIndex(e) {
    this._renderedHoverParts[e].renderedMarkdown.focus();
  }
  _getRenderedHoverPartAtIndex(e) {
    return this._renderedHoverParts[e];
  }
}
function jhe(r, e, t, i, n) {
  e.sort(cr((o) => o.ordinal, Zu));
  const s = new q();
  for (const o of e)
    s.add(l4(t, r.fragment, o.contents, i, n, r.onContentsChanged));
  return s;
}
function l4(r, e, t, i, n, s) {
  const o = new q();
  for (const a of t) {
    if (Jf(a))
      continue;
    const l = rf("div.markdown-hover"), d = G(l, rf("div.hover-contents")), c = o.add(new nl({ editor: r }, i, n));
    o.add(c.onDidRenderAsync(() => {
      d.className = "hover-contents code-hover-contents", s();
    }));
    const h = o.add(c.render(a));
    d.appendChild(h.element), e.appendChild(l);
  }
  return o;
}
function qhe(r, e) {
  switch (e) {
    case nr.Increase: {
      const t = r.lookupKeybinding(DL);
      return t ? p("increaseVerbosityWithKb", "Increase Hover Verbosity ({0})", t.getLabel()) : p("increaseVerbosity", "Increase Hover Verbosity");
    }
    case nr.Decrease: {
      const t = r.lookupKeybinding(kL);
      return t ? p("decreaseVerbosityWithKb", "Decrease Hover Verbosity ({0})", t.getLabel()) : p("decreaseVerbosity", "Decrease Hover Verbosity");
    }
  }
}
function pT(r, e) {
  return !!r[e];
}
class Zk {
  constructor(e, t) {
    this.target = e.target, this.isLeftClick = e.event.leftButton, this.isMiddleClick = e.event.middleButton, this.isRightClick = e.event.rightButton, this.hasTriggerModifier = pT(e.event, t.triggerModifier), this.hasSideBySideModifier = pT(e.event, t.triggerSideBySideModifier), this.isNoneOrSingleMouseDown = e.event.detail <= 1;
  }
}
class LW {
  constructor(e, t) {
    this.keyCodeIsTriggerKey = e.keyCode === t.triggerKey, this.keyCodeIsSideBySideKey = e.keyCode === t.triggerSideBySideKey, this.hasTriggerModifier = pT(e, t.triggerModifier);
  }
}
class GC {
  constructor(e, t, i, n) {
    this.triggerKey = e, this.triggerModifier = t, this.triggerSideBySideKey = i, this.triggerSideBySideModifier = n;
  }
  equals(e) {
    return this.triggerKey === e.triggerKey && this.triggerModifier === e.triggerModifier && this.triggerSideBySideKey === e.triggerSideBySideKey && this.triggerSideBySideModifier === e.triggerSideBySideModifier;
  }
}
function DW(r) {
  return r === "altKey" ? Je ? new GC(57, "metaKey", 6, "altKey") : new GC(5, "ctrlKey", 6, "altKey") : Je ? new GC(6, "altKey", 57, "metaKey") : new GC(6, "altKey", 5, "ctrlKey");
}
class xL extends P {
  constructor(e, t) {
    var i;
    super(), this._onMouseMoveOrRelevantKeyDown = this._register(new R()), this.onMouseMoveOrRelevantKeyDown = this._onMouseMoveOrRelevantKeyDown.event, this._onExecute = this._register(new R()), this.onExecute = this._onExecute.event, this._onCancel = this._register(new R()), this.onCancel = this._onCancel.event, this._editor = e, this._extractLineNumberFromMouseEvent = (i = t == null ? void 0 : t.extractLineNumberFromMouseEvent) !== null && i !== void 0 ? i : (n) => n.target.position ? n.target.position.lineNumber : 0, this._opts = DW(this._editor.getOption(
      78
      /* EditorOption.multiCursorModifier */
    )), this._lastMouseMoveEvent = null, this._hasTriggerKeyOnMouseDown = !1, this._lineNumberOnMouseDown = 0, this._register(this._editor.onDidChangeConfiguration((n) => {
      if (n.hasChanged(
        78
        /* EditorOption.multiCursorModifier */
      )) {
        const s = DW(this._editor.getOption(
          78
          /* EditorOption.multiCursorModifier */
        ));
        if (this._opts.equals(s))
          return;
        this._opts = s, this._lastMouseMoveEvent = null, this._hasTriggerKeyOnMouseDown = !1, this._lineNumberOnMouseDown = 0, this._onCancel.fire();
      }
    })), this._register(this._editor.onMouseMove((n) => this._onEditorMouseMove(new Zk(n, this._opts)))), this._register(this._editor.onMouseDown((n) => this._onEditorMouseDown(new Zk(n, this._opts)))), this._register(this._editor.onMouseUp((n) => this._onEditorMouseUp(new Zk(n, this._opts)))), this._register(this._editor.onKeyDown((n) => this._onEditorKeyDown(new LW(n, this._opts)))), this._register(this._editor.onKeyUp((n) => this._onEditorKeyUp(new LW(n, this._opts)))), this._register(this._editor.onMouseDrag(() => this._resetHandler())), this._register(this._editor.onDidChangeCursorSelection((n) => this._onDidChangeCursorSelection(n))), this._register(this._editor.onDidChangeModel((n) => this._resetHandler())), this._register(this._editor.onDidChangeModelContent(() => this._resetHandler())), this._register(this._editor.onDidScrollChange((n) => {
      (n.scrollTopChanged || n.scrollLeftChanged) && this._resetHandler();
    }));
  }
  _onDidChangeCursorSelection(e) {
    e.selection && e.selection.startColumn !== e.selection.endColumn && this._resetHandler();
  }
  _onEditorMouseMove(e) {
    this._lastMouseMoveEvent = e, this._onMouseMoveOrRelevantKeyDown.fire([e, null]);
  }
  _onEditorMouseDown(e) {
    this._hasTriggerKeyOnMouseDown = e.hasTriggerModifier, this._lineNumberOnMouseDown = this._extractLineNumberFromMouseEvent(e);
  }
  _onEditorMouseUp(e) {
    const t = this._extractLineNumberFromMouseEvent(e);
    this._hasTriggerKeyOnMouseDown && this._lineNumberOnMouseDown && this._lineNumberOnMouseDown === t && this._onExecute.fire(e);
  }
  _onEditorKeyDown(e) {
    this._lastMouseMoveEvent && (e.keyCodeIsTriggerKey || e.keyCodeIsSideBySideKey && e.hasTriggerModifier) ? this._onMouseMoveOrRelevantKeyDown.fire([this._lastMouseMoveEvent, e]) : e.hasTriggerModifier && this._onCancel.fire();
  }
  _onEditorKeyUp(e) {
    e.keyCodeIsTriggerKey && this._onCancel.fire();
  }
  _resetHandler() {
    this._lastMouseMoveEvent = null, this._hasTriggerKeyOnMouseDown = !1, this._onCancel.fire();
  }
}
class d4 {
  constructor(e, t) {
    this.range = e, this.direction = t;
  }
}
class mR {
  constructor(e, t, i) {
    this.hint = e, this.anchor = t, this.provider = i, this._isResolved = !1;
  }
  with(e) {
    const t = new mR(this.hint, e.anchor, this.provider);
    return t._isResolved = this._isResolved, t._currentResolve = this._currentResolve, t;
  }
  async resolve(e) {
    if (typeof this.provider.resolveInlayHint == "function") {
      if (this._currentResolve)
        return await this._currentResolve, e.isCancellationRequested ? void 0 : this.resolve(e);
      this._isResolved || (this._currentResolve = this._doResolve(e).finally(() => this._currentResolve = void 0)), await this._currentResolve;
    }
  }
  async _doResolve(e) {
    var t, i, n;
    try {
      const s = await Promise.resolve(this.provider.resolveInlayHint(this.hint, e));
      this.hint.tooltip = (t = s == null ? void 0 : s.tooltip) !== null && t !== void 0 ? t : this.hint.tooltip, this.hint.label = (i = s == null ? void 0 : s.label) !== null && i !== void 0 ? i : this.hint.label, this.hint.textEdits = (n = s == null ? void 0 : s.textEdits) !== null && n !== void 0 ? n : this.hint.textEdits, this._isResolved = !0;
    } catch (s) {
      _i(s), this._isResolved = !1;
    }
  }
}
class fu {
  static async create(e, t, i, n) {
    const s = [], o = e.ordered(t).reverse().map((a) => i.map(async (l) => {
      try {
        const d = await a.provideInlayHints(t, l, n);
        (d != null && d.hints.length || a.onDidChangeInlayHints) && s.push([d ?? fu._emptyInlayHintList, a]);
      } catch (d) {
        _i(d);
      }
    }));
    if (await Promise.all(o.flat()), n.isCancellationRequested || t.isDisposed())
      throw new Ja();
    return new fu(i, s, t);
  }
  constructor(e, t, i) {
    this._disposables = new q(), this.ranges = e, this.provider = /* @__PURE__ */ new Set();
    const n = [];
    for (const [s, o] of t) {
      this._disposables.add(s), this.provider.add(o);
      for (const a of s.hints) {
        const l = i.validatePosition(a.position);
        let d = "before";
        const c = fu._getRangeAtPosition(i, l);
        let h;
        c.getStartPosition().isBefore(l) ? (h = L.fromPositions(c.getStartPosition(), l), d = "after") : (h = L.fromPositions(l, c.getEndPosition()), d = "before"), n.push(new mR(a, new d4(h, d), o));
      }
    }
    this.items = n.sort((s, o) => A.compare(s.hint.position, o.hint.position));
  }
  dispose() {
    this._disposables.dispose();
  }
  static _getRangeAtPosition(e, t) {
    const i = t.lineNumber, n = e.getWordAtPosition(t);
    if (n)
      return new L(i, n.startColumn, i, n.endColumn);
    e.tokenization.tokenizeIfCheap(i);
    const s = e.tokenization.getLineTokens(i), o = t.column - 1, a = s.findTokenIndexAtOffset(o);
    let l = s.getStartOffset(a), d = s.getEndOffset(a);
    return d - l === 1 && (l === o && a > 1 ? (l = s.getStartOffset(a - 1), d = s.getEndOffset(a - 1)) : d === o && a < s.getCount() - 1 && (l = s.getStartOffset(a + 1), d = s.getEndOffset(a + 1))), new L(i, l + 1, i, d + 1);
  }
}
fu._emptyInlayHintList = Object.freeze({ dispose() {
}, hints: [] });
function Ghe(r) {
  return Ee.from({
    scheme: Ne.command,
    path: r.id,
    query: r.arguments && encodeURIComponent(JSON.stringify(r.arguments))
  }).toString();
}
var Zhe = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, wl = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
let jc = class extends Qf {
  constructor(e, t, i, n, s, o, a, l, d, c, h, u, g) {
    super(e, { ...n.getRawOptions(), overflowWidgetsDomNode: n.getOverflowWidgetsDomNode() }, i, s, o, a, l, d, c, h, u, g), this._parentEditor = n, this._overwriteOptions = t, super.updateOptions(this._overwriteOptions), this._register(n.onDidChangeConfiguration((f) => this._onParentConfigurationChanged(f)));
  }
  getParentEditor() {
    return this._parentEditor;
  }
  _onParentConfigurationChanged(e) {
    super.updateOptions(this._parentEditor.getRawOptions()), super.updateOptions(this._overwriteOptions);
  }
  updateOptions(e) {
    QN(this._overwriteOptions, e, !0), super.updateOptions(this._overwriteOptions);
  }
};
jc = Zhe([
  wl(4, be),
  wl(5, ht),
  wl(6, $t),
  wl(7, De),
  wl(8, $i),
  wl(9, xi),
  wl(10, qs),
  wl(11, Ot),
  wl(12, he)
], jc);
const kW = new z(new Qt(0, 122, 204)), Yhe = {
  showArrow: !0,
  showFrame: !0,
  className: "",
  frameColor: kW,
  arrowColor: kW,
  keepEditorSelection: !1
}, Qhe = "vs.editor.contrib.zoneWidget";
class Xhe {
  constructor(e, t, i, n, s, o, a, l) {
    this.id = "", this.domNode = e, this.afterLineNumber = t, this.afterColumn = i, this.heightInLines = n, this.showInHiddenAreas = a, this.ordinal = l, this._onDomNodeTop = s, this._onComputedHeight = o;
  }
  onDomNodeTop(e) {
    this._onDomNodeTop(e);
  }
  onComputedHeight(e) {
    this._onComputedHeight(e);
  }
}
class Jhe {
  constructor(e, t) {
    this._id = e, this._domNode = t;
  }
  getId() {
    return this._id;
  }
  getDomNode() {
    return this._domNode;
  }
  getPosition() {
    return null;
  }
}
class IL {
  constructor(e) {
    this._editor = e, this._ruleName = IL._IdGenerator.nextId(), this._decorations = this._editor.createDecorationsCollection(), this._color = null, this._height = -1;
  }
  dispose() {
    this.hide(), Ex(this._ruleName);
  }
  set color(e) {
    this._color !== e && (this._color = e, this._updateStyle());
  }
  set height(e) {
    this._height !== e && (this._height = e, this._updateStyle());
  }
  _updateStyle() {
    Ex(this._ruleName), gS(`.monaco-editor ${this._ruleName}`, `border-style: solid; border-color: transparent; border-bottom-color: ${this._color}; border-width: ${this._height}px; bottom: -${this._height}px !important; margin-left: -${this._height}px; `);
  }
  show(e) {
    e.column === 1 && (e = { lineNumber: e.lineNumber, column: 2 }), this._decorations.set([{
      range: L.fromPositions(e),
      options: {
        description: "zone-widget-arrow",
        className: this._ruleName,
        stickiness: 1
        /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */
      }
    }]);
  }
  hide() {
    this._decorations.clear();
  }
}
IL._IdGenerator = new hM(".arrow-decoration-");
class eue {
  constructor(e, t = {}) {
    this._arrow = null, this._overlayWidget = null, this._resizeSash = null, this._viewZone = null, this._disposables = new q(), this.container = null, this._isShowing = !1, this.editor = e, this._positionMarkerId = this.editor.createDecorationsCollection(), this.options = Hd(t), QN(this.options, Yhe, !1), this.domNode = document.createElement("div"), this.options.isAccessible || (this.domNode.setAttribute("aria-hidden", "true"), this.domNode.setAttribute("role", "presentation")), this._disposables.add(this.editor.onDidLayoutChange((i) => {
      const n = this._getWidth(i);
      this.domNode.style.width = n + "px", this.domNode.style.left = this._getLeft(i) + "px", this._onWidth(n);
    }));
  }
  dispose() {
    this._overlayWidget && (this.editor.removeOverlayWidget(this._overlayWidget), this._overlayWidget = null), this._viewZone && this.editor.changeViewZones((e) => {
      this._viewZone && e.removeZone(this._viewZone.id), this._viewZone = null;
    }), this._positionMarkerId.clear(), this._disposables.dispose();
  }
  create() {
    this.domNode.classList.add("zone-widget"), this.options.className && this.domNode.classList.add(this.options.className), this.container = document.createElement("div"), this.container.classList.add("zone-widget-container"), this.domNode.appendChild(this.container), this.options.showArrow && (this._arrow = new IL(this.editor), this._disposables.add(this._arrow)), this._fillContainer(this.container), this._initSash(), this._applyStyles();
  }
  style(e) {
    e.frameColor && (this.options.frameColor = e.frameColor), e.arrowColor && (this.options.arrowColor = e.arrowColor), this._applyStyles();
  }
  _applyStyles() {
    if (this.container && this.options.frameColor) {
      const e = this.options.frameColor.toString();
      this.container.style.borderTopColor = e, this.container.style.borderBottomColor = e;
    }
    if (this._arrow && this.options.arrowColor) {
      const e = this.options.arrowColor.toString();
      this._arrow.color = e;
    }
  }
  _getWidth(e) {
    return e.width - e.minimap.minimapWidth - e.verticalScrollbarWidth;
  }
  _getLeft(e) {
    return e.minimap.minimapWidth > 0 && e.minimap.minimapLeft === 0 ? e.minimap.minimapWidth : 0;
  }
  _onViewZoneTop(e) {
    this.domNode.style.top = e + "px";
  }
  _onViewZoneHeight(e) {
    var t;
    if (this.domNode.style.height = `${e}px`, this.container) {
      const i = e - this._decoratingElementsHeight();
      this.container.style.height = `${i}px`;
      const n = this.editor.getLayoutInfo();
      this._doLayout(i, this._getWidth(n));
    }
    (t = this._resizeSash) === null || t === void 0 || t.layout();
  }
  get position() {
    const e = this._positionMarkerId.getRange(0);
    if (e)
      return e.getStartPosition();
  }
  show(e, t) {
    const i = L.isIRange(e) ? L.lift(e) : L.fromPositions(e);
    this._isShowing = !0, this._showImpl(i, t), this._isShowing = !1, this._positionMarkerId.set([{ range: i, options: Fe.EMPTY }]);
  }
  hide() {
    var e;
    this._viewZone && (this.editor.changeViewZones((t) => {
      this._viewZone && t.removeZone(this._viewZone.id);
    }), this._viewZone = null), this._overlayWidget && (this.editor.removeOverlayWidget(this._overlayWidget), this._overlayWidget = null), (e = this._arrow) === null || e === void 0 || e.hide(), this._positionMarkerId.clear();
  }
  _decoratingElementsHeight() {
    const e = this.editor.getOption(
      67
      /* EditorOption.lineHeight */
    );
    let t = 0;
    if (this.options.showArrow) {
      const i = Math.round(e / 3);
      t += 2 * i;
    }
    if (this.options.showFrame) {
      const i = Math.round(e / 9);
      t += 2 * i;
    }
    return t;
  }
  _showImpl(e, t) {
    const i = e.getStartPosition(), n = this.editor.getLayoutInfo(), s = this._getWidth(n);
    this.domNode.style.width = `${s}px`, this.domNode.style.left = this._getLeft(n) + "px";
    const o = document.createElement("div");
    o.style.overflow = "hidden";
    const a = this.editor.getOption(
      67
      /* EditorOption.lineHeight */
    );
    if (!this.options.allowUnlimitedHeight) {
      const u = Math.max(12, this.editor.getLayoutInfo().height / a * 0.8);
      t = Math.min(t, u);
    }
    let l = 0, d = 0;
    if (this._arrow && this.options.showArrow && (l = Math.round(a / 3), this._arrow.height = l, this._arrow.show(i)), this.options.showFrame && (d = Math.round(a / 9)), this.editor.changeViewZones((u) => {
      this._viewZone && u.removeZone(this._viewZone.id), this._overlayWidget && (this.editor.removeOverlayWidget(this._overlayWidget), this._overlayWidget = null), this.domNode.style.top = "-1000px", this._viewZone = new Xhe(o, i.lineNumber, i.column, t, (g) => this._onViewZoneTop(g), (g) => this._onViewZoneHeight(g), this.options.showInHiddenAreas, this.options.ordinal), this._viewZone.id = u.addZone(this._viewZone), this._overlayWidget = new Jhe(Qhe + this._viewZone.id, this.domNode), this.editor.addOverlayWidget(this._overlayWidget);
    }), this.container && this.options.showFrame) {
      const u = this.options.frameWidth ? this.options.frameWidth : d;
      this.container.style.borderTopWidth = u + "px", this.container.style.borderBottomWidth = u + "px";
    }
    const c = t * a - this._decoratingElementsHeight();
    this.container && (this.container.style.top = l + "px", this.container.style.height = c + "px", this.container.style.overflow = "hidden"), this._doLayout(c, s), this.options.keepEditorSelection || this.editor.setSelection(e);
    const h = this.editor.getModel();
    if (h) {
      const u = h.validateRange(new L(e.startLineNumber, 1, e.endLineNumber + 1, 1));
      this.revealRange(u, u.startLineNumber === h.getLineCount());
    }
  }
  revealRange(e, t) {
    t ? this.editor.revealLineNearTop(
      e.endLineNumber,
      0
      /* ScrollType.Smooth */
    ) : this.editor.revealRange(
      e,
      0
      /* ScrollType.Smooth */
    );
  }
  setCssClass(e, t) {
    this.container && (t && this.container.classList.remove(t), this.container.classList.add(e));
  }
  _onWidth(e) {
  }
  _doLayout(e, t) {
  }
  _relayout(e) {
    this._viewZone && this._viewZone.heightInLines !== e && this.editor.changeViewZones((t) => {
      this._viewZone && (this._viewZone.heightInLines = e, t.layoutZone(this._viewZone.id));
    });
  }
  // --- sash
  _initSash() {
    if (this._resizeSash)
      return;
    this._resizeSash = this._disposables.add(new En(this.domNode, this, {
      orientation: 1
      /* Orientation.HORIZONTAL */
    })), this.options.isResizeable || (this._resizeSash.state = 0);
    let e;
    this._disposables.add(this._resizeSash.onDidStart((t) => {
      this._viewZone && (e = {
        startY: t.startY,
        heightInLines: this._viewZone.heightInLines
      });
    })), this._disposables.add(this._resizeSash.onDidEnd(() => {
      e = void 0;
    })), this._disposables.add(this._resizeSash.onDidChange((t) => {
      if (e) {
        const i = (t.currentY - e.startY) / this.editor.getOption(
          67
          /* EditorOption.lineHeight */
        ), n = i < 0 ? Math.ceil(i) : Math.floor(i), s = e.heightInLines + n;
        s > 5 && s < 35 && this._relayout(s);
      }
    }));
  }
  getHorizontalSashLeft() {
    return 0;
  }
  getHorizontalSashTop() {
    return (this.domNode.style.height === null ? 0 : parseInt(this.domNode.style.height)) - this._decoratingElementsHeight() / 2;
  }
  getHorizontalSashWidth() {
    const e = this.editor.getLayoutInfo();
    return e.width - e.minimap.minimapWidth;
  }
}
var c4 = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, h4 = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
const u4 = et("IPeekViewService");
ot(
  u4,
  class {
    constructor() {
      this._widgets = /* @__PURE__ */ new Map();
    }
    addExclusiveWidget(r, e) {
      const t = this._widgets.get(r);
      t && (t.listener.dispose(), t.widget.dispose());
      const i = () => {
        const n = this._widgets.get(r);
        n && n.widget === e && (n.listener.dispose(), this._widgets.delete(r));
      };
      this._widgets.set(r, { widget: e, listener: e.onDidClose(i) });
    }
  },
  1
  /* InstantiationType.Delayed */
);
var ks;
(function(r) {
  r.inPeekEditor = new oe("inReferenceSearchEditor", !0, p("inReferenceSearchEditor", "Whether the current code editor is embedded inside peek")), r.notInPeekEditor = r.inPeekEditor.toNegated();
})(ks || (ks = {}));
let Rv = class {
  constructor(e, t) {
    e instanceof jc && ks.inPeekEditor.bindTo(t);
  }
  dispose() {
  }
};
Rv.ID = "editor.contrib.referenceController";
Rv = c4([
  h4(1, De)
], Rv);
gt(
  Rv.ID,
  Rv,
  0
  /* EditorContributionInstantiation.Eager */
);
function tue(r) {
  const e = r.get(ht).getFocusedCodeEditor();
  return e instanceof jc ? e.getParentEditor() : e;
}
const iue = {
  headerBackgroundColor: z.white,
  primaryHeadingColor: z.fromHex("#333333"),
  secondaryHeadingColor: z.fromHex("#6c6c6cb3")
};
let Ay = class extends eue {
  constructor(e, t, i) {
    super(e, t), this.instantiationService = i, this._onDidClose = new R(), this.onDidClose = this._onDidClose.event, QN(this.options, iue, !1);
  }
  dispose() {
    this.disposed || (this.disposed = !0, super.dispose(), this._onDidClose.fire(this));
  }
  style(e) {
    const t = this.options;
    e.headerBackgroundColor && (t.headerBackgroundColor = e.headerBackgroundColor), e.primaryHeadingColor && (t.primaryHeadingColor = e.primaryHeadingColor), e.secondaryHeadingColor && (t.secondaryHeadingColor = e.secondaryHeadingColor), super.style(e);
  }
  _applyStyles() {
    super._applyStyles();
    const e = this.options;
    this._headElement && e.headerBackgroundColor && (this._headElement.style.backgroundColor = e.headerBackgroundColor.toString()), this._primaryHeading && e.primaryHeadingColor && (this._primaryHeading.style.color = e.primaryHeadingColor.toString()), this._secondaryHeading && e.secondaryHeadingColor && (this._secondaryHeading.style.color = e.secondaryHeadingColor.toString()), this._bodyElement && e.frameColor && (this._bodyElement.style.borderColor = e.frameColor.toString());
  }
  _fillContainer(e) {
    this.setCssClass("peekview-widget"), this._headElement = X(".head"), this._bodyElement = X(".body"), this._fillHead(this._headElement), this._fillBody(this._bodyElement), e.appendChild(this._headElement), e.appendChild(this._bodyElement);
  }
  _fillHead(e, t) {
    this._titleElement = X(".peekview-title"), this.options.supportOnTitleClick && (this._titleElement.classList.add("clickable"), pi(this._titleElement, "click", (s) => this._onTitleClick(s))), G(this._headElement, this._titleElement), this._fillTitleIcon(this._titleElement), this._primaryHeading = X("span.filename"), this._secondaryHeading = X("span.dirname"), this._metaHeading = X("span.meta"), G(this._titleElement, this._primaryHeading, this._secondaryHeading, this._metaHeading);
    const i = X(".peekview-actions");
    G(this._headElement, i);
    const n = this._getActionBarOptions();
    this._actionbarWidget = new Bo(i, n), this._disposables.add(this._actionbarWidget), t || this._actionbarWidget.push(new Bs("peekview.close", p("label.close", "Close"), Le.asClassName(me.close), !0, () => (this.dispose(), Promise.resolve())), { label: !1, icon: !0 });
  }
  _fillTitleIcon(e) {
  }
  _getActionBarOptions() {
    return {
      actionViewItemProvider: Rz.bind(void 0, this.instantiationService),
      orientation: 0
      /* ActionsOrientation.HORIZONTAL */
    };
  }
  _onTitleClick(e) {
  }
  setTitle(e, t) {
    this._primaryHeading && this._secondaryHeading && (this._primaryHeading.innerText = e, this._primaryHeading.setAttribute("title", e), t ? this._secondaryHeading.innerText = t : pn(this._secondaryHeading));
  }
  setMetaTitle(e) {
    this._metaHeading && (e ? (this._metaHeading.innerText = e, As(this._metaHeading)) : Xn(this._metaHeading));
  }
  _doLayout(e, t) {
    if (!this._isShowing && e < 0) {
      this.dispose();
      return;
    }
    const i = Math.ceil(this.editor.getOption(
      67
      /* EditorOption.lineHeight */
    ) * 1.2), n = Math.round(e - (i + 2));
    this._doLayoutHead(i, t), this._doLayoutBody(n, t);
  }
  _doLayoutHead(e, t) {
    this._headElement && (this._headElement.style.height = `${e}px`, this._headElement.style.lineHeight = this._headElement.style.height);
  }
  _doLayoutBody(e, t) {
    this._bodyElement && (this._bodyElement.style.height = `${e}px`);
  }
};
Ay = c4([
  h4(2, be)
], Ay);
const nue = I("peekViewTitle.background", { dark: "#252526", light: "#F3F3F3", hcDark: z.black, hcLight: z.white }, p("peekViewTitleBackground", "Background color of the peek view title area.")), g4 = I("peekViewTitleLabel.foreground", { dark: z.white, light: z.black, hcDark: z.white, hcLight: No }, p("peekViewTitleForeground", "Color of the peek view title.")), f4 = I("peekViewTitleDescription.foreground", { dark: "#ccccccb3", light: "#616161", hcDark: "#FFFFFF99", hcLight: "#292929" }, p("peekViewTitleInfoForeground", "Color of the peek view title info.")), sue = I("peekView.border", { dark: ws, light: ws, hcDark: it, hcLight: it }, p("peekViewBorder", "Color of the peek view borders and arrow.")), oue = I("peekViewResult.background", { dark: "#252526", light: "#F3F3F3", hcDark: z.black, hcLight: z.white }, p("peekViewResultsBackground", "Background color of the peek view result list."));
I("peekViewResult.lineForeground", { dark: "#bbbbbb", light: "#646465", hcDark: z.white, hcLight: No }, p("peekViewResultsMatchForeground", "Foreground color for line nodes in the peek view result list."));
I("peekViewResult.fileForeground", { dark: z.white, light: "#1E1E1E", hcDark: z.white, hcLight: No }, p("peekViewResultsFileForeground", "Foreground color for file nodes in the peek view result list."));
I("peekViewResult.selectionBackground", { dark: "#3399ff33", light: "#3399ff33", hcDark: null, hcLight: null }, p("peekViewResultsSelectionBackground", "Background color of the selected entry in the peek view result list."));
I("peekViewResult.selectionForeground", { dark: z.white, light: "#6C6C6C", hcDark: z.white, hcLight: No }, p("peekViewResultsSelectionForeground", "Foreground color of the selected entry in the peek view result list."));
const cc = I("peekViewEditor.background", { dark: "#001F33", light: "#F2F8FC", hcDark: z.black, hcLight: z.white }, p("peekViewEditorBackground", "Background color of the peek view editor."));
I("peekViewEditorGutter.background", { dark: cc, light: cc, hcDark: cc, hcLight: cc }, p("peekViewEditorGutterBackground", "Background color of the gutter in the peek view editor."));
I("peekViewEditorStickyScroll.background", { dark: cc, light: cc, hcDark: cc, hcLight: cc }, p("peekViewEditorStickScrollBackground", "Background color of sticky scroll in the peek view editor."));
I("peekViewResult.matchHighlightBackground", { dark: "#ea5c004d", light: "#ea5c004d", hcDark: null, hcLight: null }, p("peekViewResultsMatchHighlight", "Match highlight color in the peek view result list."));
I("peekViewEditor.matchHighlightBackground", { dark: "#ff8f0099", light: "#f5d802de", hcDark: null, hcLight: null }, p("peekViewEditorMatchHighlight", "Match highlight color in the peek view editor."));
I("peekViewEditor.matchHighlightBorder", { dark: null, light: null, hcDark: Gt, hcLight: Gt }, p("peekViewEditorMatchHighlightBorder", "Match highlight border in the peek view editor."));
class qc {
  constructor(e, t, i, n) {
    this.isProviderFirst = e, this.parent = t, this.link = i, this._rangeCallback = n, this.id = EI.nextId();
  }
  get uri() {
    return this.link.uri;
  }
  get range() {
    var e, t;
    return (t = (e = this._range) !== null && e !== void 0 ? e : this.link.targetSelectionRange) !== null && t !== void 0 ? t : this.link.range;
  }
  set range(e) {
    this._range = e, this._rangeCallback(this);
  }
  get ariaMessage() {
    var e;
    const t = (e = this.parent.getPreview(this)) === null || e === void 0 ? void 0 : e.preview(this.range);
    return t ? p({ key: "aria.oneReference.preview", comment: ["Placeholders are: 0: filename, 1:line number, 2: column number, 3: preview snippet of source code"] }, "{0} in {1} on line {2} at column {3}", t.value, Fo(this.uri), this.range.startLineNumber, this.range.startColumn) : p("aria.oneReference", "in {0} on line {1} at column {2}", Fo(this.uri), this.range.startLineNumber, this.range.startColumn);
  }
}
class rue {
  constructor(e) {
    this._modelReference = e;
  }
  dispose() {
    this._modelReference.dispose();
  }
  preview(e, t = 8) {
    const i = this._modelReference.object.textEditorModel;
    if (!i)
      return;
    const { startLineNumber: n, startColumn: s, endLineNumber: o, endColumn: a } = e, l = i.getWordUntilPosition({ lineNumber: n, column: s - t }), d = new L(n, l.startColumn, n, s), c = new L(
      o,
      a,
      o,
      1073741824
      /* Constants.MAX_SAFE_SMALL_INTEGER */
    ), h = i.getValueInRange(d).replace(/^\s+/, ""), u = i.getValueInRange(e), g = i.getValueInRange(c).replace(/\s+$/, "");
    return {
      value: h + u + g,
      highlight: { start: h.length, end: h.length + u.length }
    };
  }
}
class Av {
  constructor(e, t) {
    this.parent = e, this.uri = t, this.children = [], this._previews = new an();
  }
  dispose() {
    zt(this._previews.values()), this._previews.clear();
  }
  getPreview(e) {
    return this._previews.get(e.uri);
  }
  get ariaMessage() {
    const e = this.children.length;
    return e === 1 ? p("aria.fileReferences.1", "1 symbol in {0}, full path {1}", Fo(this.uri), this.uri.fsPath) : p("aria.fileReferences.N", "{0} symbols in {1}, full path {2}", e, Fo(this.uri), this.uri.fsPath);
  }
  async resolve(e) {
    if (this._previews.size !== 0)
      return this;
    for (const t of this.children)
      if (!this._previews.has(t.uri))
        try {
          const i = await e.createModelReference(t.uri);
          this._previews.set(t.uri, new rue(i));
        } catch (i) {
          He(i);
        }
    return this;
  }
}
class Vs {
  constructor(e, t) {
    this.groups = [], this.references = [], this._onDidChangeReferenceRange = new R(), this.onDidChangeReferenceRange = this._onDidChangeReferenceRange.event, this._links = e, this._title = t;
    const [i] = e;
    e.sort(Vs._compareReferences);
    let n;
    for (const s of e)
      if ((!n || !Zt.isEqual(n.uri, s.uri, !0)) && (n = new Av(this, s.uri), this.groups.push(n)), n.children.length === 0 || Vs._compareReferences(s, n.children[n.children.length - 1]) !== 0) {
        const o = new qc(i === s, n, s, (a) => this._onDidChangeReferenceRange.fire(a));
        this.references.push(o), n.children.push(o);
      }
  }
  dispose() {
    zt(this.groups), this._onDidChangeReferenceRange.dispose(), this.groups.length = 0;
  }
  clone() {
    return new Vs(this._links, this._title);
  }
  get title() {
    return this._title;
  }
  get isEmpty() {
    return this.groups.length === 0;
  }
  get ariaMessage() {
    return this.isEmpty ? p("aria.result.0", "No results found") : this.references.length === 1 ? p("aria.result.1", "Found 1 symbol in {0}", this.references[0].uri.fsPath) : this.groups.length === 1 ? p("aria.result.n1", "Found {0} symbols in {1}", this.references.length, this.groups[0].uri.fsPath) : p("aria.result.nm", "Found {0} symbols in {1} files", this.references.length, this.groups.length);
  }
  nextOrPreviousReference(e, t) {
    const { parent: i } = e;
    let n = i.children.indexOf(e);
    const s = i.children.length, o = i.parent.groups.length;
    return o === 1 || t && n + 1 < s || !t && n > 0 ? (t ? n = (n + 1) % s : n = (n + s - 1) % s, i.children[n]) : (n = i.parent.groups.indexOf(i), t ? (n = (n + 1) % o, i.parent.groups[n].children[0]) : (n = (n + o - 1) % o, i.parent.groups[n].children[i.parent.groups[n].children.length - 1]));
  }
  nearestReference(e, t) {
    const i = this.references.map((n, s) => ({
      idx: s,
      prefixLen: xc(n.uri.toString(), e.toString()),
      offsetDist: Math.abs(n.range.startLineNumber - t.lineNumber) * 100 + Math.abs(n.range.startColumn - t.column)
    })).sort((n, s) => n.prefixLen > s.prefixLen ? -1 : n.prefixLen < s.prefixLen ? 1 : n.offsetDist < s.offsetDist ? -1 : n.offsetDist > s.offsetDist ? 1 : 0)[0];
    if (i)
      return this.references[i.idx];
  }
  referenceAt(e, t) {
    for (const i of this.references)
      if (i.uri.toString() === e.toString() && L.containsPosition(i.range, t))
        return i;
  }
  firstReference() {
    for (const e of this.references)
      if (e.isProviderFirst)
        return e;
    return this.references[0];
  }
  static _compareReferences(e, t) {
    return Zt.compare(e.uri, t.uri) || L.compareRangesUsingStarts(e.range, t.range);
  }
}
var EL = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, TL = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, mT;
let _T = class {
  constructor(e) {
    this._resolverService = e;
  }
  hasChildren(e) {
    return e instanceof Vs || e instanceof Av;
  }
  getChildren(e) {
    if (e instanceof Vs)
      return e.groups;
    if (e instanceof Av)
      return e.resolve(this._resolverService).then((t) => t.children);
    throw new Error("bad tree");
  }
};
_T = EL([
  TL(0, xs)
], _T);
class aue {
  getHeight() {
    return 23;
  }
  getTemplateId(e) {
    return e instanceof Av ? Pv.id : Vb.id;
  }
}
let vT = class {
  constructor(e) {
    this._keybindingService = e;
  }
  getKeyboardNavigationLabel(e) {
    var t;
    if (e instanceof qc) {
      const i = (t = e.parent.getPreview(e)) === null || t === void 0 ? void 0 : t.preview(e.range);
      if (i)
        return i.value;
    }
    return Fo(e.uri);
  }
};
vT = EL([
  TL(0, _t)
], vT);
class lue {
  getId(e) {
    return e instanceof qc ? e.id : e.uri;
  }
}
let bT = class extends P {
  constructor(e, t) {
    super(), this._labelService = t;
    const i = document.createElement("div");
    i.classList.add("reference-file"), this.file = this._register(new hy(i, { supportHighlights: !0 })), this.badge = new lE(G(i, X(".count")), {}, Nz), e.appendChild(i);
  }
  set(e, t) {
    const i = P0(e.uri);
    this.file.setLabel(this._labelService.getUriBasenameLabel(e.uri), this._labelService.getUriLabel(i, { relative: !0 }), { title: this._labelService.getUriLabel(e.uri), matches: t });
    const n = e.children.length;
    this.badge.setCount(n), n > 1 ? this.badge.setTitleFormat(p("referencesCount", "{0} references", n)) : this.badge.setTitleFormat(p("referenceCount", "{0} reference", n));
  }
};
bT = EL([
  TL(1, tp)
], bT);
let Pv = mT = class {
  constructor(e) {
    this._instantiationService = e, this.templateId = mT.id;
  }
  renderTemplate(e) {
    return this._instantiationService.createInstance(bT, e);
  }
  renderElement(e, t, i) {
    i.set(e.element, Sb(e.filterData));
  }
  disposeTemplate(e) {
    e.dispose();
  }
};
Pv.id = "FileReferencesRenderer";
Pv = mT = EL([
  TL(0, be)
], Pv);
class due extends P {
  constructor(e) {
    super(), this.label = this._register(new Cc(e));
  }
  set(e, t) {
    var i;
    const n = (i = e.parent.getPreview(e)) === null || i === void 0 ? void 0 : i.preview(e.range);
    if (!n || !n.value)
      this.label.set(`${Fo(e.uri)}:${e.range.startLineNumber + 1}:${e.range.startColumn + 1}`);
    else {
      const { value: s, highlight: o } = n;
      t && !qr.isDefault(t) ? (this.label.element.classList.toggle("referenceMatch", !1), this.label.set(s, Sb(t))) : (this.label.element.classList.toggle("referenceMatch", !0), this.label.set(s, [o]));
    }
  }
}
class Vb {
  constructor() {
    this.templateId = Vb.id;
  }
  renderTemplate(e) {
    return new due(e);
  }
  renderElement(e, t, i) {
    i.set(e.element, e.filterData);
  }
  disposeTemplate(e) {
    e.dispose();
  }
}
Vb.id = "OneReferenceRenderer";
class cue {
  getWidgetAriaLabel() {
    return p("treeAriaLabel", "References");
  }
  getAriaLabel(e) {
    return e.ariaMessage;
  }
}
var hue = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Sl = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
class NL {
  constructor(e, t) {
    this._editor = e, this._model = t, this._decorations = /* @__PURE__ */ new Map(), this._decorationIgnoreSet = /* @__PURE__ */ new Set(), this._callOnDispose = new q(), this._callOnModelChange = new q(), this._callOnDispose.add(this._editor.onDidChangeModel(() => this._onModelChanged())), this._onModelChanged();
  }
  dispose() {
    this._callOnModelChange.dispose(), this._callOnDispose.dispose(), this.removeDecorations();
  }
  _onModelChanged() {
    this._callOnModelChange.clear();
    const e = this._editor.getModel();
    if (e) {
      for (const t of this._model.references)
        if (t.uri.toString() === e.uri.toString()) {
          this._addDecorations(t.parent);
          return;
        }
    }
  }
  _addDecorations(e) {
    if (!this._editor.hasModel())
      return;
    this._callOnModelChange.add(this._editor.getModel().onDidChangeDecorations(() => this._onDecorationChanged()));
    const t = [], i = [];
    for (let n = 0, s = e.children.length; n < s; n++) {
      const o = e.children[n];
      this._decorationIgnoreSet.has(o.id) || o.uri.toString() === this._editor.getModel().uri.toString() && (t.push({
        range: o.range,
        options: NL.DecorationOptions
      }), i.push(n));
    }
    this._editor.changeDecorations((n) => {
      const s = n.deltaDecorations([], t);
      for (let o = 0; o < s.length; o++)
        this._decorations.set(s[o], e.children[i[o]]);
    });
  }
  _onDecorationChanged() {
    const e = [], t = this._editor.getModel();
    if (t) {
      for (const [i, n] of this._decorations) {
        const s = t.getDecorationRange(i);
        if (!s)
          continue;
        let o = !1;
        if (!L.equalsRange(s, n.range)) {
          if (L.spansMultipleLines(s))
            o = !0;
          else {
            const a = n.range.endColumn - n.range.startColumn, l = s.endColumn - s.startColumn;
            a !== l && (o = !0);
          }
          o ? (this._decorationIgnoreSet.add(n.id), e.push(i)) : n.range = s;
        }
      }
      for (let i = 0, n = e.length; i < n; i++)
        this._decorations.delete(e[i]);
      this._editor.removeDecorations(e);
    }
  }
  removeDecorations() {
    this._editor.removeDecorations([...this._decorations.keys()]), this._decorations.clear();
  }
}
NL.DecorationOptions = Fe.register({
  description: "reference-decoration",
  stickiness: 1,
  className: "reference-decoration"
});
class uue {
  constructor() {
    this.ratio = 0.7, this.heightInLines = 18;
  }
  static fromJSON(e) {
    let t, i;
    try {
      const n = JSON.parse(e);
      t = n.ratio, i = n.heightInLines;
    } catch {
    }
    return {
      ratio: t || 0.7,
      heightInLines: i || 18
    };
  }
}
class gue extends gE {
}
let CT = class extends Ay {
  constructor(e, t, i, n, s, o, a, l, d, c, h, u) {
    super(e, { showFrame: !1, showArrow: !0, isResizeable: !0, isAccessible: !0, supportOnTitleClick: !0 }, o), this._defaultTreeKeyboardSupport = t, this.layoutData = i, this._textModelResolverService = s, this._instantiationService = o, this._peekViewService = a, this._uriLabel = l, this._undoRedoService = d, this._keybindingService = c, this._languageService = h, this._languageConfigurationService = u, this._disposeOnNewModel = new q(), this._callOnDispose = new q(), this._onDidSelectReference = new R(), this.onDidSelectReference = this._onDidSelectReference.event, this._dim = new pt(0, 0), this._applyTheme(n.getColorTheme()), this._callOnDispose.add(n.onDidColorThemeChange(this._applyTheme.bind(this))), this._peekViewService.addExclusiveWidget(e, this), this.create();
  }
  dispose() {
    this.setModel(void 0), this._callOnDispose.dispose(), this._disposeOnNewModel.dispose(), zt(this._preview), zt(this._previewNotAvailableMessage), zt(this._tree), zt(this._previewModelReference), this._splitView.dispose(), super.dispose();
  }
  _applyTheme(e) {
    const t = e.getColor(sue) || z.transparent;
    this.style({
      arrowColor: t,
      frameColor: t,
      headerBackgroundColor: e.getColor(nue) || z.transparent,
      primaryHeadingColor: e.getColor(g4),
      secondaryHeadingColor: e.getColor(f4)
    });
  }
  show(e) {
    super.show(e, this.layoutData.heightInLines || 18);
  }
  focusOnReferenceTree() {
    this._tree.domFocus();
  }
  focusOnPreviewEditor() {
    this._preview.focus();
  }
  isPreviewEditorFocused() {
    return this._preview.hasTextFocus();
  }
  _onTitleClick(e) {
    this._preview && this._preview.getModel() && this._onDidSelectReference.fire({
      element: this._getFocusedReference(),
      kind: e.ctrlKey || e.metaKey || e.altKey ? "side" : "open",
      source: "title"
    });
  }
  _fillBody(e) {
    this.setCssClass("reference-zone-widget"), this._messageContainer = G(e, X("div.messages")), Xn(this._messageContainer), this._splitView = new Kz(e, {
      orientation: 1
      /* Orientation.HORIZONTAL */
    }), this._previewContainer = G(e, X("div.preview.inline"));
    const t = {
      scrollBeyondLastLine: !1,
      scrollbar: {
        verticalScrollbarSize: 14,
        horizontal: "auto",
        useShadows: !0,
        verticalHasArrows: !1,
        horizontalHasArrows: !1,
        alwaysConsumeMouseWheel: !0
      },
      overviewRulerLanes: 2,
      fixedOverflowWidgets: !0,
      minimap: {
        enabled: !1
      }
    };
    this._preview = this._instantiationService.createInstance(jc, this._previewContainer, t, {}, this.editor), Xn(this._previewContainer), this._previewNotAvailableMessage = new il(p("missingPreviewMessage", "no preview available"), go, il.DEFAULT_CREATION_OPTIONS, null, this._undoRedoService, this._languageService, this._languageConfigurationService), this._treeContainer = G(e, X("div.ref-tree.inline"));
    const i = {
      keyboardSupport: this._defaultTreeKeyboardSupport,
      accessibilityProvider: new cue(),
      keyboardNavigationLabelProvider: this._instantiationService.createInstance(vT),
      identityProvider: new lue(),
      openOnSingleClick: !0,
      selectionNavigation: !0,
      overrideStyles: {
        listBackground: oue
      }
    };
    this._defaultTreeKeyboardSupport && this._callOnDispose.add(pi(this._treeContainer, "keydown", (s) => {
      s.equals(
        9
        /* KeyCode.Escape */
      ) && (this._keybindingService.dispatchEvent(s, s.target), s.stopPropagation());
    }, !0)), this._tree = this._instantiationService.createInstance(gue, "ReferencesWidget", this._treeContainer, new aue(), [
      this._instantiationService.createInstance(Pv),
      this._instantiationService.createInstance(Vb)
    ], this._instantiationService.createInstance(_T), i), this._splitView.addView({
      onDidChange: ne.None,
      element: this._previewContainer,
      minimumSize: 200,
      maximumSize: Number.MAX_VALUE,
      layout: (s) => {
        this._preview.layout({ height: this._dim.height, width: s });
      }
    }, oy.Distribute), this._splitView.addView({
      onDidChange: ne.None,
      element: this._treeContainer,
      minimumSize: 100,
      maximumSize: Number.MAX_VALUE,
      layout: (s) => {
        this._treeContainer.style.height = `${this._dim.height}px`, this._treeContainer.style.width = `${s}px`, this._tree.layout(this._dim.height, s);
      }
    }, oy.Distribute), this._disposables.add(this._splitView.onDidSashChange(() => {
      this._dim.width && (this.layoutData.ratio = this._splitView.getViewSize(0) / this._dim.width);
    }, void 0));
    const n = (s, o) => {
      s instanceof qc && (o === "show" && this._revealReference(s, !1), this._onDidSelectReference.fire({ element: s, kind: o, source: "tree" }));
    };
    this._tree.onDidOpen((s) => {
      s.sideBySide ? n(s.element, "side") : s.editorOptions.pinned ? n(s.element, "goto") : n(s.element, "show");
    }), Xn(this._treeContainer);
  }
  _onWidth(e) {
    this._dim && this._doLayoutBody(this._dim.height, e);
  }
  _doLayoutBody(e, t) {
    super._doLayoutBody(e, t), this._dim = new pt(t, e), this.layoutData.heightInLines = this._viewZone ? this._viewZone.heightInLines : this.layoutData.heightInLines, this._splitView.layout(t), this._splitView.resizeView(0, t * this.layoutData.ratio);
  }
  setSelection(e) {
    return this._revealReference(e, !0).then(() => {
      this._model && (this._tree.setSelection([e]), this._tree.setFocus([e]));
    });
  }
  setModel(e) {
    return this._disposeOnNewModel.clear(), this._model = e, this._model ? this._onNewModel() : Promise.resolve();
  }
  _onNewModel() {
    return this._model ? this._model.isEmpty ? (this.setTitle(""), this._messageContainer.innerText = p("noResults", "No results"), As(this._messageContainer), Promise.resolve(void 0)) : (Xn(this._messageContainer), this._decorationsManager = new NL(this._preview, this._model), this._disposeOnNewModel.add(this._decorationsManager), this._disposeOnNewModel.add(this._model.onDidChangeReferenceRange((e) => this._tree.rerender(e))), this._disposeOnNewModel.add(this._preview.onMouseDown((e) => {
      const { event: t, target: i } = e;
      if (t.detail !== 2)
        return;
      const n = this._getFocusedReference();
      n && this._onDidSelectReference.fire({
        element: { uri: n.uri, range: i.range },
        kind: t.ctrlKey || t.metaKey || t.altKey ? "side" : "open",
        source: "editor"
      });
    })), this.container.classList.add("results-loaded"), As(this._treeContainer), As(this._previewContainer), this._splitView.layout(this._dim.width), this.focusOnReferenceTree(), this._tree.setInput(this._model.groups.length === 1 ? this._model.groups[0] : this._model)) : Promise.resolve(void 0);
  }
  _getFocusedReference() {
    const [e] = this._tree.getFocus();
    if (e instanceof qc)
      return e;
    if (e instanceof Av && e.children.length > 0)
      return e.children[0];
  }
  async revealReference(e) {
    await this._revealReference(e, !1), this._onDidSelectReference.fire({ element: e, kind: "goto", source: "tree" });
  }
  async _revealReference(e, t) {
    if (this._revealedReference === e)
      return;
    this._revealedReference = e, e.uri.scheme !== Ne.inMemory ? this.setTitle(dQ(e.uri), this._uriLabel.getUriLabel(P0(e.uri))) : this.setTitle(p("peekView.alternateTitle", "References"));
    const i = this._textModelResolverService.createModelReference(e.uri);
    this._tree.getInput() === e.parent ? this._tree.reveal(e) : (t && this._tree.reveal(e.parent), await this._tree.expand(e.parent), this._tree.reveal(e));
    const n = await i;
    if (!this._model) {
      n.dispose();
      return;
    }
    zt(this._previewModelReference);
    const s = n.object;
    if (s) {
      const o = this._preview.getModel() === s.textEditorModel ? 0 : 1, a = L.lift(e.range).collapseToStart();
      this._previewModelReference = n, this._preview.setModel(s.textEditorModel), this._preview.setSelection(a), this._preview.revealRangeInCenter(a, o);
    } else
      this._preview.setModel(this._previewNotAvailableMessage), n.dispose();
  }
};
CT = hue([
  Sl(3, $i),
  Sl(4, xs),
  Sl(5, be),
  Sl(6, u4),
  Sl(7, tp),
  Sl(8, O0),
  Sl(9, _t),
  Sl(10, Jt),
  Sl(11, Ot)
], CT);
var fue = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Sg = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, Qw;
const cg = new oe("referenceSearchVisible", !1, p("referenceSearchVisible", "Whether reference peek is visible, like 'Peek References' or 'Peek Definition'"));
let Gc = Qw = class {
  static get(e) {
    return e.getContribution(Qw.ID);
  }
  constructor(e, t, i, n, s, o, a, l) {
    this._defaultTreeKeyboardSupport = e, this._editor = t, this._editorService = n, this._notificationService = s, this._instantiationService = o, this._storageService = a, this._configurationService = l, this._disposables = new q(), this._requestIdPool = 0, this._ignoreModelChangeEvent = !1, this._referenceSearchVisible = cg.bindTo(i);
  }
  dispose() {
    var e, t;
    this._referenceSearchVisible.reset(), this._disposables.dispose(), (e = this._widget) === null || e === void 0 || e.dispose(), (t = this._model) === null || t === void 0 || t.dispose(), this._widget = void 0, this._model = void 0;
  }
  toggleWidget(e, t, i) {
    let n;
    if (this._widget && (n = this._widget.position), this.closeWidget(), n && e.containsPosition(n))
      return;
    this._peekMode = i, this._referenceSearchVisible.set(!0), this._disposables.add(this._editor.onDidChangeModelLanguage(() => {
      this.closeWidget();
    })), this._disposables.add(this._editor.onDidChangeModel(() => {
      this._ignoreModelChangeEvent || this.closeWidget();
    }));
    const s = "peekViewLayout", o = uue.fromJSON(this._storageService.get(s, 0, "{}"));
    this._widget = this._instantiationService.createInstance(CT, this._editor, this._defaultTreeKeyboardSupport, o), this._widget.setTitle(p("labelLoading", "Loading...")), this._widget.show(e), this._disposables.add(this._widget.onDidClose(() => {
      t.cancel(), this._widget && (this._storageService.store(
        s,
        JSON.stringify(this._widget.layoutData),
        0,
        1
        /* StorageTarget.MACHINE */
      ), this._widget = void 0), this.closeWidget();
    })), this._disposables.add(this._widget.onDidSelectReference((l) => {
      const { element: d, kind: c } = l;
      if (d)
        switch (c) {
          case "open":
            (l.source !== "editor" || !this._configurationService.getValue("editor.stablePeek")) && this.openReference(d, !1, !1);
            break;
          case "side":
            this.openReference(d, !0, !1);
            break;
          case "goto":
            i ? this._gotoReference(d, !0) : this.openReference(d, !1, !0);
            break;
        }
    }));
    const a = ++this._requestIdPool;
    t.then((l) => {
      var d;
      if (a !== this._requestIdPool || !this._widget) {
        l.dispose();
        return;
      }
      return (d = this._model) === null || d === void 0 || d.dispose(), this._model = l, this._widget.setModel(this._model).then(() => {
        if (this._widget && this._model && this._editor.hasModel()) {
          this._model.isEmpty ? this._widget.setMetaTitle("") : this._widget.setMetaTitle(p("metaTitle.N", "{0} ({1})", this._model.title, this._model.references.length));
          const c = this._editor.getModel().uri, h = new A(e.startLineNumber, e.startColumn), u = this._model.nearestReference(c, h);
          if (u)
            return this._widget.setSelection(u).then(() => {
              this._widget && this._editor.getOption(
                87
                /* EditorOption.peekWidgetDefaultFocus */
              ) === "editor" && this._widget.focusOnPreviewEditor();
            });
        }
      });
    }, (l) => {
      this._notificationService.error(l);
    });
  }
  changeFocusBetweenPreviewAndReferences() {
    this._widget && (this._widget.isPreviewEditorFocused() ? this._widget.focusOnReferenceTree() : this._widget.focusOnPreviewEditor());
  }
  async goToNextOrPreviousReference(e) {
    if (!this._editor.hasModel() || !this._model || !this._widget)
      return;
    const t = this._widget.position;
    if (!t)
      return;
    const i = this._model.nearestReference(this._editor.getModel().uri, t);
    if (!i)
      return;
    const n = this._model.nextOrPreviousReference(i, e), s = this._editor.hasTextFocus(), o = this._widget.isPreviewEditorFocused();
    await this._widget.setSelection(n), await this._gotoReference(n, !1), s ? this._editor.focus() : this._widget && o && this._widget.focusOnPreviewEditor();
  }
  async revealReference(e) {
    !this._editor.hasModel() || !this._model || !this._widget || await this._widget.revealReference(e);
  }
  closeWidget(e = !0) {
    var t, i;
    (t = this._widget) === null || t === void 0 || t.dispose(), (i = this._model) === null || i === void 0 || i.dispose(), this._referenceSearchVisible.reset(), this._disposables.clear(), this._widget = void 0, this._model = void 0, e && this._editor.focus(), this._requestIdPool += 1;
  }
  _gotoReference(e, t) {
    var i;
    (i = this._widget) === null || i === void 0 || i.hide(), this._ignoreModelChangeEvent = !0;
    const n = L.lift(e.range).collapseToStart();
    return this._editorService.openCodeEditor({
      resource: e.uri,
      options: { selection: n, selectionSource: "code.jump", pinned: t }
    }, this._editor).then((s) => {
      var o;
      if (this._ignoreModelChangeEvent = !1, !s || !this._widget) {
        this.closeWidget();
        return;
      }
      if (this._editor === s)
        this._widget.show(n), this._widget.focusOnReferenceTree();
      else {
        const a = Qw.get(s), l = this._model.clone();
        this.closeWidget(), s.focus(), a == null || a.toggleWidget(n, Zi((d) => Promise.resolve(l)), (o = this._peekMode) !== null && o !== void 0 ? o : !1);
      }
    }, (s) => {
      this._ignoreModelChangeEvent = !1, He(s);
    });
  }
  openReference(e, t, i) {
    t || this.closeWidget();
    const { uri: n, range: s } = e;
    this._editorService.openCodeEditor({
      resource: n,
      options: { selection: s, selectionSource: "code.jump", pinned: i }
    }, this._editor, t);
  }
};
Gc.ID = "editor.contrib.referencesController";
Gc = Qw = fue([
  Sg(2, De),
  Sg(3, ht),
  Sg(4, xi),
  Sg(5, be),
  Sg(6, br),
  Sg(7, Ge)
], Gc);
function hg(r, e) {
  const t = tue(r);
  if (!t)
    return;
  const i = Gc.get(t);
  i && e(i);
}
ls.registerCommandAndKeybindingRule({
  id: "togglePeekWidgetFocus",
  weight: 100,
  primary: zi(
    2089,
    60
    /* KeyCode.F2 */
  ),
  when: U.or(cg, ks.inPeekEditor),
  handler(r) {
    hg(r, (e) => {
      e.changeFocusBetweenPreviewAndReferences();
    });
  }
});
ls.registerCommandAndKeybindingRule({
  id: "goToNextReference",
  weight: 90,
  primary: 62,
  secondary: [
    70
    /* KeyCode.F12 */
  ],
  when: U.or(cg, ks.inPeekEditor),
  handler(r) {
    hg(r, (e) => {
      e.goToNextOrPreviousReference(!0);
    });
  }
});
ls.registerCommandAndKeybindingRule({
  id: "goToPreviousReference",
  weight: 90,
  primary: 1086,
  secondary: [
    1094
    /* KeyCode.F12 */
  ],
  when: U.or(cg, ks.inPeekEditor),
  handler(r) {
    hg(r, (e) => {
      e.goToNextOrPreviousReference(!1);
    });
  }
});
st.registerCommandAlias("goToNextReferenceFromEmbeddedEditor", "goToNextReference");
st.registerCommandAlias("goToPreviousReferenceFromEmbeddedEditor", "goToPreviousReference");
st.registerCommandAlias("closeReferenceSearchEditor", "closeReferenceSearch");
st.registerCommand("closeReferenceSearch", (r) => hg(r, (e) => e.closeWidget()));
ls.registerKeybindingRule({
  id: "closeReferenceSearch",
  weight: -1,
  primary: 9,
  secondary: [
    1033
    /* KeyCode.Escape */
  ],
  when: U.and(ks.inPeekEditor, U.not("config.editor.stablePeek"))
});
ls.registerKeybindingRule({
  id: "closeReferenceSearch",
  weight: 250,
  primary: 9,
  secondary: [
    1033
    /* KeyCode.Escape */
  ],
  when: U.and(cg, U.not("config.editor.stablePeek"), U.or(x.editorTextFocus, t3.negate()))
});
ls.registerCommandAndKeybindingRule({
  id: "revealReference",
  weight: 200,
  primary: 3,
  mac: {
    primary: 3,
    secondary: [
      2066
      /* KeyCode.DownArrow */
    ]
  },
  when: U.and(cg, s3, NM.negate(), MM.negate()),
  handler(r) {
    var e;
    const i = (e = r.get(Ko).lastFocusedList) === null || e === void 0 ? void 0 : e.getFocus();
    Array.isArray(i) && i[0] instanceof qc && hg(r, (n) => n.revealReference(i[0]));
  }
});
ls.registerCommandAndKeybindingRule({
  id: "openReferenceToSide",
  weight: 100,
  primary: 2051,
  mac: {
    primary: 259
    /* KeyCode.Enter */
  },
  when: U.and(cg, s3, NM.negate(), MM.negate()),
  handler(r) {
    var e;
    const i = (e = r.get(Ko).lastFocusedList) === null || e === void 0 ? void 0 : e.getFocus();
    Array.isArray(i) && i[0] instanceof qc && hg(r, (n) => n.openReference(i[0], !0, !0));
  }
});
st.registerCommand("openReference", (r) => {
  var e;
  const i = (e = r.get(Ko).lastFocusedList) === null || e === void 0 ? void 0 : e.getFocus();
  Array.isArray(i) && i[0] instanceof qc && hg(r, (n) => n.openReference(i[0], !1, !0));
});
var p4 = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, zm = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
const _R = new oe("hasSymbols", !1, p("hasSymbols", "Whether there are symbol locations that can be navigated via keyboard-only.")), ML = et("ISymbolNavigationService");
let wT = class {
  constructor(e, t, i, n) {
    this._editorService = t, this._notificationService = i, this._keybindingService = n, this._currentModel = void 0, this._currentIdx = -1, this._ignoreEditorChange = !1, this._ctxHasSymbols = _R.bindTo(e);
  }
  reset() {
    var e, t;
    this._ctxHasSymbols.reset(), (e = this._currentState) === null || e === void 0 || e.dispose(), (t = this._currentMessage) === null || t === void 0 || t.dispose(), this._currentModel = void 0, this._currentIdx = -1;
  }
  put(e) {
    const t = e.parent.parent;
    if (t.references.length <= 1) {
      this.reset();
      return;
    }
    this._currentModel = t, this._currentIdx = t.references.indexOf(e), this._ctxHasSymbols.set(!0), this._showMessage();
    const i = new ST(this._editorService), n = i.onDidChange((s) => {
      if (this._ignoreEditorChange)
        return;
      const o = this._editorService.getActiveCodeEditor();
      if (!o)
        return;
      const a = o.getModel(), l = o.getPosition();
      if (!a || !l)
        return;
      let d = !1, c = !1;
      for (const h of t.references)
        if (B1(h.uri, a.uri))
          d = !0, c = c || L.containsPosition(h.range, l);
        else if (d)
          break;
      (!d || !c) && this.reset();
    });
    this._currentState = Ur(i, n);
  }
  revealNext(e) {
    if (!this._currentModel)
      return Promise.resolve();
    this._currentIdx += 1, this._currentIdx %= this._currentModel.references.length;
    const t = this._currentModel.references[this._currentIdx];
    return this._showMessage(), this._ignoreEditorChange = !0, this._editorService.openCodeEditor({
      resource: t.uri,
      options: {
        selection: L.collapseToStart(t.range),
        selectionRevealType: 3
        /* TextEditorSelectionRevealType.NearTopIfOutsideViewport */
      }
    }, e).finally(() => {
      this._ignoreEditorChange = !1;
    });
  }
  _showMessage() {
    var e;
    (e = this._currentMessage) === null || e === void 0 || e.dispose();
    const t = this._keybindingService.lookupKeybinding("editor.gotoNextSymbolFromResult"), i = t ? p("location.kb", "Symbol {0} of {1}, {2} for next", this._currentIdx + 1, this._currentModel.references.length, t.getLabel()) : p("location", "Symbol {0} of {1}", this._currentIdx + 1, this._currentModel.references.length);
    this._currentMessage = this._notificationService.status(i);
  }
};
wT = p4([
  zm(0, De),
  zm(1, ht),
  zm(2, xi),
  zm(3, _t)
], wT);
ot(
  ML,
  wT,
  1
  /* InstantiationType.Delayed */
);
se(new class extends Ui {
  constructor() {
    super({
      id: "editor.gotoNextSymbolFromResult",
      precondition: _R,
      kbOpts: {
        weight: 100,
        primary: 70
        /* KeyCode.F12 */
      }
    });
  }
  runEditorCommand(r, e) {
    return r.get(ML).revealNext(e);
  }
}());
ls.registerCommandAndKeybindingRule({
  id: "editor.gotoNextSymbolFromResult.cancel",
  weight: 100,
  when: _R,
  primary: 9,
  handler(r) {
    r.get(ML).reset();
  }
});
let ST = class {
  constructor(e) {
    this._listener = /* @__PURE__ */ new Map(), this._disposables = new q(), this._onDidChange = new R(), this.onDidChange = this._onDidChange.event, this._disposables.add(e.onCodeEditorRemove(this._onDidRemoveEditor, this)), this._disposables.add(e.onCodeEditorAdd(this._onDidAddEditor, this)), e.listCodeEditors().forEach(this._onDidAddEditor, this);
  }
  dispose() {
    this._disposables.dispose(), this._onDidChange.dispose(), zt(this._listener.values());
  }
  _onDidAddEditor(e) {
    this._listener.set(e, Ur(e.onDidChangeCursorPosition((t) => this._onDidChange.fire({ editor: e })), e.onDidChangeModelContent((t) => this._onDidChange.fire({ editor: e }))));
  }
  _onDidRemoveEditor(e) {
    var t;
    (t = this._listener.get(e)) === null || t === void 0 || t.dispose(), this._listener.delete(e);
  }
};
ST = p4([
  zm(0, ht)
], ST);
function yT(r, e) {
  return e.uri.scheme === r.uri.scheme ? !0 : !Ix(e.uri, Ne.walkThroughSnippet, Ne.vscodeChatCodeBlock, Ne.vscodeChatCodeCompareBlock, Ne.vscodeCopilotBackingChatCodeBlock);
}
async function zb(r, e, t, i) {
  const s = t.ordered(r).map((a) => Promise.resolve(i(a, r, e)).then(void 0, (l) => {
    _i(l);
  })), o = await Promise.all(s);
  return Yr(o.flat()).filter((a) => yT(r, a));
}
function RL(r, e, t, i) {
  return zb(e, t, r, (n, s, o) => n.provideDefinition(s, o, i));
}
function m4(r, e, t, i) {
  return zb(e, t, r, (n, s, o) => n.provideDeclaration(s, o, i));
}
function _4(r, e, t, i) {
  return zb(e, t, r, (n, s, o) => n.provideImplementation(s, o, i));
}
function v4(r, e, t, i) {
  return zb(e, t, r, (n, s, o) => n.provideTypeDefinition(s, o, i));
}
function AL(r, e, t, i, n) {
  return zb(e, t, r, async (s, o, a) => {
    var l, d;
    const c = (l = await s.provideReferences(o, a, { includeDeclaration: !0 }, n)) === null || l === void 0 ? void 0 : l.filter((u) => yT(o, u));
    if (!i || !c || c.length !== 2)
      return c;
    const h = (d = await s.provideReferences(o, a, { includeDeclaration: !1 }, n)) === null || d === void 0 ? void 0 : d.filter((u) => yT(o, u));
    return h && h.length === 1 ? h : c;
  });
}
async function Ub(r) {
  const e = await r(), t = new Vs(e, ""), i = t.references.map((n) => n.link);
  return t.dispose(), i;
}
ul("_executeDefinitionProvider", (r, e, t) => {
  const i = r.get(he), n = RL(i.definitionProvider, e, t, at.None);
  return Ub(() => n);
});
ul("_executeTypeDefinitionProvider", (r, e, t) => {
  const i = r.get(he), n = v4(i.typeDefinitionProvider, e, t, at.None);
  return Ub(() => n);
});
ul("_executeDeclarationProvider", (r, e, t) => {
  const i = r.get(he), n = m4(i.declarationProvider, e, t, at.None);
  return Ub(() => n);
});
ul("_executeReferenceProvider", (r, e, t) => {
  const i = r.get(he), n = AL(i.referenceProvider, e, t, !1, at.None);
  return Ub(() => n);
});
ul("_executeImplementationProvider", (r, e, t) => {
  const i = r.get(he), n = _4(i.implementationProvider, e, t, at.None);
  return Ub(() => n);
});
var pm, mm, _m, ZC, YC, QC, XC, JC;
on.appendMenuItem(D.EditorContext, {
  submenu: D.EditorContextPeek,
  title: p("peek.submenu", "Peek"),
  group: "navigation",
  order: 100
});
class pp {
  static is(e) {
    return !e || typeof e != "object" ? !1 : !!(e instanceof pp || A.isIPosition(e.position) && e.model);
  }
  constructor(e, t) {
    this.model = e, this.position = t;
  }
}
class Un extends ra {
  static all() {
    return Un._allSymbolNavigationCommands.values();
  }
  static _patchConfig(e) {
    const t = { ...e, f1: !0 };
    if (t.menu)
      for (const i of ut.wrap(t.menu))
        (i.id === D.EditorContext || i.id === D.EditorContextPeek) && (i.when = U.and(e.precondition, i.when));
    return t;
  }
  constructor(e, t) {
    super(Un._patchConfig(t)), this.configuration = e, Un._allSymbolNavigationCommands.set(t.id, this);
  }
  runEditorCommand(e, t, i, n) {
    if (!t.hasModel())
      return Promise.resolve(void 0);
    const s = e.get(xi), o = e.get(ht), a = e.get(sh), l = e.get(ML), d = e.get(he), c = e.get(be), h = t.getModel(), u = t.getPosition(), g = pp.is(i) ? i : new pp(h, u), f = new zc(
      t,
      5
      /* CodeEditorStateFlag.Position */
    ), m = rb(this._getLocationModel(d, g.model, g.position, f.token), f.token).then(async (_) => {
      var v;
      if (!_ || f.token.isCancellationRequested)
        return;
      Ls(_.ariaMessage);
      let b;
      if (_.referenceAt(h.uri, u)) {
        const w = this._getAlternativeCommand(t);
        !Un._activeAlternativeCommands.has(w) && Un._allSymbolNavigationCommands.has(w) && (b = Un._allSymbolNavigationCommands.get(w));
      }
      const C = _.references.length;
      if (C === 0) {
        if (!this.configuration.muteMessage) {
          const w = h.getWordAtPosition(u);
          (v = ss.get(t)) === null || v === void 0 || v.showMessage(this._getNoResultFoundMessage(w), u);
        }
      } else if (C === 1 && b)
        Un._activeAlternativeCommands.add(this.desc.id), c.invokeFunction((w) => b.runEditorCommand(w, t, i, n).finally(() => {
          Un._activeAlternativeCommands.delete(this.desc.id);
        }));
      else
        return this._onResult(o, l, t, _, n);
    }, (_) => {
      s.error(_);
    }).finally(() => {
      f.dispose();
    });
    return a.showWhile(m, 250), m;
  }
  async _onResult(e, t, i, n, s) {
    const o = this._getGoToPreference(i);
    if (!(i instanceof jc) && (this.configuration.openInPeek || o === "peek" && n.references.length > 1))
      this._openInPeek(i, n, s);
    else {
      const a = n.firstReference(), l = n.references.length > 1 && o === "gotoAndPeek", d = await this._openReference(i, e, a, this.configuration.openToSide, !l);
      l && d ? this._openInPeek(d, n, s) : n.dispose(), o === "goto" && t.put(a);
    }
  }
  async _openReference(e, t, i, n, s) {
    let o;
    if ($K(i) && (o = i.targetSelectionRange), o || (o = i.range), !o)
      return;
    const a = await t.openCodeEditor({
      resource: i.uri,
      options: {
        selection: L.collapseToStart(o),
        selectionRevealType: 3,
        selectionSource: "code.jump"
        /* TextEditorSelectionSource.JUMP */
      }
    }, e, n);
    if (a) {
      if (s) {
        const l = a.getModel(), d = a.createDecorationsCollection([{ range: o, options: { description: "symbol-navigate-action-highlight", className: "symbolHighlight" } }]);
        setTimeout(() => {
          a.getModel() === l && d.clear();
        }, 350);
      }
      return a;
    }
  }
  _openInPeek(e, t, i) {
    const n = Gc.get(e);
    n && e.hasModel() ? n.toggleWidget(i ?? e.getSelection(), Zi((s) => Promise.resolve(t)), this.configuration.openInPeek) : t.dispose();
  }
}
Un._allSymbolNavigationCommands = /* @__PURE__ */ new Map();
Un._activeAlternativeCommands = /* @__PURE__ */ new Set();
class $b extends Un {
  async _getLocationModel(e, t, i, n) {
    return new Vs(await RL(e.definitionProvider, t, i, n), p("def.title", "Definitions"));
  }
  _getNoResultFoundMessage(e) {
    return e && e.word ? p("noResultWord", "No definition found for '{0}'", e.word) : p("generic.noResults", "No definition found");
  }
  _getAlternativeCommand(e) {
    return e.getOption(
      58
      /* EditorOption.gotoLocation */
    ).alternativeDefinitionCommand;
  }
  _getGoToPreference(e) {
    return e.getOption(
      58
      /* EditorOption.gotoLocation */
    ).multipleDefinitions;
  }
}
Rt((pm = class extends $b {
  constructor() {
    super({
      openToSide: !1,
      openInPeek: !1,
      muteMessage: !1
    }, {
      id: pm.id,
      title: {
        ...Me("actions.goToDecl.label", "Go to Definition"),
        mnemonicTitle: p({ key: "miGotoDefinition", comment: ["&& denotes a mnemonic"] }, "Go to &&Definition")
      },
      precondition: x.hasDefinitionProvider,
      keybinding: [{
        when: x.editorTextFocus,
        primary: 70,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }, {
        when: U.and(x.editorTextFocus, Jz),
        primary: 2118,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }],
      menu: [{
        id: D.EditorContext,
        group: "navigation",
        order: 1.1
      }, {
        id: D.MenubarGoMenu,
        precondition: null,
        group: "4_symbol_nav",
        order: 2
      }]
    }), st.registerCommandAlias("editor.action.goToDeclaration", pm.id);
  }
}, pm.id = "editor.action.revealDefinition", pm));
Rt((mm = class extends $b {
  constructor() {
    super({
      openToSide: !0,
      openInPeek: !1,
      muteMessage: !1
    }, {
      id: mm.id,
      title: Me("actions.goToDeclToSide.label", "Open Definition to the Side"),
      precondition: U.and(x.hasDefinitionProvider, x.isInEmbeddedEditor.toNegated()),
      keybinding: [{
        when: x.editorTextFocus,
        primary: zi(
          2089,
          70
          /* KeyCode.F12 */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }, {
        when: U.and(x.editorTextFocus, Jz),
        primary: zi(
          2089,
          2118
          /* KeyCode.F12 */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }]
    }), st.registerCommandAlias("editor.action.openDeclarationToTheSide", mm.id);
  }
}, mm.id = "editor.action.revealDefinitionAside", mm));
Rt((_m = class extends $b {
  constructor() {
    super({
      openToSide: !1,
      openInPeek: !0,
      muteMessage: !1
    }, {
      id: _m.id,
      title: Me("actions.previewDecl.label", "Peek Definition"),
      precondition: U.and(x.hasDefinitionProvider, ks.notInPeekEditor, x.isInEmbeddedEditor.toNegated()),
      keybinding: {
        when: x.editorTextFocus,
        primary: 582,
        linux: {
          primary: 3140
          /* KeyCode.F10 */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menu: {
        id: D.EditorContextPeek,
        group: "peek",
        order: 2
      }
    }), st.registerCommandAlias("editor.action.previewDeclaration", _m.id);
  }
}, _m.id = "editor.action.peekDefinition", _m));
class b4 extends Un {
  async _getLocationModel(e, t, i, n) {
    return new Vs(await m4(e.declarationProvider, t, i, n), p("decl.title", "Declarations"));
  }
  _getNoResultFoundMessage(e) {
    return e && e.word ? p("decl.noResultWord", "No declaration found for '{0}'", e.word) : p("decl.generic.noResults", "No declaration found");
  }
  _getAlternativeCommand(e) {
    return e.getOption(
      58
      /* EditorOption.gotoLocation */
    ).alternativeDeclarationCommand;
  }
  _getGoToPreference(e) {
    return e.getOption(
      58
      /* EditorOption.gotoLocation */
    ).multipleDeclarations;
  }
}
Rt((ZC = class extends b4 {
  constructor() {
    super({
      openToSide: !1,
      openInPeek: !1,
      muteMessage: !1
    }, {
      id: ZC.id,
      title: {
        ...Me("actions.goToDeclaration.label", "Go to Declaration"),
        mnemonicTitle: p({ key: "miGotoDeclaration", comment: ["&& denotes a mnemonic"] }, "Go to &&Declaration")
      },
      precondition: U.and(x.hasDeclarationProvider, x.isInEmbeddedEditor.toNegated()),
      menu: [{
        id: D.EditorContext,
        group: "navigation",
        order: 1.3
      }, {
        id: D.MenubarGoMenu,
        precondition: null,
        group: "4_symbol_nav",
        order: 3
      }]
    });
  }
  _getNoResultFoundMessage(e) {
    return e && e.word ? p("decl.noResultWord", "No declaration found for '{0}'", e.word) : p("decl.generic.noResults", "No declaration found");
  }
}, ZC.id = "editor.action.revealDeclaration", ZC));
Rt(class extends b4 {
  constructor() {
    super({
      openToSide: !1,
      openInPeek: !0,
      muteMessage: !1
    }, {
      id: "editor.action.peekDeclaration",
      title: Me("actions.peekDecl.label", "Peek Declaration"),
      precondition: U.and(x.hasDeclarationProvider, ks.notInPeekEditor, x.isInEmbeddedEditor.toNegated()),
      menu: {
        id: D.EditorContextPeek,
        group: "peek",
        order: 3
      }
    });
  }
});
class C4 extends Un {
  async _getLocationModel(e, t, i, n) {
    return new Vs(await v4(e.typeDefinitionProvider, t, i, n), p("typedef.title", "Type Definitions"));
  }
  _getNoResultFoundMessage(e) {
    return e && e.word ? p("goToTypeDefinition.noResultWord", "No type definition found for '{0}'", e.word) : p("goToTypeDefinition.generic.noResults", "No type definition found");
  }
  _getAlternativeCommand(e) {
    return e.getOption(
      58
      /* EditorOption.gotoLocation */
    ).alternativeTypeDefinitionCommand;
  }
  _getGoToPreference(e) {
    return e.getOption(
      58
      /* EditorOption.gotoLocation */
    ).multipleTypeDefinitions;
  }
}
Rt((YC = class extends C4 {
  constructor() {
    super({
      openToSide: !1,
      openInPeek: !1,
      muteMessage: !1
    }, {
      id: YC.ID,
      title: {
        ...Me("actions.goToTypeDefinition.label", "Go to Type Definition"),
        mnemonicTitle: p({ key: "miGotoTypeDefinition", comment: ["&& denotes a mnemonic"] }, "Go to &&Type Definition")
      },
      precondition: x.hasTypeDefinitionProvider,
      keybinding: {
        when: x.editorTextFocus,
        primary: 0,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menu: [{
        id: D.EditorContext,
        group: "navigation",
        order: 1.4
      }, {
        id: D.MenubarGoMenu,
        precondition: null,
        group: "4_symbol_nav",
        order: 3
      }]
    });
  }
}, YC.ID = "editor.action.goToTypeDefinition", YC));
Rt((QC = class extends C4 {
  constructor() {
    super({
      openToSide: !1,
      openInPeek: !0,
      muteMessage: !1
    }, {
      id: QC.ID,
      title: Me("actions.peekTypeDefinition.label", "Peek Type Definition"),
      precondition: U.and(x.hasTypeDefinitionProvider, ks.notInPeekEditor, x.isInEmbeddedEditor.toNegated()),
      menu: {
        id: D.EditorContextPeek,
        group: "peek",
        order: 4
      }
    });
  }
}, QC.ID = "editor.action.peekTypeDefinition", QC));
class w4 extends Un {
  async _getLocationModel(e, t, i, n) {
    return new Vs(await _4(e.implementationProvider, t, i, n), p("impl.title", "Implementations"));
  }
  _getNoResultFoundMessage(e) {
    return e && e.word ? p("goToImplementation.noResultWord", "No implementation found for '{0}'", e.word) : p("goToImplementation.generic.noResults", "No implementation found");
  }
  _getAlternativeCommand(e) {
    return e.getOption(
      58
      /* EditorOption.gotoLocation */
    ).alternativeImplementationCommand;
  }
  _getGoToPreference(e) {
    return e.getOption(
      58
      /* EditorOption.gotoLocation */
    ).multipleImplementations;
  }
}
Rt((XC = class extends w4 {
  constructor() {
    super({
      openToSide: !1,
      openInPeek: !1,
      muteMessage: !1
    }, {
      id: XC.ID,
      title: {
        ...Me("actions.goToImplementation.label", "Go to Implementations"),
        mnemonicTitle: p({ key: "miGotoImplementation", comment: ["&& denotes a mnemonic"] }, "Go to &&Implementations")
      },
      precondition: x.hasImplementationProvider,
      keybinding: {
        when: x.editorTextFocus,
        primary: 2118,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menu: [{
        id: D.EditorContext,
        group: "navigation",
        order: 1.45
      }, {
        id: D.MenubarGoMenu,
        precondition: null,
        group: "4_symbol_nav",
        order: 4
      }]
    });
  }
}, XC.ID = "editor.action.goToImplementation", XC));
Rt((JC = class extends w4 {
  constructor() {
    super({
      openToSide: !1,
      openInPeek: !0,
      muteMessage: !1
    }, {
      id: JC.ID,
      title: Me("actions.peekImplementation.label", "Peek Implementations"),
      precondition: U.and(x.hasImplementationProvider, ks.notInPeekEditor, x.isInEmbeddedEditor.toNegated()),
      keybinding: {
        when: x.editorTextFocus,
        primary: 3142,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menu: {
        id: D.EditorContextPeek,
        group: "peek",
        order: 5
      }
    });
  }
}, JC.ID = "editor.action.peekImplementation", JC));
class S4 extends Un {
  _getNoResultFoundMessage(e) {
    return e ? p("references.no", "No references found for '{0}'", e.word) : p("references.noGeneric", "No references found");
  }
  _getAlternativeCommand(e) {
    return e.getOption(
      58
      /* EditorOption.gotoLocation */
    ).alternativeReferenceCommand;
  }
  _getGoToPreference(e) {
    return e.getOption(
      58
      /* EditorOption.gotoLocation */
    ).multipleReferences;
  }
}
Rt(class extends S4 {
  constructor() {
    super({
      openToSide: !1,
      openInPeek: !1,
      muteMessage: !1
    }, {
      id: "editor.action.goToReferences",
      title: {
        ...Me("goToReferences.label", "Go to References"),
        mnemonicTitle: p({ key: "miGotoReference", comment: ["&& denotes a mnemonic"] }, "Go to &&References")
      },
      precondition: U.and(x.hasReferenceProvider, ks.notInPeekEditor, x.isInEmbeddedEditor.toNegated()),
      keybinding: {
        when: x.editorTextFocus,
        primary: 1094,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menu: [{
        id: D.EditorContext,
        group: "navigation",
        order: 1.45
      }, {
        id: D.MenubarGoMenu,
        precondition: null,
        group: "4_symbol_nav",
        order: 5
      }]
    });
  }
  async _getLocationModel(e, t, i, n) {
    return new Vs(await AL(e.referenceProvider, t, i, !0, n), p("ref.title", "References"));
  }
});
Rt(class extends S4 {
  constructor() {
    super({
      openToSide: !1,
      openInPeek: !0,
      muteMessage: !1
    }, {
      id: "editor.action.referenceSearch.trigger",
      title: Me("references.action.label", "Peek References"),
      precondition: U.and(x.hasReferenceProvider, ks.notInPeekEditor, x.isInEmbeddedEditor.toNegated()),
      menu: {
        id: D.EditorContextPeek,
        group: "peek",
        order: 6
      }
    });
  }
  async _getLocationModel(e, t, i, n) {
    return new Vs(await AL(e.referenceProvider, t, i, !1, n), p("ref.title", "References"));
  }
});
class pue extends Un {
  constructor(e, t, i) {
    super(e, {
      id: "editor.action.goToLocation",
      title: Me("label.generic", "Go to Any Symbol"),
      precondition: U.and(ks.notInPeekEditor, x.isInEmbeddedEditor.toNegated())
    }), this._references = t, this._gotoMultipleBehaviour = i;
  }
  async _getLocationModel(e, t, i, n) {
    return new Vs(this._references, p("generic.title", "Locations"));
  }
  _getNoResultFoundMessage(e) {
    return e && p("generic.noResult", "No results for '{0}'", e.word) || "";
  }
  _getGoToPreference(e) {
    var t;
    return (t = this._gotoMultipleBehaviour) !== null && t !== void 0 ? t : e.getOption(
      58
      /* EditorOption.gotoLocation */
    ).multipleReferences;
  }
  _getAlternativeCommand() {
    return "";
  }
}
st.registerCommand({
  id: "editor.action.goToLocations",
  metadata: {
    description: "Go to locations from a position in a file",
    args: [
      { name: "uri", description: "The text document in which to start", constraint: Ee },
      { name: "position", description: "The position at which to start", constraint: A.isIPosition },
      { name: "locations", description: "An array of locations.", constraint: Array },
      { name: "multiple", description: "Define what to do when having multiple results, either `peek`, `gotoAndPeek`, or `goto`" },
      { name: "noResultsMessage", description: "Human readable message that shows when locations is empty." }
    ]
  },
  handler: async (r, e, t, i, n, s, o) => {
    ct(Ee.isUri(e)), ct(A.isIPosition(t)), ct(Array.isArray(i)), ct(typeof n > "u" || typeof n == "string"), ct(typeof o > "u" || typeof o == "boolean");
    const a = r.get(ht), l = await a.openCodeEditor({ resource: e }, a.getFocusedCodeEditor());
    if (al(l))
      return l.setPosition(t), l.revealPositionInCenterIfOutsideViewport(
        t,
        0
        /* ScrollType.Smooth */
      ), l.invokeWithinContext((d) => {
        const c = new class extends pue {
          _getNoResultFoundMessage(h) {
            return s || super._getNoResultFoundMessage(h);
          }
        }({
          muteMessage: !s,
          openInPeek: !!o,
          openToSide: !1
        }, i, n);
        d.get(be).invokeFunction(c.run.bind(c), l);
      });
  }
});
st.registerCommand({
  id: "editor.action.peekLocations",
  metadata: {
    description: "Peek locations from a position in a file",
    args: [
      { name: "uri", description: "The text document in which to start", constraint: Ee },
      { name: "position", description: "The position at which to start", constraint: A.isIPosition },
      { name: "locations", description: "An array of locations.", constraint: Array },
      { name: "multiple", description: "Define what to do when having multiple results, either `peek`, `gotoAndPeek`, or `goto`" }
    ]
  },
  handler: async (r, e, t, i, n) => {
    r.get($t).executeCommand("editor.action.goToLocations", e, t, i, n, void 0, !0);
  }
});
st.registerCommand({
  id: "editor.action.findReferences",
  handler: (r, e, t) => {
    ct(Ee.isUri(e)), ct(A.isIPosition(t));
    const i = r.get(he), n = r.get(ht);
    return n.openCodeEditor({ resource: e }, n.getFocusedCodeEditor()).then((s) => {
      if (!al(s) || !s.hasModel())
        return;
      const o = Gc.get(s);
      if (!o)
        return;
      const a = Zi((d) => AL(i.referenceProvider, s.getModel(), A.lift(t), !1, d).then((c) => new Vs(c, p("ref.title", "References")))), l = new L(t.lineNumber, t.column, t.lineNumber, t.column);
      return Promise.resolve(o.toggleWidget(l, a, !1));
    });
  }
});
st.registerCommandAlias("editor.action.showReferences", "editor.action.peekLocations");
async function mue(r, e, t, i) {
  var n;
  const s = r.get(xs), o = r.get(Zs), a = r.get($t), l = r.get(be), d = r.get(xi);
  if (await i.item.resolve(at.None), !i.part.location)
    return;
  const c = i.part.location, h = [], u = new Set(on.getMenuItems(D.EditorContext).map((f) => Vg(f) ? f.command.id : SL()));
  for (const f of Un.all())
    u.has(f.desc.id) && h.push(new Bs(f.desc.id, Hs.label(f.desc, { renderShortTitle: !0 }), void 0, !0, async () => {
      const m = await s.createModelReference(c.uri);
      try {
        const _ = new pp(m.object.textEditorModel, L.getStartPosition(c.range)), v = i.item.anchor.range;
        await l.invokeFunction(f.runEditorCommand.bind(f), e, _, v);
      } finally {
        m.dispose();
      }
    }));
  if (i.part.command) {
    const { command: f } = i.part;
    h.push(new Oi()), h.push(new Bs(f.id, f.title, void 0, !0, async () => {
      var m;
      try {
        await a.executeCommand(f.id, ...(m = f.arguments) !== null && m !== void 0 ? m : []);
      } catch (_) {
        d.notify({
          severity: F0.Error,
          source: i.item.provider.displayName,
          message: _
        });
      }
    }));
  }
  const g = e.getOption(
    127
    /* EditorOption.useShadowDOM */
  );
  o.showContextMenu({
    domForShadowRoot: g && (n = e.getDomNode()) !== null && n !== void 0 ? n : void 0,
    getAnchor: () => {
      const f = Ei(t);
      return { x: f.left, y: f.top + f.height + 8 };
    },
    getActions: () => h,
    onHide: () => {
      e.focus();
    },
    autoSelectFirstItem: !0
  });
}
async function y4(r, e, t, i) {
  const s = await r.get(xs).createModelReference(i.uri);
  await t.invokeWithinContext(async (o) => {
    const a = e.hasSideBySideModifier, l = o.get(De), d = ks.inPeekEditor.getValue(l), c = !a && t.getOption(
      88
      /* EditorOption.definitionLinkOpensInPeek */
    ) && !d;
    return new $b({ openToSide: a, openInPeek: c, muteMessage: !0 }, { title: { value: "", original: "" }, id: "", precondition: void 0 }).run(o, new pp(s.object.textEditorModel, L.getStartPosition(i.range)), L.lift(i.range));
  }), s.dispose();
}
var _ue = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, yg = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, Ag;
class Py {
  constructor() {
    this._entries = new Cd(50);
  }
  get(e) {
    const t = Py._key(e);
    return this._entries.get(t);
  }
  set(e, t) {
    const i = Py._key(e);
    this._entries.set(i, t);
  }
  static _key(e) {
    return `${e.uri.toString()}/${e.getVersionId()}`;
  }
}
const L4 = et("IInlayHintsCache");
ot(
  L4,
  Py,
  1
  /* InstantiationType.Delayed */
);
class LT {
  constructor(e, t) {
    this.item = e, this.index = t;
  }
  get part() {
    const e = this.item.hint.label;
    return typeof e == "string" ? { label: e } : e[this.index];
  }
}
class vue {
  constructor(e, t) {
    this.part = e, this.hasTriggerModifier = t;
  }
}
let Zc = Ag = class {
  static get(e) {
    var t;
    return (t = e.getContribution(Ag.ID)) !== null && t !== void 0 ? t : void 0;
  }
  constructor(e, t, i, n, s, o, a) {
    this._editor = e, this._languageFeaturesService = t, this._inlayHintsCache = n, this._commandService = s, this._notificationService = o, this._instaService = a, this._disposables = new q(), this._sessionDisposables = new q(), this._decorationsMetadata = /* @__PURE__ */ new Map(), this._ruleFactory = new gb(this._editor), this._activeRenderMode = 0, this._debounceInfo = i.for(t.inlayHintsProvider, "InlayHint", { min: 25 }), this._disposables.add(t.inlayHintsProvider.onDidChange(() => this._update())), this._disposables.add(e.onDidChangeModel(() => this._update())), this._disposables.add(e.onDidChangeModelLanguage(() => this._update())), this._disposables.add(e.onDidChangeConfiguration((l) => {
      l.hasChanged(
        141
        /* EditorOption.inlayHints */
      ) && this._update();
    })), this._update();
  }
  dispose() {
    this._sessionDisposables.dispose(), this._removeAllDecorations(), this._disposables.dispose();
  }
  _update() {
    this._sessionDisposables.clear(), this._removeAllDecorations();
    const e = this._editor.getOption(
      141
      /* EditorOption.inlayHints */
    );
    if (e.enabled === "off")
      return;
    const t = this._editor.getModel();
    if (!t || !this._languageFeaturesService.inlayHintsProvider.has(t))
      return;
    if (e.enabled === "on")
      this._activeRenderMode = 0;
    else {
      let a, l;
      e.enabled === "onUnlessPressed" ? (a = 0, l = 1) : (a = 1, l = 0), this._activeRenderMode = a, this._sessionDisposables.add(Hl.getInstance().event((d) => {
        if (!this._editor.hasModel())
          return;
        const c = d.altKey && d.ctrlKey && !(d.shiftKey || d.metaKey) ? l : a;
        if (c !== this._activeRenderMode) {
          this._activeRenderMode = c;
          const h = this._editor.getModel(), u = this._copyInlayHintsWithCurrentAnchor(h);
          this._updateHintsDecorators([h.getFullModelRange()], u), o.schedule(0);
        }
      }));
    }
    const i = this._inlayHintsCache.get(t);
    i && this._updateHintsDecorators([t.getFullModelRange()], i), this._sessionDisposables.add(Se(() => {
      t.isDisposed() || this._cacheHintsForFastRestore(t);
    }));
    let n;
    const s = /* @__PURE__ */ new Set(), o = new xt(async () => {
      const a = Date.now();
      n == null || n.dispose(!0), n = new mi();
      const l = t.onWillDispose(() => n == null ? void 0 : n.cancel());
      try {
        const d = n.token, c = await fu.create(this._languageFeaturesService.inlayHintsProvider, t, this._getHintsRanges(), d);
        if (o.delay = this._debounceInfo.update(t, Date.now() - a), d.isCancellationRequested) {
          c.dispose();
          return;
        }
        for (const h of c.provider)
          typeof h.onDidChangeInlayHints == "function" && !s.has(h) && (s.add(h), this._sessionDisposables.add(h.onDidChangeInlayHints(() => {
            o.isScheduled() || o.schedule();
          })));
        this._sessionDisposables.add(c), this._updateHintsDecorators(c.ranges, c.items), this._cacheHintsForFastRestore(t);
      } catch (d) {
        He(d);
      } finally {
        n.dispose(), l.dispose();
      }
    }, this._debounceInfo.get(t));
    this._sessionDisposables.add(o), this._sessionDisposables.add(Se(() => n == null ? void 0 : n.dispose(!0))), o.schedule(0), this._sessionDisposables.add(this._editor.onDidScrollChange((a) => {
      (a.scrollTopChanged || !o.isScheduled()) && o.schedule();
    })), this._sessionDisposables.add(this._editor.onDidChangeModelContent((a) => {
      n == null || n.cancel();
      const l = Math.max(o.delay, 1250);
      o.schedule(l);
    })), this._sessionDisposables.add(this._installDblClickGesture(() => o.schedule(0))), this._sessionDisposables.add(this._installLinkGesture()), this._sessionDisposables.add(this._installContextMenu());
  }
  _installLinkGesture() {
    const e = new q(), t = e.add(new xL(this._editor)), i = new q();
    return e.add(i), e.add(t.onMouseMoveOrRelevantKeyDown((n) => {
      const [s] = n, o = this._getInlayHintLabelPart(s), a = this._editor.getModel();
      if (!o || !a) {
        i.clear();
        return;
      }
      const l = new mi();
      i.add(Se(() => l.dispose(!0))), o.item.resolve(l.token), this._activeInlayHintPart = o.part.command || o.part.location ? new vue(o, s.hasTriggerModifier) : void 0;
      const d = a.validatePosition(o.item.hint.position).lineNumber, c = new L(d, 1, d, a.getLineMaxColumn(d)), h = this._getInlineHintsForRange(c);
      this._updateHintsDecorators([c], h), i.add(Se(() => {
        this._activeInlayHintPart = void 0, this._updateHintsDecorators([c], h);
      }));
    })), e.add(t.onCancel(() => i.clear())), e.add(t.onExecute(async (n) => {
      const s = this._getInlayHintLabelPart(n);
      if (s) {
        const o = s.part;
        o.location ? this._instaService.invokeFunction(y4, n, this._editor, o.location) : KK.is(o.command) && await this._invokeCommand(o.command, s.item);
      }
    })), e;
  }
  _getInlineHintsForRange(e) {
    const t = /* @__PURE__ */ new Set();
    for (const i of this._decorationsMetadata.values())
      e.containsRange(i.item.anchor.range) && t.add(i.item);
    return Array.from(t);
  }
  _installDblClickGesture(e) {
    return this._editor.onMouseUp(async (t) => {
      if (t.event.detail !== 2)
        return;
      const i = this._getInlayHintLabelPart(t);
      if (i && (t.event.preventDefault(), await i.item.resolve(at.None), Rn(i.item.hint.textEdits))) {
        const n = i.item.hint.textEdits.map((s) => ti.replace(L.lift(s.range), s.text));
        this._editor.executeEdits("inlayHint.default", n), e();
      }
    });
  }
  _installContextMenu() {
    return this._editor.onContextMenu(async (e) => {
      if (!ln(e.event.target))
        return;
      const t = this._getInlayHintLabelPart(e);
      t && await this._instaService.invokeFunction(mue, this._editor, e.event.target, t);
    });
  }
  _getInlayHintLabelPart(e) {
    var t;
    if (e.target.type !== 6)
      return;
    const i = (t = e.target.detail.injectedText) === null || t === void 0 ? void 0 : t.options;
    if (i instanceof Bc && (i == null ? void 0 : i.attachedData) instanceof LT)
      return i.attachedData;
  }
  async _invokeCommand(e, t) {
    var i;
    try {
      await this._commandService.executeCommand(e.id, ...(i = e.arguments) !== null && i !== void 0 ? i : []);
    } catch (n) {
      this._notificationService.notify({
        severity: F0.Error,
        source: t.provider.displayName,
        message: n
      });
    }
  }
  _cacheHintsForFastRestore(e) {
    const t = this._copyInlayHintsWithCurrentAnchor(e);
    this._inlayHintsCache.set(e, t);
  }
  // return inlay hints but with an anchor that reflects "updates"
  // that happened after receiving them, e.g adding new lines before a hint
  _copyInlayHintsWithCurrentAnchor(e) {
    const t = /* @__PURE__ */ new Map();
    for (const [i, n] of this._decorationsMetadata) {
      if (t.has(n.item))
        continue;
      const s = e.getDecorationRange(i);
      if (s) {
        const o = new d4(s, n.item.anchor.direction), a = n.item.with({ anchor: o });
        t.set(n.item, a);
      }
    }
    return Array.from(t.values());
  }
  _getHintsRanges() {
    const t = this._editor.getModel(), i = this._editor.getVisibleRangesPlusViewportAboveBelow(), n = [];
    for (const s of i.sort(L.compareRangesUsingStarts)) {
      const o = t.validateRange(new L(s.startLineNumber - 30, s.startColumn, s.endLineNumber + 30, s.endColumn));
      n.length === 0 || !L.areIntersectingOrTouching(n[n.length - 1], o) ? n.push(o) : n[n.length - 1] = L.plusRange(n[n.length - 1], o);
    }
    return n;
  }
  _updateHintsDecorators(e, t) {
    var i, n;
    const s = [], o = (_, v, b, C, w) => {
      const S = {
        content: b,
        inlineClassNameAffectsLetterSpacing: !0,
        inlineClassName: v.className,
        cursorStops: C,
        attachedData: w
      };
      s.push({
        item: _,
        classNameRef: v,
        decoration: {
          range: _.anchor.range,
          options: {
            // className: "rangeHighlight", // DEBUG highlight to see to what range a hint is attached
            description: "InlayHint",
            showIfCollapsed: _.anchor.range.isEmpty(),
            // "original" range is empty
            collapseOnReplaceEdit: !_.anchor.range.isEmpty(),
            stickiness: 0,
            [_.anchor.direction]: this._activeRenderMode === 0 ? S : void 0
          }
        }
      });
    }, a = (_, v) => {
      const b = this._ruleFactory.createClassNameRef({
        width: `${l / 3 | 0}px`,
        display: "inline-block"
      });
      o(_, b, "", v ? Ba.Right : Ba.None);
    }, { fontSize: l, fontFamily: d, padding: c, isUniform: h } = this._getLayoutInfo(), u = "--code-editorInlayHintsFontFamily";
    this._editor.getContainerDomNode().style.setProperty(u, d);
    let g = { line: 0, totalLen: 0 };
    for (const _ of t) {
      if (g.line !== _.anchor.range.startLineNumber && (g = { line: _.anchor.range.startLineNumber, totalLen: 0 }), g.totalLen > Ag._MAX_LABEL_LEN)
        continue;
      _.hint.paddingLeft && a(_, !1);
      const v = typeof _.hint.label == "string" ? [{ label: _.hint.label }] : _.hint.label;
      for (let b = 0; b < v.length; b++) {
        const C = v[b], w = b === 0, S = b === v.length - 1, y = {
          fontSize: `${l}px`,
          fontFamily: `var(${u}), ${Ss.fontFamily}`,
          verticalAlign: h ? "baseline" : "middle",
          unicodeBidi: "isolate"
        };
        Rn(_.hint.textEdits) && (y.cursor = "default"), this._fillInColors(y, _.hint), (C.command || C.location) && ((i = this._activeInlayHintPart) === null || i === void 0 ? void 0 : i.part.item) === _ && this._activeInlayHintPart.part.index === b && (y.textDecoration = "underline", this._activeInlayHintPart.hasTriggerModifier && (y.color = ai(yG), y.cursor = "pointer")), c && (w && S ? (y.padding = `1px ${Math.max(1, l / 4) | 0}px`, y.borderRadius = `${l / 4 | 0}px`) : w ? (y.padding = `1px 0 1px ${Math.max(1, l / 4) | 0}px`, y.borderRadius = `${l / 4 | 0}px 0 0 ${l / 4 | 0}px`) : S ? (y.padding = `1px ${Math.max(1, l / 4) | 0}px 1px 0`, y.borderRadius = `0 ${l / 4 | 0}px ${l / 4 | 0}px 0`) : y.padding = "1px 0 1px 0");
        let k = C.label;
        g.totalLen += k.length;
        let E = !1;
        const N = g.totalLen - Ag._MAX_LABEL_LEN;
        if (N > 0 && (k = k.slice(0, -N) + "", E = !0), o(_, this._ruleFactory.createClassNameRef(y), bue(k), S && !_.hint.paddingRight ? Ba.Right : Ba.None, new LT(_, b)), E)
          break;
      }
      if (_.hint.paddingRight && a(_, !0), s.length > Ag._MAX_DECORATORS)
        break;
    }
    const f = [];
    for (const [_, v] of this._decorationsMetadata) {
      const b = (n = this._editor.getModel()) === null || n === void 0 ? void 0 : n.getDecorationRange(_);
      b && e.some((C) => C.containsRange(b)) && (f.push(_), v.classNameRef.dispose(), this._decorationsMetadata.delete(_));
    }
    const m = sa.capture(this._editor);
    this._editor.changeDecorations((_) => {
      const v = _.deltaDecorations(f, s.map((b) => b.decoration));
      for (let b = 0; b < v.length; b++) {
        const C = s[b];
        this._decorationsMetadata.set(v[b], C);
      }
    }), m.restore(this._editor);
  }
  _fillInColors(e, t) {
    t.kind === hA.Parameter ? (e.backgroundColor = ai(NG), e.color = ai(TG)) : t.kind === hA.Type ? (e.backgroundColor = ai(EG), e.color = ai(IG)) : (e.backgroundColor = ai(Kl), e.color = ai($l));
  }
  _getLayoutInfo() {
    const e = this._editor.getOption(
      141
      /* EditorOption.inlayHints */
    ), t = e.padding, i = this._editor.getOption(
      52
      /* EditorOption.fontSize */
    ), n = this._editor.getOption(
      49
      /* EditorOption.fontFamily */
    );
    let s = e.fontSize;
    (!s || s < 5 || s > i) && (s = i);
    const o = e.fontFamily || n;
    return { fontSize: s, fontFamily: o, padding: t, isUniform: !t && o === n && s === i };
  }
  _removeAllDecorations() {
    this._editor.removeDecorations(Array.from(this._decorationsMetadata.keys()));
    for (const e of this._decorationsMetadata.values())
      e.classNameRef.dispose();
    this._decorationsMetadata.clear();
  }
};
Zc.ID = "editor.contrib.InlayHints";
Zc._MAX_DECORATORS = 1500;
Zc._MAX_LABEL_LEN = 43;
Zc = Ag = _ue([
  yg(1, he),
  yg(2, Vo),
  yg(3, L4),
  yg(4, $t),
  yg(5, xi),
  yg(6, be)
], Zc);
function bue(r) {
  return r.replace(/[ \t]/g, "");
}
st.registerCommand("_executeInlayHintProvider", async (r, ...e) => {
  const [t, i] = e;
  ct(Ee.isUri(t)), ct(L.isIRange(i));
  const { inlayHintsProvider: n } = r.get(he), s = await r.get(xs).createModelReference(t);
  try {
    const o = await fu.create(n, s.object.textEditorModel, [L.lift(i)], at.None), a = o.items.map((l) => l.hint);
    return setTimeout(() => o.dispose(), 0), a;
  } finally {
    s.dispose();
  }
});
var Cue = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Dh = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
class xW extends gu {
  constructor(e, t, i, n) {
    super(10, t, e.item.anchor.range, i, n, !0), this.part = e;
  }
}
let Oy = class extends Mv {
  constructor(e, t, i, n, s, o, a, l) {
    super(e, t, i, o, l, n, s), this._resolverService = a, this.hoverOrdinal = 6;
  }
  suggestHoverAnchor(e) {
    var t;
    if (!Zc.get(this._editor) || e.target.type !== 6)
      return null;
    const n = (t = e.target.detail.injectedText) === null || t === void 0 ? void 0 : t.options;
    return n instanceof Bc && n.attachedData instanceof LT ? new xW(n.attachedData, this, e.event.posx, e.event.posy) : null;
  }
  computeSync() {
    return [];
  }
  computeAsync(e, t, i) {
    return e instanceof xW ? new Ni(async (n) => {
      const { part: s } = e;
      if (await s.item.resolve(i), i.isCancellationRequested)
        return;
      let o;
      typeof s.item.hint.tooltip == "string" ? o = new Nn().appendText(s.item.hint.tooltip) : s.item.hint.tooltip && (o = s.item.hint.tooltip), o && n.emitOne(new Wr(this, e.range, [o], !1, 0)), Rn(s.item.hint.textEdits) && n.emitOne(new Wr(this, e.range, [new Nn().appendText(p("hint.dbl", "Double-click to insert"))], !1, 10001));
      let a;
      if (typeof s.part.tooltip == "string" ? a = new Nn().appendText(s.part.tooltip) : s.part.tooltip && (a = s.part.tooltip), a && n.emitOne(new Wr(this, e.range, [a], !1, 1)), s.part.location || s.part.command) {
        let d;
        const h = this._editor.getOption(
          78
          /* EditorOption.multiCursorModifier */
        ) === "altKey" ? Je ? p("links.navigate.kb.meta.mac", "cmd + click") : p("links.navigate.kb.meta", "ctrl + click") : Je ? p("links.navigate.kb.alt.mac", "option + click") : p("links.navigate.kb.alt", "alt + click");
        s.part.location && s.part.command ? d = new Nn().appendText(p("hint.defAndCommand", "Go to Definition ({0}), right click for more", h)) : s.part.location ? d = new Nn().appendText(p("hint.def", "Go to Definition ({0})", h)) : s.part.command && (d = new Nn(`[${p("hint.cmd", "Execute Command")}](${Ghe(s.part.command)} "${s.part.command.title}") (${h})`, { isTrusted: !0 })), d && n.emitOne(new Wr(this, e.range, [d], !1, 1e4));
      }
      const l = await this._resolveInlayHintLabelPartHover(s, i);
      for await (const d of l)
        n.emitOne(d);
    }) : Ni.EMPTY;
  }
  async _resolveInlayHintLabelPartHover(e, t) {
    if (!e.part.location)
      return Ni.EMPTY;
    const { uri: i, range: n } = e.part.location, s = await this._resolverService.createModelReference(i);
    try {
      const o = s.object.textEditorModel;
      return this._languageFeaturesService.hoverProvider.has(o) ? pR(this._languageFeaturesService.hoverProvider, o, new A(n.startLineNumber, n.startColumn), t).filter((a) => !Jf(a.hover.contents)).map((a) => new Wr(this, e.item.anchor.range, a.hover.contents, !1, 2 + a.ordinal)) : Ni.EMPTY;
    } finally {
      s.dispose();
    }
  }
};
Oy = Cue([
  Dh(1, Jt),
  Dh(2, Ys),
  Dh(3, _t),
  Dh(4, gl),
  Dh(5, Ge),
  Dh(6, xs),
  Dh(7, he)
], Oy);
class Fy {
  get anchor() {
    return this._anchor;
  }
  set anchor(e) {
    this._anchor = e;
  }
  get shouldFocus() {
    return this._shouldFocus;
  }
  set shouldFocus(e) {
    this._shouldFocus = e;
  }
  get source() {
    return this._source;
  }
  set source(e) {
    this._source = e;
  }
  get insistOnKeepingHoverVisible() {
    return this._insistOnKeepingHoverVisible;
  }
  set insistOnKeepingHoverVisible(e) {
    this._insistOnKeepingHoverVisible = e;
  }
  constructor(e, t) {
    this._editor = e, this._participants = t, this._anchor = null, this._shouldFocus = !1, this._source = 0, this._insistOnKeepingHoverVisible = !1;
  }
  static _getLineDecorations(e, t) {
    if (t.type !== 1 && !t.supportsMarkerHover)
      return [];
    const i = e.getModel(), n = t.range.startLineNumber;
    if (n > i.getLineCount())
      return [];
    const s = i.getLineMaxColumn(n);
    return e.getLineDecorations(n).filter((o) => {
      if (o.options.isWholeLine)
        return !0;
      const a = o.range.startLineNumber === n ? o.range.startColumn : 1, l = o.range.endLineNumber === n ? o.range.endColumn : s;
      if (o.options.showIfCollapsed) {
        if (a > t.range.startColumn + 1 || t.range.endColumn - 1 > l)
          return !1;
      } else if (a > t.range.startColumn || t.range.endColumn > l)
        return !1;
      return !0;
    });
  }
  computeAsync(e) {
    const t = this._anchor;
    if (!this._editor.hasModel() || !t)
      return Ni.EMPTY;
    const i = Fy._getLineDecorations(this._editor, t);
    return Ni.merge(this._participants.map((n) => n.computeAsync ? n.computeAsync(t, i, e) : Ni.EMPTY));
  }
  computeSync() {
    if (!this._editor.hasModel() || !this._anchor)
      return [];
    const e = Fy._getLineDecorations(this._editor, this._anchor);
    let t = [];
    for (const i of this._participants)
      t = t.concat(i.computeSync(this._anchor, e));
    return Yr(t);
  }
}
class D4 {
  constructor(e, t, i) {
    this.anchor = e, this.messages = t, this.isComplete = i;
  }
  filter(e) {
    const t = this.messages.filter((i) => i.isValidForHoverAnchor(e));
    return t.length === this.messages.length ? this : new wue(this, this.anchor, t, this.isComplete);
  }
}
class wue extends D4 {
  constructor(e, t, i, n) {
    super(t, i, n), this.original = e;
  }
  filter(e) {
    return this.original.filter(e);
  }
}
class Sue {
  constructor(e, t, i, n, s, o, a, l, d, c) {
    this.initialMousePosX = e, this.initialMousePosY = t, this.colorPicker = i, this.showAtPosition = n, this.showAtSecondaryPosition = s, this.preferAbove = o, this.stoleFocus = a, this.source = l, this.isBeforeContent = d, this.disposables = c, this.closestMouseDistance = void 0;
  }
}
var yue = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Lue = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
const IW = X;
let Wy = class extends P {
  get hasContent() {
    return this._hasContent;
  }
  constructor(e) {
    super(), this._keybindingService = e, this._hasContent = !1, this.hoverElement = IW("div.hover-row.status-bar"), this.hoverElement.tabIndex = 0, this.actionsElement = G(this.hoverElement, IW("div.actions"));
  }
  addAction(e) {
    const t = this._keybindingService.lookupKeybinding(e.commandId), i = t ? t.getLabel() : null;
    return this._hasContent = !0, this._register(B0.render(this.actionsElement, e, i));
  }
  append(e) {
    const t = G(this.actionsElement, e);
    return this._hasContent = !0, t;
  }
};
Wy = yue([
  Lue(0, _t)
], Wy);
var Due = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, EW = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, Xw;
let By = Xw = class extends P {
  constructor(e, t, i) {
    super(), this._editor = e, this._instantiationService = t, this._keybindingService = i, this._currentResult = null, this._onContentsChanged = this._register(new R()), this.onContentsChanged = this._onContentsChanged.event, this._widget = this._register(this._instantiationService.createInstance(fp, this._editor)), this._participants = [];
    for (const n of ah.getAll()) {
      const s = this._instantiationService.createInstance(n, this._editor);
      s instanceof Mv && !(s instanceof Oy) && (this._markdownHoverParticipant = s), this._participants.push(s);
    }
    this._participants.sort((n, s) => n.hoverOrdinal - s.hoverOrdinal), this._computer = new Fy(this._editor, this._participants), this._hoverOperation = this._register(new r4(this._editor, this._computer)), this._register(this._hoverOperation.onResult((n) => {
      if (!this._computer.anchor)
        return;
      const s = n.hasLoadingMessage ? this._addLoadingMessage(n.value) : n.value;
      this._withResult(new D4(this._computer.anchor, s, n.isComplete));
    })), this._register(pi(this._widget.getDomNode(), "keydown", (n) => {
      n.equals(
        9
        /* KeyCode.Escape */
      ) && this.hide();
    })), this._register(ri.onDidChange(() => {
      this._widget.position && this._currentResult && this._setCurrentResult(this._currentResult);
    }));
  }
  /**
   * Returns true if the hover shows now or will show.
   */
  _startShowingOrUpdateHover(e, t, i, n, s) {
    return !this._widget.position || !this._currentResult ? e ? (this._startHoverOperationIfNecessary(e, t, i, n, !1), !0) : !1 : this._editor.getOption(
      60
      /* EditorOption.hover */
    ).sticky && s && this._widget.isMouseGettingCloser(s.event.posx, s.event.posy) ? (e && this._startHoverOperationIfNecessary(e, t, i, n, !0), !0) : e ? e && this._currentResult.anchor.equals(e) ? !0 : e.canAdoptVisibleHover(this._currentResult.anchor, this._widget.position) ? (this._setCurrentResult(this._currentResult.filter(e)), this._startHoverOperationIfNecessary(e, t, i, n, !1), !0) : (this._setCurrentResult(null), this._startHoverOperationIfNecessary(e, t, i, n, !1), !0) : (this._setCurrentResult(null), !1);
  }
  _startHoverOperationIfNecessary(e, t, i, n, s) {
    this._computer.anchor && this._computer.anchor.equals(e) || (this._hoverOperation.cancel(), this._computer.anchor = e, this._computer.shouldFocus = n, this._computer.source = i, this._computer.insistOnKeepingHoverVisible = s, this._hoverOperation.start(t));
  }
  _setCurrentResult(e) {
    this._currentResult !== e && (e && e.messages.length === 0 && (e = null), this._currentResult = e, this._currentResult ? this._renderMessages(this._currentResult.anchor, this._currentResult.messages) : this._widget.hide());
  }
  _addLoadingMessage(e) {
    if (this._computer.anchor) {
      for (const t of this._participants)
        if (t.createLoadingMessage) {
          const i = t.createLoadingMessage(this._computer.anchor);
          if (i)
            return e.slice(0).concat([i]);
        }
    }
    return e;
  }
  _withResult(e) {
    this._widget.position && this._currentResult && this._currentResult.isComplete && (!e.isComplete || this._computer.insistOnKeepingHoverVisible && e.messages.length === 0) || this._setCurrentResult(e);
  }
  _renderMessages(e, t) {
    const { showAtPosition: i, showAtSecondaryPosition: n, highlightRange: s } = Xw.computeHoverRanges(this._editor, e.range, t), o = new q(), a = o.add(new Wy(this._keybindingService)), l = document.createDocumentFragment();
    let d = null;
    const c = {
      fragment: l,
      statusBar: a,
      setColorPicker: (u) => d = u,
      onContentsChanged: () => this._doOnContentsChanged(),
      setMinimumDimensions: (u) => this._widget.setMinimumDimensions(u),
      hide: () => this.hide()
    };
    for (const u of this._participants) {
      const g = t.filter((f) => f.owner === u);
      g.length > 0 && o.add(u.renderHoverParts(c, g));
    }
    const h = t.some((u) => u.isBeforeContent);
    if (a.hasContent && l.appendChild(a.hoverElement), l.hasChildNodes()) {
      if (s) {
        const u = this._editor.createDecorationsCollection();
        u.set([{
          range: s,
          options: Xw._DECORATION_OPTIONS
        }]), o.add(Se(() => {
          u.clear();
        }));
      }
      this._widget.showAt(l, new Sue(e.initialMousePosX, e.initialMousePosY, d, i, n, this._editor.getOption(
        60
        /* EditorOption.hover */
      ).above, this._computer.shouldFocus, this._computer.source, h, o));
    } else
      o.dispose();
  }
  _doOnContentsChanged() {
    this._onContentsChanged.fire(), this._widget.onContentsChanged();
  }
  static computeHoverRanges(e, t, i) {
    let n = 1;
    if (e.hasModel()) {
      const h = e._getViewModel(), u = h.coordinatesConverter, g = u.convertModelRangeToViewRange(t), f = new A(g.startLineNumber, h.getLineMinColumn(g.startLineNumber));
      n = u.convertViewPositionToModelPosition(f).column;
    }
    const s = t.startLineNumber;
    let o = t.startColumn, a = i[0].range, l = null;
    for (const h of i)
      a = L.plusRange(a, h.range), h.range.startLineNumber === s && h.range.endLineNumber === s && (o = Math.max(Math.min(o, h.range.startColumn), n)), h.forceShowAtRange && (l = h.range);
    const d = l ? l.getStartPosition() : new A(s, t.startColumn), c = l ? l.getStartPosition() : new A(s, o);
    return {
      showAtPosition: d,
      showAtSecondaryPosition: c,
      highlightRange: a
    };
  }
  showsOrWillShow(e) {
    if (this._widget.isResizing)
      return !0;
    const t = [];
    for (const n of this._participants)
      if (n.suggestHoverAnchor) {
        const s = n.suggestHoverAnchor(e);
        s && t.push(s);
      }
    const i = e.target;
    if (i.type === 6 && t.push(new Gk(0, i.range, e.event.posx, e.event.posy)), i.type === 7) {
      const n = this._editor.getOption(
        50
        /* EditorOption.fontInfo */
      ).typicalHalfwidthCharacterWidth / 2;
      !i.detail.isAfterLines && typeof i.detail.horizontalDistanceToText == "number" && i.detail.horizontalDistanceToText < n && t.push(new Gk(0, i.range, e.event.posx, e.event.posy));
    }
    return t.length === 0 ? this._startShowingOrUpdateHover(null, 0, 0, !1, e) : (t.sort((n, s) => s.priority - n.priority), this._startShowingOrUpdateHover(t[0], 0, 0, !1, e));
  }
  startShowingAtRange(e, t, i, n) {
    this._startShowingOrUpdateHover(new Gk(0, e, void 0, void 0), t, i, n, null);
  }
  async updateMarkdownHoverVerbosityLevel(e, t, i) {
    var n;
    (n = this._markdownHoverParticipant) === null || n === void 0 || n.updateMarkdownHoverVerbosityLevel(e, t, i);
  }
  markdownHoverContentAtIndex(e) {
    var t, i;
    return (i = (t = this._markdownHoverParticipant) === null || t === void 0 ? void 0 : t.markdownHoverContentAtIndex(e)) !== null && i !== void 0 ? i : "";
  }
  doesMarkdownHoverAtIndexSupportVerbosityAction(e, t) {
    var i, n;
    return (n = (i = this._markdownHoverParticipant) === null || i === void 0 ? void 0 : i.doesMarkdownHoverAtIndexSupportVerbosityAction(e, t)) !== null && n !== void 0 ? n : !1;
  }
  containsNode(e) {
    return e ? this._widget.getDomNode().contains(e) : !1;
  }
  focus() {
    this._widget.focus();
  }
  scrollUp() {
    this._widget.scrollUp();
  }
  scrollDown() {
    this._widget.scrollDown();
  }
  scrollLeft() {
    this._widget.scrollLeft();
  }
  scrollRight() {
    this._widget.scrollRight();
  }
  pageUp() {
    this._widget.pageUp();
  }
  pageDown() {
    this._widget.pageDown();
  }
  goToTop() {
    this._widget.goToTop();
  }
  goToBottom() {
    this._widget.goToBottom();
  }
  hide() {
    this._computer.anchor = null, this._hoverOperation.cancel(), this._setCurrentResult(null);
  }
  get isColorPickerVisible() {
    return this._widget.isColorPickerVisible;
  }
  get isVisibleFromKeyboard() {
    return this._widget.isVisibleFromKeyboard;
  }
  get isVisible() {
    return this._widget.isVisible;
  }
  get isFocused() {
    return this._widget.isFocused;
  }
  get isResizing() {
    return this._widget.isResizing;
  }
  get widget() {
    return this._widget;
  }
};
By._DECORATION_OPTIONS = Fe.register({
  description: "content-hover-highlight",
  className: "hoverHighlight"
});
By = Xw = Due([
  EW(1, be),
  EW(2, _t)
], By);
class kue {
  get lineNumber() {
    return this._lineNumber;
  }
  set lineNumber(e) {
    this._lineNumber = e;
  }
  get lane() {
    return this._laneOrLine;
  }
  set lane(e) {
    this._laneOrLine = e;
  }
  constructor(e) {
    this._editor = e, this._lineNumber = -1, this._laneOrLine = Ec.Center;
  }
  computeSync() {
    var e, t;
    const i = (a) => ({
      value: a
    }), n = this._editor.getLineDecorations(this._lineNumber), s = [], o = this._laneOrLine === "lineNo";
    if (!n)
      return s;
    for (const a of n) {
      const l = (t = (e = a.options.glyphMargin) === null || e === void 0 ? void 0 : e.position) !== null && t !== void 0 ? t : Ec.Center;
      if (!o && l !== this._laneOrLine)
        continue;
      const d = o ? a.options.lineNumberHoverMessage : a.options.glyphMarginHoverMessage;
      !d || Jf(d) || s.push(...YN(d).map(i));
    }
    return s;
  }
}
const TW = X;
class Ov extends P {
  constructor(e, t, i) {
    super(), this._renderDisposeables = this._register(new q()), this._editor = e, this._isVisible = !1, this._messages = [], this._hover = this._register(new iM()), this._hover.containerDomNode.classList.toggle("hidden", !this._isVisible), this._markdownRenderer = this._register(new nl({ editor: this._editor }, t, i)), this._computer = new kue(this._editor), this._hoverOperation = this._register(new r4(this._editor, this._computer)), this._register(this._hoverOperation.onResult((n) => {
      this._withResult(n.value);
    })), this._register(this._editor.onDidChangeModelDecorations(() => this._onModelDecorationsChanged())), this._register(this._editor.onDidChangeConfiguration((n) => {
      n.hasChanged(
        50
        /* EditorOption.fontInfo */
      ) && this._updateFont();
    })), this._editor.addOverlayWidget(this);
  }
  dispose() {
    this._editor.removeOverlayWidget(this), super.dispose();
  }
  getId() {
    return Ov.ID;
  }
  getDomNode() {
    return this._hover.containerDomNode;
  }
  getPosition() {
    return null;
  }
  _updateFont() {
    Array.prototype.slice.call(this._hover.contentsDomNode.getElementsByClassName("code")).forEach((t) => this._editor.applyFontInfo(t));
  }
  _onModelDecorationsChanged() {
    this._isVisible && (this._hoverOperation.cancel(), this._hoverOperation.start(
      0
      /* HoverStartMode.Delayed */
    ));
  }
  showsOrWillShow(e) {
    const t = e.target;
    return t.type === 2 && t.detail.glyphMarginLane ? (this._startShowingAt(t.position.lineNumber, t.detail.glyphMarginLane), !0) : t.type === 3 ? (this._startShowingAt(t.position.lineNumber, "lineNo"), !0) : !1;
  }
  _startShowingAt(e, t) {
    this._computer.lineNumber === e && this._computer.lane === t || (this._hoverOperation.cancel(), this.hide(), this._computer.lineNumber = e, this._computer.lane = t, this._hoverOperation.start(
      0
      /* HoverStartMode.Delayed */
    ));
  }
  hide() {
    this._computer.lineNumber = -1, this._hoverOperation.cancel(), this._isVisible && (this._isVisible = !1, this._hover.containerDomNode.classList.toggle("hidden", !this._isVisible));
  }
  _withResult(e) {
    this._messages = e, this._messages.length > 0 ? this._renderMessages(this._computer.lineNumber, this._messages) : this.hide();
  }
  _renderMessages(e, t) {
    this._renderDisposeables.clear();
    const i = document.createDocumentFragment();
    for (const n of t) {
      const s = TW("div.hover-row.markdown-hover"), o = G(s, TW("div.hover-contents")), a = this._renderDisposeables.add(this._markdownRenderer.render(n.value));
      o.appendChild(a.element), i.appendChild(s);
    }
    this._updateContents(i), this._showAt(e);
  }
  _updateContents(e) {
    this._hover.contentsDomNode.textContent = "", this._hover.contentsDomNode.appendChild(e), this._updateFont();
  }
  _showAt(e) {
    this._isVisible || (this._isVisible = !0, this._hover.containerDomNode.classList.toggle("hidden", !this._isVisible));
    const t = this._editor.getLayoutInfo(), i = this._editor.getTopForLineNumber(e), n = this._editor.getScrollTop(), s = this._editor.getOption(
      67
      /* EditorOption.lineHeight */
    ), o = this._hover.containerDomNode.clientHeight, a = i - n - (o - s) / 2, l = t.glyphMarginLeft + t.glyphMarginWidth + (this._computer.lane === "lineNo" ? t.lineNumbersWidth : 0);
    this._hover.containerDomNode.style.left = `${l}px`, this._hover.containerDomNode.style.top = `${Math.max(Math.round(a), 0)}px`;
  }
}
Ov.ID = "editor.contrib.modesGlyphHoverWidget";
var xue = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, NW = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, DT;
const Iue = !1;
let jn = DT = class extends P {
  constructor(e, t, i) {
    super(), this._editor = e, this._instantiationService = t, this._keybindingService = i, this._onHoverContentsChanged = this._register(new R()), this.shouldKeepOpenOnEditorMouseMoveOrLeave = !1, this._listenersStore = new q(), this._hoverState = {
      mouseDown: !1,
      activatedByDecoratorClick: !1
    }, this._reactToEditorMouseMoveRunner = this._register(new xt(() => this._reactToEditorMouseMove(this._mouseMoveEvent), 0)), this._hookListeners(), this._register(this._editor.onDidChangeConfiguration((n) => {
      n.hasChanged(
        60
        /* EditorOption.hover */
      ) && (this._unhookListeners(), this._hookListeners());
    }));
  }
  static get(e) {
    return e.getContribution(DT.ID);
  }
  _hookListeners() {
    const e = this._editor.getOption(
      60
      /* EditorOption.hover */
    );
    this._hoverSettings = {
      enabled: e.enabled,
      sticky: e.sticky,
      hidingDelay: e.delay
    }, e.enabled ? (this._listenersStore.add(this._editor.onMouseDown((t) => this._onEditorMouseDown(t))), this._listenersStore.add(this._editor.onMouseUp(() => this._onEditorMouseUp())), this._listenersStore.add(this._editor.onMouseMove((t) => this._onEditorMouseMove(t))), this._listenersStore.add(this._editor.onKeyDown((t) => this._onKeyDown(t)))) : (this._listenersStore.add(this._editor.onMouseMove((t) => this._onEditorMouseMove(t))), this._listenersStore.add(this._editor.onKeyDown((t) => this._onKeyDown(t)))), this._listenersStore.add(this._editor.onMouseLeave((t) => this._onEditorMouseLeave(t))), this._listenersStore.add(this._editor.onDidChangeModel(() => {
      this._cancelScheduler(), this._hideWidgets();
    })), this._listenersStore.add(this._editor.onDidChangeModelContent(() => this._cancelScheduler())), this._listenersStore.add(this._editor.onDidScrollChange((t) => this._onEditorScrollChanged(t)));
  }
  _unhookListeners() {
    this._listenersStore.clear();
  }
  _cancelScheduler() {
    this._mouseMoveEvent = void 0, this._reactToEditorMouseMoveRunner.cancel();
  }
  _onEditorScrollChanged(e) {
    (e.scrollTopChanged || e.scrollLeftChanged) && this._hideWidgets();
  }
  _onEditorMouseDown(e) {
    this._hoverState.mouseDown = !0, !this._shouldNotHideCurrentHoverWidget(e) && this._hideWidgets();
  }
  _shouldNotHideCurrentHoverWidget(e) {
    return !!(this._isMouseOnContentHoverWidget(e) || this._isMouseOnMarginHoverWidget(e) || this._isContentWidgetResizing());
  }
  _isMouseOnMarginHoverWidget(e) {
    const t = e.target;
    return t ? t.type === 12 && t.detail === Ov.ID : !1;
  }
  _isMouseOnContentHoverWidget(e) {
    const t = e.target;
    return t ? t.type === 9 && t.detail === fp.ID : !1;
  }
  _onEditorMouseUp() {
    this._hoverState.mouseDown = !1;
  }
  _onEditorMouseLeave(e) {
    this.shouldKeepOpenOnEditorMouseMoveOrLeave || (this._cancelScheduler(), this._shouldNotHideCurrentHoverWidget(e)) || this._hideWidgets();
  }
  _shouldNotRecomputeCurrentHoverWidget(e) {
    const t = this._hoverSettings.sticky, i = (a, l) => {
      const d = this._isMouseOnMarginHoverWidget(a);
      return l && d;
    }, n = (a, l) => {
      const d = this._isMouseOnContentHoverWidget(a);
      return l && d;
    }, s = (a) => {
      var l;
      const d = this._isMouseOnContentHoverWidget(a), c = (l = this._contentWidget) === null || l === void 0 ? void 0 : l.isColorPickerVisible;
      return d && c;
    }, o = (a, l) => {
      var d, c, h, u;
      return l && ((d = this._contentWidget) === null || d === void 0 ? void 0 : d.containsNode((c = a.event.browserEvent.view) === null || c === void 0 ? void 0 : c.document.activeElement)) && !(!((u = (h = a.event.browserEvent.view) === null || h === void 0 ? void 0 : h.getSelection()) === null || u === void 0) && u.isCollapsed);
    };
    return !!(i(e, t) || n(e, t) || s(e) || o(e, t));
  }
  _onEditorMouseMove(e) {
    var t, i, n, s;
    if (this.shouldKeepOpenOnEditorMouseMoveOrLeave || (this._mouseMoveEvent = e, !((t = this._contentWidget) === null || t === void 0) && t.isFocused || !((i = this._contentWidget) === null || i === void 0) && i.isResizing))
      return;
    const o = this._hoverSettings.sticky;
    if (o && (!((n = this._contentWidget) === null || n === void 0) && n.isVisibleFromKeyboard))
      return;
    if (this._shouldNotRecomputeCurrentHoverWidget(e)) {
      this._reactToEditorMouseMoveRunner.cancel();
      return;
    }
    const l = this._hoverSettings.hidingDelay;
    if (((s = this._contentWidget) === null || s === void 0 ? void 0 : s.isVisible) && o && l > 0) {
      this._reactToEditorMouseMoveRunner.isScheduled() || this._reactToEditorMouseMoveRunner.schedule(l);
      return;
    }
    this._reactToEditorMouseMove(e);
  }
  _reactToEditorMouseMove(e) {
    var t;
    if (!e)
      return;
    const n = (t = e.target.element) === null || t === void 0 ? void 0 : t.classList.contains("colorpicker-color-decoration"), s = this._editor.getOption(
      148
      /* EditorOption.colorDecoratorsActivatedOn */
    ), o = this._hoverSettings.enabled, a = this._hoverState.activatedByDecoratorClick;
    if (n && (s === "click" && !a || s === "hover" && !o && !Iue || s === "clickAndHover" && !o && !a) || !n && !o && !a) {
      this._hideWidgets();
      return;
    }
    this._tryShowHoverWidget(
      e,
      0
      /* HoverWidgetType.Content */
    ) || this._tryShowHoverWidget(
      e,
      1
      /* HoverWidgetType.Glyph */
    ) || this._hideWidgets();
  }
  _tryShowHoverWidget(e, t) {
    const i = this._getOrCreateContentWidget(), n = this._getOrCreateGlyphWidget();
    let s, o;
    switch (t) {
      case 0:
        s = i, o = n;
        break;
      case 1:
        s = n, o = i;
        break;
      default:
        throw new Error(`HoverWidgetType ${t} is unrecognized`);
    }
    const a = s.showsOrWillShow(e);
    return a && o.hide(), a;
  }
  _onKeyDown(e) {
    var t;
    if (!this._editor.hasModel())
      return;
    const i = this._keybindingService.softDispatch(e, this._editor.getDomNode()), n = i.kind === 1 || i.kind === 2 && (i.commandId === i4 || i.commandId === DL || i.commandId === kL) && ((t = this._contentWidget) === null || t === void 0 ? void 0 : t.isVisible);
    e.keyCode === 5 || e.keyCode === 6 || e.keyCode === 57 || e.keyCode === 4 || n || this._hideWidgets();
  }
  _hideWidgets() {
    var e, t, i;
    this._hoverState.mouseDown && (!((e = this._contentWidget) === null || e === void 0) && e.isColorPickerVisible) || Kc.dropDownVisible || (this._hoverState.activatedByDecoratorClick = !1, (t = this._glyphWidget) === null || t === void 0 || t.hide(), (i = this._contentWidget) === null || i === void 0 || i.hide());
  }
  _getOrCreateContentWidget() {
    return this._contentWidget || (this._contentWidget = this._instantiationService.createInstance(By, this._editor), this._listenersStore.add(this._contentWidget.onContentsChanged(() => this._onHoverContentsChanged.fire()))), this._contentWidget;
  }
  _getOrCreateGlyphWidget() {
    return this._glyphWidget || (this._glyphWidget = this._instantiationService.createInstance(Ov, this._editor)), this._glyphWidget;
  }
  showContentHover(e, t, i, n, s = !1) {
    this._hoverState.activatedByDecoratorClick = s, this._getOrCreateContentWidget().startShowingAtRange(e, t, i, n);
  }
  _isContentWidgetResizing() {
    var e;
    return ((e = this._contentWidget) === null || e === void 0 ? void 0 : e.widget.isResizing) || !1;
  }
  markdownHoverContentAtIndex(e) {
    return this._getOrCreateContentWidget().markdownHoverContentAtIndex(e);
  }
  doesMarkdownHoverAtIndexSupportVerbosityAction(e, t) {
    return this._getOrCreateContentWidget().doesMarkdownHoverAtIndexSupportVerbosityAction(e, t);
  }
  updateMarkdownHoverVerbosityLevel(e, t, i) {
    this._getOrCreateContentWidget().updateMarkdownHoverVerbosityLevel(e, t, i);
  }
  focus() {
    var e;
    (e = this._contentWidget) === null || e === void 0 || e.focus();
  }
  scrollUp() {
    var e;
    (e = this._contentWidget) === null || e === void 0 || e.scrollUp();
  }
  scrollDown() {
    var e;
    (e = this._contentWidget) === null || e === void 0 || e.scrollDown();
  }
  scrollLeft() {
    var e;
    (e = this._contentWidget) === null || e === void 0 || e.scrollLeft();
  }
  scrollRight() {
    var e;
    (e = this._contentWidget) === null || e === void 0 || e.scrollRight();
  }
  pageUp() {
    var e;
    (e = this._contentWidget) === null || e === void 0 || e.pageUp();
  }
  pageDown() {
    var e;
    (e = this._contentWidget) === null || e === void 0 || e.pageDown();
  }
  goToTop() {
    var e;
    (e = this._contentWidget) === null || e === void 0 || e.goToTop();
  }
  goToBottom() {
    var e;
    (e = this._contentWidget) === null || e === void 0 || e.goToBottom();
  }
  get isColorPickerVisible() {
    var e;
    return (e = this._contentWidget) === null || e === void 0 ? void 0 : e.isColorPickerVisible;
  }
  get isHoverVisible() {
    var e;
    return (e = this._contentWidget) === null || e === void 0 ? void 0 : e.isVisible;
  }
  dispose() {
    var e, t;
    super.dispose(), this._unhookListeners(), this._listenersStore.dispose(), (e = this._glyphWidget) === null || e === void 0 || e.dispose(), (t = this._contentWidget) === null || t === void 0 || t.dispose();
  }
};
jn.ID = "editor.contrib.hover";
jn = DT = xue([
  NW(1, be),
  NW(2, _t)
], jn);
class kT extends P {
  constructor(e) {
    super(), this._editor = e, this._register(e.onMouseDown((t) => this.onMouseDown(t)));
  }
  dispose() {
    super.dispose();
  }
  onMouseDown(e) {
    const t = this._editor.getOption(
      148
      /* EditorOption.colorDecoratorsActivatedOn */
    );
    if (t !== "click" && t !== "clickAndHover")
      return;
    const i = e.target;
    if (i.type !== 6 || !i.detail.injectedText || i.detail.injectedText.options.attachedData !== ZU || !i.range)
      return;
    const n = this._editor.getContribution(jn.ID);
    if (n && !n.isColorPickerVisible) {
      const s = new L(i.range.startLineNumber, i.range.startColumn + 1, i.range.endLineNumber, i.range.endColumn + 1);
      n.showContentHover(s, 1, 0, !1, !0);
    }
  }
}
kT.ID = "editor.contrib.colorContribution";
gt(
  kT.ID,
  kT,
  2
  /* EditorContributionInstantiation.BeforeFirstInteraction */
);
ah.register(Ry);
var k4 = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Ar = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, xT, IT;
let Yc = xT = class extends P {
  constructor(e, t, i, n, s, o, a) {
    super(), this._editor = e, this._modelService = i, this._keybindingService = n, this._instantiationService = s, this._languageFeatureService = o, this._languageConfigurationService = a, this._standaloneColorPickerWidget = null, this._standaloneColorPickerVisible = x.standaloneColorPickerVisible.bindTo(t), this._standaloneColorPickerFocused = x.standaloneColorPickerFocused.bindTo(t);
  }
  showOrFocus() {
    var e;
    this._editor.hasModel() && (this._standaloneColorPickerVisible.get() ? this._standaloneColorPickerFocused.get() || (e = this._standaloneColorPickerWidget) === null || e === void 0 || e.focus() : this._standaloneColorPickerWidget = new Hy(this._editor, this._standaloneColorPickerVisible, this._standaloneColorPickerFocused, this._instantiationService, this._modelService, this._keybindingService, this._languageFeatureService, this._languageConfigurationService));
  }
  hide() {
    var e;
    this._standaloneColorPickerFocused.set(!1), this._standaloneColorPickerVisible.set(!1), (e = this._standaloneColorPickerWidget) === null || e === void 0 || e.hide(), this._editor.focus();
  }
  insertColor() {
    var e;
    (e = this._standaloneColorPickerWidget) === null || e === void 0 || e.updateEditor(), this.hide();
  }
  static get(e) {
    return e.getContribution(xT.ID);
  }
};
Yc.ID = "editor.contrib.standaloneColorPickerController";
Yc = xT = k4([
  Ar(1, De),
  Ar(2, ii),
  Ar(3, _t),
  Ar(4, be),
  Ar(5, he),
  Ar(6, Ot)
], Yc);
gt(
  Yc.ID,
  Yc,
  1
  /* EditorContributionInstantiation.AfterFirstRender */
);
const MW = 8, Eue = 22;
let Hy = IT = class extends P {
  constructor(e, t, i, n, s, o, a, l) {
    var d;
    super(), this._editor = e, this._standaloneColorPickerVisible = t, this._standaloneColorPickerFocused = i, this._modelService = s, this._keybindingService = o, this._languageFeaturesService = a, this._languageConfigurationService = l, this.allowEditorOverflow = !0, this._position = void 0, this._body = document.createElement("div"), this._colorHover = null, this._selectionSetInEditor = !1, this._onResult = this._register(new R()), this.onResult = this._onResult.event, this._standaloneColorPickerVisible.set(!0), this._standaloneColorPickerParticipant = n.createInstance(Nv, this._editor), this._position = (d = this._editor._getViewModel()) === null || d === void 0 ? void 0 : d.getPrimaryCursorState().modelState.position;
    const c = this._editor.getSelection(), h = c ? {
      startLineNumber: c.startLineNumber,
      startColumn: c.startColumn,
      endLineNumber: c.endLineNumber,
      endColumn: c.endColumn
    } : { startLineNumber: 0, endLineNumber: 0, endColumn: 0, startColumn: 0 }, u = this._register(Xr(this._body));
    this._register(u.onDidBlur((g) => {
      this.hide();
    })), this._register(u.onDidFocus((g) => {
      this.focus();
    })), this._register(this._editor.onDidChangeCursorPosition(() => {
      this._selectionSetInEditor ? this._selectionSetInEditor = !1 : this.hide();
    })), this._register(this._editor.onMouseMove((g) => {
      var f;
      const m = (f = g.target.element) === null || f === void 0 ? void 0 : f.classList;
      m && m.contains("colorpicker-color-decoration") && this.hide();
    })), this._register(this.onResult((g) => {
      this._render(g.value, g.foundInEditor);
    })), this._start(h), this._body.style.zIndex = "50", this._editor.addContentWidget(this);
  }
  updateEditor() {
    this._colorHover && this._standaloneColorPickerParticipant.updateEditorModel(this._colorHover);
  }
  getId() {
    return IT.ID;
  }
  getDomNode() {
    return this._body;
  }
  getPosition() {
    if (!this._position)
      return null;
    const e = this._editor.getOption(
      60
      /* EditorOption.hover */
    ).above;
    return {
      position: this._position,
      secondaryPosition: this._position,
      preference: e ? [
        1,
        2
        /* ContentWidgetPositionPreference.BELOW */
      ] : [
        2,
        1
        /* ContentWidgetPositionPreference.ABOVE */
      ],
      positionAffinity: 2
      /* PositionAffinity.None */
    };
  }
  hide() {
    this.dispose(), this._standaloneColorPickerVisible.set(!1), this._standaloneColorPickerFocused.set(!1), this._editor.removeContentWidget(this), this._editor.focus();
  }
  focus() {
    this._standaloneColorPickerFocused.set(!0), this._body.focus();
  }
  async _start(e) {
    const t = await this._computeAsync(e);
    t && this._onResult.fire(new Tue(t.result, t.foundInEditor));
  }
  async _computeAsync(e) {
    if (!this._editor.hasModel())
      return null;
    const t = {
      range: e,
      color: { red: 0, green: 0, blue: 0, alpha: 1 }
    }, i = await this._standaloneColorPickerParticipant.createColorHover(t, new hR(this._modelService, this._languageConfigurationService), this._languageFeaturesService.colorProvider);
    return i ? { result: i.colorHover, foundInEditor: i.foundInEditor } : null;
  }
  _render(e, t) {
    const i = document.createDocumentFragment(), n = this._register(new Wy(this._keybindingService));
    let s;
    const o = {
      fragment: i,
      statusBar: n,
      setColorPicker: (m) => s = m,
      onContentsChanged: () => {
      },
      hide: () => this.hide()
    };
    if (this._colorHover = e, this._register(this._standaloneColorPickerParticipant.renderHoverParts(o, [e])), s === void 0)
      return;
    this._body.classList.add("standalone-colorpicker-body"), this._body.style.maxHeight = Math.max(this._editor.getLayoutInfo().height / 4, 250) + "px", this._body.style.maxWidth = Math.max(this._editor.getLayoutInfo().width * 0.66, 500) + "px", this._body.tabIndex = 0, this._body.appendChild(i), s.layout();
    const a = s.body, l = a.saturationBox.domNode.clientWidth, d = a.domNode.clientWidth - l - Eue - MW, c = s.body.enterButton;
    c == null || c.onClicked(() => {
      this.updateEditor(), this.hide();
    });
    const h = s.header, u = h.pickedColorNode;
    u.style.width = l + MW + "px";
    const g = h.originalColorNode;
    g.style.width = d + "px";
    const f = s.header.closeButton;
    f == null || f.onClicked(() => {
      this.hide();
    }), t && (c && (c.button.textContent = "Replace"), this._selectionSetInEditor = !0, this._editor.setSelection(e.range)), this._editor.layoutContentWidget(this);
  }
};
Hy.ID = "editor.contrib.standaloneColorPickerWidget";
Hy = IT = k4([
  Ar(3, be),
  Ar(4, ii),
  Ar(5, _t),
  Ar(6, he),
  Ar(7, Ot)
], Hy);
class Tue {
  // The color picker result consists of: an array of color results and a boolean indicating if the color was found in the editor
  constructor(e, t) {
    this.value = e, this.foundInEditor = t;
  }
}
class Nue extends ra {
  constructor() {
    super({
      id: "editor.action.showOrFocusStandaloneColorPicker",
      title: {
        ...Me("showOrFocusStandaloneColorPicker", "Show or Focus Standalone Color Picker"),
        mnemonicTitle: p({ key: "mishowOrFocusStandaloneColorPicker", comment: ["&& denotes a mnemonic"] }, "&&Show or Focus Standalone Color Picker")
      },
      precondition: void 0,
      menu: [
        { id: D.CommandPalette }
      ],
      metadata: {
        description: Me("showOrFocusStandaloneColorPickerDescription", "Show or focus a standalone color picker which uses the default color provider. It displays hex/rgb/hsl colors.")
      }
    });
  }
  runEditorCommand(e, t) {
    var i;
    (i = Yc.get(t)) === null || i === void 0 || i.showOrFocus();
  }
}
class Mue extends ae {
  constructor() {
    super({
      id: "editor.action.hideColorPicker",
      label: p({
        key: "hideColorPicker",
        comment: [
          "Action that hides the color picker"
        ]
      }, "Hide the Color Picker"),
      alias: "Hide the Color Picker",
      precondition: x.standaloneColorPickerVisible.isEqualTo(!0),
      kbOpts: {
        primary: 9,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      metadata: {
        description: Me("hideColorPickerDescription", "Hide the standalone color picker.")
      }
    });
  }
  run(e, t) {
    var i;
    (i = Yc.get(t)) === null || i === void 0 || i.hide();
  }
}
class Rue extends ae {
  constructor() {
    super({
      id: "editor.action.insertColorWithStandaloneColorPicker",
      label: p({
        key: "insertColorWithStandaloneColorPicker",
        comment: [
          "Action that inserts color with standalone color picker"
        ]
      }, "Insert Color with Standalone Color Picker"),
      alias: "Insert Color with Standalone Color Picker",
      precondition: x.standaloneColorPickerFocused.isEqualTo(!0),
      kbOpts: {
        primary: 3,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      metadata: {
        description: Me("insertColorWithStandaloneColorPickerDescription", "Insert hex/rgb/hsl colors with the focused standalone color picker.")
      }
    });
  }
  run(e, t) {
    var i;
    (i = Yc.get(t)) === null || i === void 0 || i.insertColor();
  }
}
Y(Mue);
Y(Rue);
Rt(Nue);
class hc {
  constructor(e, t, i) {
    this.languageConfigurationService = i, this._selection = e, this._insertSpace = t, this._usedEndToken = null;
  }
  static _haystackHasNeedleAtOffset(e, t, i) {
    if (i < 0)
      return !1;
    const n = t.length, s = e.length;
    if (i + n > s)
      return !1;
    for (let o = 0; o < n; o++) {
      const a = e.charCodeAt(i + o), l = t.charCodeAt(o);
      if (a !== l && !(a >= 65 && a <= 90 && a + 32 === l) && !(l >= 65 && l <= 90 && l + 32 === a))
        return !1;
    }
    return !0;
  }
  _createOperationsForBlockComment(e, t, i, n, s, o) {
    const a = e.startLineNumber, l = e.startColumn, d = e.endLineNumber, c = e.endColumn, h = s.getLineContent(a), u = s.getLineContent(d);
    let g = h.lastIndexOf(t, l - 1 + t.length), f = u.indexOf(i, c - 1 - i.length);
    if (g !== -1 && f !== -1)
      if (a === d)
        h.substring(g + t.length, f).indexOf(i) >= 0 && (g = -1, f = -1);
      else {
        const _ = h.substring(g + t.length), v = u.substring(0, f);
        (_.indexOf(i) >= 0 || v.indexOf(i) >= 0) && (g = -1, f = -1);
      }
    let m;
    g !== -1 && f !== -1 ? (n && g + t.length < h.length && h.charCodeAt(g + t.length) === 32 && (t = t + " "), n && f > 0 && u.charCodeAt(f - 1) === 32 && (i = " " + i, f -= 1), m = hc._createRemoveBlockCommentOperations(new L(a, g + t.length + 1, d, f + 1), t, i)) : (m = hc._createAddBlockCommentOperations(e, t, i, this._insertSpace), this._usedEndToken = m.length === 1 ? i : null);
    for (const _ of m)
      o.addTrackedEditOperation(_.range, _.text);
  }
  static _createRemoveBlockCommentOperations(e, t, i) {
    const n = [];
    return L.isEmpty(e) ? n.push(ti.delete(new L(e.startLineNumber, e.startColumn - t.length, e.endLineNumber, e.endColumn + i.length))) : (n.push(ti.delete(new L(e.startLineNumber, e.startColumn - t.length, e.startLineNumber, e.startColumn))), n.push(ti.delete(new L(e.endLineNumber, e.endColumn, e.endLineNumber, e.endColumn + i.length)))), n;
  }
  static _createAddBlockCommentOperations(e, t, i, n) {
    const s = [];
    return L.isEmpty(e) ? s.push(ti.replace(new L(e.startLineNumber, e.startColumn, e.endLineNumber, e.endColumn), t + "  " + i)) : (s.push(ti.insert(new A(e.startLineNumber, e.startColumn), t + (n ? " " : ""))), s.push(ti.insert(new A(e.endLineNumber, e.endColumn), (n ? " " : "") + i))), s;
  }
  getEditOperations(e, t) {
    const i = this._selection.startLineNumber, n = this._selection.startColumn;
    e.tokenization.tokenizeIfCheap(i);
    const s = e.getLanguageIdAtPosition(i, n), o = this.languageConfigurationService.getLanguageConfiguration(s).comments;
    !o || !o.blockCommentStartToken || !o.blockCommentEndToken || this._createOperationsForBlockComment(this._selection, o.blockCommentStartToken, o.blockCommentEndToken, this._insertSpace, e, t);
  }
  computeCursorState(e, t) {
    const i = t.getInverseEditOperations();
    if (i.length === 2) {
      const n = i[0], s = i[1];
      return new ge(n.range.endLineNumber, n.range.endColumn, s.range.startLineNumber, s.range.startColumn);
    } else {
      const n = i[0].range, s = this._usedEndToken ? -this._usedEndToken.length - 1 : 0;
      return new ge(n.endLineNumber, n.endColumn + s, n.endLineNumber, n.endColumn + s);
    }
  }
}
class Il {
  constructor(e, t, i, n, s, o, a) {
    this.languageConfigurationService = e, this._selection = t, this._indentSize = i, this._type = n, this._insertSpace = s, this._selectionId = null, this._deltaColumn = 0, this._moveEndPositionDown = !1, this._ignoreEmptyLines = o, this._ignoreFirstLine = a || !1;
  }
  /**
   * Do an initial pass over the lines and gather info about the line comment string.
   * Returns null if any of the lines doesn't support a line comment string.
   */
  static _gatherPreflightCommentStrings(e, t, i, n) {
    e.tokenization.tokenizeIfCheap(t);
    const s = e.getLanguageIdAtPosition(t, 1), o = n.getLanguageConfiguration(s).comments, a = o ? o.lineCommentToken : null;
    if (!a)
      return null;
    const l = [];
    for (let d = 0, c = i - t + 1; d < c; d++)
      l[d] = {
        ignore: !1,
        commentStr: a,
        commentStrOffset: 0,
        commentStrLength: a.length
      };
    return l;
  }
  /**
   * Analyze lines and decide which lines are relevant and what the toggle should do.
   * Also, build up several offsets and lengths useful in the generation of editor operations.
   */
  static _analyzeLines(e, t, i, n, s, o, a, l) {
    let d = !0, c;
    e === 0 ? c = !0 : e === 1 ? c = !1 : c = !0;
    for (let h = 0, u = n.length; h < u; h++) {
      const g = n[h], f = s + h;
      if (f === s && a) {
        g.ignore = !0;
        continue;
      }
      const m = i.getLineContent(f), _ = ns(m);
      if (_ === -1) {
        g.ignore = o, g.commentStrOffset = m.length;
        continue;
      }
      if (d = !1, g.ignore = !1, g.commentStrOffset = _, c && !hc._haystackHasNeedleAtOffset(m, g.commentStr, _) && (e === 0 ? c = !1 : e === 1 || (g.ignore = !0)), c && t) {
        const v = _ + g.commentStrLength;
        v < m.length && m.charCodeAt(v) === 32 && (g.commentStrLength += 1);
      }
    }
    if (e === 0 && d) {
      c = !1;
      for (let h = 0, u = n.length; h < u; h++)
        n[h].ignore = !1;
    }
    return {
      supported: !0,
      shouldRemoveComments: c,
      lines: n
    };
  }
  /**
   * Analyze all lines and decide exactly what to do => not supported | insert line comments | remove line comments
   */
  static _gatherPreflightData(e, t, i, n, s, o, a, l) {
    const d = Il._gatherPreflightCommentStrings(i, n, s, l);
    return d === null ? {
      supported: !1
    } : Il._analyzeLines(e, t, i, d, n, o, a, l);
  }
  /**
   * Given a successful analysis, execute either insert line comments, either remove line comments
   */
  _executeLineComments(e, t, i, n) {
    let s;
    i.shouldRemoveComments ? s = Il._createRemoveLineCommentsOperations(i.lines, n.startLineNumber) : (Il._normalizeInsertionPoint(e, i.lines, n.startLineNumber, this._indentSize), s = this._createAddLineCommentsOperations(i.lines, n.startLineNumber));
    const o = new A(n.positionLineNumber, n.positionColumn);
    for (let a = 0, l = s.length; a < l; a++)
      t.addEditOperation(s[a].range, s[a].text), L.isEmpty(s[a].range) && L.getStartPosition(s[a].range).equals(o) && e.getLineContent(o.lineNumber).length + 1 === o.column && (this._deltaColumn = (s[a].text || "").length);
    this._selectionId = t.trackSelection(n);
  }
  _attemptRemoveBlockComment(e, t, i, n) {
    let s = t.startLineNumber, o = t.endLineNumber;
    const a = n.length + Math.max(e.getLineFirstNonWhitespaceColumn(t.startLineNumber), t.startColumn);
    let l = e.getLineContent(s).lastIndexOf(i, a - 1), d = e.getLineContent(o).indexOf(n, t.endColumn - 1 - i.length);
    return l !== -1 && d === -1 && (d = e.getLineContent(s).indexOf(n, l + i.length), o = s), l === -1 && d !== -1 && (l = e.getLineContent(o).lastIndexOf(i, d), s = o), t.isEmpty() && (l === -1 || d === -1) && (l = e.getLineContent(s).indexOf(i), l !== -1 && (d = e.getLineContent(s).indexOf(n, l + i.length))), l !== -1 && e.getLineContent(s).charCodeAt(l + i.length) === 32 && (i += " "), d !== -1 && e.getLineContent(o).charCodeAt(d - 1) === 32 && (n = " " + n, d -= 1), l !== -1 && d !== -1 ? hc._createRemoveBlockCommentOperations(new L(s, l + i.length + 1, o, d + 1), i, n) : null;
  }
  /**
   * Given an unsuccessful analysis, delegate to the block comment command
   */
  _executeBlockComment(e, t, i) {
    e.tokenization.tokenizeIfCheap(i.startLineNumber);
    const n = e.getLanguageIdAtPosition(i.startLineNumber, 1), s = this.languageConfigurationService.getLanguageConfiguration(n).comments;
    if (!s || !s.blockCommentStartToken || !s.blockCommentEndToken)
      return;
    const o = s.blockCommentStartToken, a = s.blockCommentEndToken;
    let l = this._attemptRemoveBlockComment(e, i, o, a);
    if (!l) {
      if (i.isEmpty()) {
        const d = e.getLineContent(i.startLineNumber);
        let c = ns(d);
        c === -1 && (c = d.length), l = hc._createAddBlockCommentOperations(new L(i.startLineNumber, c + 1, i.startLineNumber, d.length + 1), o, a, this._insertSpace);
      } else
        l = hc._createAddBlockCommentOperations(new L(i.startLineNumber, e.getLineFirstNonWhitespaceColumn(i.startLineNumber), i.endLineNumber, e.getLineMaxColumn(i.endLineNumber)), o, a, this._insertSpace);
      l.length === 1 && (this._deltaColumn = o.length + 1);
    }
    this._selectionId = t.trackSelection(i);
    for (const d of l)
      t.addEditOperation(d.range, d.text);
  }
  getEditOperations(e, t) {
    let i = this._selection;
    if (this._moveEndPositionDown = !1, i.startLineNumber === i.endLineNumber && this._ignoreFirstLine) {
      t.addEditOperation(new L(i.startLineNumber, e.getLineMaxColumn(i.startLineNumber), i.startLineNumber + 1, 1), i.startLineNumber === e.getLineCount() ? "" : `
`), this._selectionId = t.trackSelection(i);
      return;
    }
    i.startLineNumber < i.endLineNumber && i.endColumn === 1 && (this._moveEndPositionDown = !0, i = i.setEndPosition(i.endLineNumber - 1, e.getLineMaxColumn(i.endLineNumber - 1)));
    const n = Il._gatherPreflightData(this._type, this._insertSpace, e, i.startLineNumber, i.endLineNumber, this._ignoreEmptyLines, this._ignoreFirstLine, this.languageConfigurationService);
    return n.supported ? this._executeLineComments(e, t, n, i) : this._executeBlockComment(e, t, i);
  }
  computeCursorState(e, t) {
    let i = t.getTrackedSelection(this._selectionId);
    return this._moveEndPositionDown && (i = i.setEndPosition(i.endLineNumber + 1, 1)), new ge(i.selectionStartLineNumber, i.selectionStartColumn + this._deltaColumn, i.positionLineNumber, i.positionColumn + this._deltaColumn);
  }
  /**
   * Generate edit operations in the remove line comment case
   */
  static _createRemoveLineCommentsOperations(e, t) {
    const i = [];
    for (let n = 0, s = e.length; n < s; n++) {
      const o = e[n];
      o.ignore || i.push(ti.delete(new L(t + n, o.commentStrOffset + 1, t + n, o.commentStrOffset + o.commentStrLength + 1)));
    }
    return i;
  }
  /**
   * Generate edit operations in the add line comment case
   */
  _createAddLineCommentsOperations(e, t) {
    const i = [], n = this._insertSpace ? " " : "";
    for (let s = 0, o = e.length; s < o; s++) {
      const a = e[s];
      a.ignore || i.push(ti.insert(new A(t + s, a.commentStrOffset + 1), a.commentStr + n));
    }
    return i;
  }
  static nextVisibleColumn(e, t, i, n) {
    return i ? e + (t - e % t) : e + n;
  }
  /**
   * Adjust insertion points to have them vertically aligned in the add line comment case
   */
  static _normalizeInsertionPoint(e, t, i, n) {
    let s = 1073741824, o, a;
    for (let l = 0, d = t.length; l < d; l++) {
      if (t[l].ignore)
        continue;
      const c = e.getLineContent(i + l);
      let h = 0;
      for (let u = 0, g = t[l].commentStrOffset; h < s && u < g; u++)
        h = Il.nextVisibleColumn(h, n, c.charCodeAt(u) === 9, 1);
      h < s && (s = h);
    }
    s = Math.floor(s / n) * n;
    for (let l = 0, d = t.length; l < d; l++) {
      if (t[l].ignore)
        continue;
      const c = e.getLineContent(i + l);
      let h = 0;
      for (o = 0, a = t[l].commentStrOffset; h < s && o < a; o++)
        h = Il.nextVisibleColumn(h, n, c.charCodeAt(o) === 9, 1);
      h > s ? t[l].commentStrOffset = o - 1 : t[l].commentStrOffset = o;
    }
  }
}
class vR extends ae {
  constructor(e, t) {
    super(t), this._type = e;
  }
  run(e, t) {
    const i = e.get(Ot);
    if (!t.hasModel())
      return;
    const n = t.getModel(), s = [], o = n.getOptions(), a = t.getOption(
      23
      /* EditorOption.comments */
    ), l = t.getSelections().map((c, h) => ({ selection: c, index: h, ignoreFirstLine: !1 }));
    l.sort((c, h) => L.compareRangesUsingStarts(c.selection, h.selection));
    let d = l[0];
    for (let c = 1; c < l.length; c++) {
      const h = l[c];
      d.selection.endLineNumber === h.selection.startLineNumber && (d.index < h.index ? h.ignoreFirstLine = !0 : (d.ignoreFirstLine = !0, d = h));
    }
    for (const c of l)
      s.push(new Il(i, c.selection, o.indentSize, this._type, a.insertSpace, a.ignoreEmptyLines, c.ignoreFirstLine));
    t.pushUndoStop(), t.executeCommands(this.id, s), t.pushUndoStop();
  }
}
class Aue extends vR {
  constructor() {
    super(0, {
      id: "editor.action.commentLine",
      label: p("comment.line", "Toggle Line Comment"),
      alias: "Toggle Line Comment",
      precondition: x.writable,
      kbOpts: {
        kbExpr: x.editorTextFocus,
        primary: 2138,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: D.MenubarEditMenu,
        group: "5_insert",
        title: p({ key: "miToggleLineComment", comment: ["&& denotes a mnemonic"] }, "&&Toggle Line Comment"),
        order: 1
      }
    });
  }
}
class Pue extends vR {
  constructor() {
    super(1, {
      id: "editor.action.addCommentLine",
      label: p("comment.line.add", "Add Line Comment"),
      alias: "Add Line Comment",
      precondition: x.writable,
      kbOpts: {
        kbExpr: x.editorTextFocus,
        primary: zi(
          2089,
          2081
          /* KeyCode.KeyC */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
}
class Oue extends vR {
  constructor() {
    super(2, {
      id: "editor.action.removeCommentLine",
      label: p("comment.line.remove", "Remove Line Comment"),
      alias: "Remove Line Comment",
      precondition: x.writable,
      kbOpts: {
        kbExpr: x.editorTextFocus,
        primary: zi(
          2089,
          2099
          /* KeyCode.KeyU */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
}
class Fue extends ae {
  constructor() {
    super({
      id: "editor.action.blockComment",
      label: p("comment.block", "Toggle Block Comment"),
      alias: "Toggle Block Comment",
      precondition: x.writable,
      kbOpts: {
        kbExpr: x.editorTextFocus,
        primary: 1567,
        linux: {
          primary: 3103
          /* KeyCode.KeyA */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: D.MenubarEditMenu,
        group: "5_insert",
        title: p({ key: "miToggleBlockComment", comment: ["&& denotes a mnemonic"] }, "Toggle &&Block Comment"),
        order: 2
      }
    });
  }
  run(e, t) {
    const i = e.get(Ot);
    if (!t.hasModel())
      return;
    const n = t.getOption(
      23
      /* EditorOption.comments */
    ), s = [], o = t.getSelections();
    for (const a of o)
      s.push(new hc(a, n.insertSpace, i));
    t.pushUndoStop(), t.executeCommands(this.id, s), t.pushUndoStop();
  }
}
Y(Aue);
Y(Pue);
Y(Oue);
Y(Fue);
var Wue = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, kh = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, ET;
let mp = ET = class {
  static get(e) {
    return e.getContribution(ET.ID);
  }
  constructor(e, t, i, n, s, o, a, l) {
    this._contextMenuService = t, this._contextViewService = i, this._contextKeyService = n, this._keybindingService = s, this._menuService = o, this._configurationService = a, this._workspaceContextService = l, this._toDispose = new q(), this._contextMenuIsBeingShownCount = 0, this._editor = e, this._toDispose.add(this._editor.onContextMenu((d) => this._onContextMenu(d))), this._toDispose.add(this._editor.onMouseWheel((d) => {
      if (this._contextMenuIsBeingShownCount > 0) {
        const c = this._contextViewService.getContextViewElement(), h = d.srcElement;
        h.shadowRoot && Cu(c) === h.shadowRoot || this._contextViewService.hideContextView();
      }
    })), this._toDispose.add(this._editor.onKeyDown((d) => {
      this._editor.getOption(
        24
        /* EditorOption.contextmenu */
      ) && d.keyCode === 58 && (d.preventDefault(), d.stopPropagation(), this.showContextMenu());
    }));
  }
  _onContextMenu(e) {
    if (!this._editor.hasModel())
      return;
    if (!this._editor.getOption(
      24
      /* EditorOption.contextmenu */
    )) {
      this._editor.focus(), e.target.position && !this._editor.getSelection().containsPosition(e.target.position) && this._editor.setPosition(e.target.position);
      return;
    }
    if (e.target.type === 12 || e.target.type === 6 && e.target.detail.injectedText)
      return;
    if (e.event.preventDefault(), e.event.stopPropagation(), e.target.type === 11)
      return this._showScrollbarContextMenu(e.event);
    if (e.target.type !== 6 && e.target.type !== 7 && e.target.type !== 1)
      return;
    if (this._editor.focus(), e.target.position) {
      let i = !1;
      for (const n of this._editor.getSelections())
        if (n.containsPosition(e.target.position)) {
          i = !0;
          break;
        }
      i || this._editor.setPosition(e.target.position);
    }
    let t = null;
    e.target.type !== 1 && (t = e.event), this.showContextMenu(t);
  }
  showContextMenu(e) {
    if (!this._editor.getOption(
      24
      /* EditorOption.contextmenu */
    ) || !this._editor.hasModel())
      return;
    const t = this._getMenuActions(this._editor.getModel(), this._editor.contextMenuId);
    t.length > 0 && this._doShowContextMenu(t, e);
  }
  _getMenuActions(e, t) {
    const i = [], n = this._menuService.createMenu(t, this._contextKeyService), s = n.getActions({ arg: e.uri });
    n.dispose();
    for (const o of s) {
      const [, a] = o;
      let l = 0;
      for (const d of a)
        if (d instanceof gf) {
          const c = this._getMenuActions(e, d.item.submenu);
          c.length > 0 && (i.push(new Bf(d.id, d.label, c)), l++);
        } else
          i.push(d), l++;
      l && i.push(new Oi());
    }
    return i.length && i.pop(), i;
  }
  _doShowContextMenu(e, t = null) {
    if (!this._editor.hasModel())
      return;
    const i = this._editor.getOption(
      60
      /* EditorOption.hover */
    );
    this._editor.updateOptions({
      hover: {
        enabled: !1
      }
    });
    let n = t;
    if (!n) {
      this._editor.revealPosition(
        this._editor.getPosition(),
        1
        /* ScrollType.Immediate */
      ), this._editor.render();
      const o = this._editor.getScrolledVisiblePosition(this._editor.getPosition()), a = Ei(this._editor.getDomNode()), l = a.left + o.left, d = a.top + o.top + o.height;
      n = { x: l, y: d };
    }
    const s = this._editor.getOption(
      127
      /* EditorOption.useShadowDOM */
    ) && !Zr;
    this._contextMenuIsBeingShownCount++, this._contextMenuService.showContextMenu({
      domForShadowRoot: s ? this._editor.getDomNode() : void 0,
      getAnchor: () => n,
      getActions: () => e,
      getActionViewItem: (o) => {
        const a = this._keybindingFor(o);
        if (a)
          return new sp(o, o, { label: !0, keybinding: a.getLabel(), isMenu: !0 });
        const l = o;
        return typeof l.getActionViewItem == "function" ? l.getActionViewItem() : new sp(o, o, { icon: !0, label: !0, isMenu: !0 });
      },
      getKeyBinding: (o) => this._keybindingFor(o),
      onHide: (o) => {
        this._contextMenuIsBeingShownCount--, this._editor.updateOptions({
          hover: i
        });
      }
    });
  }
  _showScrollbarContextMenu(e) {
    if (!this._editor.hasModel() || Ate(this._workspaceContextService.getWorkspace()))
      return;
    const t = this._editor.getOption(
      73
      /* EditorOption.minimap */
    );
    let i = 0;
    const n = (d) => ({
      id: `menu-action-${++i}`,
      label: d.label,
      tooltip: "",
      class: void 0,
      enabled: typeof d.enabled > "u" ? !0 : d.enabled,
      checked: d.checked,
      run: d.run
    }), s = (d, c) => new Bf(`menu-action-${++i}`, d, c, void 0), o = (d, c, h, u, g) => {
      if (!c)
        return n({ label: d, enabled: c, run: () => {
        } });
      const f = (_) => () => {
        this._configurationService.updateValue(h, _);
      }, m = [];
      for (const _ of g)
        m.push(n({
          label: _.label,
          checked: u === _.value,
          run: f(_.value)
        }));
      return s(d, m);
    }, a = [];
    a.push(n({
      label: p("context.minimap.minimap", "Minimap"),
      checked: t.enabled,
      run: () => {
        this._configurationService.updateValue("editor.minimap.enabled", !t.enabled);
      }
    })), a.push(new Oi()), a.push(n({
      label: p("context.minimap.renderCharacters", "Render Characters"),
      enabled: t.enabled,
      checked: t.renderCharacters,
      run: () => {
        this._configurationService.updateValue("editor.minimap.renderCharacters", !t.renderCharacters);
      }
    })), a.push(o(p("context.minimap.size", "Vertical size"), t.enabled, "editor.minimap.size", t.size, [{
      label: p("context.minimap.size.proportional", "Proportional"),
      value: "proportional"
    }, {
      label: p("context.minimap.size.fill", "Fill"),
      value: "fill"
    }, {
      label: p("context.minimap.size.fit", "Fit"),
      value: "fit"
    }])), a.push(o(p("context.minimap.slider", "Slider"), t.enabled, "editor.minimap.showSlider", t.showSlider, [{
      label: p("context.minimap.slider.mouseover", "Mouse Over"),
      value: "mouseover"
    }, {
      label: p("context.minimap.slider.always", "Always"),
      value: "always"
    }]));
    const l = this._editor.getOption(
      127
      /* EditorOption.useShadowDOM */
    ) && !Zr;
    this._contextMenuIsBeingShownCount++, this._contextMenuService.showContextMenu({
      domForShadowRoot: l ? this._editor.getDomNode() : void 0,
      getAnchor: () => e,
      getActions: () => a,
      onHide: (d) => {
        this._contextMenuIsBeingShownCount--, this._editor.focus();
      }
    });
  }
  _keybindingFor(e) {
    return this._keybindingService.lookupKeybinding(e.id);
  }
  dispose() {
    this._contextMenuIsBeingShownCount > 0 && this._contextViewService.hideContextView(), this._toDispose.dispose();
  }
};
mp.ID = "editor.contrib.contextmenu";
mp = ET = Wue([
  kh(1, Zs),
  kh(2, Sd),
  kh(3, De),
  kh(4, _t),
  kh(5, vo),
  kh(6, Ge),
  kh(7, ku)
], mp);
class Bue extends ae {
  constructor() {
    super({
      id: "editor.action.showContextMenu",
      label: p("action.showContextMenu.label", "Show Editor Context Menu"),
      alias: "Show Editor Context Menu",
      precondition: void 0,
      kbOpts: {
        kbExpr: x.textInputFocus,
        primary: 1092,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(e, t) {
    var i;
    (i = mp.get(t)) === null || i === void 0 || i.showContextMenu();
  }
}
gt(
  mp.ID,
  mp,
  2
  /* EditorContributionInstantiation.BeforeFirstInteraction */
);
Y(Bue);
class Yk {
  constructor(e) {
    this.selections = e;
  }
  equals(e) {
    const t = this.selections.length, i = e.selections.length;
    if (t !== i)
      return !1;
    for (let n = 0; n < t; n++)
      if (!this.selections[n].equalsSelection(e.selections[n]))
        return !1;
    return !0;
  }
}
class Qk {
  constructor(e, t, i) {
    this.cursorState = e, this.scrollTop = t, this.scrollLeft = i;
  }
}
class Fu extends P {
  static get(e) {
    return e.getContribution(Fu.ID);
  }
  constructor(e) {
    super(), this._editor = e, this._isCursorUndoRedo = !1, this._undoStack = [], this._redoStack = [], this._register(e.onDidChangeModel((t) => {
      this._undoStack = [], this._redoStack = [];
    })), this._register(e.onDidChangeModelContent((t) => {
      this._undoStack = [], this._redoStack = [];
    })), this._register(e.onDidChangeCursorSelection((t) => {
      if (this._isCursorUndoRedo || !t.oldSelections || t.oldModelVersionId !== t.modelVersionId)
        return;
      const i = new Yk(t.oldSelections);
      this._undoStack.length > 0 && this._undoStack[this._undoStack.length - 1].cursorState.equals(i) || (this._undoStack.push(new Qk(i, e.getScrollTop(), e.getScrollLeft())), this._redoStack = [], this._undoStack.length > 50 && this._undoStack.shift());
    }));
  }
  cursorUndo() {
    !this._editor.hasModel() || this._undoStack.length === 0 || (this._redoStack.push(new Qk(new Yk(this._editor.getSelections()), this._editor.getScrollTop(), this._editor.getScrollLeft())), this._applyState(this._undoStack.pop()));
  }
  cursorRedo() {
    !this._editor.hasModel() || this._redoStack.length === 0 || (this._undoStack.push(new Qk(new Yk(this._editor.getSelections()), this._editor.getScrollTop(), this._editor.getScrollLeft())), this._applyState(this._redoStack.pop()));
  }
  _applyState(e) {
    this._isCursorUndoRedo = !0, this._editor.setSelections(e.cursorState.selections), this._editor.setScrollPosition({
      scrollTop: e.scrollTop,
      scrollLeft: e.scrollLeft
    }), this._isCursorUndoRedo = !1;
  }
}
Fu.ID = "editor.contrib.cursorUndoRedoController";
class Hue extends ae {
  constructor() {
    super({
      id: "cursorUndo",
      label: p("cursor.undo", "Cursor Undo"),
      alias: "Cursor Undo",
      precondition: void 0,
      kbOpts: {
        kbExpr: x.textInputFocus,
        primary: 2099,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(e, t, i) {
    var n;
    (n = Fu.get(t)) === null || n === void 0 || n.cursorUndo();
  }
}
class Vue extends ae {
  constructor() {
    super({
      id: "cursorRedo",
      label: p("cursor.redo", "Cursor Redo"),
      alias: "Cursor Redo",
      precondition: void 0
    });
  }
  run(e, t, i) {
    var n;
    (n = Fu.get(t)) === null || n === void 0 || n.cursorRedo();
  }
}
gt(
  Fu.ID,
  Fu,
  0
  /* EditorContributionInstantiation.Eager */
);
Y(Hue);
Y(Vue);
class zue {
  constructor(e, t, i) {
    this.selection = e, this.targetPosition = t, this.copy = i, this.targetSelection = null;
  }
  getEditOperations(e, t) {
    const i = e.getValueInRange(this.selection);
    if (this.copy || t.addEditOperation(this.selection, null), t.addEditOperation(new L(this.targetPosition.lineNumber, this.targetPosition.column, this.targetPosition.lineNumber, this.targetPosition.column), i), this.selection.containsPosition(this.targetPosition) && !(this.copy && (this.selection.getEndPosition().equals(this.targetPosition) || this.selection.getStartPosition().equals(this.targetPosition)))) {
      this.targetSelection = this.selection;
      return;
    }
    if (this.copy) {
      this.targetSelection = new ge(this.targetPosition.lineNumber, this.targetPosition.column, this.selection.endLineNumber - this.selection.startLineNumber + this.targetPosition.lineNumber, this.selection.startLineNumber === this.selection.endLineNumber ? this.targetPosition.column + this.selection.endColumn - this.selection.startColumn : this.selection.endColumn);
      return;
    }
    if (this.targetPosition.lineNumber > this.selection.endLineNumber) {
      this.targetSelection = new ge(this.targetPosition.lineNumber - this.selection.endLineNumber + this.selection.startLineNumber, this.targetPosition.column, this.targetPosition.lineNumber, this.selection.startLineNumber === this.selection.endLineNumber ? this.targetPosition.column + this.selection.endColumn - this.selection.startColumn : this.selection.endColumn);
      return;
    }
    if (this.targetPosition.lineNumber < this.selection.endLineNumber) {
      this.targetSelection = new ge(this.targetPosition.lineNumber, this.targetPosition.column, this.targetPosition.lineNumber + this.selection.endLineNumber - this.selection.startLineNumber, this.selection.startLineNumber === this.selection.endLineNumber ? this.targetPosition.column + this.selection.endColumn - this.selection.startColumn : this.selection.endColumn);
      return;
    }
    this.selection.endColumn <= this.targetPosition.column ? this.targetSelection = new ge(this.targetPosition.lineNumber - this.selection.endLineNumber + this.selection.startLineNumber, this.selection.startLineNumber === this.selection.endLineNumber ? this.targetPosition.column - this.selection.endColumn + this.selection.startColumn : this.targetPosition.column - this.selection.endColumn + this.selection.startColumn, this.targetPosition.lineNumber, this.selection.startLineNumber === this.selection.endLineNumber ? this.targetPosition.column : this.selection.endColumn) : this.targetSelection = new ge(this.targetPosition.lineNumber - this.selection.endLineNumber + this.selection.startLineNumber, this.targetPosition.column, this.targetPosition.lineNumber, this.targetPosition.column + this.selection.endColumn - this.selection.startColumn);
  }
  computeCursorState(e, t) {
    return this.targetSelection;
  }
}
function Lg(r) {
  return Je ? r.altKey : r.ctrlKey;
}
class nd extends P {
  constructor(e) {
    super(), this._editor = e, this._dndDecorationIds = this._editor.createDecorationsCollection(), this._register(this._editor.onMouseDown((t) => this._onEditorMouseDown(t))), this._register(this._editor.onMouseUp((t) => this._onEditorMouseUp(t))), this._register(this._editor.onMouseDrag((t) => this._onEditorMouseDrag(t))), this._register(this._editor.onMouseDrop((t) => this._onEditorMouseDrop(t))), this._register(this._editor.onMouseDropCanceled(() => this._onEditorMouseDropCanceled())), this._register(this._editor.onKeyDown((t) => this.onEditorKeyDown(t))), this._register(this._editor.onKeyUp((t) => this.onEditorKeyUp(t))), this._register(this._editor.onDidBlurEditorWidget(() => this.onEditorBlur())), this._register(this._editor.onDidBlurEditorText(() => this.onEditorBlur())), this._mouseDown = !1, this._modifierPressed = !1, this._dragSelection = null;
  }
  onEditorBlur() {
    this._removeDecoration(), this._dragSelection = null, this._mouseDown = !1, this._modifierPressed = !1;
  }
  onEditorKeyDown(e) {
    !this._editor.getOption(
      35
      /* EditorOption.dragAndDrop */
    ) || this._editor.getOption(
      22
      /* EditorOption.columnSelection */
    ) || (Lg(e) && (this._modifierPressed = !0), this._mouseDown && Lg(e) && this._editor.updateOptions({
      mouseStyle: "copy"
    }));
  }
  onEditorKeyUp(e) {
    !this._editor.getOption(
      35
      /* EditorOption.dragAndDrop */
    ) || this._editor.getOption(
      22
      /* EditorOption.columnSelection */
    ) || (Lg(e) && (this._modifierPressed = !1), this._mouseDown && e.keyCode === nd.TRIGGER_KEY_VALUE && this._editor.updateOptions({
      mouseStyle: "default"
    }));
  }
  _onEditorMouseDown(e) {
    this._mouseDown = !0;
  }
  _onEditorMouseUp(e) {
    this._mouseDown = !1, this._editor.updateOptions({
      mouseStyle: "text"
    });
  }
  _onEditorMouseDrag(e) {
    const t = e.target;
    if (this._dragSelection === null) {
      const n = (this._editor.getSelections() || []).filter((s) => t.position && s.containsPosition(t.position));
      if (n.length === 1)
        this._dragSelection = n[0];
      else
        return;
    }
    Lg(e.event) ? this._editor.updateOptions({
      mouseStyle: "copy"
    }) : this._editor.updateOptions({
      mouseStyle: "default"
    }), t.position && (this._dragSelection.containsPosition(t.position) ? this._removeDecoration() : this.showAt(t.position));
  }
  _onEditorMouseDropCanceled() {
    this._editor.updateOptions({
      mouseStyle: "text"
    }), this._removeDecoration(), this._dragSelection = null, this._mouseDown = !1;
  }
  _onEditorMouseDrop(e) {
    if (e.target && (this._hitContent(e.target) || this._hitMargin(e.target)) && e.target.position) {
      const t = new A(e.target.position.lineNumber, e.target.position.column);
      if (this._dragSelection === null) {
        let i = null;
        if (e.event.shiftKey) {
          const n = this._editor.getSelection();
          if (n) {
            const { selectionStartLineNumber: s, selectionStartColumn: o } = n;
            i = [new ge(s, o, t.lineNumber, t.column)];
          }
        } else
          i = (this._editor.getSelections() || []).map((n) => n.containsPosition(t) ? new ge(t.lineNumber, t.column, t.lineNumber, t.column) : n);
        this._editor.setSelections(
          i || [],
          "mouse",
          3
          /* CursorChangeReason.Explicit */
        );
      } else (!this._dragSelection.containsPosition(t) || (Lg(e.event) || this._modifierPressed) && (this._dragSelection.getEndPosition().equals(t) || this._dragSelection.getStartPosition().equals(t))) && (this._editor.pushUndoStop(), this._editor.executeCommand(nd.ID, new zue(this._dragSelection, t, Lg(e.event) || this._modifierPressed)), this._editor.pushUndoStop());
    }
    this._editor.updateOptions({
      mouseStyle: "text"
    }), this._removeDecoration(), this._dragSelection = null, this._mouseDown = !1;
  }
  showAt(e) {
    this._dndDecorationIds.set([{
      range: new L(e.lineNumber, e.column, e.lineNumber, e.column),
      options: nd._DECORATION_OPTIONS
    }]), this._editor.revealPosition(
      e,
      1
      /* ScrollType.Immediate */
    );
  }
  _removeDecoration() {
    this._dndDecorationIds.clear();
  }
  _hitContent(e) {
    return e.type === 6 || e.type === 7;
  }
  _hitMargin(e) {
    return e.type === 2 || e.type === 3 || e.type === 4;
  }
  dispose() {
    this._removeDecoration(), this._dragSelection = null, this._mouseDown = !1, this._modifierPressed = !1, super.dispose();
  }
}
nd.ID = "editor.contrib.dragAndDrop";
nd.TRIGGER_KEY_VALUE = Je ? 6 : 5;
nd._DECORATION_OPTIONS = Fe.register({
  description: "dnd-target",
  className: "dnd-target"
});
gt(
  nd.ID,
  nd,
  2
  /* EditorContributionInstantiation.BeforeFirstInteraction */
);
var ew;
gt(
  ll.ID,
  ll,
  0
  /* EditorContributionInstantiation.Eager */
);
Rb(iT);
se(new class extends Ui {
  constructor() {
    super({
      id: EU,
      precondition: oR,
      kbOpts: {
        weight: 100,
        primary: 2137
      }
    });
  }
  runEditorCommand(r, e) {
    var t;
    return (t = ll.get(e)) === null || t === void 0 ? void 0 : t.changePasteType();
  }
}());
se(new class extends Ui {
  constructor() {
    super({
      id: "editor.hidePasteWidget",
      precondition: oR,
      kbOpts: {
        weight: 100,
        primary: 9
      }
    });
  }
  runEditorCommand(r, e) {
    var t;
    (t = ll.get(e)) === null || t === void 0 || t.clearWidgets();
  }
}());
Y((ew = class extends ae {
  constructor() {
    super({
      id: "editor.action.pasteAs",
      label: p("pasteAs", "Paste As..."),
      alias: "Paste As...",
      precondition: x.writable,
      metadata: {
        description: "Paste as",
        args: [{
          name: "args",
          schema: ew.argsSchema
        }]
      }
    });
  }
  run(e, t, i) {
    var n;
    let s = typeof (i == null ? void 0 : i.kind) == "string" ? i.kind : void 0;
    return !s && i && (s = typeof i.id == "string" ? i.id : void 0), (n = ll.get(t)) === null || n === void 0 ? void 0 : n.pasteAs(s ? new kt(s) : void 0);
  }
}, ew.argsSchema = {
  type: "object",
  properties: {
    kind: {
      type: "string",
      description: p("pasteAs.kind", "The kind of the paste edit to try applying. If not provided or there are multiple edits for this kind, the editor will show a picker.")
    }
  }
}, ew));
Y(class extends ae {
  constructor() {
    super({
      id: "editor.action.pasteAsText",
      label: p("pasteAsText", "Paste as Text"),
      alias: "Paste as Text",
      precondition: x.writable
    });
  }
  run(r, e) {
    var t;
    return (t = ll.get(e)) === null || t === void 0 ? void 0 : t.pasteAs({ providerId: fd.id });
  }
});
class Uue {
  constructor() {
    this._dragOperations = /* @__PURE__ */ new Map();
  }
  removeDragOperationTransfer(e) {
    if (e && this._dragOperations.has(e)) {
      const t = this._dragOperations.get(e);
      return this._dragOperations.delete(e), t;
    }
  }
}
class RW {
  constructor(e) {
    this.identifier = e;
  }
}
const x4 = et("treeViewsDndService");
ot(
  x4,
  Uue,
  1
  /* InstantiationType.Delayed */
);
var $ue = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, tw = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, TT;
const I4 = "editor.experimental.dropIntoEditor.defaultProvider", E4 = "editor.changeDropType", bR = new oe("dropWidgetVisible", !1, p("dropWidgetVisible", "Whether the drop widget is showing"));
let Wu = TT = class extends P {
  static get(e) {
    return e.getContribution(TT.ID);
  }
  constructor(e, t, i, n, s) {
    super(), this._configService = i, this._languageFeaturesService = n, this._treeViewsDragAndDropService = s, this.treeItemsTransfer = xv.getInstance(), this._dropProgressManager = this._register(t.createInstance(Iy, "dropIntoEditor", e)), this._postDropWidgetManager = this._register(t.createInstance(Ny, "dropIntoEditor", e, bR, { id: E4, label: p("postDropWidgetTitle", "Show drop options...") })), this._register(e.onDropIntoEditor((o) => this.onDropIntoEditor(e, o.position, o.event)));
  }
  clearWidgets() {
    this._postDropWidgetManager.clear();
  }
  changeDropType() {
    this._postDropWidgetManager.tryShowSelector();
  }
  async onDropIntoEditor(e, t, i) {
    var n;
    if (!i.dataTransfer || !e.hasModel())
      return;
    (n = this._currentOperation) === null || n === void 0 || n.cancel(), e.focus(), e.setPosition(t);
    const s = Zi(async (o) => {
      const a = new zc(e, 1, void 0, o);
      try {
        const l = await this.extractDataTransferData(i);
        if (l.size === 0 || a.token.isCancellationRequested)
          return;
        const d = e.getModel();
        if (!d)
          return;
        const c = this._languageFeaturesService.documentDropEditProvider.ordered(d).filter((u) => u.dropMimeTypes ? u.dropMimeTypes.some((g) => l.matches(g)) : !0), h = await this.getDropEdits(c, d, t, l, a);
        if (a.token.isCancellationRequested)
          return;
        if (h.length) {
          const u = this.getInitialActiveEditIndex(d, h), g = e.getOption(
            36
            /* EditorOption.dropIntoEditor */
          ).showDropSelector === "afterDrop";
          await this._postDropWidgetManager.applyEditAndShowIfNeeded([L.fromPositions(t)], { activeEditIndex: u, allEdits: h }, g, async (f) => f, o);
        }
      } finally {
        a.dispose(), this._currentOperation === s && (this._currentOperation = void 0);
      }
    });
    this._dropProgressManager.showWhile(t, p("dropIntoEditorProgress", "Running drop handlers. Click to cancel"), s), this._currentOperation = s;
  }
  async getDropEdits(e, t, i, n, s) {
    const o = await rb(Promise.all(e.map(async (l) => {
      try {
        const d = await l.provideDocumentDropEdits(t, i, n, s.token);
        return d == null ? void 0 : d.map((c) => ({ ...c, providerId: l.id }));
      } catch (d) {
        console.error(d);
      }
    })), s.token), a = Yr(o ?? []).flat();
    return xU(a);
  }
  getInitialActiveEditIndex(e, t) {
    const i = this._configService.getValue(I4, { resource: e.uri });
    for (const [n, s] of Object.entries(i)) {
      const o = new kt(s), a = t.findIndex((l) => o.value === l.providerId && l.handledMimeType && bU(n, [l.handledMimeType]));
      if (a >= 0)
        return a;
    }
    return 0;
  }
  async extractDataTransferData(e) {
    if (!e.dataTransfer)
      return new vU();
    const t = SU(e.dataTransfer);
    if (this.treeItemsTransfer.hasData(RW.prototype)) {
      const i = this.treeItemsTransfer.getData(RW.prototype);
      if (Array.isArray(i))
        for (const n of i) {
          const s = await this._treeViewsDragAndDropService.removeDragOperationTransfer(n.identifier);
          if (s)
            for (const [o, a] of s)
              t.replace(o, a);
        }
    }
    return t;
  }
};
Wu.ID = "editor.contrib.dropIntoEditorController";
Wu = TT = $ue([
  tw(1, be),
  tw(2, Ge),
  tw(3, he),
  tw(4, x4)
], Wu);
gt(
  Wu.ID,
  Wu,
  2
  /* EditorContributionInstantiation.BeforeFirstInteraction */
);
Rb(tT);
se(new class extends Ui {
  constructor() {
    super({
      id: E4,
      precondition: bR,
      kbOpts: {
        weight: 100,
        primary: 2137
      }
    });
  }
  runEditorCommand(r, e, t) {
    var i;
    (i = Wu.get(e)) === null || i === void 0 || i.changeDropType();
  }
}());
se(new class extends Ui {
  constructor() {
    super({
      id: "editor.hideDropWidget",
      precondition: bR,
      kbOpts: {
        weight: 100,
        primary: 9
      }
    });
  }
  runEditorCommand(r, e, t) {
    var i;
    (i = Wu.get(e)) === null || i === void 0 || i.clearWidgets();
  }
}());
si.as(aa.Configuration).registerConfiguration({
  ...U0,
  properties: {
    [I4]: {
      type: "object",
      scope: 5,
      description: p("defaultProviderDescription", "Configures the default drop provider to use for content of a given mime type."),
      default: {},
      additionalProperties: {
        type: "string"
      }
    }
  }
});
class Vn {
  constructor(e) {
    this._editor = e, this._decorations = [], this._overviewRulerApproximateDecorations = [], this._findScopeDecorationIds = [], this._rangeHighlightDecorationId = null, this._highlightedDecorationId = null, this._startPosition = this._editor.getPosition();
  }
  dispose() {
    this._editor.removeDecorations(this._allDecorations()), this._decorations = [], this._overviewRulerApproximateDecorations = [], this._findScopeDecorationIds = [], this._rangeHighlightDecorationId = null, this._highlightedDecorationId = null;
  }
  reset() {
    this._decorations = [], this._overviewRulerApproximateDecorations = [], this._findScopeDecorationIds = [], this._rangeHighlightDecorationId = null, this._highlightedDecorationId = null;
  }
  getCount() {
    return this._decorations.length;
  }
  /** @deprecated use getFindScopes to support multiple selections */
  getFindScope() {
    return this._findScopeDecorationIds[0] ? this._editor.getModel().getDecorationRange(this._findScopeDecorationIds[0]) : null;
  }
  getFindScopes() {
    if (this._findScopeDecorationIds.length) {
      const e = this._findScopeDecorationIds.map((t) => this._editor.getModel().getDecorationRange(t)).filter((t) => !!t);
      if (e.length)
        return e;
    }
    return null;
  }
  getStartPosition() {
    return this._startPosition;
  }
  setStartPosition(e) {
    this._startPosition = e, this.setCurrentFindMatch(null);
  }
  _getDecorationIndex(e) {
    const t = this._decorations.indexOf(e);
    return t >= 0 ? t + 1 : 1;
  }
  getDecorationRangeAt(e) {
    const t = e < this._decorations.length ? this._decorations[e] : null;
    return t ? this._editor.getModel().getDecorationRange(t) : null;
  }
  getCurrentMatchesPosition(e) {
    const t = this._editor.getModel().getDecorationsInRange(e);
    for (const i of t) {
      const n = i.options;
      if (n === Vn._FIND_MATCH_DECORATION || n === Vn._CURRENT_FIND_MATCH_DECORATION)
        return this._getDecorationIndex(i.id);
    }
    return 0;
  }
  setCurrentFindMatch(e) {
    let t = null, i = 0;
    if (e)
      for (let n = 0, s = this._decorations.length; n < s; n++) {
        const o = this._editor.getModel().getDecorationRange(this._decorations[n]);
        if (e.equalsRange(o)) {
          t = this._decorations[n], i = n + 1;
          break;
        }
      }
    return (this._highlightedDecorationId !== null || t !== null) && this._editor.changeDecorations((n) => {
      if (this._highlightedDecorationId !== null && (n.changeDecorationOptions(this._highlightedDecorationId, Vn._FIND_MATCH_DECORATION), this._highlightedDecorationId = null), t !== null && (this._highlightedDecorationId = t, n.changeDecorationOptions(this._highlightedDecorationId, Vn._CURRENT_FIND_MATCH_DECORATION)), this._rangeHighlightDecorationId !== null && (n.removeDecoration(this._rangeHighlightDecorationId), this._rangeHighlightDecorationId = null), t !== null) {
        let s = this._editor.getModel().getDecorationRange(t);
        if (s.startLineNumber !== s.endLineNumber && s.endColumn === 1) {
          const o = s.endLineNumber - 1, a = this._editor.getModel().getLineMaxColumn(o);
          s = new L(s.startLineNumber, s.startColumn, o, a);
        }
        this._rangeHighlightDecorationId = n.addDecoration(s, Vn._RANGE_HIGHLIGHT_DECORATION);
      }
    }), i;
  }
  set(e, t) {
    this._editor.changeDecorations((i) => {
      let n = Vn._FIND_MATCH_DECORATION;
      const s = [];
      if (e.length > 1e3) {
        n = Vn._FIND_MATCH_NO_OVERVIEW_DECORATION;
        const a = this._editor.getModel().getLineCount(), d = this._editor.getLayoutInfo().height / a, c = Math.max(2, Math.ceil(3 / d));
        let h = e[0].range.startLineNumber, u = e[0].range.endLineNumber;
        for (let g = 1, f = e.length; g < f; g++) {
          const m = e[g].range;
          u + c >= m.startLineNumber ? m.endLineNumber > u && (u = m.endLineNumber) : (s.push({
            range: new L(h, 1, u, 1),
            options: Vn._FIND_MATCH_ONLY_OVERVIEW_DECORATION
          }), h = m.startLineNumber, u = m.endLineNumber);
        }
        s.push({
          range: new L(h, 1, u, 1),
          options: Vn._FIND_MATCH_ONLY_OVERVIEW_DECORATION
        });
      }
      const o = new Array(e.length);
      for (let a = 0, l = e.length; a < l; a++)
        o[a] = {
          range: e[a].range,
          options: n
        };
      this._decorations = i.deltaDecorations(this._decorations, o), this._overviewRulerApproximateDecorations = i.deltaDecorations(this._overviewRulerApproximateDecorations, s), this._rangeHighlightDecorationId && (i.removeDecoration(this._rangeHighlightDecorationId), this._rangeHighlightDecorationId = null), this._findScopeDecorationIds.length && (this._findScopeDecorationIds.forEach((a) => i.removeDecoration(a)), this._findScopeDecorationIds = []), t != null && t.length && (this._findScopeDecorationIds = t.map((a) => i.addDecoration(a, Vn._FIND_SCOPE_DECORATION)));
    });
  }
  matchBeforePosition(e) {
    if (this._decorations.length === 0)
      return null;
    for (let t = this._decorations.length - 1; t >= 0; t--) {
      const i = this._decorations[t], n = this._editor.getModel().getDecorationRange(i);
      if (!(!n || n.endLineNumber > e.lineNumber)) {
        if (n.endLineNumber < e.lineNumber)
          return n;
        if (!(n.endColumn > e.column))
          return n;
      }
    }
    return this._editor.getModel().getDecorationRange(this._decorations[this._decorations.length - 1]);
  }
  matchAfterPosition(e) {
    if (this._decorations.length === 0)
      return null;
    for (let t = 0, i = this._decorations.length; t < i; t++) {
      const n = this._decorations[t], s = this._editor.getModel().getDecorationRange(n);
      if (!(!s || s.startLineNumber < e.lineNumber)) {
        if (s.startLineNumber > e.lineNumber)
          return s;
        if (!(s.startColumn < e.column))
          return s;
      }
    }
    return this._editor.getModel().getDecorationRange(this._decorations[0]);
  }
  _allDecorations() {
    let e = [];
    return e = e.concat(this._decorations), e = e.concat(this._overviewRulerApproximateDecorations), this._findScopeDecorationIds.length && e.push(...this._findScopeDecorationIds), this._rangeHighlightDecorationId && e.push(this._rangeHighlightDecorationId), e;
  }
}
Vn._CURRENT_FIND_MATCH_DECORATION = Fe.register({
  description: "current-find-match",
  stickiness: 1,
  zIndex: 13,
  className: "currentFindMatch",
  inlineClassName: "currentFindMatchInline",
  showIfCollapsed: !0,
  overviewRuler: {
    color: ai(C1),
    position: _r.Center
  },
  minimap: {
    color: ai(qg),
    position: 1
    /* MinimapPosition.Inline */
  }
});
Vn._FIND_MATCH_DECORATION = Fe.register({
  description: "find-match",
  stickiness: 1,
  zIndex: 10,
  className: "findMatch",
  inlineClassName: "findMatchInline",
  showIfCollapsed: !0,
  overviewRuler: {
    color: ai(C1),
    position: _r.Center
  },
  minimap: {
    color: ai(qg),
    position: 1
    /* MinimapPosition.Inline */
  }
});
Vn._FIND_MATCH_NO_OVERVIEW_DECORATION = Fe.register({
  description: "find-match-no-overview",
  stickiness: 1,
  className: "findMatch",
  showIfCollapsed: !0
});
Vn._FIND_MATCH_ONLY_OVERVIEW_DECORATION = Fe.register({
  description: "find-match-only-overview",
  stickiness: 1,
  overviewRuler: {
    color: ai(C1),
    position: _r.Center
  }
});
Vn._RANGE_HIGHLIGHT_DECORATION = Fe.register({
  description: "find-range-highlight",
  stickiness: 1,
  className: "rangeHighlight",
  isWholeLine: !0
});
Vn._FIND_SCOPE_DECORATION = Fe.register({
  description: "find-scope",
  className: "findScope",
  isWholeLine: !0
});
class Kue {
  constructor(e, t, i) {
    this._editorSelection = e, this._ranges = t, this._replaceStrings = i, this._trackedEditorSelectionId = null;
  }
  getEditOperations(e, t) {
    if (this._ranges.length > 0) {
      const i = [];
      for (let o = 0; o < this._ranges.length; o++)
        i.push({
          range: this._ranges[o],
          text: this._replaceStrings[o]
        });
      i.sort((o, a) => L.compareRangesUsingStarts(o.range, a.range));
      const n = [];
      let s = i[0];
      for (let o = 1; o < i.length; o++)
        s.range.endLineNumber === i[o].range.startLineNumber && s.range.endColumn === i[o].range.startColumn ? (s.range = s.range.plusRange(i[o].range), s.text = s.text + i[o].text) : (n.push(s), s = i[o]);
      n.push(s);
      for (const o of n)
        t.addEditOperation(o.range, o.text);
    }
    this._trackedEditorSelectionId = t.trackSelection(this._editorSelection);
  }
  computeCursorState(e, t) {
    return t.getTrackedSelection(this._trackedEditorSelectionId);
  }
}
function T4(r, e) {
  if (r && r[0] !== "") {
    const t = AW(r, e, "-"), i = AW(r, e, "_");
    return t && !i ? PW(r, e, "-") : !t && i ? PW(r, e, "_") : r[0].toUpperCase() === r[0] ? e.toUpperCase() : r[0].toLowerCase() === r[0] ? e.toLowerCase() : jK(r[0][0]) && e.length > 0 ? e[0].toUpperCase() + e.substr(1) : r[0][0].toUpperCase() !== r[0][0] && e.length > 0 ? e[0].toLowerCase() + e.substr(1) : e;
  } else
    return e;
}
function AW(r, e, t) {
  return r[0].indexOf(t) !== -1 && e.indexOf(t) !== -1 && r[0].split(t).length === e.split(t).length;
}
function PW(r, e, t) {
  const i = e.split(t), n = r[0].split(t);
  let s = "";
  return i.forEach((o, a) => {
    s += T4([n[a]], o) + t;
  }), s.slice(0, -1);
}
class OW {
  constructor(e) {
    this.staticValue = e, this.kind = 0;
  }
}
class jue {
  constructor(e) {
    this.pieces = e, this.kind = 1;
  }
}
class _p {
  static fromStaticValue(e) {
    return new _p([pu.staticValue(e)]);
  }
  get hasReplacementPatterns() {
    return this._state.kind === 1;
  }
  constructor(e) {
    !e || e.length === 0 ? this._state = new OW("") : e.length === 1 && e[0].staticValue !== null ? this._state = new OW(e[0].staticValue) : this._state = new jue(e);
  }
  buildReplaceString(e, t) {
    if (this._state.kind === 0)
      return t ? T4(e, this._state.staticValue) : this._state.staticValue;
    let i = "";
    for (let n = 0, s = this._state.pieces.length; n < s; n++) {
      const o = this._state.pieces[n];
      if (o.staticValue !== null) {
        i += o.staticValue;
        continue;
      }
      let a = _p._substitute(o.matchIndex, e);
      if (o.caseOps !== null && o.caseOps.length > 0) {
        const l = [], d = o.caseOps.length;
        let c = 0;
        for (let h = 0, u = a.length; h < u; h++) {
          if (c >= d) {
            l.push(a.slice(h));
            break;
          }
          switch (o.caseOps[c]) {
            case "U":
              l.push(a[h].toUpperCase());
              break;
            case "u":
              l.push(a[h].toUpperCase()), c++;
              break;
            case "L":
              l.push(a[h].toLowerCase());
              break;
            case "l":
              l.push(a[h].toLowerCase()), c++;
              break;
            default:
              l.push(a[h]);
          }
        }
        a = l.join("");
      }
      i += a;
    }
    return i;
  }
  static _substitute(e, t) {
    if (t === null)
      return "";
    if (e === 0)
      return t[0];
    let i = "";
    for (; e > 0; ) {
      if (e < t.length)
        return (t[e] || "") + i;
      i = String(e % 10) + i, e = Math.floor(e / 10);
    }
    return "$" + i;
  }
}
class pu {
  static staticValue(e) {
    return new pu(e, -1, null);
  }
  static caseOps(e, t) {
    return new pu(null, e, t);
  }
  constructor(e, t, i) {
    this.staticValue = e, this.matchIndex = t, !i || i.length === 0 ? this.caseOps = null : this.caseOps = i.slice(0);
  }
}
class que {
  constructor(e) {
    this._source = e, this._lastCharIndex = 0, this._result = [], this._resultLen = 0, this._currentStaticPiece = "";
  }
  emitUnchanged(e) {
    this._emitStatic(this._source.substring(this._lastCharIndex, e)), this._lastCharIndex = e;
  }
  emitStatic(e, t) {
    this._emitStatic(e), this._lastCharIndex = t;
  }
  _emitStatic(e) {
    e.length !== 0 && (this._currentStaticPiece += e);
  }
  emitMatchIndex(e, t, i) {
    this._currentStaticPiece.length !== 0 && (this._result[this._resultLen++] = pu.staticValue(this._currentStaticPiece), this._currentStaticPiece = ""), this._result[this._resultLen++] = pu.caseOps(e, i), this._lastCharIndex = t;
  }
  finalize() {
    return this.emitUnchanged(this._source.length), this._currentStaticPiece.length !== 0 && (this._result[this._resultLen++] = pu.staticValue(this._currentStaticPiece), this._currentStaticPiece = ""), new _p(this._result);
  }
}
function Gue(r) {
  if (!r || r.length === 0)
    return new _p(null);
  const e = [], t = new que(r);
  for (let i = 0, n = r.length; i < n; i++) {
    const s = r.charCodeAt(i);
    if (s === 92) {
      if (i++, i >= n)
        break;
      const o = r.charCodeAt(i);
      switch (o) {
        case 92:
          t.emitUnchanged(i - 1), t.emitStatic("\\", i + 1);
          break;
        case 110:
          t.emitUnchanged(i - 1), t.emitStatic(`
`, i + 1);
          break;
        case 116:
          t.emitUnchanged(i - 1), t.emitStatic("	", i + 1);
          break;
        case 117:
        case 85:
        case 108:
        case 76:
          t.emitUnchanged(i - 1), t.emitStatic("", i + 1), e.push(String.fromCharCode(o));
          break;
      }
      continue;
    }
    if (s === 36) {
      if (i++, i >= n)
        break;
      const o = r.charCodeAt(i);
      if (o === 36) {
        t.emitUnchanged(i - 1), t.emitStatic("$", i + 1);
        continue;
      }
      if (o === 48 || o === 38) {
        t.emitUnchanged(i - 1), t.emitMatchIndex(0, i + 1, e), e.length = 0;
        continue;
      }
      if (49 <= o && o <= 57) {
        let a = o - 48;
        if (i + 1 < n) {
          const l = r.charCodeAt(i + 1);
          if (48 <= l && l <= 57) {
            i++, a = a * 10 + (l - 48), t.emitUnchanged(i - 2), t.emitMatchIndex(a, i + 1, e), e.length = 0;
            continue;
          }
        }
        t.emitUnchanged(i - 1), t.emitMatchIndex(a, i + 1, e), e.length = 0;
        continue;
      }
    }
  }
  return t.finalize();
}
const xd = new oe("findWidgetVisible", !1);
xd.toNegated();
const PL = new oe("findInputFocussed", !1), CR = new oe("replaceInputFocussed", !1), iw = {
  primary: 545,
  mac: {
    primary: 2593
    /* KeyCode.KeyC */
  }
}, nw = {
  primary: 565,
  mac: {
    primary: 2613
    /* KeyCode.KeyW */
  }
}, sw = {
  primary: 560,
  mac: {
    primary: 2608
    /* KeyCode.KeyR */
  }
}, ow = {
  primary: 554,
  mac: {
    primary: 2602
    /* KeyCode.KeyL */
  }
}, rw = {
  primary: 558,
  mac: {
    primary: 2606
    /* KeyCode.KeyP */
  }
}, Ht = {
  StartFindAction: "actions.find",
  StartFindWithSelection: "actions.findWithSelection",
  StartFindWithArgs: "editor.actions.findWithArgs",
  NextMatchFindAction: "editor.action.nextMatchFindAction",
  PreviousMatchFindAction: "editor.action.previousMatchFindAction",
  GoToMatchFindAction: "editor.action.goToMatchFindAction",
  NextSelectionMatchFindAction: "editor.action.nextSelectionMatchFindAction",
  PreviousSelectionMatchFindAction: "editor.action.previousSelectionMatchFindAction",
  StartFindReplaceAction: "editor.action.startFindReplaceAction",
  CloseFindWidgetCommand: "closeFindWidget",
  ToggleCaseSensitiveCommand: "toggleFindCaseSensitive",
  ToggleWholeWordCommand: "toggleFindWholeWord",
  ToggleRegexCommand: "toggleFindRegex",
  ToggleSearchScopeCommand: "toggleFindInSelection",
  TogglePreserveCaseCommand: "togglePreserveCase",
  ReplaceOneAction: "editor.action.replaceOne",
  ReplaceAllAction: "editor.action.replaceAll",
  SelectAllMatchesAction: "editor.action.selectAllMatches"
}, uc = 19999, Zue = 240;
class y_ {
  constructor(e, t) {
    this._toDispose = new q(), this._editor = e, this._state = t, this._isDisposed = !1, this._startSearchingTimer = new vr(), this._decorations = new Vn(e), this._toDispose.add(this._decorations), this._updateDecorationsScheduler = new xt(() => this.research(!1), 100), this._toDispose.add(this._updateDecorationsScheduler), this._toDispose.add(this._editor.onDidChangeCursorPosition((i) => {
      (i.reason === 3 || i.reason === 5 || i.reason === 6) && this._decorations.setStartPosition(this._editor.getPosition());
    })), this._ignoreModelContentChanged = !1, this._toDispose.add(this._editor.onDidChangeModelContent((i) => {
      this._ignoreModelContentChanged || (i.isFlush && this._decorations.reset(), this._decorations.setStartPosition(this._editor.getPosition()), this._updateDecorationsScheduler.schedule());
    })), this._toDispose.add(this._state.onFindReplaceStateChange((i) => this._onStateChanged(i))), this.research(!1, this._state.searchScope);
  }
  dispose() {
    this._isDisposed = !0, zt(this._startSearchingTimer), this._toDispose.dispose();
  }
  _onStateChanged(e) {
    this._isDisposed || this._editor.hasModel() && (e.searchString || e.isReplaceRevealed || e.isRegex || e.wholeWord || e.matchCase || e.searchScope) && (this._editor.getModel().isTooLargeForSyncing() ? (this._startSearchingTimer.cancel(), this._startSearchingTimer.setIfNotSet(() => {
      e.searchScope ? this.research(e.moveCursor, this._state.searchScope) : this.research(e.moveCursor);
    }, Zue)) : e.searchScope ? this.research(e.moveCursor, this._state.searchScope) : this.research(e.moveCursor));
  }
  static _getSearchRange(e, t) {
    return t || e.getFullModelRange();
  }
  research(e, t) {
    let i = null;
    typeof t < "u" ? t !== null && (Array.isArray(t) ? i = t : i = [t]) : i = this._decorations.getFindScopes(), i !== null && (i = i.map((a) => {
      if (a.startLineNumber !== a.endLineNumber) {
        let l = a.endLineNumber;
        return a.endColumn === 1 && (l = l - 1), new L(a.startLineNumber, 1, l, this._editor.getModel().getLineMaxColumn(l));
      }
      return a;
    }));
    const n = this._findMatches(i, !1, uc);
    this._decorations.set(n, i);
    const s = this._editor.getSelection();
    let o = this._decorations.getCurrentMatchesPosition(s);
    if (o === 0 && n.length > 0) {
      const a = vH(n.map((l) => l.range), (l) => L.compareRangesUsingStarts(l, s) >= 0);
      o = a > 0 ? a - 1 + 1 : o;
    }
    this._state.changeMatchInfo(o, this._decorations.getCount(), void 0), e && this._editor.getOption(
      41
      /* EditorOption.find */
    ).cursorMoveOnType && this._moveToNextMatch(this._decorations.getStartPosition());
  }
  _hasMatches() {
    return this._state.matchesCount > 0;
  }
  _cannotFind() {
    if (!this._hasMatches()) {
      const e = this._decorations.getFindScope();
      return e && this._editor.revealRangeInCenterIfOutsideViewport(
        e,
        0
        /* ScrollType.Smooth */
      ), !0;
    }
    return !1;
  }
  _setCurrentFindMatch(e) {
    const t = this._decorations.setCurrentFindMatch(e);
    this._state.changeMatchInfo(t, this._decorations.getCount(), e), this._editor.setSelection(e), this._editor.revealRangeInCenterIfOutsideViewport(
      e,
      0
      /* ScrollType.Smooth */
    );
  }
  _prevSearchPosition(e) {
    const t = this._state.isRegex && (this._state.searchString.indexOf("^") >= 0 || this._state.searchString.indexOf("$") >= 0);
    let { lineNumber: i, column: n } = e;
    const s = this._editor.getModel();
    return t || n === 1 ? (i === 1 ? i = s.getLineCount() : i--, n = s.getLineMaxColumn(i)) : n--, new A(i, n);
  }
  _moveToPrevMatch(e, t = !1) {
    if (!this._state.canNavigateBack()) {
      const c = this._decorations.matchAfterPosition(e);
      c && this._setCurrentFindMatch(c);
      return;
    }
    if (this._decorations.getCount() < uc) {
      let c = this._decorations.matchBeforePosition(e);
      c && c.isEmpty() && c.getStartPosition().equals(e) && (e = this._prevSearchPosition(e), c = this._decorations.matchBeforePosition(e)), c && this._setCurrentFindMatch(c);
      return;
    }
    if (this._cannotFind())
      return;
    const i = this._decorations.getFindScope(), n = y_._getSearchRange(this._editor.getModel(), i);
    n.getEndPosition().isBefore(e) && (e = n.getEndPosition()), e.isBefore(n.getStartPosition()) && (e = n.getEndPosition());
    const { lineNumber: s, column: o } = e, a = this._editor.getModel();
    let l = new A(s, o), d = a.findPreviousMatch(this._state.searchString, l, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(
      131
      /* EditorOption.wordSeparators */
    ) : null, !1);
    if (d && d.range.isEmpty() && d.range.getStartPosition().equals(l) && (l = this._prevSearchPosition(l), d = a.findPreviousMatch(this._state.searchString, l, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(
      131
      /* EditorOption.wordSeparators */
    ) : null, !1)), !!d) {
      if (!t && !n.containsRange(d.range))
        return this._moveToPrevMatch(d.range.getStartPosition(), !0);
      this._setCurrentFindMatch(d.range);
    }
  }
  moveToPrevMatch() {
    this._moveToPrevMatch(this._editor.getSelection().getStartPosition());
  }
  _nextSearchPosition(e) {
    const t = this._state.isRegex && (this._state.searchString.indexOf("^") >= 0 || this._state.searchString.indexOf("$") >= 0);
    let { lineNumber: i, column: n } = e;
    const s = this._editor.getModel();
    return t || n === s.getLineMaxColumn(i) ? (i === s.getLineCount() ? i = 1 : i++, n = 1) : n++, new A(i, n);
  }
  _moveToNextMatch(e) {
    if (!this._state.canNavigateForward()) {
      const i = this._decorations.matchBeforePosition(e);
      i && this._setCurrentFindMatch(i);
      return;
    }
    if (this._decorations.getCount() < uc) {
      let i = this._decorations.matchAfterPosition(e);
      i && i.isEmpty() && i.getStartPosition().equals(e) && (e = this._nextSearchPosition(e), i = this._decorations.matchAfterPosition(e)), i && this._setCurrentFindMatch(i);
      return;
    }
    const t = this._getNextMatch(e, !1, !0);
    t && this._setCurrentFindMatch(t.range);
  }
  _getNextMatch(e, t, i, n = !1) {
    if (this._cannotFind())
      return null;
    const s = this._decorations.getFindScope(), o = y_._getSearchRange(this._editor.getModel(), s);
    o.getEndPosition().isBefore(e) && (e = o.getStartPosition()), e.isBefore(o.getStartPosition()) && (e = o.getStartPosition());
    const { lineNumber: a, column: l } = e, d = this._editor.getModel();
    let c = new A(a, l), h = d.findNextMatch(this._state.searchString, c, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(
      131
      /* EditorOption.wordSeparators */
    ) : null, t);
    return i && h && h.range.isEmpty() && h.range.getStartPosition().equals(c) && (c = this._nextSearchPosition(c), h = d.findNextMatch(this._state.searchString, c, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(
      131
      /* EditorOption.wordSeparators */
    ) : null, t)), h ? !n && !o.containsRange(h.range) ? this._getNextMatch(h.range.getEndPosition(), t, i, !0) : h : null;
  }
  moveToNextMatch() {
    this._moveToNextMatch(this._editor.getSelection().getEndPosition());
  }
  _moveToMatch(e) {
    const t = this._decorations.getDecorationRangeAt(e);
    t && this._setCurrentFindMatch(t);
  }
  moveToMatch(e) {
    this._moveToMatch(e);
  }
  _getReplacePattern() {
    return this._state.isRegex ? Gue(this._state.replaceString) : _p.fromStaticValue(this._state.replaceString);
  }
  replace() {
    if (!this._hasMatches())
      return;
    const e = this._getReplacePattern(), t = this._editor.getSelection(), i = this._getNextMatch(t.getStartPosition(), !0, !1);
    if (i)
      if (t.equalsRange(i.range)) {
        const n = e.buildReplaceString(i.matches, this._state.preserveCase), s = new Cn(t, n);
        this._executeEditorCommand("replace", s), this._decorations.setStartPosition(new A(t.startLineNumber, t.startColumn + n.length)), this.research(!0);
      } else
        this._decorations.setStartPosition(this._editor.getPosition()), this._setCurrentFindMatch(i.range);
  }
  _findMatches(e, t, i) {
    const n = (e || [null]).map((s) => y_._getSearchRange(this._editor.getModel(), s));
    return this._editor.getModel().findMatches(this._state.searchString, n, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(
      131
      /* EditorOption.wordSeparators */
    ) : null, t, i);
  }
  replaceAll() {
    if (!this._hasMatches())
      return;
    const e = this._decorations.getFindScopes();
    e === null && this._state.matchesCount >= uc ? this._largeReplaceAll() : this._regularReplaceAll(e), this.research(!1);
  }
  _largeReplaceAll() {
    const t = new Ih(this._state.searchString, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(
      131
      /* EditorOption.wordSeparators */
    ) : null).parseSearchRequest();
    if (!t)
      return;
    let i = t.regex;
    if (!i.multiline) {
      let h = "mu";
      i.ignoreCase && (h += "i"), i.global && (h += "g"), i = new RegExp(i.source, h);
    }
    const n = this._editor.getModel(), s = n.getValue(
      1
      /* EndOfLinePreference.LF */
    ), o = n.getFullModelRange(), a = this._getReplacePattern();
    let l;
    const d = this._state.preserveCase;
    a.hasReplacementPatterns || d ? l = s.replace(i, function() {
      return a.buildReplaceString(arguments, d);
    }) : l = s.replace(i, a.buildReplaceString(null, d));
    const c = new E1(o, l, this._editor.getSelection());
    this._executeEditorCommand("replaceAll", c);
  }
  _regularReplaceAll(e) {
    const t = this._getReplacePattern(), i = this._findMatches(
      e,
      t.hasReplacementPatterns || this._state.preserveCase,
      1073741824
      /* Constants.MAX_SAFE_SMALL_INTEGER */
    ), n = [];
    for (let o = 0, a = i.length; o < a; o++)
      n[o] = t.buildReplaceString(i[o].matches, this._state.preserveCase);
    const s = new Kue(this._editor.getSelection(), i.map((o) => o.range), n);
    this._executeEditorCommand("replaceAll", s);
  }
  selectAllMatches() {
    if (!this._hasMatches())
      return;
    const e = this._decorations.getFindScopes();
    let i = this._findMatches(
      e,
      !1,
      1073741824
      /* Constants.MAX_SAFE_SMALL_INTEGER */
    ).map((s) => new ge(s.range.startLineNumber, s.range.startColumn, s.range.endLineNumber, s.range.endColumn));
    const n = this._editor.getSelection();
    for (let s = 0, o = i.length; s < o; s++)
      if (i[s].equalsRange(n)) {
        i = [n].concat(i.slice(0, s)).concat(i.slice(s + 1));
        break;
      }
    this._editor.setSelections(i);
  }
  _executeEditorCommand(e, t) {
    try {
      this._ignoreModelContentChanged = !0, this._editor.pushUndoStop(), this._editor.executeCommand(e, t), this._editor.pushUndoStop();
    } finally {
      this._ignoreModelContentChanged = !1;
    }
  }
}
class OL extends bo {
  constructor(e, t, i) {
    super(), this._hideSoon = this._register(new xt(() => this._hide(), 2e3)), this._isVisible = !1, this._editor = e, this._state = t, this._keybindingService = i, this._domNode = document.createElement("div"), this._domNode.className = "findOptionsWidget", this._domNode.style.display = "none", this._domNode.style.top = "10px", this._domNode.style.zIndex = "12", this._domNode.setAttribute("role", "presentation"), this._domNode.setAttribute("aria-hidden", "true");
    const n = {
      inputActiveOptionBorder: le(w1),
      inputActiveOptionForeground: le(S1),
      inputActiveOptionBackground: le(Gh)
    }, s = this._register(np());
    this.caseSensitive = this._register(new Bz({
      appendTitle: this._keybindingLabelFor(Ht.ToggleCaseSensitiveCommand),
      isChecked: this._state.matchCase,
      hoverDelegate: s,
      ...n
    })), this._domNode.appendChild(this.caseSensitive.domNode), this._register(this.caseSensitive.onChange(() => {
      this._state.change({
        matchCase: this.caseSensitive.checked
      }, !1);
    })), this.wholeWords = this._register(new Hz({
      appendTitle: this._keybindingLabelFor(Ht.ToggleWholeWordCommand),
      isChecked: this._state.wholeWord,
      hoverDelegate: s,
      ...n
    })), this._domNode.appendChild(this.wholeWords.domNode), this._register(this.wholeWords.onChange(() => {
      this._state.change({
        wholeWord: this.wholeWords.checked
      }, !1);
    })), this.regex = this._register(new Vz({
      appendTitle: this._keybindingLabelFor(Ht.ToggleRegexCommand),
      isChecked: this._state.isRegex,
      hoverDelegate: s,
      ...n
    })), this._domNode.appendChild(this.regex.domNode), this._register(this.regex.onChange(() => {
      this._state.change({
        isRegex: this.regex.checked
      }, !1);
    })), this._editor.addOverlayWidget(this), this._register(this._state.onFindReplaceStateChange((o) => {
      let a = !1;
      o.isRegex && (this.regex.checked = this._state.isRegex, a = !0), o.wholeWord && (this.wholeWords.checked = this._state.wholeWord, a = !0), o.matchCase && (this.caseSensitive.checked = this._state.matchCase, a = !0), !this._state.isRevealed && a && this._revealTemporarily();
    })), this._register(W(this._domNode, Q.MOUSE_LEAVE, (o) => this._onMouseLeave())), this._register(W(this._domNode, "mouseover", (o) => this._onMouseOver()));
  }
  _keybindingLabelFor(e) {
    const t = this._keybindingService.lookupKeybinding(e);
    return t ? ` (${t.getLabel()})` : "";
  }
  dispose() {
    this._editor.removeOverlayWidget(this), super.dispose();
  }
  // ----- IOverlayWidget API
  getId() {
    return OL.ID;
  }
  getDomNode() {
    return this._domNode;
  }
  getPosition() {
    return {
      preference: 0
      /* OverlayWidgetPositionPreference.TOP_RIGHT_CORNER */
    };
  }
  highlightFindOptions() {
    this._revealTemporarily();
  }
  _revealTemporarily() {
    this._show(), this._hideSoon.schedule();
  }
  _onMouseLeave() {
    this._hideSoon.schedule();
  }
  _onMouseOver() {
    this._hideSoon.cancel();
  }
  _show() {
    this._isVisible || (this._isVisible = !0, this._domNode.style.display = "block");
  }
  _hide() {
    this._isVisible && (this._isVisible = !1, this._domNode.style.display = "none");
  }
}
OL.ID = "editor.contrib.findOptionsWidget";
function aw(r, e) {
  return r === 1 ? !0 : r === 2 ? !1 : e;
}
class Yue extends P {
  get searchString() {
    return this._searchString;
  }
  get replaceString() {
    return this._replaceString;
  }
  get isRevealed() {
    return this._isRevealed;
  }
  get isReplaceRevealed() {
    return this._isReplaceRevealed;
  }
  get isRegex() {
    return aw(this._isRegexOverride, this._isRegex);
  }
  get wholeWord() {
    return aw(this._wholeWordOverride, this._wholeWord);
  }
  get matchCase() {
    return aw(this._matchCaseOverride, this._matchCase);
  }
  get preserveCase() {
    return aw(this._preserveCaseOverride, this._preserveCase);
  }
  get actualIsRegex() {
    return this._isRegex;
  }
  get actualWholeWord() {
    return this._wholeWord;
  }
  get actualMatchCase() {
    return this._matchCase;
  }
  get actualPreserveCase() {
    return this._preserveCase;
  }
  get searchScope() {
    return this._searchScope;
  }
  get matchesPosition() {
    return this._matchesPosition;
  }
  get matchesCount() {
    return this._matchesCount;
  }
  get currentMatch() {
    return this._currentMatch;
  }
  constructor() {
    super(), this._onFindReplaceStateChange = this._register(new R()), this.onFindReplaceStateChange = this._onFindReplaceStateChange.event, this._searchString = "", this._replaceString = "", this._isRevealed = !1, this._isReplaceRevealed = !1, this._isRegex = !1, this._isRegexOverride = 0, this._wholeWord = !1, this._wholeWordOverride = 0, this._matchCase = !1, this._matchCaseOverride = 0, this._preserveCase = !1, this._preserveCaseOverride = 0, this._searchScope = null, this._matchesPosition = 0, this._matchesCount = 0, this._currentMatch = null, this._loop = !0, this._isSearching = !1, this._filters = null;
  }
  changeMatchInfo(e, t, i) {
    const n = {
      moveCursor: !1,
      updateHistory: !1,
      searchString: !1,
      replaceString: !1,
      isRevealed: !1,
      isReplaceRevealed: !1,
      isRegex: !1,
      wholeWord: !1,
      matchCase: !1,
      preserveCase: !1,
      searchScope: !1,
      matchesPosition: !1,
      matchesCount: !1,
      currentMatch: !1,
      loop: !1,
      isSearching: !1,
      filters: !1
    };
    let s = !1;
    t === 0 && (e = 0), e > t && (e = t), this._matchesPosition !== e && (this._matchesPosition = e, n.matchesPosition = !0, s = !0), this._matchesCount !== t && (this._matchesCount = t, n.matchesCount = !0, s = !0), typeof i < "u" && (L.equalsRange(this._currentMatch, i) || (this._currentMatch = i, n.currentMatch = !0, s = !0)), s && this._onFindReplaceStateChange.fire(n);
  }
  change(e, t, i = !0) {
    var n;
    const s = {
      moveCursor: t,
      updateHistory: i,
      searchString: !1,
      replaceString: !1,
      isRevealed: !1,
      isReplaceRevealed: !1,
      isRegex: !1,
      wholeWord: !1,
      matchCase: !1,
      preserveCase: !1,
      searchScope: !1,
      matchesPosition: !1,
      matchesCount: !1,
      currentMatch: !1,
      loop: !1,
      isSearching: !1,
      filters: !1
    };
    let o = !1;
    const a = this.isRegex, l = this.wholeWord, d = this.matchCase, c = this.preserveCase;
    typeof e.searchString < "u" && this._searchString !== e.searchString && (this._searchString = e.searchString, s.searchString = !0, o = !0), typeof e.replaceString < "u" && this._replaceString !== e.replaceString && (this._replaceString = e.replaceString, s.replaceString = !0, o = !0), typeof e.isRevealed < "u" && this._isRevealed !== e.isRevealed && (this._isRevealed = e.isRevealed, s.isRevealed = !0, o = !0), typeof e.isReplaceRevealed < "u" && this._isReplaceRevealed !== e.isReplaceRevealed && (this._isReplaceRevealed = e.isReplaceRevealed, s.isReplaceRevealed = !0, o = !0), typeof e.isRegex < "u" && (this._isRegex = e.isRegex), typeof e.wholeWord < "u" && (this._wholeWord = e.wholeWord), typeof e.matchCase < "u" && (this._matchCase = e.matchCase), typeof e.preserveCase < "u" && (this._preserveCase = e.preserveCase), typeof e.searchScope < "u" && (!((n = e.searchScope) === null || n === void 0) && n.every((h) => {
      var u;
      return (u = this._searchScope) === null || u === void 0 ? void 0 : u.some((g) => !L.equalsRange(g, h));
    }) || (this._searchScope = e.searchScope, s.searchScope = !0, o = !0)), typeof e.loop < "u" && this._loop !== e.loop && (this._loop = e.loop, s.loop = !0, o = !0), typeof e.isSearching < "u" && this._isSearching !== e.isSearching && (this._isSearching = e.isSearching, s.isSearching = !0, o = !0), typeof e.filters < "u" && (this._filters ? this._filters.update(e.filters) : this._filters = e.filters, s.filters = !0, o = !0), this._isRegexOverride = typeof e.isRegexOverride < "u" ? e.isRegexOverride : 0, this._wholeWordOverride = typeof e.wholeWordOverride < "u" ? e.wholeWordOverride : 0, this._matchCaseOverride = typeof e.matchCaseOverride < "u" ? e.matchCaseOverride : 0, this._preserveCaseOverride = typeof e.preserveCaseOverride < "u" ? e.preserveCaseOverride : 0, a !== this.isRegex && (o = !0, s.isRegex = !0), l !== this.wholeWord && (o = !0, s.wholeWord = !0), d !== this.matchCase && (o = !0, s.matchCase = !0), c !== this.preserveCase && (o = !0, s.preserveCase = !0), o && this._onFindReplaceStateChange.fire(s);
  }
  canNavigateBack() {
    return this.canNavigateInLoop() || this.matchesPosition !== 1;
  }
  canNavigateForward() {
    return this.canNavigateInLoop() || this.matchesPosition < this.matchesCount;
  }
  canNavigateInLoop() {
    return this._loop || this.matchesCount >= uc;
  }
}
const Que = p("defaultLabel", "input"), Xue = p("label.preserveCaseToggle", "Preserve Case");
class Jue extends Ap {
  constructor(e) {
    var t;
    super({
      // TODO: does this need its own icon?
      icon: me.preserveCase,
      title: Xue + e.appendTitle,
      isChecked: e.isChecked,
      hoverDelegate: (t = e.hoverDelegate) !== null && t !== void 0 ? t : us("element"),
      inputActiveOptionBorder: e.inputActiveOptionBorder,
      inputActiveOptionForeground: e.inputActiveOptionForeground,
      inputActiveOptionBackground: e.inputActiveOptionBackground
    });
  }
}
class ege extends bo {
  constructor(e, t, i, n) {
    super(), this._showOptionButtons = i, this.fixFocusOnOptionClickEnabled = !0, this.cachedOptionsWidth = 0, this._onDidOptionChange = this._register(new R()), this.onDidOptionChange = this._onDidOptionChange.event, this._onKeyDown = this._register(new R()), this.onKeyDown = this._onKeyDown.event, this._onMouseDown = this._register(new R()), this._onInput = this._register(new R()), this._onKeyUp = this._register(new R()), this._onPreserveCaseKeyDown = this._register(new R()), this.onPreserveCaseKeyDown = this._onPreserveCaseKeyDown.event, this.contextViewProvider = t, this.placeholder = n.placeholder || "", this.validation = n.validation, this.label = n.label || Que;
    const s = n.appendPreserveCaseLabel || "", o = n.history || [], a = !!n.flexibleHeight, l = !!n.flexibleWidth, d = n.flexibleMaxHeight;
    this.domNode = document.createElement("div"), this.domNode.classList.add("monaco-findInput"), this.inputBox = this._register(new zz(this.domNode, this.contextViewProvider, {
      ariaLabel: this.label || "",
      placeholder: this.placeholder || "",
      validationOptions: {
        validation: this.validation
      },
      history: o,
      showHistoryHint: n.showHistoryHint,
      flexibleHeight: a,
      flexibleWidth: l,
      flexibleMaxHeight: d,
      inputBoxStyles: n.inputBoxStyles
    })), this.preserveCase = this._register(new Jue({
      appendTitle: s,
      isChecked: !1,
      ...n.toggleStyles
    })), this._register(this.preserveCase.onChange((u) => {
      this._onDidOptionChange.fire(u), !u && this.fixFocusOnOptionClickEnabled && this.inputBox.focus(), this.validate();
    })), this._register(this.preserveCase.onKeyDown((u) => {
      this._onPreserveCaseKeyDown.fire(u);
    })), this._showOptionButtons ? this.cachedOptionsWidth = this.preserveCase.width() : this.cachedOptionsWidth = 0;
    const c = [this.preserveCase.domNode];
    this.onkeydown(this.domNode, (u) => {
      if (u.equals(
        15
        /* KeyCode.LeftArrow */
      ) || u.equals(
        17
        /* KeyCode.RightArrow */
      ) || u.equals(
        9
        /* KeyCode.Escape */
      )) {
        const g = c.indexOf(this.domNode.ownerDocument.activeElement);
        if (g >= 0) {
          let f = -1;
          u.equals(
            17
            /* KeyCode.RightArrow */
          ) ? f = (g + 1) % c.length : u.equals(
            15
            /* KeyCode.LeftArrow */
          ) && (g === 0 ? f = c.length - 1 : f = g - 1), u.equals(
            9
            /* KeyCode.Escape */
          ) ? (c[g].blur(), this.inputBox.focus()) : f >= 0 && c[f].focus(), nt.stop(u, !0);
        }
      }
    });
    const h = document.createElement("div");
    h.className = "controls", h.style.display = this._showOptionButtons ? "block" : "none", h.appendChild(this.preserveCase.domNode), this.domNode.appendChild(h), e == null || e.appendChild(this.domNode), this.onkeydown(this.inputBox.inputElement, (u) => this._onKeyDown.fire(u)), this.onkeyup(this.inputBox.inputElement, (u) => this._onKeyUp.fire(u)), this.oninput(this.inputBox.inputElement, (u) => this._onInput.fire()), this.onmousedown(this.inputBox.inputElement, (u) => this._onMouseDown.fire(u));
  }
  enable() {
    this.domNode.classList.remove("disabled"), this.inputBox.enable(), this.preserveCase.enable();
  }
  disable() {
    this.domNode.classList.add("disabled"), this.inputBox.disable(), this.preserveCase.disable();
  }
  setEnabled(e) {
    e ? this.enable() : this.disable();
  }
  select() {
    this.inputBox.select();
  }
  focus() {
    this.inputBox.focus();
  }
  getPreserveCase() {
    return this.preserveCase.checked;
  }
  setPreserveCase(e) {
    this.preserveCase.checked = e;
  }
  focusOnPreserve() {
    this.preserveCase.focus();
  }
  validate() {
    var e;
    (e = this.inputBox) === null || e === void 0 || e.validate();
  }
  set width(e) {
    this.inputBox.paddingRight = this.cachedOptionsWidth, this.domNode.style.width = e + "px";
  }
  dispose() {
    super.dispose();
  }
}
var N4 = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, M4 = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
const wR = new oe("suggestWidgetVisible", !1, p("suggestWidgetVisible", "Whether suggestion are visible")), SR = "historyNavigationWidgetFocus", R4 = "historyNavigationForwardsEnabled", A4 = "historyNavigationBackwardsEnabled";
let sd;
const lw = [];
function P4(r, e) {
  if (lw.includes(e))
    throw new Error("Cannot register the same widget multiple times");
  lw.push(e);
  const t = new q(), i = new oe(SR, !1).bindTo(r), n = new oe(R4, !0).bindTo(r), s = new oe(A4, !0).bindTo(r), o = () => {
    i.set(!0), sd = e;
  }, a = () => {
    i.set(!1), sd === e && (sd = void 0);
  };
  return a0(e.element) && o(), t.add(e.onDidFocus(() => o())), t.add(e.onDidBlur(() => a())), t.add(Se(() => {
    lw.splice(lw.indexOf(e), 1), a();
  })), {
    historyNavigationForwardsEnablement: n,
    historyNavigationBackwardsEnablement: s,
    dispose() {
      t.dispose();
    }
  };
}
let NT = class extends Uz {
  constructor(e, t, i, n) {
    super(e, t, i);
    const s = this._register(n.createScoped(this.inputBox.element));
    this._register(P4(s, this.inputBox));
  }
};
NT = N4([
  M4(3, De)
], NT);
let MT = class extends ege {
  constructor(e, t, i, n, s = !1) {
    super(e, t, s, i);
    const o = this._register(n.createScoped(this.inputBox.element));
    this._register(P4(o, this.inputBox));
  }
};
MT = N4([
  M4(3, De)
], MT);
ls.registerCommandAndKeybindingRule({
  id: "history.showPrevious",
  weight: 200,
  when: U.and(U.has(SR), U.equals(A4, !0), U.not("isComposing"), wR.isEqualTo(!1)),
  primary: 16,
  secondary: [
    528
    /* KeyCode.UpArrow */
  ],
  handler: (r) => {
    sd == null || sd.showPreviousValue();
  }
});
ls.registerCommandAndKeybindingRule({
  id: "history.showNext",
  weight: 200,
  when: U.and(U.has(SR), U.equals(R4, !0), U.not("isComposing"), wR.isEqualTo(!1)),
  primary: 18,
  secondary: [
    530
    /* KeyCode.DownArrow */
  ],
  handler: (r) => {
    sd == null || sd.showNextValue();
  }
});
function FW(r) {
  var e, t;
  return ((e = r.lookupKeybinding("history.showPrevious")) === null || e === void 0 ? void 0 : e.getElectronAccelerator()) === "Up" && ((t = r.lookupKeybinding("history.showNext")) === null || t === void 0 ? void 0 : t.getElectronAccelerator()) === "Down";
}
const WW = hi("find-collapsed", me.chevronRight, p("findCollapsedIcon", "Icon to indicate that the editor find widget is collapsed.")), BW = hi("find-expanded", me.chevronDown, p("findExpandedIcon", "Icon to indicate that the editor find widget is expanded.")), tge = hi("find-selection", me.selection, p("findSelectionIcon", "Icon for 'Find in Selection' in the editor find widget.")), ige = hi("find-replace", me.replace, p("findReplaceIcon", "Icon for 'Replace' in the editor find widget.")), nge = hi("find-replace-all", me.replaceAll, p("findReplaceAllIcon", "Icon for 'Replace All' in the editor find widget.")), sge = hi("find-previous-match", me.arrowUp, p("findPreviousMatchIcon", "Icon for 'Find Previous' in the editor find widget.")), oge = hi("find-next-match", me.arrowDown, p("findNextMatchIcon", "Icon for 'Find Next' in the editor find widget.")), rge = p("label.findDialog", "Find / Replace"), age = p("label.find", "Find"), lge = p("placeholder.find", "Find"), dge = p("label.previousMatchButton", "Previous Match"), cge = p("label.nextMatchButton", "Next Match"), hge = p("label.toggleSelectionFind", "Find in Selection"), uge = p("label.closeButton", "Close"), gge = p("label.replace", "Replace"), fge = p("placeholder.replace", "Replace"), pge = p("label.replaceButton", "Replace"), mge = p("label.replaceAllButton", "Replace All"), _ge = p("label.toggleReplaceButton", "Toggle Replace"), vge = p("title.matchesCountLimit", "Only the first {0} results are highlighted, but all find operations work on the entire text.", uc), bge = p("label.matchesLocation", "{0} of {1}"), HW = p("label.noResults", "No results"), va = 419, Cge = 275, wge = Cge - 54;
let vm = 69;
const Sge = 33, VW = "ctrlEnterReplaceAll.windows.donotask", zW = Je ? 256 : 2048;
class Xk {
  constructor(e) {
    this.afterLineNumber = e, this.heightInPx = Sge, this.suppressMouseDown = !1, this.domNode = document.createElement("div"), this.domNode.className = "dock-find-viewzone";
  }
}
function UW(r, e, t) {
  const i = !!e.match(/\n/);
  if (t && i && t.selectionStart > 0) {
    r.stopPropagation();
    return;
  }
}
function $W(r, e, t) {
  const i = !!e.match(/\n/);
  if (t && i && t.selectionEnd < t.value.length) {
    r.stopPropagation();
    return;
  }
}
class FL extends bo {
  constructor(e, t, i, n, s, o, a, l, d, c) {
    super(), this._hoverService = c, this._cachedHeight = null, this._revealTimeouts = [], this._codeEditor = e, this._controller = t, this._state = i, this._contextViewProvider = n, this._keybindingService = s, this._contextKeyService = o, this._storageService = l, this._notificationService = d, this._ctrlEnterReplaceAllWarningPrompted = !!l.getBoolean(
      VW,
      0
      /* StorageScope.PROFILE */
    ), this._isVisible = !1, this._isReplaceVisible = !1, this._ignoreChangeEvent = !1, this._updateHistoryDelayer = new pr(500), this._register(Se(() => this._updateHistoryDelayer.cancel())), this._register(this._state.onFindReplaceStateChange((h) => this._onStateChanged(h))), this._buildDomNode(), this._updateButtons(), this._tryUpdateWidgetWidth(), this._findInput.inputBox.layout(), this._register(this._codeEditor.onDidChangeConfiguration((h) => {
      if (h.hasChanged(
        91
        /* EditorOption.readOnly */
      ) && (this._codeEditor.getOption(
        91
        /* EditorOption.readOnly */
      ) && this._state.change({ isReplaceRevealed: !1 }, !1), this._updateButtons()), h.hasChanged(
        145
        /* EditorOption.layoutInfo */
      ) && this._tryUpdateWidgetWidth(), h.hasChanged(
        2
        /* EditorOption.accessibilitySupport */
      ) && this.updateAccessibilitySupport(), h.hasChanged(
        41
        /* EditorOption.find */
      )) {
        const u = this._codeEditor.getOption(
          41
          /* EditorOption.find */
        ).loop;
        this._state.change({ loop: u }, !1);
        const g = this._codeEditor.getOption(
          41
          /* EditorOption.find */
        ).addExtraSpaceOnTop;
        g && !this._viewZone && (this._viewZone = new Xk(0), this._showViewZone()), !g && this._viewZone && this._removeViewZone();
      }
    })), this.updateAccessibilitySupport(), this._register(this._codeEditor.onDidChangeCursorSelection(() => {
      this._isVisible && this._updateToggleSelectionFindButton();
    })), this._register(this._codeEditor.onDidFocusEditorWidget(async () => {
      if (this._isVisible) {
        const h = await this._controller.getGlobalBufferTerm();
        h && h !== this._state.searchString && (this._state.change({ searchString: h }, !1), this._findInput.select());
      }
    })), this._findInputFocused = PL.bindTo(o), this._findFocusTracker = this._register(Xr(this._findInput.inputBox.inputElement)), this._register(this._findFocusTracker.onDidFocus(() => {
      this._findInputFocused.set(!0), this._updateSearchScope();
    })), this._register(this._findFocusTracker.onDidBlur(() => {
      this._findInputFocused.set(!1);
    })), this._replaceInputFocused = CR.bindTo(o), this._replaceFocusTracker = this._register(Xr(this._replaceInput.inputBox.inputElement)), this._register(this._replaceFocusTracker.onDidFocus(() => {
      this._replaceInputFocused.set(!0), this._updateSearchScope();
    })), this._register(this._replaceFocusTracker.onDidBlur(() => {
      this._replaceInputFocused.set(!1);
    })), this._codeEditor.addOverlayWidget(this), this._codeEditor.getOption(
      41
      /* EditorOption.find */
    ).addExtraSpaceOnTop && (this._viewZone = new Xk(0)), this._register(this._codeEditor.onDidChangeModel(() => {
      this._isVisible && (this._viewZoneId = void 0);
    })), this._register(this._codeEditor.onDidScrollChange((h) => {
      if (h.scrollTopChanged) {
        this._layoutViewZone();
        return;
      }
      setTimeout(() => {
        this._layoutViewZone();
      }, 0);
    }));
  }
  // ----- IOverlayWidget API
  getId() {
    return FL.ID;
  }
  getDomNode() {
    return this._domNode;
  }
  getPosition() {
    return this._isVisible ? {
      preference: 0
      /* OverlayWidgetPositionPreference.TOP_RIGHT_CORNER */
    } : null;
  }
  // ----- React to state changes
  _onStateChanged(e) {
    if (e.searchString) {
      try {
        this._ignoreChangeEvent = !0, this._findInput.setValue(this._state.searchString);
      } finally {
        this._ignoreChangeEvent = !1;
      }
      this._updateButtons();
    }
    if (e.replaceString && (this._replaceInput.inputBox.value = this._state.replaceString), e.isRevealed && (this._state.isRevealed ? this._reveal() : this._hide(!0)), e.isReplaceRevealed && (this._state.isReplaceRevealed ? !this._codeEditor.getOption(
      91
      /* EditorOption.readOnly */
    ) && !this._isReplaceVisible && (this._isReplaceVisible = !0, this._replaceInput.width = Ms(this._findInput.domNode), this._updateButtons(), this._replaceInput.inputBox.layout()) : this._isReplaceVisible && (this._isReplaceVisible = !1, this._updateButtons())), (e.isRevealed || e.isReplaceRevealed) && (this._state.isRevealed || this._state.isReplaceRevealed) && this._tryUpdateHeight() && this._showViewZone(), e.isRegex && this._findInput.setRegex(this._state.isRegex), e.wholeWord && this._findInput.setWholeWords(this._state.wholeWord), e.matchCase && this._findInput.setCaseSensitive(this._state.matchCase), e.preserveCase && this._replaceInput.setPreserveCase(this._state.preserveCase), e.searchScope && (this._state.searchScope ? this._toggleSelectionFind.checked = !0 : this._toggleSelectionFind.checked = !1, this._updateToggleSelectionFindButton()), e.searchString || e.matchesCount || e.matchesPosition) {
      const t = this._state.searchString.length > 0 && this._state.matchesCount === 0;
      this._domNode.classList.toggle("no-results", t), this._updateMatchesCount(), this._updateButtons();
    }
    (e.searchString || e.currentMatch) && this._layoutViewZone(), e.updateHistory && this._delayedUpdateHistory(), e.loop && this._updateButtons();
  }
  _delayedUpdateHistory() {
    this._updateHistoryDelayer.trigger(this._updateHistory.bind(this)).then(void 0, He);
  }
  _updateHistory() {
    this._state.searchString && this._findInput.inputBox.addToHistory(), this._state.replaceString && this._replaceInput.inputBox.addToHistory();
  }
  _updateMatchesCount() {
    this._matchesCount.style.minWidth = vm + "px", this._state.matchesCount >= uc ? this._matchesCount.title = vge : this._matchesCount.title = "", this._matchesCount.firstChild && this._matchesCount.removeChild(this._matchesCount.firstChild);
    let e;
    if (this._state.matchesCount > 0) {
      let t = String(this._state.matchesCount);
      this._state.matchesCount >= uc && (t += "+");
      let i = String(this._state.matchesPosition);
      i === "0" && (i = "?"), e = vu(bge, i, t);
    } else
      e = HW;
    this._matchesCount.appendChild(document.createTextNode(e)), Ls(this._getAriaLabel(e, this._state.currentMatch, this._state.searchString)), vm = Math.max(vm, this._matchesCount.clientWidth);
  }
  // ----- actions
  _getAriaLabel(e, t, i) {
    if (e === HW)
      return i === "" ? p("ariaSearchNoResultEmpty", "{0} found", e) : p("ariaSearchNoResult", "{0} found for '{1}'", e, i);
    if (t) {
      const n = p("ariaSearchNoResultWithLineNum", "{0} found for '{1}', at {2}", e, i, t.startLineNumber + ":" + t.startColumn), s = this._codeEditor.getModel();
      return s && t.startLineNumber <= s.getLineCount() && t.startLineNumber >= 1 ? `${s.getLineContent(t.startLineNumber)}, ${n}` : n;
    }
    return p("ariaSearchNoResultWithLineNumNoCurrentMatch", "{0} found for '{1}'", e, i);
  }
  /**
   * If 'selection find' is ON we should not disable the button (its function is to cancel 'selection find').
   * If 'selection find' is OFF we enable the button only if there is a selection.
   */
  _updateToggleSelectionFindButton() {
    const e = this._codeEditor.getSelection(), t = e ? e.startLineNumber !== e.endLineNumber || e.startColumn !== e.endColumn : !1, i = this._toggleSelectionFind.checked;
    this._isVisible && (i || t) ? this._toggleSelectionFind.enable() : this._toggleSelectionFind.disable();
  }
  _updateButtons() {
    this._findInput.setEnabled(this._isVisible), this._replaceInput.setEnabled(this._isVisible && this._isReplaceVisible), this._updateToggleSelectionFindButton(), this._closeBtn.setEnabled(this._isVisible);
    const e = this._state.searchString.length > 0, t = !!this._state.matchesCount;
    this._prevBtn.setEnabled(this._isVisible && e && t && this._state.canNavigateBack()), this._nextBtn.setEnabled(this._isVisible && e && t && this._state.canNavigateForward()), this._replaceBtn.setEnabled(this._isVisible && this._isReplaceVisible && e), this._replaceAllBtn.setEnabled(this._isVisible && this._isReplaceVisible && e), this._domNode.classList.toggle("replaceToggled", this._isReplaceVisible), this._toggleReplaceBtn.setExpanded(this._isReplaceVisible);
    const i = !this._codeEditor.getOption(
      91
      /* EditorOption.readOnly */
    );
    this._toggleReplaceBtn.setEnabled(this._isVisible && i);
  }
  _reveal() {
    if (this._revealTimeouts.forEach((e) => {
      clearTimeout(e);
    }), this._revealTimeouts = [], !this._isVisible) {
      this._isVisible = !0;
      const e = this._codeEditor.getSelection();
      switch (this._codeEditor.getOption(
        41
        /* EditorOption.find */
      ).autoFindInSelection) {
        case "always":
          this._toggleSelectionFind.checked = !0;
          break;
        case "never":
          this._toggleSelectionFind.checked = !1;
          break;
        case "multiline": {
          const i = !!e && e.startLineNumber !== e.endLineNumber;
          this._toggleSelectionFind.checked = i;
          break;
        }
      }
      this._tryUpdateWidgetWidth(), this._updateButtons(), this._revealTimeouts.push(setTimeout(() => {
        this._domNode.classList.add("visible"), this._domNode.setAttribute("aria-hidden", "false");
      }, 0)), this._revealTimeouts.push(setTimeout(() => {
        this._findInput.validate();
      }, 200)), this._codeEditor.layoutOverlayWidget(this);
      let t = !0;
      if (this._codeEditor.getOption(
        41
        /* EditorOption.find */
      ).seedSearchStringFromSelection && e) {
        const i = this._codeEditor.getDomNode();
        if (i) {
          const n = Ei(i), s = this._codeEditor.getScrolledVisiblePosition(e.getStartPosition()), o = n.left + (s ? s.left : 0), a = s ? s.top : 0;
          if (this._viewZone && a < this._viewZone.heightInPx) {
            e.endLineNumber > e.startLineNumber && (t = !1);
            const l = HH(this._domNode).left;
            o > l && (t = !1);
            const d = this._codeEditor.getScrolledVisiblePosition(e.getEndPosition());
            n.left + (d ? d.left : 0) > l && (t = !1);
          }
        }
      }
      this._showViewZone(t);
    }
  }
  _hide(e) {
    this._revealTimeouts.forEach((t) => {
      clearTimeout(t);
    }), this._revealTimeouts = [], this._isVisible && (this._isVisible = !1, this._updateButtons(), this._domNode.classList.remove("visible"), this._domNode.setAttribute("aria-hidden", "true"), this._findInput.clearMessage(), e && this._codeEditor.focus(), this._codeEditor.layoutOverlayWidget(this), this._removeViewZone());
  }
  _layoutViewZone(e) {
    if (!this._codeEditor.getOption(
      41
      /* EditorOption.find */
    ).addExtraSpaceOnTop) {
      this._removeViewZone();
      return;
    }
    if (!this._isVisible)
      return;
    const i = this._viewZone;
    this._viewZoneId !== void 0 || !i || this._codeEditor.changeViewZones((n) => {
      i.heightInPx = this._getHeight(), this._viewZoneId = n.addZone(i), this._codeEditor.setScrollTop(e || this._codeEditor.getScrollTop() + i.heightInPx);
    });
  }
  _showViewZone(e = !0) {
    if (!this._isVisible || !this._codeEditor.getOption(
      41
      /* EditorOption.find */
    ).addExtraSpaceOnTop)
      return;
    this._viewZone === void 0 && (this._viewZone = new Xk(0));
    const i = this._viewZone;
    this._codeEditor.changeViewZones((n) => {
      if (this._viewZoneId !== void 0) {
        const s = this._getHeight();
        if (s === i.heightInPx)
          return;
        const o = s - i.heightInPx;
        i.heightInPx = s, n.layoutZone(this._viewZoneId), e && this._codeEditor.setScrollTop(this._codeEditor.getScrollTop() + o);
        return;
      } else {
        let s = this._getHeight();
        if (s -= this._codeEditor.getOption(
          84
          /* EditorOption.padding */
        ).top, s <= 0)
          return;
        i.heightInPx = s, this._viewZoneId = n.addZone(i), e && this._codeEditor.setScrollTop(this._codeEditor.getScrollTop() + s);
      }
    });
  }
  _removeViewZone() {
    this._codeEditor.changeViewZones((e) => {
      this._viewZoneId !== void 0 && (e.removeZone(this._viewZoneId), this._viewZoneId = void 0, this._viewZone && (this._codeEditor.setScrollTop(this._codeEditor.getScrollTop() - this._viewZone.heightInPx), this._viewZone = void 0));
    });
  }
  _tryUpdateWidgetWidth() {
    if (!this._isVisible || !this._domNode.isConnected)
      return;
    const e = this._codeEditor.getLayoutInfo();
    if (e.contentWidth <= 0) {
      this._domNode.classList.add("hiddenEditor");
      return;
    } else this._domNode.classList.contains("hiddenEditor") && this._domNode.classList.remove("hiddenEditor");
    const i = e.width, n = e.minimap.minimapWidth;
    let s = !1, o = !1, a = !1;
    if (this._resized && Ms(this._domNode) > va) {
      this._domNode.style.maxWidth = `${i - 28 - n - 15}px`, this._replaceInput.width = Ms(this._findInput.domNode);
      return;
    }
    if (va + 28 + n >= i && (o = !0), va + 28 + n - vm >= i && (a = !0), va + 28 + n - vm >= i + 50 && (s = !0), this._domNode.classList.toggle("collapsed-find-widget", s), this._domNode.classList.toggle("narrow-find-widget", a), this._domNode.classList.toggle("reduced-find-widget", o), !a && !s && (this._domNode.style.maxWidth = `${i - 28 - n - 15}px`), this._findInput.layout({ collapsedFindWidget: s, narrowFindWidget: a, reducedFindWidget: o }), this._resized) {
      const l = this._findInput.inputBox.element.clientWidth;
      l > 0 && (this._replaceInput.width = l);
    } else this._isReplaceVisible && (this._replaceInput.width = Ms(this._findInput.domNode));
  }
  _getHeight() {
    let e = 0;
    return e += 4, e += this._findInput.inputBox.height + 2, this._isReplaceVisible && (e += 4, e += this._replaceInput.inputBox.height + 2), e += 4, e;
  }
  _tryUpdateHeight() {
    const e = this._getHeight();
    return this._cachedHeight !== null && this._cachedHeight === e ? !1 : (this._cachedHeight = e, this._domNode.style.height = `${e}px`, !0);
  }
  // ----- Public
  focusFindInput() {
    this._findInput.select(), this._findInput.focus();
  }
  focusReplaceInput() {
    this._replaceInput.select(), this._replaceInput.focus();
  }
  highlightFindOptions() {
    this._findInput.highlightFindOptions();
  }
  _updateSearchScope() {
    if (this._codeEditor.hasModel() && this._toggleSelectionFind.checked) {
      const e = this._codeEditor.getSelections();
      e.map((t) => {
        t.endColumn === 1 && t.endLineNumber > t.startLineNumber && (t = t.setEndPosition(t.endLineNumber - 1, this._codeEditor.getModel().getLineMaxColumn(t.endLineNumber - 1)));
        const i = this._state.currentMatch;
        return t.startLineNumber !== t.endLineNumber && !L.equalsRange(t, i) ? t : null;
      }).filter((t) => !!t), e.length && this._state.change({ searchScope: e }, !0);
    }
  }
  _onFindInputMouseDown(e) {
    e.middleButton && e.stopPropagation();
  }
  _onFindInputKeyDown(e) {
    if (e.equals(
      zW | 3
      /* KeyCode.Enter */
    ))
      if (this._keybindingService.dispatchEvent(e, e.target)) {
        e.preventDefault();
        return;
      } else {
        this._findInput.inputBox.insertAtCursor(`
`), e.preventDefault();
        return;
      }
    if (e.equals(
      2
      /* KeyCode.Tab */
    )) {
      this._isReplaceVisible ? this._replaceInput.focus() : this._findInput.focusOnCaseSensitive(), e.preventDefault();
      return;
    }
    if (e.equals(
      2066
      /* KeyCode.DownArrow */
    )) {
      this._codeEditor.focus(), e.preventDefault();
      return;
    }
    if (e.equals(
      16
      /* KeyCode.UpArrow */
    ))
      return UW(e, this._findInput.getValue(), this._findInput.domNode.querySelector("textarea"));
    if (e.equals(
      18
      /* KeyCode.DownArrow */
    ))
      return $W(e, this._findInput.getValue(), this._findInput.domNode.querySelector("textarea"));
  }
  _onReplaceInputKeyDown(e) {
    if (e.equals(
      zW | 3
      /* KeyCode.Enter */
    ))
      if (this._keybindingService.dispatchEvent(e, e.target)) {
        e.preventDefault();
        return;
      } else {
        Ks && zr && !this._ctrlEnterReplaceAllWarningPrompted && (this._notificationService.info(p("ctrlEnter.keybindingChanged", "Ctrl+Enter now inserts line break instead of replacing all. You can modify the keybinding for editor.action.replaceAll to override this behavior.")), this._ctrlEnterReplaceAllWarningPrompted = !0, this._storageService.store(
          VW,
          !0,
          0,
          0
          /* StorageTarget.USER */
        )), this._replaceInput.inputBox.insertAtCursor(`
`), e.preventDefault();
        return;
      }
    if (e.equals(
      2
      /* KeyCode.Tab */
    )) {
      this._findInput.focusOnCaseSensitive(), e.preventDefault();
      return;
    }
    if (e.equals(
      1026
      /* KeyCode.Tab */
    )) {
      this._findInput.focus(), e.preventDefault();
      return;
    }
    if (e.equals(
      2066
      /* KeyCode.DownArrow */
    )) {
      this._codeEditor.focus(), e.preventDefault();
      return;
    }
    if (e.equals(
      16
      /* KeyCode.UpArrow */
    ))
      return UW(e, this._replaceInput.inputBox.value, this._replaceInput.inputBox.element.querySelector("textarea"));
    if (e.equals(
      18
      /* KeyCode.DownArrow */
    ))
      return $W(e, this._replaceInput.inputBox.value, this._replaceInput.inputBox.element.querySelector("textarea"));
  }
  // ----- sash
  getVerticalSashLeft(e) {
    return 0;
  }
  // ----- initialization
  _keybindingLabelFor(e) {
    const t = this._keybindingService.lookupKeybinding(e);
    return t ? ` (${t.getLabel()})` : "";
  }
  _buildDomNode() {
    this._findInput = this._register(new NT(null, this._contextViewProvider, {
      width: wge,
      label: age,
      placeholder: lge,
      appendCaseSensitiveLabel: this._keybindingLabelFor(Ht.ToggleCaseSensitiveCommand),
      appendWholeWordsLabel: this._keybindingLabelFor(Ht.ToggleWholeWordCommand),
      appendRegexLabel: this._keybindingLabelFor(Ht.ToggleRegexCommand),
      validation: (c) => {
        if (c.length === 0 || !this._findInput.getRegex())
          return null;
        try {
          return new RegExp(c, "gu"), null;
        } catch (h) {
          return { content: h.message };
        }
      },
      flexibleHeight: !0,
      flexibleWidth: !0,
      flexibleMaxHeight: 118,
      showCommonFindToggles: !0,
      showHistoryHint: () => FW(this._keybindingService),
      inputBoxStyles: ZS,
      toggleStyles: GS
    }, this._contextKeyService)), this._findInput.setRegex(!!this._state.isRegex), this._findInput.setCaseSensitive(!!this._state.matchCase), this._findInput.setWholeWords(!!this._state.wholeWord), this._register(this._findInput.onKeyDown((c) => this._onFindInputKeyDown(c))), this._register(this._findInput.inputBox.onDidChange(() => {
      this._ignoreChangeEvent || this._state.change({ searchString: this._findInput.getValue() }, !0);
    })), this._register(this._findInput.onDidOptionChange(() => {
      this._state.change({
        isRegex: this._findInput.getRegex(),
        wholeWord: this._findInput.getWholeWords(),
        matchCase: this._findInput.getCaseSensitive()
      }, !0);
    })), this._register(this._findInput.onCaseSensitiveKeyDown((c) => {
      c.equals(
        1026
        /* KeyCode.Tab */
      ) && this._isReplaceVisible && (this._replaceInput.focus(), c.preventDefault());
    })), this._register(this._findInput.onRegexKeyDown((c) => {
      c.equals(
        2
        /* KeyCode.Tab */
      ) && this._isReplaceVisible && (this._replaceInput.focusOnPreserve(), c.preventDefault());
    })), this._register(this._findInput.inputBox.onDidHeightChange((c) => {
      this._tryUpdateHeight() && this._showViewZone();
    })), os && this._register(this._findInput.onMouseDown((c) => this._onFindInputMouseDown(c))), this._matchesCount = document.createElement("div"), this._matchesCount.className = "matchesCount", this._updateMatchesCount();
    const i = this._register(np());
    this._prevBtn = this._register(new Dg({
      label: dge + this._keybindingLabelFor(Ht.PreviousMatchFindAction),
      icon: sge,
      hoverDelegate: i,
      onTrigger: () => {
        Xd(this._codeEditor.getAction(Ht.PreviousMatchFindAction)).run().then(void 0, He);
      }
    }, this._hoverService)), this._nextBtn = this._register(new Dg({
      label: cge + this._keybindingLabelFor(Ht.NextMatchFindAction),
      icon: oge,
      hoverDelegate: i,
      onTrigger: () => {
        Xd(this._codeEditor.getAction(Ht.NextMatchFindAction)).run().then(void 0, He);
      }
    }, this._hoverService));
    const n = document.createElement("div");
    n.className = "find-part", n.appendChild(this._findInput.domNode);
    const s = document.createElement("div");
    s.className = "find-actions", n.appendChild(s), s.appendChild(this._matchesCount), s.appendChild(this._prevBtn.domNode), s.appendChild(this._nextBtn.domNode), this._toggleSelectionFind = this._register(new Ap({
      icon: tge,
      title: hge + this._keybindingLabelFor(Ht.ToggleSearchScopeCommand),
      isChecked: !1,
      hoverDelegate: i,
      inputActiveOptionBackground: le(Gh),
      inputActiveOptionBorder: le(w1),
      inputActiveOptionForeground: le(S1)
    })), this._register(this._toggleSelectionFind.onChange(() => {
      if (this._toggleSelectionFind.checked) {
        if (this._codeEditor.hasModel()) {
          let c = this._codeEditor.getSelections();
          c = c.map((h) => (h.endColumn === 1 && h.endLineNumber > h.startLineNumber && (h = h.setEndPosition(h.endLineNumber - 1, this._codeEditor.getModel().getLineMaxColumn(h.endLineNumber - 1))), h.isEmpty() ? null : h)).filter((h) => !!h), c.length && this._state.change({ searchScope: c }, !0);
        }
      } else
        this._state.change({ searchScope: null }, !0);
    })), s.appendChild(this._toggleSelectionFind.domNode), this._closeBtn = this._register(new Dg({
      label: uge + this._keybindingLabelFor(Ht.CloseFindWidgetCommand),
      icon: b3,
      hoverDelegate: i,
      onTrigger: () => {
        this._state.change({ isRevealed: !1, searchScope: null }, !1);
      },
      onKeyDown: (c) => {
        c.equals(
          2
          /* KeyCode.Tab */
        ) && this._isReplaceVisible && (this._replaceBtn.isEnabled() ? this._replaceBtn.focus() : this._codeEditor.focus(), c.preventDefault());
      }
    }, this._hoverService)), this._replaceInput = this._register(new MT(null, void 0, {
      label: gge,
      placeholder: fge,
      appendPreserveCaseLabel: this._keybindingLabelFor(Ht.TogglePreserveCaseCommand),
      history: [],
      flexibleHeight: !0,
      flexibleWidth: !0,
      flexibleMaxHeight: 118,
      showHistoryHint: () => FW(this._keybindingService),
      inputBoxStyles: ZS,
      toggleStyles: GS
    }, this._contextKeyService, !0)), this._replaceInput.setPreserveCase(!!this._state.preserveCase), this._register(this._replaceInput.onKeyDown((c) => this._onReplaceInputKeyDown(c))), this._register(this._replaceInput.inputBox.onDidChange(() => {
      this._state.change({ replaceString: this._replaceInput.inputBox.value }, !1);
    })), this._register(this._replaceInput.inputBox.onDidHeightChange((c) => {
      this._isReplaceVisible && this._tryUpdateHeight() && this._showViewZone();
    })), this._register(this._replaceInput.onDidOptionChange(() => {
      this._state.change({
        preserveCase: this._replaceInput.getPreserveCase()
      }, !0);
    })), this._register(this._replaceInput.onPreserveCaseKeyDown((c) => {
      c.equals(
        2
        /* KeyCode.Tab */
      ) && (this._prevBtn.isEnabled() ? this._prevBtn.focus() : this._nextBtn.isEnabled() ? this._nextBtn.focus() : this._toggleSelectionFind.enabled ? this._toggleSelectionFind.focus() : this._closeBtn.isEnabled() && this._closeBtn.focus(), c.preventDefault());
    }));
    const o = this._register(np());
    this._replaceBtn = this._register(new Dg({
      label: pge + this._keybindingLabelFor(Ht.ReplaceOneAction),
      icon: ige,
      hoverDelegate: o,
      onTrigger: () => {
        this._controller.replace();
      },
      onKeyDown: (c) => {
        c.equals(
          1026
          /* KeyCode.Tab */
        ) && (this._closeBtn.focus(), c.preventDefault());
      }
    }, this._hoverService)), this._replaceAllBtn = this._register(new Dg({
      label: mge + this._keybindingLabelFor(Ht.ReplaceAllAction),
      icon: nge,
      hoverDelegate: o,
      onTrigger: () => {
        this._controller.replaceAll();
      }
    }, this._hoverService));
    const a = document.createElement("div");
    a.className = "replace-part", a.appendChild(this._replaceInput.domNode);
    const l = document.createElement("div");
    l.className = "replace-actions", a.appendChild(l), l.appendChild(this._replaceBtn.domNode), l.appendChild(this._replaceAllBtn.domNode), this._toggleReplaceBtn = this._register(new Dg({
      label: _ge,
      className: "codicon toggle left",
      onTrigger: () => {
        this._state.change({ isReplaceRevealed: !this._isReplaceVisible }, !1), this._isReplaceVisible && (this._replaceInput.width = Ms(this._findInput.domNode), this._replaceInput.inputBox.layout()), this._showViewZone();
      }
    }, this._hoverService)), this._toggleReplaceBtn.setExpanded(this._isReplaceVisible), this._domNode = document.createElement("div"), this._domNode.className = "editor-widget find-widget", this._domNode.setAttribute("aria-hidden", "true"), this._domNode.ariaLabel = rge, this._domNode.role = "dialog", this._domNode.style.width = `${va}px`, this._domNode.appendChild(this._toggleReplaceBtn.domNode), this._domNode.appendChild(n), this._domNode.appendChild(this._closeBtn.domNode), this._domNode.appendChild(a), this._resizeSash = this._register(new En(this._domNode, this, { orientation: 0, size: 2 })), this._resized = !1;
    let d = va;
    this._register(this._resizeSash.onDidStart(() => {
      d = Ms(this._domNode);
    })), this._register(this._resizeSash.onDidChange((c) => {
      this._resized = !0;
      const h = d + c.startX - c.currentX;
      if (h < va)
        return;
      const u = parseFloat(r0(this._domNode).maxWidth) || 0;
      h > u || (this._domNode.style.width = `${h}px`, this._isReplaceVisible && (this._replaceInput.width = Ms(this._findInput.domNode)), this._findInput.inputBox.layout(), this._tryUpdateHeight());
    })), this._register(this._resizeSash.onDidReset(() => {
      const c = Ms(this._domNode);
      if (c < va)
        return;
      let h = va;
      if (!this._resized || c === va) {
        const u = this._codeEditor.getLayoutInfo();
        h = u.width - 28 - u.minimap.minimapWidth - 15, this._resized = !0;
      }
      this._domNode.style.width = `${h}px`, this._isReplaceVisible && (this._replaceInput.width = Ms(this._findInput.domNode)), this._findInput.inputBox.layout();
    }));
  }
  updateAccessibilitySupport() {
    const e = this._codeEditor.getOption(
      2
      /* EditorOption.accessibilitySupport */
    );
    this._findInput.setFocusInputOnOptionClick(
      e !== 2
      /* AccessibilitySupport.Enabled */
    );
  }
}
FL.ID = "editor.contrib.findWidget";
class Dg extends bo {
  constructor(e, t) {
    var i;
    super(), this._opts = e;
    let n = "button";
    this._opts.className && (n = n + " " + this._opts.className), this._opts.icon && (n = n + " " + Le.asClassName(this._opts.icon)), this._domNode = document.createElement("div"), this._domNode.tabIndex = 0, this._domNode.className = n, this._domNode.setAttribute("role", "button"), this._domNode.setAttribute("aria-label", this._opts.label), this._register(t.setupUpdatableHover((i = e.hoverDelegate) !== null && i !== void 0 ? i : us("element"), this._domNode, this._opts.label)), this.onclick(this._domNode, (s) => {
      this._opts.onTrigger(), s.preventDefault();
    }), this.onkeydown(this._domNode, (s) => {
      var o, a;
      if (s.equals(
        10
        /* KeyCode.Space */
      ) || s.equals(
        3
        /* KeyCode.Enter */
      )) {
        this._opts.onTrigger(), s.preventDefault();
        return;
      }
      (a = (o = this._opts).onKeyDown) === null || a === void 0 || a.call(o, s);
    });
  }
  get domNode() {
    return this._domNode;
  }
  isEnabled() {
    return this._domNode.tabIndex >= 0;
  }
  focus() {
    this._domNode.focus();
  }
  setEnabled(e) {
    this._domNode.classList.toggle("disabled", !e), this._domNode.setAttribute("aria-disabled", String(!e)), this._domNode.tabIndex = e ? 0 : -1;
  }
  setExpanded(e) {
    this._domNode.setAttribute("aria-expanded", String(!!e)), e ? (this._domNode.classList.remove(...Le.asClassNameArray(WW)), this._domNode.classList.add(...Le.asClassNameArray(BW))) : (this._domNode.classList.remove(...Le.asClassNameArray(BW)), this._domNode.classList.add(...Le.asClassNameArray(WW)));
  }
}
Ho((r, e) => {
  const t = r.getColor(tc);
  t && e.addRule(`.monaco-editor .findMatch { border: 1px ${jr(r.type) ? "dotted" : "solid"} ${t}; box-sizing: border-box; }`);
  const i = r.getColor(xG);
  i && e.addRule(`.monaco-editor .findScope { border: 1px ${jr(r.type) ? "dashed" : "solid"} ${i}; }`);
  const n = r.getColor(it);
  n && e.addRule(`.monaco-editor .find-widget { border: 1px solid ${n}; }`);
  const s = r.getColor(DG);
  s && e.addRule(`.monaco-editor .findMatchInline { color: ${s}; }`);
  const o = r.getColor(kG);
  o && e.addRule(`.monaco-editor .currentFindMatchInline { color: ${o}; }`);
});
var O4 = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Do = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, RT;
const yge = 524288;
function AT(r, e = "single", t = !1) {
  if (!r.hasModel())
    return null;
  const i = r.getSelection();
  if (e === "single" && i.startLineNumber === i.endLineNumber || e === "multiple") {
    if (i.isEmpty()) {
      const n = r.getConfiguredWordAtPosition(i.getStartPosition());
      if (n && t === !1)
        return n.word;
    } else if (r.getModel().getValueLengthInRange(i) < yge)
      return r.getModel().getValueInRange(i);
  }
  return null;
}
let ds = RT = class extends P {
  get editor() {
    return this._editor;
  }
  static get(e) {
    return e.getContribution(RT.ID);
  }
  constructor(e, t, i, n, s, o) {
    super(), this._editor = e, this._findWidgetVisible = xd.bindTo(t), this._contextKeyService = t, this._storageService = i, this._clipboardService = n, this._notificationService = s, this._hoverService = o, this._updateHistoryDelayer = new pr(500), this._state = this._register(new Yue()), this.loadQueryState(), this._register(this._state.onFindReplaceStateChange((a) => this._onStateChanged(a))), this._model = null, this._register(this._editor.onDidChangeModel(() => {
      const a = this._editor.getModel() && this._state.isRevealed;
      this.disposeModel(), this._state.change({
        searchScope: null,
        matchCase: this._storageService.getBoolean("editor.matchCase", 1, !1),
        wholeWord: this._storageService.getBoolean("editor.wholeWord", 1, !1),
        isRegex: this._storageService.getBoolean("editor.isRegex", 1, !1),
        preserveCase: this._storageService.getBoolean("editor.preserveCase", 1, !1)
      }, !1), a && this._start({
        forceRevealReplace: !1,
        seedSearchStringFromSelection: "none",
        seedSearchStringFromNonEmptySelection: !1,
        seedSearchStringFromGlobalClipboard: !1,
        shouldFocus: 0,
        shouldAnimate: !1,
        updateSearchScope: !1,
        loop: this._editor.getOption(
          41
          /* EditorOption.find */
        ).loop
      });
    }));
  }
  dispose() {
    this.disposeModel(), super.dispose();
  }
  disposeModel() {
    this._model && (this._model.dispose(), this._model = null);
  }
  _onStateChanged(e) {
    this.saveQueryState(e), e.isRevealed && (this._state.isRevealed ? this._findWidgetVisible.set(!0) : (this._findWidgetVisible.reset(), this.disposeModel())), e.searchString && this.setGlobalBufferTerm(this._state.searchString);
  }
  saveQueryState(e) {
    e.isRegex && this._storageService.store(
      "editor.isRegex",
      this._state.actualIsRegex,
      1,
      1
      /* StorageTarget.MACHINE */
    ), e.wholeWord && this._storageService.store(
      "editor.wholeWord",
      this._state.actualWholeWord,
      1,
      1
      /* StorageTarget.MACHINE */
    ), e.matchCase && this._storageService.store(
      "editor.matchCase",
      this._state.actualMatchCase,
      1,
      1
      /* StorageTarget.MACHINE */
    ), e.preserveCase && this._storageService.store(
      "editor.preserveCase",
      this._state.actualPreserveCase,
      1,
      1
      /* StorageTarget.MACHINE */
    );
  }
  loadQueryState() {
    this._state.change({
      matchCase: this._storageService.getBoolean("editor.matchCase", 1, this._state.matchCase),
      wholeWord: this._storageService.getBoolean("editor.wholeWord", 1, this._state.wholeWord),
      isRegex: this._storageService.getBoolean("editor.isRegex", 1, this._state.isRegex),
      preserveCase: this._storageService.getBoolean("editor.preserveCase", 1, this._state.preserveCase)
    }, !1);
  }
  isFindInputFocused() {
    return !!PL.getValue(this._contextKeyService);
  }
  getState() {
    return this._state;
  }
  closeFindWidget() {
    this._state.change({
      isRevealed: !1,
      searchScope: null
    }, !1), this._editor.focus();
  }
  toggleCaseSensitive() {
    this._state.change({ matchCase: !this._state.matchCase }, !1), this._state.isRevealed || this.highlightFindOptions();
  }
  toggleWholeWords() {
    this._state.change({ wholeWord: !this._state.wholeWord }, !1), this._state.isRevealed || this.highlightFindOptions();
  }
  toggleRegex() {
    this._state.change({ isRegex: !this._state.isRegex }, !1), this._state.isRevealed || this.highlightFindOptions();
  }
  togglePreserveCase() {
    this._state.change({ preserveCase: !this._state.preserveCase }, !1), this._state.isRevealed || this.highlightFindOptions();
  }
  toggleSearchScope() {
    if (this._state.searchScope)
      this._state.change({ searchScope: null }, !0);
    else if (this._editor.hasModel()) {
      let e = this._editor.getSelections();
      e = e.map((t) => (t.endColumn === 1 && t.endLineNumber > t.startLineNumber && (t = t.setEndPosition(t.endLineNumber - 1, this._editor.getModel().getLineMaxColumn(t.endLineNumber - 1))), t.isEmpty() ? null : t)).filter((t) => !!t), e.length && this._state.change({ searchScope: e }, !0);
    }
  }
  setSearchString(e) {
    this._state.isRegex && (e = gr(e)), this._state.change({ searchString: e }, !1);
  }
  highlightFindOptions(e = !1) {
  }
  async _start(e, t) {
    if (this.disposeModel(), !this._editor.hasModel())
      return;
    const i = {
      ...t,
      isRevealed: !0
    };
    if (e.seedSearchStringFromSelection === "single") {
      const n = AT(this._editor, e.seedSearchStringFromSelection, e.seedSearchStringFromNonEmptySelection);
      n && (this._state.isRegex ? i.searchString = gr(n) : i.searchString = n);
    } else if (e.seedSearchStringFromSelection === "multiple" && !e.updateSearchScope) {
      const n = AT(this._editor, e.seedSearchStringFromSelection);
      n && (i.searchString = n);
    }
    if (!i.searchString && e.seedSearchStringFromGlobalClipboard) {
      const n = await this.getGlobalBufferTerm();
      if (!this._editor.hasModel())
        return;
      n && (i.searchString = n);
    }
    if (e.forceRevealReplace || i.isReplaceRevealed ? i.isReplaceRevealed = !0 : this._findWidgetVisible.get() || (i.isReplaceRevealed = !1), e.updateSearchScope) {
      const n = this._editor.getSelections();
      n.some((s) => !s.isEmpty()) && (i.searchScope = n);
    }
    i.loop = e.loop, this._state.change(i, !1), this._model || (this._model = new y_(this._editor, this._state));
  }
  start(e, t) {
    return this._start(e, t);
  }
  moveToNextMatch() {
    return this._model ? (this._model.moveToNextMatch(), !0) : !1;
  }
  moveToPrevMatch() {
    return this._model ? (this._model.moveToPrevMatch(), !0) : !1;
  }
  goToMatch(e) {
    return this._model ? (this._model.moveToMatch(e), !0) : !1;
  }
  replace() {
    return this._model ? (this._model.replace(), !0) : !1;
  }
  replaceAll() {
    var e;
    return this._model ? !((e = this._editor.getModel()) === null || e === void 0) && e.isTooLargeForHeapOperation() ? (this._notificationService.warn(p("too.large.for.replaceall", "The file is too large to perform a replace all operation.")), !1) : (this._model.replaceAll(), !0) : !1;
  }
  selectAllMatches() {
    return this._model ? (this._model.selectAllMatches(), this._editor.focus(), !0) : !1;
  }
  async getGlobalBufferTerm() {
    return this._editor.getOption(
      41
      /* EditorOption.find */
    ).globalFindClipboard && this._editor.hasModel() && !this._editor.getModel().isTooLargeForSyncing() ? this._clipboardService.readFindText() : "";
  }
  setGlobalBufferTerm(e) {
    this._editor.getOption(
      41
      /* EditorOption.find */
    ).globalFindClipboard && this._editor.hasModel() && !this._editor.getModel().isTooLargeForSyncing() && this._clipboardService.writeFindText(e);
  }
};
ds.ID = "editor.contrib.findController";
ds = RT = O4([
  Do(1, De),
  Do(2, br),
  Do(3, Dd),
  Do(4, xi),
  Do(5, gl)
], ds);
let PT = class extends ds {
  constructor(e, t, i, n, s, o, a, l, d) {
    super(e, i, a, l, o, d), this._contextViewService = t, this._keybindingService = n, this._themeService = s, this._widget = null, this._findOptionsWidget = null;
  }
  async _start(e, t) {
    this._widget || this._createFindWidget();
    const i = this._editor.getSelection();
    let n = !1;
    switch (this._editor.getOption(
      41
      /* EditorOption.find */
    ).autoFindInSelection) {
      case "always":
        n = !0;
        break;
      case "never":
        n = !1;
        break;
      case "multiline": {
        n = !!i && i.startLineNumber !== i.endLineNumber;
        break;
      }
    }
    e.updateSearchScope = e.updateSearchScope || n, await super._start(e, t), this._widget && (e.shouldFocus === 2 ? this._widget.focusReplaceInput() : e.shouldFocus === 1 && this._widget.focusFindInput());
  }
  highlightFindOptions(e = !1) {
    this._widget || this._createFindWidget(), this._state.isRevealed && !e ? this._widget.highlightFindOptions() : this._findOptionsWidget.highlightFindOptions();
  }
  _createFindWidget() {
    this._widget = this._register(new FL(this._editor, this, this._state, this._contextViewService, this._keybindingService, this._contextKeyService, this._themeService, this._storageService, this._notificationService, this._hoverService)), this._findOptionsWidget = this._register(new OL(this._editor, this._state, this._keybindingService));
  }
};
PT = O4([
  Do(1, Sd),
  Do(2, De),
  Do(3, _t),
  Do(4, $i),
  Do(5, xi),
  Do(6, br),
  Do(7, Dd),
  Do(8, gl)
], PT);
const Lge = nV(new iV({
  id: Ht.StartFindAction,
  label: p("startFindAction", "Find"),
  alias: "Find",
  precondition: U.or(x.focus, U.has("editorIsOpen")),
  kbOpts: {
    kbExpr: null,
    primary: 2084,
    weight: 100
    /* KeybindingWeight.EditorContrib */
  },
  menuOpts: {
    menuId: D.MenubarEditMenu,
    group: "3_find",
    title: p({ key: "miFind", comment: ["&& denotes a mnemonic"] }, "&&Find"),
    order: 1
  }
}));
Lge.addImplementation(0, (r, e, t) => {
  const i = ds.get(e);
  return i ? i.start({
    forceRevealReplace: !1,
    seedSearchStringFromSelection: e.getOption(
      41
      /* EditorOption.find */
    ).seedSearchStringFromSelection !== "never" ? "single" : "none",
    seedSearchStringFromNonEmptySelection: e.getOption(
      41
      /* EditorOption.find */
    ).seedSearchStringFromSelection === "selection",
    seedSearchStringFromGlobalClipboard: e.getOption(
      41
      /* EditorOption.find */
    ).globalFindClipboard,
    shouldFocus: 1,
    shouldAnimate: !0,
    updateSearchScope: !1,
    loop: e.getOption(
      41
      /* EditorOption.find */
    ).loop
  }) : !1;
});
const Dge = {
  description: "Open a new In-Editor Find Widget.",
  args: [{
    name: "Open a new In-Editor Find Widget args",
    schema: {
      properties: {
        searchString: { type: "string" },
        replaceString: { type: "string" },
        isRegex: { type: "boolean" },
        matchWholeWord: { type: "boolean" },
        isCaseSensitive: { type: "boolean" },
        preserveCase: { type: "boolean" },
        findInSelection: { type: "boolean" }
      }
    }
  }]
};
class kge extends ae {
  constructor() {
    super({
      id: Ht.StartFindWithArgs,
      label: p("startFindWithArgsAction", "Find With Arguments"),
      alias: "Find With Arguments",
      precondition: void 0,
      kbOpts: {
        kbExpr: null,
        primary: 0,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      metadata: Dge
    });
  }
  async run(e, t, i) {
    const n = ds.get(t);
    if (n) {
      const s = i ? {
        searchString: i.searchString,
        replaceString: i.replaceString,
        isReplaceRevealed: i.replaceString !== void 0,
        isRegex: i.isRegex,
        // isRegexOverride: args.regexOverride,
        wholeWord: i.matchWholeWord,
        // wholeWordOverride: args.wholeWordOverride,
        matchCase: i.isCaseSensitive,
        // matchCaseOverride: args.matchCaseOverride,
        preserveCase: i.preserveCase
        // preserveCaseOverride: args.preserveCaseOverride,
      } : {};
      await n.start({
        forceRevealReplace: !1,
        seedSearchStringFromSelection: n.getState().searchString.length === 0 && t.getOption(
          41
          /* EditorOption.find */
        ).seedSearchStringFromSelection !== "never" ? "single" : "none",
        seedSearchStringFromNonEmptySelection: t.getOption(
          41
          /* EditorOption.find */
        ).seedSearchStringFromSelection === "selection",
        seedSearchStringFromGlobalClipboard: !0,
        shouldFocus: 1,
        shouldAnimate: !0,
        updateSearchScope: (i == null ? void 0 : i.findInSelection) || !1,
        loop: t.getOption(
          41
          /* EditorOption.find */
        ).loop
      }, s), n.setGlobalBufferTerm(n.getState().searchString);
    }
  }
}
class xge extends ae {
  constructor() {
    super({
      id: Ht.StartFindWithSelection,
      label: p("startFindWithSelectionAction", "Find With Selection"),
      alias: "Find With Selection",
      precondition: void 0,
      kbOpts: {
        kbExpr: null,
        primary: 0,
        mac: {
          primary: 2083
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  async run(e, t) {
    const i = ds.get(t);
    i && (await i.start({
      forceRevealReplace: !1,
      seedSearchStringFromSelection: "multiple",
      seedSearchStringFromNonEmptySelection: !1,
      seedSearchStringFromGlobalClipboard: !1,
      shouldFocus: 0,
      shouldAnimate: !0,
      updateSearchScope: !1,
      loop: t.getOption(
        41
        /* EditorOption.find */
      ).loop
    }), i.setGlobalBufferTerm(i.getState().searchString));
  }
}
class F4 extends ae {
  async run(e, t) {
    const i = ds.get(t);
    i && !this._run(i) && (await i.start({
      forceRevealReplace: !1,
      seedSearchStringFromSelection: i.getState().searchString.length === 0 && t.getOption(
        41
        /* EditorOption.find */
      ).seedSearchStringFromSelection !== "never" ? "single" : "none",
      seedSearchStringFromNonEmptySelection: t.getOption(
        41
        /* EditorOption.find */
      ).seedSearchStringFromSelection === "selection",
      seedSearchStringFromGlobalClipboard: !0,
      shouldFocus: 0,
      shouldAnimate: !0,
      updateSearchScope: !1,
      loop: t.getOption(
        41
        /* EditorOption.find */
      ).loop
    }), this._run(i));
  }
}
class Ige extends F4 {
  constructor() {
    super({
      id: Ht.NextMatchFindAction,
      label: p("findNextMatchAction", "Find Next"),
      alias: "Find Next",
      precondition: void 0,
      kbOpts: [{
        kbExpr: x.focus,
        primary: 61,
        mac: { primary: 2085, secondary: [
          61
          /* KeyCode.F3 */
        ] },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }, {
        kbExpr: U.and(x.focus, PL),
        primary: 3,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }]
    });
  }
  _run(e) {
    return e.moveToNextMatch() ? (e.editor.pushUndoStop(), !0) : !1;
  }
}
class Ege extends F4 {
  constructor() {
    super({
      id: Ht.PreviousMatchFindAction,
      label: p("findPreviousMatchAction", "Find Previous"),
      alias: "Find Previous",
      precondition: void 0,
      kbOpts: [
        {
          kbExpr: x.focus,
          primary: 1085,
          mac: { primary: 3109, secondary: [
            1085
            /* KeyCode.F3 */
          ] },
          weight: 100
          /* KeybindingWeight.EditorContrib */
        },
        {
          kbExpr: U.and(x.focus, PL),
          primary: 1027,
          weight: 100
          /* KeybindingWeight.EditorContrib */
        }
      ]
    });
  }
  _run(e) {
    return e.moveToPrevMatch();
  }
}
class Tge extends ae {
  constructor() {
    super({
      id: Ht.GoToMatchFindAction,
      label: p("findMatchAction.goToMatch", "Go to Match..."),
      alias: "Go to Match...",
      precondition: xd
    }), this._highlightDecorations = [];
  }
  run(e, t, i) {
    const n = ds.get(t);
    if (!n)
      return;
    const s = n.getState().matchesCount;
    if (s < 1) {
      e.get(xi).notify({
        severity: F0.Warning,
        message: p("findMatchAction.noResults", "No matches. Try searching for something else.")
      });
      return;
    }
    const a = e.get($o).createInputBox();
    a.placeholder = p("findMatchAction.inputPlaceHolder", "Type a number to go to a specific match (between 1 and {0})", s);
    const l = (c) => {
      const h = parseInt(c);
      if (isNaN(h))
        return;
      const u = n.getState().matchesCount;
      if (h > 0 && h <= u)
        return h - 1;
      if (h < 0 && h >= -u)
        return u + h;
    }, d = (c) => {
      const h = l(c);
      if (typeof h == "number") {
        a.validationMessage = void 0, n.goToMatch(h);
        const u = n.getState().currentMatch;
        u && this.addDecorations(t, u);
      } else
        a.validationMessage = p("findMatchAction.inputValidationMessage", "Please type a number between 1 and {0}", n.getState().matchesCount), this.clearDecorations(t);
    };
    a.onDidChangeValue((c) => {
      d(c);
    }), a.onDidAccept(() => {
      const c = l(a.value);
      typeof c == "number" ? (n.goToMatch(c), a.hide()) : a.validationMessage = p("findMatchAction.inputValidationMessage", "Please type a number between 1 and {0}", n.getState().matchesCount);
    }), a.onDidHide(() => {
      this.clearDecorations(t), a.dispose();
    }), a.show();
  }
  clearDecorations(e) {
    e.changeDecorations((t) => {
      this._highlightDecorations = t.deltaDecorations(this._highlightDecorations, []);
    });
  }
  addDecorations(e, t) {
    e.changeDecorations((i) => {
      this._highlightDecorations = i.deltaDecorations(this._highlightDecorations, [
        {
          range: t,
          options: {
            description: "find-match-quick-access-range-highlight",
            className: "rangeHighlight",
            isWholeLine: !0
          }
        },
        {
          range: t,
          options: {
            description: "find-match-quick-access-range-highlight-overview",
            overviewRuler: {
              color: ai(GV),
              position: _r.Full
            }
          }
        }
      ]);
    });
  }
}
class W4 extends ae {
  async run(e, t) {
    const i = ds.get(t);
    if (!i)
      return;
    const n = AT(t, "single", !1);
    n && i.setSearchString(n), this._run(i) || (await i.start({
      forceRevealReplace: !1,
      seedSearchStringFromSelection: "none",
      seedSearchStringFromNonEmptySelection: !1,
      seedSearchStringFromGlobalClipboard: !1,
      shouldFocus: 0,
      shouldAnimate: !0,
      updateSearchScope: !1,
      loop: t.getOption(
        41
        /* EditorOption.find */
      ).loop
    }), this._run(i));
  }
}
class Nge extends W4 {
  constructor() {
    super({
      id: Ht.NextSelectionMatchFindAction,
      label: p("nextSelectionMatchFindAction", "Find Next Selection"),
      alias: "Find Next Selection",
      precondition: void 0,
      kbOpts: {
        kbExpr: x.focus,
        primary: 2109,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  _run(e) {
    return e.moveToNextMatch();
  }
}
class Mge extends W4 {
  constructor() {
    super({
      id: Ht.PreviousSelectionMatchFindAction,
      label: p("previousSelectionMatchFindAction", "Find Previous Selection"),
      alias: "Find Previous Selection",
      precondition: void 0,
      kbOpts: {
        kbExpr: x.focus,
        primary: 3133,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  _run(e) {
    return e.moveToPrevMatch();
  }
}
const Rge = nV(new iV({
  id: Ht.StartFindReplaceAction,
  label: p("startReplace", "Replace"),
  alias: "Replace",
  precondition: U.or(x.focus, U.has("editorIsOpen")),
  kbOpts: {
    kbExpr: null,
    primary: 2086,
    mac: {
      primary: 2596
      /* KeyCode.KeyF */
    },
    weight: 100
    /* KeybindingWeight.EditorContrib */
  },
  menuOpts: {
    menuId: D.MenubarEditMenu,
    group: "3_find",
    title: p({ key: "miReplace", comment: ["&& denotes a mnemonic"] }, "&&Replace"),
    order: 2
  }
}));
Rge.addImplementation(0, (r, e, t) => {
  if (!e.hasModel() || e.getOption(
    91
    /* EditorOption.readOnly */
  ))
    return !1;
  const i = ds.get(e);
  if (!i)
    return !1;
  const n = e.getSelection(), s = i.isFindInputFocused(), o = !n.isEmpty() && n.startLineNumber === n.endLineNumber && e.getOption(
    41
    /* EditorOption.find */
  ).seedSearchStringFromSelection !== "never" && !s, a = s || o ? 2 : 1;
  return i.start({
    forceRevealReplace: !0,
    seedSearchStringFromSelection: o ? "single" : "none",
    seedSearchStringFromNonEmptySelection: e.getOption(
      41
      /* EditorOption.find */
    ).seedSearchStringFromSelection === "selection",
    seedSearchStringFromGlobalClipboard: e.getOption(
      41
      /* EditorOption.find */
    ).seedSearchStringFromSelection !== "never",
    shouldFocus: a,
    shouldAnimate: !0,
    updateSearchScope: !1,
    loop: e.getOption(
      41
      /* EditorOption.find */
    ).loop
  });
});
gt(
  ds.ID,
  PT,
  0
  /* EditorContributionInstantiation.Eager */
);
Y(kge);
Y(xge);
Y(Ige);
Y(Ege);
Y(Tge);
Y(Nge);
Y(Mge);
const ca = Ui.bindToContribution(ds.get);
se(new ca({
  id: Ht.CloseFindWidgetCommand,
  precondition: xd,
  handler: (r) => r.closeFindWidget(),
  kbOpts: {
    weight: 105,
    kbExpr: U.and(x.focus, U.not("isComposing")),
    primary: 9,
    secondary: [
      1033
      /* KeyCode.Escape */
    ]
  }
}));
se(new ca({
  id: Ht.ToggleCaseSensitiveCommand,
  precondition: void 0,
  handler: (r) => r.toggleCaseSensitive(),
  kbOpts: {
    weight: 105,
    kbExpr: x.focus,
    primary: iw.primary,
    mac: iw.mac,
    win: iw.win,
    linux: iw.linux
  }
}));
se(new ca({
  id: Ht.ToggleWholeWordCommand,
  precondition: void 0,
  handler: (r) => r.toggleWholeWords(),
  kbOpts: {
    weight: 105,
    kbExpr: x.focus,
    primary: nw.primary,
    mac: nw.mac,
    win: nw.win,
    linux: nw.linux
  }
}));
se(new ca({
  id: Ht.ToggleRegexCommand,
  precondition: void 0,
  handler: (r) => r.toggleRegex(),
  kbOpts: {
    weight: 105,
    kbExpr: x.focus,
    primary: sw.primary,
    mac: sw.mac,
    win: sw.win,
    linux: sw.linux
  }
}));
se(new ca({
  id: Ht.ToggleSearchScopeCommand,
  precondition: void 0,
  handler: (r) => r.toggleSearchScope(),
  kbOpts: {
    weight: 105,
    kbExpr: x.focus,
    primary: ow.primary,
    mac: ow.mac,
    win: ow.win,
    linux: ow.linux
  }
}));
se(new ca({
  id: Ht.TogglePreserveCaseCommand,
  precondition: void 0,
  handler: (r) => r.togglePreserveCase(),
  kbOpts: {
    weight: 105,
    kbExpr: x.focus,
    primary: rw.primary,
    mac: rw.mac,
    win: rw.win,
    linux: rw.linux
  }
}));
se(new ca({
  id: Ht.ReplaceOneAction,
  precondition: xd,
  handler: (r) => r.replace(),
  kbOpts: {
    weight: 105,
    kbExpr: x.focus,
    primary: 3094
    /* KeyCode.Digit1 */
  }
}));
se(new ca({
  id: Ht.ReplaceOneAction,
  precondition: xd,
  handler: (r) => r.replace(),
  kbOpts: {
    weight: 105,
    kbExpr: U.and(x.focus, CR),
    primary: 3
    /* KeyCode.Enter */
  }
}));
se(new ca({
  id: Ht.ReplaceAllAction,
  precondition: xd,
  handler: (r) => r.replaceAll(),
  kbOpts: {
    weight: 105,
    kbExpr: x.focus,
    primary: 2563
    /* KeyCode.Enter */
  }
}));
se(new ca({
  id: Ht.ReplaceAllAction,
  precondition: xd,
  handler: (r) => r.replaceAll(),
  kbOpts: {
    weight: 105,
    kbExpr: U.and(x.focus, CR),
    primary: void 0,
    mac: {
      primary: 2051
    }
  }
}));
se(new ca({
  id: Ht.SelectAllMatchesAction,
  precondition: xd,
  handler: (r) => r.selectAllMatches(),
  kbOpts: {
    weight: 105,
    kbExpr: x.focus,
    primary: 515
    /* KeyCode.Enter */
  }
}));
const Age = {
  0: " ",
  1: "u",
  2: "r"
}, KW = 65535, Mr = 16777215, jW = 4278190080;
class Jk {
  constructor(e) {
    const t = Math.ceil(e / 32);
    this._states = new Uint32Array(t);
  }
  get(e) {
    const t = e / 32 | 0, i = e % 32;
    return (this._states[t] & 1 << i) !== 0;
  }
  set(e, t) {
    const i = e / 32 | 0, n = e % 32, s = this._states[i];
    t ? this._states[i] = s | 1 << n : this._states[i] = s & ~(1 << n);
  }
}
class oo {
  constructor(e, t, i) {
    if (e.length !== t.length || e.length > KW)
      throw new Error("invalid startIndexes or endIndexes size");
    this._startIndexes = e, this._endIndexes = t, this._collapseStates = new Jk(e.length), this._userDefinedStates = new Jk(e.length), this._recoveredStates = new Jk(e.length), this._types = i, this._parentsComputed = !1;
  }
  ensureParentIndices() {
    if (!this._parentsComputed) {
      this._parentsComputed = !0;
      const e = [], t = (i, n) => {
        const s = e[e.length - 1];
        return this.getStartLineNumber(s) <= i && this.getEndLineNumber(s) >= n;
      };
      for (let i = 0, n = this._startIndexes.length; i < n; i++) {
        const s = this._startIndexes[i], o = this._endIndexes[i];
        if (s > Mr || o > Mr)
          throw new Error("startLineNumber or endLineNumber must not exceed " + Mr);
        for (; e.length > 0 && !t(s, o); )
          e.pop();
        const a = e.length > 0 ? e[e.length - 1] : -1;
        e.push(i), this._startIndexes[i] = s + ((a & 255) << 24), this._endIndexes[i] = o + ((a & 65280) << 16);
      }
    }
  }
  get length() {
    return this._startIndexes.length;
  }
  getStartLineNumber(e) {
    return this._startIndexes[e] & Mr;
  }
  getEndLineNumber(e) {
    return this._endIndexes[e] & Mr;
  }
  getType(e) {
    return this._types ? this._types[e] : void 0;
  }
  hasTypes() {
    return !!this._types;
  }
  isCollapsed(e) {
    return this._collapseStates.get(e);
  }
  setCollapsed(e, t) {
    this._collapseStates.set(e, t);
  }
  isUserDefined(e) {
    return this._userDefinedStates.get(e);
  }
  setUserDefined(e, t) {
    return this._userDefinedStates.set(e, t);
  }
  isRecovered(e) {
    return this._recoveredStates.get(e);
  }
  setRecovered(e, t) {
    return this._recoveredStates.set(e, t);
  }
  getSource(e) {
    return this.isUserDefined(e) ? 1 : this.isRecovered(e) ? 2 : 0;
  }
  setSource(e, t) {
    t === 1 ? (this.setUserDefined(e, !0), this.setRecovered(e, !1)) : t === 2 ? (this.setUserDefined(e, !1), this.setRecovered(e, !0)) : (this.setUserDefined(e, !1), this.setRecovered(e, !1));
  }
  setCollapsedAllOfType(e, t) {
    let i = !1;
    if (this._types)
      for (let n = 0; n < this._types.length; n++)
        this._types[n] === e && (this.setCollapsed(n, t), i = !0);
    return i;
  }
  toRegion(e) {
    return new Pge(this, e);
  }
  getParentIndex(e) {
    this.ensureParentIndices();
    const t = ((this._startIndexes[e] & jW) >>> 24) + ((this._endIndexes[e] & jW) >>> 16);
    return t === KW ? -1 : t;
  }
  contains(e, t) {
    return this.getStartLineNumber(e) <= t && this.getEndLineNumber(e) >= t;
  }
  findIndex(e) {
    let t = 0, i = this._startIndexes.length;
    if (i === 0)
      return -1;
    for (; t < i; ) {
      const n = Math.floor((t + i) / 2);
      e < this.getStartLineNumber(n) ? i = n : t = n + 1;
    }
    return t - 1;
  }
  findRange(e) {
    let t = this.findIndex(e);
    if (t >= 0) {
      if (this.getEndLineNumber(t) >= e)
        return t;
      for (t = this.getParentIndex(t); t !== -1; ) {
        if (this.contains(t, e))
          return t;
        t = this.getParentIndex(t);
      }
    }
    return -1;
  }
  toString() {
    const e = [];
    for (let t = 0; t < this.length; t++)
      e[t] = `[${Age[this.getSource(t)]}${this.isCollapsed(t) ? "+" : "-"}] ${this.getStartLineNumber(t)}/${this.getEndLineNumber(t)}`;
    return e.join(", ");
  }
  toFoldRange(e) {
    return {
      startLineNumber: this._startIndexes[e] & Mr,
      endLineNumber: this._endIndexes[e] & Mr,
      type: this._types ? this._types[e] : void 0,
      isCollapsed: this.isCollapsed(e),
      source: this.getSource(e)
    };
  }
  static fromFoldRanges(e) {
    const t = e.length, i = new Uint32Array(t), n = new Uint32Array(t);
    let s = [], o = !1;
    for (let l = 0; l < t; l++) {
      const d = e[l];
      i[l] = d.startLineNumber, n[l] = d.endLineNumber, s.push(d.type), d.type && (o = !0);
    }
    o || (s = void 0);
    const a = new oo(i, n, s);
    for (let l = 0; l < t; l++)
      e[l].isCollapsed && a.setCollapsed(l, !0), a.setSource(l, e[l].source);
    return a;
  }
  /**
   * Two inputs, each a FoldingRegions or a FoldRange[], are merged.
   * Each input must be pre-sorted on startLineNumber.
   * The first list is assumed to always include all regions currently defined by range providers.
   * The second list only contains the previously collapsed and all manual ranges.
   * If the line position matches, the range of the new range is taken, and the range is no longer manual
   * When an entry in one list overlaps an entry in the other, the second list's entry "wins" and
   * overlapping entries in the first list are discarded.
   * Invalid entries are discarded. An entry is invalid if:
   * 		the start and end line numbers aren't a valid range of line numbers,
   * 		it is out of sequence or has the same start line as a preceding entry,
   * 		it overlaps a preceding entry and is not fully contained by that entry.
   */
  static sanitizeAndMerge(e, t, i) {
    i = i ?? Number.MAX_VALUE;
    const n = (m, _) => Array.isArray(m) ? (v) => v < _ ? m[v] : void 0 : (v) => v < _ ? m.toFoldRange(v) : void 0, s = n(e, e.length), o = n(t, t.length);
    let a = 0, l = 0, d = s(0), c = o(0);
    const h = [];
    let u, g = 0;
    const f = [];
    for (; d || c; ) {
      let m;
      if (c && (!d || d.startLineNumber >= c.startLineNumber))
        d && d.startLineNumber === c.startLineNumber ? (c.source === 1 ? m = c : (m = d, m.isCollapsed = c.isCollapsed && d.endLineNumber === c.endLineNumber, m.source = 0), d = s(++a)) : (m = c, c.isCollapsed && c.source === 0 && (m.source = 2)), c = o(++l);
      else {
        let _ = l, v = c;
        for (; ; ) {
          if (!v || v.startLineNumber > d.endLineNumber) {
            m = d;
            break;
          }
          if (v.source === 1 && v.endLineNumber > d.endLineNumber)
            break;
          v = o(++_);
        }
        d = s(++a);
      }
      if (m) {
        for (; u && u.endLineNumber < m.startLineNumber; )
          u = h.pop();
        m.endLineNumber > m.startLineNumber && m.startLineNumber > g && m.endLineNumber <= i && (!u || u.endLineNumber >= m.endLineNumber) && (f.push(m), g = m.startLineNumber, u && h.push(u), u = m);
      }
    }
    return f;
  }
}
class Pge {
  constructor(e, t) {
    this.ranges = e, this.index = t;
  }
  get startLineNumber() {
    return this.ranges.getStartLineNumber(this.index);
  }
  get endLineNumber() {
    return this.ranges.getEndLineNumber(this.index);
  }
  get regionIndex() {
    return this.index;
  }
  get parentIndex() {
    return this.ranges.getParentIndex(this.index);
  }
  get isCollapsed() {
    return this.ranges.isCollapsed(this.index);
  }
  containedBy(e) {
    return e.startLineNumber <= this.startLineNumber && e.endLineNumber >= this.endLineNumber;
  }
  containsLine(e) {
    return this.startLineNumber <= e && e <= this.endLineNumber;
  }
}
class Oge {
  get regions() {
    return this._regions;
  }
  get textModel() {
    return this._textModel;
  }
  constructor(e, t) {
    this._updateEventEmitter = new R(), this.onDidChange = this._updateEventEmitter.event, this._textModel = e, this._decorationProvider = t, this._regions = new oo(new Uint32Array(0), new Uint32Array(0)), this._editorDecorationIds = [];
  }
  toggleCollapseState(e) {
    if (!e.length)
      return;
    e = e.sort((i, n) => i.regionIndex - n.regionIndex);
    const t = {};
    this._decorationProvider.changeDecorations((i) => {
      let n = 0, s = -1, o = -1;
      const a = (l) => {
        for (; n < l; ) {
          const d = this._regions.getEndLineNumber(n), c = this._regions.isCollapsed(n);
          if (d <= s) {
            const h = this.regions.getSource(n) !== 0;
            i.changeDecorationOptions(this._editorDecorationIds[n], this._decorationProvider.getDecorationOption(c, d <= o, h));
          }
          c && d > o && (o = d), n++;
        }
      };
      for (const l of e) {
        const d = l.regionIndex, c = this._editorDecorationIds[d];
        if (c && !t[c]) {
          t[c] = !0, a(d);
          const h = !this._regions.isCollapsed(d);
          this._regions.setCollapsed(d, h), s = Math.max(s, this._regions.getEndLineNumber(d));
        }
      }
      a(this._regions.length);
    }), this._updateEventEmitter.fire({ model: this, collapseStateChanged: e });
  }
  removeManualRanges(e) {
    const t = new Array(), i = (n) => {
      for (const s of e)
        if (!(s.startLineNumber > n.endLineNumber || n.startLineNumber > s.endLineNumber))
          return !0;
      return !1;
    };
    for (let n = 0; n < this._regions.length; n++) {
      const s = this._regions.toFoldRange(n);
      (s.source === 0 || !i(s)) && t.push(s);
    }
    this.updatePost(oo.fromFoldRanges(t));
  }
  update(e, t = []) {
    const i = this._currentFoldedOrManualRanges(t), n = oo.sanitizeAndMerge(e, i, this._textModel.getLineCount());
    this.updatePost(oo.fromFoldRanges(n));
  }
  updatePost(e) {
    const t = [];
    let i = -1;
    for (let n = 0, s = e.length; n < s; n++) {
      const o = e.getStartLineNumber(n), a = e.getEndLineNumber(n), l = e.isCollapsed(n), d = e.getSource(n) !== 0, c = {
        startLineNumber: o,
        startColumn: this._textModel.getLineMaxColumn(o),
        endLineNumber: a,
        endColumn: this._textModel.getLineMaxColumn(a) + 1
      };
      t.push({ range: c, options: this._decorationProvider.getDecorationOption(l, a <= i, d) }), l && a > i && (i = a);
    }
    this._decorationProvider.changeDecorations((n) => this._editorDecorationIds = n.deltaDecorations(this._editorDecorationIds, t)), this._regions = e, this._updateEventEmitter.fire({ model: this });
  }
  _currentFoldedOrManualRanges(e = []) {
    const t = (n, s) => {
      for (const o of e)
        if (n < o && o <= s)
          return !0;
      return !1;
    }, i = [];
    for (let n = 0, s = this._regions.length; n < s; n++) {
      let o = this.regions.isCollapsed(n);
      const a = this.regions.getSource(n);
      if (o || a !== 0) {
        const l = this._regions.toFoldRange(n), d = this._textModel.getDecorationRange(this._editorDecorationIds[n]);
        d && (o && t(d.startLineNumber, d.endLineNumber) && (o = !1), i.push({
          startLineNumber: d.startLineNumber,
          endLineNumber: d.endLineNumber,
          type: l.type,
          isCollapsed: o,
          source: a
        }));
      }
    }
    return i;
  }
  /**
   * Collapse state memento, for persistence only
   */
  getMemento() {
    const e = this._currentFoldedOrManualRanges(), t = [], i = this._textModel.getLineCount();
    for (let n = 0, s = e.length; n < s; n++) {
      const o = e[n];
      if (o.startLineNumber >= o.endLineNumber || o.startLineNumber < 1 || o.endLineNumber > i)
        continue;
      const a = this._getLinesChecksum(o.startLineNumber + 1, o.endLineNumber);
      t.push({
        startLineNumber: o.startLineNumber,
        endLineNumber: o.endLineNumber,
        isCollapsed: o.isCollapsed,
        source: o.source,
        checksum: a
      });
    }
    return t.length > 0 ? t : void 0;
  }
  /**
   * Apply persisted state, for persistence only
   */
  applyMemento(e) {
    var t, i;
    if (!Array.isArray(e))
      return;
    const n = [], s = this._textModel.getLineCount();
    for (const a of e) {
      if (a.startLineNumber >= a.endLineNumber || a.startLineNumber < 1 || a.endLineNumber > s)
        continue;
      const l = this._getLinesChecksum(a.startLineNumber + 1, a.endLineNumber);
      (!a.checksum || l === a.checksum) && n.push({
        startLineNumber: a.startLineNumber,
        endLineNumber: a.endLineNumber,
        type: void 0,
        isCollapsed: (t = a.isCollapsed) !== null && t !== void 0 ? t : !0,
        source: (i = a.source) !== null && i !== void 0 ? i : 0
        /* FoldSource.provider */
      });
    }
    const o = oo.sanitizeAndMerge(this._regions, n, s);
    this.updatePost(oo.fromFoldRanges(o));
  }
  _getLinesChecksum(e, t) {
    return Xy(this._textModel.getLineContent(e) + this._textModel.getLineContent(t)) % 1e6;
  }
  dispose() {
    this._decorationProvider.removeDecorations(this._editorDecorationIds);
  }
  getAllRegionsAtLine(e, t) {
    const i = [];
    if (this._regions) {
      let n = this._regions.findRange(e), s = 1;
      for (; n >= 0; ) {
        const o = this._regions.toRegion(n);
        (!t || t(o, s)) && i.push(o), s++, n = o.parentIndex;
      }
    }
    return i;
  }
  getRegionAtLine(e) {
    if (this._regions) {
      const t = this._regions.findRange(e);
      if (t >= 0)
        return this._regions.toRegion(t);
    }
    return null;
  }
  getRegionsInside(e, t) {
    const i = [], n = e ? e.regionIndex + 1 : 0, s = e ? e.endLineNumber : Number.MAX_VALUE;
    if (t && t.length === 2) {
      const o = [];
      for (let a = n, l = this._regions.length; a < l; a++) {
        const d = this._regions.toRegion(a);
        if (this._regions.getStartLineNumber(a) < s) {
          for (; o.length > 0 && !d.containedBy(o[o.length - 1]); )
            o.pop();
          o.push(d), t(d, o.length) && i.push(d);
        } else
          break;
      }
    } else
      for (let o = n, a = this._regions.length; o < a; o++) {
        const l = this._regions.toRegion(o);
        if (this._regions.getStartLineNumber(o) < s)
          (!t || t(l)) && i.push(l);
        else
          break;
      }
    return i;
  }
}
function B4(r, e, t) {
  const i = [];
  for (const n of t) {
    const s = r.getRegionAtLine(n);
    if (s) {
      const o = !s.isCollapsed;
      if (i.push(s), e > 1) {
        const a = r.getRegionsInside(s, (l, d) => l.isCollapsed !== o && d < e);
        i.push(...a);
      }
    }
  }
  r.toggleCollapseState(i);
}
function zp(r, e, t = Number.MAX_VALUE, i) {
  const n = [];
  if (i && i.length > 0)
    for (const s of i) {
      const o = r.getRegionAtLine(s);
      if (o && (o.isCollapsed !== e && n.push(o), t > 1)) {
        const a = r.getRegionsInside(o, (l, d) => l.isCollapsed !== e && d < t);
        n.push(...a);
      }
    }
  else {
    const s = r.getRegionsInside(null, (o, a) => o.isCollapsed !== e && a < t);
    n.push(...s);
  }
  r.toggleCollapseState(n);
}
function H4(r, e, t, i) {
  const n = [];
  for (const s of i) {
    const o = r.getAllRegionsAtLine(s, (a, l) => a.isCollapsed !== e && l <= t);
    n.push(...o);
  }
  r.toggleCollapseState(n);
}
function Fge(r, e, t) {
  const i = [];
  for (const n of t) {
    const s = r.getAllRegionsAtLine(n, (o) => o.isCollapsed !== e);
    s.length > 0 && i.push(s[0]);
  }
  r.toggleCollapseState(i);
}
function Wge(r, e, t, i) {
  const n = (o, a) => a === e && o.isCollapsed !== t && !i.some((l) => o.containsLine(l)), s = r.getRegionsInside(null, n);
  r.toggleCollapseState(s);
}
function V4(r, e, t) {
  const i = [];
  for (const o of t) {
    const a = r.getAllRegionsAtLine(o, void 0);
    a.length > 0 && i.push(a[0]);
  }
  const n = (o) => i.every((a) => !a.containedBy(o) && !o.containedBy(a)) && o.isCollapsed !== e, s = r.getRegionsInside(null, n);
  r.toggleCollapseState(s);
}
function yR(r, e, t) {
  const i = r.textModel, n = r.regions, s = [];
  for (let o = n.length - 1; o >= 0; o--)
    if (t !== n.isCollapsed(o)) {
      const a = n.getStartLineNumber(o);
      e.test(i.getLineContent(a)) && s.push(n.toRegion(o));
    }
  r.toggleCollapseState(s);
}
function LR(r, e, t) {
  const i = r.regions, n = [];
  for (let s = i.length - 1; s >= 0; s--)
    t !== i.isCollapsed(s) && e === i.getType(s) && n.push(i.toRegion(s));
  r.toggleCollapseState(n);
}
function Bge(r, e) {
  let t = null;
  const i = e.getRegionAtLine(r);
  if (i !== null && (t = i.startLineNumber, r === t)) {
    const n = i.parentIndex;
    n !== -1 ? t = e.regions.getStartLineNumber(n) : t = null;
  }
  return t;
}
function Hge(r, e) {
  let t = e.getRegionAtLine(r);
  if (t !== null && t.startLineNumber === r) {
    if (r !== t.startLineNumber)
      return t.startLineNumber;
    {
      const i = t.parentIndex;
      let n = 0;
      for (i !== -1 && (n = e.regions.getStartLineNumber(t.parentIndex)); t !== null; )
        if (t.regionIndex > 0) {
          if (t = e.regions.toRegion(t.regionIndex - 1), t.startLineNumber <= n)
            return null;
          if (t.parentIndex === i)
            return t.startLineNumber;
        } else
          return null;
    }
  } else if (e.regions.length > 0)
    for (t = e.regions.toRegion(e.regions.length - 1); t !== null; ) {
      if (t.startLineNumber < r)
        return t.startLineNumber;
      t.regionIndex > 0 ? t = e.regions.toRegion(t.regionIndex - 1) : t = null;
    }
  return null;
}
function Vge(r, e) {
  let t = e.getRegionAtLine(r);
  if (t !== null && t.startLineNumber === r) {
    const i = t.parentIndex;
    let n = 0;
    if (i !== -1)
      n = e.regions.getEndLineNumber(t.parentIndex);
    else {
      if (e.regions.length === 0)
        return null;
      n = e.regions.getEndLineNumber(e.regions.length - 1);
    }
    for (; t !== null; )
      if (t.regionIndex < e.regions.length) {
        if (t = e.regions.toRegion(t.regionIndex + 1), t.startLineNumber >= n)
          return null;
        if (t.parentIndex === i)
          return t.startLineNumber;
      } else
        return null;
  } else if (e.regions.length > 0)
    for (t = e.regions.toRegion(0); t !== null; ) {
      if (t.startLineNumber > r)
        return t.startLineNumber;
      t.regionIndex < e.regions.length ? t = e.regions.toRegion(t.regionIndex + 1) : t = null;
    }
  return null;
}
class zge {
  get onDidChange() {
    return this._updateEventEmitter.event;
  }
  get hiddenRanges() {
    return this._hiddenRanges;
  }
  constructor(e) {
    this._updateEventEmitter = new R(), this._hasLineChanges = !1, this._foldingModel = e, this._foldingModelListener = e.onDidChange((t) => this.updateHiddenRanges()), this._hiddenRanges = [], e.regions.length && this.updateHiddenRanges();
  }
  notifyChangeModelContent(e) {
    this._hiddenRanges.length && !this._hasLineChanges && (this._hasLineChanges = e.changes.some((t) => t.range.endLineNumber !== t.range.startLineNumber || Oc(t.text)[0] !== 0));
  }
  updateHiddenRanges() {
    let e = !1;
    const t = [];
    let i = 0, n = 0, s = Number.MAX_VALUE, o = -1;
    const a = this._foldingModel.regions;
    for (; i < a.length; i++) {
      if (!a.isCollapsed(i))
        continue;
      const l = a.getStartLineNumber(i) + 1, d = a.getEndLineNumber(i);
      s <= l && d <= o || (!e && n < this._hiddenRanges.length && this._hiddenRanges[n].startLineNumber === l && this._hiddenRanges[n].endLineNumber === d ? (t.push(this._hiddenRanges[n]), n++) : (e = !0, t.push(new L(l, 1, d, 1))), s = l, o = d);
    }
    (this._hasLineChanges || e || n < this._hiddenRanges.length) && this.applyHiddenRanges(t);
  }
  applyHiddenRanges(e) {
    this._hiddenRanges = e, this._hasLineChanges = !1, this._updateEventEmitter.fire(e);
  }
  hasRanges() {
    return this._hiddenRanges.length > 0;
  }
  isHidden(e) {
    return qW(this._hiddenRanges, e) !== null;
  }
  adjustSelections(e) {
    let t = !1;
    const i = this._foldingModel.textModel;
    let n = null;
    const s = (o) => ((!n || !Uge(o, n)) && (n = qW(this._hiddenRanges, o)), n ? n.startLineNumber - 1 : null);
    for (let o = 0, a = e.length; o < a; o++) {
      let l = e[o];
      const d = s(l.startLineNumber);
      d && (l = l.setStartPosition(d, i.getLineMaxColumn(d)), t = !0);
      const c = s(l.endLineNumber);
      c && (l = l.setEndPosition(c, i.getLineMaxColumn(c)), t = !0), e[o] = l;
    }
    return t;
  }
  dispose() {
    this.hiddenRanges.length > 0 && (this._hiddenRanges = [], this._updateEventEmitter.fire(this._hiddenRanges)), this._foldingModelListener && (this._foldingModelListener.dispose(), this._foldingModelListener = null);
  }
}
function Uge(r, e) {
  return r >= e.startLineNumber && r <= e.endLineNumber;
}
function qW(r, e) {
  const t = vH(r, (i) => e < i.startLineNumber) - 1;
  return t >= 0 && r[t].endLineNumber >= e ? r[t] : null;
}
const $ge = 5e3, Kge = "indent";
class DR {
  constructor(e, t, i) {
    this.editorModel = e, this.languageConfigurationService = t, this.foldingRangesLimit = i, this.id = Kge;
  }
  dispose() {
  }
  compute(e) {
    const t = this.languageConfigurationService.getLanguageConfiguration(this.editorModel.getLanguageId()).foldingRules, i = t && !!t.offSide, n = t && t.markers;
    return Promise.resolve(Gge(this.editorModel, i, n, this.foldingRangesLimit));
  }
}
let jge = class {
  constructor(e) {
    this._startIndexes = [], this._endIndexes = [], this._indentOccurrences = [], this._length = 0, this._foldingRangesLimit = e;
  }
  insertFirst(e, t, i) {
    if (e > Mr || t > Mr)
      return;
    const n = this._length;
    this._startIndexes[n] = e, this._endIndexes[n] = t, this._length++, i < 1e3 && (this._indentOccurrences[i] = (this._indentOccurrences[i] || 0) + 1);
  }
  toIndentRanges(e) {
    const t = this._foldingRangesLimit.limit;
    if (this._length <= t) {
      this._foldingRangesLimit.update(this._length, !1);
      const i = new Uint32Array(this._length), n = new Uint32Array(this._length);
      for (let s = this._length - 1, o = 0; s >= 0; s--, o++)
        i[o] = this._startIndexes[s], n[o] = this._endIndexes[s];
      return new oo(i, n);
    } else {
      this._foldingRangesLimit.update(this._length, t);
      let i = 0, n = this._indentOccurrences.length;
      for (let l = 0; l < this._indentOccurrences.length; l++) {
        const d = this._indentOccurrences[l];
        if (d) {
          if (d + i > t) {
            n = l;
            break;
          }
          i += d;
        }
      }
      const s = e.getOptions().tabSize, o = new Uint32Array(t), a = new Uint32Array(t);
      for (let l = this._length - 1, d = 0; l >= 0; l--) {
        const c = this._startIndexes[l], h = e.getLineContent(c), u = R0(h, s);
        (u < n || u === n && i++ < t) && (o[d] = c, a[d] = this._endIndexes[l], d++);
      }
      return new oo(o, a);
    }
  }
};
const qge = {
  limit: $ge,
  update: () => {
  }
};
function Gge(r, e, t, i = qge) {
  const n = r.getOptions().tabSize, s = new jge(i);
  let o;
  t && (o = new RegExp(`(${t.start.source})|(?:${t.end.source})`));
  const a = [], l = r.getLineCount() + 1;
  a.push({ indent: -1, endAbove: l, line: l });
  for (let d = r.getLineCount(); d > 0; d--) {
    const c = r.getLineContent(d), h = R0(c, n);
    let u = a[a.length - 1];
    if (h === -1) {
      e && (u.endAbove = d);
      continue;
    }
    let g;
    if (o && (g = c.match(o)))
      if (g[1]) {
        let f = a.length - 1;
        for (; f > 0 && a[f].indent !== -2; )
          f--;
        if (f > 0) {
          a.length = f + 1, u = a[f], s.insertFirst(d, u.line, h), u.line = d, u.indent = h, u.endAbove = d;
          continue;
        }
      } else {
        a.push({ indent: -2, endAbove: d, line: d });
        continue;
      }
    if (u.indent > h) {
      do
        a.pop(), u = a[a.length - 1];
      while (u.indent > h);
      const f = u.endAbove - 1;
      f - d >= 1 && s.insertFirst(d, f, h);
    }
    u.indent === h ? u.endAbove = d : a.push({ indent: h, endAbove: d, line: d });
  }
  return s.toIndentRanges(r);
}
const Zge = I("editor.foldBackground", { light: ve(ec, 0.3), dark: ve(ec, 0.3), hcDark: null, hcLight: null }, p("foldBackgroundBackground", "Background color behind folded ranges. The color must not be opaque so as not to hide underlying decorations."), !0);
I("editorGutter.foldingControlForeground", { dark: Ha, light: Ha, hcDark: Ha, hcLight: Ha }, p("editorGutter.foldingControlForeground", "Color of the folding control in the editor gutter."));
const WL = hi("folding-expanded", me.chevronDown, p("foldingExpandedIcon", "Icon for expanded ranges in the editor glyph margin.")), BL = hi("folding-collapsed", me.chevronRight, p("foldingCollapsedIcon", "Icon for collapsed ranges in the editor glyph margin.")), z4 = hi("folding-manual-collapsed", BL, p("foldingManualCollapedIcon", "Icon for manually collapsed ranges in the editor glyph margin.")), U4 = hi("folding-manual-expanded", WL, p("foldingManualExpandedIcon", "Icon for manually expanded ranges in the editor glyph margin.")), kR = {
  color: ai(Zge),
  position: 1
  /* MinimapPosition.Inline */
}, Up = p("linesCollapsed", "Click to expand the range."), HL = p("linesExpanded", "Click to collapse the range.");
class Ti {
  constructor(e) {
    this.editor = e, this.showFoldingControls = "mouseover", this.showFoldingHighlights = !0;
  }
  getDecorationOption(e, t, i) {
    return t ? Ti.HIDDEN_RANGE_DECORATION : this.showFoldingControls === "never" ? e ? this.showFoldingHighlights ? Ti.NO_CONTROLS_COLLAPSED_HIGHLIGHTED_RANGE_DECORATION : Ti.NO_CONTROLS_COLLAPSED_RANGE_DECORATION : Ti.NO_CONTROLS_EXPANDED_RANGE_DECORATION : e ? i ? this.showFoldingHighlights ? Ti.MANUALLY_COLLAPSED_HIGHLIGHTED_VISUAL_DECORATION : Ti.MANUALLY_COLLAPSED_VISUAL_DECORATION : this.showFoldingHighlights ? Ti.COLLAPSED_HIGHLIGHTED_VISUAL_DECORATION : Ti.COLLAPSED_VISUAL_DECORATION : this.showFoldingControls === "mouseover" ? i ? Ti.MANUALLY_EXPANDED_AUTO_HIDE_VISUAL_DECORATION : Ti.EXPANDED_AUTO_HIDE_VISUAL_DECORATION : i ? Ti.MANUALLY_EXPANDED_VISUAL_DECORATION : Ti.EXPANDED_VISUAL_DECORATION;
  }
  changeDecorations(e) {
    return this.editor.changeDecorations(e);
  }
  removeDecorations(e) {
    this.editor.removeDecorations(e);
  }
}
Ti.COLLAPSED_VISUAL_DECORATION = Fe.register({
  description: "folding-collapsed-visual-decoration",
  stickiness: 0,
  afterContentClassName: "inline-folded",
  isWholeLine: !0,
  linesDecorationsTooltip: Up,
  firstLineDecorationClassName: Le.asClassName(BL)
});
Ti.COLLAPSED_HIGHLIGHTED_VISUAL_DECORATION = Fe.register({
  description: "folding-collapsed-highlighted-visual-decoration",
  stickiness: 0,
  afterContentClassName: "inline-folded",
  className: "folded-background",
  minimap: kR,
  isWholeLine: !0,
  linesDecorationsTooltip: Up,
  firstLineDecorationClassName: Le.asClassName(BL)
});
Ti.MANUALLY_COLLAPSED_VISUAL_DECORATION = Fe.register({
  description: "folding-manually-collapsed-visual-decoration",
  stickiness: 0,
  afterContentClassName: "inline-folded",
  isWholeLine: !0,
  linesDecorationsTooltip: Up,
  firstLineDecorationClassName: Le.asClassName(z4)
});
Ti.MANUALLY_COLLAPSED_HIGHLIGHTED_VISUAL_DECORATION = Fe.register({
  description: "folding-manually-collapsed-highlighted-visual-decoration",
  stickiness: 0,
  afterContentClassName: "inline-folded",
  className: "folded-background",
  minimap: kR,
  isWholeLine: !0,
  linesDecorationsTooltip: Up,
  firstLineDecorationClassName: Le.asClassName(z4)
});
Ti.NO_CONTROLS_COLLAPSED_RANGE_DECORATION = Fe.register({
  description: "folding-no-controls-range-decoration",
  stickiness: 0,
  afterContentClassName: "inline-folded",
  isWholeLine: !0,
  linesDecorationsTooltip: Up
});
Ti.NO_CONTROLS_COLLAPSED_HIGHLIGHTED_RANGE_DECORATION = Fe.register({
  description: "folding-no-controls-range-decoration",
  stickiness: 0,
  afterContentClassName: "inline-folded",
  className: "folded-background",
  minimap: kR,
  isWholeLine: !0,
  linesDecorationsTooltip: Up
});
Ti.EXPANDED_VISUAL_DECORATION = Fe.register({
  description: "folding-expanded-visual-decoration",
  stickiness: 1,
  isWholeLine: !0,
  firstLineDecorationClassName: "alwaysShowFoldIcons " + Le.asClassName(WL),
  linesDecorationsTooltip: HL
});
Ti.EXPANDED_AUTO_HIDE_VISUAL_DECORATION = Fe.register({
  description: "folding-expanded-auto-hide-visual-decoration",
  stickiness: 1,
  isWholeLine: !0,
  firstLineDecorationClassName: Le.asClassName(WL),
  linesDecorationsTooltip: HL
});
Ti.MANUALLY_EXPANDED_VISUAL_DECORATION = Fe.register({
  description: "folding-manually-expanded-visual-decoration",
  stickiness: 0,
  isWholeLine: !0,
  firstLineDecorationClassName: "alwaysShowFoldIcons " + Le.asClassName(U4),
  linesDecorationsTooltip: HL
});
Ti.MANUALLY_EXPANDED_AUTO_HIDE_VISUAL_DECORATION = Fe.register({
  description: "folding-manually-expanded-auto-hide-visual-decoration",
  stickiness: 0,
  isWholeLine: !0,
  firstLineDecorationClassName: Le.asClassName(U4),
  linesDecorationsTooltip: HL
});
Ti.NO_CONTROLS_EXPANDED_RANGE_DECORATION = Fe.register({
  description: "folding-no-controls-range-decoration",
  stickiness: 0,
  isWholeLine: !0
});
Ti.HIDDEN_RANGE_DECORATION = Fe.register({
  description: "folding-hidden-range-decoration",
  stickiness: 1
  /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */
});
const Yge = {}, Qge = "syntax";
class xR {
  constructor(e, t, i, n, s) {
    this.editorModel = e, this.providers = t, this.handleFoldingRangesChange = i, this.foldingRangesLimit = n, this.fallbackRangeProvider = s, this.id = Qge, this.disposables = new q(), s && this.disposables.add(s);
    for (const o of t)
      typeof o.onDidChange == "function" && this.disposables.add(o.onDidChange(i));
  }
  compute(e) {
    return Xge(this.providers, this.editorModel, e).then((t) => {
      var i, n;
      return t ? efe(t, this.foldingRangesLimit) : (n = (i = this.fallbackRangeProvider) === null || i === void 0 ? void 0 : i.compute(e)) !== null && n !== void 0 ? n : null;
    });
  }
  dispose() {
    this.disposables.dispose();
  }
}
function Xge(r, e, t) {
  let i = null;
  const n = r.map((s, o) => Promise.resolve(s.provideFoldingRanges(e, Yge, t)).then((a) => {
    if (!t.isCancellationRequested && Array.isArray(a)) {
      Array.isArray(i) || (i = []);
      const l = e.getLineCount();
      for (const d of a)
        d.start > 0 && d.end > d.start && d.end <= l && i.push({ start: d.start, end: d.end, rank: o, kind: d.kind });
    }
  }, _i));
  return Promise.all(n).then((s) => i);
}
class Jge {
  constructor(e) {
    this._startIndexes = [], this._endIndexes = [], this._nestingLevels = [], this._nestingLevelCounts = [], this._types = [], this._length = 0, this._foldingRangesLimit = e;
  }
  add(e, t, i, n) {
    if (e > Mr || t > Mr)
      return;
    const s = this._length;
    this._startIndexes[s] = e, this._endIndexes[s] = t, this._nestingLevels[s] = n, this._types[s] = i, this._length++, n < 30 && (this._nestingLevelCounts[n] = (this._nestingLevelCounts[n] || 0) + 1);
  }
  toIndentRanges() {
    const e = this._foldingRangesLimit.limit;
    if (this._length <= e) {
      this._foldingRangesLimit.update(this._length, !1);
      const t = new Uint32Array(this._length), i = new Uint32Array(this._length);
      for (let n = 0; n < this._length; n++)
        t[n] = this._startIndexes[n], i[n] = this._endIndexes[n];
      return new oo(t, i, this._types);
    } else {
      this._foldingRangesLimit.update(this._length, e);
      let t = 0, i = this._nestingLevelCounts.length;
      for (let a = 0; a < this._nestingLevelCounts.length; a++) {
        const l = this._nestingLevelCounts[a];
        if (l) {
          if (l + t > e) {
            i = a;
            break;
          }
          t += l;
        }
      }
      const n = new Uint32Array(e), s = new Uint32Array(e), o = [];
      for (let a = 0, l = 0; a < this._length; a++) {
        const d = this._nestingLevels[a];
        (d < i || d === i && t++ < e) && (n[l] = this._startIndexes[a], s[l] = this._endIndexes[a], o[l] = this._types[a], l++);
      }
      return new oo(n, s, o);
    }
  }
}
function efe(r, e) {
  const t = r.sort((o, a) => {
    let l = o.start - a.start;
    return l === 0 && (l = o.rank - a.rank), l;
  }), i = new Jge(e);
  let n;
  const s = [];
  for (const o of t)
    if (!n)
      n = o, i.add(o.start, o.end, o.kind && o.kind.value, s.length);
    else if (o.start > n.start)
      if (o.end <= n.end)
        s.push(n), n = o, i.add(o.start, o.end, o.kind && o.kind.value, s.length);
      else {
        if (o.start > n.end) {
          do
            n = s.pop();
          while (n && o.start > n.end);
          n && s.push(n), n = o;
        }
        i.add(o.start, o.end, o.kind && o.kind.value, s.length);
      }
  return i.toIndentRanges();
}
var tfe = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, bm = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, Pg;
const On = new oe("foldingEnabled", !1);
let pd = Pg = class extends P {
  static get(e) {
    return e.getContribution(Pg.ID);
  }
  static getFoldingRangeProviders(e, t) {
    var i, n;
    const s = e.foldingRangeProvider.ordered(t);
    return (n = (i = Pg._foldingRangeSelector) === null || i === void 0 ? void 0 : i.call(Pg, s, t)) !== null && n !== void 0 ? n : s;
  }
  constructor(e, t, i, n, s, o) {
    super(), this.contextKeyService = t, this.languageConfigurationService = i, this.languageFeaturesService = o, this.localToDispose = this._register(new q()), this.editor = e, this._foldingLimitReporter = new $4(e);
    const a = this.editor.getOptions();
    this._isEnabled = a.get(
      43
      /* EditorOption.folding */
    ), this._useFoldingProviders = a.get(
      44
      /* EditorOption.foldingStrategy */
    ) !== "indentation", this._unfoldOnClickAfterEndOfLine = a.get(
      48
      /* EditorOption.unfoldOnClickAfterEndOfLine */
    ), this._restoringViewState = !1, this._currentModelHasFoldedImports = !1, this._foldingImportsByDefault = a.get(
      46
      /* EditorOption.foldingImportsByDefault */
    ), this.updateDebounceInfo = s.for(o.foldingRangeProvider, "Folding", { min: 200 }), this.foldingModel = null, this.hiddenRangeModel = null, this.rangeProvider = null, this.foldingRegionPromise = null, this.foldingModelPromise = null, this.updateScheduler = null, this.cursorChangedScheduler = null, this.mouseDownInfo = null, this.foldingDecorationProvider = new Ti(e), this.foldingDecorationProvider.showFoldingControls = a.get(
      110
      /* EditorOption.showFoldingControls */
    ), this.foldingDecorationProvider.showFoldingHighlights = a.get(
      45
      /* EditorOption.foldingHighlight */
    ), this.foldingEnabled = On.bindTo(this.contextKeyService), this.foldingEnabled.set(this._isEnabled), this._register(this.editor.onDidChangeModel(() => this.onModelChanged())), this._register(this.editor.onDidChangeConfiguration((l) => {
      if (l.hasChanged(
        43
        /* EditorOption.folding */
      ) && (this._isEnabled = this.editor.getOptions().get(
        43
        /* EditorOption.folding */
      ), this.foldingEnabled.set(this._isEnabled), this.onModelChanged()), l.hasChanged(
        47
        /* EditorOption.foldingMaximumRegions */
      ) && this.onModelChanged(), l.hasChanged(
        110
        /* EditorOption.showFoldingControls */
      ) || l.hasChanged(
        45
        /* EditorOption.foldingHighlight */
      )) {
        const d = this.editor.getOptions();
        this.foldingDecorationProvider.showFoldingControls = d.get(
          110
          /* EditorOption.showFoldingControls */
        ), this.foldingDecorationProvider.showFoldingHighlights = d.get(
          45
          /* EditorOption.foldingHighlight */
        ), this.triggerFoldingModelChanged();
      }
      l.hasChanged(
        44
        /* EditorOption.foldingStrategy */
      ) && (this._useFoldingProviders = this.editor.getOptions().get(
        44
        /* EditorOption.foldingStrategy */
      ) !== "indentation", this.onFoldingStrategyChanged()), l.hasChanged(
        48
        /* EditorOption.unfoldOnClickAfterEndOfLine */
      ) && (this._unfoldOnClickAfterEndOfLine = this.editor.getOptions().get(
        48
        /* EditorOption.unfoldOnClickAfterEndOfLine */
      )), l.hasChanged(
        46
        /* EditorOption.foldingImportsByDefault */
      ) && (this._foldingImportsByDefault = this.editor.getOptions().get(
        46
        /* EditorOption.foldingImportsByDefault */
      ));
    })), this.onModelChanged();
  }
  /**
   * Store view state.
   */
  saveViewState() {
    const e = this.editor.getModel();
    if (!e || !this._isEnabled || e.isTooLargeForTokenization())
      return {};
    if (this.foldingModel) {
      const t = this.foldingModel.getMemento(), i = this.rangeProvider ? this.rangeProvider.id : void 0;
      return { collapsedRegions: t, lineCount: e.getLineCount(), provider: i, foldedImports: this._currentModelHasFoldedImports };
    }
  }
  /**
   * Restore view state.
   */
  restoreViewState(e) {
    const t = this.editor.getModel();
    if (!(!t || !this._isEnabled || t.isTooLargeForTokenization() || !this.hiddenRangeModel) && e && (this._currentModelHasFoldedImports = !!e.foldedImports, e.collapsedRegions && e.collapsedRegions.length > 0 && this.foldingModel)) {
      this._restoringViewState = !0;
      try {
        this.foldingModel.applyMemento(e.collapsedRegions);
      } finally {
        this._restoringViewState = !1;
      }
    }
  }
  onModelChanged() {
    this.localToDispose.clear();
    const e = this.editor.getModel();
    !this._isEnabled || !e || e.isTooLargeForTokenization() || (this._currentModelHasFoldedImports = !1, this.foldingModel = new Oge(e, this.foldingDecorationProvider), this.localToDispose.add(this.foldingModel), this.hiddenRangeModel = new zge(this.foldingModel), this.localToDispose.add(this.hiddenRangeModel), this.localToDispose.add(this.hiddenRangeModel.onDidChange((t) => this.onHiddenRangesChanges(t))), this.updateScheduler = new pr(this.updateDebounceInfo.get(e)), this.cursorChangedScheduler = new xt(() => this.revealCursor(), 200), this.localToDispose.add(this.cursorChangedScheduler), this.localToDispose.add(this.languageFeaturesService.foldingRangeProvider.onDidChange(() => this.onFoldingStrategyChanged())), this.localToDispose.add(this.editor.onDidChangeModelLanguageConfiguration(() => this.onFoldingStrategyChanged())), this.localToDispose.add(this.editor.onDidChangeModelContent((t) => this.onDidChangeModelContent(t))), this.localToDispose.add(this.editor.onDidChangeCursorPosition(() => this.onCursorPositionChanged())), this.localToDispose.add(this.editor.onMouseDown((t) => this.onEditorMouseDown(t))), this.localToDispose.add(this.editor.onMouseUp((t) => this.onEditorMouseUp(t))), this.localToDispose.add({
      dispose: () => {
        var t, i;
        this.foldingRegionPromise && (this.foldingRegionPromise.cancel(), this.foldingRegionPromise = null), (t = this.updateScheduler) === null || t === void 0 || t.cancel(), this.updateScheduler = null, this.foldingModel = null, this.foldingModelPromise = null, this.hiddenRangeModel = null, this.cursorChangedScheduler = null, (i = this.rangeProvider) === null || i === void 0 || i.dispose(), this.rangeProvider = null;
      }
    }), this.triggerFoldingModelChanged());
  }
  onFoldingStrategyChanged() {
    var e;
    (e = this.rangeProvider) === null || e === void 0 || e.dispose(), this.rangeProvider = null, this.triggerFoldingModelChanged();
  }
  getRangeProvider(e) {
    if (this.rangeProvider)
      return this.rangeProvider;
    const t = new DR(e, this.languageConfigurationService, this._foldingLimitReporter);
    if (this.rangeProvider = t, this._useFoldingProviders && this.foldingModel) {
      const i = Pg.getFoldingRangeProviders(this.languageFeaturesService, e);
      i.length > 0 && (this.rangeProvider = new xR(e, i, () => this.triggerFoldingModelChanged(), this._foldingLimitReporter, t));
    }
    return this.rangeProvider;
  }
  getFoldingModel() {
    return this.foldingModelPromise;
  }
  onDidChangeModelContent(e) {
    var t;
    (t = this.hiddenRangeModel) === null || t === void 0 || t.notifyChangeModelContent(e), this.triggerFoldingModelChanged();
  }
  triggerFoldingModelChanged() {
    this.updateScheduler && (this.foldingRegionPromise && (this.foldingRegionPromise.cancel(), this.foldingRegionPromise = null), this.foldingModelPromise = this.updateScheduler.trigger(() => {
      const e = this.foldingModel;
      if (!e)
        return null;
      const t = new rs(), i = this.getRangeProvider(e.textModel), n = this.foldingRegionPromise = Zi((s) => i.compute(s));
      return n.then((s) => {
        if (s && n === this.foldingRegionPromise) {
          let o;
          if (this._foldingImportsByDefault && !this._currentModelHasFoldedImports) {
            const c = s.setCollapsedAllOfType(Lp.Imports.value, !0);
            c && (o = sa.capture(this.editor), this._currentModelHasFoldedImports = c);
          }
          const a = this.editor.getSelections(), l = a ? a.map((c) => c.startLineNumber) : [];
          e.update(s, l), o == null || o.restore(this.editor);
          const d = this.updateDebounceInfo.update(e.textModel, t.elapsed());
          this.updateScheduler && (this.updateScheduler.defaultDelay = d);
        }
        return e;
      });
    }).then(void 0, (e) => (He(e), null)));
  }
  onHiddenRangesChanges(e) {
    if (this.hiddenRangeModel && e.length && !this._restoringViewState) {
      const t = this.editor.getSelections();
      t && this.hiddenRangeModel.adjustSelections(t) && this.editor.setSelections(t);
    }
    this.editor.setHiddenAreas(e, this);
  }
  onCursorPositionChanged() {
    this.hiddenRangeModel && this.hiddenRangeModel.hasRanges() && this.cursorChangedScheduler.schedule();
  }
  revealCursor() {
    const e = this.getFoldingModel();
    e && e.then((t) => {
      if (t) {
        const i = this.editor.getSelections();
        if (i && i.length > 0) {
          const n = [];
          for (const s of i) {
            const o = s.selectionStartLineNumber;
            this.hiddenRangeModel && this.hiddenRangeModel.isHidden(o) && n.push(...t.getAllRegionsAtLine(o, (a) => a.isCollapsed && o > a.startLineNumber));
          }
          n.length && (t.toggleCollapseState(n), this.reveal(i[0].getPosition()));
        }
      }
    }).then(void 0, He);
  }
  onEditorMouseDown(e) {
    if (this.mouseDownInfo = null, !this.hiddenRangeModel || !e.target || !e.target.range || !e.event.leftButton && !e.event.middleButton)
      return;
    const t = e.target.range;
    let i = !1;
    switch (e.target.type) {
      case 4: {
        const n = e.target.detail, s = e.target.element.offsetLeft;
        if (n.offsetX - s < 4)
          return;
        i = !0;
        break;
      }
      case 7: {
        if (this._unfoldOnClickAfterEndOfLine && this.hiddenRangeModel.hasRanges() && !e.target.detail.isAfterLines)
          break;
        return;
      }
      case 6: {
        if (this.hiddenRangeModel.hasRanges()) {
          const n = this.editor.getModel();
          if (n && t.startColumn === n.getLineMaxColumn(t.startLineNumber))
            break;
        }
        return;
      }
      default:
        return;
    }
    this.mouseDownInfo = { lineNumber: t.startLineNumber, iconClicked: i };
  }
  onEditorMouseUp(e) {
    const t = this.foldingModel;
    if (!t || !this.mouseDownInfo || !e.target)
      return;
    const i = this.mouseDownInfo.lineNumber, n = this.mouseDownInfo.iconClicked, s = e.target.range;
    if (!s || s.startLineNumber !== i)
      return;
    if (n) {
      if (e.target.type !== 4)
        return;
    } else {
      const a = this.editor.getModel();
      if (!a || s.startColumn !== a.getLineMaxColumn(i))
        return;
    }
    const o = t.getRegionAtLine(i);
    if (o && o.startLineNumber === i) {
      const a = o.isCollapsed;
      if (n || a) {
        const l = e.event.altKey;
        let d = [];
        if (l) {
          const c = (u) => !u.containedBy(o) && !o.containedBy(u), h = t.getRegionsInside(null, c);
          for (const u of h)
            u.isCollapsed && d.push(u);
          d.length === 0 && (d = h);
        } else {
          const c = e.event.middleButton || e.event.shiftKey;
          if (c)
            for (const h of t.getRegionsInside(o))
              h.isCollapsed === a && d.push(h);
          (a || !c || d.length === 0) && d.push(o);
        }
        t.toggleCollapseState(d), this.reveal({ lineNumber: i, column: 1 });
      }
    }
  }
  reveal(e) {
    this.editor.revealPositionInCenterIfOutsideViewport(
      e,
      0
      /* ScrollType.Smooth */
    );
  }
};
pd.ID = "editor.contrib.folding";
pd = Pg = tfe([
  bm(1, De),
  bm(2, Ot),
  bm(3, xi),
  bm(4, Vo),
  bm(5, he)
], pd);
class $4 {
  constructor(e) {
    this.editor = e, this._onDidChange = new R(), this._computed = 0, this._limited = !1;
  }
  get limit() {
    return this.editor.getOptions().get(
      47
      /* EditorOption.foldingMaximumRegions */
    );
  }
  update(e, t) {
    (e !== this._computed || t !== this._limited) && (this._computed = e, this._limited = t, this._onDidChange.fire());
  }
}
class qn extends ae {
  runEditorCommand(e, t, i) {
    const n = e.get(Ot), s = pd.get(t);
    if (!s)
      return;
    const o = s.getFoldingModel();
    if (o)
      return this.reportTelemetry(e, t), o.then((a) => {
        if (a) {
          this.invoke(s, a, t, i, n);
          const l = t.getSelection();
          l && s.reveal(l.getStartPosition());
        }
      });
  }
  getSelectedLines(e) {
    const t = e.getSelections();
    return t ? t.map((i) => i.startLineNumber) : [];
  }
  getLineNumbers(e, t) {
    return e && e.selectionLines ? e.selectionLines.map((i) => i + 1) : this.getSelectedLines(t);
  }
  run(e, t) {
  }
}
function K4(r) {
  if (!Fs(r)) {
    if (!ur(r))
      return !1;
    const e = r;
    if (!Fs(e.levels) && !Ic(e.levels) || !Fs(e.direction) && !Ws(e.direction) || !Fs(e.selectionLines) && (!Array.isArray(e.selectionLines) || !e.selectionLines.every(Ic)))
      return !1;
  }
  return !0;
}
class ife extends qn {
  constructor() {
    super({
      id: "editor.unfold",
      label: p("unfoldAction.label", "Unfold"),
      alias: "Unfold",
      precondition: On,
      kbOpts: {
        kbExpr: x.editorTextFocus,
        primary: 3166,
        mac: {
          primary: 2654
          /* KeyCode.BracketRight */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      metadata: {
        description: "Unfold the content in the editor",
        args: [
          {
            name: "Unfold editor argument",
            description: `Property-value pairs that can be passed through this argument:
						* 'levels': Number of levels to unfold. If not set, defaults to 1.
						* 'direction': If 'up', unfold given number of levels up otherwise unfolds down.
						* 'selectionLines': Array of the start lines (0-based) of the editor selections to apply the unfold action to. If not set, the active selection(s) will be used.
						`,
            constraint: K4,
            schema: {
              type: "object",
              properties: {
                levels: {
                  type: "number",
                  default: 1
                },
                direction: {
                  type: "string",
                  enum: ["up", "down"],
                  default: "down"
                },
                selectionLines: {
                  type: "array",
                  items: {
                    type: "number"
                  }
                }
              }
            }
          }
        ]
      }
    });
  }
  invoke(e, t, i, n) {
    const s = n && n.levels || 1, o = this.getLineNumbers(n, i);
    n && n.direction === "up" ? H4(t, !1, s, o) : zp(t, !1, s, o);
  }
}
class nfe extends qn {
  constructor() {
    super({
      id: "editor.unfoldRecursively",
      label: p("unFoldRecursivelyAction.label", "Unfold Recursively"),
      alias: "Unfold Recursively",
      precondition: On,
      kbOpts: {
        kbExpr: x.editorTextFocus,
        primary: zi(
          2089,
          2142
          /* KeyCode.BracketRight */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(e, t, i, n) {
    zp(t, !1, Number.MAX_VALUE, this.getSelectedLines(i));
  }
}
class sfe extends qn {
  constructor() {
    super({
      id: "editor.fold",
      label: p("foldAction.label", "Fold"),
      alias: "Fold",
      precondition: On,
      kbOpts: {
        kbExpr: x.editorTextFocus,
        primary: 3164,
        mac: {
          primary: 2652
          /* KeyCode.BracketLeft */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      metadata: {
        description: "Fold the content in the editor",
        args: [
          {
            name: "Fold editor argument",
            description: `Property-value pairs that can be passed through this argument:
							* 'levels': Number of levels to fold.
							* 'direction': If 'up', folds given number of levels up otherwise folds down.
							* 'selectionLines': Array of the start lines (0-based) of the editor selections to apply the fold action to. If not set, the active selection(s) will be used.
							If no levels or direction is set, folds the region at the locations or if already collapsed, the first uncollapsed parent instead.
						`,
            constraint: K4,
            schema: {
              type: "object",
              properties: {
                levels: {
                  type: "number"
                },
                direction: {
                  type: "string",
                  enum: ["up", "down"]
                },
                selectionLines: {
                  type: "array",
                  items: {
                    type: "number"
                  }
                }
              }
            }
          }
        ]
      }
    });
  }
  invoke(e, t, i, n) {
    const s = this.getLineNumbers(n, i), o = n && n.levels, a = n && n.direction;
    typeof o != "number" && typeof a != "string" ? Fge(t, !0, s) : a === "up" ? H4(t, !0, o || 1, s) : zp(t, !0, o || 1, s);
  }
}
class ofe extends qn {
  constructor() {
    super({
      id: "editor.toggleFold",
      label: p("toggleFoldAction.label", "Toggle Fold"),
      alias: "Toggle Fold",
      precondition: On,
      kbOpts: {
        kbExpr: x.editorTextFocus,
        primary: zi(
          2089,
          2090
          /* KeyCode.KeyL */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(e, t, i) {
    const n = this.getSelectedLines(i);
    B4(t, 1, n);
  }
}
class rfe extends qn {
  constructor() {
    super({
      id: "editor.foldRecursively",
      label: p("foldRecursivelyAction.label", "Fold Recursively"),
      alias: "Fold Recursively",
      precondition: On,
      kbOpts: {
        kbExpr: x.editorTextFocus,
        primary: zi(
          2089,
          2140
          /* KeyCode.BracketLeft */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(e, t, i) {
    const n = this.getSelectedLines(i);
    zp(t, !0, Number.MAX_VALUE, n);
  }
}
class afe extends qn {
  constructor() {
    super({
      id: "editor.foldAllBlockComments",
      label: p("foldAllBlockComments.label", "Fold All Block Comments"),
      alias: "Fold All Block Comments",
      precondition: On,
      kbOpts: {
        kbExpr: x.editorTextFocus,
        primary: zi(
          2089,
          2138
          /* KeyCode.Slash */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(e, t, i, n, s) {
    if (t.regions.hasTypes())
      LR(t, Lp.Comment.value, !0);
    else {
      const o = i.getModel();
      if (!o)
        return;
      const a = s.getLanguageConfiguration(o.getLanguageId()).comments;
      if (a && a.blockCommentStartToken) {
        const l = new RegExp("^\\s*" + gr(a.blockCommentStartToken));
        yR(t, l, !0);
      }
    }
  }
}
class lfe extends qn {
  constructor() {
    super({
      id: "editor.foldAllMarkerRegions",
      label: p("foldAllMarkerRegions.label", "Fold All Regions"),
      alias: "Fold All Regions",
      precondition: On,
      kbOpts: {
        kbExpr: x.editorTextFocus,
        primary: zi(
          2089,
          2077
          /* KeyCode.Digit8 */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(e, t, i, n, s) {
    if (t.regions.hasTypes())
      LR(t, Lp.Region.value, !0);
    else {
      const o = i.getModel();
      if (!o)
        return;
      const a = s.getLanguageConfiguration(o.getLanguageId()).foldingRules;
      if (a && a.markers && a.markers.start) {
        const l = new RegExp(a.markers.start);
        yR(t, l, !0);
      }
    }
  }
}
class dfe extends qn {
  constructor() {
    super({
      id: "editor.unfoldAllMarkerRegions",
      label: p("unfoldAllMarkerRegions.label", "Unfold All Regions"),
      alias: "Unfold All Regions",
      precondition: On,
      kbOpts: {
        kbExpr: x.editorTextFocus,
        primary: zi(
          2089,
          2078
          /* KeyCode.Digit9 */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(e, t, i, n, s) {
    if (t.regions.hasTypes())
      LR(t, Lp.Region.value, !1);
    else {
      const o = i.getModel();
      if (!o)
        return;
      const a = s.getLanguageConfiguration(o.getLanguageId()).foldingRules;
      if (a && a.markers && a.markers.start) {
        const l = new RegExp(a.markers.start);
        yR(t, l, !1);
      }
    }
  }
}
class cfe extends qn {
  constructor() {
    super({
      id: "editor.foldAllExcept",
      label: p("foldAllExcept.label", "Fold All Except Selected"),
      alias: "Fold All Except Selected",
      precondition: On,
      kbOpts: {
        kbExpr: x.editorTextFocus,
        primary: zi(
          2089,
          2136
          /* KeyCode.Minus */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(e, t, i) {
    const n = this.getSelectedLines(i);
    V4(t, !0, n);
  }
}
class hfe extends qn {
  constructor() {
    super({
      id: "editor.unfoldAllExcept",
      label: p("unfoldAllExcept.label", "Unfold All Except Selected"),
      alias: "Unfold All Except Selected",
      precondition: On,
      kbOpts: {
        kbExpr: x.editorTextFocus,
        primary: zi(
          2089,
          2134
          /* KeyCode.Equal */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(e, t, i) {
    const n = this.getSelectedLines(i);
    V4(t, !1, n);
  }
}
class ufe extends qn {
  constructor() {
    super({
      id: "editor.foldAll",
      label: p("foldAllAction.label", "Fold All"),
      alias: "Fold All",
      precondition: On,
      kbOpts: {
        kbExpr: x.editorTextFocus,
        primary: zi(
          2089,
          2069
          /* KeyCode.Digit0 */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(e, t, i) {
    zp(t, !0);
  }
}
class gfe extends qn {
  constructor() {
    super({
      id: "editor.unfoldAll",
      label: p("unfoldAllAction.label", "Unfold All"),
      alias: "Unfold All",
      precondition: On,
      kbOpts: {
        kbExpr: x.editorTextFocus,
        primary: zi(
          2089,
          2088
          /* KeyCode.KeyJ */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(e, t, i) {
    zp(t, !1);
  }
}
class Bu extends qn {
  getFoldingLevel() {
    return parseInt(this.id.substr(Bu.ID_PREFIX.length));
  }
  invoke(e, t, i) {
    Wge(t, this.getFoldingLevel(), !0, this.getSelectedLines(i));
  }
}
Bu.ID_PREFIX = "editor.foldLevel";
Bu.ID = (r) => Bu.ID_PREFIX + r;
class ffe extends qn {
  constructor() {
    super({
      id: "editor.gotoParentFold",
      label: p("gotoParentFold.label", "Go to Parent Fold"),
      alias: "Go to Parent Fold",
      precondition: On,
      kbOpts: {
        kbExpr: x.editorTextFocus,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(e, t, i) {
    const n = this.getSelectedLines(i);
    if (n.length > 0) {
      const s = Bge(n[0], t);
      s !== null && i.setSelection({
        startLineNumber: s,
        startColumn: 1,
        endLineNumber: s,
        endColumn: 1
      });
    }
  }
}
class pfe extends qn {
  constructor() {
    super({
      id: "editor.gotoPreviousFold",
      label: p("gotoPreviousFold.label", "Go to Previous Folding Range"),
      alias: "Go to Previous Folding Range",
      precondition: On,
      kbOpts: {
        kbExpr: x.editorTextFocus,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(e, t, i) {
    const n = this.getSelectedLines(i);
    if (n.length > 0) {
      const s = Hge(n[0], t);
      s !== null && i.setSelection({
        startLineNumber: s,
        startColumn: 1,
        endLineNumber: s,
        endColumn: 1
      });
    }
  }
}
class mfe extends qn {
  constructor() {
    super({
      id: "editor.gotoNextFold",
      label: p("gotoNextFold.label", "Go to Next Folding Range"),
      alias: "Go to Next Folding Range",
      precondition: On,
      kbOpts: {
        kbExpr: x.editorTextFocus,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(e, t, i) {
    const n = this.getSelectedLines(i);
    if (n.length > 0) {
      const s = Vge(n[0], t);
      s !== null && i.setSelection({
        startLineNumber: s,
        startColumn: 1,
        endLineNumber: s,
        endColumn: 1
      });
    }
  }
}
class _fe extends qn {
  constructor() {
    super({
      id: "editor.createFoldingRangeFromSelection",
      label: p("createManualFoldRange.label", "Create Folding Range from Selection"),
      alias: "Create Folding Range from Selection",
      precondition: On,
      kbOpts: {
        kbExpr: x.editorTextFocus,
        primary: zi(
          2089,
          2135
          /* KeyCode.Comma */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(e, t, i) {
    var n;
    const s = [], o = i.getSelections();
    if (o) {
      for (const a of o) {
        let l = a.endLineNumber;
        a.endColumn === 1 && --l, l > a.startLineNumber && (s.push({
          startLineNumber: a.startLineNumber,
          endLineNumber: l,
          type: void 0,
          isCollapsed: !0,
          source: 1
          /* FoldSource.userDefined */
        }), i.setSelection({
          startLineNumber: a.startLineNumber,
          startColumn: 1,
          endLineNumber: a.startLineNumber,
          endColumn: 1
        }));
      }
      if (s.length > 0) {
        s.sort((l, d) => l.startLineNumber - d.startLineNumber);
        const a = oo.sanitizeAndMerge(t.regions, s, (n = i.getModel()) === null || n === void 0 ? void 0 : n.getLineCount());
        t.updatePost(oo.fromFoldRanges(a));
      }
    }
  }
}
class vfe extends qn {
  constructor() {
    super({
      id: "editor.removeManualFoldingRanges",
      label: p("removeManualFoldingRanges.label", "Remove Manual Folding Ranges"),
      alias: "Remove Manual Folding Ranges",
      precondition: On,
      kbOpts: {
        kbExpr: x.editorTextFocus,
        primary: zi(
          2089,
          2137
          /* KeyCode.Period */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(e, t, i) {
    const n = i.getSelections();
    if (n) {
      const s = [];
      for (const o of n) {
        const { startLineNumber: a, endLineNumber: l } = o;
        s.push(l >= a ? { startLineNumber: a, endLineNumber: l } : { endLineNumber: l, startLineNumber: a });
      }
      t.removeManualRanges(s), e.triggerFoldingModelChanged();
    }
  }
}
gt(
  pd.ID,
  pd,
  0
  /* EditorContributionInstantiation.Eager */
);
Y(ife);
Y(nfe);
Y(sfe);
Y(rfe);
Y(ufe);
Y(gfe);
Y(afe);
Y(lfe);
Y(dfe);
Y(cfe);
Y(hfe);
Y(ofe);
Y(ffe);
Y(pfe);
Y(mfe);
Y(_fe);
Y(vfe);
for (let r = 1; r <= 7; r++)
  O6(new Bu({
    id: Bu.ID(r),
    label: p("foldLevelAction.label", "Fold Level {0}", r),
    alias: `Fold Level ${r}`,
    precondition: On,
    kbOpts: {
      kbExpr: x.editorTextFocus,
      primary: zi(2089, 2048 | 21 + r),
      weight: 100
      /* KeybindingWeight.EditorContrib */
    }
  }));
st.registerCommand("_executeFoldingRangeProvider", async function(r, ...e) {
  const [t] = e;
  if (!(t instanceof Ee))
    throw Ro();
  const i = r.get(he), n = r.get(ii).getModel(t);
  if (!n)
    throw Ro();
  const s = r.get(Ge);
  if (!s.getValue("editor.folding", { resource: t }))
    return [];
  const o = r.get(Ot), a = s.getValue("editor.foldingStrategy", { resource: t }), l = {
    get limit() {
      return s.getValue("editor.foldingMaximumRegions", { resource: t });
    },
    update: (g, f) => {
    }
  }, d = new DR(n, o, l);
  let c = d;
  if (a !== "indentation") {
    const g = pd.getFoldingRangeProviders(i, n);
    g.length && (c = new xR(n, g, () => {
    }, l, d));
  }
  const h = await c.compute(at.None), u = [];
  try {
    if (h)
      for (let g = 0; g < h.length; g++) {
        const f = h.getType(g);
        u.push({ start: h.getStartLineNumber(g), end: h.getEndLineNumber(g), kind: f ? Lp.fromValue(f) : void 0 });
      }
    return u;
  } finally {
    c.dispose();
  }
});
class bfe extends ae {
  constructor() {
    super({
      id: "editor.action.fontZoomIn",
      label: p("EditorFontZoomIn.label", "Increase Editor Font Size"),
      alias: "Increase Editor Font Size",
      precondition: void 0
    });
  }
  run(e, t) {
    xo.setZoomLevel(xo.getZoomLevel() + 1);
  }
}
class Cfe extends ae {
  constructor() {
    super({
      id: "editor.action.fontZoomOut",
      label: p("EditorFontZoomOut.label", "Decrease Editor Font Size"),
      alias: "Decrease Editor Font Size",
      precondition: void 0
    });
  }
  run(e, t) {
    xo.setZoomLevel(xo.getZoomLevel() - 1);
  }
}
class wfe extends ae {
  constructor() {
    super({
      id: "editor.action.fontZoomReset",
      label: p("EditorFontZoomReset.label", "Reset Editor Font Size"),
      alias: "Reset Editor Font Size",
      precondition: void 0
    });
  }
  run(e, t) {
    xo.setZoomLevel(0);
  }
}
Y(bfe);
Y(Cfe);
Y(wfe);
var j4 = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, L_ = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
let Fv = class {
  constructor(e, t, i, n) {
    this._editor = e, this._languageFeaturesService = t, this._workerService = i, this._accessibilitySignalService = n, this._disposables = new q(), this._sessionDisposables = new q(), this._disposables.add(t.onTypeFormattingEditProvider.onDidChange(this._update, this)), this._disposables.add(e.onDidChangeModel(() => this._update())), this._disposables.add(e.onDidChangeModelLanguage(() => this._update())), this._disposables.add(e.onDidChangeConfiguration((s) => {
      s.hasChanged(
        56
        /* EditorOption.formatOnType */
      ) && this._update();
    })), this._update();
  }
  dispose() {
    this._disposables.dispose(), this._sessionDisposables.dispose();
  }
  _update() {
    if (this._sessionDisposables.clear(), !this._editor.getOption(
      56
      /* EditorOption.formatOnType */
    ) || !this._editor.hasModel())
      return;
    const e = this._editor.getModel(), [t] = this._languageFeaturesService.onTypeFormattingEditProvider.ordered(e);
    if (!t || !t.autoFormatTriggerCharacters)
      return;
    const i = new lS();
    for (const n of t.autoFormatTriggerCharacters)
      i.add(n.charCodeAt(0));
    this._sessionDisposables.add(this._editor.onDidType((n) => {
      const s = n.charCodeAt(n.length - 1);
      i.has(s) && this._trigger(String.fromCharCode(s));
    }));
  }
  _trigger(e) {
    if (!this._editor.hasModel() || this._editor.getSelections().length > 1 || !this._editor.getSelection().isEmpty())
      return;
    const t = this._editor.getModel(), i = this._editor.getPosition(), n = new mi(), s = this._editor.onDidChangeModelContent((o) => {
      if (o.isFlush) {
        n.cancel(), s.dispose();
        return;
      }
      for (let a = 0, l = o.changes.length; a < l; a++)
        if (o.changes[a].range.endLineNumber <= i.lineNumber) {
          n.cancel(), s.dispose();
          return;
        }
    });
    q3(this._workerService, this._languageFeaturesService, t, i, e, t.getFormattingOptions(), n.token).then((o) => {
      n.token.isCancellationRequested || Rn(o) && (this._accessibilitySignalService.playSignal(Re.format, { userGesture: !1 }), hp.execute(this._editor, o, !0));
    }).finally(() => {
      s.dispose();
    });
  }
};
Fv.ID = "editor.contrib.autoFormat";
Fv = j4([
  L_(1, he),
  L_(2, Uo),
  L_(3, rh)
], Fv);
let Wv = class {
  constructor(e, t, i) {
    this.editor = e, this._languageFeaturesService = t, this._instantiationService = i, this._callOnDispose = new q(), this._callOnModel = new q(), this._callOnDispose.add(e.onDidChangeConfiguration(() => this._update())), this._callOnDispose.add(e.onDidChangeModel(() => this._update())), this._callOnDispose.add(e.onDidChangeModelLanguage(() => this._update())), this._callOnDispose.add(t.documentRangeFormattingEditProvider.onDidChange(this._update, this));
  }
  dispose() {
    this._callOnDispose.dispose(), this._callOnModel.dispose();
  }
  _update() {
    this._callOnModel.clear(), this.editor.getOption(
      55
      /* EditorOption.formatOnPaste */
    ) && this.editor.hasModel() && this._languageFeaturesService.documentRangeFormattingEditProvider.has(this.editor.getModel()) && this._callOnModel.add(this.editor.onDidPaste(({ range: e }) => this._trigger(e)));
  }
  _trigger(e) {
    this.editor.hasModel() && (this.editor.getSelections().length > 1 || this._instantiationService.invokeFunction(j3, this.editor, e, 2, id.None, at.None, !1).catch(He));
  }
};
Wv.ID = "editor.contrib.formatOnPaste";
Wv = j4([
  L_(1, he),
  L_(2, be)
], Wv);
class Sfe extends ae {
  constructor() {
    super({
      id: "editor.action.formatDocument",
      label: p("formatDocument.label", "Format Document"),
      alias: "Format Document",
      precondition: U.and(x.notInCompositeEditor, x.writable, x.hasDocumentFormattingProvider),
      kbOpts: {
        kbExpr: x.editorTextFocus,
        primary: 1572,
        linux: {
          primary: 3111
          /* KeyCode.KeyI */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      contextMenuOpts: {
        group: "1_modification",
        order: 1.3
      }
    });
  }
  async run(e, t) {
    if (t.hasModel()) {
      const i = e.get(be);
      await e.get(sh).showWhile(i.invokeFunction(Ele, t, 1, id.None, at.None, !0), 250);
    }
  }
}
class yfe extends ae {
  constructor() {
    super({
      id: "editor.action.formatSelection",
      label: p("formatSelection.label", "Format Selection"),
      alias: "Format Selection",
      precondition: U.and(x.writable, x.hasDocumentSelectionFormattingProvider),
      kbOpts: {
        kbExpr: x.editorTextFocus,
        primary: zi(
          2089,
          2084
          /* KeyCode.KeyF */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      contextMenuOpts: {
        when: x.hasNonEmptySelection,
        group: "1_modification",
        order: 1.31
      }
    });
  }
  async run(e, t) {
    if (!t.hasModel())
      return;
    const i = e.get(be), n = t.getModel(), s = t.getSelections().map((a) => a.isEmpty() ? new L(a.startLineNumber, 1, a.startLineNumber, n.getLineMaxColumn(a.startLineNumber)) : a);
    await e.get(sh).showWhile(i.invokeFunction(j3, t, s, 1, id.None, at.None, !0), 250);
  }
}
gt(
  Fv.ID,
  Fv,
  2
  /* EditorContributionInstantiation.BeforeFirstInteraction */
);
gt(
  Wv.ID,
  Wv,
  2
  /* EditorContributionInstantiation.BeforeFirstInteraction */
);
Y(Sfe);
Y(yfe);
st.registerCommand("editor.action.format", async (r) => {
  const e = r.get(ht).getFocusedCodeEditor();
  if (!e || !e.hasModel())
    return;
  const t = r.get($t);
  e.getSelection().isEmpty() ? await t.executeCommand("editor.action.formatDocument") : await t.executeCommand("editor.action.formatSelection");
});
var Lfe = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, ex = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
class af {
  remove() {
    var e;
    (e = this.parent) === null || e === void 0 || e.children.delete(this.id);
  }
  static findId(e, t) {
    let i;
    typeof e == "string" ? i = `${t.id}/${e}` : (i = `${t.id}/${e.name}`, t.children.get(i) !== void 0 && (i = `${t.id}/${e.name}_${e.range.startLineNumber}_${e.range.startColumn}`));
    let n = i;
    for (let s = 0; t.children.get(n) !== void 0; s++)
      n = `${i}_${s}`;
    return n;
  }
  static empty(e) {
    return e.children.size === 0;
  }
}
class OT extends af {
  constructor(e, t, i) {
    super(), this.id = e, this.parent = t, this.symbol = i, this.children = /* @__PURE__ */ new Map();
  }
}
class q4 extends af {
  constructor(e, t, i, n) {
    super(), this.id = e, this.parent = t, this.label = i, this.order = n, this.children = /* @__PURE__ */ new Map();
  }
}
class Ml extends af {
  static create(e, t, i) {
    const n = new mi(i), s = new Ml(t.uri), o = e.ordered(t), a = o.map((d, c) => {
      var h;
      const u = af.findId(`provider_${c}`, s), g = new q4(u, s, (h = d.displayName) !== null && h !== void 0 ? h : "Unknown Outline Provider", c);
      return Promise.resolve(d.provideDocumentSymbols(t, n.token)).then((f) => {
        for (const m of f || [])
          Ml._makeOutlineElement(m, g);
        return g;
      }, (f) => (_i(f), g)).then((f) => {
        af.empty(f) ? f.remove() : s._groups.set(u, f);
      });
    }), l = e.onDidChange(() => {
      const d = e.ordered(t);
      ci(d, o) || n.cancel();
    });
    return Promise.all(a).then(() => n.token.isCancellationRequested && !i.isCancellationRequested ? Ml.create(e, t, i) : s._compact()).finally(() => {
      n.dispose(), l.dispose(), n.dispose();
    });
  }
  static _makeOutlineElement(e, t) {
    const i = af.findId(e, t), n = new OT(i, t, e);
    if (e.children)
      for (const s of e.children)
        Ml._makeOutlineElement(s, n);
    t.children.set(n.id, n);
  }
  constructor(e) {
    super(), this.uri = e, this.id = "root", this.parent = void 0, this._groups = /* @__PURE__ */ new Map(), this.children = /* @__PURE__ */ new Map(), this.id = "root", this.parent = void 0;
  }
  _compact() {
    let e = 0;
    for (const [t, i] of this._groups)
      i.children.size === 0 ? this._groups.delete(t) : e += 1;
    if (e !== 1)
      this.children = this._groups;
    else {
      const t = ut.first(this._groups.values());
      for (const [, i] of t.children)
        i.parent = this, this.children.set(i.id, i);
    }
    return this;
  }
  getTopLevelSymbols() {
    const e = [];
    for (const t of this.children.values())
      t instanceof OT ? e.push(t.symbol) : e.push(...ut.map(t.children.values(), (i) => i.symbol));
    return e.sort((t, i) => L.compareRangesUsingStarts(t.range, i.range));
  }
  asListOfDocumentSymbols() {
    const e = this.getTopLevelSymbols(), t = [];
    return Ml._flattenDocumentSymbols(t, e, ""), t.sort((i, n) => A.compare(L.getStartPosition(i.range), L.getStartPosition(n.range)) || A.compare(L.getEndPosition(n.range), L.getEndPosition(i.range)));
  }
  static _flattenDocumentSymbols(e, t, i) {
    for (const n of t)
      e.push({
        kind: n.kind,
        tags: n.tags,
        name: n.name,
        detail: n.detail,
        containerName: n.containerName || i,
        range: n.range,
        selectionRange: n.selectionRange,
        children: void 0
        // we flatten it...
      }), n.children && Ml._flattenDocumentSymbols(e, n.children, n.name);
  }
}
const Kb = et("IOutlineModelService");
let FT = class {
  constructor(e, t, i) {
    this._languageFeaturesService = e, this._disposables = new q(), this._cache = new Cd(10, 0.7), this._debounceInformation = t.for(e.documentSymbolProvider, "DocumentSymbols", { min: 350 }), this._disposables.add(i.onModelRemoved((n) => {
      this._cache.delete(n.id);
    }));
  }
  dispose() {
    this._disposables.dispose();
  }
  async getOrCreate(e, t) {
    const i = this._languageFeaturesService.documentSymbolProvider, n = i.ordered(e);
    let s = this._cache.get(e.id);
    if (!s || s.versionId !== e.getVersionId() || !ci(s.provider, n)) {
      const a = new mi();
      s = {
        versionId: e.getVersionId(),
        provider: n,
        promiseCnt: 0,
        source: a,
        promise: Ml.create(i, e, a.token),
        model: void 0
      }, this._cache.set(e.id, s);
      const l = Date.now();
      s.promise.then((d) => {
        s.model = d, this._debounceInformation.update(e, Date.now() - l);
      }).catch((d) => {
        this._cache.delete(e.id);
      });
    }
    if (s.model)
      return s.model;
    s.promiseCnt += 1;
    const o = t.onCancellationRequested(() => {
      --s.promiseCnt === 0 && (s.source.cancel(), this._cache.delete(e.id));
    });
    try {
      return await s.promise;
    } finally {
      o.dispose();
    }
  }
};
FT = Lfe([
  ex(0, he),
  ex(1, Vo),
  ex(2, ii)
], FT);
ot(
  Kb,
  FT,
  1
  /* InstantiationType.Delayed */
);
st.registerCommand("_executeDocumentSymbolProvider", async function(r, ...e) {
  const [t] = e;
  ct(Ee.isUri(t));
  const i = r.get(Kb), s = await r.get(xs).createModelReference(t);
  try {
    return (await i.getOrCreate(s.object.textEditorModel, at.None)).getTopLevelSymbols();
  } finally {
    s.dispose();
  }
});
class rn extends P {
  constructor(e, t) {
    super(), this.contextKeyService = e, this.model = t, this.inlineCompletionVisible = rn.inlineSuggestionVisible.bindTo(this.contextKeyService), this.inlineCompletionSuggestsIndentation = rn.inlineSuggestionHasIndentation.bindTo(this.contextKeyService), this.inlineCompletionSuggestsIndentationLessThanTabSize = rn.inlineSuggestionHasIndentationLessThanTabSize.bindTo(this.contextKeyService), this.suppressSuggestions = rn.suppressSuggestions.bindTo(this.contextKeyService), this._register(qe((i) => {
      const n = this.model.read(i), s = n == null ? void 0 : n.state.read(i), o = !!(s != null && s.inlineCompletion) && (s == null ? void 0 : s.primaryGhostText) !== void 0 && !(s != null && s.primaryGhostText.isEmpty());
      this.inlineCompletionVisible.set(o), s != null && s.primaryGhostText && (s != null && s.inlineCompletion) && this.suppressSuggestions.set(s.inlineCompletion.inlineCompletion.source.inlineCompletions.suppressSuggestions);
    })), this._register(qe((i) => {
      const n = this.model.read(i);
      let s = !1, o = !0;
      const a = n == null ? void 0 : n.primaryGhostText.read(i);
      if (n != null && n.selectedSuggestItem && a && a.parts.length > 0) {
        const { column: l, lines: d } = a.parts[0], c = d[0], h = n.textModel.getLineIndentColumn(a.lineNumber);
        if (l <= h) {
          let g = ns(c);
          g === -1 && (g = c.length - 1), s = g > 0;
          const f = n.textModel.getOptions().tabSize;
          o = Hi.visibleColumnFromColumn(c, g + 1, f) < f;
        }
      }
      this.inlineCompletionSuggestsIndentation.set(s), this.inlineCompletionSuggestsIndentationLessThanTabSize.set(o);
    }));
  }
}
rn.inlineSuggestionVisible = new oe("inlineSuggestionVisible", !1, p("inlineSuggestionVisible", "Whether an inline suggestion is visible"));
rn.inlineSuggestionHasIndentation = new oe("inlineSuggestionHasIndentation", !1, p("inlineSuggestionHasIndentation", "Whether the inline suggestion starts with whitespace"));
rn.inlineSuggestionHasIndentationLessThanTabSize = new oe("inlineSuggestionHasIndentationLessThanTabSize", !0, p("inlineSuggestionHasIndentationLessThanTabSize", "Whether the inline suggestion starts with whitespace that is less than what would be inserted by tab"));
rn.suppressSuggestions = new oe("inlineSuggestionSuppressSuggestions", void 0, p("suppressSuggestions", "Whether suggestions should be suppressed for the current suggestion"));
class Bv {
  constructor(e, t) {
    this.lineNumber = e, this.parts = t;
  }
  equals(e) {
    return this.lineNumber === e.lineNumber && this.parts.length === e.parts.length && this.parts.every((t, i) => t.equals(e.parts[i]));
  }
  renderForScreenReader(e) {
    if (this.parts.length === 0)
      return "";
    const t = this.parts[this.parts.length - 1], i = e.substr(0, t.column - 1);
    return new ZN([
      ...this.parts.map((s) => new Nc(L.fromPositions(new A(1, s.column)), s.lines.join(`
`)))
    ]).applyToString(i).substring(this.parts[0].column - 1);
  }
  isEmpty() {
    return this.parts.every((e) => e.lines.length === 0);
  }
  get lineCount() {
    return 1 + this.parts.reduce((e, t) => e + t.lines.length - 1, 0);
  }
}
class Vy {
  constructor(e, t, i) {
    this.column = e, this.text = t, this.preview = i, this.lines = vd(this.text);
  }
  equals(e) {
    return this.column === e.column && this.lines.length === e.lines.length && this.lines.every((t, i) => t === e.lines[i]);
  }
}
class WT {
  constructor(e, t, i, n = 0) {
    this.lineNumber = e, this.columnRange = t, this.text = i, this.additionalReservedLineCount = n, this.parts = [
      new Vy(this.columnRange.endColumnExclusive, this.text, !1)
    ], this.newLines = vd(this.text);
  }
  renderForScreenReader(e) {
    return this.newLines.join(`
`);
  }
  get lineCount() {
    return this.newLines.length;
  }
  isEmpty() {
    return this.parts.every((e) => e.lines.length === 0);
  }
  equals(e) {
    return this.lineNumber === e.lineNumber && this.columnRange.equals(e.columnRange) && this.newLines.length === e.newLines.length && this.newLines.every((t, i) => t === e.newLines[i]) && this.additionalReservedLineCount === e.additionalReservedLineCount;
  }
}
function GW(r, e) {
  return ci(r, e, G4);
}
function G4(r, e) {
  return r === e ? !0 : !r || !e ? !1 : r instanceof Bv && e instanceof Bv || r instanceof WT && e instanceof WT ? r.equals(e) : !1;
}
const Dfe = [];
function kfe() {
  return Dfe;
}
class Z4 {
  constructor(e, t) {
    if (this.startColumn = e, this.endColumnExclusive = t, e > t)
      throw new Li(`startColumn ${e} cannot be after endColumnExclusive ${t}`);
  }
  toRange(e) {
    return new L(e, this.startColumn, e, this.endColumnExclusive);
  }
  equals(e) {
    return this.startColumn === e.startColumn && this.endColumnExclusive === e.endColumnExclusive;
  }
}
function Y4(r, e) {
  const t = new q(), i = r.createDecorationsCollection();
  return t.add(Z0({ debugName: () => `Apply decorations from ${e.debugName}` }, (n) => {
    const s = e.read(n);
    i.set(s);
  })), t.add({
    dispose: () => {
      i.clear();
    }
  }), t;
}
function xfe(r, e) {
  return new A(r.lineNumber + e.lineNumber - 1, e.lineNumber === 1 ? r.column + e.column - 1 : e.column);
}
function ZW(r, e) {
  return new A(r.lineNumber - e.lineNumber + 1, r.lineNumber - e.lineNumber === 0 ? r.column - e.column + 1 : r.column);
}
var Ife = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Efe = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
const YW = "ghost-text";
let BT = class extends P {
  constructor(e, t, i) {
    super(), this.editor = e, this.model = t, this.languageService = i, this.isDisposed = rt(this, !1), this.currentTextModel = Lt(this.editor.onDidChangeModel, () => (
      /** @description editor.model */
      this.editor.getModel()
    )), this.uiState = Pe(this, (n) => {
      if (this.isDisposed.read(n))
        return;
      const s = this.currentTextModel.read(n);
      if (s !== this.model.targetTextModel.read(n))
        return;
      const o = this.model.ghostText.read(n);
      if (!o)
        return;
      const a = o instanceof WT ? o.columnRange : void 0, l = [], d = [];
      function c(m, _) {
        if (d.length > 0) {
          const v = d[d.length - 1];
          _ && v.decorations.push(new ts(
            v.content.length + 1,
            v.content.length + 1 + m[0].length,
            _,
            0
            /* InlineDecorationType.Regular */
          )), v.content += m[0], m = m.slice(1);
        }
        for (const v of m)
          d.push({
            content: v,
            decorations: _ ? [new ts(
              1,
              v.length + 1,
              _,
              0
              /* InlineDecorationType.Regular */
            )] : []
          });
      }
      const h = s.getLineContent(o.lineNumber);
      let u, g = 0;
      for (const m of o.parts) {
        let _ = m.lines;
        u === void 0 ? (l.push({
          column: m.column,
          text: _[0],
          preview: m.preview
        }), _ = _.slice(1)) : c([h.substring(g, m.column - 1)], void 0), _.length > 0 && (c(_, YW), u === void 0 && m.column <= h.length && (u = m.column)), g = m.column - 1;
      }
      u !== void 0 && c([h.substring(g)], void 0);
      const f = u !== void 0 ? new Z4(u, h.length + 1) : void 0;
      return {
        replacedRange: a,
        inlineTexts: l,
        additionalLines: d,
        hiddenRange: f,
        lineNumber: o.lineNumber,
        additionalReservedLineCount: this.model.minReservedLineCount.read(n),
        targetTextModel: s
      };
    }), this.decorations = Pe(this, (n) => {
      const s = this.uiState.read(n);
      if (!s)
        return [];
      const o = [];
      s.replacedRange && o.push({
        range: s.replacedRange.toRange(s.lineNumber),
        options: { inlineClassName: "inline-completion-text-to-replace", description: "GhostTextReplacement" }
      }), s.hiddenRange && o.push({
        range: s.hiddenRange.toRange(s.lineNumber),
        options: { inlineClassName: "ghost-text-hidden", description: "ghost-text-hidden" }
      });
      for (const a of s.inlineTexts)
        o.push({
          range: L.fromPositions(new A(s.lineNumber, a.column)),
          options: {
            description: YW,
            after: { content: a.text, inlineClassName: a.preview ? "ghost-text-decoration-preview" : "ghost-text-decoration", cursorStops: Ba.Left },
            showIfCollapsed: !0
          }
        });
      return o;
    }), this.additionalLinesWidget = this._register(new Q4(this.editor, this.languageService.languageIdCodec, Pe((n) => {
      const s = this.uiState.read(n);
      return s ? {
        lineNumber: s.lineNumber,
        additionalLines: s.additionalLines,
        minReservedLineCount: s.additionalReservedLineCount,
        targetTextModel: s.targetTextModel
      } : void 0;
    }))), this._register(Se(() => {
      this.isDisposed.set(!0, void 0);
    })), this._register(Y4(this.editor, this.decorations));
  }
  ownsViewZone(e) {
    return this.additionalLinesWidget.viewZoneId === e;
  }
};
BT = Ife([
  Efe(2, Jt)
], BT);
class Q4 extends P {
  get viewZoneId() {
    return this._viewZoneId;
  }
  constructor(e, t, i) {
    super(), this.editor = e, this.languageIdCodec = t, this.lines = i, this._viewZoneId = void 0, this.editorOptionsChanged = Mn("editorOptionChanged", ne.filter(this.editor.onDidChangeConfiguration, (n) => n.hasChanged(
      33
      /* EditorOption.disableMonospaceOptimizations */
    ) || n.hasChanged(
      117
      /* EditorOption.stopRenderingLineAfter */
    ) || n.hasChanged(
      99
      /* EditorOption.renderWhitespace */
    ) || n.hasChanged(
      94
      /* EditorOption.renderControlCharacters */
    ) || n.hasChanged(
      51
      /* EditorOption.fontLigatures */
    ) || n.hasChanged(
      50
      /* EditorOption.fontInfo */
    ) || n.hasChanged(
      67
      /* EditorOption.lineHeight */
    ))), this._register(qe((n) => {
      const s = this.lines.read(n);
      this.editorOptionsChanged.read(n), s ? this.updateLines(s.lineNumber, s.additionalLines, s.minReservedLineCount) : this.clear();
    }));
  }
  dispose() {
    super.dispose(), this.clear();
  }
  clear() {
    this.editor.changeViewZones((e) => {
      this._viewZoneId && (e.removeZone(this._viewZoneId), this._viewZoneId = void 0);
    });
  }
  updateLines(e, t, i) {
    const n = this.editor.getModel();
    if (!n)
      return;
    const { tabSize: s } = n.getOptions();
    this.editor.changeViewZones((o) => {
      this._viewZoneId && (o.removeZone(this._viewZoneId), this._viewZoneId = void 0);
      const a = Math.max(t.length, i);
      if (a > 0) {
        const l = document.createElement("div");
        Tfe(l, s, t, this.editor.getOptions(), this.languageIdCodec), this._viewZoneId = o.addZone({
          afterLineNumber: e,
          heightInLines: a,
          domNode: l,
          afterColumnAffinity: 1
          /* PositionAffinity.Right */
        });
      }
    });
  }
}
function Tfe(r, e, t, i, n) {
  const s = i.get(
    33
    /* EditorOption.disableMonospaceOptimizations */
  ), o = i.get(
    117
    /* EditorOption.stopRenderingLineAfter */
  ), a = "none", l = i.get(
    94
    /* EditorOption.renderControlCharacters */
  ), d = i.get(
    51
    /* EditorOption.fontLigatures */
  ), c = i.get(
    50
    /* EditorOption.fontInfo */
  ), h = i.get(
    67
    /* EditorOption.lineHeight */
  ), u = new Tp(1e4);
  u.appendString('<div class="suggest-preview-text">');
  for (let m = 0, _ = t.length; m < _; m++) {
    const v = t[m], b = v.content;
    u.appendString('<div class="view-line'), u.appendString('" style="top:'), u.appendString(String(m * h)), u.appendString('px;width:1000000px;">');
    const C = e0(b), w = Of(b), S = Ri.createEmpty(b, n);
    hb(new th(c.isMonospace && !s, c.canUseHalfwidthRightwardsArrow, b, !1, C, w, 0, S, v.decorations, e, 0, c.spaceWidth, c.middotWidth, c.wsmiddotWidth, o, a, l, d !== ro.OFF, null), u), u.appendString("</div>");
  }
  u.appendString("</div>"), _n(r, c);
  const g = u.build(), f = QW ? QW.createHTML(g) : g;
  r.innerHTML = f;
}
const QW = wd("editorGhostText", { createHTML: (r) => r });
function Nfe(r, e) {
  const t = new m2(), i = new v2(t, (d) => e.getLanguageConfiguration(d)), n = new _2(new Mfe([r]), i), s = sI(n, [], void 0, !0);
  let o = "";
  const a = r.getLineContent();
  function l(d, c) {
    if (d.kind === 2)
      if (l(d.openingBracket, c), c = li(c, d.openingBracket.length), d.child && (l(d.child, c), c = li(c, d.child.length)), d.closingBracket)
        l(d.closingBracket, c), c = li(c, d.closingBracket.length);
      else {
        const u = i.getSingleLanguageBracketTokens(d.openingBracket.languageId).findClosingTokenText(d.openingBracket.bracketIds);
        o += u;
      }
    else if (d.kind !== 3) {
      if (d.kind === 0 || d.kind === 1)
        o += a.substring(c, li(c, d.length));
      else if (d.kind === 4)
        for (const h of d.children)
          l(h, c), c = li(c, h.length);
    }
  }
  return l(s, is), o;
}
class Mfe {
  constructor(e) {
    this.lines = e, this.tokenization = {
      getLineTokens: (t) => this.lines[t - 1]
    };
  }
  getLineCount() {
    return this.lines.length;
  }
  getLineLength(e) {
    return this.lines[e - 1].getLineContent().length;
  }
}
async function Rfe(r, e, t, i, n = at.None, s) {
  const o = Ofe(e, t), a = r.all(t), l = new cH();
  for (const v of a)
    v.groupId && l.add(v.groupId, v);
  function d(v) {
    if (!v.yieldsToGroupIds)
      return [];
    const b = [];
    for (const C of v.yieldsToGroupIds || []) {
      const w = l.get(C);
      for (const S of w)
        b.push(S);
    }
    return b;
  }
  const c = /* @__PURE__ */ new Map(), h = /* @__PURE__ */ new Set();
  function u(v, b) {
    if (b = [...b, v], h.has(v))
      return b;
    h.add(v);
    try {
      const C = d(v);
      for (const w of C) {
        const S = u(w, b);
        if (S)
          return S;
      }
    } finally {
      h.delete(v);
    }
  }
  function g(v) {
    const b = c.get(v);
    if (b)
      return b;
    const C = u(v, []);
    C && _i(new Error(`Inline completions: cyclic yield-to dependency detected. Path: ${C.map((S) => S.toString ? S.toString() : "" + S).join(" -> ")}`));
    const w = new ab();
    return c.set(v, w.p), (async () => {
      if (!C) {
        const S = d(v);
        for (const y of S) {
          const k = await g(y);
          if (k && k.items.length > 0)
            return;
        }
      }
      try {
        return await v.provideInlineCompletions(t, e, i, n);
      } catch (S) {
        _i(S);
        return;
      }
    })().then((S) => w.complete(S), (S) => w.error(S)), w.p;
  }
  const f = await Promise.all(a.map(async (v) => ({ provider: v, completions: await g(v) }))), m = /* @__PURE__ */ new Map(), _ = [];
  for (const v of f) {
    const b = v.completions;
    if (!b)
      continue;
    const C = new Pfe(b, v.provider);
    _.push(C);
    for (const w of b.items) {
      const S = zy.from(w, C, o, t, s);
      m.set(S.hash(), S);
    }
  }
  return new Afe(Array.from(m.values()), new Set(m.keys()), _);
}
class Afe {
  constructor(e, t, i) {
    this.completions = e, this.hashs = t, this.providerResults = i;
  }
  has(e) {
    return this.hashs.has(e.hash());
  }
  dispose() {
    for (const e of this.providerResults)
      e.removeRef();
  }
}
class Pfe {
  constructor(e, t) {
    this.inlineCompletions = e, this.provider = t, this.refCount = 1;
  }
  addRef() {
    this.refCount++;
  }
  removeRef() {
    this.refCount--, this.refCount === 0 && this.provider.freeInlineCompletions(this.inlineCompletions);
  }
}
class zy {
  static from(e, t, i, n, s) {
    let o, a, l = e.range ? L.lift(e.range) : i;
    if (typeof e.insertText == "string") {
      if (o = e.insertText, s && e.completeBracketPairs) {
        o = XW(o, l.getStartPosition(), n, s);
        const d = o.length - e.insertText.length;
        d !== 0 && (l = new L(l.startLineNumber, l.startColumn, l.endLineNumber, l.endColumn + d));
      }
      a = void 0;
    } else if ("snippet" in e.insertText) {
      const d = e.insertText.snippet.length;
      if (s && e.completeBracketPairs) {
        e.insertText.snippet = XW(e.insertText.snippet, l.getStartPosition(), n, s);
        const h = e.insertText.snippet.length - d;
        h !== 0 && (l = new L(l.startLineNumber, l.startColumn, l.endLineNumber, l.endColumn + h));
      }
      const c = new Mu().parse(e.insertText.snippet);
      c.children.length === 1 && c.children[0] instanceof es ? (o = c.children[0].value, a = void 0) : (o = c.toString(), a = {
        snippet: e.insertText.snippet,
        range: l
      });
    } else
      $N(e.insertText);
    return new zy(o, e.command, l, o, a, e.additionalTextEdits || kfe(), e, t);
  }
  constructor(e, t, i, n, s, o, a, l) {
    this.filterText = e, this.command = t, this.range = i, this.insertText = n, this.snippetInfo = s, this.additionalTextEdits = o, this.sourceInlineCompletion = a, this.source = l, e = e.replace(/\r\n|\r/g, `
`), n = e.replace(/\r\n|\r/g, `
`);
  }
  withRange(e) {
    return new zy(this.filterText, this.command, e, this.insertText, this.snippetInfo, this.additionalTextEdits, this.sourceInlineCompletion, this.source);
  }
  hash() {
    return JSON.stringify({ insertText: this.insertText, range: this.range.toString() });
  }
}
function Ofe(r, e) {
  const t = e.getWordAtPosition(r), i = e.getLineMaxColumn(r.lineNumber);
  return t ? new L(r.lineNumber, t.startColumn, r.lineNumber, i) : L.fromPositions(r, r.with(void 0, i));
}
function XW(r, e, t, i) {
  const s = t.getLineContent(e.lineNumber).substring(0, e.column - 1) + r, o = t.tokenization.tokenizeLineWithEdit(e, s.length - (e.column - 1), r), a = o == null ? void 0 : o.sliceAndInflate(e.column - 1, s.length, 0);
  return a ? Nfe(a, i) : r;
}
function mu(r, e, t) {
  const i = t ? r.range.intersectRanges(t) : r.range;
  if (!i)
    return r;
  const n = e.getValueInRange(
    i,
    1
    /* EndOfLinePreference.LF */
  ), s = xc(n, r.text), o = Tc.ofText(n.substring(0, s)).addToPosition(r.range.getStartPosition()), a = r.text.substring(s), l = L.fromPositions(o, r.range.getEndPosition());
  return new Nc(l, a);
}
function X4(r, e) {
  return r.text.startsWith(e.text) && Ffe(r.range, e.range);
}
function JW(r, e, t, i, n = 0) {
  let s = mu(r, e);
  if (s.range.endLineNumber !== s.range.startLineNumber)
    return;
  const o = e.getLineContent(s.range.startLineNumber), a = Tt(o).length;
  if (s.range.startColumn - 1 <= a) {
    const f = Tt(s.text).length, m = o.substring(s.range.startColumn - 1, a), [_, v] = [s.range.getStartPosition(), s.range.getEndPosition()], b = _.column + m.length <= v.column ? _.delta(0, m.length) : v, C = L.fromPositions(b, v), w = s.text.startsWith(m) ? s.text.substring(m.length) : s.text.substring(f);
    s = new Nc(C, w);
  }
  const d = e.getValueInRange(s.range), c = Wfe(d, s.text);
  if (!c)
    return;
  const h = s.range.startLineNumber, u = new Array();
  if (t === "prefix") {
    const f = c.filter((m) => m.originalLength === 0);
    if (f.length > 1 || f.length === 1 && f[0].originalStart !== d.length)
      return;
  }
  const g = s.text.length - n;
  for (const f of c) {
    const m = s.range.startColumn + f.originalStart + f.originalLength;
    if (t === "subwordSmart" && i && i.lineNumber === s.range.startLineNumber && m < i.column || f.originalLength > 0)
      return;
    if (f.modifiedLength === 0)
      continue;
    const _ = f.modifiedStart + f.modifiedLength, v = Math.max(f.modifiedStart, Math.min(_, g)), b = s.text.substring(f.modifiedStart, v), C = s.text.substring(v, Math.max(f.modifiedStart, _));
    b.length > 0 && u.push(new Vy(m, b, !1)), C.length > 0 && u.push(new Vy(m, C, !0));
  }
  return new Bv(h, u);
}
function Ffe(r, e) {
  return e.getStartPosition().equals(r.getStartPosition()) && e.getEndPosition().isBeforeOrEqual(r.getEndPosition());
}
let ba;
function Wfe(r, e) {
  if ((ba == null ? void 0 : ba.originalValue) === r && (ba == null ? void 0 : ba.newValue) === e)
    return ba == null ? void 0 : ba.changes;
  {
    let t = tB(r, e, !0);
    if (t) {
      const i = eB(t);
      if (i > 0) {
        const n = tB(r, e, !1);
        n && eB(n) < i && (t = n);
      }
    }
    return ba = {
      originalValue: r,
      newValue: e,
      changes: t
    }, t;
  }
}
function eB(r) {
  let e = 0;
  for (const t of r)
    e += t.originalLength;
  return e;
}
function tB(r, e, t) {
  if (r.length > 5e3 || e.length > 5e3)
    return;
  function i(d) {
    let c = 0;
    for (let h = 0, u = d.length; h < u; h++) {
      const g = d.charCodeAt(h);
      g > c && (c = g);
    }
    return c;
  }
  const n = Math.max(i(r), i(e));
  function s(d) {
    if (d < 0)
      throw new Error("unexpected");
    return n + d + 1;
  }
  function o(d) {
    let c = 0, h = 0;
    const u = new Int32Array(d.length);
    for (let g = 0, f = d.length; g < f; g++)
      if (t && d[g] === "(") {
        const m = h * 100 + c;
        u[g] = s(2 * m), c++;
      } else if (t && d[g] === ")") {
        c = Math.max(c - 1, 0);
        const m = h * 100 + c;
        u[g] = s(2 * m + 1), c === 0 && h++;
      } else
        u[g] = d.charCodeAt(g);
    return u;
  }
  const a = o(r), l = o(e);
  return new dH({ getElements: () => a }, { getElements: () => l }).ComputeDiff(!1).changes;
}
var Bfe = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, iB = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
let HT = class extends P {
  constructor(e, t, i, n, s) {
    super(), this.textModel = e, this.versionId = t, this._debounceValue = i, this.languageFeaturesService = n, this.languageConfigurationService = s, this._updateOperation = this._register(new Yi()), this.inlineCompletions = cv("inlineCompletions", void 0), this.suggestWidgetInlineCompletions = cv("suggestWidgetInlineCompletions", void 0), this._register(this.textModel.onDidChangeContent(() => {
      this._updateOperation.clear();
    }));
  }
  fetch(e, t, i) {
    var n, s;
    const o = new Vfe(e, t, this.textModel.getVersionId()), a = t.selectedSuggestionInfo ? this.suggestWidgetInlineCompletions : this.inlineCompletions;
    if (!((n = this._updateOperation.value) === null || n === void 0) && n.request.satisfies(o))
      return this._updateOperation.value.promise;
    if (!((s = a.get()) === null || s === void 0) && s.request.satisfies(o))
      return Promise.resolve(!0);
    const l = !!this._updateOperation.value;
    this._updateOperation.clear();
    const d = new mi(), c = (async () => {
      if ((l || t.triggerKind === nu.Automatic) && await Hfe(this._debounceValue.get(this.textModel), d.token), d.token.isCancellationRequested || this.textModel.getVersionId() !== o.versionId)
        return !1;
      const g = /* @__PURE__ */ new Date(), f = await Rfe(this.languageFeaturesService.inlineCompletionsProvider, e, this.textModel, t, d.token, this.languageConfigurationService);
      if (d.token.isCancellationRequested || this.textModel.getVersionId() !== o.versionId)
        return !1;
      const m = /* @__PURE__ */ new Date();
      this._debounceValue.update(this.textModel, m.getTime() - g.getTime());
      const _ = new Ufe(f, o, this.textModel, this.versionId);
      if (i) {
        const v = i.toInlineCompletion(void 0);
        i.canBeReused(this.textModel, e) && !f.has(v) && _.prepend(i.inlineCompletion, v.range, !0);
      }
      return this._updateOperation.clear(), Nt((v) => {
        a.set(_, v);
      }), !0;
    })(), h = new zfe(o, d, c);
    return this._updateOperation.value = h, c;
  }
  clear(e) {
    this._updateOperation.clear(), this.inlineCompletions.set(void 0, e), this.suggestWidgetInlineCompletions.set(void 0, e);
  }
  clearSuggestWidgetInlineCompletions(e) {
    var t;
    !((t = this._updateOperation.value) === null || t === void 0) && t.request.context.selectedSuggestionInfo && this._updateOperation.clear(), this.suggestWidgetInlineCompletions.set(void 0, e);
  }
  cancelUpdate() {
    this._updateOperation.clear();
  }
};
HT = Bfe([
  iB(3, he),
  iB(4, Ot)
], HT);
function Hfe(r, e) {
  return new Promise((t) => {
    let i;
    const n = setTimeout(() => {
      i && i.dispose(), t();
    }, r);
    e && (i = e.onCancellationRequested(() => {
      clearTimeout(n), i && i.dispose(), t();
    }));
  });
}
class Vfe {
  constructor(e, t, i) {
    this.position = e, this.context = t, this.versionId = i;
  }
  satisfies(e) {
    return this.position.equals(e.position) && nie(this.context.selectedSuggestionInfo, e.context.selectedSuggestionInfo, vz()) && (e.context.triggerKind === nu.Automatic || this.context.triggerKind === nu.Explicit) && this.versionId === e.versionId;
  }
}
class zfe {
  constructor(e, t, i) {
    this.request = e, this.cancellationTokenSource = t, this.promise = i;
  }
  dispose() {
    this.cancellationTokenSource.cancel();
  }
}
class Ufe {
  get inlineCompletions() {
    return this._inlineCompletions;
  }
  constructor(e, t, i, n) {
    this.inlineCompletionProviderResult = e, this.request = t, this._textModel = i, this._versionId = n, this._refCount = 1, this._prependedInlineCompletionItems = [];
    const s = i.deltaDecorations([], e.completions.map((o) => ({
      range: o.range,
      options: {
        description: "inline-completion-tracking-range"
      }
    })));
    this._inlineCompletions = e.completions.map((o, a) => new nB(o, s[a], this._textModel, this._versionId));
  }
  clone() {
    return this._refCount++, this;
  }
  dispose() {
    if (this._refCount--, this._refCount === 0) {
      setTimeout(() => {
        this._textModel.isDisposed() || this._textModel.deltaDecorations(this._inlineCompletions.map((e) => e.decorationId), []);
      }, 0), this.inlineCompletionProviderResult.dispose();
      for (const e of this._prependedInlineCompletionItems)
        e.source.removeRef();
    }
  }
  prepend(e, t, i) {
    i && e.source.addRef();
    const n = this._textModel.deltaDecorations([], [{
      range: t,
      options: {
        description: "inline-completion-tracking-range"
      }
    }])[0];
    this._inlineCompletions.unshift(new nB(e, n, this._textModel, this._versionId)), this._prependedInlineCompletionItems.push(e);
  }
}
class nB {
  get forwardStable() {
    var e;
    return (e = this.inlineCompletion.source.inlineCompletions.enableForwardStability) !== null && e !== void 0 ? e : !1;
  }
  constructor(e, t, i, n) {
    this.inlineCompletion = e, this.decorationId = t, this._textModel = i, this._modelVersion = n, this.semanticId = JSON.stringify([
      this.inlineCompletion.filterText,
      this.inlineCompletion.insertText,
      this.inlineCompletion.range.getStartPosition().toString()
    ]), this._updatedRange = Fl({ owner: this, equalsFn: L.equalsRange }, (s) => (this._modelVersion.read(s), this._textModel.getDecorationRange(this.decorationId)));
  }
  toInlineCompletion(e) {
    var t;
    return this.inlineCompletion.withRange((t = this._updatedRange.read(e)) !== null && t !== void 0 ? t : tx);
  }
  toSingleTextEdit(e) {
    var t;
    return new Nc((t = this._updatedRange.read(e)) !== null && t !== void 0 ? t : tx, this.inlineCompletion.insertText);
  }
  isVisible(e, t, i) {
    const n = mu(this._toFilterTextReplacement(i), e), s = this._updatedRange.read(i);
    if (!s || !this.inlineCompletion.range.getStartPosition().equals(s.getStartPosition()) || t.lineNumber !== n.range.startLineNumber)
      return !1;
    const o = e.getValueInRange(
      n.range,
      1
      /* EndOfLinePreference.LF */
    ), a = n.text, l = Math.max(0, t.column - n.range.startColumn);
    let d = a.substring(0, l), c = a.substring(l), h = o.substring(0, l), u = o.substring(l);
    const g = e.getLineIndentColumn(n.range.startLineNumber);
    return n.range.startColumn <= g && (h = h.trimStart(), h.length === 0 && (u = u.trimStart()), d = d.trimStart(), d.length === 0 && (c = c.trimStart())), d.startsWith(h) && !!iz(u, c);
  }
  canBeReused(e, t) {
    const i = this._updatedRange.read(void 0);
    return !!i && i.containsPosition(t) && this.isVisible(e, t, void 0) && Tc.ofRange(i).isGreaterThanOrEqualTo(Tc.ofRange(this.inlineCompletion.range));
  }
  _toFilterTextReplacement(e) {
    var t;
    return new Nc((t = this._updatedRange.read(e)) !== null && t !== void 0 ? t : tx, this.inlineCompletion.filterText);
  }
}
const tx = new L(1, 1, 1, 1), je = {
  Visible: wR,
  HasFocusedSuggestion: new oe("suggestWidgetHasFocusedSuggestion", !1, p("suggestWidgetHasSelection", "Whether any suggestion is focused")),
  DetailsVisible: new oe("suggestWidgetDetailsVisible", !1, p("suggestWidgetDetailsVisible", "Whether suggestion details are visible")),
  MultipleSuggestions: new oe("suggestWidgetMultipleSuggestions", !1, p("suggestWidgetMultipleSuggestions", "Whether there are multiple suggestions to pick from")),
  MakesTextEdit: new oe("suggestionMakesTextEdit", !0, p("suggestionMakesTextEdit", "Whether inserting the current suggestion yields in a change or has everything already been typed")),
  AcceptSuggestionsOnEnter: new oe("acceptSuggestionOnEnter", !0, p("acceptSuggestionOnEnter", "Whether suggestions are inserted when pressing Enter")),
  HasInsertAndReplaceRange: new oe("suggestionHasInsertAndReplaceRange", !1, p("suggestionHasInsertAndReplaceRange", "Whether the current suggestion has insert and replace behaviour")),
  InsertMode: new oe("suggestionInsertMode", void 0, { type: "string", description: p("suggestionInsertMode", "Whether the default behaviour is to insert or replace") }),
  CanResolve: new oe("suggestionCanResolve", !1, p("suggestionCanResolve", "Whether the current suggestion supports to resolve further details"))
}, Sc = new D("suggestWidgetStatusBar");
class $fe {
  constructor(e, t, i, n) {
    var s;
    this.position = e, this.completion = t, this.container = i, this.provider = n, this.isInvalid = !1, this.score = qr.Default, this.distance = 0, this.textLabel = typeof t.label == "string" ? t.label : (s = t.label) === null || s === void 0 ? void 0 : s.label, this.labelLow = this.textLabel.toLowerCase(), this.isInvalid = !this.textLabel, this.sortTextLow = t.sortText && t.sortText.toLowerCase(), this.filterTextLow = t.filterText && t.filterText.toLowerCase(), this.extensionId = t.extensionId, L.isIRange(t.range) ? (this.editStart = new A(t.range.startLineNumber, t.range.startColumn), this.editInsertEnd = new A(t.range.endLineNumber, t.range.endColumn), this.editReplaceEnd = new A(t.range.endLineNumber, t.range.endColumn), this.isInvalid = this.isInvalid || L.spansMultipleLines(t.range) || t.range.startLineNumber !== e.lineNumber) : (this.editStart = new A(t.range.insert.startLineNumber, t.range.insert.startColumn), this.editInsertEnd = new A(t.range.insert.endLineNumber, t.range.insert.endColumn), this.editReplaceEnd = new A(t.range.replace.endLineNumber, t.range.replace.endColumn), this.isInvalid = this.isInvalid || L.spansMultipleLines(t.range.insert) || L.spansMultipleLines(t.range.replace) || t.range.insert.startLineNumber !== e.lineNumber || t.range.replace.startLineNumber !== e.lineNumber || t.range.insert.startColumn !== t.range.replace.startColumn), typeof n.resolveCompletionItem != "function" && (this._resolveCache = Promise.resolve(), this._resolveDuration = 0);
  }
  // ---- resolving
  get isResolved() {
    return this._resolveDuration !== void 0;
  }
  get resolveDuration() {
    return this._resolveDuration !== void 0 ? this._resolveDuration : -1;
  }
  async resolve(e) {
    if (!this._resolveCache) {
      const t = e.onCancellationRequested(() => {
        this._resolveCache = void 0, this._resolveDuration = void 0;
      }), i = new rs(!0);
      this._resolveCache = Promise.resolve(this.provider.resolveCompletionItem(this.completion, e)).then((n) => {
        Object.assign(this.completion, n), this._resolveDuration = i.elapsed();
      }, (n) => {
        cl(n) && (this._resolveCache = void 0, this._resolveDuration = void 0);
      }).finally(() => {
        t.dispose();
      });
    }
    return this._resolveCache;
  }
}
class Hv {
  constructor(e = 2, t = /* @__PURE__ */ new Set(), i = /* @__PURE__ */ new Set(), n = /* @__PURE__ */ new Map(), s = !0) {
    this.snippetSortOrder = e, this.kindFilter = t, this.providerFilter = i, this.providerItemsToReuse = n, this.showDeprecated = s;
  }
}
Hv.default = new Hv();
let Kfe;
function jfe() {
  return Kfe;
}
class qfe {
  constructor(e, t, i, n) {
    this.items = e, this.needsClipboard = t, this.durations = i, this.disposable = n;
  }
}
async function IR(r, e, t, i = Hv.default, n = {
  triggerKind: 0
  /* languages.CompletionTriggerKind.Invoke */
}, s = at.None) {
  const o = new rs();
  t = t.clone();
  const a = e.getWordAtPosition(t), l = a ? new L(t.lineNumber, a.startColumn, t.lineNumber, a.endColumn) : L.fromPositions(t), d = { replace: l, insert: l.setEndPosition(t.lineNumber, t.column) }, c = [], h = new q(), u = [];
  let g = !1;
  const f = (_, v, b) => {
    var C, w, S;
    let y = !1;
    if (!v)
      return y;
    for (const k of v.suggestions)
      if (!i.kindFilter.has(k.kind)) {
        if (!i.showDeprecated && (!((C = k == null ? void 0 : k.tags) === null || C === void 0) && C.includes(
          1
          /* languages.CompletionItemTag.Deprecated */
        )))
          continue;
        k.range || (k.range = d), k.sortText || (k.sortText = typeof k.label == "string" ? k.label : k.label.label), !g && k.insertTextRules && k.insertTextRules & 4 && (g = Mu.guessNeedsClipboard(k.insertText)), c.push(new $fe(t, k, v, _)), y = !0;
      }
    return t0(v) && h.add(v), u.push({
      providerName: (w = _._debugDisplayName) !== null && w !== void 0 ? w : "unknown_provider",
      elapsedProvider: (S = v.duration) !== null && S !== void 0 ? S : -1,
      elapsedOverall: b.elapsed()
    }), y;
  }, m = (async () => {
  })();
  for (const _ of r.orderedGroups(e)) {
    let v = !1;
    if (await Promise.all(_.map(async (b) => {
      if (i.providerItemsToReuse.has(b)) {
        const C = i.providerItemsToReuse.get(b);
        C.forEach((w) => c.push(w)), v = v || C.length > 0;
        return;
      }
      if (!(i.providerFilter.size > 0 && !i.providerFilter.has(b)))
        try {
          const C = new rs(), w = await b.provideCompletionItems(e, t, n, s);
          v = f(b, w, C) || v;
        } catch (C) {
          _i(C);
        }
    })), v || s.isCancellationRequested)
      break;
  }
  return await m, s.isCancellationRequested ? (h.dispose(), Promise.reject(new Ja())) : new qfe(c.sort(Yfe(i.snippetSortOrder)), g, { entries: u, elapsed: o.elapsed() }, h);
}
function ER(r, e) {
  if (r.sortTextLow && e.sortTextLow) {
    if (r.sortTextLow < e.sortTextLow)
      return -1;
    if (r.sortTextLow > e.sortTextLow)
      return 1;
  }
  return r.textLabel < e.textLabel ? -1 : r.textLabel > e.textLabel ? 1 : r.completion.kind - e.completion.kind;
}
function Gfe(r, e) {
  if (r.completion.kind !== e.completion.kind) {
    if (r.completion.kind === 27)
      return -1;
    if (e.completion.kind === 27)
      return 1;
  }
  return ER(r, e);
}
function Zfe(r, e) {
  if (r.completion.kind !== e.completion.kind) {
    if (r.completion.kind === 27)
      return 1;
    if (e.completion.kind === 27)
      return -1;
  }
  return ER(r, e);
}
const VL = /* @__PURE__ */ new Map();
VL.set(0, Gfe);
VL.set(2, Zfe);
VL.set(1, ER);
function Yfe(r) {
  return VL.get(r);
}
st.registerCommand("_executeCompletionItemProvider", async (r, ...e) => {
  const [t, i, n, s] = e;
  ct(Ee.isUri(t)), ct(A.isIPosition(i)), ct(typeof n == "string" || !n), ct(typeof s == "number" || !s);
  const { completionProvider: o } = r.get(he), a = await r.get(xs).createModelReference(t);
  try {
    const l = {
      incomplete: !1,
      suggestions: []
    }, d = [], c = a.object.textEditorModel.validatePosition(i), h = await IR(o, a.object.textEditorModel, c, void 0, {
      triggerCharacter: n ?? void 0,
      triggerKind: n ? 1 : 0
      /* languages.CompletionTriggerKind.Invoke */
    });
    for (const u of h.items)
      d.length < (s ?? 0) && d.push(u.resolve(at.None)), l.incomplete = l.incomplete || u.container.incomplete, l.suggestions.push(u.completion);
    try {
      return await Promise.all(d), l;
    } finally {
      setTimeout(() => h.disposable.dispose(), 100);
    }
  } finally {
    a.dispose();
  }
});
function Qfe(r, e) {
  var t;
  (t = r.getContribution("editor.contrib.suggestController")) === null || t === void 0 || t.triggerSuggest((/* @__PURE__ */ new Set()).add(e), void 0, !0);
}
class lf {
  static isAllOff(e) {
    return e.other === "off" && e.comments === "off" && e.strings === "off";
  }
  static isAllOn(e) {
    return e.other === "on" && e.comments === "on" && e.strings === "on";
  }
  static valueFor(e, t) {
    switch (t) {
      case 1:
        return e.comments;
      case 2:
        return e.strings;
      default:
        return e.other;
    }
  }
}
function sB(r, e = Ks) {
  return aQ(r, e) ? r.charAt(0).toUpperCase() + r.slice(1) : r;
}
var Xfe = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Jfe = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
class oB {
  constructor(e) {
    this._delegates = e;
  }
  resolve(e) {
    for (const t of this._delegates) {
      const i = t.resolve(e);
      if (i !== void 0)
        return i;
    }
  }
}
class rB {
  constructor(e, t, i, n) {
    this._model = e, this._selection = t, this._selectionIdx = i, this._overtypingCapturer = n;
  }
  resolve(e) {
    const { name: t } = e;
    if (t === "SELECTION" || t === "TM_SELECTED_TEXT") {
      let i = this._model.getValueInRange(this._selection) || void 0, n = this._selection.startLineNumber !== this._selection.endLineNumber;
      if (!i && this._overtypingCapturer) {
        const s = this._overtypingCapturer.getLastOvertypedInfo(this._selectionIdx);
        s && (i = s.value, n = s.multiline);
      }
      if (i && n && e.snippet) {
        const s = this._model.getLineContent(this._selection.startLineNumber), o = Tt(s, 0, this._selection.startColumn - 1);
        let a = o;
        e.snippet.walk((d) => d === e ? !1 : (d instanceof es && (a = Tt(vd(d.value).pop())), !0));
        const l = xc(a, o);
        i = i.replace(/(\r\n|\r|\n)(.*)/g, (d, c, h) => `${c}${a.substr(l)}${h}`);
      }
      return i;
    } else {
      if (t === "TM_CURRENT_LINE")
        return this._model.getLineContent(this._selection.positionLineNumber);
      if (t === "TM_CURRENT_WORD") {
        const i = this._model.getWordAtPosition({
          lineNumber: this._selection.positionLineNumber,
          column: this._selection.positionColumn
        });
        return i && i.word || void 0;
      } else {
        if (t === "TM_LINE_INDEX")
          return String(this._selection.positionLineNumber - 1);
        if (t === "TM_LINE_NUMBER")
          return String(this._selection.positionLineNumber);
        if (t === "CURSOR_INDEX")
          return String(this._selectionIdx);
        if (t === "CURSOR_NUMBER")
          return String(this._selectionIdx + 1);
      }
    }
  }
}
class aB {
  constructor(e, t) {
    this._labelService = e, this._model = t;
  }
  resolve(e) {
    const { name: t } = e;
    if (t === "TM_FILENAME")
      return fc(this._model.uri.fsPath);
    if (t === "TM_FILENAME_BASE") {
      const i = fc(this._model.uri.fsPath), n = i.lastIndexOf(".");
      return n <= 0 ? i : i.slice(0, n);
    } else {
      if (t === "TM_DIRECTORY")
        return QB(this._model.uri.fsPath) === "." ? "" : this._labelService.getUriLabel(P0(this._model.uri));
      if (t === "TM_FILEPATH")
        return this._labelService.getUriLabel(this._model.uri);
      if (t === "RELATIVE_FILEPATH")
        return this._labelService.getUriLabel(this._model.uri, { relative: !0, noPrefix: !0 });
    }
  }
}
class lB {
  constructor(e, t, i, n) {
    this._readClipboardText = e, this._selectionIdx = t, this._selectionCount = i, this._spread = n;
  }
  resolve(e) {
    if (e.name !== "CLIPBOARD")
      return;
    const t = this._readClipboardText();
    if (t) {
      if (this._spread) {
        const i = t.split(/\r\n|\n|\r/).filter((n) => !$B(n));
        if (i.length === this._selectionCount)
          return i[this._selectionIdx];
      }
      return t;
    }
  }
}
let Uy = class {
  constructor(e, t, i) {
    this._model = e, this._selection = t, this._languageConfigurationService = i;
  }
  resolve(e) {
    const { name: t } = e, i = this._model.getLanguageIdAtPosition(this._selection.selectionStartLineNumber, this._selection.selectionStartColumn), n = this._languageConfigurationService.getLanguageConfiguration(i).comments;
    if (n) {
      if (t === "LINE_COMMENT")
        return n.lineCommentToken || void 0;
      if (t === "BLOCK_COMMENT_START")
        return n.blockCommentStartToken || void 0;
      if (t === "BLOCK_COMMENT_END")
        return n.blockCommentEndToken || void 0;
    }
  }
};
Uy = Xfe([
  Jfe(2, Ot)
], Uy);
class Vr {
  constructor() {
    this._date = /* @__PURE__ */ new Date();
  }
  resolve(e) {
    const { name: t } = e;
    if (t === "CURRENT_YEAR")
      return String(this._date.getFullYear());
    if (t === "CURRENT_YEAR_SHORT")
      return String(this._date.getFullYear()).slice(-2);
    if (t === "CURRENT_MONTH")
      return String(this._date.getMonth().valueOf() + 1).padStart(2, "0");
    if (t === "CURRENT_DATE")
      return String(this._date.getDate().valueOf()).padStart(2, "0");
    if (t === "CURRENT_HOUR")
      return String(this._date.getHours().valueOf()).padStart(2, "0");
    if (t === "CURRENT_MINUTE")
      return String(this._date.getMinutes().valueOf()).padStart(2, "0");
    if (t === "CURRENT_SECOND")
      return String(this._date.getSeconds().valueOf()).padStart(2, "0");
    if (t === "CURRENT_DAY_NAME")
      return Vr.dayNames[this._date.getDay()];
    if (t === "CURRENT_DAY_NAME_SHORT")
      return Vr.dayNamesShort[this._date.getDay()];
    if (t === "CURRENT_MONTH_NAME")
      return Vr.monthNames[this._date.getMonth()];
    if (t === "CURRENT_MONTH_NAME_SHORT")
      return Vr.monthNamesShort[this._date.getMonth()];
    if (t === "CURRENT_SECONDS_UNIX")
      return String(Math.floor(this._date.getTime() / 1e3));
    if (t === "CURRENT_TIMEZONE_OFFSET") {
      const i = this._date.getTimezoneOffset(), n = i > 0 ? "-" : "+", s = Math.trunc(Math.abs(i / 60)), o = s < 10 ? "0" + s : s, a = Math.abs(i) - s * 60, l = a < 10 ? "0" + a : a;
      return n + o + ":" + l;
    }
  }
}
Vr.dayNames = [p("Sunday", "Sunday"), p("Monday", "Monday"), p("Tuesday", "Tuesday"), p("Wednesday", "Wednesday"), p("Thursday", "Thursday"), p("Friday", "Friday"), p("Saturday", "Saturday")];
Vr.dayNamesShort = [p("SundayShort", "Sun"), p("MondayShort", "Mon"), p("TuesdayShort", "Tue"), p("WednesdayShort", "Wed"), p("ThursdayShort", "Thu"), p("FridayShort", "Fri"), p("SaturdayShort", "Sat")];
Vr.monthNames = [p("January", "January"), p("February", "February"), p("March", "March"), p("April", "April"), p("May", "May"), p("June", "June"), p("July", "July"), p("August", "August"), p("September", "September"), p("October", "October"), p("November", "November"), p("December", "December")];
Vr.monthNamesShort = [p("JanuaryShort", "Jan"), p("FebruaryShort", "Feb"), p("MarchShort", "Mar"), p("AprilShort", "Apr"), p("MayShort", "May"), p("JuneShort", "Jun"), p("JulyShort", "Jul"), p("AugustShort", "Aug"), p("SeptemberShort", "Sep"), p("OctoberShort", "Oct"), p("NovemberShort", "Nov"), p("DecemberShort", "Dec")];
class dB {
  constructor(e) {
    this._workspaceService = e;
  }
  resolve(e) {
    if (!this._workspaceService)
      return;
    const t = Nte(this._workspaceService.getWorkspace());
    if (!Ete(t)) {
      if (e.name === "WORKSPACE_NAME")
        return this._resolveWorkspaceName(t);
      if (e.name === "WORKSPACE_FOLDER")
        return this._resoveWorkspacePath(t);
    }
  }
  _resolveWorkspaceName(e) {
    if (FI(e))
      return fc(e.uri.path);
    let t = fc(e.configPath.path);
    return t.endsWith(WI) && (t = t.substr(0, t.length - WI.length - 1)), t;
  }
  _resoveWorkspacePath(e) {
    if (FI(e))
      return sB(e.uri.fsPath);
    const t = fc(e.configPath.path);
    let i = e.configPath.fsPath;
    return i.endsWith(t) && (i = i.substr(0, i.length - t.length - 1)), i ? sB(i) : "/";
  }
}
class cB {
  resolve(e) {
    const { name: t } = e;
    if (t === "RANDOM")
      return Math.random().toString().slice(-6);
    if (t === "RANDOM_HEX")
      return Math.random().toString(16).slice(-6);
    if (t === "UUID")
      return SL();
  }
}
var epe = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, tpe = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, kr;
class Lo {
  constructor(e, t, i) {
    this._editor = e, this._snippet = t, this._snippetLineLeadingWhitespace = i, this._offset = -1, this._nestingLevel = 1, this._placeholderGroups = uA(t.placeholders, ko.compareByIndex), this._placeholderGroupsIdx = -1;
  }
  initialize(e) {
    this._offset = e.newPosition;
  }
  dispose() {
    this._placeholderDecorations && this._editor.removeDecorations([...this._placeholderDecorations.values()]), this._placeholderGroups.length = 0;
  }
  _initDecorations() {
    if (this._offset === -1)
      throw new Error("Snippet not initialized!");
    if (this._placeholderDecorations)
      return;
    this._placeholderDecorations = /* @__PURE__ */ new Map();
    const e = this._editor.getModel();
    this._editor.changeDecorations((t) => {
      for (const i of this._snippet.placeholders) {
        const n = this._snippet.offset(i), s = this._snippet.fullLen(i), o = L.fromPositions(e.getPositionAt(this._offset + n), e.getPositionAt(this._offset + n + s)), a = i.isFinalTabstop ? Lo._decor.inactiveFinal : Lo._decor.inactive, l = t.addDecoration(o, a);
        this._placeholderDecorations.set(i, l);
      }
    });
  }
  move(e) {
    if (!this._editor.hasModel())
      return [];
    if (this._initDecorations(), this._placeholderGroupsIdx >= 0) {
      const n = [];
      for (const s of this._placeholderGroups[this._placeholderGroupsIdx])
        if (s.transform) {
          const o = this._placeholderDecorations.get(s), a = this._editor.getModel().getDecorationRange(o), l = this._editor.getModel().getValueInRange(a), d = s.transform.resolve(l).split(/\r\n|\r|\n/);
          for (let c = 1; c < d.length; c++)
            d[c] = this._editor.getModel().normalizeIndentation(this._snippetLineLeadingWhitespace + d[c]);
          n.push(ti.replace(a, d.join(this._editor.getModel().getEOL())));
        }
      n.length > 0 && this._editor.executeEdits("snippet.placeholderTransform", n);
    }
    let t = !1;
    e === !0 && this._placeholderGroupsIdx < this._placeholderGroups.length - 1 ? (this._placeholderGroupsIdx += 1, t = !0) : e === !1 && this._placeholderGroupsIdx > 0 && (this._placeholderGroupsIdx -= 1, t = !0);
    const i = this._editor.getModel().changeDecorations((n) => {
      const s = /* @__PURE__ */ new Set(), o = [];
      for (const a of this._placeholderGroups[this._placeholderGroupsIdx]) {
        const l = this._placeholderDecorations.get(a), d = this._editor.getModel().getDecorationRange(l);
        o.push(new ge(d.startLineNumber, d.startColumn, d.endLineNumber, d.endColumn)), t = t && this._hasPlaceholderBeenCollapsed(a), n.changeDecorationOptions(l, a.isFinalTabstop ? Lo._decor.activeFinal : Lo._decor.active), s.add(a);
        for (const c of this._snippet.enclosingPlaceholders(a)) {
          const h = this._placeholderDecorations.get(c);
          n.changeDecorationOptions(h, c.isFinalTabstop ? Lo._decor.activeFinal : Lo._decor.active), s.add(c);
        }
      }
      for (const [a, l] of this._placeholderDecorations)
        s.has(a) || n.changeDecorationOptions(l, a.isFinalTabstop ? Lo._decor.inactiveFinal : Lo._decor.inactive);
      return o;
    });
    return t ? this.move(e) : i ?? [];
  }
  _hasPlaceholderBeenCollapsed(e) {
    let t = e;
    for (; t; ) {
      if (t instanceof ko) {
        const i = this._placeholderDecorations.get(t);
        if (this._editor.getModel().getDecorationRange(i).isEmpty() && t.toString().length > 0)
          return !0;
      }
      t = t.parent;
    }
    return !1;
  }
  get isAtFirstPlaceholder() {
    return this._placeholderGroupsIdx <= 0 || this._placeholderGroups.length === 0;
  }
  get isAtLastPlaceholder() {
    return this._placeholderGroupsIdx === this._placeholderGroups.length - 1;
  }
  get hasPlaceholder() {
    return this._snippet.placeholders.length > 0;
  }
  /**
   * A snippet is trivial when it has no placeholder or only a final placeholder at
   * its very end
   */
  get isTrivialSnippet() {
    if (this._snippet.placeholders.length === 0)
      return !0;
    if (this._snippet.placeholders.length === 1) {
      const [e] = this._snippet.placeholders;
      if (e.isFinalTabstop && this._snippet.rightMostDescendant === e)
        return !0;
    }
    return !1;
  }
  computePossibleSelections() {
    const e = /* @__PURE__ */ new Map();
    for (const t of this._placeholderGroups) {
      let i;
      for (const n of t) {
        if (n.isFinalTabstop)
          break;
        i || (i = [], e.set(n.index, i));
        const s = this._placeholderDecorations.get(n), o = this._editor.getModel().getDecorationRange(s);
        if (!o) {
          e.delete(n.index);
          break;
        }
        i.push(o);
      }
    }
    return e;
  }
  get activeChoice() {
    if (!this._placeholderDecorations)
      return;
    const e = this._placeholderGroups[this._placeholderGroupsIdx][0];
    if (!(e != null && e.choice))
      return;
    const t = this._placeholderDecorations.get(e);
    if (!t)
      return;
    const i = this._editor.getModel().getDecorationRange(t);
    if (i)
      return { range: i, choice: e.choice };
  }
  get hasChoice() {
    let e = !1;
    return this._snippet.walk((t) => (e = t instanceof Vp, !e)), e;
  }
  merge(e) {
    const t = this._editor.getModel();
    this._nestingLevel *= 10, this._editor.changeDecorations((i) => {
      for (const n of this._placeholderGroups[this._placeholderGroupsIdx]) {
        const s = e.shift();
        console.assert(s._offset !== -1), console.assert(!s._placeholderDecorations);
        const o = s._snippet.placeholderInfo.last.index;
        for (const l of s._snippet.placeholderInfo.all)
          l.isFinalTabstop ? l.index = n.index + (o + 1) / this._nestingLevel : l.index = n.index + l.index / this._nestingLevel;
        this._snippet.replace(n, s._snippet.children);
        const a = this._placeholderDecorations.get(n);
        i.removeDecoration(a), this._placeholderDecorations.delete(n);
        for (const l of s._snippet.placeholders) {
          const d = s._snippet.offset(l), c = s._snippet.fullLen(l), h = L.fromPositions(t.getPositionAt(s._offset + d), t.getPositionAt(s._offset + d + c)), u = i.addDecoration(h, Lo._decor.inactive);
          this._placeholderDecorations.set(l, u);
        }
      }
      this._placeholderGroups = uA(this._snippet.placeholders, ko.compareByIndex);
    });
  }
}
Lo._decor = {
  active: Fe.register({ description: "snippet-placeholder-1", stickiness: 0, className: "snippet-placeholder" }),
  inactive: Fe.register({ description: "snippet-placeholder-2", stickiness: 1, className: "snippet-placeholder" }),
  activeFinal: Fe.register({ description: "snippet-placeholder-3", stickiness: 1, className: "finish-snippet-placeholder" }),
  inactiveFinal: Fe.register({ description: "snippet-placeholder-4", stickiness: 1, className: "finish-snippet-placeholder" })
};
const hB = {
  overwriteBefore: 0,
  overwriteAfter: 0,
  adjustWhitespace: !0,
  clipboardText: void 0,
  overtypingCapturer: void 0
};
let $y = kr = class {
  static adjustWhitespace(e, t, i, n, s) {
    const o = e.getLineContent(t.lineNumber), a = Tt(o, 0, t.column - 1);
    let l;
    return n.walk((d) => {
      if (!(d instanceof es) || d.parent instanceof Vp || s && !s.has(d))
        return !0;
      const c = d.value.split(/\r\n|\r|\n/);
      if (i) {
        const u = n.offset(d);
        if (u === 0)
          c[0] = e.normalizeIndentation(c[0]);
        else {
          l = l ?? n.toString();
          const g = l.charCodeAt(u - 1);
          (g === 10 || g === 13) && (c[0] = e.normalizeIndentation(a + c[0]));
        }
        for (let g = 1; g < c.length; g++)
          c[g] = e.normalizeIndentation(a + c[g]);
      }
      const h = c.join(e.getEOL());
      return h !== d.value && (d.parent.replace(d, [new es(h)]), l = void 0), !0;
    }), a;
  }
  static adjustSelection(e, t, i, n) {
    if (i !== 0 || n !== 0) {
      const { positionLineNumber: s, positionColumn: o } = t, a = o - i, l = o + n, d = e.validateRange({
        startLineNumber: s,
        startColumn: a,
        endLineNumber: s,
        endColumn: l
      });
      t = ge.createWithDirection(d.startLineNumber, d.startColumn, d.endLineNumber, d.endColumn, t.getDirection());
    }
    return t;
  }
  static createEditsAndSnippetsFromSelections(e, t, i, n, s, o, a, l, d) {
    const c = [], h = [];
    if (!e.hasModel())
      return { edits: c, snippets: h };
    const u = e.getModel(), g = e.invokeWithinContext((w) => w.get(ku)), f = e.invokeWithinContext((w) => new aB(w.get(tp), u)), m = () => a, _ = u.getValueInRange(kr.adjustSelection(u, e.getSelection(), i, 0)), v = u.getValueInRange(kr.adjustSelection(u, e.getSelection(), 0, n)), b = u.getLineFirstNonWhitespaceColumn(e.getSelection().positionLineNumber), C = e.getSelections().map((w, S) => ({ selection: w, idx: S })).sort((w, S) => L.compareRangesUsingStarts(w.selection, S.selection));
    for (const { selection: w, idx: S } of C) {
      let y = kr.adjustSelection(u, w, i, 0), k = kr.adjustSelection(u, w, 0, n);
      _ !== u.getValueInRange(y) && (y = w), v !== u.getValueInRange(k) && (k = w);
      const E = w.setStartPosition(y.startLineNumber, y.startColumn).setEndPosition(k.endLineNumber, k.endColumn), N = new Mu().parse(t, !0, s), F = E.getStartPosition(), V = kr.adjustWhitespace(u, F, o || S > 0 && b !== u.getLineFirstNonWhitespaceColumn(w.positionLineNumber), N);
      N.resolveVariables(new oB([
        f,
        new lB(m, S, C.length, e.getOption(
          79
          /* EditorOption.multiCursorPaste */
        ) === "spread"),
        new rB(u, w, S, l),
        new Uy(u, w, d),
        new Vr(),
        new dB(g),
        new cB()
      ])), c[S] = ti.replace(E, N.toString()), c[S].identifier = { major: S, minor: 0 }, c[S]._isTracked = !0, h[S] = new Lo(e, N, V);
    }
    return { edits: c, snippets: h };
  }
  static createEditsAndSnippetsFromEdits(e, t, i, n, s, o, a) {
    if (!e.hasModel() || t.length === 0)
      return { edits: [], snippets: [] };
    const l = [], d = e.getModel(), c = new Mu(), h = new Wb(), u = new oB([
      e.invokeWithinContext((f) => new aB(f.get(tp), d)),
      new lB(() => s, 0, e.getSelections().length, e.getOption(
        79
        /* EditorOption.multiCursorPaste */
      ) === "spread"),
      new rB(d, e.getSelection(), 0, o),
      new Uy(d, e.getSelection(), a),
      new Vr(),
      new dB(e.invokeWithinContext((f) => f.get(ku))),
      new cB()
    ]);
    t = t.sort((f, m) => L.compareRangesUsingStarts(f.range, m.range));
    let g = 0;
    for (let f = 0; f < t.length; f++) {
      const { range: m, template: _ } = t[f];
      if (f > 0) {
        const S = t[f - 1].range, y = L.fromPositions(S.getEndPosition(), m.getStartPosition()), k = new es(d.getValueInRange(y));
        h.appendChild(k), g += k.value.length;
      }
      const v = c.parseFragment(_, h);
      kr.adjustWhitespace(d, m.getStartPosition(), !0, h, new Set(v)), h.resolveVariables(u);
      const b = h.toString(), C = b.slice(g);
      g = b.length;
      const w = ti.replace(m, C);
      w.identifier = { major: f, minor: 0 }, w._isTracked = !0, l.push(w);
    }
    return c.ensureFinalTabstop(h, i, !0), {
      edits: l,
      snippets: [new Lo(e, h, "")]
    };
  }
  constructor(e, t, i = hB, n) {
    this._editor = e, this._template = t, this._options = i, this._languageConfigurationService = n, this._templateMerges = [], this._snippets = [];
  }
  dispose() {
    zt(this._snippets);
  }
  _logInfo() {
    return `template="${this._template}", merged_templates="${this._templateMerges.join(" -> ")}"`;
  }
  insert() {
    if (!this._editor.hasModel())
      return;
    const { edits: e, snippets: t } = typeof this._template == "string" ? kr.createEditsAndSnippetsFromSelections(this._editor, this._template, this._options.overwriteBefore, this._options.overwriteAfter, !1, this._options.adjustWhitespace, this._options.clipboardText, this._options.overtypingCapturer, this._languageConfigurationService) : kr.createEditsAndSnippetsFromEdits(this._editor, this._template, !1, this._options.adjustWhitespace, this._options.clipboardText, this._options.overtypingCapturer, this._languageConfigurationService);
    this._snippets = t, this._editor.executeEdits("snippet", e, (i) => {
      const n = i.filter((s) => !!s.identifier);
      for (let s = 0; s < t.length; s++)
        t[s].initialize(n[s].textChange);
      return this._snippets[0].hasPlaceholder ? this._move(!0) : n.map((s) => ge.fromPositions(s.range.getEndPosition()));
    }), this._editor.revealRange(this._editor.getSelections()[0]);
  }
  merge(e, t = hB) {
    if (!this._editor.hasModel())
      return;
    this._templateMerges.push([this._snippets[0]._nestingLevel, this._snippets[0]._placeholderGroupsIdx, e]);
    const { edits: i, snippets: n } = kr.createEditsAndSnippetsFromSelections(this._editor, e, t.overwriteBefore, t.overwriteAfter, !0, t.adjustWhitespace, t.clipboardText, t.overtypingCapturer, this._languageConfigurationService);
    this._editor.executeEdits("snippet", i, (s) => {
      const o = s.filter((l) => !!l.identifier);
      for (let l = 0; l < n.length; l++)
        n[l].initialize(o[l].textChange);
      const a = n[0].isTrivialSnippet;
      if (!a) {
        for (const l of this._snippets)
          l.merge(n);
        console.assert(n.length === 0);
      }
      return this._snippets[0].hasPlaceholder && !a ? this._move(void 0) : o.map((l) => ge.fromPositions(l.range.getEndPosition()));
    });
  }
  next() {
    const e = this._move(!0);
    this._editor.setSelections(e), this._editor.revealPositionInCenterIfOutsideViewport(e[0].getPosition());
  }
  prev() {
    const e = this._move(!1);
    this._editor.setSelections(e), this._editor.revealPositionInCenterIfOutsideViewport(e[0].getPosition());
  }
  _move(e) {
    const t = [];
    for (const i of this._snippets) {
      const n = i.move(e);
      t.push(...n);
    }
    return t;
  }
  get isAtFirstPlaceholder() {
    return this._snippets[0].isAtFirstPlaceholder;
  }
  get isAtLastPlaceholder() {
    return this._snippets[0].isAtLastPlaceholder;
  }
  get hasPlaceholder() {
    return this._snippets[0].hasPlaceholder;
  }
  get hasChoice() {
    return this._snippets[0].hasChoice;
  }
  get activeChoice() {
    return this._snippets[0].activeChoice;
  }
  isSelectionWithinPlaceholders() {
    if (!this.hasPlaceholder)
      return !1;
    const e = this._editor.getSelections();
    if (e.length < this._snippets.length)
      return !1;
    const t = /* @__PURE__ */ new Map();
    for (const i of this._snippets) {
      const n = i.computePossibleSelections();
      if (t.size === 0)
        for (const [s, o] of n) {
          o.sort(L.compareRangesUsingStarts);
          for (const a of e)
            if (o[0].containsRange(a)) {
              t.set(s, []);
              break;
            }
        }
      if (t.size === 0)
        return !1;
      t.forEach((s, o) => {
        s.push(...n.get(o));
      });
    }
    e.sort(L.compareRangesUsingStarts);
    for (const [i, n] of t) {
      if (n.length !== e.length) {
        t.delete(i);
        continue;
      }
      n.sort(L.compareRangesUsingStarts);
      for (let s = 0; s < n.length; s++)
        if (!n[s].containsRange(e[s])) {
          t.delete(i);
          continue;
        }
    }
    return t.size > 0;
  }
};
$y = kr = epe([
  tpe(3, Ot)
], $y);
var ipe = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, dw = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, Og;
const uB = {
  overwriteBefore: 0,
  overwriteAfter: 0,
  undoStopBefore: !0,
  undoStopAfter: !0,
  adjustWhitespace: !0,
  clipboardText: void 0,
  overtypingCapturer: void 0
};
let vn = Og = class {
  static get(e) {
    return e.getContribution(Og.ID);
  }
  constructor(e, t, i, n, s) {
    this._editor = e, this._logService = t, this._languageFeaturesService = i, this._languageConfigurationService = s, this._snippetListener = new q(), this._modelVersionId = -1, this._inSnippet = Og.InSnippetMode.bindTo(n), this._hasNextTabstop = Og.HasNextTabstop.bindTo(n), this._hasPrevTabstop = Og.HasPrevTabstop.bindTo(n);
  }
  dispose() {
    var e;
    this._inSnippet.reset(), this._hasPrevTabstop.reset(), this._hasNextTabstop.reset(), (e = this._session) === null || e === void 0 || e.dispose(), this._snippetListener.dispose();
  }
  insert(e, t) {
    try {
      this._doInsert(e, typeof t > "u" ? uB : { ...uB, ...t });
    } catch (i) {
      this.cancel(), this._logService.error(i), this._logService.error("snippet_error"), this._logService.error("insert_template=", e), this._logService.error("existing_template=", this._session ? this._session._logInfo() : "<no_session>");
    }
  }
  _doInsert(e, t) {
    var i;
    if (this._editor.hasModel()) {
      if (this._snippetListener.clear(), t.undoStopBefore && this._editor.getModel().pushStackElement(), this._session && typeof e != "string" && this.cancel(), this._session ? (ct(typeof e == "string"), this._session.merge(e, t)) : (this._modelVersionId = this._editor.getModel().getAlternativeVersionId(), this._session = new $y(this._editor, e, t, this._languageConfigurationService), this._session.insert()), t.undoStopAfter && this._editor.getModel().pushStackElement(), !((i = this._session) === null || i === void 0) && i.hasChoice) {
        const n = {
          _debugDisplayName: "snippetChoiceCompletions",
          provideCompletionItems: (c, h) => {
            if (!this._session || c !== this._editor.getModel() || !A.equals(this._editor.getPosition(), h))
              return;
            const { activeChoice: u } = this._session;
            if (!u || u.choice.options.length === 0)
              return;
            const g = c.getValueInRange(u.range), f = !!u.choice.options.find((_) => _.value === g), m = [];
            for (let _ = 0; _ < u.choice.options.length; _++) {
              const v = u.choice.options[_];
              m.push({
                kind: 13,
                label: v.value,
                insertText: v.value,
                sortText: "a".repeat(_ + 1),
                range: u.range,
                filterText: f ? `${g}_${v.value}` : void 0,
                command: { id: "jumpToNextSnippetPlaceholder", title: p("next", "Go to next placeholder...") }
              });
            }
            return { suggestions: m };
          }
        }, s = this._editor.getModel();
        let o, a = !1;
        const l = () => {
          o == null || o.dispose(), a = !1;
        }, d = () => {
          a || (o = this._languageFeaturesService.completionProvider.register({
            language: s.getLanguageId(),
            pattern: s.uri.fsPath,
            scheme: s.uri.scheme,
            exclusive: !0
          }, n), this._snippetListener.add(o), a = !0);
        };
        this._choiceCompletions = { provider: n, enable: d, disable: l };
      }
      this._updateState(), this._snippetListener.add(this._editor.onDidChangeModelContent((n) => n.isFlush && this.cancel())), this._snippetListener.add(this._editor.onDidChangeModel(() => this.cancel())), this._snippetListener.add(this._editor.onDidChangeCursorSelection(() => this._updateState()));
    }
  }
  _updateState() {
    if (!(!this._session || !this._editor.hasModel())) {
      if (this._modelVersionId === this._editor.getModel().getAlternativeVersionId())
        return this.cancel();
      if (!this._session.hasPlaceholder)
        return this.cancel();
      if (this._session.isAtLastPlaceholder || !this._session.isSelectionWithinPlaceholders())
        return this._editor.getModel().pushStackElement(), this.cancel();
      this._inSnippet.set(!0), this._hasPrevTabstop.set(!this._session.isAtFirstPlaceholder), this._hasNextTabstop.set(!this._session.isAtLastPlaceholder), this._handleChoice();
    }
  }
  _handleChoice() {
    var e;
    if (!this._session || !this._editor.hasModel()) {
      this._currentChoice = void 0;
      return;
    }
    const { activeChoice: t } = this._session;
    if (!t || !this._choiceCompletions) {
      (e = this._choiceCompletions) === null || e === void 0 || e.disable(), this._currentChoice = void 0;
      return;
    }
    this._currentChoice !== t.choice && (this._currentChoice = t.choice, this._choiceCompletions.enable(), queueMicrotask(() => {
      Qfe(this._editor, this._choiceCompletions.provider);
    }));
  }
  finish() {
    for (; this._inSnippet.get(); )
      this.next();
  }
  cancel(e = !1) {
    var t;
    this._inSnippet.reset(), this._hasPrevTabstop.reset(), this._hasNextTabstop.reset(), this._snippetListener.clear(), this._currentChoice = void 0, (t = this._session) === null || t === void 0 || t.dispose(), this._session = void 0, this._modelVersionId = -1, e && this._editor.setSelections([this._editor.getSelection()]);
  }
  prev() {
    var e;
    (e = this._session) === null || e === void 0 || e.prev(), this._updateState();
  }
  next() {
    var e;
    (e = this._session) === null || e === void 0 || e.next(), this._updateState();
  }
  isInSnippet() {
    return !!this._inSnippet.get();
  }
};
vn.ID = "snippetController2";
vn.InSnippetMode = new oe("inSnippetMode", !1, p("inSnippetMode", "Whether the editor in current in snippet mode"));
vn.HasNextTabstop = new oe("hasNextTabstop", !1, p("hasNextTabstop", "Whether there is a next tab stop when in snippet mode"));
vn.HasPrevTabstop = new oe("hasPrevTabstop", !1, p("hasPrevTabstop", "Whether there is a previous tab stop when in snippet mode"));
vn = Og = ipe([
  dw(1, Pn),
  dw(2, he),
  dw(3, De),
  dw(4, Ot)
], vn);
gt(
  vn.ID,
  vn,
  4
  /* EditorContributionInstantiation.Lazy */
);
const zL = Ui.bindToContribution(vn.get);
se(new zL({
  id: "jumpToNextSnippetPlaceholder",
  precondition: U.and(vn.InSnippetMode, vn.HasNextTabstop),
  handler: (r) => r.next(),
  kbOpts: {
    weight: 130,
    kbExpr: x.textInputFocus,
    primary: 2
    /* KeyCode.Tab */
  }
}));
se(new zL({
  id: "jumpToPrevSnippetPlaceholder",
  precondition: U.and(vn.InSnippetMode, vn.HasPrevTabstop),
  handler: (r) => r.prev(),
  kbOpts: {
    weight: 130,
    kbExpr: x.textInputFocus,
    primary: 1026
    /* KeyCode.Tab */
  }
}));
se(new zL({
  id: "leaveSnippet",
  precondition: vn.InSnippetMode,
  handler: (r) => r.cancel(!0),
  kbOpts: {
    weight: 130,
    kbExpr: x.textInputFocus,
    primary: 9,
    secondary: [
      1033
      /* KeyCode.Escape */
    ]
  }
}));
se(new zL({
  id: "acceptSnippet",
  precondition: vn.InSnippetMode,
  handler: (r) => r.finish()
  // kbOpts: {
  // 	weight: KeybindingWeight.EditorContrib + 30,
  // 	kbExpr: EditorContextKeys.textFocus,
  // 	primary: KeyCode.Enter,
  // }
}));
var npe = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, ix = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, to;
(function(r) {
  r[r.Undo = 0] = "Undo", r[r.Redo = 1] = "Redo", r[r.AcceptWord = 2] = "AcceptWord", r[r.Other = 3] = "Other";
})(to || (to = {}));
let VT = class extends P {
  get isAcceptingPartially() {
    return this._isAcceptingPartially;
  }
  constructor(e, t, i, n, s, o, a, l, d, c, h, u) {
    super(), this.textModel = e, this.selectedSuggestItem = t, this.textModelVersionId = i, this._positions = n, this._debounceValue = s, this._suggestPreviewEnabled = o, this._suggestPreviewMode = a, this._inlineSuggestMode = l, this._enabled = d, this._instantiationService = c, this._commandService = h, this._languageConfigurationService = u, this._source = this._register(this._instantiationService.createInstance(HT, this.textModel, this.textModelVersionId, this._debounceValue)), this._isActive = rt(this, !1), this._forceUpdateExplicitlySignal = Q0(this), this._selectedInlineCompletionId = rt(this, void 0), this._primaryPosition = Pe(this, (f) => {
      var m;
      return (m = this._positions.read(f)[0]) !== null && m !== void 0 ? m : new A(1, 1);
    }), this._isAcceptingPartially = !1, this._preserveCurrentCompletionReasons = /* @__PURE__ */ new Set([
      to.Redo,
      to.Undo,
      to.AcceptWord
    ]), this._fetchInlineCompletionsPromise = pie({
      owner: this,
      createEmptyChangeSummary: () => ({
        preserveCurrentCompletion: !1,
        inlineCompletionTriggerKind: nu.Automatic
      }),
      handleChange: (f, m) => (f.didChange(this.textModelVersionId) && this._preserveCurrentCompletionReasons.has(f.change) ? m.preserveCurrentCompletion = !0 : f.didChange(this._forceUpdateExplicitlySignal) && (m.inlineCompletionTriggerKind = nu.Explicit), !0)
    }, (f, m) => {
      if (this._forceUpdateExplicitlySignal.read(f), !(this._enabled.read(f) && this.selectedSuggestItem.read(f) || this._isActive.read(f))) {
        this._source.cancelUpdate();
        return;
      }
      this.textModelVersionId.read(f);
      const v = this._source.suggestWidgetInlineCompletions.get(), b = this.selectedSuggestItem.read(f);
      if (v && !b) {
        const k = this._source.inlineCompletions.get();
        Nt((E) => {
          (!k || v.request.versionId > k.request.versionId) && this._source.inlineCompletions.set(v.clone(), E), this._source.clearSuggestWidgetInlineCompletions(E);
        });
      }
      const C = this._primaryPosition.read(f), w = {
        triggerKind: m.inlineCompletionTriggerKind,
        selectedSuggestionInfo: b == null ? void 0 : b.toSelectedSuggestionInfo()
      }, S = this.selectedInlineCompletion.get(), y = m.preserveCurrentCompletion || S != null && S.forwardStable ? S : void 0;
      return this._source.fetch(C, w, y);
    }), this._filteredInlineCompletionItems = Fl({ owner: this, equalsFn: $I() }, (f) => {
      const m = this._source.inlineCompletions.read(f);
      if (!m)
        return [];
      const _ = this._primaryPosition.read(f);
      return m.inlineCompletions.filter((b) => b.isVisible(this.textModel, _, f));
    }), this.selectedInlineCompletionIndex = Pe(this, (f) => {
      const m = this._selectedInlineCompletionId.read(f), _ = this._filteredInlineCompletionItems.read(f), v = this._selectedInlineCompletionId === void 0 ? -1 : _.findIndex((b) => b.semanticId === m);
      return v === -1 ? (this._selectedInlineCompletionId.set(void 0, void 0), 0) : v;
    }), this.selectedInlineCompletion = Pe(this, (f) => {
      const m = this._filteredInlineCompletionItems.read(f), _ = this.selectedInlineCompletionIndex.read(f);
      return m[_];
    }), this.activeCommands = Fl({ owner: this, equalsFn: $I() }, (f) => {
      var m, _;
      return (_ = (m = this.selectedInlineCompletion.read(f)) === null || m === void 0 ? void 0 : m.inlineCompletion.source.inlineCompletions.commands) !== null && _ !== void 0 ? _ : [];
    }), this.lastTriggerKind = this._source.inlineCompletions.map(this, (f) => f == null ? void 0 : f.request.context.triggerKind), this.inlineCompletionsCount = Pe(this, (f) => {
      if (this.lastTriggerKind.read(f) === nu.Explicit)
        return this._filteredInlineCompletionItems.read(f).length;
    }), this.state = Fl({
      owner: this,
      equalsFn: (f, m) => !f || !m ? f === m : GW(f.ghostTexts, m.ghostTexts) && f.inlineCompletion === m.inlineCompletion && f.suggestItem === m.suggestItem
    }, (f) => {
      var m, _;
      const v = this.textModel, b = this.selectedSuggestItem.read(f);
      if (b) {
        const C = mu(b.toSingleTextEdit(), v), w = this._computeAugmentation(C, f);
        if (!this._suggestPreviewEnabled.read(f) && !w)
          return;
        const y = (m = w == null ? void 0 : w.edit) !== null && m !== void 0 ? m : C, k = w ? w.edit.text.length - C.text.length : 0, E = this._suggestPreviewMode.read(f), N = this._positions.read(f), F = [y, ...nx(this.textModel, N, y)], V = F.map((H, re) => JW(H, v, E, N[re], k)).filter(qa), Z = (_ = V[0]) !== null && _ !== void 0 ? _ : new Bv(y.range.endLineNumber, []);
        return { edits: F, primaryGhostText: Z, ghostTexts: V, inlineCompletion: w == null ? void 0 : w.completion, suggestItem: b };
      } else {
        if (!this._isActive.read(f))
          return;
        const C = this.selectedInlineCompletion.read(f);
        if (!C)
          return;
        const w = C.toSingleTextEdit(f), S = this._inlineSuggestMode.read(f), y = this._positions.read(f), k = [w, ...nx(this.textModel, y, w)], E = k.map((N, F) => JW(N, v, S, y[F], 0)).filter(qa);
        return E[0] ? { edits: k, primaryGhostText: E[0], ghostTexts: E, inlineCompletion: C, suggestItem: void 0 } : void 0;
      }
    }), this.ghostTexts = Fl({
      owner: this,
      equalsFn: GW
    }, (f) => {
      const m = this.state.read(f);
      if (m)
        return m.ghostTexts;
    }), this.primaryGhostText = Fl({
      owner: this,
      equalsFn: G4
    }, (f) => {
      const m = this.state.read(f);
      if (m)
        return m == null ? void 0 : m.primaryGhostText;
    }), this._register(xb(this._fetchInlineCompletionsPromise));
    let g;
    this._register(qe((f) => {
      var m, _;
      const v = this.state.read(f), b = v == null ? void 0 : v.inlineCompletion;
      if ((b == null ? void 0 : b.semanticId) !== (g == null ? void 0 : g.semanticId) && (g = b, b)) {
        const C = b.inlineCompletion, w = C.source;
        (_ = (m = w.provider).handleItemDidShow) === null || _ === void 0 || _.call(m, w.inlineCompletions, C.sourceInlineCompletion, C.insertText);
      }
    }));
  }
  async trigger(e) {
    this._isActive.set(!0, e), await this._fetchInlineCompletionsPromise.get();
  }
  async triggerExplicitly(e) {
    dv(e, (t) => {
      this._isActive.set(!0, t), this._forceUpdateExplicitlySignal.trigger(t);
    }), await this._fetchInlineCompletionsPromise.get();
  }
  stop(e) {
    dv(e, (t) => {
      this._isActive.set(!1, t), this._source.clear(t);
    });
  }
  _computeAugmentation(e, t) {
    const i = this.textModel, n = this._source.suggestWidgetInlineCompletions.read(t), s = n ? n.inlineCompletions : [this.selectedInlineCompletion.read(t)].filter(qa);
    return qK(s, (a) => {
      let l = a.toSingleTextEdit(t);
      return l = mu(l, i, L.fromPositions(l.range.getStartPosition(), e.range.getEndPosition())), X4(l, e) ? { completion: a, edit: l } : void 0;
    });
  }
  async _deltaSelectedInlineCompletionIndex(e) {
    await this.triggerExplicitly();
    const t = this._filteredInlineCompletionItems.get() || [];
    if (t.length > 0) {
      const i = (this.selectedInlineCompletionIndex.get() + e + t.length) % t.length;
      this._selectedInlineCompletionId.set(t[i].semanticId, void 0);
    } else
      this._selectedInlineCompletionId.set(void 0, void 0);
  }
  async next() {
    await this._deltaSelectedInlineCompletionIndex(1);
  }
  async previous() {
    await this._deltaSelectedInlineCompletionIndex(-1);
  }
  async accept(e) {
    var t;
    if (e.getModel() !== this.textModel)
      throw new Li();
    const i = this.state.get();
    if (!i || i.primaryGhostText.isEmpty() || !i.inlineCompletion)
      return;
    const n = i.inlineCompletion.toInlineCompletion(void 0);
    if (e.pushUndoStop(), n.snippetInfo)
      e.executeEdits("inlineSuggestion.accept", [
        ti.replace(n.range, ""),
        ...n.additionalTextEdits
      ]), e.setPosition(n.snippetInfo.range.getStartPosition(), "inlineCompletionAccept"), (t = vn.get(e)) === null || t === void 0 || t.insert(n.snippetInfo.snippet, { undoStopBefore: !1 });
    else {
      const s = i.edits, o = gB(s).map((a) => ge.fromPositions(a));
      e.executeEdits("inlineSuggestion.accept", [
        ...s.map((a) => ti.replace(a.range, a.text)),
        ...n.additionalTextEdits
      ]), e.setSelections(o, "inlineCompletionAccept");
    }
    n.command && n.source.addRef(), Nt((s) => {
      this._source.clear(s), this._isActive.set(!1, s);
    }), n.command && (await this._commandService.executeCommand(n.command.id, ...n.command.arguments || []).then(void 0, _i), n.source.removeRef());
  }
  async acceptNextWord(e) {
    await this._acceptNext(
      e,
      (t, i) => {
        const n = this.textModel.getLanguageIdAtPosition(t.lineNumber, t.column), s = this._languageConfigurationService.getLanguageConfiguration(n), o = new RegExp(s.wordDefinition.source, s.wordDefinition.flags.replace("g", "")), a = i.match(o);
        let l = 0;
        a && a.index !== void 0 ? a.index === 0 ? l = a[0].length : l = a.index : l = i.length;
        const c = /\s+/g.exec(i);
        return c && c.index !== void 0 && c.index + c[0].length < l && (l = c.index + c[0].length), l;
      },
      0
      /* PartialAcceptTriggerKind.Word */
    );
  }
  async acceptNextLine(e) {
    await this._acceptNext(
      e,
      (t, i) => {
        const n = i.match(/\n/);
        return n && n.index !== void 0 ? n.index + 1 : i.length;
      },
      1
      /* PartialAcceptTriggerKind.Line */
    );
  }
  async _acceptNext(e, t, i) {
    if (e.getModel() !== this.textModel)
      throw new Li();
    const n = this.state.get();
    if (!n || n.primaryGhostText.isEmpty() || !n.inlineCompletion)
      return;
    const s = n.primaryGhostText, o = n.inlineCompletion.toInlineCompletion(void 0);
    if (o.snippetInfo || o.filterText !== o.insertText) {
      await this.accept(e);
      return;
    }
    const a = s.parts[0], l = new A(s.lineNumber, a.column), d = a.text, c = t(l, d);
    if (c === d.length && s.parts.length === 1) {
      this.accept(e);
      return;
    }
    const h = d.substring(0, c), u = this._positions.get(), g = u[0];
    o.source.addRef();
    try {
      this._isAcceptingPartially = !0;
      try {
        e.pushUndoStop();
        const f = L.fromPositions(g, l), m = e.getModel().getValueInRange(f) + h, _ = new Nc(f, m), v = [_, ...nx(this.textModel, u, _)], b = gB(v).map((C) => ge.fromPositions(C));
        e.executeEdits("inlineSuggestion.accept", v.map((C) => ti.replace(C.range, C.text))), e.setSelections(b, "inlineCompletionPartialAccept"), e.revealPositionInCenterIfOutsideViewport(
          e.getPosition(),
          1
          /* ScrollType.Immediate */
        );
      } finally {
        this._isAcceptingPartially = !1;
      }
      if (o.source.provider.handlePartialAccept) {
        const f = L.fromPositions(o.range.getStartPosition(), Tc.ofText(h).addToPosition(l)), m = e.getModel().getValueInRange(
          f,
          1
          /* EndOfLinePreference.LF */
        );
        o.source.provider.handlePartialAccept(o.source.inlineCompletions, o.sourceInlineCompletion, m.length, {
          kind: i
        });
      }
    } finally {
      o.source.removeRef();
    }
  }
  handleSuggestAccepted(e) {
    var t, i;
    const n = mu(e.toSingleTextEdit(), this.textModel), s = this._computeAugmentation(n, void 0);
    if (!s)
      return;
    const o = s.completion.inlineCompletion;
    (i = (t = o.source.provider).handlePartialAccept) === null || i === void 0 || i.call(t, o.source.inlineCompletions, o.sourceInlineCompletion, n.text.length, {
      kind: 2
    });
  }
};
VT = npe([
  ix(9, be),
  ix(10, $t),
  ix(11, Ot)
], VT);
function nx(r, e, t) {
  if (e.length === 1)
    return [];
  const i = e[0], n = e.slice(1), s = t.range.getStartPosition(), o = t.range.getEndPosition(), a = r.getValueInRange(L.fromPositions(i, o)), l = ZW(i, s);
  if (l.lineNumber < 1)
    return He(new Li(`positionWithinTextEdit line number should be bigger than 0.
			Invalid subtraction between ${i.toString()} and ${s.toString()}`)), [];
  const d = spe(t.text, l);
  return n.map((c) => {
    const h = xfe(ZW(c, s), o), u = r.getValueInRange(L.fromPositions(c, h)), g = xc(a, u), f = L.fromPositions(c, c.delta(0, g));
    return new Nc(f, d);
  });
}
function spe(r, e) {
  let t = "";
  const i = GK(r);
  for (let n = e.lineNumber - 1; n < i.length; n++)
    t += i[n].substring(n === e.lineNumber - 1 ? e.column - 1 : 0);
  return t;
}
function gB(r) {
  const e = ZK.createSortPermutation(r, (s, o) => L.compareRangesUsingStarts(s.range, o.range)), i = new ZN(e.apply(r)).getNewRanges();
  return e.inverse().apply(i).map((s) => s.getEndPosition());
}
var ope = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, fB = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, Um;
class TR {
  constructor(e) {
    this.name = e;
  }
  select(e, t, i) {
    if (i.length === 0)
      return 0;
    const n = i[0].score[0];
    for (let s = 0; s < i.length; s++) {
      const { score: o, completion: a } = i[s];
      if (o[0] !== n)
        break;
      if (a.preselect)
        return s;
    }
    return 0;
  }
}
class J4 extends TR {
  constructor() {
    super("first");
  }
  memorize(e, t, i) {
  }
  toJSON() {
  }
  fromJSON() {
  }
}
class rpe extends TR {
  constructor() {
    super("recentlyUsed"), this._cache = new Cd(300, 0.66), this._seq = 0;
  }
  memorize(e, t, i) {
    const n = `${e.getLanguageId()}/${i.textLabel}`;
    this._cache.set(n, {
      touch: this._seq++,
      type: i.completion.kind,
      insertText: i.completion.insertText
    });
  }
  select(e, t, i) {
    if (i.length === 0)
      return 0;
    const n = e.getLineContent(t.lineNumber).substr(t.column - 10, t.column - 1);
    if (/\s$/.test(n))
      return super.select(e, t, i);
    const s = i[0].score[0];
    let o = -1, a = -1, l = -1;
    for (let d = 0; d < i.length && i[d].score[0] === s; d++) {
      const c = `${e.getLanguageId()}/${i[d].textLabel}`, h = this._cache.peek(c);
      if (h && h.touch > l && h.type === i[d].completion.kind && h.insertText === i[d].completion.insertText && (l = h.touch, a = d), i[d].completion.preselect && o === -1)
        return o = d;
    }
    return a !== -1 ? a : o !== -1 ? o : 0;
  }
  toJSON() {
    return this._cache.toJSON();
  }
  fromJSON(e) {
    this._cache.clear();
    const t = 0;
    for (const [i, n] of e)
      n.touch = t, n.type = typeof n.type == "number" ? n.type : XN.fromString(n.type), this._cache.set(i, n);
    this._seq = this._cache.size;
  }
}
class ape extends TR {
  constructor() {
    super("recentlyUsedByPrefix"), this._trie = xf.forStrings(), this._seq = 0;
  }
  memorize(e, t, i) {
    const { word: n } = e.getWordUntilPosition(t), s = `${e.getLanguageId()}/${n}`;
    this._trie.set(s, {
      type: i.completion.kind,
      insertText: i.completion.insertText,
      touch: this._seq++
    });
  }
  select(e, t, i) {
    const { word: n } = e.getWordUntilPosition(t);
    if (!n)
      return super.select(e, t, i);
    const s = `${e.getLanguageId()}/${n}`;
    let o = this._trie.get(s);
    if (o || (o = this._trie.findSubstr(s)), o)
      for (let a = 0; a < i.length; a++) {
        const { kind: l, insertText: d } = i[a].completion;
        if (l === o.type && d === o.insertText)
          return a;
      }
    return super.select(e, t, i);
  }
  toJSON() {
    const e = [];
    return this._trie.forEach((t, i) => e.push([i, t])), e.sort((t, i) => -(t[1].touch - i[1].touch)).forEach((t, i) => t[1].touch = i), e.slice(0, 200);
  }
  fromJSON(e) {
    if (this._trie.clear(), e.length > 0) {
      this._seq = e[0][1].touch + 1;
      for (const [t, i] of e)
        i.type = typeof i.type == "number" ? i.type : XN.fromString(i.type), this._trie.set(t, i);
    }
  }
}
let Vv = Um = class {
  constructor(e, t) {
    this._storageService = e, this._configService = t, this._disposables = new q(), this._persistSoon = new xt(() => this._saveState(), 500), this._disposables.add(e.onWillSaveState((i) => {
      i.reason === uv.SHUTDOWN && this._saveState();
    }));
  }
  dispose() {
    this._disposables.dispose(), this._persistSoon.dispose();
  }
  memorize(e, t, i) {
    this._withStrategy(e, t).memorize(e, t, i), this._persistSoon.schedule();
  }
  select(e, t, i) {
    return this._withStrategy(e, t).select(e, t, i);
  }
  _withStrategy(e, t) {
    var i;
    const n = this._configService.getValue("editor.suggestSelection", {
      overrideIdentifier: e.getLanguageIdAtPosition(t.lineNumber, t.column),
      resource: e.uri
    });
    if (((i = this._strategy) === null || i === void 0 ? void 0 : i.name) !== n) {
      this._saveState();
      const s = Um._strategyCtors.get(n) || J4;
      this._strategy = new s();
      try {
        const a = this._configService.getValue("editor.suggest.shareSuggestSelections") ? 0 : 1, l = this._storageService.get(`${Um._storagePrefix}/${n}`, a);
        l && this._strategy.fromJSON(JSON.parse(l));
      } catch {
      }
    }
    return this._strategy;
  }
  _saveState() {
    if (this._strategy) {
      const t = this._configService.getValue("editor.suggest.shareSuggestSelections") ? 0 : 1, i = JSON.stringify(this._strategy);
      this._storageService.store(
        `${Um._storagePrefix}/${this._strategy.name}`,
        i,
        t,
        1
        /* StorageTarget.MACHINE */
      );
    }
  }
};
Vv._strategyCtors = /* @__PURE__ */ new Map([
  ["recentlyUsedByPrefix", ape],
  ["recentlyUsed", rpe],
  ["first", J4]
]);
Vv._storagePrefix = "suggest/memories";
Vv = Um = ope([
  fB(0, br),
  fB(1, Ge)
], Vv);
const UL = et("ISuggestMemories");
ot(
  UL,
  Vv,
  1
  /* InstantiationType.Delayed */
);
var lpe = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, dpe = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, zT;
let zv = zT = class {
  constructor(e, t) {
    this._editor = e, this._enabled = !1, this._ckAtEnd = zT.AtEnd.bindTo(t), this._configListener = this._editor.onDidChangeConfiguration((i) => i.hasChanged(
      123
      /* EditorOption.tabCompletion */
    ) && this._update()), this._update();
  }
  dispose() {
    var e;
    this._configListener.dispose(), (e = this._selectionListener) === null || e === void 0 || e.dispose(), this._ckAtEnd.reset();
  }
  _update() {
    const e = this._editor.getOption(
      123
      /* EditorOption.tabCompletion */
    ) === "on";
    if (this._enabled !== e)
      if (this._enabled = e, this._enabled) {
        const t = () => {
          if (!this._editor.hasModel()) {
            this._ckAtEnd.set(!1);
            return;
          }
          const i = this._editor.getModel(), n = this._editor.getSelection(), s = i.getWordAtPosition(n.getStartPosition());
          if (!s) {
            this._ckAtEnd.set(!1);
            return;
          }
          this._ckAtEnd.set(s.endColumn === n.getStartPosition().column);
        };
        this._selectionListener = this._editor.onDidChangeCursorSelection(t), t();
      } else this._selectionListener && (this._ckAtEnd.reset(), this._selectionListener.dispose(), this._selectionListener = void 0);
  }
};
zv.AtEnd = new oe("atEndOfWord", !1);
zv = zT = lpe([
  dpe(1, De)
], zv);
var cpe = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, hpe = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, $m;
let Hu = $m = class {
  constructor(e, t) {
    this._editor = e, this._index = 0, this._ckOtherSuggestions = $m.OtherSuggestions.bindTo(t);
  }
  dispose() {
    this.reset();
  }
  reset() {
    var e;
    this._ckOtherSuggestions.reset(), (e = this._listener) === null || e === void 0 || e.dispose(), this._model = void 0, this._acceptNext = void 0, this._ignore = !1;
  }
  set({ model: e, index: t }, i) {
    if (e.items.length === 0) {
      this.reset();
      return;
    }
    if ($m._moveIndex(!0, e, t) === t) {
      this.reset();
      return;
    }
    this._acceptNext = i, this._model = e, this._index = t, this._listener = this._editor.onDidChangeCursorPosition(() => {
      this._ignore || this.reset();
    }), this._ckOtherSuggestions.set(!0);
  }
  static _moveIndex(e, t, i) {
    let n = i;
    for (let s = t.items.length; s > 0 && (n = (n + t.items.length + (e ? 1 : -1)) % t.items.length, !(n === i || !t.items[n].completion.additionalTextEdits)); s--)
      ;
    return n;
  }
  next() {
    this._move(!0);
  }
  prev() {
    this._move(!1);
  }
  _move(e) {
    if (this._model)
      try {
        this._ignore = !0, this._index = $m._moveIndex(e, this._model, this._index), this._acceptNext({ index: this._index, item: this._model.items[this._index], model: this._model });
      } finally {
        this._ignore = !1;
      }
  }
};
Hu.OtherSuggestions = new oe("hasOtherSuggestions", !1);
Hu = $m = cpe([
  hpe(1, De)
], Hu);
class upe {
  constructor(e, t, i, n) {
    this._disposables = new q(), this._disposables.add(i.onDidSuggest((s) => {
      s.completionModel.items.length === 0 && this.reset();
    })), this._disposables.add(i.onDidCancel((s) => {
      this.reset();
    })), this._disposables.add(t.onDidShow(() => this._onItem(t.getFocusedItem()))), this._disposables.add(t.onDidFocus(this._onItem, this)), this._disposables.add(t.onDidHide(this.reset, this)), this._disposables.add(e.onWillType((s) => {
      if (this._active && !t.isFrozen() && i.state !== 0) {
        const o = s.charCodeAt(s.length - 1);
        this._active.acceptCharacters.has(o) && e.getOption(
          0
          /* EditorOption.acceptSuggestionOnCommitCharacter */
        ) && n(this._active.item);
      }
    }));
  }
  _onItem(e) {
    if (!e || !Rn(e.item.completion.commitCharacters)) {
      this.reset();
      return;
    }
    if (this._active && this._active.item.item === e.item)
      return;
    const t = new lS();
    for (const i of e.item.completion.commitCharacters)
      i.length > 0 && t.add(i.charCodeAt(0));
    this._active = { acceptCharacters: t, item: e };
  }
  reset() {
    this._active = void 0;
  }
  dispose() {
    this._disposables.dispose();
  }
}
class io {
  async provideSelectionRanges(e, t) {
    const i = [];
    for (const n of t) {
      const s = [];
      i.push(s);
      const o = /* @__PURE__ */ new Map();
      await new Promise((a) => io._bracketsRightYield(a, 0, e, n, o)), await new Promise((a) => io._bracketsLeftYield(a, 0, e, n, o, s));
    }
    return i;
  }
  static _bracketsRightYield(e, t, i, n, s) {
    const o = /* @__PURE__ */ new Map(), a = Date.now();
    for (; ; ) {
      if (t >= io._maxRounds) {
        e();
        break;
      }
      if (!n) {
        e();
        break;
      }
      const l = i.bracketPairs.findNextBracket(n);
      if (!l) {
        e();
        break;
      }
      if (Date.now() - a > io._maxDuration) {
        setTimeout(() => io._bracketsRightYield(e, t + 1, i, n, s));
        break;
      }
      if (l.bracketInfo.isOpeningBracket) {
        const c = l.bracketInfo.bracketText, h = o.has(c) ? o.get(c) : 0;
        o.set(c, h + 1);
      } else {
        const c = l.bracketInfo.getOpeningBrackets()[0].bracketText;
        let h = o.has(c) ? o.get(c) : 0;
        if (h -= 1, o.set(c, Math.max(0, h)), h < 0) {
          let u = s.get(c);
          u || (u = new Ps(), s.set(c, u)), u.push(l.range);
        }
      }
      n = l.range.getEndPosition();
    }
  }
  static _bracketsLeftYield(e, t, i, n, s, o) {
    const a = /* @__PURE__ */ new Map(), l = Date.now();
    for (; ; ) {
      if (t >= io._maxRounds && s.size === 0) {
        e();
        break;
      }
      if (!n) {
        e();
        break;
      }
      const d = i.bracketPairs.findPrevBracket(n);
      if (!d) {
        e();
        break;
      }
      if (Date.now() - l > io._maxDuration) {
        setTimeout(() => io._bracketsLeftYield(e, t + 1, i, n, s, o));
        break;
      }
      if (d.bracketInfo.isOpeningBracket) {
        const h = d.bracketInfo.bracketText;
        let u = a.has(h) ? a.get(h) : 0;
        if (u -= 1, a.set(h, Math.max(0, u)), u < 0) {
          const g = s.get(h);
          if (g) {
            const f = g.shift();
            g.size === 0 && s.delete(h);
            const m = L.fromPositions(d.range.getEndPosition(), f.getStartPosition()), _ = L.fromPositions(d.range.getStartPosition(), f.getEndPosition());
            o.push({ range: m }), o.push({ range: _ }), io._addBracketLeading(i, _, o);
          }
        }
      } else {
        const h = d.bracketInfo.getOpeningBrackets()[0].bracketText, u = a.has(h) ? a.get(h) : 0;
        a.set(h, u + 1);
      }
      n = d.range.getStartPosition();
    }
  }
  static _addBracketLeading(e, t, i) {
    if (t.startLineNumber === t.endLineNumber)
      return;
    const n = t.startLineNumber, s = e.getLineFirstNonWhitespaceColumn(n);
    s !== 0 && s !== t.startColumn && (i.push({ range: L.fromPositions(new A(n, s), t.getEndPosition()) }), i.push({ range: L.fromPositions(new A(n, 1), t.getEndPosition()) }));
    const o = n - 1;
    if (o > 0) {
      const a = e.getLineFirstNonWhitespaceColumn(o);
      a === t.startColumn && a !== e.getLineLastNonWhitespaceColumn(o) && (i.push({ range: L.fromPositions(new A(o, a), t.getEndPosition()) }), i.push({ range: L.fromPositions(new A(o, 1), t.getEndPosition()) }));
    }
  }
}
io._maxDuration = 30;
io._maxRounds = 2;
class Pr {
  static async create(e, t) {
    if (!t.getOption(
      118
      /* EditorOption.suggest */
    ).localityBonus || !t.hasModel())
      return Pr.None;
    const i = t.getModel(), n = t.getPosition();
    if (!e.canComputeWordRanges(i.uri))
      return Pr.None;
    const [s] = await new io().provideSelectionRanges(i, [n]);
    if (s.length === 0)
      return Pr.None;
    const o = await e.computeWordRanges(i.uri, s[0].range);
    if (!o)
      return Pr.None;
    const a = i.getWordUntilPosition(n);
    return delete o[a.word], new class extends Pr {
      distance(l, d) {
        if (!n.equals(t.getPosition()))
          return 0;
        if (d.kind === 17)
          return 2 << 20;
        const c = typeof d.label == "string" ? d.label : d.label.label, h = o[c];
        if (uH(h))
          return 2 << 20;
        const u = R_(h, L.fromPositions(l), L.compareRangesUsingStarts), g = u >= 0 ? h[u] : h[Math.max(0, ~u - 1)];
        let f = s.length;
        for (const m of s) {
          if (!L.containsRange(m.range, g))
            break;
          f -= 1;
        }
        return f;
      }
    }();
  }
}
Pr.None = new class extends Pr {
  distance() {
    return 0;
  }
}();
let pB = class {
  constructor(e, t) {
    this.leadingLineContent = e, this.characterCountDelta = t;
  }
};
class Yd {
  constructor(e, t, i, n, s, o, a = V0.default, l = void 0) {
    this.clipboardText = l, this._snippetCompareFn = Yd._compareCompletionItems, this._items = e, this._column = t, this._wordDistance = n, this._options = s, this._refilterKind = 1, this._lineContext = i, this._fuzzyScoreOptions = a, o === "top" ? this._snippetCompareFn = Yd._compareCompletionItemsSnippetsUp : o === "bottom" && (this._snippetCompareFn = Yd._compareCompletionItemsSnippetsDown);
  }
  get lineContext() {
    return this._lineContext;
  }
  set lineContext(e) {
    (this._lineContext.leadingLineContent !== e.leadingLineContent || this._lineContext.characterCountDelta !== e.characterCountDelta) && (this._refilterKind = this._lineContext.characterCountDelta < e.characterCountDelta && this._filteredItems ? 2 : 1, this._lineContext = e);
  }
  get items() {
    return this._ensureCachedState(), this._filteredItems;
  }
  getItemsByProvider() {
    return this._ensureCachedState(), this._itemsByProvider;
  }
  getIncompleteProvider() {
    this._ensureCachedState();
    const e = /* @__PURE__ */ new Set();
    for (const [t, i] of this.getItemsByProvider())
      i.length > 0 && i[0].container.incomplete && e.add(t);
    return e;
  }
  get stats() {
    return this._ensureCachedState(), this._stats;
  }
  _ensureCachedState() {
    this._refilterKind !== 0 && this._createCachedState();
  }
  _createCachedState() {
    this._itemsByProvider = /* @__PURE__ */ new Map();
    const e = [], { leadingLineContent: t, characterCountDelta: i } = this._lineContext;
    let n = "", s = "";
    const o = this._refilterKind === 1 ? this._items : this._filteredItems, a = [], l = !this._options.filterGraceful || o.length > 2e3 ? Du : hee;
    for (let d = 0; d < o.length; d++) {
      const c = o[d];
      if (c.isInvalid)
        continue;
      const h = this._itemsByProvider.get(c.provider);
      h ? h.push(c) : this._itemsByProvider.set(c.provider, [c]);
      const u = c.position.column - c.editStart.column, g = u + i - (c.position.column - this._column);
      if (n.length !== g && (n = g === 0 ? "" : t.slice(-g), s = n.toLowerCase()), c.word = n, g === 0)
        c.score = qr.Default;
      else {
        let f = 0;
        for (; f < u; ) {
          const m = n.charCodeAt(f);
          if (m === 32 || m === 9)
            f += 1;
          else
            break;
        }
        if (f >= g)
          c.score = qr.Default;
        else if (typeof c.completion.filterText == "string") {
          const m = l(n, s, f, c.completion.filterText, c.filterTextLow, 0, this._fuzzyScoreOptions);
          if (!m)
            continue;
          vx(c.completion.filterText, c.textLabel) === 0 ? c.score = m : (c.score = aee(n, s, f, c.textLabel, c.labelLow, 0), c.score[0] = m[0]);
        } else {
          const m = l(n, s, f, c.textLabel, c.labelLow, 0, this._fuzzyScoreOptions);
          if (!m)
            continue;
          c.score = m;
        }
      }
      c.idx = d, c.distance = this._wordDistance.distance(c.position, c.completion), a.push(c), e.push(c.textLabel.length);
    }
    this._filteredItems = a.sort(this._snippetCompareFn), this._refilterKind = 0, this._stats = {
      pLabelLen: e.length ? YK(e.length - 0.85, e, (d, c) => d - c) : 0
    };
  }
  static _compareCompletionItems(e, t) {
    return e.score[0] > t.score[0] ? -1 : e.score[0] < t.score[0] ? 1 : e.distance < t.distance ? -1 : e.distance > t.distance ? 1 : e.idx < t.idx ? -1 : e.idx > t.idx ? 1 : 0;
  }
  static _compareCompletionItemsSnippetsDown(e, t) {
    if (e.completion.kind !== t.completion.kind) {
      if (e.completion.kind === 27)
        return 1;
      if (t.completion.kind === 27)
        return -1;
    }
    return Yd._compareCompletionItems(e, t);
  }
  static _compareCompletionItemsSnippetsUp(e, t) {
    if (e.completion.kind !== t.completion.kind) {
      if (e.completion.kind === 27)
        return -1;
      if (t.completion.kind === 27)
        return 1;
    }
    return Yd._compareCompletionItems(e, t);
  }
}
var gpe = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Nd = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, UT;
class xh {
  static shouldAutoTrigger(e) {
    if (!e.hasModel())
      return !1;
    const t = e.getModel(), i = e.getPosition();
    t.tokenization.tokenizeIfCheap(i.lineNumber);
    const n = t.getWordAtPosition(i);
    return !(!n || n.endColumn !== i.column && n.startColumn + 1 !== i.column || !isNaN(Number(n.word)));
  }
  constructor(e, t, i) {
    this.leadingLineContent = e.getLineContent(t.lineNumber).substr(0, t.column - 1), this.leadingWord = e.getWordUntilPosition(t), this.lineNumber = t.lineNumber, this.column = t.column, this.triggerOptions = i;
  }
}
function fpe(r, e, t) {
  if (!e.getContextKeyValue(rn.inlineSuggestionVisible.key))
    return !0;
  const i = e.getContextKeyValue(rn.suppressSuggestions.key);
  return i !== void 0 ? !i : !r.getOption(
    62
    /* EditorOption.inlineSuggest */
  ).suppressSuggestions;
}
function ppe(r, e, t) {
  if (!e.getContextKeyValue("inlineSuggestionVisible"))
    return !0;
  const i = e.getContextKeyValue(rn.suppressSuggestions.key);
  return i !== void 0 ? !i : !r.getOption(
    62
    /* EditorOption.inlineSuggest */
  ).suppressSuggestions;
}
let Ky = UT = class {
  constructor(e, t, i, n, s, o, a, l, d) {
    this._editor = e, this._editorWorkerService = t, this._clipboardService = i, this._telemetryService = n, this._logService = s, this._contextKeyService = o, this._configurationService = a, this._languageFeaturesService = l, this._envService = d, this._toDispose = new q(), this._triggerCharacterListener = new q(), this._triggerQuickSuggest = new vr(), this._triggerState = void 0, this._completionDisposables = new q(), this._onDidCancel = new R(), this._onDidTrigger = new R(), this._onDidSuggest = new R(), this.onDidCancel = this._onDidCancel.event, this.onDidTrigger = this._onDidTrigger.event, this.onDidSuggest = this._onDidSuggest.event, this._telemetryGate = 0, this._currentSelection = this._editor.getSelection() || new ge(1, 1, 1, 1), this._toDispose.add(this._editor.onDidChangeModel(() => {
      this._updateTriggerCharacters(), this.cancel();
    })), this._toDispose.add(this._editor.onDidChangeModelLanguage(() => {
      this._updateTriggerCharacters(), this.cancel();
    })), this._toDispose.add(this._editor.onDidChangeConfiguration(() => {
      this._updateTriggerCharacters();
    })), this._toDispose.add(this._languageFeaturesService.completionProvider.onDidChange(() => {
      this._updateTriggerCharacters(), this._updateActiveSuggestSession();
    }));
    let c = !1;
    this._toDispose.add(this._editor.onDidCompositionStart(() => {
      c = !0;
    })), this._toDispose.add(this._editor.onDidCompositionEnd(() => {
      c = !1, this._onCompositionEnd();
    })), this._toDispose.add(this._editor.onDidChangeCursorSelection((h) => {
      c || this._onCursorChange(h);
    })), this._toDispose.add(this._editor.onDidChangeModelContent(() => {
      !c && this._triggerState !== void 0 && this._refilterCompletionItems();
    })), this._updateTriggerCharacters();
  }
  dispose() {
    zt(this._triggerCharacterListener), zt([this._onDidCancel, this._onDidSuggest, this._onDidTrigger, this._triggerQuickSuggest]), this._toDispose.dispose(), this._completionDisposables.dispose(), this.cancel();
  }
  _updateTriggerCharacters() {
    if (this._triggerCharacterListener.clear(), this._editor.getOption(
      91
      /* EditorOption.readOnly */
    ) || !this._editor.hasModel() || !this._editor.getOption(
      121
      /* EditorOption.suggestOnTriggerCharacters */
    ))
      return;
    const e = /* @__PURE__ */ new Map();
    for (const i of this._languageFeaturesService.completionProvider.all(this._editor.getModel()))
      for (const n of i.triggerCharacters || []) {
        let s = e.get(n);
        s || (s = /* @__PURE__ */ new Set(), s.add(jfe()), e.set(n, s)), s.add(i);
      }
    const t = (i) => {
      var n;
      if (!ppe(this._editor, this._contextKeyService, this._configurationService) || xh.shouldAutoTrigger(this._editor))
        return;
      if (!i) {
        const a = this._editor.getPosition();
        i = this._editor.getModel().getLineContent(a.lineNumber).substr(0, a.column - 1);
      }
      let s = "";
      iH(i.charCodeAt(i.length - 1)) ? $n(i.charCodeAt(i.length - 2)) && (s = i.substr(i.length - 2)) : s = i.charAt(i.length - 1);
      const o = e.get(s);
      if (o) {
        const a = /* @__PURE__ */ new Map();
        if (this._completionModel)
          for (const [l, d] of this._completionModel.getItemsByProvider())
            o.has(l) || a.set(l, d);
        this.trigger({
          auto: !0,
          triggerKind: 1,
          triggerCharacter: s,
          retrigger: !!this._completionModel,
          clipboardText: (n = this._completionModel) === null || n === void 0 ? void 0 : n.clipboardText,
          completionOptions: { providerFilter: o, providerItemsToReuse: a }
        });
      }
    };
    this._triggerCharacterListener.add(this._editor.onDidType(t)), this._triggerCharacterListener.add(this._editor.onDidCompositionEnd(() => t()));
  }
  // --- trigger/retrigger/cancel suggest
  get state() {
    return this._triggerState ? this._triggerState.auto ? 2 : 1 : 0;
  }
  cancel(e = !1) {
    var t;
    this._triggerState !== void 0 && (this._triggerQuickSuggest.cancel(), (t = this._requestToken) === null || t === void 0 || t.cancel(), this._requestToken = void 0, this._triggerState = void 0, this._completionModel = void 0, this._context = void 0, this._onDidCancel.fire({ retrigger: e }));
  }
  clear() {
    this._completionDisposables.clear();
  }
  _updateActiveSuggestSession() {
    this._triggerState !== void 0 && (!this._editor.hasModel() || !this._languageFeaturesService.completionProvider.has(this._editor.getModel()) ? this.cancel() : this.trigger({ auto: this._triggerState.auto, retrigger: !0 }));
  }
  _onCursorChange(e) {
    if (!this._editor.hasModel())
      return;
    const t = this._currentSelection;
    if (this._currentSelection = this._editor.getSelection(), !e.selection.isEmpty() || e.reason !== 0 && e.reason !== 3 || e.source !== "keyboard" && e.source !== "deleteLeft") {
      this.cancel();
      return;
    }
    this._triggerState === void 0 && e.reason === 0 ? (t.containsRange(this._currentSelection) || t.getEndPosition().isBeforeOrEqual(this._currentSelection.getPosition())) && this._doTriggerQuickSuggest() : this._triggerState !== void 0 && e.reason === 3 && this._refilterCompletionItems();
  }
  _onCompositionEnd() {
    this._triggerState === void 0 ? this._doTriggerQuickSuggest() : this._refilterCompletionItems();
  }
  _doTriggerQuickSuggest() {
    var e;
    lf.isAllOff(this._editor.getOption(
      89
      /* EditorOption.quickSuggestions */
    )) || this._editor.getOption(
      118
      /* EditorOption.suggest */
    ).snippetsPreventQuickSuggestions && (!((e = vn.get(this._editor)) === null || e === void 0) && e.isInSnippet()) || (this.cancel(), this._triggerQuickSuggest.cancelAndSet(() => {
      if (this._triggerState !== void 0 || !xh.shouldAutoTrigger(this._editor) || !this._editor.hasModel() || !this._editor.hasWidgetFocus())
        return;
      const t = this._editor.getModel(), i = this._editor.getPosition(), n = this._editor.getOption(
        89
        /* EditorOption.quickSuggestions */
      );
      if (!lf.isAllOff(n)) {
        if (!lf.isAllOn(n)) {
          t.tokenization.tokenizeIfCheap(i.lineNumber);
          const s = t.tokenization.getLineTokens(i.lineNumber), o = s.getStandardTokenType(s.findTokenIndexAtOffset(Math.max(i.column - 1 - 1, 0)));
          if (lf.valueFor(n, o) !== "on")
            return;
        }
        fpe(this._editor, this._contextKeyService, this._configurationService) && this._languageFeaturesService.completionProvider.has(t) && this.trigger({ auto: !0 });
      }
    }, this._editor.getOption(
      90
      /* EditorOption.quickSuggestionsDelay */
    )));
  }
  _refilterCompletionItems() {
    ct(this._editor.hasModel()), ct(this._triggerState !== void 0);
    const e = this._editor.getModel(), t = this._editor.getPosition(), i = new xh(e, t, { ...this._triggerState, refilter: !0 });
    this._onNewContext(i);
  }
  trigger(e) {
    var t, i, n, s, o, a;
    if (!this._editor.hasModel())
      return;
    const l = this._editor.getModel(), d = new xh(l, this._editor.getPosition(), e);
    this.cancel(e.retrigger), this._triggerState = e, this._onDidTrigger.fire({ auto: e.auto, shy: (t = e.shy) !== null && t !== void 0 ? t : !1, position: this._editor.getPosition() }), this._context = d;
    let c = {
      triggerKind: (i = e.triggerKind) !== null && i !== void 0 ? i : 0
      /* CompletionTriggerKind.Invoke */
    };
    e.triggerCharacter && (c = {
      triggerKind: 1,
      triggerCharacter: e.triggerCharacter
    }), this._requestToken = new mi();
    const h = this._editor.getOption(
      112
      /* EditorOption.snippetSuggestions */
    );
    let u = 1;
    switch (h) {
      case "top":
        u = 0;
        break;
      case "bottom":
        u = 2;
        break;
    }
    const { itemKind: g, showDeprecated: f } = UT.createSuggestFilter(this._editor), m = new Hv(u, (s = (n = e.completionOptions) === null || n === void 0 ? void 0 : n.kindFilter) !== null && s !== void 0 ? s : g, (o = e.completionOptions) === null || o === void 0 ? void 0 : o.providerFilter, (a = e.completionOptions) === null || a === void 0 ? void 0 : a.providerItemsToReuse, f), _ = Pr.create(this._editorWorkerService, this._editor), v = IR(this._languageFeaturesService.completionProvider, l, this._editor.getPosition(), m, c, this._requestToken.token);
    Promise.all([v, _]).then(async ([b, C]) => {
      var w;
      if ((w = this._requestToken) === null || w === void 0 || w.dispose(), !this._editor.hasModel())
        return;
      let S = e == null ? void 0 : e.clipboardText;
      if (!S && b.needsClipboard && (S = await this._clipboardService.readText()), this._triggerState === void 0)
        return;
      const y = this._editor.getModel(), k = new xh(y, this._editor.getPosition(), e), E = {
        ...V0.default,
        firstMatchCanBeWeak: !this._editor.getOption(
          118
          /* EditorOption.suggest */
        ).matchOnWordStartOnly
      };
      if (this._completionModel = new Yd(b.items, this._context.column, {
        leadingLineContent: k.leadingLineContent,
        characterCountDelta: k.column - this._context.column
      }, C, this._editor.getOption(
        118
        /* EditorOption.suggest */
      ), this._editor.getOption(
        112
        /* EditorOption.snippetSuggestions */
      ), E, S), this._completionDisposables.add(b.disposable), this._onNewContext(k), this._reportDurationsTelemetry(b.durations), !this._envService.isBuilt || this._envService.isExtensionDevelopment)
        for (const N of b.items)
          N.isInvalid && this._logService.warn(`[suggest] did IGNORE invalid completion item from ${N.provider._debugDisplayName}`, N.completion);
    }).catch(He);
  }
  _reportDurationsTelemetry(e) {
    this._telemetryGate++ % 230 === 0 && setTimeout(() => {
      this._telemetryService.publicLog2("suggest.durations.json", { data: JSON.stringify(e) }), this._logService.debug("suggest.durations.json", e);
    });
  }
  static createSuggestFilter(e) {
    const t = /* @__PURE__ */ new Set();
    e.getOption(
      112
      /* EditorOption.snippetSuggestions */
    ) === "none" && t.add(
      27
      /* CompletionItemKind.Snippet */
    );
    const n = e.getOption(
      118
      /* EditorOption.suggest */
    );
    return n.showMethods || t.add(
      0
      /* CompletionItemKind.Method */
    ), n.showFunctions || t.add(
      1
      /* CompletionItemKind.Function */
    ), n.showConstructors || t.add(
      2
      /* CompletionItemKind.Constructor */
    ), n.showFields || t.add(
      3
      /* CompletionItemKind.Field */
    ), n.showVariables || t.add(
      4
      /* CompletionItemKind.Variable */
    ), n.showClasses || t.add(
      5
      /* CompletionItemKind.Class */
    ), n.showStructs || t.add(
      6
      /* CompletionItemKind.Struct */
    ), n.showInterfaces || t.add(
      7
      /* CompletionItemKind.Interface */
    ), n.showModules || t.add(
      8
      /* CompletionItemKind.Module */
    ), n.showProperties || t.add(
      9
      /* CompletionItemKind.Property */
    ), n.showEvents || t.add(
      10
      /* CompletionItemKind.Event */
    ), n.showOperators || t.add(
      11
      /* CompletionItemKind.Operator */
    ), n.showUnits || t.add(
      12
      /* CompletionItemKind.Unit */
    ), n.showValues || t.add(
      13
      /* CompletionItemKind.Value */
    ), n.showConstants || t.add(
      14
      /* CompletionItemKind.Constant */
    ), n.showEnums || t.add(
      15
      /* CompletionItemKind.Enum */
    ), n.showEnumMembers || t.add(
      16
      /* CompletionItemKind.EnumMember */
    ), n.showKeywords || t.add(
      17
      /* CompletionItemKind.Keyword */
    ), n.showWords || t.add(
      18
      /* CompletionItemKind.Text */
    ), n.showColors || t.add(
      19
      /* CompletionItemKind.Color */
    ), n.showFiles || t.add(
      20
      /* CompletionItemKind.File */
    ), n.showReferences || t.add(
      21
      /* CompletionItemKind.Reference */
    ), n.showColors || t.add(
      22
      /* CompletionItemKind.Customcolor */
    ), n.showFolders || t.add(
      23
      /* CompletionItemKind.Folder */
    ), n.showTypeParameters || t.add(
      24
      /* CompletionItemKind.TypeParameter */
    ), n.showSnippets || t.add(
      27
      /* CompletionItemKind.Snippet */
    ), n.showUsers || t.add(
      25
      /* CompletionItemKind.User */
    ), n.showIssues || t.add(
      26
      /* CompletionItemKind.Issue */
    ), { itemKind: t, showDeprecated: n.showDeprecated };
  }
  _onNewContext(e) {
    if (this._context) {
      if (e.lineNumber !== this._context.lineNumber) {
        this.cancel();
        return;
      }
      if (Tt(e.leadingLineContent) !== Tt(this._context.leadingLineContent)) {
        this.cancel();
        return;
      }
      if (e.column < this._context.column) {
        e.leadingWord.word ? this.trigger({ auto: this._context.triggerOptions.auto, retrigger: !0 }) : this.cancel();
        return;
      }
      if (this._completionModel) {
        if (e.leadingWord.word.length !== 0 && e.leadingWord.startColumn > this._context.leadingWord.startColumn) {
          if (xh.shouldAutoTrigger(this._editor) && this._context) {
            const i = this._completionModel.getItemsByProvider();
            this.trigger({
              auto: this._context.triggerOptions.auto,
              retrigger: !0,
              clipboardText: this._completionModel.clipboardText,
              completionOptions: { providerItemsToReuse: i }
            });
          }
          return;
        }
        if (e.column > this._context.column && this._completionModel.getIncompleteProvider().size > 0 && e.leadingWord.word.length !== 0) {
          const t = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Set();
          for (const [n, s] of this._completionModel.getItemsByProvider())
            s.length > 0 && s[0].container.incomplete ? i.add(n) : t.set(n, s);
          this.trigger({
            auto: this._context.triggerOptions.auto,
            triggerKind: 2,
            retrigger: !0,
            clipboardText: this._completionModel.clipboardText,
            completionOptions: { providerFilter: i, providerItemsToReuse: t }
          });
        } else {
          const t = this._completionModel.lineContext;
          let i = !1;
          if (this._completionModel.lineContext = {
            leadingLineContent: e.leadingLineContent,
            characterCountDelta: e.column - this._context.column
          }, this._completionModel.items.length === 0) {
            const n = xh.shouldAutoTrigger(this._editor);
            if (!this._context) {
              this.cancel();
              return;
            }
            if (n && this._context.leadingWord.endColumn < e.leadingWord.startColumn) {
              this.trigger({ auto: this._context.triggerOptions.auto, retrigger: !0 });
              return;
            }
            if (this._context.triggerOptions.auto) {
              this.cancel();
              return;
            } else if (this._completionModel.lineContext = t, i = this._completionModel.items.length > 0, i && e.leadingWord.word.length === 0) {
              this.cancel();
              return;
            }
          }
          this._onDidSuggest.fire({
            completionModel: this._completionModel,
            triggerOptions: e.triggerOptions,
            isFrozen: i
          });
        }
      }
    }
  }
};
Ky = UT = gpe([
  Nd(1, Uo),
  Nd(2, Dd),
  Nd(3, kn),
  Nd(4, Pn),
  Nd(5, De),
  Nd(6, Ge),
  Nd(7, he),
  Nd(8, J1)
], Ky);
class $L {
  constructor(e, t) {
    this._disposables = new q(), this._lastOvertyped = [], this._locked = !1, this._disposables.add(e.onWillType(() => {
      if (this._locked || !e.hasModel())
        return;
      const i = e.getSelections(), n = i.length;
      let s = !1;
      for (let a = 0; a < n; a++)
        if (!i[a].isEmpty()) {
          s = !0;
          break;
        }
      if (!s) {
        this._lastOvertyped.length !== 0 && (this._lastOvertyped.length = 0);
        return;
      }
      this._lastOvertyped = [];
      const o = e.getModel();
      for (let a = 0; a < n; a++) {
        const l = i[a];
        if (o.getValueLengthInRange(l) > $L._maxSelectionLength)
          return;
        this._lastOvertyped[a] = { value: o.getValueInRange(l), multiline: l.startLineNumber !== l.endLineNumber };
      }
    })), this._disposables.add(t.onDidTrigger((i) => {
      this._locked = !0;
    })), this._disposables.add(t.onDidCancel((i) => {
      this._locked = !1;
    }));
  }
  getLastOvertypedInfo(e) {
    if (e >= 0 && e < this._lastOvertyped.length)
      return this._lastOvertyped[e];
  }
  dispose() {
    this._disposables.dispose();
  }
}
$L._maxSelectionLength = 51200;
var mpe = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, sx = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
let _pe = class e$ extends Hc {
  updateLabel() {
    const e = this._keybindingService.lookupKeybinding(this._action.id, this._contextKeyService);
    if (!e)
      return super.updateLabel();
    this.label && (this.label.textContent = p({ key: "content", comment: ["A label", "A keybinding"] }, "{0} ({1})", this._action.label, e$.symbolPrintEnter(e)));
  }
  static symbolPrintEnter(e) {
    var t;
    return (t = e.getLabel()) === null || t === void 0 ? void 0 : t.replace(/\benter\b/gi, "");
  }
}, $T = class {
  constructor(e, t, i, n, s) {
    this._menuId = t, this._menuService = n, this._contextKeyService = s, this._menuDisposables = new q(), this.element = G(e, X(".suggest-status-bar"));
    const o = (a) => a instanceof Hs ? i.createInstance(_pe, a, void 0) : void 0;
    this._leftActions = new Bo(this.element, { actionViewItemProvider: o }), this._rightActions = new Bo(this.element, { actionViewItemProvider: o }), this._leftActions.domNode.classList.add("left"), this._rightActions.domNode.classList.add("right");
  }
  dispose() {
    this._menuDisposables.dispose(), this._leftActions.dispose(), this._rightActions.dispose(), this.element.remove();
  }
  show() {
    const e = this._menuService.createMenu(this._menuId, this._contextKeyService), t = () => {
      const i = [], n = [];
      for (const [s, o] of e.getActions())
        s === "left" ? i.push(...o) : n.push(...o);
      this._leftActions.clear(), this._leftActions.push(i), this._rightActions.clear(), this._rightActions.push(n);
    };
    this._menuDisposables.add(e.onDidChange(() => t())), this._menuDisposables.add(e);
  }
  hide() {
    this._menuDisposables.clear();
  }
};
$T = mpe([
  sx(2, be),
  sx(3, vo),
  sx(4, De)
], $T);
var vpe = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, bpe = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
function NR(r) {
  return !!r && !!(r.completion.documentation || r.completion.detail && r.completion.detail !== r.completion.label);
}
let KT = class {
  constructor(e, t) {
    this._editor = e, this._onDidClose = new R(), this.onDidClose = this._onDidClose.event, this._onDidChangeContents = new R(), this.onDidChangeContents = this._onDidChangeContents.event, this._disposables = new q(), this._renderDisposeable = new q(), this._borderWidth = 1, this._size = new pt(330, 0), this.domNode = X(".suggest-details"), this.domNode.classList.add("no-docs"), this._markdownRenderer = t.createInstance(nl, { editor: e }), this._body = X(".body"), this._scrollbar = new pb(this._body, {
      alwaysConsumeMouseWheel: !0
    }), G(this.domNode, this._scrollbar.getDomNode()), this._disposables.add(this._scrollbar), this._header = G(this._body, X(".header")), this._close = G(this._header, X("span" + Le.asCSSSelector(me.close))), this._close.title = p("details.close", "Close"), this._type = G(this._header, X("p.type")), this._docs = G(this._body, X("p.docs")), this._configureFont(), this._disposables.add(this._editor.onDidChangeConfiguration((i) => {
      i.hasChanged(
        50
        /* EditorOption.fontInfo */
      ) && this._configureFont();
    }));
  }
  dispose() {
    this._disposables.dispose(), this._renderDisposeable.dispose();
  }
  _configureFont() {
    const e = this._editor.getOptions(), t = e.get(
      50
      /* EditorOption.fontInfo */
    ), i = t.getMassagedFontFamily(), n = e.get(
      119
      /* EditorOption.suggestFontSize */
    ) || t.fontSize, s = e.get(
      120
      /* EditorOption.suggestLineHeight */
    ) || t.lineHeight, o = t.fontWeight, a = `${n}px`, l = `${s}px`;
    this.domNode.style.fontSize = a, this.domNode.style.lineHeight = `${s / n}`, this.domNode.style.fontWeight = o, this.domNode.style.fontFeatureSettings = t.fontFeatureSettings, this._type.style.fontFamily = i, this._close.style.height = l, this._close.style.width = l;
  }
  getLayoutInfo() {
    const e = this._editor.getOption(
      120
      /* EditorOption.suggestLineHeight */
    ) || this._editor.getOption(
      50
      /* EditorOption.fontInfo */
    ).lineHeight, t = this._borderWidth, i = t * 2;
    return {
      lineHeight: e,
      borderWidth: t,
      borderHeight: i,
      verticalPadding: 22,
      horizontalPadding: 14
    };
  }
  renderLoading() {
    this._type.textContent = p("loading", "Loading..."), this._docs.textContent = "", this.domNode.classList.remove("no-docs", "no-type"), this.layout(this.size.width, this.getLayoutInfo().lineHeight * 2), this._onDidChangeContents.fire(this);
  }
  renderItem(e, t) {
    var i, n;
    this._renderDisposeable.clear();
    let { detail: s, documentation: o } = e.completion;
    if (t) {
      let a = "";
      a += `score: ${e.score[0]}
`, a += `prefix: ${(i = e.word) !== null && i !== void 0 ? i : "(no prefix)"}
`, a += `word: ${e.completion.filterText ? e.completion.filterText + " (filterText)" : e.textLabel}
`, a += `distance: ${e.distance} (localityBonus-setting)
`, a += `index: ${e.idx}, based on ${e.completion.sortText && `sortText: "${e.completion.sortText}"` || "label"}
`, a += `commit_chars: ${(n = e.completion.commitCharacters) === null || n === void 0 ? void 0 : n.join("")}
`, o = new Nn().appendCodeblock("empty", a), s = `Provider: ${e.provider._debugDisplayName}`;
    }
    if (!t && !NR(e)) {
      this.clearContents();
      return;
    }
    if (this.domNode.classList.remove("no-docs", "no-type"), s) {
      const a = s.length > 1e5 ? `${s.substr(0, 1e5)}` : s;
      this._type.textContent = a, this._type.title = a, As(this._type), this._type.classList.toggle("auto-wrap", !/\r?\n^\s+/gmi.test(a));
    } else
      pn(this._type), this._type.title = "", Xn(this._type), this.domNode.classList.add("no-type");
    if (pn(this._docs), typeof o == "string")
      this._docs.classList.remove("markdown-docs"), this._docs.textContent = o;
    else if (o) {
      this._docs.classList.add("markdown-docs"), pn(this._docs);
      const a = this._markdownRenderer.render(o);
      this._docs.appendChild(a.element), this._renderDisposeable.add(a), this._renderDisposeable.add(this._markdownRenderer.onDidRenderAsync(() => {
        this.layout(this._size.width, this._type.clientHeight + this._docs.clientHeight), this._onDidChangeContents.fire(this);
      }));
    }
    this.domNode.style.userSelect = "text", this.domNode.tabIndex = -1, this._close.onmousedown = (a) => {
      a.preventDefault(), a.stopPropagation();
    }, this._close.onclick = (a) => {
      a.preventDefault(), a.stopPropagation(), this._onDidClose.fire();
    }, this._body.scrollTop = 0, this.layout(this._size.width, this._type.clientHeight + this._docs.clientHeight), this._onDidChangeContents.fire(this);
  }
  clearContents() {
    this.domNode.classList.add("no-docs"), this._type.textContent = "", this._docs.textContent = "";
  }
  get isEmpty() {
    return this.domNode.classList.contains("no-docs");
  }
  get size() {
    return this._size;
  }
  layout(e, t) {
    const i = new pt(e, t);
    pt.equals(i, this._size) || (this._size = i, z8(this.domNode, e, t)), this._scrollbar.scanDomNode();
  }
  scrollDown(e = 8) {
    this._body.scrollTop += e;
  }
  scrollUp(e = 8) {
    this._body.scrollTop -= e;
  }
  scrollTop() {
    this._body.scrollTop = 0;
  }
  scrollBottom() {
    this._body.scrollTop = this._body.scrollHeight;
  }
  pageDown() {
    this.scrollDown(80);
  }
  pageUp() {
    this.scrollUp(80);
  }
  set borderWidth(e) {
    this._borderWidth = e;
  }
  get borderWidth() {
    return this._borderWidth;
  }
};
KT = vpe([
  bpe(1, be)
], KT);
class Cpe {
  constructor(e, t) {
    this.widget = e, this._editor = t, this.allowEditorOverflow = !0, this._disposables = new q(), this._added = !1, this._preferAlignAtTop = !0, this._resizable = new fR(), this._resizable.domNode.classList.add("suggest-details-container"), this._resizable.domNode.appendChild(e.domNode), this._resizable.enableSashes(!1, !0, !0, !1);
    let i, n, s = 0, o = 0;
    this._disposables.add(this._resizable.onDidWillResize(() => {
      i = this._topLeft, n = this._resizable.size;
    })), this._disposables.add(this._resizable.onDidResize((a) => {
      if (i && n) {
        this.widget.layout(a.dimension.width, a.dimension.height);
        let l = !1;
        a.west && (o = n.width - a.dimension.width, l = !0), a.north && (s = n.height - a.dimension.height, l = !0), l && this._applyTopLeft({
          top: i.top + s,
          left: i.left + o
        });
      }
      a.done && (i = void 0, n = void 0, s = 0, o = 0, this._userSize = a.dimension);
    })), this._disposables.add(this.widget.onDidChangeContents(() => {
      var a;
      this._anchorBox && this._placeAtAnchor(this._anchorBox, (a = this._userSize) !== null && a !== void 0 ? a : this.widget.size, this._preferAlignAtTop);
    }));
  }
  dispose() {
    this._resizable.dispose(), this._disposables.dispose(), this.hide();
  }
  getId() {
    return "suggest.details";
  }
  getDomNode() {
    return this._resizable.domNode;
  }
  getPosition() {
    return this._topLeft ? { preference: this._topLeft } : null;
  }
  show() {
    this._added || (this._editor.addOverlayWidget(this), this._added = !0);
  }
  hide(e = !1) {
    this._resizable.clearSashHoverState(), this._added && (this._editor.removeOverlayWidget(this), this._added = !1, this._anchorBox = void 0, this._topLeft = void 0), e && (this._userSize = void 0, this.widget.clearContents());
  }
  placeAtAnchor(e, t) {
    var i;
    const n = e.getBoundingClientRect();
    this._anchorBox = n, this._preferAlignAtTop = t, this._placeAtAnchor(this._anchorBox, (i = this._userSize) !== null && i !== void 0 ? i : this.widget.size, t);
  }
  _placeAtAnchor(e, t, i) {
    var n;
    const s = Rc(this.getDomNode().ownerDocument.body), o = this.widget.getLayoutInfo(), a = new pt(220, 2 * o.lineHeight), l = e.top, d = function() {
      const y = s.width - (e.left + e.width + o.borderWidth + o.horizontalPadding), k = -o.borderWidth + e.left + e.width, E = new pt(y, s.height - e.top - o.borderHeight - o.verticalPadding), N = E.with(void 0, e.top + e.height - o.borderHeight - o.verticalPadding);
      return { top: l, left: k, fit: y - t.width, maxSizeTop: E, maxSizeBottom: N, minSize: a.with(Math.min(y, a.width)) };
    }(), c = function() {
      const y = e.left - o.borderWidth - o.horizontalPadding, k = Math.max(o.horizontalPadding, e.left - t.width - o.borderWidth), E = new pt(y, s.height - e.top - o.borderHeight - o.verticalPadding), N = E.with(void 0, e.top + e.height - o.borderHeight - o.verticalPadding);
      return { top: l, left: k, fit: y - t.width, maxSizeTop: E, maxSizeBottom: N, minSize: a.with(Math.min(y, a.width)) };
    }(), h = function() {
      const y = e.left, k = -o.borderWidth + e.top + e.height, E = new pt(e.width - o.borderHeight, s.height - e.top - e.height - o.verticalPadding);
      return { top: k, left: y, fit: E.height - t.height, maxSizeBottom: E, maxSizeTop: E, minSize: a.with(E.width) };
    }(), u = [d, c, h], g = (n = u.find((y) => y.fit >= 0)) !== null && n !== void 0 ? n : u.sort((y, k) => k.fit - y.fit)[0], f = e.top + e.height - o.borderHeight;
    let m, _ = t.height;
    const v = Math.max(g.maxSizeTop.height, g.maxSizeBottom.height);
    _ > v && (_ = v);
    let b;
    i ? _ <= g.maxSizeTop.height ? (m = !0, b = g.maxSizeTop) : (m = !1, b = g.maxSizeBottom) : _ <= g.maxSizeBottom.height ? (m = !1, b = g.maxSizeBottom) : (m = !0, b = g.maxSizeTop);
    let { top: C, left: w } = g;
    !m && _ > e.height && (C = f - _);
    const S = this._editor.getDomNode();
    if (S) {
      const y = S.getBoundingClientRect();
      C -= y.top, w -= y.left;
    }
    this._applyTopLeft({ left: w, top: C }), this._resizable.enableSashes(!m, g === d, m, g !== d), this._resizable.minSize = g.minSize, this._resizable.maxSize = b, this._resizable.layout(_, Math.min(b.width, t.width)), this.widget.layout(this._resizable.size.width, this._resizable.size.height);
  }
  _applyTopLeft(e) {
    this._topLeft = e, this._editor.layoutOverlayWidget(this);
  }
}
var Ka;
(function(r) {
  r[r.FILE = 0] = "FILE", r[r.FOLDER = 1] = "FOLDER", r[r.ROOT_FOLDER = 2] = "ROOT_FOLDER";
})(Ka || (Ka = {}));
const wpe = /(?:\/|^)(?:([^\/]+)\/)?([^\/]+)$/;
function cw(r, e, t, i, n) {
  if (Le.isThemeIcon(n))
    return [`codicon-${n.id}`, "predefined-file-icon"];
  if (Ee.isUri(n))
    return [];
  const s = i === Ka.ROOT_FOLDER ? ["rootfolder-icon"] : i === Ka.FOLDER ? ["folder-icon"] : ["file-icon"];
  if (t) {
    let o;
    if (t.scheme === Ne.data)
      o = Fc.parseMetaData(t).get(Fc.META_DATA_LABEL);
    else {
      const a = t.path.match(wpe);
      a ? (o = hw(a[2].toLowerCase()), a[1] && s.push(`${hw(a[1].toLowerCase())}-name-dir-icon`)) : o = hw(t.authority.toLowerCase());
    }
    if (i === Ka.ROOT_FOLDER)
      s.push(`${o}-root-name-folder-icon`);
    else if (i === Ka.FOLDER)
      s.push(`${o}-name-folder-icon`);
    else {
      if (o) {
        if (s.push(`${o}-name-file-icon`), s.push("name-file-icon"), o.length <= 255) {
          const l = o.split(".");
          for (let d = 1; d < l.length; d++)
            s.push(`${l.slice(d).join(".")}-ext-file-icon`);
        }
        s.push("ext-file-icon");
      }
      const a = Spe(r, e, t);
      a && s.push(`${hw(a)}-lang-file-icon`);
    }
  }
  return s;
}
function Spe(r, e, t) {
  if (!t)
    return null;
  let i = null;
  if (t.scheme === Ne.data) {
    const s = Fc.parseMetaData(t).get(Fc.META_DATA_MIME);
    s && (i = e.getLanguageIdByMimeType(s));
  } else {
    const n = r.getModel(t);
    n && (i = n.getLanguageId());
  }
  return i && i !== go ? i : e.guessLanguageIdByFilepathOrFirstLine(t);
}
function hw(r) {
  return r.replace(/[\11\12\14\15\40]/g, "/");
}
var ype = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, ox = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, Md;
function t$(r) {
  return `suggest-aria-id:${r}`;
}
const Lpe = hi("suggest-more-info", me.chevronRight, p("suggestMoreInfoIcon", "Icon for more information in the suggest widget.")), Dpe = new (Md = class {
  extract(e, t) {
    if (e.textLabel.match(Md._regexStrict))
      return t[0] = e.textLabel, !0;
    if (e.completion.detail && e.completion.detail.match(Md._regexStrict))
      return t[0] = e.completion.detail, !0;
    if (e.completion.documentation) {
      const i = typeof e.completion.documentation == "string" ? e.completion.documentation : e.completion.documentation.value, n = Md._regexRelaxed.exec(i);
      if (n && (n.index === 0 || n.index + n[0].length === i.length))
        return t[0] = n[0], !0;
    }
    return !1;
  }
}, Md._regexRelaxed = /(#([\da-fA-F]{3}){1,2}|(rgb|hsl)a\(\s*(\d{1,3}%?\s*,\s*){3}(1|0?\.\d+)\)|(rgb|hsl)\(\s*\d{1,3}%?(\s*,\s*\d{1,3}%?){2}\s*\))/, Md._regexStrict = new RegExp(`^${Md._regexRelaxed.source}$`, "i"), Md)();
let jT = class {
  constructor(e, t, i, n) {
    this._editor = e, this._modelService = t, this._languageService = i, this._themeService = n, this._onDidToggleDetails = new R(), this.onDidToggleDetails = this._onDidToggleDetails.event, this.templateId = "suggestion";
  }
  dispose() {
    this._onDidToggleDetails.dispose();
  }
  renderTemplate(e) {
    const t = new q(), i = e;
    i.classList.add("show-file-icons");
    const n = G(e, X(".icon")), s = G(n, X("span.colorspan")), o = G(e, X(".contents")), a = G(o, X(".main")), l = G(a, X(".icon-label.codicon")), d = G(a, X("span.left")), c = G(a, X("span.right")), h = new hy(d, { supportHighlights: !0, supportIcons: !0 });
    t.add(h);
    const u = G(d, X("span.signature-label")), g = G(d, X("span.qualifier-label")), f = G(c, X("span.details-label")), m = G(c, X("span.readMore" + Le.asCSSSelector(Lpe)));
    return m.title = p("readMore", "Read More"), { root: i, left: d, right: c, icon: n, colorspan: s, iconLabel: h, iconContainer: l, parametersLabel: u, qualifierLabel: g, detailsLabel: f, readMore: m, disposables: t, configureFont: () => {
      const v = this._editor.getOptions(), b = v.get(
        50
        /* EditorOption.fontInfo */
      ), C = b.getMassagedFontFamily(), w = b.fontFeatureSettings, S = v.get(
        119
        /* EditorOption.suggestFontSize */
      ) || b.fontSize, y = v.get(
        120
        /* EditorOption.suggestLineHeight */
      ) || b.lineHeight, k = b.fontWeight, E = b.letterSpacing, N = `${S}px`, F = `${y}px`, V = `${E}px`;
      i.style.fontSize = N, i.style.fontWeight = k, i.style.letterSpacing = V, a.style.fontFamily = C, a.style.fontFeatureSettings = w, a.style.lineHeight = F, n.style.height = F, n.style.width = F, m.style.height = F, m.style.width = F;
    } };
  }
  renderElement(e, t, i) {
    i.configureFont();
    const { completion: n } = e;
    i.root.id = t$(t), i.colorspan.style.backgroundColor = "";
    const s = {
      labelEscapeNewLines: !0,
      matches: Sb(e.score)
    }, o = [];
    if (n.kind === 19 && Dpe.extract(e, o))
      i.icon.className = "icon customcolor", i.iconContainer.className = "icon hide", i.colorspan.style.backgroundColor = o[0];
    else if (n.kind === 20 && this._themeService.getFileIconTheme().hasFileIcons) {
      i.icon.className = "icon hide", i.iconContainer.className = "icon hide";
      const a = cw(this._modelService, this._languageService, Ee.from({ scheme: "fake", path: e.textLabel }), Ka.FILE), l = cw(this._modelService, this._languageService, Ee.from({ scheme: "fake", path: n.detail }), Ka.FILE);
      s.extraClasses = a.length > l.length ? a : l;
    } else n.kind === 23 && this._themeService.getFileIconTheme().hasFolderIcons ? (i.icon.className = "icon hide", i.iconContainer.className = "icon hide", s.extraClasses = [
      cw(this._modelService, this._languageService, Ee.from({ scheme: "fake", path: e.textLabel }), Ka.FOLDER),
      cw(this._modelService, this._languageService, Ee.from({ scheme: "fake", path: n.detail }), Ka.FOLDER)
    ].flat()) : (i.icon.className = "icon hide", i.iconContainer.className = "", i.iconContainer.classList.add("suggest-icon", ...Le.asClassNameArray(XN.toIcon(n.kind))));
    n.tags && n.tags.indexOf(
      1
      /* CompletionItemTag.Deprecated */
    ) >= 0 && (s.extraClasses = (s.extraClasses || []).concat(["deprecated"]), s.matches = []), i.iconLabel.setLabel(e.textLabel, void 0, s), typeof n.label == "string" ? (i.parametersLabel.textContent = "", i.detailsLabel.textContent = rx(n.detail || ""), i.root.classList.add("string-label")) : (i.parametersLabel.textContent = rx(n.label.detail || ""), i.detailsLabel.textContent = rx(n.label.description || ""), i.root.classList.remove("string-label")), this._editor.getOption(
      118
      /* EditorOption.suggest */
    ).showInlineDetails ? As(i.detailsLabel) : Xn(i.detailsLabel), NR(e) ? (i.right.classList.add("can-expand-details"), As(i.readMore), i.readMore.onmousedown = (a) => {
      a.stopPropagation(), a.preventDefault();
    }, i.readMore.onclick = (a) => {
      a.stopPropagation(), a.preventDefault(), this._onDidToggleDetails.fire();
    }) : (i.right.classList.remove("can-expand-details"), Xn(i.readMore), i.readMore.onmousedown = null, i.readMore.onclick = null);
  }
  disposeTemplate(e) {
    e.disposables.dispose();
  }
};
jT = ype([
  ox(1, ii),
  ox(2, Jt),
  ox(3, $i)
], jT);
function rx(r) {
  return r.replace(/\r\n|\r|\n/g, "");
}
var kpe = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, uw = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, Fg;
I("editorSuggestWidget.background", { dark: Di, light: Di, hcDark: Di, hcLight: Di }, p("editorSuggestWidgetBackground", "Background color of the suggest widget."));
I("editorSuggestWidget.border", { dark: zl, light: zl, hcDark: zl, hcLight: zl }, p("editorSuggestWidgetBorder", "Border color of the suggest widget."));
const gw = I("editorSuggestWidget.foreground", { dark: No, light: No, hcDark: No, hcLight: No }, p("editorSuggestWidgetForeground", "Foreground color of the suggest widget."));
I("editorSuggestWidget.selectedForeground", { dark: ic, light: ic, hcDark: ic, hcLight: ic }, p("editorSuggestWidgetSelectedForeground", "Foreground color of the selected entry in the suggest widget."));
I("editorSuggestWidget.selectedIconForeground", { dark: Zg, light: Zg, hcDark: Zg, hcLight: Zg }, p("editorSuggestWidgetSelectedIconForeground", "Icon foreground color of the selected entry in the suggest widget."));
const xpe = I("editorSuggestWidget.selectedBackground", { dark: nc, light: nc, hcDark: nc, hcLight: nc }, p("editorSuggestWidgetSelectedBackground", "Background color of the selected entry in the suggest widget."));
I("editorSuggestWidget.highlightForeground", { dark: lr, light: lr, hcDark: lr, hcLight: lr }, p("editorSuggestWidgetHighlightForeground", "Color of the match highlights in the suggest widget."));
I("editorSuggestWidget.focusHighlightForeground", { dark: cC, light: cC, hcDark: cC, hcLight: cC }, p("editorSuggestWidgetFocusHighlightForeground", "Color of the match highlights in the suggest widget when an item is focused."));
I("editorSuggestWidgetStatus.foreground", { dark: ve(gw, 0.5), light: ve(gw, 0.5), hcDark: ve(gw, 0.5), hcLight: ve(gw, 0.5) }, p("editorSuggestWidgetStatusForeground", "Foreground color of the suggest widget status."));
class Ipe {
  constructor(e, t) {
    this._service = e, this._key = `suggestWidget.size/${t.getEditorType()}/${t instanceof jc}`;
  }
  restore() {
    var e;
    const t = (e = this._service.get(
      this._key,
      0
      /* StorageScope.PROFILE */
    )) !== null && e !== void 0 ? e : "";
    try {
      const i = JSON.parse(t);
      if (pt.is(i))
        return pt.lift(i);
    } catch {
    }
  }
  store(e) {
    this._service.store(
      this._key,
      JSON.stringify(e),
      0,
      1
      /* StorageTarget.MACHINE */
    );
  }
  reset() {
    this._service.remove(
      this._key,
      0
      /* StorageScope.PROFILE */
    );
  }
}
let Uv = Fg = class {
  constructor(e, t, i, n, s) {
    this.editor = e, this._storageService = t, this._state = 0, this._isAuto = !1, this._pendingLayout = new Yi(), this._pendingShowDetails = new Yi(), this._ignoreFocusEvents = !1, this._forceRenderingAbove = !1, this._explainMode = !1, this._showTimeout = new vr(), this._disposables = new q(), this._onDidSelect = new Wf(), this._onDidFocus = new Wf(), this._onDidHide = new R(), this._onDidShow = new R(), this.onDidSelect = this._onDidSelect.event, this.onDidFocus = this._onDidFocus.event, this.onDidHide = this._onDidHide.event, this.onDidShow = this._onDidShow.event, this._onDetailsKeydown = new R(), this.onDetailsKeyDown = this._onDetailsKeydown.event, this.element = new fR(), this.element.domNode.classList.add("editor-widget", "suggest-widget"), this._contentWidget = new Epe(this, e), this._persistedSize = new Ipe(t, e);
    class o {
      constructor(g, f, m = !1, _ = !1) {
        this.persistedSize = g, this.currentSize = f, this.persistHeight = m, this.persistWidth = _;
      }
    }
    let a;
    this._disposables.add(this.element.onDidWillResize(() => {
      this._contentWidget.lockPreference(), a = new o(this._persistedSize.restore(), this.element.size);
    })), this._disposables.add(this.element.onDidResize((u) => {
      var g, f, m, _;
      if (this._resize(u.dimension.width, u.dimension.height), a && (a.persistHeight = a.persistHeight || !!u.north || !!u.south, a.persistWidth = a.persistWidth || !!u.east || !!u.west), !!u.done) {
        if (a) {
          const { itemHeight: v, defaultSize: b } = this.getLayoutInfo(), C = Math.round(v / 2);
          let { width: w, height: S } = this.element.size;
          (!a.persistHeight || Math.abs(a.currentSize.height - S) <= C) && (S = (f = (g = a.persistedSize) === null || g === void 0 ? void 0 : g.height) !== null && f !== void 0 ? f : b.height), (!a.persistWidth || Math.abs(a.currentSize.width - w) <= C) && (w = (_ = (m = a.persistedSize) === null || m === void 0 ? void 0 : m.width) !== null && _ !== void 0 ? _ : b.width), this._persistedSize.store(new pt(w, S));
        }
        this._contentWidget.unlockPreference(), a = void 0;
      }
    })), this._messageElement = G(this.element.domNode, X(".message")), this._listElement = G(this.element.domNode, X(".tree"));
    const l = this._disposables.add(s.createInstance(KT, this.editor));
    l.onDidClose(this.toggleDetails, this, this._disposables), this._details = new Cpe(l, this.editor);
    const d = () => this.element.domNode.classList.toggle("no-icons", !this.editor.getOption(
      118
      /* EditorOption.suggest */
    ).showIcons);
    d();
    const c = s.createInstance(jT, this.editor);
    this._disposables.add(c), this._disposables.add(c.onDidToggleDetails(() => this.toggleDetails())), this._list = new Co("SuggestWidget", this._listElement, {
      getHeight: (u) => this.getLayoutInfo().itemHeight,
      getTemplateId: (u) => "suggestion"
    }, [c], {
      alwaysConsumeMouseWheel: !0,
      useShadows: !1,
      mouseSupport: !1,
      multipleSelectionSupport: !1,
      accessibilityProvider: {
        getRole: () => "option",
        getWidgetAriaLabel: () => p("suggest", "Suggest"),
        getWidgetRole: () => "listbox",
        getAriaLabel: (u) => {
          let g = u.textLabel;
          if (typeof u.completion.label != "string") {
            const { detail: v, description: b } = u.completion.label;
            v && b ? g = p("label.full", "{0} {1}, {2}", g, v, b) : v ? g = p("label.detail", "{0} {1}", g, v) : b && (g = p("label.desc", "{0}, {1}", g, b));
          }
          if (!u.isResolved || !this._isDetailsVisible())
            return g;
          const { documentation: f, detail: m } = u.completion, _ = vu("{0}{1}", m || "", f ? typeof f == "string" ? f : f.value : "");
          return p("ariaCurrenttSuggestionReadDetails", "{0}, docs: {1}", g, _);
        }
      }
    }), this._list.style(sg({
      listInactiveFocusBackground: xpe,
      listInactiveFocusOutline: Gt
    })), this._status = s.createInstance($T, this.element.domNode, Sc);
    const h = () => this.element.domNode.classList.toggle("with-status-bar", this.editor.getOption(
      118
      /* EditorOption.suggest */
    ).showStatusBar);
    h(), this._disposables.add(n.onDidColorThemeChange((u) => this._onThemeChange(u))), this._onThemeChange(n.getColorTheme()), this._disposables.add(this._list.onMouseDown((u) => this._onListMouseDownOrTap(u))), this._disposables.add(this._list.onTap((u) => this._onListMouseDownOrTap(u))), this._disposables.add(this._list.onDidChangeSelection((u) => this._onListSelection(u))), this._disposables.add(this._list.onDidChangeFocus((u) => this._onListFocus(u))), this._disposables.add(this.editor.onDidChangeCursorSelection(() => this._onCursorSelectionChanged())), this._disposables.add(this.editor.onDidChangeConfiguration((u) => {
      u.hasChanged(
        118
        /* EditorOption.suggest */
      ) && (h(), d()), this._completionModel && (u.hasChanged(
        50
        /* EditorOption.fontInfo */
      ) || u.hasChanged(
        119
        /* EditorOption.suggestFontSize */
      ) || u.hasChanged(
        120
        /* EditorOption.suggestLineHeight */
      )) && this._list.splice(0, this._list.length, this._completionModel.items);
    })), this._ctxSuggestWidgetVisible = je.Visible.bindTo(i), this._ctxSuggestWidgetDetailsVisible = je.DetailsVisible.bindTo(i), this._ctxSuggestWidgetMultipleSuggestions = je.MultipleSuggestions.bindTo(i), this._ctxSuggestWidgetHasFocusedSuggestion = je.HasFocusedSuggestion.bindTo(i), this._disposables.add(pi(this._details.widget.domNode, "keydown", (u) => {
      this._onDetailsKeydown.fire(u);
    })), this._disposables.add(this.editor.onMouseDown((u) => this._onEditorMouseDown(u)));
  }
  dispose() {
    var e;
    this._details.widget.dispose(), this._details.dispose(), this._list.dispose(), this._status.dispose(), this._disposables.dispose(), (e = this._loadingTimeout) === null || e === void 0 || e.dispose(), this._pendingLayout.dispose(), this._pendingShowDetails.dispose(), this._showTimeout.dispose(), this._contentWidget.dispose(), this.element.dispose();
  }
  _onEditorMouseDown(e) {
    this._details.widget.domNode.contains(e.target.element) ? this._details.widget.domNode.focus() : this.element.domNode.contains(e.target.element) && this.editor.focus();
  }
  _onCursorSelectionChanged() {
    this._state !== 0 && this._contentWidget.layout();
  }
  _onListMouseDownOrTap(e) {
    typeof e.element > "u" || typeof e.index > "u" || (e.browserEvent.preventDefault(), e.browserEvent.stopPropagation(), this._select(e.element, e.index));
  }
  _onListSelection(e) {
    e.elements.length && this._select(e.elements[0], e.indexes[0]);
  }
  _select(e, t) {
    const i = this._completionModel;
    i && (this._onDidSelect.fire({ item: e, index: t, model: i }), this.editor.focus());
  }
  _onThemeChange(e) {
    this._details.widget.borderWidth = jr(e.type) ? 2 : 1;
  }
  _onListFocus(e) {
    var t;
    if (this._ignoreFocusEvents)
      return;
    if (!e.elements.length) {
      this._currentSuggestionDetails && (this._currentSuggestionDetails.cancel(), this._currentSuggestionDetails = void 0, this._focusedItem = void 0), this.editor.setAriaOptions({ activeDescendant: void 0 }), this._ctxSuggestWidgetHasFocusedSuggestion.set(!1);
      return;
    }
    if (!this._completionModel)
      return;
    this._ctxSuggestWidgetHasFocusedSuggestion.set(!0);
    const i = e.elements[0], n = e.indexes[0];
    i !== this._focusedItem && ((t = this._currentSuggestionDetails) === null || t === void 0 || t.cancel(), this._currentSuggestionDetails = void 0, this._focusedItem = i, this._list.reveal(n), this._currentSuggestionDetails = Zi(async (s) => {
      const o = Mc(() => {
        this._isDetailsVisible() && this.showDetails(!0);
      }, 250), a = s.onCancellationRequested(() => o.dispose());
      try {
        return await i.resolve(s);
      } finally {
        o.dispose(), a.dispose();
      }
    }), this._currentSuggestionDetails.then(() => {
      n >= this._list.length || i !== this._list.element(n) || (this._ignoreFocusEvents = !0, this._list.splice(n, 1, [i]), this._list.setFocus([n]), this._ignoreFocusEvents = !1, this._isDetailsVisible() ? this.showDetails(!1) : this.element.domNode.classList.remove("docs-side"), this.editor.setAriaOptions({ activeDescendant: t$(n) }));
    }).catch(He)), this._onDidFocus.fire({ item: i, index: n, model: this._completionModel });
  }
  _setState(e) {
    if (this._state !== e)
      switch (this._state = e, this.element.domNode.classList.toggle(
        "frozen",
        e === 4
        /* State.Frozen */
      ), this.element.domNode.classList.remove("message"), e) {
        case 0:
          Xn(this._messageElement, this._listElement, this._status.element), this._details.hide(!0), this._status.hide(), this._contentWidget.hide(), this._ctxSuggestWidgetVisible.reset(), this._ctxSuggestWidgetMultipleSuggestions.reset(), this._ctxSuggestWidgetHasFocusedSuggestion.reset(), this._showTimeout.cancel(), this.element.domNode.classList.remove("visible"), this._list.splice(0, this._list.length), this._focusedItem = void 0, this._cappedHeight = void 0, this._explainMode = !1;
          break;
        case 1:
          this.element.domNode.classList.add("message"), this._messageElement.textContent = Fg.LOADING_MESSAGE, Xn(this._listElement, this._status.element), As(this._messageElement), this._details.hide(), this._show(), this._focusedItem = void 0, el(Fg.LOADING_MESSAGE);
          break;
        case 2:
          this.element.domNode.classList.add("message"), this._messageElement.textContent = Fg.NO_SUGGESTIONS_MESSAGE, Xn(this._listElement, this._status.element), As(this._messageElement), this._details.hide(), this._show(), this._focusedItem = void 0, el(Fg.NO_SUGGESTIONS_MESSAGE);
          break;
        case 3:
          Xn(this._messageElement), As(this._listElement, this._status.element), this._show();
          break;
        case 4:
          Xn(this._messageElement), As(this._listElement, this._status.element), this._show();
          break;
        case 5:
          Xn(this._messageElement), As(this._listElement, this._status.element), this._details.show(), this._show();
          break;
      }
  }
  _show() {
    this._status.show(), this._contentWidget.show(), this._layout(this._persistedSize.restore()), this._ctxSuggestWidgetVisible.set(!0), this._showTimeout.cancelAndSet(() => {
      this.element.domNode.classList.add("visible"), this._onDidShow.fire(this);
    }, 100);
  }
  showTriggered(e, t) {
    this._state === 0 && (this._contentWidget.setPosition(this.editor.getPosition()), this._isAuto = !!e, this._isAuto || (this._loadingTimeout = Mc(() => this._setState(
      1
      /* State.Loading */
    ), t)));
  }
  showSuggestions(e, t, i, n, s) {
    var o, a;
    if (this._contentWidget.setPosition(this.editor.getPosition()), (o = this._loadingTimeout) === null || o === void 0 || o.dispose(), (a = this._currentSuggestionDetails) === null || a === void 0 || a.cancel(), this._currentSuggestionDetails = void 0, this._completionModel !== e && (this._completionModel = e), i && this._state !== 2 && this._state !== 0) {
      this._setState(
        4
        /* State.Frozen */
      );
      return;
    }
    const l = this._completionModel.items.length, d = l === 0;
    if (this._ctxSuggestWidgetMultipleSuggestions.set(l > 1), d) {
      this._setState(
        n ? 0 : 2
        /* State.Empty */
      ), this._completionModel = void 0;
      return;
    }
    this._focusedItem = void 0, this._onDidFocus.pause(), this._onDidSelect.pause();
    try {
      this._list.splice(0, this._list.length, this._completionModel.items), this._setState(
        i ? 4 : 3
        /* State.Open */
      ), this._list.reveal(t, 0), this._list.setFocus(s ? [] : [t]);
    } finally {
      this._onDidFocus.resume(), this._onDidSelect.resume();
    }
    this._pendingLayout.value = hS(we(this.element.domNode), () => {
      this._pendingLayout.clear(), this._layout(this.element.size), this._details.widget.domNode.classList.remove("focused");
    });
  }
  focusSelected() {
    this._list.length > 0 && this._list.setFocus([0]);
  }
  selectNextPage() {
    switch (this._state) {
      case 0:
        return !1;
      case 5:
        return this._details.widget.pageDown(), !0;
      case 1:
        return !this._isAuto;
      default:
        return this._list.focusNextPage(), !0;
    }
  }
  selectNext() {
    switch (this._state) {
      case 0:
        return !1;
      case 1:
        return !this._isAuto;
      default:
        return this._list.focusNext(1, !0), !0;
    }
  }
  selectLast() {
    switch (this._state) {
      case 0:
        return !1;
      case 5:
        return this._details.widget.scrollBottom(), !0;
      case 1:
        return !this._isAuto;
      default:
        return this._list.focusLast(), !0;
    }
  }
  selectPreviousPage() {
    switch (this._state) {
      case 0:
        return !1;
      case 5:
        return this._details.widget.pageUp(), !0;
      case 1:
        return !this._isAuto;
      default:
        return this._list.focusPreviousPage(), !0;
    }
  }
  selectPrevious() {
    switch (this._state) {
      case 0:
        return !1;
      case 1:
        return !this._isAuto;
      default:
        return this._list.focusPrevious(1, !0), !1;
    }
  }
  selectFirst() {
    switch (this._state) {
      case 0:
        return !1;
      case 5:
        return this._details.widget.scrollTop(), !0;
      case 1:
        return !this._isAuto;
      default:
        return this._list.focusFirst(), !0;
    }
  }
  getFocusedItem() {
    if (this._state !== 0 && this._state !== 2 && this._state !== 1 && this._completionModel && this._list.getFocus().length > 0)
      return {
        item: this._list.getFocusedElements()[0],
        index: this._list.getFocus()[0],
        model: this._completionModel
      };
  }
  toggleDetailsFocus() {
    this._state === 5 ? (this._setState(
      3
      /* State.Open */
    ), this._details.widget.domNode.classList.remove("focused")) : this._state === 3 && this._isDetailsVisible() && (this._setState(
      5
      /* State.Details */
    ), this._details.widget.domNode.classList.add("focused"));
  }
  toggleDetails() {
    this._isDetailsVisible() ? (this._pendingShowDetails.clear(), this._ctxSuggestWidgetDetailsVisible.set(!1), this._setDetailsVisible(!1), this._details.hide(), this.element.domNode.classList.remove("shows-details")) : (NR(this._list.getFocusedElements()[0]) || this._explainMode) && (this._state === 3 || this._state === 5 || this._state === 4) && (this._ctxSuggestWidgetDetailsVisible.set(!0), this._setDetailsVisible(!0), this.showDetails(!1));
  }
  showDetails(e) {
    this._pendingShowDetails.value = hS(we(this.element.domNode), () => {
      this._pendingShowDetails.clear(), this._details.show(), e ? this._details.widget.renderLoading() : this._details.widget.renderItem(this._list.getFocusedElements()[0], this._explainMode), this._details.widget.isEmpty ? this._details.hide() : (this._positionDetails(), this.element.domNode.classList.add("shows-details")), this.editor.focus();
    });
  }
  toggleExplainMode() {
    this._list.getFocusedElements()[0] && (this._explainMode = !this._explainMode, this._isDetailsVisible() ? this.showDetails(!1) : this.toggleDetails());
  }
  resetPersistedSize() {
    this._persistedSize.reset();
  }
  hideWidget() {
    var e;
    this._pendingLayout.clear(), this._pendingShowDetails.clear(), (e = this._loadingTimeout) === null || e === void 0 || e.dispose(), this._setState(
      0
      /* State.Hidden */
    ), this._onDidHide.fire(this), this.element.clearSashHoverState();
    const t = this._persistedSize.restore(), i = Math.ceil(this.getLayoutInfo().itemHeight * 4.3);
    t && t.height < i && this._persistedSize.store(t.with(void 0, i));
  }
  isFrozen() {
    return this._state === 4;
  }
  _afterRender(e) {
    if (e === null) {
      this._isDetailsVisible() && this._details.hide();
      return;
    }
    this._state === 2 || this._state === 1 || (this._isDetailsVisible() && !this._details.widget.isEmpty && this._details.show(), this._positionDetails());
  }
  _layout(e) {
    var t, i, n;
    if (!this.editor.hasModel() || !this.editor.getDomNode())
      return;
    const s = Rc(this.element.domNode.ownerDocument.body), o = this.getLayoutInfo();
    e || (e = o.defaultSize);
    let a = e.height, l = e.width;
    if (this._status.element.style.height = `${o.itemHeight}px`, this._state === 2 || this._state === 1)
      a = o.itemHeight + o.borderHeight, l = o.defaultSize.width / 2, this.element.enableSashes(!1, !1, !1, !1), this.element.minSize = this.element.maxSize = new pt(l, a), this._contentWidget.setPreference(
        2
        /* ContentWidgetPositionPreference.BELOW */
      );
    else {
      const d = s.width - o.borderHeight - 2 * o.horizontalPadding;
      l > d && (l = d);
      const c = this._completionModel ? this._completionModel.stats.pLabelLen * o.typicalHalfwidthCharacterWidth : l, h = o.statusBarHeight + this._list.contentHeight + o.borderHeight, u = o.itemHeight + o.statusBarHeight, g = Ei(this.editor.getDomNode()), f = this.editor.getScrolledVisiblePosition(this.editor.getPosition()), m = g.top + f.top + f.height, _ = Math.min(s.height - m - o.verticalPadding, h), v = g.top + f.top - o.verticalPadding, b = Math.min(v, h);
      let C = Math.min(Math.max(b, _) + o.borderHeight, h);
      a === ((t = this._cappedHeight) === null || t === void 0 ? void 0 : t.capped) && (a = this._cappedHeight.wanted), a < u && (a = u), a > C && (a = C), a > _ || this._forceRenderingAbove && v > 150 ? (this._contentWidget.setPreference(
        1
        /* ContentWidgetPositionPreference.ABOVE */
      ), this.element.enableSashes(!0, !0, !1, !1), C = b) : (this._contentWidget.setPreference(
        2
        /* ContentWidgetPositionPreference.BELOW */
      ), this.element.enableSashes(!1, !0, !0, !1), C = _), this.element.preferredSize = new pt(c, o.defaultSize.height), this.element.maxSize = new pt(d, C), this.element.minSize = new pt(220, u), this._cappedHeight = a === h ? { wanted: (n = (i = this._cappedHeight) === null || i === void 0 ? void 0 : i.wanted) !== null && n !== void 0 ? n : e.height, capped: a } : void 0;
    }
    this._resize(l, a);
  }
  _resize(e, t) {
    const { width: i, height: n } = this.element.maxSize;
    e = Math.min(i, e), t = Math.min(n, t);
    const { statusBarHeight: s } = this.getLayoutInfo();
    this._list.layout(t - s, e), this._listElement.style.height = `${t - s}px`, this.element.layout(t, e), this._contentWidget.layout(), this._positionDetails();
  }
  _positionDetails() {
    var e;
    this._isDetailsVisible() && this._details.placeAtAnchor(
      this.element.domNode,
      ((e = this._contentWidget.getPosition()) === null || e === void 0 ? void 0 : e.preference[0]) === 2
      /* ContentWidgetPositionPreference.BELOW */
    );
  }
  getLayoutInfo() {
    const e = this.editor.getOption(
      50
      /* EditorOption.fontInfo */
    ), t = Yn(this.editor.getOption(
      120
      /* EditorOption.suggestLineHeight */
    ) || e.lineHeight, 8, 1e3), i = !this.editor.getOption(
      118
      /* EditorOption.suggest */
    ).showStatusBar || this._state === 2 || this._state === 1 ? 0 : t, n = this._details.widget.borderWidth, s = 2 * n;
    return {
      itemHeight: t,
      statusBarHeight: i,
      borderWidth: n,
      borderHeight: s,
      typicalHalfwidthCharacterWidth: e.typicalHalfwidthCharacterWidth,
      verticalPadding: 22,
      horizontalPadding: 14,
      defaultSize: new pt(430, i + 12 * t + s)
    };
  }
  _isDetailsVisible() {
    return this._storageService.getBoolean("expandSuggestionDocs", 0, !1);
  }
  _setDetailsVisible(e) {
    this._storageService.store(
      "expandSuggestionDocs",
      e,
      0,
      0
      /* StorageTarget.USER */
    );
  }
  forceRenderingAbove() {
    this._forceRenderingAbove || (this._forceRenderingAbove = !0, this._layout(this._persistedSize.restore()));
  }
  stopForceRenderingAbove() {
    this._forceRenderingAbove = !1;
  }
};
Uv.LOADING_MESSAGE = p("suggestWidget.loading", "Loading...");
Uv.NO_SUGGESTIONS_MESSAGE = p("suggestWidget.noSuggestions", "No suggestions.");
Uv = Fg = kpe([
  uw(1, br),
  uw(2, De),
  uw(3, $i),
  uw(4, be)
], Uv);
class Epe {
  constructor(e, t) {
    this._widget = e, this._editor = t, this.allowEditorOverflow = !0, this.suppressMouseDown = !1, this._preferenceLocked = !1, this._added = !1, this._hidden = !1;
  }
  dispose() {
    this._added && (this._added = !1, this._editor.removeContentWidget(this));
  }
  getId() {
    return "editor.widget.suggestWidget";
  }
  getDomNode() {
    return this._widget.element.domNode;
  }
  show() {
    this._hidden = !1, this._added || (this._added = !0, this._editor.addContentWidget(this));
  }
  hide() {
    this._hidden || (this._hidden = !0, this.layout());
  }
  layout() {
    this._editor.layoutContentWidget(this);
  }
  getPosition() {
    return this._hidden || !this._position || !this._preference ? null : {
      position: this._position,
      preference: [this._preference]
    };
  }
  beforeRender() {
    const { height: e, width: t } = this._widget.element.size, { borderWidth: i, horizontalPadding: n } = this._widget.getLayoutInfo();
    return new pt(t + 2 * i + n, e + 2 * i);
  }
  afterRender(e) {
    this._widget._afterRender(e);
  }
  setPreference(e) {
    this._preferenceLocked || (this._preference = e);
  }
  lockPreference() {
    this._preferenceLocked = !0;
  }
  unlockPreference() {
    this._preferenceLocked = !1;
  }
  setPosition(e) {
    this._position = e;
  }
}
var Tpe = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, kg = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, qT;
class Npe {
  constructor(e, t) {
    if (this._model = e, this._position = t, this._decorationOptions = Fe.register({
      description: "suggest-line-suffix",
      stickiness: 1
      /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */
    }), e.getLineMaxColumn(t.lineNumber) !== t.column) {
      const n = e.getOffsetAt(t), s = e.getPositionAt(n + 1);
      e.changeDecorations((o) => {
        this._marker && o.removeDecoration(this._marker), this._marker = o.addDecoration(L.fromPositions(t, s), this._decorationOptions);
      });
    }
  }
  dispose() {
    this._marker && !this._model.isDisposed() && this._model.changeDecorations((e) => {
      e.removeDecoration(this._marker), this._marker = void 0;
    });
  }
  delta(e) {
    if (this._model.isDisposed() || this._position.lineNumber !== e.lineNumber)
      return 0;
    if (this._marker) {
      const t = this._model.getDecorationRange(this._marker);
      return this._model.getOffsetAt(t.getStartPosition()) - this._model.getOffsetAt(e);
    } else
      return this._model.getLineMaxColumn(e.lineNumber) - e.column;
  }
}
let dr = qT = class {
  static get(e) {
    return e.getContribution(qT.ID);
  }
  constructor(e, t, i, n, s, o, a) {
    this._memoryService = t, this._commandService = i, this._contextKeyService = n, this._instantiationService = s, this._logService = o, this._telemetryService = a, this._lineSuffix = new Yi(), this._toDispose = new q(), this._selectors = new Mpe((h) => h.priority), this._onWillInsertSuggestItem = new R(), this.onWillInsertSuggestItem = this._onWillInsertSuggestItem.event, this.editor = e, this.model = s.createInstance(Ky, this.editor), this._selectors.register({
      priority: 0,
      select: (h, u, g) => this._memoryService.select(h, u, g)
    });
    const l = je.InsertMode.bindTo(n);
    l.set(e.getOption(
      118
      /* EditorOption.suggest */
    ).insertMode), this._toDispose.add(this.model.onDidTrigger(() => l.set(e.getOption(
      118
      /* EditorOption.suggest */
    ).insertMode))), this.widget = this._toDispose.add(new xD(we(e.getDomNode()), () => {
      const h = this._instantiationService.createInstance(Uv, this.editor);
      this._toDispose.add(h), this._toDispose.add(h.onDidSelect((_) => this._insertSuggestion(
        _,
        0
        /* InsertFlags.None */
      ), this));
      const u = new upe(this.editor, h, this.model, (_) => this._insertSuggestion(
        _,
        2
        /* InsertFlags.NoAfterUndoStop */
      ));
      this._toDispose.add(u);
      const g = je.MakesTextEdit.bindTo(this._contextKeyService), f = je.HasInsertAndReplaceRange.bindTo(this._contextKeyService), m = je.CanResolve.bindTo(this._contextKeyService);
      return this._toDispose.add(Se(() => {
        g.reset(), f.reset(), m.reset();
      })), this._toDispose.add(h.onDidFocus(({ item: _ }) => {
        const v = this.editor.getPosition(), b = _.editStart.column, C = v.column;
        let w = !0;
        this.editor.getOption(
          1
          /* EditorOption.acceptSuggestionOnEnter */
        ) === "smart" && this.model.state === 2 && !_.completion.additionalTextEdits && !(_.completion.insertTextRules & 4) && C - b === _.completion.insertText.length && (w = this.editor.getModel().getValueInRange({
          startLineNumber: v.lineNumber,
          startColumn: b,
          endLineNumber: v.lineNumber,
          endColumn: C
        }) !== _.completion.insertText), g.set(w), f.set(!A.equals(_.editInsertEnd, _.editReplaceEnd)), m.set(!!_.provider.resolveCompletionItem || !!_.completion.documentation || _.completion.detail !== _.completion.label);
      })), this._toDispose.add(h.onDetailsKeyDown((_) => {
        if (_.toKeyCodeChord().equals(new dd(
          !0,
          !1,
          !1,
          !1,
          33
          /* KeyCode.KeyC */
        )) || Je && _.toKeyCodeChord().equals(new dd(
          !1,
          !1,
          !1,
          !0,
          33
          /* KeyCode.KeyC */
        ))) {
          _.stopPropagation();
          return;
        }
        _.toKeyCodeChord().isModifierKey() || this.editor.focus();
      })), h;
    })), this._overtypingCapturer = this._toDispose.add(new xD(we(e.getDomNode()), () => this._toDispose.add(new $L(this.editor, this.model)))), this._alternatives = this._toDispose.add(new xD(we(e.getDomNode()), () => this._toDispose.add(new Hu(this.editor, this._contextKeyService)))), this._toDispose.add(s.createInstance(zv, e)), this._toDispose.add(this.model.onDidTrigger((h) => {
      this.widget.value.showTriggered(h.auto, h.shy ? 250 : 50), this._lineSuffix.value = new Npe(this.editor.getModel(), h.position);
    })), this._toDispose.add(this.model.onDidSuggest((h) => {
      if (h.triggerOptions.shy)
        return;
      let u = -1;
      for (const f of this._selectors.itemsOrderedByPriorityDesc)
        if (u = f.select(this.editor.getModel(), this.editor.getPosition(), h.completionModel.items), u !== -1)
          break;
      if (u === -1 && (u = 0), this.model.state === 0)
        return;
      let g = !1;
      if (h.triggerOptions.auto) {
        const f = this.editor.getOption(
          118
          /* EditorOption.suggest */
        );
        f.selectionMode === "never" || f.selectionMode === "always" ? g = f.selectionMode === "never" : f.selectionMode === "whenTriggerCharacter" ? g = h.triggerOptions.triggerKind !== 1 : f.selectionMode === "whenQuickSuggestion" && (g = h.triggerOptions.triggerKind === 1 && !h.triggerOptions.refilter);
      }
      this.widget.value.showSuggestions(h.completionModel, u, h.isFrozen, h.triggerOptions.auto, g);
    })), this._toDispose.add(this.model.onDidCancel((h) => {
      h.retrigger || this.widget.value.hideWidget();
    })), this._toDispose.add(this.editor.onDidBlurEditorWidget(() => {
      this.model.cancel(), this.model.clear();
    }));
    const d = je.AcceptSuggestionsOnEnter.bindTo(n), c = () => {
      const h = this.editor.getOption(
        1
        /* EditorOption.acceptSuggestionOnEnter */
      );
      d.set(h === "on" || h === "smart");
    };
    this._toDispose.add(this.editor.onDidChangeConfiguration(() => c())), c();
  }
  dispose() {
    this._alternatives.dispose(), this._toDispose.dispose(), this.widget.dispose(), this.model.dispose(), this._lineSuffix.dispose(), this._onWillInsertSuggestItem.dispose();
  }
  _insertSuggestion(e, t) {
    if (!e || !e.item) {
      this._alternatives.value.reset(), this.model.cancel(), this.model.clear();
      return;
    }
    if (!this.editor.hasModel())
      return;
    const i = vn.get(this.editor);
    if (!i)
      return;
    this._onWillInsertSuggestItem.fire({ item: e.item });
    const n = this.editor.getModel(), s = n.getAlternativeVersionId(), { item: o } = e, a = [], l = new mi();
    t & 1 || this.editor.pushUndoStop();
    const d = this.getOverwriteInfo(o, !!(t & 8));
    this._memoryService.memorize(n, this.editor.getPosition(), o);
    const c = o.isResolved;
    let h = -1, u = -1;
    if (Array.isArray(o.completion.additionalTextEdits)) {
      this.model.cancel();
      const f = sa.capture(this.editor);
      this.editor.executeEdits("suggestController.additionalTextEdits.sync", o.completion.additionalTextEdits.map((m) => {
        let _ = L.lift(m.range);
        if (_.startLineNumber === o.position.lineNumber && _.startColumn > o.position.column) {
          const v = this.editor.getPosition().column - o.position.column, b = v, C = L.spansMultipleLines(_) ? 0 : v;
          _ = new L(_.startLineNumber, _.startColumn + b, _.endLineNumber, _.endColumn + C);
        }
        return ti.replaceMove(_, m.text);
      })), f.restoreRelativeVerticalPositionOfCursor(this.editor);
    } else if (!c) {
      const f = new rs();
      let m;
      const _ = n.onDidChangeContent((w) => {
        if (w.isFlush) {
          l.cancel(), _.dispose();
          return;
        }
        for (const S of w.changes) {
          const y = L.getEndPosition(S.range);
          (!m || A.isBefore(y, m)) && (m = y);
        }
      }), v = t;
      t |= 2;
      let b = !1;
      const C = this.editor.onWillType(() => {
        C.dispose(), b = !0, v & 2 || this.editor.pushUndoStop();
      });
      a.push(o.resolve(l.token).then(() => {
        if (!o.completion.additionalTextEdits || l.token.isCancellationRequested)
          return;
        if (m && o.completion.additionalTextEdits.some((S) => A.isBefore(m, L.getStartPosition(S.range))))
          return !1;
        b && this.editor.pushUndoStop();
        const w = sa.capture(this.editor);
        return this.editor.executeEdits("suggestController.additionalTextEdits.async", o.completion.additionalTextEdits.map((S) => ti.replaceMove(L.lift(S.range), S.text))), w.restoreRelativeVerticalPositionOfCursor(this.editor), (b || !(v & 2)) && this.editor.pushUndoStop(), !0;
      }).then((w) => {
        this._logService.trace("[suggest] async resolving of edits DONE (ms, applied?)", f.elapsed(), w), u = w === !0 ? 1 : w === !1 ? 0 : -2;
      }).finally(() => {
        _.dispose(), C.dispose();
      }));
    }
    let { insertText: g } = o.completion;
    if (o.completion.insertTextRules & 4 || (g = Mu.escape(g)), this.model.cancel(), i.insert(g, {
      overwriteBefore: d.overwriteBefore,
      overwriteAfter: d.overwriteAfter,
      undoStopBefore: !1,
      undoStopAfter: !1,
      adjustWhitespace: !(o.completion.insertTextRules & 1),
      clipboardText: e.model.clipboardText,
      overtypingCapturer: this._overtypingCapturer.value
    }), t & 2 || this.editor.pushUndoStop(), o.completion.command)
      if (o.completion.command.id === jb.id)
        this.model.trigger({ auto: !0, retrigger: !0 });
      else {
        const f = new rs();
        a.push(this._commandService.executeCommand(o.completion.command.id, ...o.completion.command.arguments ? [...o.completion.command.arguments] : []).catch((m) => {
          o.completion.extensionId ? _i(m) : He(m);
        }).finally(() => {
          h = f.elapsed();
        }));
      }
    t & 4 && this._alternatives.value.set(e, (f) => {
      for (l.cancel(); n.canUndo(); ) {
        s !== n.getAlternativeVersionId() && n.undo(), this._insertSuggestion(f, 3 | (t & 8 ? 8 : 0));
        break;
      }
    }), this._alertCompletionItem(o), Promise.all(a).finally(() => {
      this._reportSuggestionAcceptedTelemetry(o, n, c, h, u), this.model.clear(), l.dispose();
    });
  }
  _reportSuggestionAcceptedTelemetry(e, t, i, n, s) {
    var o, a, l;
    Math.floor(Math.random() * 100) !== 0 && this._telemetryService.publicLog2("suggest.acceptedSuggestion", {
      extensionId: (a = (o = e.extensionId) === null || o === void 0 ? void 0 : o.value) !== null && a !== void 0 ? a : "unknown",
      providerId: (l = e.provider._debugDisplayName) !== null && l !== void 0 ? l : "unknown",
      kind: e.completion.kind,
      basenameHash: Xy(Fo(t.uri)).toString(16),
      languageId: t.getLanguageId(),
      fileExtension: cQ(t.uri),
      resolveInfo: e.provider.resolveCompletionItem ? i ? 1 : 0 : -1,
      resolveDuration: e.resolveDuration,
      commandDuration: n,
      additionalEditsAsync: s
    });
  }
  getOverwriteInfo(e, t) {
    ct(this.editor.hasModel());
    let i = this.editor.getOption(
      118
      /* EditorOption.suggest */
    ).insertMode === "replace";
    t && (i = !i);
    const n = e.position.column - e.editStart.column, s = (i ? e.editReplaceEnd.column : e.editInsertEnd.column) - e.position.column, o = this.editor.getPosition().column - e.position.column, a = this._lineSuffix.value ? this._lineSuffix.value.delta(this.editor.getPosition()) : 0;
    return {
      overwriteBefore: n + o,
      overwriteAfter: s + a
    };
  }
  _alertCompletionItem(e) {
    if (Rn(e.completion.additionalTextEdits)) {
      const t = p("aria.alert.snippet", "Accepting '{0}' made {1} additional edits", e.textLabel, e.completion.additionalTextEdits.length);
      Ls(t);
    }
  }
  triggerSuggest(e, t, i) {
    this.editor.hasModel() && (this.model.trigger({
      auto: t ?? !1,
      completionOptions: { providerFilter: e, kindFilter: i ? /* @__PURE__ */ new Set() : void 0 }
    }), this.editor.revealPosition(
      this.editor.getPosition(),
      0
      /* ScrollType.Smooth */
    ), this.editor.focus());
  }
  triggerSuggestAndAcceptBest(e) {
    if (!this.editor.hasModel())
      return;
    const t = this.editor.getPosition(), i = () => {
      t.equals(this.editor.getPosition()) && this._commandService.executeCommand(e.fallback);
    }, n = (s) => {
      if (s.completion.insertTextRules & 4 || s.completion.additionalTextEdits)
        return !0;
      const o = this.editor.getPosition(), a = s.editStart.column, l = o.column;
      return l - a !== s.completion.insertText.length ? !0 : this.editor.getModel().getValueInRange({
        startLineNumber: o.lineNumber,
        startColumn: a,
        endLineNumber: o.lineNumber,
        endColumn: l
      }) !== s.completion.insertText;
    };
    ne.once(this.model.onDidTrigger)((s) => {
      const o = [];
      ne.any(this.model.onDidTrigger, this.model.onDidCancel)(() => {
        zt(o), i();
      }, void 0, o), this.model.onDidSuggest(({ completionModel: a }) => {
        if (zt(o), a.items.length === 0) {
          i();
          return;
        }
        const l = this._memoryService.select(this.editor.getModel(), this.editor.getPosition(), a.items), d = a.items[l];
        if (!n(d)) {
          i();
          return;
        }
        this.editor.pushUndoStop(), this._insertSuggestion(
          { index: l, item: d, model: a },
          7
          /* InsertFlags.NoAfterUndoStop */
        );
      }, void 0, o);
    }), this.model.trigger({ auto: !1, shy: !0 }), this.editor.revealPosition(
      t,
      0
      /* ScrollType.Smooth */
    ), this.editor.focus();
  }
  acceptSelectedSuggestion(e, t) {
    const i = this.widget.value.getFocusedItem();
    let n = 0;
    e && (n |= 4), t && (n |= 8), this._insertSuggestion(i, n);
  }
  acceptNextSuggestion() {
    this._alternatives.value.next();
  }
  acceptPrevSuggestion() {
    this._alternatives.value.prev();
  }
  cancelSuggestWidget() {
    this.model.cancel(), this.model.clear(), this.widget.value.hideWidget();
  }
  focusSuggestion() {
    this.widget.value.focusSelected();
  }
  selectNextSuggestion() {
    this.widget.value.selectNext();
  }
  selectNextPageSuggestion() {
    this.widget.value.selectNextPage();
  }
  selectLastSuggestion() {
    this.widget.value.selectLast();
  }
  selectPrevSuggestion() {
    this.widget.value.selectPrevious();
  }
  selectPrevPageSuggestion() {
    this.widget.value.selectPreviousPage();
  }
  selectFirstSuggestion() {
    this.widget.value.selectFirst();
  }
  toggleSuggestionDetails() {
    this.widget.value.toggleDetails();
  }
  toggleExplainMode() {
    this.widget.value.toggleExplainMode();
  }
  toggleSuggestionFocus() {
    this.widget.value.toggleDetailsFocus();
  }
  resetWidgetSize() {
    this.widget.value.resetPersistedSize();
  }
  forceRenderingAbove() {
    this.widget.value.forceRenderingAbove();
  }
  stopForceRenderingAbove() {
    this.widget.isInitialized && this.widget.value.stopForceRenderingAbove();
  }
  registerSelector(e) {
    return this._selectors.register(e);
  }
};
dr.ID = "editor.contrib.suggestController";
dr = qT = Tpe([
  kg(1, UL),
  kg(2, $t),
  kg(3, De),
  kg(4, be),
  kg(5, Pn),
  kg(6, kn)
], dr);
class Mpe {
  constructor(e) {
    this.prioritySelector = e, this._items = new Array();
  }
  register(e) {
    if (this._items.indexOf(e) !== -1)
      throw new Error("Value is already registered");
    return this._items.push(e), this._items.sort((t, i) => this.prioritySelector(i) - this.prioritySelector(t)), {
      dispose: () => {
        const t = this._items.indexOf(e);
        t >= 0 && this._items.splice(t, 1);
      }
    };
  }
  get itemsOrderedByPriorityDesc() {
    return this._items;
  }
}
class jb extends ae {
  constructor() {
    super({
      id: jb.id,
      label: p("suggest.trigger.label", "Trigger Suggest"),
      alias: "Trigger Suggest",
      precondition: U.and(x.writable, x.hasCompletionItemProvider, je.Visible.toNegated()),
      kbOpts: {
        kbExpr: x.textInputFocus,
        primary: 2058,
        secondary: [
          2087
          /* KeyCode.KeyI */
        ],
        mac: { primary: 266, secondary: [
          521,
          2087
          /* KeyCode.KeyI */
        ] },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(e, t, i) {
    const n = dr.get(t);
    if (!n)
      return;
    let s;
    i && typeof i == "object" && i.auto === !0 && (s = !0), n.triggerSuggest(void 0, s, void 0);
  }
}
jb.id = "editor.action.triggerSuggest";
gt(
  dr.ID,
  dr,
  2
  /* EditorContributionInstantiation.BeforeFirstInteraction */
);
Y(jb);
const mo = 190, fs = Ui.bindToContribution(dr.get);
se(new fs({
  id: "acceptSelectedSuggestion",
  precondition: U.and(je.Visible, je.HasFocusedSuggestion),
  handler(r) {
    r.acceptSelectedSuggestion(!0, !1);
  },
  kbOpts: [{
    // normal tab
    primary: 2,
    kbExpr: U.and(je.Visible, x.textInputFocus),
    weight: mo
  }, {
    // accept on enter has special rules
    primary: 3,
    kbExpr: U.and(je.Visible, x.textInputFocus, je.AcceptSuggestionsOnEnter, je.MakesTextEdit),
    weight: mo
  }],
  menuOpts: [{
    menuId: Sc,
    title: p("accept.insert", "Insert"),
    group: "left",
    order: 1,
    when: je.HasInsertAndReplaceRange.toNegated()
  }, {
    menuId: Sc,
    title: p("accept.insert", "Insert"),
    group: "left",
    order: 1,
    when: U.and(je.HasInsertAndReplaceRange, je.InsertMode.isEqualTo("insert"))
  }, {
    menuId: Sc,
    title: p("accept.replace", "Replace"),
    group: "left",
    order: 1,
    when: U.and(je.HasInsertAndReplaceRange, je.InsertMode.isEqualTo("replace"))
  }]
}));
se(new fs({
  id: "acceptAlternativeSelectedSuggestion",
  precondition: U.and(je.Visible, x.textInputFocus, je.HasFocusedSuggestion),
  kbOpts: {
    weight: mo,
    kbExpr: x.textInputFocus,
    primary: 1027,
    secondary: [
      1026
      /* KeyCode.Tab */
    ]
  },
  handler(r) {
    r.acceptSelectedSuggestion(!1, !0);
  },
  menuOpts: [{
    menuId: Sc,
    group: "left",
    order: 2,
    when: U.and(je.HasInsertAndReplaceRange, je.InsertMode.isEqualTo("insert")),
    title: p("accept.replace", "Replace")
  }, {
    menuId: Sc,
    group: "left",
    order: 2,
    when: U.and(je.HasInsertAndReplaceRange, je.InsertMode.isEqualTo("replace")),
    title: p("accept.insert", "Insert")
  }]
}));
st.registerCommandAlias("acceptSelectedSuggestionOnEnter", "acceptSelectedSuggestion");
se(new fs({
  id: "hideSuggestWidget",
  precondition: je.Visible,
  handler: (r) => r.cancelSuggestWidget(),
  kbOpts: {
    weight: mo,
    kbExpr: x.textInputFocus,
    primary: 9,
    secondary: [
      1033
      /* KeyCode.Escape */
    ]
  }
}));
se(new fs({
  id: "selectNextSuggestion",
  precondition: U.and(je.Visible, U.or(je.MultipleSuggestions, je.HasFocusedSuggestion.negate())),
  handler: (r) => r.selectNextSuggestion(),
  kbOpts: {
    weight: mo,
    kbExpr: x.textInputFocus,
    primary: 18,
    secondary: [
      2066
      /* KeyCode.DownArrow */
    ],
    mac: { primary: 18, secondary: [
      2066,
      300
      /* KeyCode.KeyN */
    ] }
  }
}));
se(new fs({
  id: "selectNextPageSuggestion",
  precondition: U.and(je.Visible, U.or(je.MultipleSuggestions, je.HasFocusedSuggestion.negate())),
  handler: (r) => r.selectNextPageSuggestion(),
  kbOpts: {
    weight: mo,
    kbExpr: x.textInputFocus,
    primary: 12,
    secondary: [
      2060
      /* KeyCode.PageDown */
    ]
  }
}));
se(new fs({
  id: "selectLastSuggestion",
  precondition: U.and(je.Visible, U.or(je.MultipleSuggestions, je.HasFocusedSuggestion.negate())),
  handler: (r) => r.selectLastSuggestion()
}));
se(new fs({
  id: "selectPrevSuggestion",
  precondition: U.and(je.Visible, U.or(je.MultipleSuggestions, je.HasFocusedSuggestion.negate())),
  handler: (r) => r.selectPrevSuggestion(),
  kbOpts: {
    weight: mo,
    kbExpr: x.textInputFocus,
    primary: 16,
    secondary: [
      2064
      /* KeyCode.UpArrow */
    ],
    mac: { primary: 16, secondary: [
      2064,
      302
      /* KeyCode.KeyP */
    ] }
  }
}));
se(new fs({
  id: "selectPrevPageSuggestion",
  precondition: U.and(je.Visible, U.or(je.MultipleSuggestions, je.HasFocusedSuggestion.negate())),
  handler: (r) => r.selectPrevPageSuggestion(),
  kbOpts: {
    weight: mo,
    kbExpr: x.textInputFocus,
    primary: 11,
    secondary: [
      2059
      /* KeyCode.PageUp */
    ]
  }
}));
se(new fs({
  id: "selectFirstSuggestion",
  precondition: U.and(je.Visible, U.or(je.MultipleSuggestions, je.HasFocusedSuggestion.negate())),
  handler: (r) => r.selectFirstSuggestion()
}));
se(new fs({
  id: "focusSuggestion",
  precondition: U.and(je.Visible, je.HasFocusedSuggestion.negate()),
  handler: (r) => r.focusSuggestion(),
  kbOpts: {
    weight: mo,
    kbExpr: x.textInputFocus,
    primary: 2058,
    secondary: [
      2087
      /* KeyCode.KeyI */
    ],
    mac: { primary: 266, secondary: [
      2087
      /* KeyCode.KeyI */
    ] }
  }
}));
se(new fs({
  id: "focusAndAcceptSuggestion",
  precondition: U.and(je.Visible, je.HasFocusedSuggestion.negate()),
  handler: (r) => {
    r.focusSuggestion(), r.acceptSelectedSuggestion(!0, !1);
  }
}));
se(new fs({
  id: "toggleSuggestionDetails",
  precondition: U.and(je.Visible, je.HasFocusedSuggestion),
  handler: (r) => r.toggleSuggestionDetails(),
  kbOpts: {
    weight: mo,
    kbExpr: x.textInputFocus,
    primary: 2058,
    secondary: [
      2087
      /* KeyCode.KeyI */
    ],
    mac: { primary: 266, secondary: [
      2087
      /* KeyCode.KeyI */
    ] }
  },
  menuOpts: [{
    menuId: Sc,
    group: "right",
    order: 1,
    when: U.and(je.DetailsVisible, je.CanResolve),
    title: p("detail.more", "show less")
  }, {
    menuId: Sc,
    group: "right",
    order: 1,
    when: U.and(je.DetailsVisible.toNegated(), je.CanResolve),
    title: p("detail.less", "show more")
  }]
}));
se(new fs({
  id: "toggleExplainMode",
  precondition: je.Visible,
  handler: (r) => r.toggleExplainMode(),
  kbOpts: {
    weight: 100,
    primary: 2138
  }
}));
se(new fs({
  id: "toggleSuggestionFocus",
  precondition: je.Visible,
  handler: (r) => r.toggleSuggestionFocus(),
  kbOpts: {
    weight: mo,
    kbExpr: x.textInputFocus,
    primary: 2570,
    mac: {
      primary: 778
      /* KeyCode.Space */
    }
  }
}));
se(new fs({
  id: "insertBestCompletion",
  precondition: U.and(x.textInputFocus, U.equals("config.editor.tabCompletion", "on"), zv.AtEnd, je.Visible.toNegated(), Hu.OtherSuggestions.toNegated(), vn.InSnippetMode.toNegated()),
  handler: (r, e) => {
    r.triggerSuggestAndAcceptBest(ur(e) ? { fallback: "tab", ...e } : { fallback: "tab" });
  },
  kbOpts: {
    weight: mo,
    primary: 2
    /* KeyCode.Tab */
  }
}));
se(new fs({
  id: "insertNextSuggestion",
  precondition: U.and(x.textInputFocus, U.equals("config.editor.tabCompletion", "on"), Hu.OtherSuggestions, je.Visible.toNegated(), vn.InSnippetMode.toNegated()),
  handler: (r) => r.acceptNextSuggestion(),
  kbOpts: {
    weight: mo,
    kbExpr: x.textInputFocus,
    primary: 2
    /* KeyCode.Tab */
  }
}));
se(new fs({
  id: "insertPrevSuggestion",
  precondition: U.and(x.textInputFocus, U.equals("config.editor.tabCompletion", "on"), Hu.OtherSuggestions, je.Visible.toNegated(), vn.InSnippetMode.toNegated()),
  handler: (r) => r.acceptPrevSuggestion(),
  kbOpts: {
    weight: mo,
    kbExpr: x.textInputFocus,
    primary: 1026
    /* KeyCode.Tab */
  }
}));
Y(class extends ae {
  constructor() {
    super({
      id: "editor.action.resetSuggestSize",
      label: p("suggest.reset.label", "Reset Suggest Widget Size"),
      alias: "Reset Suggest Widget Size",
      precondition: void 0
    });
  }
  run(r, e) {
    var t;
    (t = dr.get(e)) === null || t === void 0 || t.resetWidgetSize();
  }
});
class Rpe extends P {
  get selectedItem() {
    return this._selectedItem;
  }
  constructor(e, t, i, n) {
    super(), this.editor = e, this.suggestControllerPreselector = t, this.checkModelVersion = i, this.onWillAccept = n, this.isSuggestWidgetVisible = !1, this.isShiftKeyPressed = !1, this._isActive = !1, this._currentSuggestItemInfo = void 0, this._selectedItem = rt(this, void 0), this._register(e.onKeyDown((o) => {
      o.shiftKey && !this.isShiftKeyPressed && (this.isShiftKeyPressed = !0, this.update(this._isActive));
    })), this._register(e.onKeyUp((o) => {
      o.shiftKey && this.isShiftKeyPressed && (this.isShiftKeyPressed = !1, this.update(this._isActive));
    }));
    const s = dr.get(this.editor);
    if (s) {
      this._register(s.registerSelector({
        priority: 100,
        select: (l, d, c) => {
          Nt((v) => this.checkModelVersion(v));
          const h = this.editor.getModel();
          if (!h)
            return -1;
          const u = this.suggestControllerPreselector(), g = u ? mu(u, h) : void 0;
          if (!g)
            return -1;
          const f = A.lift(d), m = c.map((v, b) => {
            const C = D_.fromSuggestion(s, h, f, v, this.isShiftKeyPressed), w = mu(C.toSingleTextEdit(), h), S = X4(g, w);
            return { index: b, valid: S, prefixLength: w.text.length, suggestItem: v };
          }).filter((v) => v && v.valid && v.prefixLength > 0), _ = pH(m, cr((v) => v.prefixLength, Zu));
          return _ ? _.index : -1;
        }
      }));
      let o = !1;
      const a = () => {
        o || (o = !0, this._register(s.widget.value.onDidShow(() => {
          this.isSuggestWidgetVisible = !0, this.update(!0);
        })), this._register(s.widget.value.onDidHide(() => {
          this.isSuggestWidgetVisible = !1, this.update(!1);
        })), this._register(s.widget.value.onDidFocus(() => {
          this.isSuggestWidgetVisible = !0, this.update(!0);
        })));
      };
      this._register(ne.once(s.model.onDidTrigger)((l) => {
        a();
      })), this._register(s.onWillInsertSuggestItem((l) => {
        const d = this.editor.getPosition(), c = this.editor.getModel();
        if (!d || !c)
          return;
        const h = D_.fromSuggestion(s, c, d, l.item, this.isShiftKeyPressed);
        this.onWillAccept(h);
      }));
    }
    this.update(this._isActive);
  }
  update(e) {
    const t = this.getSuggestItemInfo();
    (this._isActive !== e || !Ape(this._currentSuggestItemInfo, t)) && (this._isActive = e, this._currentSuggestItemInfo = t, Nt((i) => {
      this.checkModelVersion(i), this._selectedItem.set(this._isActive ? this._currentSuggestItemInfo : void 0, i);
    }));
  }
  getSuggestItemInfo() {
    const e = dr.get(this.editor);
    if (!e || !this.isSuggestWidgetVisible)
      return;
    const t = e.widget.value.getFocusedItem(), i = this.editor.getPosition(), n = this.editor.getModel();
    if (!(!t || !i || !n))
      return D_.fromSuggestion(e, n, i, t.item, this.isShiftKeyPressed);
  }
  stopForceRenderingAbove() {
    const e = dr.get(this.editor);
    e == null || e.stopForceRenderingAbove();
  }
  forceRenderingAbove() {
    const e = dr.get(this.editor);
    e == null || e.forceRenderingAbove();
  }
}
class D_ {
  static fromSuggestion(e, t, i, n, s) {
    let { insertText: o } = n.completion, a = !1;
    if (n.completion.insertTextRules & 4) {
      const d = new Mu().parse(o);
      d.children.length < 100 && $y.adjustWhitespace(t, i, !0, d), o = d.toString(), a = !0;
    }
    const l = e.getOverwriteInfo(n, s);
    return new D_(L.fromPositions(i.delta(0, -l.overwriteBefore), i.delta(0, Math.max(l.overwriteAfter, 0))), o, n.completion.kind, a);
  }
  constructor(e, t, i, n) {
    this.range = e, this.insertText = t, this.completionItemKind = i, this.isSnippetText = n;
  }
  equals(e) {
    return this.range.equalsRange(e.range) && this.insertText === e.insertText && this.completionItemKind === e.completionItemKind && this.isSnippetText === e.isSnippetText;
  }
  toSelectedSuggestionInfo() {
    return new mH(this.range, this.insertText, this.completionItemKind, this.isSnippetText);
  }
  toSingleTextEdit() {
    return new Nc(this.range, this.insertText);
  }
}
function Ape(r, e) {
  return r === e ? !0 : !r || !e ? !1 : r.equals(e);
}
var Ppe = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, yl = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, GT;
let _o = GT = class extends P {
  static get(e) {
    return e.getContribution(GT.ID);
  }
  constructor(e, t, i, n, s, o, a, l, d, c) {
    super(), this.editor = e, this._instantiationService = t, this._contextKeyService = i, this._configurationService = n, this._commandService = s, this._debounceService = o, this._languageFeaturesService = a, this._accessibilitySignalService = l, this._keybindingService = d, this._accessibilityService = c, this.model = this._register(cv("inlineCompletionModel", void 0)), this._textModelVersionId = rt(this, -1), this._positions = gie({ owner: this, equalsFn: $I(vz()) }, [new A(1, 1)]), this._suggestWidgetAdaptor = this._register(new Rpe(this.editor, () => {
      var m, _;
      return (_ = (m = this.model.get()) === null || m === void 0 ? void 0 : m.selectedInlineCompletion.get()) === null || _ === void 0 ? void 0 : _.toSingleTextEdit(void 0);
    }, (m) => this.updateObservables(m, to.Other), (m) => {
      Nt((_) => {
        var v;
        this.updateObservables(_, to.Other), (v = this.model.get()) === null || v === void 0 || v.handleSuggestAccepted(m);
      });
    })), this._enabledInConfig = Lt(this.editor.onDidChangeConfiguration, () => this.editor.getOption(
      62
      /* EditorOption.inlineSuggest */
    ).enabled), this._isScreenReaderEnabled = Lt(this._accessibilityService.onDidChangeScreenReaderOptimized, () => this._accessibilityService.isScreenReaderOptimized()), this._editorDictationInProgress = Lt(this._contextKeyService.onDidChangeContext, () => this._contextKeyService.getContext(this.editor.getDomNode()).getValue("editorDictation.inProgress") === !0), this._enabled = Pe(this, (m) => this._enabledInConfig.read(m) && (!this._isScreenReaderEnabled.read(m) || !this._editorDictationInProgress.read(m))), this._fontFamily = Lt(this.editor.onDidChangeConfiguration, () => this.editor.getOption(
      62
      /* EditorOption.inlineSuggest */
    ).fontFamily), this._ghostTexts = Pe(this, (m) => {
      var _;
      const v = this.model.read(m);
      return (_ = v == null ? void 0 : v.ghostTexts.read(m)) !== null && _ !== void 0 ? _ : [];
    }), this._stablizedGhostTexts = Ope(this._ghostTexts, this._store), this._ghostTextWidgets = wie(this, this._stablizedGhostTexts, (m, _) => _.add(this._instantiationService.createInstance(BT, this.editor, {
      ghostText: m,
      minReservedLineCount: Hr(0),
      targetTextModel: this.model.map((v) => v == null ? void 0 : v.textModel)
    }))).recomputeInitiallyAndOnChange(this._store), this._debounceValue = this._debounceService.for(this._languageFeaturesService.inlineCompletionsProvider, "InlineCompletionsDebounce", { min: 50, max: 50 }), this._playAccessibilitySignal = Q0(this), this._isReadonly = Lt(this.editor.onDidChangeConfiguration, () => this.editor.getOption(
      91
      /* EditorOption.readOnly */
    )), this._textModel = Lt(this.editor.onDidChangeModel, () => this.editor.getModel()), this._textModelIfWritable = Pe((m) => this._isReadonly.read(m) ? void 0 : this._textModel.read(m)), this._register(new rn(this._contextKeyService, this.model)), this._register(qe((m) => {
      const _ = this._textModelIfWritable.read(m);
      Nt((v) => {
        if (this.model.set(void 0, v), this.updateObservables(v, to.Other), _) {
          const b = t.createInstance(VT, _, this._suggestWidgetAdaptor.selectedItem, this._textModelVersionId, this._positions, this._debounceValue, Lt(e.onDidChangeConfiguration, () => e.getOption(
            118
            /* EditorOption.suggest */
          ).preview), Lt(e.onDidChangeConfiguration, () => e.getOption(
            118
            /* EditorOption.suggest */
          ).previewMode), Lt(e.onDidChangeConfiguration, () => e.getOption(
            62
            /* EditorOption.inlineSuggest */
          ).mode), this._enabled);
          this.model.set(b, v);
        }
      });
    }));
    const h = this._register($H());
    this._register(qe((m) => {
      const _ = this._fontFamily.read(m);
      h.setStyle(_ === "" || _ === "default" ? "" : `
.monaco-editor .ghost-text-decoration,
.monaco-editor .ghost-text-decoration-preview,
.monaco-editor .ghost-text {
	font-family: ${_};
}`);
    }));
    const u = (m) => {
      var _;
      return m.isUndoing ? to.Undo : m.isRedoing ? to.Redo : !((_ = this.model.get()) === null || _ === void 0) && _.isAcceptingPartially ? to.AcceptWord : to.Other;
    };
    this._register(e.onDidChangeModelContent((m) => Nt((_) => (
      /** @description InlineCompletionsController.onDidChangeModelContent */
      this.updateObservables(_, u(m))
    )))), this._register(e.onDidChangeCursorPosition((m) => Nt((_) => {
      var v;
      this.updateObservables(_, to.Other), (m.reason === 3 || m.source === "api") && ((v = this.model.get()) === null || v === void 0 || v.stop(_));
    }))), this._register(e.onDidType(() => Nt((m) => {
      var _;
      this.updateObservables(m, to.Other), this._enabled.get() && ((_ = this.model.get()) === null || _ === void 0 || _.trigger(m));
    }))), this._register(this._commandService.onDidExecuteCommand((m) => {
      (/* @__PURE__ */ new Set([
        Cf.Tab.id,
        Cf.DeleteLeft.id,
        Cf.DeleteRight.id,
        n4,
        "acceptSelectedSuggestion"
      ])).has(m.commandId) && e.hasTextFocus() && this._enabled.get() && Nt((v) => {
        var b;
        (b = this.model.get()) === null || b === void 0 || b.trigger(v);
      });
    })), this._register(this.editor.onDidBlurEditorWidget(() => {
      this._contextKeyService.getContextKeyValue("accessibleViewIsShown") || this._configurationService.getValue("editor.inlineSuggest.keepOnBlur") || e.getOption(
        62
        /* EditorOption.inlineSuggest */
      ).keepOnBlur || Kc.dropDownVisible || Nt((m) => {
        var _;
        (_ = this.model.get()) === null || _ === void 0 || _.stop(m);
      });
    })), this._register(qe((m) => {
      var _;
      const v = (_ = this.model.read(m)) === null || _ === void 0 ? void 0 : _.state.read(m);
      v != null && v.suggestItem ? v.primaryGhostText.lineCount >= 2 && this._suggestWidgetAdaptor.forceRenderingAbove() : this._suggestWidgetAdaptor.stopForceRenderingAbove();
    })), this._register(Se(() => {
      this._suggestWidgetAdaptor.stopForceRenderingAbove();
    }));
    const g = this._register(new q());
    let f;
    this._register(kb({
      handleChange: (m, _) => (m.didChange(this._playAccessibilitySignal) && (f = void 0), !0)
    }, async (m, _) => {
      this._playAccessibilitySignal.read(m);
      const v = this.model.read(m), b = v == null ? void 0 : v.state.read(m);
      if (!v || !b || !b.inlineCompletion) {
        f = void 0;
        return;
      }
      if (b.inlineCompletion.semanticId !== f) {
        g.clear(), f = b.inlineCompletion.semanticId;
        const C = v.textModel.getLineContent(b.primaryGhostText.lineNumber);
        await cd(50, gA(g)), await yz(this._suggestWidgetAdaptor.selectedItem, Fs, () => !1, gA(g)), await this._accessibilitySignalService.playSignal(Re.inlineSuggestion), this.editor.getOption(
          8
          /* EditorOption.screenReaderAnnounceInlineSuggestion */
        ) && this.provideScreenReaderUpdate(b.primaryGhostText.renderForScreenReader(C));
      }
    })), this._register(new gT(this.editor, this.model, this._instantiationService)), this._register(this._configurationService.onDidChangeConfiguration((m) => {
      m.affectsConfiguration("accessibility.verbosity.inlineCompletions") && this.editor.updateOptions({ inlineCompletionsAccessibilityVerbose: this._configurationService.getValue("accessibility.verbosity.inlineCompletions") });
    })), this.editor.updateOptions({ inlineCompletionsAccessibilityVerbose: this._configurationService.getValue("accessibility.verbosity.inlineCompletions") });
  }
  playAccessibilitySignal(e) {
    this._playAccessibilitySignal.trigger(e);
  }
  provideScreenReaderUpdate(e) {
    const t = this._contextKeyService.getContextKeyValue("accessibleViewIsShown"), i = this._keybindingService.lookupKeybinding("editor.action.accessibleView");
    let n;
    !t && i && this.editor.getOption(
      149
      /* EditorOption.inlineCompletionsAccessibilityVerbose */
    ) && (n = p("showAccessibleViewHint", "Inspect this in the accessible view ({0})", i.getAriaLabel())), Ls(n ? e + ", " + n : e);
  }
  /**
   * Copies over the relevant state from the text model to observables.
   * This solves all kind of eventing issues, as we make sure we always operate on the latest state,
   * regardless of who calls into us.
   */
  updateObservables(e, t) {
    var i, n, s;
    const o = this.editor.getModel();
    this._textModelVersionId.set((i = o == null ? void 0 : o.getVersionId()) !== null && i !== void 0 ? i : -1, e, t), this._positions.set((s = (n = this.editor.getSelections()) === null || n === void 0 ? void 0 : n.map((a) => a.getPosition())) !== null && s !== void 0 ? s : [new A(1, 1)], e);
  }
  shouldShowHoverAt(e) {
    var t;
    const i = (t = this.model.get()) === null || t === void 0 ? void 0 : t.primaryGhostText.get();
    return i ? i.parts.some((n) => e.containsPosition(new A(i.lineNumber, n.column))) : !1;
  }
  shouldShowHoverAtViewZone(e) {
    var t, i;
    return (i = (t = this._ghostTextWidgets.get()[0]) === null || t === void 0 ? void 0 : t.ownsViewZone(e)) !== null && i !== void 0 ? i : !1;
  }
};
_o.ID = "editor.contrib.inlineCompletionsController";
_o = GT = Ppe([
  yl(1, be),
  yl(2, De),
  yl(3, Ge),
  yl(4, $t),
  yl(5, Vo),
  yl(6, he),
  yl(7, rh),
  yl(8, _t),
  yl(9, qs)
], _o);
function Ope(r, e) {
  const t = rt("result", []), i = [];
  return e.add(qe((n) => {
    const s = r.read(n);
    Nt((o) => {
      if (s.length !== i.length) {
        i.length = s.length;
        for (let a = 0; a < i.length; a++)
          i[a] || (i[a] = rt("item", s[a]));
        t.set([...i], o);
      }
      i.forEach((a, l) => a.set(s[l], o));
    });
  })), t;
}
class KL extends ae {
  constructor() {
    super({
      id: KL.ID,
      label: p("action.inlineSuggest.showNext", "Show Next Inline Suggestion"),
      alias: "Show Next Inline Suggestion",
      precondition: U.and(x.writable, rn.inlineSuggestionVisible),
      kbOpts: {
        weight: 100,
        primary: 606
      }
    });
  }
  async run(e, t) {
    var i;
    const n = _o.get(t);
    (i = n == null ? void 0 : n.model.get()) === null || i === void 0 || i.next();
  }
}
KL.ID = o4;
class jL extends ae {
  constructor() {
    super({
      id: jL.ID,
      label: p("action.inlineSuggest.showPrevious", "Show Previous Inline Suggestion"),
      alias: "Show Previous Inline Suggestion",
      precondition: U.and(x.writable, rn.inlineSuggestionVisible),
      kbOpts: {
        weight: 100,
        primary: 604
      }
    });
  }
  async run(e, t) {
    var i;
    const n = _o.get(t);
    (i = n == null ? void 0 : n.model.get()) === null || i === void 0 || i.previous();
  }
}
jL.ID = s4;
class Fpe extends ae {
  constructor() {
    super({
      id: "editor.action.inlineSuggest.trigger",
      label: p("action.inlineSuggest.trigger", "Trigger Inline Suggestion"),
      alias: "Trigger Inline Suggestion",
      precondition: x.writable
    });
  }
  async run(e, t) {
    const i = _o.get(t);
    await uie(async (n) => {
      var s;
      await ((s = i == null ? void 0 : i.model.get()) === null || s === void 0 ? void 0 : s.triggerExplicitly(n)), i == null || i.playAccessibilitySignal(n);
    });
  }
}
class Wpe extends ae {
  constructor() {
    super({
      id: "editor.action.inlineSuggest.acceptNextWord",
      label: p("action.inlineSuggest.acceptNextWord", "Accept Next Word Of Inline Suggestion"),
      alias: "Accept Next Word Of Inline Suggestion",
      precondition: U.and(x.writable, rn.inlineSuggestionVisible),
      kbOpts: {
        weight: 101,
        primary: 2065,
        kbExpr: U.and(x.writable, rn.inlineSuggestionVisible)
      },
      menuOpts: [{
        menuId: D.InlineSuggestionToolbar,
        title: p("acceptWord", "Accept Word"),
        group: "primary",
        order: 2
      }]
    });
  }
  async run(e, t) {
    var i;
    const n = _o.get(t);
    await ((i = n == null ? void 0 : n.model.get()) === null || i === void 0 ? void 0 : i.acceptNextWord(n.editor));
  }
}
class Bpe extends ae {
  constructor() {
    super({
      id: "editor.action.inlineSuggest.acceptNextLine",
      label: p("action.inlineSuggest.acceptNextLine", "Accept Next Line Of Inline Suggestion"),
      alias: "Accept Next Line Of Inline Suggestion",
      precondition: U.and(x.writable, rn.inlineSuggestionVisible),
      kbOpts: {
        weight: 101
      },
      menuOpts: [{
        menuId: D.InlineSuggestionToolbar,
        title: p("acceptLine", "Accept Line"),
        group: "secondary",
        order: 2
      }]
    });
  }
  async run(e, t) {
    var i;
    const n = _o.get(t);
    await ((i = n == null ? void 0 : n.model.get()) === null || i === void 0 ? void 0 : i.acceptNextLine(n.editor));
  }
}
class Hpe extends ae {
  constructor() {
    super({
      id: n4,
      label: p("action.inlineSuggest.accept", "Accept Inline Suggestion"),
      alias: "Accept Inline Suggestion",
      precondition: rn.inlineSuggestionVisible,
      menuOpts: [{
        menuId: D.InlineSuggestionToolbar,
        title: p("accept", "Accept"),
        group: "primary",
        order: 1
      }],
      kbOpts: {
        primary: 2,
        weight: 200,
        kbExpr: U.and(rn.inlineSuggestionVisible, x.tabMovesFocus.toNegated(), rn.inlineSuggestionHasIndentationLessThanTabSize, je.Visible.toNegated(), x.hoverFocused.toNegated())
      }
    });
  }
  async run(e, t) {
    var i;
    const n = _o.get(t);
    n && ((i = n.model.get()) === null || i === void 0 || i.accept(n.editor), n.editor.focus());
  }
}
class qL extends ae {
  constructor() {
    super({
      id: qL.ID,
      label: p("action.inlineSuggest.hide", "Hide Inline Suggestion"),
      alias: "Hide Inline Suggestion",
      precondition: rn.inlineSuggestionVisible,
      kbOpts: {
        weight: 100,
        primary: 9
      }
    });
  }
  async run(e, t) {
    const i = _o.get(t);
    Nt((n) => {
      var s;
      (s = i == null ? void 0 : i.model.get()) === null || s === void 0 || s.stop(n);
    });
  }
}
qL.ID = "editor.action.inlineSuggest.hide";
class GL extends cs {
  constructor() {
    super({
      id: GL.ID,
      title: p("action.inlineSuggest.alwaysShowToolbar", "Always Show Toolbar"),
      f1: !1,
      precondition: void 0,
      menu: [{
        id: D.InlineSuggestionToolbar,
        group: "secondary",
        order: 10
      }],
      toggled: U.equals("config.editor.inlineSuggest.showToolbar", "always")
    });
  }
  async run(e, t) {
    const i = e.get(Ge), s = i.getValue("editor.inlineSuggest.showToolbar") === "always" ? "onHover" : "always";
    i.updateValue("editor.inlineSuggest.showToolbar", s);
  }
}
GL.ID = "editor.action.inlineSuggest.toggleAlwaysShowToolbar";
var Vpe = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Cm = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
class zpe {
  constructor(e, t, i) {
    this.owner = e, this.range = t, this.controller = i;
  }
  isValidForHoverAnchor(e) {
    return e.type === 1 && this.range.startColumn <= e.range.startColumn && this.range.endColumn >= e.range.endColumn;
  }
}
let ZT = class {
  constructor(e, t, i, n, s, o) {
    this._editor = e, this._languageService = t, this._openerService = i, this.accessibilityService = n, this._instantiationService = s, this._telemetryService = o, this.hoverOrdinal = 4;
  }
  suggestHoverAnchor(e) {
    const t = _o.get(this._editor);
    if (!t)
      return null;
    const i = e.target;
    if (i.type === 8) {
      const n = i.detail;
      if (t.shouldShowHoverAtViewZone(n.viewZoneId))
        return new gu(1e3, this, L.fromPositions(this._editor.getModel().validatePosition(n.positionBefore || n.position)), e.event.posx, e.event.posy, !1);
    }
    return i.type === 7 && t.shouldShowHoverAt(i.range) ? new gu(1e3, this, i.range, e.event.posx, e.event.posy, !1) : i.type === 6 && i.detail.mightBeForeignElement && t.shouldShowHoverAt(i.range) ? new gu(1e3, this, i.range, e.event.posx, e.event.posy, !1) : null;
  }
  computeSync(e, t) {
    if (this._editor.getOption(
      62
      /* EditorOption.inlineSuggest */
    ).showToolbar !== "onHover")
      return [];
    const i = _o.get(this._editor);
    return i && i.shouldShowHoverAt(e.range) ? [new zpe(this, e.range, i)] : [];
  }
  renderHoverParts(e, t) {
    const i = new q(), n = t[0];
    this._telemetryService.publicLog2("inlineCompletionHover.shown"), this.accessibilityService.isScreenReaderOptimized() && !this._editor.getOption(
      8
      /* EditorOption.screenReaderAnnounceInlineSuggestion */
    ) && this.renderScreenReaderText(e, n, i);
    const s = n.controller.model.get(), o = this._instantiationService.createInstance(Kc, this._editor, !1, Hr(null), s.selectedInlineCompletionIndex, s.inlineCompletionsCount, s.activeCommands);
    return e.fragment.appendChild(o.getDomNode()), s.triggerExplicitly(), i.add(o), i;
  }
  renderScreenReaderText(e, t, i) {
    const n = X, s = n("div.hover-row.markdown-hover"), o = G(s, n("div.hover-contents", { "aria-live": "assertive" })), a = i.add(new nl({ editor: this._editor }, this._languageService, this._openerService)), l = (d) => {
      i.add(a.onDidRenderAsync(() => {
        o.className = "hover-contents code-hover-contents", e.onContentsChanged();
      }));
      const c = p("inlineSuggestionFollows", "Suggestion:"), h = i.add(a.render(new Nn().appendText(c).appendCodeblock("text", d)));
      o.replaceChildren(h.element);
    };
    i.add(qe((d) => {
      var c;
      const h = (c = t.controller.model.read(d)) === null || c === void 0 ? void 0 : c.primaryGhostText.read(d);
      if (h) {
        const u = this._editor.getModel().getLineContent(h.lineNumber);
        l(h.renderForScreenReader(u));
      } else
        mn(o);
    })), e.fragment.appendChild(s);
  }
};
ZT = Vpe([
  Cm(1, Jt),
  Cm(2, Ys),
  Cm(3, qs),
  Cm(4, be),
  Cm(5, kn)
], ZT);
class Upe extends P {
  constructor() {
    super();
  }
}
const ZL = new class {
  constructor() {
    this._implementations = [];
  }
  register(e) {
    return this._implementations.push(e), {
      dispose: () => {
        const t = this._implementations.indexOf(e);
        t !== -1 && this._implementations.splice(t, 1), e.dispose();
      }
    };
  }
  getImplementations() {
    return this._implementations;
  }
}();
gt(
  _o.ID,
  _o,
  3
  /* EditorContributionInstantiation.Eventually */
);
Y(Fpe);
Y(KL);
Y(jL);
Y(Wpe);
Y(Bpe);
Y(Hpe);
Y(qL);
Rt(GL);
ah.register(ZT);
ZL.register(new Upe());
var $pe = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, ax = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, Km;
let Vu = Km = class {
  constructor(e, t, i, n) {
    this.textModelResolverService = t, this.languageService = i, this.languageFeaturesService = n, this.toUnhook = new q(), this.toUnhookForKeyboard = new q(), this.currentWordAtPosition = null, this.previousPromise = null, this.editor = e, this.linkDecorations = this.editor.createDecorationsCollection();
    const s = new xL(e);
    this.toUnhook.add(s), this.toUnhook.add(s.onMouseMoveOrRelevantKeyDown(([o, a]) => {
      this.startFindDefinitionFromMouse(o, a ?? void 0);
    })), this.toUnhook.add(s.onExecute((o) => {
      this.isEnabled(o) && this.gotoDefinition(o.target.position, o.hasSideBySideModifier).catch((a) => {
        He(a);
      }).finally(() => {
        this.removeLinkDecorations();
      });
    })), this.toUnhook.add(s.onCancel(() => {
      this.removeLinkDecorations(), this.currentWordAtPosition = null;
    }));
  }
  static get(e) {
    return e.getContribution(Km.ID);
  }
  async startFindDefinitionFromCursor(e) {
    await this.startFindDefinition(e), this.toUnhookForKeyboard.add(this.editor.onDidChangeCursorPosition(() => {
      this.currentWordAtPosition = null, this.removeLinkDecorations(), this.toUnhookForKeyboard.clear();
    })), this.toUnhookForKeyboard.add(this.editor.onKeyDown((t) => {
      t && (this.currentWordAtPosition = null, this.removeLinkDecorations(), this.toUnhookForKeyboard.clear());
    }));
  }
  startFindDefinitionFromMouse(e, t) {
    if (e.target.type === 9 && this.linkDecorations.length > 0)
      return;
    if (!this.editor.hasModel() || !this.isEnabled(e, t)) {
      this.currentWordAtPosition = null, this.removeLinkDecorations();
      return;
    }
    const i = e.target.position;
    this.startFindDefinition(i);
  }
  async startFindDefinition(e) {
    var t;
    this.toUnhookForKeyboard.clear();
    const i = e ? (t = this.editor.getModel()) === null || t === void 0 ? void 0 : t.getWordAtPosition(e) : null;
    if (!i) {
      this.currentWordAtPosition = null, this.removeLinkDecorations();
      return;
    }
    if (this.currentWordAtPosition && this.currentWordAtPosition.startColumn === i.startColumn && this.currentWordAtPosition.endColumn === i.endColumn && this.currentWordAtPosition.word === i.word)
      return;
    this.currentWordAtPosition = i;
    const n = new U3(
      this.editor,
      15
      /* CodeEditorStateFlag.Scroll */
    );
    this.previousPromise && (this.previousPromise.cancel(), this.previousPromise = null), this.previousPromise = Zi((a) => this.findDefinition(e, a));
    let s;
    try {
      s = await this.previousPromise;
    } catch (a) {
      He(a);
      return;
    }
    if (!s || !s.length || !n.validate(this.editor)) {
      this.removeLinkDecorations();
      return;
    }
    const o = s[0].originSelectionRange ? L.lift(s[0].originSelectionRange) : new L(e.lineNumber, i.startColumn, e.lineNumber, i.endColumn);
    if (s.length > 1) {
      let a = o;
      for (const { originSelectionRange: l } of s)
        l && (a = L.plusRange(a, l));
      this.addDecoration(a, new Nn().appendText(p("multipleResults", "Click to show {0} definitions.", s.length)));
    } else {
      const a = s[0];
      if (!a.uri)
        return;
      this.textModelResolverService.createModelReference(a.uri).then((l) => {
        if (!l.object || !l.object.textEditorModel) {
          l.dispose();
          return;
        }
        const { object: { textEditorModel: d } } = l, { startLineNumber: c } = a.range;
        if (c < 1 || c > d.getLineCount()) {
          l.dispose();
          return;
        }
        const h = this.getPreviewValue(d, c, a), u = this.languageService.guessLanguageIdByFilepathOrFirstLine(d.uri);
        this.addDecoration(o, h ? new Nn().appendCodeblock(u || "", h) : void 0), l.dispose();
      });
    }
  }
  getPreviewValue(e, t, i) {
    let n = i.range;
    return n.endLineNumber - n.startLineNumber >= Km.MAX_SOURCE_PREVIEW_LINES && (n = this.getPreviewRangeBasedOnIndentation(e, t)), this.stripIndentationFromPreviewRange(e, t, n);
  }
  stripIndentationFromPreviewRange(e, t, i) {
    let s = e.getLineFirstNonWhitespaceColumn(t);
    for (let a = t + 1; a < i.endLineNumber; a++) {
      const l = e.getLineFirstNonWhitespaceColumn(a);
      s = Math.min(s, l);
    }
    return e.getValueInRange(i).replace(new RegExp(`^\\s{${s - 1}}`, "gm"), "").trim();
  }
  getPreviewRangeBasedOnIndentation(e, t) {
    const i = e.getLineFirstNonWhitespaceColumn(t), n = Math.min(e.getLineCount(), t + Km.MAX_SOURCE_PREVIEW_LINES);
    let s = t + 1;
    for (; s < n; s++) {
      const o = e.getLineFirstNonWhitespaceColumn(s);
      if (i === o)
        break;
    }
    return new L(t, 1, s + 1, 1);
  }
  addDecoration(e, t) {
    const i = {
      range: e,
      options: {
        description: "goto-definition-link",
        inlineClassName: "goto-definition-link",
        hoverMessage: t
      }
    };
    this.linkDecorations.set([i]);
  }
  removeLinkDecorations() {
    this.linkDecorations.clear();
  }
  isEnabled(e, t) {
    var i;
    return this.editor.hasModel() && e.isLeftClick && e.isNoneOrSingleMouseDown && e.target.type === 6 && !(((i = e.target.detail.injectedText) === null || i === void 0 ? void 0 : i.options) instanceof Bc) && (e.hasTriggerModifier || (t ? t.keyCodeIsTriggerKey : !1)) && this.languageFeaturesService.definitionProvider.has(this.editor.getModel());
  }
  findDefinition(e, t) {
    const i = this.editor.getModel();
    return i ? RL(this.languageFeaturesService.definitionProvider, i, e, t) : Promise.resolve(null);
  }
  gotoDefinition(e, t) {
    return this.editor.setPosition(e), this.editor.invokeWithinContext((i) => {
      const n = !t && this.editor.getOption(
        88
        /* EditorOption.definitionLinkOpensInPeek */
      ) && !this.isInPeekEditor(i);
      return new $b({ openToSide: t, openInPeek: n, muteMessage: !0 }, { title: { value: "", original: "" }, id: "", precondition: void 0 }).run(i);
    });
  }
  isInPeekEditor(e) {
    const t = e.get(De);
    return ks.inPeekEditor.getValue(t);
  }
  dispose() {
    this.toUnhook.dispose(), this.toUnhookForKeyboard.dispose();
  }
};
Vu.ID = "editor.contrib.gotodefinitionatposition";
Vu.MAX_SOURCE_PREVIEW_LINES = 8;
Vu = Km = $pe([
  ax(1, xs),
  ax(2, Jt),
  ax(3, he)
], Vu);
gt(
  Vu.ID,
  Vu,
  2
  /* EditorContributionInstantiation.BeforeFirstInteraction */
);
var i$ = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, jy = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
class mB {
  constructor(e, t, i) {
    this.marker = e, this.index = t, this.total = i;
  }
}
let YT = class {
  constructor(e, t, i) {
    this._markerService = t, this._configService = i, this._onDidChange = new R(), this.onDidChange = this._onDidChange.event, this._dispoables = new q(), this._markers = [], this._nextIdx = -1, Ee.isUri(e) ? this._resourceFilter = (a) => a.toString() === e.toString() : e && (this._resourceFilter = e);
    const n = this._configService.getValue("problems.sortOrder"), s = (a, l) => {
      let d = M_(a.resource.toString(), l.resource.toString());
      return d === 0 && (n === "position" ? d = L.compareRangesUsingStarts(a, l) || di.compare(a.severity, l.severity) : d = di.compare(a.severity, l.severity) || L.compareRangesUsingStarts(a, l)), d;
    }, o = () => {
      this._markers = this._markerService.read({
        resource: Ee.isUri(e) ? e : void 0,
        severities: di.Error | di.Warning | di.Info
      }), typeof e == "function" && (this._markers = this._markers.filter((a) => this._resourceFilter(a.resource))), this._markers.sort(s);
    };
    o(), this._dispoables.add(t.onMarkerChanged((a) => {
      (!this._resourceFilter || a.some((l) => this._resourceFilter(l))) && (o(), this._nextIdx = -1, this._onDidChange.fire());
    }));
  }
  dispose() {
    this._dispoables.dispose(), this._onDidChange.dispose();
  }
  matches(e) {
    return !this._resourceFilter && !e ? !0 : !this._resourceFilter || !e ? !1 : this._resourceFilter(e);
  }
  get selected() {
    const e = this._markers[this._nextIdx];
    return e && new mB(e, this._nextIdx + 1, this._markers.length);
  }
  _initIdx(e, t, i) {
    let n = !1, s = this._markers.findIndex((o) => o.resource.toString() === e.uri.toString());
    s < 0 && (s = R_(this._markers, { resource: e.uri }, (o, a) => M_(o.resource.toString(), a.resource.toString())), s < 0 && (s = ~s));
    for (let o = s; o < this._markers.length; o++) {
      let a = L.lift(this._markers[o]);
      if (a.isEmpty()) {
        const l = e.getWordAtPosition(a.getStartPosition());
        l && (a = new L(a.startLineNumber, l.startColumn, a.startLineNumber, l.endColumn));
      }
      if (t && (a.containsPosition(t) || t.isBeforeOrEqual(a.getStartPosition()))) {
        this._nextIdx = o, n = !0;
        break;
      }
      if (this._markers[o].resource.toString() !== e.uri.toString())
        break;
    }
    n || (this._nextIdx = i ? 0 : this._markers.length - 1), this._nextIdx < 0 && (this._nextIdx = this._markers.length - 1);
  }
  resetIndex() {
    this._nextIdx = -1;
  }
  move(e, t, i) {
    if (this._markers.length === 0)
      return !1;
    const n = this._nextIdx;
    return this._nextIdx === -1 ? this._initIdx(t, i, e) : e ? this._nextIdx = (this._nextIdx + 1) % this._markers.length : e || (this._nextIdx = (this._nextIdx - 1 + this._markers.length) % this._markers.length), n !== this._nextIdx;
  }
  find(e, t) {
    let i = this._markers.findIndex((n) => n.resource.toString() === e.toString());
    if (!(i < 0)) {
      for (; i < this._markers.length; i++)
        if (L.containsPosition(this._markers[i], t))
          return new mB(this._markers[i], i + 1, this._markers.length);
    }
  }
};
YT = i$([
  jy(1, fl),
  jy(2, Ge)
], YT);
const n$ = et("IMarkerNavigationService");
let QT = class {
  constructor(e, t) {
    this._markerService = e, this._configService = t, this._provider = new Ps();
  }
  getMarkerList(e) {
    for (const t of this._provider) {
      const i = t.getMarkerList(e);
      if (i)
        return i;
    }
    return new YT(e, this._markerService, this._configService);
  }
};
QT = i$([
  jy(0, fl),
  jy(1, Ge)
], QT);
ot(
  n$,
  QT,
  1
  /* InstantiationType.Delayed */
);
var XT;
(function(r) {
  function e(t) {
    switch (t) {
      case yi.Ignore:
        return "severity-ignore " + Le.asClassName(me.info);
      case yi.Info:
        return Le.asClassName(me.info);
      case yi.Warning:
        return Le.asClassName(me.warning);
      case yi.Error:
        return Le.asClassName(me.error);
      default:
        return "";
    }
  }
  r.className = e;
})(XT || (XT = {}));
var Kpe = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, xg = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, JT;
class jpe {
  constructor(e, t, i, n, s) {
    this._openerService = n, this._labelService = s, this._lines = 0, this._longestLineLength = 0, this._relatedDiagnostics = /* @__PURE__ */ new WeakMap(), this._disposables = new q(), this._editor = t;
    const o = document.createElement("div");
    o.className = "descriptioncontainer", this._messageBlock = document.createElement("div"), this._messageBlock.classList.add("message"), this._messageBlock.setAttribute("aria-live", "assertive"), this._messageBlock.setAttribute("role", "alert"), o.appendChild(this._messageBlock), this._relatedBlock = document.createElement("div"), o.appendChild(this._relatedBlock), this._disposables.add(pi(this._relatedBlock, "click", (a) => {
      a.preventDefault();
      const l = this._relatedDiagnostics.get(a.target);
      l && i(l);
    })), this._scrollable = new zV(o, {
      horizontal: 1,
      vertical: 1,
      useShadows: !1,
      horizontalScrollbarSize: 6,
      verticalScrollbarSize: 6
    }), e.appendChild(this._scrollable.getDomNode()), this._disposables.add(this._scrollable.onScroll((a) => {
      o.style.left = `-${a.scrollLeft}px`, o.style.top = `-${a.scrollTop}px`;
    })), this._disposables.add(this._scrollable);
  }
  dispose() {
    zt(this._disposables);
  }
  update(e) {
    const { source: t, message: i, relatedInformation: n, code: s } = e;
    let o = ((t == null ? void 0 : t.length) || 0) + 2;
    s && (typeof s == "string" ? o += s.length : o += s.value.length);
    const a = vd(i);
    this._lines = a.length, this._longestLineLength = 0;
    for (const u of a)
      this._longestLineLength = Math.max(u.length + o, this._longestLineLength);
    pn(this._messageBlock), this._messageBlock.setAttribute("aria-label", this.getAriaLabel(e)), this._editor.applyFontInfo(this._messageBlock);
    let l = this._messageBlock;
    for (const u of a)
      l = document.createElement("div"), l.innerText = u, u === "" && (l.style.height = this._messageBlock.style.lineHeight), this._messageBlock.appendChild(l);
    if (t || s) {
      const u = document.createElement("span");
      if (u.classList.add("details"), l.appendChild(u), t) {
        const g = document.createElement("span");
        g.innerText = t, g.classList.add("source"), u.appendChild(g);
      }
      if (s)
        if (typeof s == "string") {
          const g = document.createElement("span");
          g.innerText = `(${s})`, g.classList.add("code"), u.appendChild(g);
        } else {
          this._codeLink = X("a.code-link"), this._codeLink.setAttribute("href", `${s.target.toString()}`), this._codeLink.onclick = (f) => {
            this._openerService.open(s.target, { allowCommands: !0 }), f.preventDefault(), f.stopPropagation();
          };
          const g = G(this._codeLink, X("span"));
          g.innerText = s.value, u.appendChild(this._codeLink);
        }
    }
    if (pn(this._relatedBlock), this._editor.applyFontInfo(this._relatedBlock), Rn(n)) {
      const u = this._relatedBlock.appendChild(document.createElement("div"));
      u.style.paddingTop = `${Math.floor(this._editor.getOption(
        67
        /* EditorOption.lineHeight */
      ) * 0.66)}px`, this._lines += 1;
      for (const g of n) {
        const f = document.createElement("div"), m = document.createElement("a");
        m.classList.add("filename"), m.innerText = `${this._labelService.getUriBasenameLabel(g.resource)}(${g.startLineNumber}, ${g.startColumn}): `, m.title = this._labelService.getUriLabel(g.resource), this._relatedDiagnostics.set(m, g);
        const _ = document.createElement("span");
        _.innerText = g.message, f.appendChild(m), f.appendChild(_), this._lines += 1, u.appendChild(f);
      }
    }
    const d = this._editor.getOption(
      50
      /* EditorOption.fontInfo */
    ), c = Math.ceil(d.typicalFullwidthCharacterWidth * this._longestLineLength * 0.75), h = d.lineHeight * this._lines;
    this._scrollable.setScrollDimensions({ scrollWidth: c, scrollHeight: h });
  }
  layout(e, t) {
    this._scrollable.getDomNode().style.height = `${e}px`, this._scrollable.getDomNode().style.width = `${t}px`, this._scrollable.setScrollDimensions({ width: t, height: e });
  }
  getHeightInLines() {
    return Math.min(17, this._lines);
  }
  getAriaLabel(e) {
    let t = "";
    switch (e.severity) {
      case di.Error:
        t = p("Error", "Error");
        break;
      case di.Warning:
        t = p("Warning", "Warning");
        break;
      case di.Info:
        t = p("Info", "Info");
        break;
      case di.Hint:
        t = p("Hint", "Hint");
        break;
    }
    let i = p("marker aria", "{0} at {1}. ", t, e.startLineNumber + ":" + e.startColumn);
    const n = this._editor.getModel();
    return n && e.startLineNumber <= n.getLineCount() && e.startLineNumber >= 1 && (i = `${n.getLineContent(e.startLineNumber)}, ${i}`), i;
  }
}
let vp = JT = class extends Ay {
  constructor(e, t, i, n, s, o, a) {
    super(e, { showArrow: !0, showFrame: !0, isAccessible: !0, frameWidth: 1 }, s), this._themeService = t, this._openerService = i, this._menuService = n, this._contextKeyService = o, this._labelService = a, this._callOnDispose = new q(), this._onDidSelectRelatedInformation = new R(), this.onDidSelectRelatedInformation = this._onDidSelectRelatedInformation.event, this._severity = di.Warning, this._backgroundColor = z.white, this._applyTheme(t.getColorTheme()), this._callOnDispose.add(t.onDidColorThemeChange(this._applyTheme.bind(this))), this.create();
  }
  _applyTheme(e) {
    this._backgroundColor = e.getColor(Ype);
    let t = eN, i = qpe;
    this._severity === di.Warning ? (t = Jw, i = Gpe) : this._severity === di.Info && (t = tN, i = Zpe);
    const n = e.getColor(t), s = e.getColor(i);
    this.style({
      arrowColor: n,
      frameColor: n,
      headerBackgroundColor: s,
      primaryHeadingColor: e.getColor(g4),
      secondaryHeadingColor: e.getColor(f4)
    });
  }
  _applyStyles() {
    this._parentContainer && (this._parentContainer.style.backgroundColor = this._backgroundColor ? this._backgroundColor.toString() : ""), super._applyStyles();
  }
  dispose() {
    this._callOnDispose.dispose(), super.dispose();
  }
  _fillHead(e) {
    super._fillHead(e), this._disposables.add(this._actionbarWidget.actionRunner.onWillRun((n) => this.editor.focus()));
    const t = [], i = this._menuService.createMenu(JT.TitleMenu, this._contextKeyService);
    eL(i, void 0, t), this._actionbarWidget.push(t, { label: !1, icon: !0, index: 0 }), i.dispose();
  }
  _fillTitleIcon(e) {
    this._icon = G(e, X(""));
  }
  _fillBody(e) {
    this._parentContainer = e, e.classList.add("marker-widget"), this._parentContainer.tabIndex = 0, this._parentContainer.setAttribute("role", "tooltip"), this._container = document.createElement("div"), e.appendChild(this._container), this._message = new jpe(this._container, this.editor, (t) => this._onDidSelectRelatedInformation.fire(t), this._openerService, this._labelService), this._disposables.add(this._message);
  }
  show() {
    throw new Error("call showAtMarker");
  }
  showAtMarker(e, t, i) {
    this._container.classList.remove("stale"), this._message.update(e), this._severity = e.severity, this._applyTheme(this._themeService.getColorTheme());
    const n = L.lift(e), s = this.editor.getPosition(), o = s && n.containsPosition(s) ? s : n.getStartPosition();
    super.show(o, this.computeRequiredHeight());
    const a = this.editor.getModel();
    if (a) {
      const l = i > 1 ? p("problems", "{0} of {1} problems", t, i) : p("change", "{0} of {1} problem", t, i);
      this.setTitle(Fo(a.uri), l);
    }
    this._icon.className = `codicon ${XT.className(di.toSeverity(this._severity))}`, this.editor.revealPositionNearTop(
      o,
      0
      /* ScrollType.Smooth */
    ), this.editor.focus();
  }
  updateMarker(e) {
    this._container.classList.remove("stale"), this._message.update(e);
  }
  showStale() {
    this._container.classList.add("stale"), this._relayout();
  }
  _doLayoutBody(e, t) {
    super._doLayoutBody(e, t), this._heightInPixel = e, this._message.layout(e, t), this._container.style.height = `${e}px`;
  }
  _onWidth(e) {
    this._message.layout(this._heightInPixel, e);
  }
  _relayout() {
    super._relayout(this.computeRequiredHeight());
  }
  computeRequiredHeight() {
    return 3 + this._message.getHeightInLines();
  }
};
vp.TitleMenu = new D("gotoErrorTitleMenu");
vp = JT = Kpe([
  xg(1, $i),
  xg(2, Ys),
  xg(3, vo),
  xg(4, be),
  xg(5, De),
  xg(6, tp)
], vp);
const _B = z_(Va, wG), vB = z_(Kn, U_), bB = z_(ws, $_), eN = I("editorMarkerNavigationError.background", { dark: _B, light: _B, hcDark: it, hcLight: it }, p("editorMarkerNavigationError", "Editor marker navigation widget error color.")), qpe = I("editorMarkerNavigationError.headerBackground", { dark: ve(eN, 0.1), light: ve(eN, 0.1), hcDark: null, hcLight: null }, p("editorMarkerNavigationErrorHeaderBackground", "Editor marker navigation widget error heading background.")), Jw = I("editorMarkerNavigationWarning.background", { dark: vB, light: vB, hcDark: it, hcLight: it }, p("editorMarkerNavigationWarning", "Editor marker navigation widget warning color.")), Gpe = I("editorMarkerNavigationWarning.headerBackground", { dark: ve(Jw, 0.1), light: ve(Jw, 0.1), hcDark: "#0C141F", hcLight: ve(Jw, 0.2) }, p("editorMarkerNavigationWarningBackground", "Editor marker navigation widget warning heading background.")), tN = I("editorMarkerNavigationInfo.background", { dark: bB, light: bB, hcDark: it, hcLight: it }, p("editorMarkerNavigationInfo", "Editor marker navigation widget info color.")), Zpe = I("editorMarkerNavigationInfo.headerBackground", { dark: ve(tN, 0.1), light: ve(tN, 0.1), hcDark: null, hcLight: null }, p("editorMarkerNavigationInfoHeaderBackground", "Editor marker navigation widget info heading background.")), Ype = I("editorMarkerNavigation.background", { dark: Gi, light: Gi, hcDark: Gi, hcLight: Gi }, p("editorMarkerNavigationBackground", "Editor marker navigation widget background."));
var Qpe = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, fw = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, jm;
let Qc = jm = class {
  static get(e) {
    return e.getContribution(jm.ID);
  }
  constructor(e, t, i, n, s) {
    this._markerNavigationService = t, this._contextKeyService = i, this._editorService = n, this._instantiationService = s, this._sessionDispoables = new q(), this._editor = e, this._widgetVisible = s$.bindTo(this._contextKeyService);
  }
  dispose() {
    this._cleanUp(), this._sessionDispoables.dispose();
  }
  _cleanUp() {
    this._widgetVisible.reset(), this._sessionDispoables.clear(), this._widget = void 0, this._model = void 0;
  }
  _getOrCreateModel(e) {
    if (this._model && this._model.matches(e))
      return this._model;
    let t = !1;
    return this._model && (t = !0, this._cleanUp()), this._model = this._markerNavigationService.getMarkerList(e), t && this._model.move(!0, this._editor.getModel(), this._editor.getPosition()), this._widget = this._instantiationService.createInstance(vp, this._editor), this._widget.onDidClose(() => this.close(), this, this._sessionDispoables), this._widgetVisible.set(!0), this._sessionDispoables.add(this._model), this._sessionDispoables.add(this._widget), this._sessionDispoables.add(this._editor.onDidChangeCursorPosition((i) => {
      var n, s, o;
      (!(!((n = this._model) === null || n === void 0) && n.selected) || !L.containsPosition((s = this._model) === null || s === void 0 ? void 0 : s.selected.marker, i.position)) && ((o = this._model) === null || o === void 0 || o.resetIndex());
    })), this._sessionDispoables.add(this._model.onDidChange(() => {
      if (!this._widget || !this._widget.position || !this._model)
        return;
      const i = this._model.find(this._editor.getModel().uri, this._widget.position);
      i ? this._widget.updateMarker(i.marker) : this._widget.showStale();
    })), this._sessionDispoables.add(this._widget.onDidSelectRelatedInformation((i) => {
      this._editorService.openCodeEditor({
        resource: i.resource,
        options: { pinned: !0, revealIfOpened: !0, selection: L.lift(i).collapseToStart() }
      }, this._editor), this.close(!1);
    })), this._sessionDispoables.add(this._editor.onDidChangeModel(() => this._cleanUp())), this._model;
  }
  close(e = !0) {
    this._cleanUp(), e && this._editor.focus();
  }
  showAtMarker(e) {
    if (this._editor.hasModel()) {
      const t = this._getOrCreateModel(this._editor.getModel().uri);
      t.resetIndex(), t.move(!0, this._editor.getModel(), new A(e.startLineNumber, e.startColumn)), t.selected && this._widget.showAtMarker(t.selected.marker, t.selected.index, t.selected.total);
    }
  }
  async nagivate(e, t) {
    var i, n;
    if (this._editor.hasModel()) {
      const s = this._getOrCreateModel(t ? void 0 : this._editor.getModel().uri);
      if (s.move(e, this._editor.getModel(), this._editor.getPosition()), !s.selected)
        return;
      if (s.selected.marker.resource.toString() !== this._editor.getModel().uri.toString()) {
        this._cleanUp();
        const o = await this._editorService.openCodeEditor({
          resource: s.selected.marker.resource,
          options: { pinned: !1, revealIfOpened: !0, selectionRevealType: 2, selection: s.selected.marker }
        }, this._editor);
        o && ((i = jm.get(o)) === null || i === void 0 || i.close(), (n = jm.get(o)) === null || n === void 0 || n.nagivate(e, t));
      } else
        this._widget.showAtMarker(s.selected.marker, s.selected.index, s.selected.total);
    }
  }
};
Qc.ID = "editor.contrib.markerController";
Qc = jm = Qpe([
  fw(1, n$),
  fw(2, De),
  fw(3, ht),
  fw(4, be)
], Qc);
class YL extends ae {
  constructor(e, t, i) {
    super(i), this._next = e, this._multiFile = t;
  }
  async run(e, t) {
    var i;
    t.hasModel() && ((i = Qc.get(t)) === null || i === void 0 || i.nagivate(this._next, this._multiFile));
  }
}
class yc extends YL {
  constructor() {
    super(!0, !1, {
      id: yc.ID,
      label: yc.LABEL,
      alias: "Go to Next Problem (Error, Warning, Info)",
      precondition: void 0,
      kbOpts: {
        kbExpr: x.focus,
        primary: 578,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: vp.TitleMenu,
        title: yc.LABEL,
        icon: hi("marker-navigation-next", me.arrowDown, p("nextMarkerIcon", "Icon for goto next marker.")),
        group: "navigation",
        order: 1
      }
    });
  }
}
yc.ID = "editor.action.marker.next";
yc.LABEL = p("markerAction.next.label", "Go to Next Problem (Error, Warning, Info)");
class _u extends YL {
  constructor() {
    super(!1, !1, {
      id: _u.ID,
      label: _u.LABEL,
      alias: "Go to Previous Problem (Error, Warning, Info)",
      precondition: void 0,
      kbOpts: {
        kbExpr: x.focus,
        primary: 1602,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: vp.TitleMenu,
        title: _u.LABEL,
        icon: hi("marker-navigation-previous", me.arrowUp, p("previousMarkerIcon", "Icon for goto previous marker.")),
        group: "navigation",
        order: 2
      }
    });
  }
}
_u.ID = "editor.action.marker.prev";
_u.LABEL = p("markerAction.previous.label", "Go to Previous Problem (Error, Warning, Info)");
class Xpe extends YL {
  constructor() {
    super(!0, !0, {
      id: "editor.action.marker.nextInFiles",
      label: p("markerAction.nextInFiles.label", "Go to Next Problem in Files (Error, Warning, Info)"),
      alias: "Go to Next Problem in Files (Error, Warning, Info)",
      precondition: void 0,
      kbOpts: {
        kbExpr: x.focus,
        primary: 66,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: D.MenubarGoMenu,
        title: p({ key: "miGotoNextProblem", comment: ["&& denotes a mnemonic"] }, "Next &&Problem"),
        group: "6_problem_nav",
        order: 1
      }
    });
  }
}
class Jpe extends YL {
  constructor() {
    super(!1, !0, {
      id: "editor.action.marker.prevInFiles",
      label: p("markerAction.previousInFiles.label", "Go to Previous Problem in Files (Error, Warning, Info)"),
      alias: "Go to Previous Problem in Files (Error, Warning, Info)",
      precondition: void 0,
      kbOpts: {
        kbExpr: x.focus,
        primary: 1090,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: D.MenubarGoMenu,
        title: p({ key: "miGotoPreviousProblem", comment: ["&& denotes a mnemonic"] }, "Previous &&Problem"),
        group: "6_problem_nav",
        order: 2
      }
    });
  }
}
gt(
  Qc.ID,
  Qc,
  4
  /* EditorContributionInstantiation.Lazy */
);
Y(yc);
Y(_u);
Y(Xpe);
Y(Jpe);
const s$ = new oe("markersNavigationVisible", !1), eme = Ui.bindToContribution(Qc.get);
se(new eme({
  id: "closeMarkersNavigation",
  precondition: s$,
  handler: (r) => r.close(),
  kbOpts: {
    weight: 150,
    kbExpr: x.focus,
    primary: 9,
    secondary: [
      1033
      /* KeyCode.Escape */
    ]
  }
}));
var xr;
(function(r) {
  r.NoAutoFocus = "noAutoFocus", r.FocusIfVisible = "focusIfVisible", r.AutoFocusImmediately = "autoFocusImmediately";
})(xr || (xr = {}));
class tme extends ae {
  constructor() {
    super({
      id: i4,
      label: p({
        key: "showOrFocusHover",
        comment: [
          "Label for action that will trigger the showing/focusing of a hover in the editor.",
          "If the hover is not visible, it will show the hover.",
          "This allows for users to show the hover without using the mouse."
        ]
      }, "Show or Focus Hover"),
      metadata: {
        description: Me("showOrFocusHoverDescription", "Show or focus the editor hover which shows documentation, references, and other content for a symbol at the current cursor position."),
        args: [{
          name: "args",
          schema: {
            type: "object",
            properties: {
              focus: {
                description: "Controls if and when the hover should take focus upon being triggered by this action.",
                enum: [xr.NoAutoFocus, xr.FocusIfVisible, xr.AutoFocusImmediately],
                enumDescriptions: [
                  p("showOrFocusHover.focus.noAutoFocus", "The hover will not automatically take focus."),
                  p("showOrFocusHover.focus.focusIfVisible", "The hover will take focus only if it is already visible."),
                  p("showOrFocusHover.focus.autoFocusImmediately", "The hover will automatically take focus when it appears.")
                ],
                default: xr.FocusIfVisible
              }
            }
          }
        }]
      },
      alias: "Show or Focus Hover",
      precondition: void 0,
      kbOpts: {
        kbExpr: x.editorTextFocus,
        primary: zi(
          2089,
          2087
          /* KeyCode.KeyI */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(e, t, i) {
    if (!t.hasModel())
      return;
    const n = jn.get(t);
    if (!n)
      return;
    const s = i == null ? void 0 : i.focus;
    let o = xr.FocusIfVisible;
    Object.values(xr).includes(s) ? o = s : typeof s == "boolean" && s && (o = xr.AutoFocusImmediately);
    const a = (d) => {
      const c = t.getPosition(), h = new L(c.lineNumber, c.column, c.lineNumber, c.column);
      n.showContentHover(h, 1, 1, d);
    }, l = t.getOption(
      2
      /* EditorOption.accessibilitySupport */
    ) === 2;
    n.isHoverVisible ? o !== xr.NoAutoFocus ? n.focus() : a(l) : a(l || o === xr.AutoFocusImmediately);
  }
}
class ime extends ae {
  constructor() {
    super({
      id: _he,
      label: p({
        key: "showDefinitionPreviewHover",
        comment: [
          "Label for action that will trigger the showing of definition preview hover in the editor.",
          "This allows for users to show the definition preview hover without using the mouse."
        ]
      }, "Show Definition Preview Hover"),
      alias: "Show Definition Preview Hover",
      precondition: void 0,
      metadata: {
        description: Me("showDefinitionPreviewHoverDescription", "Show the definition preview hover in the editor.")
      }
    });
  }
  run(e, t) {
    const i = jn.get(t);
    if (!i)
      return;
    const n = t.getPosition();
    if (!n)
      return;
    const s = new L(n.lineNumber, n.column, n.lineNumber, n.column), o = Vu.get(t);
    if (!o)
      return;
    o.startFindDefinitionFromCursor(n).then(() => {
      i.showContentHover(s, 1, 1, !0);
    });
  }
}
class nme extends ae {
  constructor() {
    super({
      id: vhe,
      label: p({
        key: "scrollUpHover",
        comment: [
          "Action that allows to scroll up in the hover widget with the up arrow when the hover widget is focused."
        ]
      }, "Scroll Up Hover"),
      alias: "Scroll Up Hover",
      precondition: x.hoverFocused,
      kbOpts: {
        kbExpr: x.hoverFocused,
        primary: 16,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      metadata: {
        description: Me("scrollUpHoverDescription", "Scroll up the editor hover.")
      }
    });
  }
  run(e, t) {
    const i = jn.get(t);
    i && i.scrollUp();
  }
}
class sme extends ae {
  constructor() {
    super({
      id: bhe,
      label: p({
        key: "scrollDownHover",
        comment: [
          "Action that allows to scroll down in the hover widget with the up arrow when the hover widget is focused."
        ]
      }, "Scroll Down Hover"),
      alias: "Scroll Down Hover",
      precondition: x.hoverFocused,
      kbOpts: {
        kbExpr: x.hoverFocused,
        primary: 18,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      metadata: {
        description: Me("scrollDownHoverDescription", "Scroll down the editor hover.")
      }
    });
  }
  run(e, t) {
    const i = jn.get(t);
    i && i.scrollDown();
  }
}
class ome extends ae {
  constructor() {
    super({
      id: Che,
      label: p({
        key: "scrollLeftHover",
        comment: [
          "Action that allows to scroll left in the hover widget with the left arrow when the hover widget is focused."
        ]
      }, "Scroll Left Hover"),
      alias: "Scroll Left Hover",
      precondition: x.hoverFocused,
      kbOpts: {
        kbExpr: x.hoverFocused,
        primary: 15,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      metadata: {
        description: Me("scrollLeftHoverDescription", "Scroll left the editor hover.")
      }
    });
  }
  run(e, t) {
    const i = jn.get(t);
    i && i.scrollLeft();
  }
}
class rme extends ae {
  constructor() {
    super({
      id: whe,
      label: p({
        key: "scrollRightHover",
        comment: [
          "Action that allows to scroll right in the hover widget with the right arrow when the hover widget is focused."
        ]
      }, "Scroll Right Hover"),
      alias: "Scroll Right Hover",
      precondition: x.hoverFocused,
      kbOpts: {
        kbExpr: x.hoverFocused,
        primary: 17,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      metadata: {
        description: Me("scrollRightHoverDescription", "Scroll right the editor hover.")
      }
    });
  }
  run(e, t) {
    const i = jn.get(t);
    i && i.scrollRight();
  }
}
class ame extends ae {
  constructor() {
    super({
      id: She,
      label: p({
        key: "pageUpHover",
        comment: [
          "Action that allows to page up in the hover widget with the page up command when the hover widget is focused."
        ]
      }, "Page Up Hover"),
      alias: "Page Up Hover",
      precondition: x.hoverFocused,
      kbOpts: {
        kbExpr: x.hoverFocused,
        primary: 11,
        secondary: [
          528
          /* KeyCode.UpArrow */
        ],
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      metadata: {
        description: Me("pageUpHoverDescription", "Page up the editor hover.")
      }
    });
  }
  run(e, t) {
    const i = jn.get(t);
    i && i.pageUp();
  }
}
class lme extends ae {
  constructor() {
    super({
      id: yhe,
      label: p({
        key: "pageDownHover",
        comment: [
          "Action that allows to page down in the hover widget with the page down command when the hover widget is focused."
        ]
      }, "Page Down Hover"),
      alias: "Page Down Hover",
      precondition: x.hoverFocused,
      kbOpts: {
        kbExpr: x.hoverFocused,
        primary: 12,
        secondary: [
          530
          /* KeyCode.DownArrow */
        ],
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      metadata: {
        description: Me("pageDownHoverDescription", "Page down the editor hover.")
      }
    });
  }
  run(e, t) {
    const i = jn.get(t);
    i && i.pageDown();
  }
}
class dme extends ae {
  constructor() {
    super({
      id: Lhe,
      label: p({
        key: "goToTopHover",
        comment: [
          "Action that allows to go to the top of the hover widget with the home command when the hover widget is focused."
        ]
      }, "Go To Top Hover"),
      alias: "Go To Bottom Hover",
      precondition: x.hoverFocused,
      kbOpts: {
        kbExpr: x.hoverFocused,
        primary: 14,
        secondary: [
          2064
          /* KeyCode.UpArrow */
        ],
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      metadata: {
        description: Me("goToTopHoverDescription", "Go to the top of the editor hover.")
      }
    });
  }
  run(e, t) {
    const i = jn.get(t);
    i && i.goToTop();
  }
}
class cme extends ae {
  constructor() {
    super({
      id: Dhe,
      label: p({
        key: "goToBottomHover",
        comment: [
          "Action that allows to go to the bottom in the hover widget with the end command when the hover widget is focused."
        ]
      }, "Go To Bottom Hover"),
      alias: "Go To Bottom Hover",
      precondition: x.hoverFocused,
      kbOpts: {
        kbExpr: x.hoverFocused,
        primary: 13,
        secondary: [
          2066
          /* KeyCode.DownArrow */
        ],
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      metadata: {
        description: Me("goToBottomHoverDescription", "Go to the bottom of the editor hover.")
      }
    });
  }
  run(e, t) {
    const i = jn.get(t);
    i && i.goToBottom();
  }
}
class hme extends ae {
  constructor() {
    super({
      id: DL,
      label: khe,
      alias: "Increase Hover Verbosity Level",
      precondition: x.hoverVisible
    });
  }
  run(e, t, i) {
    var n;
    (n = jn.get(t)) === null || n === void 0 || n.updateMarkdownHoverVerbosityLevel(nr.Increase, i == null ? void 0 : i.index, i == null ? void 0 : i.focus);
  }
}
class ume extends ae {
  constructor() {
    super({
      id: kL,
      label: xhe,
      alias: "Decrease Hover Verbosity Level",
      precondition: x.hoverVisible
    });
  }
  run(e, t, i) {
    var n;
    (n = jn.get(t)) === null || n === void 0 || n.updateMarkdownHoverVerbosityLevel(nr.Decrease, i == null ? void 0 : i.index, i == null ? void 0 : i.focus);
  }
}
var gme = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, lx = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
const Yo = X;
class fme {
  constructor(e, t, i) {
    this.owner = e, this.range = t, this.marker = i;
  }
  isValidForHoverAnchor(e) {
    return e.type === 1 && this.range.startColumn <= e.range.startColumn && this.range.endColumn >= e.range.endColumn;
  }
}
const CB = {
  type: 1,
  filter: { include: qt.QuickFix },
  triggerAction: $s.QuickFixHover
};
let iN = class {
  constructor(e, t, i, n) {
    this._editor = e, this._markerDecorationsService = t, this._openerService = i, this._languageFeaturesService = n, this.hoverOrdinal = 1, this.recentMarkerCodeActionsInfo = void 0;
  }
  computeSync(e, t) {
    if (!this._editor.hasModel() || e.type !== 1 && !e.supportsMarkerHover)
      return [];
    const i = this._editor.getModel(), n = e.range.startLineNumber, s = i.getLineMaxColumn(n), o = [];
    for (const a of t) {
      const l = a.range.startLineNumber === n ? a.range.startColumn : 1, d = a.range.endLineNumber === n ? a.range.endColumn : s, c = this._markerDecorationsService.getMarker(i.uri, a);
      if (!c)
        continue;
      const h = new L(e.range.startLineNumber, l, e.range.startLineNumber, d);
      o.push(new fme(this, h, c));
    }
    return o;
  }
  renderHoverParts(e, t) {
    if (!t.length)
      return P.None;
    const i = new q();
    t.forEach((s) => e.fragment.appendChild(this.renderMarkerHover(s, i)));
    const n = t.length === 1 ? t[0] : t.sort((s, o) => di.compare(s.marker.severity, o.marker.severity))[0];
    return this.renderMarkerStatusbar(e, n, i), i;
  }
  renderMarkerHover(e, t) {
    const i = Yo("div.hover-row");
    i.tabIndex = 0;
    const n = G(i, Yo("div.marker.hover-contents")), { source: s, message: o, code: a, relatedInformation: l } = e.marker;
    this._editor.applyFontInfo(n);
    const d = G(n, Yo("span"));
    if (d.style.whiteSpace = "pre-wrap", d.innerText = o, s || a)
      if (a && typeof a != "string") {
        const c = Yo("span");
        if (s) {
          const f = G(c, Yo("span"));
          f.innerText = s;
        }
        const h = G(c, Yo("a.code-link"));
        h.setAttribute("href", a.target.toString()), t.add(W(h, "click", (f) => {
          this._openerService.open(a.target, { allowCommands: !0 }), f.preventDefault(), f.stopPropagation();
        }));
        const u = G(h, Yo("span"));
        u.innerText = a.value;
        const g = G(n, c);
        g.style.opacity = "0.6", g.style.paddingLeft = "6px";
      } else {
        const c = G(n, Yo("span"));
        c.style.opacity = "0.6", c.style.paddingLeft = "6px", c.innerText = s && a ? `${s}(${a})` : s || `(${a})`;
      }
    if (Rn(l))
      for (const { message: c, resource: h, startLineNumber: u, startColumn: g } of l) {
        const f = G(n, Yo("div"));
        f.style.marginTop = "8px";
        const m = G(f, Yo("a"));
        m.innerText = `${Fo(h)}(${u}, ${g}): `, m.style.cursor = "pointer", t.add(W(m, "click", (v) => {
          v.stopPropagation(), v.preventDefault(), this._openerService && this._openerService.open(h, {
            fromUserGesture: !0,
            editorOptions: { selection: { startLineNumber: u, startColumn: g } }
          }).catch(He);
        }));
        const _ = G(f, Yo("span"));
        _.innerText = c, this._editor.applyFontInfo(_);
      }
    return i;
  }
  renderMarkerStatusbar(e, t, i) {
    if (t.marker.severity === di.Error || t.marker.severity === di.Warning || t.marker.severity === di.Info) {
      const n = Qc.get(this._editor);
      n && e.statusBar.addAction({
        label: p("view problem", "View Problem"),
        commandId: yc.ID,
        run: () => {
          e.hide(), n.showAtMarker(t.marker), this._editor.focus();
        }
      });
    }
    if (!this._editor.getOption(
      91
      /* EditorOption.readOnly */
    )) {
      const n = e.statusBar.append(Yo("div"));
      this.recentMarkerCodeActionsInfo && (JS.makeKey(this.recentMarkerCodeActionsInfo.marker) === JS.makeKey(t.marker) ? this.recentMarkerCodeActionsInfo.hasCodeActions || (n.textContent = p("noQuickFixes", "No quick fixes available")) : this.recentMarkerCodeActionsInfo = void 0);
      const s = this.recentMarkerCodeActionsInfo && !this.recentMarkerCodeActionsInfo.hasCodeActions ? P.None : Mc(() => n.textContent = p("checkingForQuickFixes", "Checking for quick fixes..."), 200, i);
      n.textContent || (n.textContent = "");
      const o = this.getCodeActions(t.marker);
      i.add(Se(() => o.cancel())), o.then((a) => {
        if (s.dispose(), this.recentMarkerCodeActionsInfo = { marker: t.marker, hasCodeActions: a.validActions.length > 0 }, !this.recentMarkerCodeActionsInfo.hasCodeActions) {
          a.dispose(), n.textContent = p("noQuickFixes", "No quick fixes available");
          return;
        }
        n.style.display = "none";
        let l = !1;
        i.add(Se(() => {
          l || a.dispose();
        })), e.statusBar.addAction({
          label: p("quick fixes", "Quick Fix..."),
          commandId: aR,
          run: (d) => {
            l = !0;
            const c = Uc.get(this._editor), h = Ei(d);
            e.hide(), c == null || c.showCodeActions(CB, a, {
              x: h.left,
              y: h.top,
              width: h.width,
              height: h.height
            });
          }
        });
      }, He);
    }
  }
  getCodeActions(e) {
    return Zi((t) => S_(this._languageFeaturesService.codeActionProvider, this._editor.getModel(), new L(e.startLineNumber, e.startColumn, e.endLineNumber, e.endColumn), CB, id.None, t));
  }
};
iN = gme([
  lx(1, _1),
  lx(2, Ys),
  lx(3, he)
], iN);
var wB;
(function(r) {
  r.intro = p("intro", "Focus on the hover widget to cycle through the hover parts with the Tab key."), r.increaseVerbosity = p("increaseVerbosity", "- The focused hover part verbosity level can be increased with the Increase Hover Verbosity command<keybinding:{0}>.", DL), r.decreaseVerbosity = p("decreaseVerbosity", "- The focused hover part verbosity level can be decreased with the Decrease Hover Verbosity command<keybinding:{0}>.", kL), r.hoverContent = p("contentHover", "The last focused hover content is the following.");
})(wB || (wB = {}));
class pme {
  dispose() {
    var e;
    (e = this._provider) === null || e === void 0 || e.dispose();
  }
}
class mme {
  dispose() {
    var e;
    (e = this._provider) === null || e === void 0 || e.dispose();
  }
}
class _me {
  dispose() {
  }
}
gt(
  jn.ID,
  jn,
  2
  /* EditorContributionInstantiation.BeforeFirstInteraction */
);
Y(tme);
Y(ime);
Y(nme);
Y(sme);
Y(ome);
Y(rme);
Y(ame);
Y(lme);
Y(dme);
Y(cme);
Y(hme);
Y(ume);
ah.register(Mv);
ah.register(iN);
Ho((r, e) => {
  const t = r.getColor(EV);
  t && (e.addRule(`.monaco-editor .monaco-hover .hover-row:not(:first-child):not(:empty) { border-top: 1px solid ${t.transparent(0.5)}; }`), e.addRule(`.monaco-editor .monaco-hover hr { border-top: 1px solid ${t.transparent(0.5)}; }`), e.addRule(`.monaco-editor .monaco-hover hr { border-bottom: 0px solid ${t.transparent(0.5)}; }`));
});
ZL.register(new pme());
ZL.register(new mme());
ZL.register(new _me());
function Ns(r, e) {
  let t = 0;
  for (let i = 0; i < r.length; i++)
    r.charAt(i) === "	" ? t += e : t++;
  return t;
}
function k_(r, e, t) {
  r = r < 0 ? 0 : r;
  let i = "";
  if (!t) {
    const n = Math.floor(r / e);
    r = r % e;
    for (let s = 0; s < n; s++)
      i += "	";
  }
  for (let n = 0; n < r; n++)
    i += " ";
  return i;
}
function o$(r, e, t, i) {
  if (r.getLineCount() === 1 && r.getLineMaxColumn(1) === 1)
    return [];
  const n = e.getLanguageConfiguration(r.getLanguageId()).indentRulesSupport;
  if (!n)
    return [];
  const s = new T1(r, n, e);
  for (i = Math.min(i, r.getLineCount()); t <= i && s.shouldIgnore(t); )
    t++;
  if (t > i - 1)
    return [];
  const { tabSize: o, indentSize: a, insertSpaces: l } = r.getOptions(), d = (m, _) => (_ = _ || 1, Eo.shiftIndent(m, m.length + _, o, a, l)), c = (m, _) => (_ = _ || 1, Eo.unshiftIndent(m, m.length + _, o, a, l)), h = [], u = r.getLineContent(t);
  let g = Tt(u), f = g;
  s.shouldIncrease(t) ? (f = d(f), g = d(g)) : s.shouldIndentNextLine(t) && (f = d(f)), t++;
  for (let m = t; m <= i; m++) {
    if (vme(r, m))
      continue;
    const _ = r.getLineContent(m), v = Tt(_), b = f;
    s.shouldDecrease(m, b) && (f = c(f), g = c(g)), v !== f && h.push(ti.replaceMove(new ge(m, 1, m, v.length + 1), I1(f, a, l))), !s.shouldIgnore(m) && (s.shouldIncrease(m, b) ? (g = d(g), f = g) : s.shouldIndentNextLine(m, b) ? f = d(f) : f = g);
  }
  return h;
}
function vme(r, e) {
  return r.tokenization.isCheapToTokenize(e) ? r.tokenization.getLineTokens(e).getStandardTokenType(0) === 2 : !1;
}
var bme = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Cme = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
class QL extends ae {
  constructor() {
    super({
      id: QL.ID,
      label: p("indentationToSpaces", "Convert Indentation to Spaces"),
      alias: "Convert Indentation to Spaces",
      precondition: x.writable,
      metadata: {
        description: Me("indentationToSpacesDescription", "Convert the tab indentation to spaces.")
      }
    });
  }
  run(e, t) {
    const i = t.getModel();
    if (!i)
      return;
    const n = i.getOptions(), s = t.getSelection();
    if (!s)
      return;
    const o = new Dme(s, n.tabSize);
    t.pushUndoStop(), t.executeCommands(this.id, [o]), t.pushUndoStop(), i.updateOptions({
      insertSpaces: !0
    });
  }
}
QL.ID = "editor.action.indentationToSpaces";
class XL extends ae {
  constructor() {
    super({
      id: XL.ID,
      label: p("indentationToTabs", "Convert Indentation to Tabs"),
      alias: "Convert Indentation to Tabs",
      precondition: x.writable,
      metadata: {
        description: Me("indentationToTabsDescription", "Convert the spaces indentation to tabs.")
      }
    });
  }
  run(e, t) {
    const i = t.getModel();
    if (!i)
      return;
    const n = i.getOptions(), s = t.getSelection();
    if (!s)
      return;
    const o = new kme(s, n.tabSize);
    t.pushUndoStop(), t.executeCommands(this.id, [o]), t.pushUndoStop(), i.updateOptions({
      insertSpaces: !1
    });
  }
}
XL.ID = "editor.action.indentationToTabs";
class MR extends ae {
  constructor(e, t, i) {
    super(i), this.insertSpaces = e, this.displaySizeOnly = t;
  }
  run(e, t) {
    const i = e.get($o), n = e.get(ii), s = t.getModel();
    if (!s)
      return;
    const o = n.getCreationOptions(s.getLanguageId(), s.uri, s.isForSimpleWidget), a = s.getOptions(), l = [1, 2, 3, 4, 5, 6, 7, 8].map((c) => ({
      id: c.toString(),
      label: c.toString(),
      // add description for tabSize value set in the configuration
      description: c === o.tabSize && c === a.tabSize ? p("configuredTabSize", "Configured Tab Size") : c === o.tabSize ? p("defaultTabSize", "Default Tab Size") : c === a.tabSize ? p("currentTabSize", "Current Tab Size") : void 0
    })), d = Math.min(s.getOptions().tabSize - 1, 7);
    setTimeout(
      () => {
        i.pick(l, { placeHolder: p({ key: "selectTabWidth", comment: ["Tab corresponds to the tab key"] }, "Select Tab Size for Current File"), activeItem: l[d] }).then((c) => {
          if (c && s && !s.isDisposed()) {
            const h = parseInt(c.label, 10);
            this.displaySizeOnly ? s.updateOptions({
              tabSize: h
            }) : s.updateOptions({
              tabSize: h,
              indentSize: h,
              insertSpaces: this.insertSpaces
            });
          }
        });
      },
      50
      /* quick input is sensitive to being opened so soon after another */
    );
  }
}
class JL extends MR {
  constructor() {
    super(!1, !1, {
      id: JL.ID,
      label: p("indentUsingTabs", "Indent Using Tabs"),
      alias: "Indent Using Tabs",
      precondition: void 0,
      metadata: {
        description: Me("indentUsingTabsDescription", "Use indentation with tabs.")
      }
    });
  }
}
JL.ID = "editor.action.indentUsingTabs";
class eD extends MR {
  constructor() {
    super(!0, !1, {
      id: eD.ID,
      label: p("indentUsingSpaces", "Indent Using Spaces"),
      alias: "Indent Using Spaces",
      precondition: void 0,
      metadata: {
        description: Me("indentUsingSpacesDescription", "Use indentation with spaces.")
      }
    });
  }
}
eD.ID = "editor.action.indentUsingSpaces";
class tD extends MR {
  constructor() {
    super(!0, !0, {
      id: tD.ID,
      label: p("changeTabDisplaySize", "Change Tab Display Size"),
      alias: "Change Tab Display Size",
      precondition: void 0,
      metadata: {
        description: Me("changeTabDisplaySizeDescription", "Change the space size equivalent of the tab.")
      }
    });
  }
}
tD.ID = "editor.action.changeTabDisplaySize";
class iD extends ae {
  constructor() {
    super({
      id: iD.ID,
      label: p("detectIndentation", "Detect Indentation from Content"),
      alias: "Detect Indentation from Content",
      precondition: void 0,
      metadata: {
        description: Me("detectIndentationDescription", "Detect the indentation from content.")
      }
    });
  }
  run(e, t) {
    const i = e.get(ii), n = t.getModel();
    if (!n)
      return;
    const s = i.getCreationOptions(n.getLanguageId(), n.uri, n.isForSimpleWidget);
    n.detectIndentation(s.insertSpaces, s.tabSize);
  }
}
iD.ID = "editor.action.detectIndentation";
class wme extends ae {
  constructor() {
    super({
      id: "editor.action.reindentlines",
      label: p("editor.reindentlines", "Reindent Lines"),
      alias: "Reindent Lines",
      precondition: x.writable,
      metadata: {
        description: Me("editor.reindentlinesDescription", "Reindent the lines of the editor.")
      }
    });
  }
  run(e, t) {
    const i = e.get(Ot), n = t.getModel();
    if (!n)
      return;
    const s = o$(n, i, 1, n.getLineCount());
    s.length > 0 && (t.pushUndoStop(), t.executeEdits(this.id, s), t.pushUndoStop());
  }
}
class Sme extends ae {
  constructor() {
    super({
      id: "editor.action.reindentselectedlines",
      label: p("editor.reindentselectedlines", "Reindent Selected Lines"),
      alias: "Reindent Selected Lines",
      precondition: x.writable,
      metadata: {
        description: Me("editor.reindentselectedlinesDescription", "Reindent the selected lines of the editor.")
      }
    });
  }
  run(e, t) {
    const i = e.get(Ot), n = t.getModel();
    if (!n)
      return;
    const s = t.getSelections();
    if (s === null)
      return;
    const o = [];
    for (const a of s) {
      let l = a.startLineNumber, d = a.endLineNumber;
      if (l !== d && a.endColumn === 1 && d--, l === 1) {
        if (l === d)
          continue;
      } else
        l--;
      const c = o$(n, i, l, d);
      o.push(...c);
    }
    o.length > 0 && (t.pushUndoStop(), t.executeEdits(this.id, o), t.pushUndoStop());
  }
}
class yme {
  constructor(e, t) {
    this._initialSelection = t, this._edits = [], this._selectionId = null;
    for (const i of e)
      i.range && typeof i.text == "string" && this._edits.push(i);
  }
  getEditOperations(e, t) {
    for (const n of this._edits)
      t.addEditOperation(L.lift(n.range), n.text);
    let i = !1;
    Array.isArray(this._edits) && this._edits.length === 1 && this._initialSelection.isEmpty() && (this._edits[0].range.startColumn === this._initialSelection.endColumn && this._edits[0].range.startLineNumber === this._initialSelection.endLineNumber ? (i = !0, this._selectionId = t.trackSelection(this._initialSelection, !0)) : this._edits[0].range.endColumn === this._initialSelection.startColumn && this._edits[0].range.endLineNumber === this._initialSelection.startLineNumber && (i = !0, this._selectionId = t.trackSelection(this._initialSelection, !1))), i || (this._selectionId = t.trackSelection(this._initialSelection));
  }
  computeCursorState(e, t) {
    return t.getTrackedSelection(this._selectionId);
  }
}
let $v = class {
  constructor(e, t) {
    this.editor = e, this._languageConfigurationService = t, this.callOnDispose = new q(), this.callOnModel = new q(), this.callOnDispose.add(e.onDidChangeConfiguration(() => this.update())), this.callOnDispose.add(e.onDidChangeModel(() => this.update())), this.callOnDispose.add(e.onDidChangeModelLanguage(() => this.update()));
  }
  update() {
    this.callOnModel.clear(), !(this.editor.getOption(
      12
      /* EditorOption.autoIndent */
    ) < 4 || this.editor.getOption(
      55
      /* EditorOption.formatOnPaste */
    )) && this.editor.hasModel() && this.callOnModel.add(this.editor.onDidPaste(({ range: e }) => {
      this.trigger(e);
    }));
  }
  trigger(e) {
    const t = this.editor.getSelections();
    if (t === null || t.length > 1)
      return;
    const i = this.editor.getModel();
    if (!i || Lme(i, e) || !i.tokenization.isCheapToTokenize(e.getStartPosition().lineNumber))
      return;
    const n = this.editor.getOption(
      12
      /* EditorOption.autoIndent */
    ), { tabSize: s, indentSize: o, insertSpaces: a } = i.getOptions(), l = [], d = {
      shiftIndent: (g) => Eo.shiftIndent(g, g.length + 1, s, o, a),
      unshiftIndent: (g) => Eo.unshiftIndent(g, g.length + 1, s, o, a)
    };
    let c = e.startLineNumber;
    for (; c <= e.endLineNumber; ) {
      if (this.shouldIgnoreLine(i, c)) {
        c++;
        continue;
      }
      break;
    }
    if (c > e.endLineNumber)
      return;
    let h = i.getLineContent(c);
    if (!/\S/.test(h.substring(0, e.startColumn - 1))) {
      const g = n_(n, i, i.getLanguageId(), c, d, this._languageConfigurationService);
      if (g !== null) {
        const f = Tt(h), m = Ns(g, s), _ = Ns(f, s);
        if (m !== _) {
          const v = k_(m, s, a);
          l.push({
            range: new L(c, 1, c, f.length + 1),
            text: v
          }), h = v + h.substr(f.length);
        } else {
          const v = n2(i, c, this._languageConfigurationService);
          if (v === 0 || v === 8)
            return;
        }
      }
    }
    const u = c;
    for (; c < e.endLineNumber; ) {
      if (!/\S/.test(i.getLineContent(c + 1))) {
        c++;
        continue;
      }
      break;
    }
    if (c !== e.endLineNumber) {
      const f = n_(n, {
        tokenization: {
          getLineTokens: (m) => i.tokenization.getLineTokens(m),
          getLanguageId: () => i.getLanguageId(),
          getLanguageIdAtPosition: (m, _) => i.getLanguageIdAtPosition(m, _)
        },
        getLineContent: (m) => m === u ? h : i.getLineContent(m)
      }, i.getLanguageId(), c + 1, d, this._languageConfigurationService);
      if (f !== null) {
        const m = Ns(f, s), _ = Ns(Tt(i.getLineContent(c + 1)), s);
        if (m !== _) {
          const v = m - _;
          for (let b = c + 1; b <= e.endLineNumber; b++) {
            const C = i.getLineContent(b), w = Tt(C), y = Ns(w, s) + v, k = k_(y, s, a);
            k !== w && l.push({
              range: new L(b, 1, b, w.length + 1),
              text: k
            });
          }
        }
      }
    }
    if (l.length > 0) {
      this.editor.pushUndoStop();
      const g = new yme(l, this.editor.getSelection());
      this.editor.executeCommand("autoIndentOnPaste", g), this.editor.pushUndoStop();
    }
  }
  shouldIgnoreLine(e, t) {
    e.tokenization.forceTokenization(t);
    const i = e.getLineFirstNonWhitespaceColumn(t);
    if (i === 0)
      return !0;
    const n = e.tokenization.getLineTokens(t);
    if (n.getCount() > 0) {
      const s = n.findTokenIndexAtOffset(i);
      if (s >= 0 && n.getStandardTokenType(s) === 1)
        return !0;
    }
    return !1;
  }
  dispose() {
    this.callOnDispose.dispose(), this.callOnModel.dispose();
  }
};
$v.ID = "editor.contrib.autoIndentOnPaste";
$v = bme([
  Cme(1, Ot)
], $v);
function Lme(r, e) {
  const t = (i) => Tq(r, i) === 2;
  return t(e.getStartPosition()) || t(e.getEndPosition());
}
function r$(r, e, t, i) {
  if (r.getLineCount() === 1 && r.getLineMaxColumn(1) === 1)
    return;
  let n = "";
  for (let o = 0; o < t; o++)
    n += " ";
  const s = new RegExp(n, "gi");
  for (let o = 1, a = r.getLineCount(); o <= a; o++) {
    let l = r.getLineFirstNonWhitespaceColumn(o);
    if (l === 0 && (l = r.getLineMaxColumn(o)), l === 1)
      continue;
    const d = new L(o, 1, o, l), c = r.getValueInRange(d), h = i ? c.replace(/\t/ig, n) : c.replace(s, "	");
    e.addEditOperation(d, h);
  }
}
class Dme {
  constructor(e, t) {
    this.selection = e, this.tabSize = t, this.selectionId = null;
  }
  getEditOperations(e, t) {
    this.selectionId = t.trackSelection(this.selection), r$(e, t, this.tabSize, !0);
  }
  computeCursorState(e, t) {
    return t.getTrackedSelection(this.selectionId);
  }
}
class kme {
  constructor(e, t) {
    this.selection = e, this.tabSize = t, this.selectionId = null;
  }
  getEditOperations(e, t) {
    this.selectionId = t.trackSelection(this.selection), r$(e, t, this.tabSize, !1);
  }
  computeCursorState(e, t) {
    return t.getTrackedSelection(this.selectionId);
  }
}
gt(
  $v.ID,
  $v,
  2
  /* EditorContributionInstantiation.BeforeFirstInteraction */
);
Y(QL);
Y(XL);
Y(JL);
Y(eD);
Y(tD);
Y(iD);
Y(wme);
Y(Sme);
gt(
  Zc.ID,
  Zc,
  1
  /* EditorContributionInstantiation.AfterFirstRender */
);
ah.register(Oy);
class xme {
  constructor(e, t, i) {
    this._editRange = e, this._originalSelection = t, this._text = i;
  }
  getEditOperations(e, t) {
    t.addTrackedEditOperation(this._editRange, this._text);
  }
  computeCursorState(e, t) {
    const n = t.getInverseEditOperations()[0].range;
    return this._originalSelection.isEmpty() ? new ge(n.endLineNumber, Math.min(this._originalSelection.positionColumn, n.endColumn), n.endLineNumber, Math.min(this._originalSelection.positionColumn, n.endColumn)) : new ge(n.endLineNumber, n.endColumn - this._text.length, n.endLineNumber, n.endColumn);
  }
}
var Ime = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Eme = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, eS;
let Xc = eS = class {
  static get(e) {
    return e.getContribution(eS.ID);
  }
  constructor(e, t) {
    this.editor = e, this.editorWorkerService = t, this.decorations = this.editor.createDecorationsCollection();
  }
  dispose() {
  }
  run(e, t) {
    var i;
    (i = this.currentRequest) === null || i === void 0 || i.cancel();
    const n = this.editor.getSelection(), s = this.editor.getModel();
    if (!s || !n)
      return;
    let o = n;
    if (o.startLineNumber !== o.endLineNumber)
      return;
    const a = new U3(
      this.editor,
      5
      /* CodeEditorStateFlag.Position */
    ), l = s.uri;
    return this.editorWorkerService.canNavigateValueSet(l) ? (this.currentRequest = Zi((d) => this.editorWorkerService.navigateValueSet(l, o, t)), this.currentRequest.then((d) => {
      var c;
      if (!d || !d.range || !d.value || !a.validate(this.editor))
        return;
      const h = L.lift(d.range);
      let u = d.range;
      const g = d.value.length - (o.endColumn - o.startColumn);
      u = {
        startLineNumber: u.startLineNumber,
        startColumn: u.startColumn,
        endLineNumber: u.endLineNumber,
        endColumn: u.startColumn + d.value.length
      }, g > 1 && (o = new ge(o.startLineNumber, o.startColumn, o.endLineNumber, o.endColumn + g - 1));
      const f = new xme(h, o, d.value);
      this.editor.pushUndoStop(), this.editor.executeCommand(e, f), this.editor.pushUndoStop(), this.decorations.set([{
        range: u,
        options: eS.DECORATION
      }]), (c = this.decorationRemover) === null || c === void 0 || c.cancel(), this.decorationRemover = cd(350), this.decorationRemover.then(() => this.decorations.clear()).catch(He);
    }).catch(He)) : Promise.resolve(void 0);
  }
};
Xc.ID = "editor.contrib.inPlaceReplaceController";
Xc.DECORATION = Fe.register({
  description: "in-place-replace",
  className: "valueSetReplacement"
});
Xc = eS = Ime([
  Eme(1, Uo)
], Xc);
class Tme extends ae {
  constructor() {
    super({
      id: "editor.action.inPlaceReplace.up",
      label: p("InPlaceReplaceAction.previous.label", "Replace with Previous Value"),
      alias: "Replace with Previous Value",
      precondition: x.writable,
      kbOpts: {
        kbExpr: x.editorTextFocus,
        primary: 3159,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(e, t) {
    const i = Xc.get(t);
    return i ? i.run(this.id, !1) : Promise.resolve(void 0);
  }
}
class Nme extends ae {
  constructor() {
    super({
      id: "editor.action.inPlaceReplace.down",
      label: p("InPlaceReplaceAction.next.label", "Replace with Next Value"),
      alias: "Replace with Next Value",
      precondition: x.writable,
      kbOpts: {
        kbExpr: x.editorTextFocus,
        primary: 3161,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(e, t) {
    const i = Xc.get(t);
    return i ? i.run(this.id, !0) : Promise.resolve(void 0);
  }
}
gt(
  Xc.ID,
  Xc,
  4
  /* EditorContributionInstantiation.Lazy */
);
Y(Tme);
Y(Nme);
class Mme extends ae {
  constructor() {
    super({
      id: "expandLineSelection",
      label: p("expandLineSelection", "Expand Line Selection"),
      alias: "Expand Line Selection",
      precondition: void 0,
      kbOpts: {
        weight: 0,
        kbExpr: x.textInputFocus,
        primary: 2090
        /* KeyCode.KeyL */
      }
    });
  }
  run(e, t, i) {
    if (i = i || {}, !t.hasModel())
      return;
    const n = t._getViewModel();
    n.model.pushStackElement(), n.setCursorStates(i.source, 3, cn.expandLineSelection(n, n.getCursorStates())), n.revealAllCursors(i.source, !0);
  }
}
Y(Mme);
class Rme {
  constructor(e, t, i) {
    this._selection = e, this._cursors = t, this._selectionId = null, this._trimInRegexesAndStrings = i;
  }
  getEditOperations(e, t) {
    const i = Ame(e, this._cursors, this._trimInRegexesAndStrings);
    for (let n = 0, s = i.length; n < s; n++) {
      const o = i[n];
      t.addEditOperation(o.range, o.text);
    }
    this._selectionId = t.trackSelection(this._selection);
  }
  computeCursorState(e, t) {
    return t.getTrackedSelection(this._selectionId);
  }
}
function Ame(r, e, t) {
  e.sort((a, l) => a.lineNumber === l.lineNumber ? a.column - l.column : a.lineNumber - l.lineNumber);
  for (let a = e.length - 2; a >= 0; a--)
    e[a].lineNumber === e[a + 1].lineNumber && e.splice(a, 1);
  const i = [];
  let n = 0, s = 0;
  const o = e.length;
  for (let a = 1, l = r.getLineCount(); a <= l; a++) {
    const d = r.getLineContent(a), c = d.length + 1;
    let h = 0;
    if (s < o && e[s].lineNumber === a && (h = e[s].column, s++, h === c) || d.length === 0)
      continue;
    const u = ja(d);
    let g = 0;
    if (u === -1)
      g = 1;
    else if (u !== d.length - 1)
      g = u + 2;
    else
      continue;
    if (!t) {
      if (!r.tokenization.hasAccurateTokensForLine(a))
        continue;
      const f = r.tokenization.getLineTokens(a), m = f.getStandardTokenType(f.findTokenIndexAtOffset(g));
      if (m === 2 || m === 3)
        continue;
    }
    g = Math.max(h, g), i[n++] = ti.delete(new L(a, g, a, c));
  }
  return i;
}
class a$ {
  constructor(e, t, i) {
    this._selection = e, this._isCopyingDown = t, this._noop = i || !1, this._selectionDirection = 0, this._selectionId = null, this._startLineNumberDelta = 0, this._endLineNumberDelta = 0;
  }
  getEditOperations(e, t) {
    let i = this._selection;
    this._startLineNumberDelta = 0, this._endLineNumberDelta = 0, i.startLineNumber < i.endLineNumber && i.endColumn === 1 && (this._endLineNumberDelta = 1, i = i.setEndPosition(i.endLineNumber - 1, e.getLineMaxColumn(i.endLineNumber - 1)));
    const n = [];
    for (let o = i.startLineNumber; o <= i.endLineNumber; o++)
      n.push(e.getLineContent(o));
    const s = n.join(`
`);
    s === "" && this._isCopyingDown && (this._startLineNumberDelta++, this._endLineNumberDelta++), this._noop ? t.addEditOperation(new L(i.endLineNumber, e.getLineMaxColumn(i.endLineNumber), i.endLineNumber + 1, 1), i.endLineNumber === e.getLineCount() ? "" : `
`) : this._isCopyingDown ? t.addEditOperation(new L(i.startLineNumber, 1, i.startLineNumber, 1), s + `
`) : t.addEditOperation(new L(i.endLineNumber, e.getLineMaxColumn(i.endLineNumber), i.endLineNumber, e.getLineMaxColumn(i.endLineNumber)), `
` + s), this._selectionId = t.trackSelection(i), this._selectionDirection = this._selection.getDirection();
  }
  computeCursorState(e, t) {
    let i = t.getTrackedSelection(this._selectionId);
    if (this._startLineNumberDelta !== 0 || this._endLineNumberDelta !== 0) {
      let n = i.startLineNumber, s = i.startColumn, o = i.endLineNumber, a = i.endColumn;
      this._startLineNumberDelta !== 0 && (n = n + this._startLineNumberDelta, s = 1), this._endLineNumberDelta !== 0 && (o = o + this._endLineNumberDelta, a = 1), i = ge.createWithDirection(n, s, o, a, this._selectionDirection);
    }
    return i;
  }
}
var Pme = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Ome = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
let nN = class {
  constructor(e, t, i, n) {
    this._languageConfigurationService = n, this._selection = e, this._isMovingDown = t, this._autoIndent = i, this._selectionId = null, this._moveEndLineSelectionShrink = !1;
  }
  getEditOperations(e, t) {
    const i = () => e.getLanguageId(), n = (h, u) => e.getLanguageIdAtPosition(h, u), s = e.getLineCount();
    if (this._isMovingDown && this._selection.endLineNumber === s) {
      this._selectionId = t.trackSelection(this._selection);
      return;
    }
    if (!this._isMovingDown && this._selection.startLineNumber === 1) {
      this._selectionId = t.trackSelection(this._selection);
      return;
    }
    this._moveEndPositionDown = !1;
    let o = this._selection;
    o.startLineNumber < o.endLineNumber && o.endColumn === 1 && (this._moveEndPositionDown = !0, o = o.setEndPosition(o.endLineNumber - 1, e.getLineMaxColumn(o.endLineNumber - 1)));
    const { tabSize: a, indentSize: l, insertSpaces: d } = e.getOptions(), c = this.buildIndentConverter(a, l, d);
    if (o.startLineNumber === o.endLineNumber && e.getLineMaxColumn(o.startLineNumber) === 1) {
      const h = o.startLineNumber, u = this._isMovingDown ? h + 1 : h - 1;
      e.getLineMaxColumn(u) === 1 ? t.addEditOperation(new L(1, 1, 1, 1), null) : (t.addEditOperation(new L(h, 1, h, 1), e.getLineContent(u)), t.addEditOperation(new L(u, 1, u, e.getLineMaxColumn(u)), null)), o = new ge(u, 1, u, 1);
    } else {
      let h, u;
      if (this._isMovingDown) {
        h = o.endLineNumber + 1, u = e.getLineContent(h), t.addEditOperation(new L(h - 1, e.getLineMaxColumn(h - 1), h, e.getLineMaxColumn(h)), null);
        let g = u;
        if (this.shouldAutoIndent(e, o)) {
          const f = this.matchEnterRule(e, c, a, h, o.startLineNumber - 1);
          if (f !== null) {
            const _ = Tt(e.getLineContent(h)), v = f + Ns(_, a);
            g = k_(v, a, d) + this.trimStart(u);
          } else {
            const _ = {
              tokenization: {
                getLineTokens: (b) => b === o.startLineNumber ? e.tokenization.getLineTokens(h) : e.tokenization.getLineTokens(b),
                getLanguageId: i,
                getLanguageIdAtPosition: n
              },
              getLineContent: (b) => b === o.startLineNumber ? e.getLineContent(h) : e.getLineContent(b)
            }, v = n_(this._autoIndent, _, e.getLanguageIdAtPosition(h, 1), o.startLineNumber, c, this._languageConfigurationService);
            if (v !== null) {
              const b = Tt(e.getLineContent(h)), C = Ns(v, a), w = Ns(b, a);
              C !== w && (g = k_(C, a, d) + this.trimStart(u));
            }
          }
          t.addEditOperation(new L(o.startLineNumber, 1, o.startLineNumber, 1), g + `
`);
          const m = this.matchEnterRuleMovingDown(e, c, a, o.startLineNumber, h, g);
          if (m !== null)
            m !== 0 && this.getIndentEditsOfMovingBlock(e, t, o, a, d, m);
          else {
            const _ = {
              tokenization: {
                getLineTokens: (b) => b === o.startLineNumber ? e.tokenization.getLineTokens(h) : b >= o.startLineNumber + 1 && b <= o.endLineNumber + 1 ? e.tokenization.getLineTokens(b - 1) : e.tokenization.getLineTokens(b),
                getLanguageId: i,
                getLanguageIdAtPosition: n
              },
              getLineContent: (b) => b === o.startLineNumber ? g : b >= o.startLineNumber + 1 && b <= o.endLineNumber + 1 ? e.getLineContent(b - 1) : e.getLineContent(b)
            }, v = n_(this._autoIndent, _, e.getLanguageIdAtPosition(h, 1), o.startLineNumber + 1, c, this._languageConfigurationService);
            if (v !== null) {
              const b = Tt(e.getLineContent(o.startLineNumber)), C = Ns(v, a), w = Ns(b, a);
              if (C !== w) {
                const S = C - w;
                this.getIndentEditsOfMovingBlock(e, t, o, a, d, S);
              }
            }
          }
        } else
          t.addEditOperation(new L(o.startLineNumber, 1, o.startLineNumber, 1), g + `
`);
      } else if (h = o.startLineNumber - 1, u = e.getLineContent(h), t.addEditOperation(new L(h, 1, h + 1, 1), null), t.addEditOperation(new L(o.endLineNumber, e.getLineMaxColumn(o.endLineNumber), o.endLineNumber, e.getLineMaxColumn(o.endLineNumber)), `
` + u), this.shouldAutoIndent(e, o)) {
        const g = {
          tokenization: {
            getLineTokens: (m) => m === h ? e.tokenization.getLineTokens(o.startLineNumber) : e.tokenization.getLineTokens(m),
            getLanguageId: i,
            getLanguageIdAtPosition: n
          },
          getLineContent: (m) => m === h ? e.getLineContent(o.startLineNumber) : e.getLineContent(m)
        }, f = this.matchEnterRule(e, c, a, o.startLineNumber, o.startLineNumber - 2);
        if (f !== null)
          f !== 0 && this.getIndentEditsOfMovingBlock(e, t, o, a, d, f);
        else {
          const m = n_(this._autoIndent, g, e.getLanguageIdAtPosition(o.startLineNumber, 1), h, c, this._languageConfigurationService);
          if (m !== null) {
            const _ = Tt(e.getLineContent(o.startLineNumber)), v = Ns(m, a), b = Ns(_, a);
            if (v !== b) {
              const C = v - b;
              this.getIndentEditsOfMovingBlock(e, t, o, a, d, C);
            }
          }
        }
      }
    }
    this._selectionId = t.trackSelection(o);
  }
  buildIndentConverter(e, t, i) {
    return {
      shiftIndent: (n) => Eo.shiftIndent(n, n.length + 1, e, t, i),
      unshiftIndent: (n) => Eo.unshiftIndent(n, n.length + 1, e, t, i)
    };
  }
  parseEnterResult(e, t, i, n, s) {
    if (s) {
      let o = s.indentation;
      s.indentAction === Mi.None || s.indentAction === Mi.Indent ? o = s.indentation + s.appendText : s.indentAction === Mi.IndentOutdent ? o = s.indentation : s.indentAction === Mi.Outdent && (o = t.unshiftIndent(s.indentation) + s.appendText);
      const a = e.getLineContent(n);
      if (this.trimStart(a).indexOf(this.trimStart(o)) >= 0) {
        const l = Tt(e.getLineContent(n));
        let d = Tt(o);
        const c = n2(e, n, this._languageConfigurationService);
        c !== null && c & 2 && (d = t.unshiftIndent(d));
        const h = Ns(d, i), u = Ns(l, i);
        return h - u;
      }
    }
    return null;
  }
  /**
   *
   * @param model
   * @param indentConverter
   * @param tabSize
   * @param line the line moving down
   * @param futureAboveLineNumber the line which will be at the `line` position
   * @param futureAboveLineText
   */
  matchEnterRuleMovingDown(e, t, i, n, s, o) {
    if (ja(o) >= 0) {
      const a = e.getLineMaxColumn(s), l = bf(this._autoIndent, e, new L(s, a, s, a), this._languageConfigurationService);
      return this.parseEnterResult(e, t, i, n, l);
    } else {
      let a = n - 1;
      for (; a >= 1; ) {
        const c = e.getLineContent(a);
        if (ja(c) >= 0)
          break;
        a--;
      }
      if (a < 1 || n > e.getLineCount())
        return null;
      const l = e.getLineMaxColumn(a), d = bf(this._autoIndent, e, new L(a, l, a, l), this._languageConfigurationService);
      return this.parseEnterResult(e, t, i, n, d);
    }
  }
  matchEnterRule(e, t, i, n, s, o) {
    let a = s;
    for (; a >= 1; ) {
      let c;
      if (a === s && o !== void 0 ? c = o : c = e.getLineContent(a), ja(c) >= 0)
        break;
      a--;
    }
    if (a < 1 || n > e.getLineCount())
      return null;
    const l = e.getLineMaxColumn(a), d = bf(this._autoIndent, e, new L(a, l, a, l), this._languageConfigurationService);
    return this.parseEnterResult(e, t, i, n, d);
  }
  trimStart(e) {
    return e.replace(/^\s+/, "");
  }
  shouldAutoIndent(e, t) {
    if (this._autoIndent < 4 || !e.tokenization.isCheapToTokenize(t.startLineNumber))
      return !1;
    const i = e.getLanguageIdAtPosition(t.startLineNumber, 1), n = e.getLanguageIdAtPosition(t.endLineNumber, 1);
    return !(i !== n || this._languageConfigurationService.getLanguageConfiguration(i).indentRulesSupport === null);
  }
  getIndentEditsOfMovingBlock(e, t, i, n, s, o) {
    for (let a = i.startLineNumber; a <= i.endLineNumber; a++) {
      const l = e.getLineContent(a), d = Tt(l), h = Ns(d, n) + o, u = k_(h, n, s);
      u !== d && (t.addEditOperation(new L(a, 1, a, d.length + 1), u), a === i.endLineNumber && i.endColumn <= d.length + 1 && u === "" && (this._moveEndLineSelectionShrink = !0));
    }
  }
  computeCursorState(e, t) {
    let i = t.getTrackedSelection(this._selectionId);
    return this._moveEndPositionDown && (i = i.setEndPosition(i.endLineNumber + 1, 1)), this._moveEndLineSelectionShrink && i.startLineNumber < i.endLineNumber && (i = i.setEndPosition(i.endLineNumber, 2)), i;
  }
};
nN = Pme([
  Ome(3, Ot)
], nN);
class Lc {
  static getCollator() {
    return Lc._COLLATOR || (Lc._COLLATOR = new Intl.Collator()), Lc._COLLATOR;
  }
  constructor(e, t) {
    this.selection = e, this.descending = t, this.selectionId = null;
  }
  getEditOperations(e, t) {
    const i = Fme(e, this.selection, this.descending);
    i && t.addEditOperation(i.range, i.text), this.selectionId = t.trackSelection(this.selection);
  }
  computeCursorState(e, t) {
    return t.getTrackedSelection(this.selectionId);
  }
  static canRun(e, t, i) {
    if (e === null)
      return !1;
    const n = l$(e, t, i);
    if (!n)
      return !1;
    for (let s = 0, o = n.before.length; s < o; s++)
      if (n.before[s] !== n.after[s])
        return !0;
    return !1;
  }
}
Lc._COLLATOR = null;
function l$(r, e, t) {
  const i = e.startLineNumber;
  let n = e.endLineNumber;
  if (e.endColumn === 1 && n--, i >= n)
    return null;
  const s = [];
  for (let a = i; a <= n; a++)
    s.push(r.getLineContent(a));
  let o = s.slice(0);
  return o.sort(Lc.getCollator().compare), t === !0 && (o = o.reverse()), {
    startLineNumber: i,
    endLineNumber: n,
    before: s,
    after: o
  };
}
function Fme(r, e, t) {
  const i = l$(r, e, t);
  return i ? ti.replace(new L(i.startLineNumber, 1, i.endLineNumber, r.getLineMaxColumn(i.endLineNumber)), i.after.join(`
`)) : null;
}
class d$ extends ae {
  constructor(e, t) {
    super(t), this.down = e;
  }
  run(e, t) {
    if (!t.hasModel())
      return;
    const i = t.getSelections().map((o, a) => ({ selection: o, index: a, ignore: !1 }));
    i.sort((o, a) => L.compareRangesUsingStarts(o.selection, a.selection));
    let n = i[0];
    for (let o = 1; o < i.length; o++) {
      const a = i[o];
      n.selection.endLineNumber === a.selection.startLineNumber && (n.index < a.index ? a.ignore = !0 : (n.ignore = !0, n = a));
    }
    const s = [];
    for (const o of i)
      s.push(new a$(o.selection, this.down, o.ignore));
    t.pushUndoStop(), t.executeCommands(this.id, s), t.pushUndoStop();
  }
}
class Wme extends d$ {
  constructor() {
    super(!1, {
      id: "editor.action.copyLinesUpAction",
      label: p("lines.copyUp", "Copy Line Up"),
      alias: "Copy Line Up",
      precondition: x.writable,
      kbOpts: {
        kbExpr: x.editorTextFocus,
        primary: 1552,
        linux: {
          primary: 3600
          /* KeyCode.UpArrow */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: D.MenubarSelectionMenu,
        group: "2_line",
        title: p({ key: "miCopyLinesUp", comment: ["&& denotes a mnemonic"] }, "&&Copy Line Up"),
        order: 1
      }
    });
  }
}
class Bme extends d$ {
  constructor() {
    super(!0, {
      id: "editor.action.copyLinesDownAction",
      label: p("lines.copyDown", "Copy Line Down"),
      alias: "Copy Line Down",
      precondition: x.writable,
      kbOpts: {
        kbExpr: x.editorTextFocus,
        primary: 1554,
        linux: {
          primary: 3602
          /* KeyCode.DownArrow */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: D.MenubarSelectionMenu,
        group: "2_line",
        title: p({ key: "miCopyLinesDown", comment: ["&& denotes a mnemonic"] }, "Co&&py Line Down"),
        order: 2
      }
    });
  }
}
class Hme extends ae {
  constructor() {
    super({
      id: "editor.action.duplicateSelection",
      label: p("duplicateSelection", "Duplicate Selection"),
      alias: "Duplicate Selection",
      precondition: x.writable,
      menuOpts: {
        menuId: D.MenubarSelectionMenu,
        group: "2_line",
        title: p({ key: "miDuplicateSelection", comment: ["&& denotes a mnemonic"] }, "&&Duplicate Selection"),
        order: 5
      }
    });
  }
  run(e, t, i) {
    if (!t.hasModel())
      return;
    const n = [], s = t.getSelections(), o = t.getModel();
    for (const a of s)
      if (a.isEmpty())
        n.push(new a$(a, !0));
      else {
        const l = new ge(a.endLineNumber, a.endColumn, a.endLineNumber, a.endColumn);
        n.push(new wZ(l, o.getValueInRange(a)));
      }
    t.pushUndoStop(), t.executeCommands(this.id, n), t.pushUndoStop();
  }
}
class c$ extends ae {
  constructor(e, t) {
    super(t), this.down = e;
  }
  run(e, t) {
    const i = e.get(Ot), n = [], s = t.getSelections() || [], o = t.getOption(
      12
      /* EditorOption.autoIndent */
    );
    for (const a of s)
      n.push(new nN(a, this.down, o, i));
    t.pushUndoStop(), t.executeCommands(this.id, n), t.pushUndoStop();
  }
}
class Vme extends c$ {
  constructor() {
    super(!1, {
      id: "editor.action.moveLinesUpAction",
      label: p("lines.moveUp", "Move Line Up"),
      alias: "Move Line Up",
      precondition: x.writable,
      kbOpts: {
        kbExpr: x.editorTextFocus,
        primary: 528,
        linux: {
          primary: 528
          /* KeyCode.UpArrow */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: D.MenubarSelectionMenu,
        group: "2_line",
        title: p({ key: "miMoveLinesUp", comment: ["&& denotes a mnemonic"] }, "Mo&&ve Line Up"),
        order: 3
      }
    });
  }
}
class zme extends c$ {
  constructor() {
    super(!0, {
      id: "editor.action.moveLinesDownAction",
      label: p("lines.moveDown", "Move Line Down"),
      alias: "Move Line Down",
      precondition: x.writable,
      kbOpts: {
        kbExpr: x.editorTextFocus,
        primary: 530,
        linux: {
          primary: 530
          /* KeyCode.DownArrow */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: D.MenubarSelectionMenu,
        group: "2_line",
        title: p({ key: "miMoveLinesDown", comment: ["&& denotes a mnemonic"] }, "Move &&Line Down"),
        order: 4
      }
    });
  }
}
class h$ extends ae {
  constructor(e, t) {
    super(t), this.descending = e;
  }
  run(e, t) {
    if (!t.hasModel())
      return;
    const i = t.getModel();
    let n = t.getSelections();
    n.length === 1 && n[0].isEmpty() && (n = [new ge(1, 1, i.getLineCount(), i.getLineMaxColumn(i.getLineCount()))]);
    for (const o of n)
      if (!Lc.canRun(t.getModel(), o, this.descending))
        return;
    const s = [];
    for (let o = 0, a = n.length; o < a; o++)
      s[o] = new Lc(n[o], this.descending);
    t.pushUndoStop(), t.executeCommands(this.id, s), t.pushUndoStop();
  }
}
class Ume extends h$ {
  constructor() {
    super(!1, {
      id: "editor.action.sortLinesAscending",
      label: p("lines.sortAscending", "Sort Lines Ascending"),
      alias: "Sort Lines Ascending",
      precondition: x.writable
    });
  }
}
class $me extends h$ {
  constructor() {
    super(!0, {
      id: "editor.action.sortLinesDescending",
      label: p("lines.sortDescending", "Sort Lines Descending"),
      alias: "Sort Lines Descending",
      precondition: x.writable
    });
  }
}
class Kme extends ae {
  constructor() {
    super({
      id: "editor.action.removeDuplicateLines",
      label: p("lines.deleteDuplicates", "Delete Duplicate Lines"),
      alias: "Delete Duplicate Lines",
      precondition: x.writable
    });
  }
  run(e, t) {
    if (!t.hasModel())
      return;
    const i = t.getModel();
    if (i.getLineCount() === 1 && i.getLineMaxColumn(1) === 1)
      return;
    const n = [], s = [];
    let o = 0, a = !0, l = t.getSelections();
    l.length === 1 && l[0].isEmpty() && (l = [new ge(1, 1, i.getLineCount(), i.getLineMaxColumn(i.getLineCount()))], a = !1);
    for (const d of l) {
      const c = /* @__PURE__ */ new Set(), h = [];
      for (let m = d.startLineNumber; m <= d.endLineNumber; m++) {
        const _ = i.getLineContent(m);
        c.has(_) || (h.push(_), c.add(_));
      }
      const u = new ge(d.startLineNumber, 1, d.endLineNumber, i.getLineMaxColumn(d.endLineNumber)), g = d.startLineNumber - o, f = new ge(g, 1, g + h.length - 1, h[h.length - 1].length);
      n.push(ti.replace(u, h.join(`
`))), s.push(f), o += d.endLineNumber - d.startLineNumber + 1 - h.length;
    }
    t.pushUndoStop(), t.executeEdits(this.id, n, a ? s : void 0), t.pushUndoStop();
  }
}
class nD extends ae {
  constructor() {
    super({
      id: nD.ID,
      label: p("lines.trimTrailingWhitespace", "Trim Trailing Whitespace"),
      alias: "Trim Trailing Whitespace",
      precondition: x.writable,
      kbOpts: {
        kbExpr: x.editorTextFocus,
        primary: zi(
          2089,
          2102
          /* KeyCode.KeyX */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(e, t, i) {
    let n = [];
    i.reason === "auto-save" && (n = (t.getSelections() || []).map((c) => new A(c.positionLineNumber, c.positionColumn)));
    const s = t.getSelection();
    if (s === null)
      return;
    const o = e.get(Ge), a = t.getModel(), l = o.getValue("files.trimTrailingWhitespaceInRegexAndStrings", { overrideIdentifier: a == null ? void 0 : a.getLanguageId(), resource: a == null ? void 0 : a.uri }), d = new Rme(s, n, l);
    t.pushUndoStop(), t.executeCommands(this.id, [d]), t.pushUndoStop();
  }
}
nD.ID = "editor.action.trimTrailingWhitespace";
class jme extends ae {
  constructor() {
    super({
      id: "editor.action.deleteLines",
      label: p("lines.delete", "Delete Line"),
      alias: "Delete Line",
      precondition: x.writable,
      kbOpts: {
        kbExpr: x.textInputFocus,
        primary: 3113,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(e, t) {
    if (!t.hasModel())
      return;
    const i = this._getLinesToRemove(t), n = t.getModel();
    if (n.getLineCount() === 1 && n.getLineMaxColumn(1) === 1)
      return;
    let s = 0;
    const o = [], a = [];
    for (let l = 0, d = i.length; l < d; l++) {
      const c = i[l];
      let h = c.startLineNumber, u = c.endLineNumber, g = 1, f = n.getLineMaxColumn(u);
      u < n.getLineCount() ? (u += 1, f = 1) : h > 1 && (h -= 1, g = n.getLineMaxColumn(h)), o.push(ti.replace(new ge(h, g, u, f), "")), a.push(new ge(h - s, c.positionColumn, h - s, c.positionColumn)), s += c.endLineNumber - c.startLineNumber + 1;
    }
    t.pushUndoStop(), t.executeEdits(this.id, o, a), t.pushUndoStop();
  }
  _getLinesToRemove(e) {
    const t = e.getSelections().map((s) => {
      let o = s.endLineNumber;
      return s.startLineNumber < s.endLineNumber && s.endColumn === 1 && (o -= 1), {
        startLineNumber: s.startLineNumber,
        selectionStartColumn: s.selectionStartColumn,
        endLineNumber: o,
        positionColumn: s.positionColumn
      };
    });
    t.sort((s, o) => s.startLineNumber === o.startLineNumber ? s.endLineNumber - o.endLineNumber : s.startLineNumber - o.startLineNumber);
    const i = [];
    let n = t[0];
    for (let s = 1; s < t.length; s++)
      n.endLineNumber + 1 >= t[s].startLineNumber ? n.endLineNumber = t[s].endLineNumber : (i.push(n), n = t[s]);
    return i.push(n), i;
  }
}
class qme extends ae {
  constructor() {
    super({
      id: "editor.action.indentLines",
      label: p("lines.indent", "Indent Line"),
      alias: "Indent Line",
      precondition: x.writable,
      kbOpts: {
        kbExpr: x.editorTextFocus,
        primary: 2142,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(e, t) {
    const i = t._getViewModel();
    i && (t.pushUndoStop(), t.executeCommands(this.id, ni.indent(i.cursorConfig, t.getModel(), t.getSelections())), t.pushUndoStop());
  }
}
class Gme extends ae {
  constructor() {
    super({
      id: "editor.action.outdentLines",
      label: p("lines.outdent", "Outdent Line"),
      alias: "Outdent Line",
      precondition: x.writable,
      kbOpts: {
        kbExpr: x.editorTextFocus,
        primary: 2140,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(e, t) {
    Cf.Outdent.runEditorCommand(e, t, null);
  }
}
class Zme extends ae {
  constructor() {
    super({
      id: "editor.action.insertLineBefore",
      label: p("lines.insertBefore", "Insert Line Above"),
      alias: "Insert Line Above",
      precondition: x.writable,
      kbOpts: {
        kbExpr: x.editorTextFocus,
        primary: 3075,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(e, t) {
    const i = t._getViewModel();
    i && (t.pushUndoStop(), t.executeCommands(this.id, ni.lineInsertBefore(i.cursorConfig, t.getModel(), t.getSelections())));
  }
}
class Yme extends ae {
  constructor() {
    super({
      id: "editor.action.insertLineAfter",
      label: p("lines.insertAfter", "Insert Line Below"),
      alias: "Insert Line Below",
      precondition: x.writable,
      kbOpts: {
        kbExpr: x.editorTextFocus,
        primary: 2051,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(e, t) {
    const i = t._getViewModel();
    i && (t.pushUndoStop(), t.executeCommands(this.id, ni.lineInsertAfter(i.cursorConfig, t.getModel(), t.getSelections())));
  }
}
class u$ extends ae {
  run(e, t) {
    if (!t.hasModel())
      return;
    const i = t.getSelection(), n = this._getRangesToDelete(t), s = [];
    for (let l = 0, d = n.length - 1; l < d; l++) {
      const c = n[l], h = n[l + 1];
      L.intersectRanges(c, h) === null ? s.push(c) : n[l + 1] = L.plusRange(c, h);
    }
    s.push(n[n.length - 1]);
    const o = this._getEndCursorState(i, s), a = s.map((l) => ti.replace(l, ""));
    t.pushUndoStop(), t.executeEdits(this.id, a, o), t.pushUndoStop();
  }
}
class Qme extends u$ {
  constructor() {
    super({
      id: "deleteAllLeft",
      label: p("lines.deleteAllLeft", "Delete All Left"),
      alias: "Delete All Left",
      precondition: x.writable,
      kbOpts: {
        kbExpr: x.textInputFocus,
        primary: 0,
        mac: {
          primary: 2049
          /* KeyCode.Backspace */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  _getEndCursorState(e, t) {
    let i = null;
    const n = [];
    let s = 0;
    return t.forEach((o) => {
      let a;
      if (o.endColumn === 1 && s > 0) {
        const l = o.startLineNumber - s;
        a = new ge(l, o.startColumn, l, o.startColumn);
      } else
        a = new ge(o.startLineNumber, o.startColumn, o.startLineNumber, o.startColumn);
      s += o.endLineNumber - o.startLineNumber, o.intersectRanges(e) ? i = a : n.push(a);
    }), i && n.unshift(i), n;
  }
  _getRangesToDelete(e) {
    const t = e.getSelections();
    if (t === null)
      return [];
    let i = t;
    const n = e.getModel();
    return n === null ? [] : (i.sort(L.compareRangesUsingStarts), i = i.map((s) => {
      if (s.isEmpty())
        if (s.startColumn === 1) {
          const o = Math.max(1, s.startLineNumber - 1), a = s.startLineNumber === 1 ? 1 : n.getLineLength(o) + 1;
          return new L(o, a, s.startLineNumber, 1);
        } else
          return new L(s.startLineNumber, 1, s.startLineNumber, s.startColumn);
      else
        return new L(s.startLineNumber, 1, s.endLineNumber, s.endColumn);
    }), i);
  }
}
class Xme extends u$ {
  constructor() {
    super({
      id: "deleteAllRight",
      label: p("lines.deleteAllRight", "Delete All Right"),
      alias: "Delete All Right",
      precondition: x.writable,
      kbOpts: {
        kbExpr: x.textInputFocus,
        primary: 0,
        mac: { primary: 297, secondary: [
          2068
          /* KeyCode.Delete */
        ] },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  _getEndCursorState(e, t) {
    let i = null;
    const n = [];
    for (let s = 0, o = t.length, a = 0; s < o; s++) {
      const l = t[s], d = new ge(l.startLineNumber - a, l.startColumn, l.startLineNumber - a, l.startColumn);
      l.intersectRanges(e) ? i = d : n.push(d);
    }
    return i && n.unshift(i), n;
  }
  _getRangesToDelete(e) {
    const t = e.getModel();
    if (t === null)
      return [];
    const i = e.getSelections();
    if (i === null)
      return [];
    const n = i.map((s) => {
      if (s.isEmpty()) {
        const o = t.getLineMaxColumn(s.startLineNumber);
        return s.startColumn === o ? new L(s.startLineNumber, s.startColumn, s.startLineNumber + 1, 1) : new L(s.startLineNumber, s.startColumn, s.startLineNumber, o);
      }
      return s;
    });
    return n.sort(L.compareRangesUsingStarts), n;
  }
}
class Jme extends ae {
  constructor() {
    super({
      id: "editor.action.joinLines",
      label: p("lines.joinLines", "Join Lines"),
      alias: "Join Lines",
      precondition: x.writable,
      kbOpts: {
        kbExpr: x.editorTextFocus,
        primary: 0,
        mac: {
          primary: 296
          /* KeyCode.KeyJ */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(e, t) {
    const i = t.getSelections();
    if (i === null)
      return;
    let n = t.getSelection();
    if (n === null)
      return;
    i.sort(L.compareRangesUsingStarts);
    const s = [], o = i.reduce((u, g) => u.isEmpty() ? u.endLineNumber === g.startLineNumber ? (n.equalsSelection(u) && (n = g), g) : g.startLineNumber > u.endLineNumber + 1 ? (s.push(u), g) : new ge(u.startLineNumber, u.startColumn, g.endLineNumber, g.endColumn) : g.startLineNumber > u.endLineNumber ? (s.push(u), g) : new ge(u.startLineNumber, u.startColumn, g.endLineNumber, g.endColumn));
    s.push(o);
    const a = t.getModel();
    if (a === null)
      return;
    const l = [], d = [];
    let c = n, h = 0;
    for (let u = 0, g = s.length; u < g; u++) {
      const f = s[u], m = f.startLineNumber, _ = 1;
      let v = 0, b, C;
      const w = a.getLineLength(f.endLineNumber) - f.endColumn;
      if (f.isEmpty() || f.startLineNumber === f.endLineNumber) {
        const k = f.getStartPosition();
        k.lineNumber < a.getLineCount() ? (b = m + 1, C = a.getLineMaxColumn(b)) : (b = k.lineNumber, C = a.getLineMaxColumn(k.lineNumber));
      } else
        b = f.endLineNumber, C = a.getLineMaxColumn(b);
      let S = a.getLineContent(m);
      for (let k = m + 1; k <= b; k++) {
        const E = a.getLineContent(k), N = a.getLineFirstNonWhitespaceColumn(k);
        if (N >= 1) {
          let F = !0;
          S === "" && (F = !1), F && (S.charAt(S.length - 1) === " " || S.charAt(S.length - 1) === "	") && (F = !1, S = S.replace(/[\s\uFEFF\xA0]+$/g, " "));
          const V = E.substr(N - 1);
          S += (F ? " " : "") + V, F ? v = V.length + 1 : v = V.length;
        } else
          v = 0;
      }
      const y = new L(m, _, b, C);
      if (!y.isEmpty()) {
        let k;
        f.isEmpty() ? (l.push(ti.replace(y, S)), k = new ge(y.startLineNumber - h, S.length - v + 1, m - h, S.length - v + 1)) : f.startLineNumber === f.endLineNumber ? (l.push(ti.replace(y, S)), k = new ge(f.startLineNumber - h, f.startColumn, f.endLineNumber - h, f.endColumn)) : (l.push(ti.replace(y, S)), k = new ge(f.startLineNumber - h, f.startColumn, f.startLineNumber - h, S.length - w)), L.intersectRanges(y, n) !== null ? c = k : d.push(k);
      }
      h += y.endLineNumber - y.startLineNumber;
    }
    d.unshift(c), t.pushUndoStop(), t.executeEdits(this.id, l, d), t.pushUndoStop();
  }
}
class e_e extends ae {
  constructor() {
    super({
      id: "editor.action.transpose",
      label: p("editor.transpose", "Transpose Characters around the Cursor"),
      alias: "Transpose Characters around the Cursor",
      precondition: x.writable
    });
  }
  run(e, t) {
    const i = t.getSelections();
    if (i === null)
      return;
    const n = t.getModel();
    if (n === null)
      return;
    const s = [];
    for (let o = 0, a = i.length; o < a; o++) {
      const l = i[o];
      if (!l.isEmpty())
        continue;
      const d = l.getStartPosition(), c = n.getLineMaxColumn(d.lineNumber);
      if (d.column >= c) {
        if (d.lineNumber === n.getLineCount())
          continue;
        const h = new L(d.lineNumber, Math.max(1, d.column - 1), d.lineNumber + 1, 1), u = n.getValueInRange(h).split("").reverse().join("");
        s.push(new Cn(new ge(d.lineNumber, Math.max(1, d.column - 1), d.lineNumber + 1, 1), u));
      } else {
        const h = new L(d.lineNumber, Math.max(1, d.column - 1), d.lineNumber, d.column + 1), u = n.getValueInRange(h).split("").reverse().join("");
        s.push(new E1(h, u, new ge(d.lineNumber, d.column + 1, d.lineNumber, d.column + 1)));
      }
    }
    t.pushUndoStop(), t.executeCommands(this.id, s), t.pushUndoStop();
  }
}
class ug extends ae {
  run(e, t) {
    const i = t.getSelections();
    if (i === null)
      return;
    const n = t.getModel();
    if (n === null)
      return;
    const s = t.getOption(
      131
      /* EditorOption.wordSeparators */
    ), o = [];
    for (const a of i)
      if (a.isEmpty()) {
        const l = a.getStartPosition(), d = t.getConfiguredWordAtPosition(l);
        if (!d)
          continue;
        const c = new L(l.lineNumber, d.startColumn, l.lineNumber, d.endColumn), h = n.getValueInRange(c);
        o.push(ti.replace(c, this._modifyText(h, s)));
      } else {
        const l = n.getValueInRange(a);
        o.push(ti.replace(a, this._modifyText(l, s)));
      }
    t.pushUndoStop(), t.executeEdits(this.id, o), t.pushUndoStop();
  }
}
class t_e extends ug {
  constructor() {
    super({
      id: "editor.action.transformToUppercase",
      label: p("editor.transformToUppercase", "Transform to Uppercase"),
      alias: "Transform to Uppercase",
      precondition: x.writable
    });
  }
  _modifyText(e, t) {
    return e.toLocaleUpperCase();
  }
}
class i_e extends ug {
  constructor() {
    super({
      id: "editor.action.transformToLowercase",
      label: p("editor.transformToLowercase", "Transform to Lowercase"),
      alias: "Transform to Lowercase",
      precondition: x.writable
    });
  }
  _modifyText(e, t) {
    return e.toLocaleLowerCase();
  }
}
class Id {
  constructor(e, t) {
    this._pattern = e, this._flags = t, this._actual = null, this._evaluated = !1;
  }
  get() {
    if (!this._evaluated) {
      this._evaluated = !0;
      try {
        this._actual = new RegExp(this._pattern, this._flags);
      } catch {
      }
    }
    return this._actual;
  }
  isSupported() {
    return this.get() !== null;
  }
}
class Kv extends ug {
  constructor() {
    super({
      id: "editor.action.transformToTitlecase",
      label: p("editor.transformToTitlecase", "Transform to Title Case"),
      alias: "Transform to Title Case",
      precondition: x.writable
    });
  }
  _modifyText(e, t) {
    const i = Kv.titleBoundary.get();
    return i ? e.toLocaleLowerCase().replace(i, (n) => n.toLocaleUpperCase()) : e;
  }
}
Kv.titleBoundary = new Id("(^|[^\\p{L}\\p{N}']|((^|\\P{L})'))\\p{L}", "gmu");
class Dc extends ug {
  constructor() {
    super({
      id: "editor.action.transformToSnakecase",
      label: p("editor.transformToSnakecase", "Transform to Snake Case"),
      alias: "Transform to Snake Case",
      precondition: x.writable
    });
  }
  _modifyText(e, t) {
    const i = Dc.caseBoundary.get(), n = Dc.singleLetters.get();
    return !i || !n ? e : e.replace(i, "$1_$2").replace(n, "$1_$2$3").toLocaleLowerCase();
  }
}
Dc.caseBoundary = new Id("(\\p{Ll})(\\p{Lu})", "gmu");
Dc.singleLetters = new Id("(\\p{Lu}|\\p{N})(\\p{Lu})(\\p{Ll})", "gmu");
class jv extends ug {
  constructor() {
    super({
      id: "editor.action.transformToCamelcase",
      label: p("editor.transformToCamelcase", "Transform to Camel Case"),
      alias: "Transform to Camel Case",
      precondition: x.writable
    });
  }
  _modifyText(e, t) {
    const i = jv.wordBoundary.get();
    if (!i)
      return e;
    const n = e.split(i);
    return n.shift() + n.map((o) => o.substring(0, 1).toLocaleUpperCase() + o.substring(1)).join("");
  }
}
jv.wordBoundary = new Id("[_\\s-]", "gm");
class zu extends ug {
  constructor() {
    super({
      id: "editor.action.transformToPascalcase",
      label: p("editor.transformToPascalcase", "Transform to Pascal Case"),
      alias: "Transform to Pascal Case",
      precondition: x.writable
    });
  }
  _modifyText(e, t) {
    const i = zu.wordBoundary.get(), n = zu.wordBoundaryToMaintain.get();
    return !i || !n ? e : e.split(n).map((a) => a.split(i)).flat().map((a) => a.substring(0, 1).toLocaleUpperCase() + a.substring(1)).join("");
  }
}
zu.wordBoundary = new Id("[_\\s-]", "gm");
zu.wordBoundaryToMaintain = new Id("(?<=\\.)", "gm");
class od extends ug {
  static isSupported() {
    return [
      this.caseBoundary,
      this.singleLetters,
      this.underscoreBoundary
    ].every((t) => t.isSupported());
  }
  constructor() {
    super({
      id: "editor.action.transformToKebabcase",
      label: p("editor.transformToKebabcase", "Transform to Kebab Case"),
      alias: "Transform to Kebab Case",
      precondition: x.writable
    });
  }
  _modifyText(e, t) {
    const i = od.caseBoundary.get(), n = od.singleLetters.get(), s = od.underscoreBoundary.get();
    return !i || !n || !s ? e : e.replace(s, "$1-$3").replace(i, "$1-$2").replace(n, "$1-$2").toLocaleLowerCase();
  }
}
od.caseBoundary = new Id("(\\p{Ll})(\\p{Lu})", "gmu");
od.singleLetters = new Id("(\\p{Lu}|\\p{N})(\\p{Lu}\\p{Ll})", "gmu");
od.underscoreBoundary = new Id("(\\S)(_)(\\S)", "gm");
Y(Wme);
Y(Bme);
Y(Hme);
Y(Vme);
Y(zme);
Y(Ume);
Y($me);
Y(Kme);
Y(nD);
Y(jme);
Y(qme);
Y(Gme);
Y(Zme);
Y(Yme);
Y(Qme);
Y(Xme);
Y(Jme);
Y(e_e);
Y(t_e);
Y(i_e);
Dc.caseBoundary.isSupported() && Dc.singleLetters.isSupported() && Y(Dc);
jv.wordBoundary.isSupported() && Y(jv);
zu.wordBoundary.isSupported() && Y(zu);
Kv.titleBoundary.isSupported() && Y(Kv);
od.isSupported() && Y(od);
var n_e = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, pw = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, tS;
const g$ = new oe("LinkedEditingInputVisible", !1), s_e = "linked-editing-decoration";
let Jc = tS = class extends P {
  static get(e) {
    return e.getContribution(tS.ID);
  }
  constructor(e, t, i, n, s) {
    super(), this.languageConfigurationService = n, this._syncRangesToken = 0, this._localToDispose = this._register(new q()), this._editor = e, this._providers = i.linkedEditingRangeProvider, this._enabled = !1, this._visibleContextKey = g$.bindTo(t), this._debounceInformation = s.for(this._providers, "Linked Editing", { max: 200 }), this._currentDecorations = this._editor.createDecorationsCollection(), this._languageWordPattern = null, this._currentWordPattern = null, this._ignoreChangeEvent = !1, this._localToDispose = this._register(new q()), this._rangeUpdateTriggerPromise = null, this._rangeSyncTriggerPromise = null, this._currentRequestCts = null, this._currentRequestPosition = null, this._currentRequestModelVersion = null, this._register(this._editor.onDidChangeModel(() => this.reinitialize(!0))), this._register(this._editor.onDidChangeConfiguration((o) => {
      (o.hasChanged(
        70
        /* EditorOption.linkedEditing */
      ) || o.hasChanged(
        93
        /* EditorOption.renameOnType */
      )) && this.reinitialize(!1);
    })), this._register(this._providers.onDidChange(() => this.reinitialize(!1))), this._register(this._editor.onDidChangeModelLanguage(() => this.reinitialize(!0))), this.reinitialize(!0);
  }
  reinitialize(e) {
    const t = this._editor.getModel(), i = t !== null && (this._editor.getOption(
      70
      /* EditorOption.linkedEditing */
    ) || this._editor.getOption(
      93
      /* EditorOption.renameOnType */
    )) && this._providers.has(t);
    if (i === this._enabled && !e || (this._enabled = i, this.clearRanges(), this._localToDispose.clear(), !i || t === null))
      return;
    this._localToDispose.add(ne.runAndSubscribe(t.onDidChangeLanguageConfiguration, () => {
      this._languageWordPattern = this.languageConfigurationService.getLanguageConfiguration(t.getLanguageId()).getWordDefinition();
    }));
    const n = new pr(this._debounceInformation.get(t)), s = () => {
      var l;
      this._rangeUpdateTriggerPromise = n.trigger(() => this.updateRanges(), (l = this._debounceDuration) !== null && l !== void 0 ? l : this._debounceInformation.get(t));
    }, o = new pr(0), a = (l) => {
      this._rangeSyncTriggerPromise = o.trigger(() => this._syncRanges(l));
    };
    this._localToDispose.add(this._editor.onDidChangeCursorPosition(() => {
      s();
    })), this._localToDispose.add(this._editor.onDidChangeModelContent((l) => {
      if (!this._ignoreChangeEvent && this._currentDecorations.length > 0) {
        const d = this._currentDecorations.getRange(0);
        if (d && l.changes.every((c) => d.intersectRanges(c.range))) {
          a(this._syncRangesToken);
          return;
        }
      }
      s();
    })), this._localToDispose.add({
      dispose: () => {
        n.dispose(), o.dispose();
      }
    }), this.updateRanges();
  }
  _syncRanges(e) {
    if (!this._editor.hasModel() || e !== this._syncRangesToken || this._currentDecorations.length === 0)
      return;
    const t = this._editor.getModel(), i = this._currentDecorations.getRange(0);
    if (!i || i.startLineNumber !== i.endLineNumber)
      return this.clearRanges();
    const n = t.getValueInRange(i);
    if (this._currentWordPattern) {
      const o = n.match(this._currentWordPattern);
      if ((o ? o[0].length : 0) !== n.length)
        return this.clearRanges();
    }
    const s = [];
    for (let o = 1, a = this._currentDecorations.length; o < a; o++) {
      const l = this._currentDecorations.getRange(o);
      if (l)
        if (l.startLineNumber !== l.endLineNumber)
          s.push({
            range: l,
            text: n
          });
        else {
          let d = t.getValueInRange(l), c = n, h = l.startColumn, u = l.endColumn;
          const g = xc(d, c);
          h += g, d = d.substr(g), c = c.substr(g);
          const f = rS(d, c);
          u -= f, d = d.substr(0, d.length - f), c = c.substr(0, c.length - f), (h !== u || c.length !== 0) && s.push({
            range: new L(l.startLineNumber, h, l.endLineNumber, u),
            text: c
          });
        }
    }
    if (s.length !== 0)
      try {
        this._editor.popUndoStop(), this._ignoreChangeEvent = !0;
        const o = this._editor._getViewModel().getPrevEditOperationType();
        this._editor.executeEdits("linkedEditing", s), this._editor._getViewModel().setPrevEditOperationType(o);
      } finally {
        this._ignoreChangeEvent = !1;
      }
  }
  dispose() {
    this.clearRanges(), super.dispose();
  }
  clearRanges() {
    this._visibleContextKey.set(!1), this._currentDecorations.clear(), this._currentRequestCts && (this._currentRequestCts.cancel(), this._currentRequestCts = null, this._currentRequestPosition = null);
  }
  async updateRanges(e = !1) {
    if (!this._editor.hasModel()) {
      this.clearRanges();
      return;
    }
    const t = this._editor.getPosition();
    if (!this._enabled && !e || this._editor.getSelections().length > 1) {
      this.clearRanges();
      return;
    }
    const i = this._editor.getModel(), n = i.getVersionId();
    if (this._currentRequestPosition && this._currentRequestModelVersion === n) {
      if (t.equals(this._currentRequestPosition))
        return;
      if (this._currentDecorations.length > 0) {
        const o = this._currentDecorations.getRange(0);
        if (o && o.containsPosition(t))
          return;
      }
    }
    this.clearRanges(), this._currentRequestPosition = t, this._currentRequestModelVersion = n;
    const s = this._currentRequestCts = new mi();
    try {
      const o = new rs(!1), a = await f$(this._providers, i, t, s.token);
      if (this._debounceInformation.update(i, o.elapsed()), s !== this._currentRequestCts || (this._currentRequestCts = null, n !== i.getVersionId()))
        return;
      let l = [];
      a != null && a.ranges && (l = a.ranges), this._currentWordPattern = (a == null ? void 0 : a.wordPattern) || this._languageWordPattern;
      let d = !1;
      for (let h = 0, u = l.length; h < u; h++)
        if (L.containsPosition(l[h], t)) {
          if (d = !0, h !== 0) {
            const g = l[h];
            l.splice(h, 1), l.unshift(g);
          }
          break;
        }
      if (!d) {
        this.clearRanges();
        return;
      }
      const c = l.map((h) => ({ range: h, options: tS.DECORATION }));
      this._visibleContextKey.set(!0), this._currentDecorations.set(c), this._syncRangesToken++;
    } catch (o) {
      cl(o) || He(o), (this._currentRequestCts === s || !this._currentRequestCts) && this.clearRanges();
    }
  }
};
Jc.ID = "editor.contrib.linkedEditing";
Jc.DECORATION = Fe.register({
  description: "linked-editing",
  stickiness: 0,
  className: s_e
});
Jc = tS = n_e([
  pw(1, De),
  pw(2, he),
  pw(3, Ot),
  pw(4, Vo)
], Jc);
class o_e extends ae {
  constructor() {
    super({
      id: "editor.action.linkedEditing",
      label: p("linkedEditing.label", "Start Linked Editing"),
      alias: "Start Linked Editing",
      precondition: U.and(x.writable, x.hasRenameProvider),
      kbOpts: {
        kbExpr: x.editorTextFocus,
        primary: 3132,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  runCommand(e, t) {
    const i = e.get(ht), [n, s] = Array.isArray(t) && t || [void 0, void 0];
    return Ee.isUri(n) && A.isIPosition(s) ? i.openCodeEditor({ resource: n }, i.getActiveCodeEditor()).then((o) => {
      o && (o.setPosition(s), o.invokeWithinContext((a) => (this.reportTelemetry(a, o), this.run(a, o))));
    }, He) : super.runCommand(e, t);
  }
  run(e, t) {
    const i = Jc.get(t);
    return i ? Promise.resolve(i.updateRanges(!0)) : Promise.resolve();
  }
}
const r_e = Ui.bindToContribution(Jc.get);
se(new r_e({
  id: "cancelLinkedEditingInput",
  precondition: g$,
  handler: (r) => r.clearRanges(),
  kbOpts: {
    kbExpr: x.editorTextFocus,
    weight: 199,
    primary: 9,
    secondary: [
      1033
      /* KeyCode.Escape */
    ]
  }
}));
function f$(r, e, t, i) {
  const n = r.ordered(e);
  return e1(n.map((s) => async () => {
    try {
      return await s.provideLinkedEditingRanges(e, t, i);
    } catch (o) {
      _i(o);
      return;
    }
  }), (s) => !!s && Rn(s == null ? void 0 : s.ranges));
}
I("editor.linkedEditingBackground", { dark: z.fromHex("#f00").transparent(0.3), light: z.fromHex("#f00").transparent(0.3), hcDark: z.fromHex("#f00").transparent(0.3), hcLight: z.white }, p("editorLinkedEditingBackground", "Background color when the editor auto renames on type."));
ul("_executeLinkedEditingProvider", (r, e, t) => {
  const { linkedEditingRangeProvider: i } = r.get(he);
  return f$(i, e, t, at.None);
});
gt(
  Jc.ID,
  Jc,
  1
  /* EditorContributionInstantiation.AfterFirstRender */
);
Y(o_e);
let a_e = class {
  constructor(e, t) {
    this._link = e, this._provider = t;
  }
  toJSON() {
    return {
      range: this.range,
      url: this.url,
      tooltip: this.tooltip
    };
  }
  get range() {
    return this._link.range;
  }
  get url() {
    return this._link.url;
  }
  get tooltip() {
    return this._link.tooltip;
  }
  async resolve(e) {
    return this._link.url ? this._link.url : typeof this._provider.resolveLink == "function" ? Promise.resolve(this._provider.resolveLink(this._link, e)).then((t) => (this._link = t || this._link, this._link.url ? this.resolve(e) : Promise.reject(new Error("missing")))) : Promise.reject(new Error("missing"));
  }
};
class qy {
  constructor(e) {
    this._disposables = new q();
    let t = [];
    for (const [i, n] of e) {
      const s = i.links.map((o) => new a_e(o, n));
      t = qy._union(t, s), t0(i) && this._disposables.add(i);
    }
    this.links = t;
  }
  dispose() {
    this._disposables.dispose(), this.links.length = 0;
  }
  static _union(e, t) {
    const i = [];
    let n, s, o, a;
    for (n = 0, o = 0, s = e.length, a = t.length; n < s && o < a; ) {
      const l = e[n], d = t[o];
      if (L.areIntersectingOrTouching(l.range, d.range)) {
        n++;
        continue;
      }
      L.compareRangesUsingStarts(l.range, d.range) < 0 ? (i.push(l), n++) : (i.push(d), o++);
    }
    for (; n < s; n++)
      i.push(e[n]);
    for (; o < a; o++)
      i.push(t[o]);
    return i;
  }
}
function p$(r, e, t) {
  const i = [], n = r.ordered(e).reverse().map((s, o) => Promise.resolve(s.provideLinks(e, t)).then((a) => {
    a && (i[o] = [a, s]);
  }, _i));
  return Promise.all(n).then(() => {
    const s = new qy(Yr(i));
    return t.isCancellationRequested ? (s.dispose(), new qy([])) : s;
  });
}
st.registerCommand("_executeLinkProvider", async (r, ...e) => {
  let [t, i] = e;
  ct(t instanceof Ee), typeof i != "number" && (i = 0);
  const { linkProvider: n } = r.get(he), s = r.get(ii).getModel(t);
  if (!s)
    return [];
  const o = await p$(n, s, at.None);
  if (!o)
    return [];
  for (let l = 0; l < Math.min(i, o.links.length); l++)
    await o.links[l].resolve(at.None);
  const a = o.links.slice(0);
  return o.dispose(), a;
});
var l_e = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, mw = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, sN;
let bp = sN = class extends P {
  static get(e) {
    return e.getContribution(sN.ID);
  }
  constructor(e, t, i, n, s) {
    super(), this.editor = e, this.openerService = t, this.notificationService = i, this.languageFeaturesService = n, this.providers = this.languageFeaturesService.linkProvider, this.debounceInformation = s.for(this.providers, "Links", { min: 1e3, max: 4e3 }), this.computeLinks = this._register(new xt(() => this.computeLinksNow(), 1e3)), this.computePromise = null, this.activeLinksList = null, this.currentOccurrences = {}, this.activeLinkDecorationId = null;
    const o = this._register(new xL(e));
    this._register(o.onMouseMoveOrRelevantKeyDown(([a, l]) => {
      this._onEditorMouseMove(a, l);
    })), this._register(o.onExecute((a) => {
      this.onEditorMouseUp(a);
    })), this._register(o.onCancel((a) => {
      this.cleanUpActiveLinkDecoration();
    })), this._register(e.onDidChangeConfiguration((a) => {
      a.hasChanged(
        71
        /* EditorOption.links */
      ) && (this.updateDecorations([]), this.stop(), this.computeLinks.schedule(0));
    })), this._register(e.onDidChangeModelContent((a) => {
      this.editor.hasModel() && this.computeLinks.schedule(this.debounceInformation.get(this.editor.getModel()));
    })), this._register(e.onDidChangeModel((a) => {
      this.currentOccurrences = {}, this.activeLinkDecorationId = null, this.stop(), this.computeLinks.schedule(0);
    })), this._register(e.onDidChangeModelLanguage((a) => {
      this.stop(), this.computeLinks.schedule(0);
    })), this._register(this.providers.onDidChange((a) => {
      this.stop(), this.computeLinks.schedule(0);
    })), this.computeLinks.schedule(0);
  }
  async computeLinksNow() {
    if (!this.editor.hasModel() || !this.editor.getOption(
      71
      /* EditorOption.links */
    ))
      return;
    const e = this.editor.getModel();
    if (!e.isTooLargeForSyncing() && this.providers.has(e)) {
      this.activeLinksList && (this.activeLinksList.dispose(), this.activeLinksList = null), this.computePromise = Zi((t) => p$(this.providers, e, t));
      try {
        const t = new rs(!1);
        if (this.activeLinksList = await this.computePromise, this.debounceInformation.update(e, t.elapsed()), e.isDisposed())
          return;
        this.updateDecorations(this.activeLinksList.links);
      } catch (t) {
        He(t);
      } finally {
        this.computePromise = null;
      }
    }
  }
  updateDecorations(e) {
    const t = this.editor.getOption(
      78
      /* EditorOption.multiCursorModifier */
    ) === "altKey", i = [], n = Object.keys(this.currentOccurrences);
    for (const o of n) {
      const a = this.currentOccurrences[o];
      i.push(a.decorationId);
    }
    const s = [];
    if (e)
      for (const o of e)
        s.push(Rf.decoration(o, t));
    this.editor.changeDecorations((o) => {
      const a = o.deltaDecorations(i, s);
      this.currentOccurrences = {}, this.activeLinkDecorationId = null;
      for (let l = 0, d = a.length; l < d; l++) {
        const c = new Rf(e[l], a[l]);
        this.currentOccurrences[c.decorationId] = c;
      }
    });
  }
  _onEditorMouseMove(e, t) {
    const i = this.editor.getOption(
      78
      /* EditorOption.multiCursorModifier */
    ) === "altKey";
    if (this.isEnabled(e, t)) {
      this.cleanUpActiveLinkDecoration();
      const n = this.getLinkOccurrence(e.target.position);
      n && this.editor.changeDecorations((s) => {
        n.activate(s, i), this.activeLinkDecorationId = n.decorationId;
      });
    } else
      this.cleanUpActiveLinkDecoration();
  }
  cleanUpActiveLinkDecoration() {
    const e = this.editor.getOption(
      78
      /* EditorOption.multiCursorModifier */
    ) === "altKey";
    if (this.activeLinkDecorationId) {
      const t = this.currentOccurrences[this.activeLinkDecorationId];
      t && this.editor.changeDecorations((i) => {
        t.deactivate(i, e);
      }), this.activeLinkDecorationId = null;
    }
  }
  onEditorMouseUp(e) {
    if (!this.isEnabled(e))
      return;
    const t = this.getLinkOccurrence(e.target.position);
    t && this.openLinkOccurrence(
      t,
      e.hasSideBySideModifier,
      !0
      /* from user gesture */
    );
  }
  openLinkOccurrence(e, t, i = !1) {
    if (!this.openerService)
      return;
    const { link: n } = e;
    n.resolve(at.None).then((s) => {
      if (typeof s == "string" && this.editor.hasModel()) {
        const o = this.editor.getModel().uri;
        if (o.scheme === Ne.file && s.startsWith(`${Ne.file}:`)) {
          const a = Ee.parse(s);
          if (a.scheme === Ne.file) {
            const l = Sa(a);
            let d = null;
            l.startsWith("/./") || l.startsWith("\\.\\") ? d = `.${l.substr(1)}` : (l.startsWith("//./") || l.startsWith("\\\\.\\")) && (d = `.${l.substr(2)}`), d && (s = hQ(o, d));
          }
        }
      }
      return this.openerService.open(s, { openToSide: t, fromUserGesture: i, allowContributedOpeners: !0, allowCommands: !0, fromWorkspace: !0 });
    }, (s) => {
      const o = s instanceof Error ? s.message : s;
      o === "invalid" ? this.notificationService.warn(p("invalid.url", "Failed to open this link because it is not well-formed: {0}", n.url.toString())) : o === "missing" ? this.notificationService.warn(p("missing.url", "Failed to open this link because its target is missing.")) : He(s);
    });
  }
  getLinkOccurrence(e) {
    if (!this.editor.hasModel() || !e)
      return null;
    const t = this.editor.getModel().getDecorationsInRange({
      startLineNumber: e.lineNumber,
      startColumn: e.column,
      endLineNumber: e.lineNumber,
      endColumn: e.column
    }, 0, !0);
    for (const i of t) {
      const n = this.currentOccurrences[i.id];
      if (n)
        return n;
    }
    return null;
  }
  isEnabled(e, t) {
    return !!(e.target.type === 6 && (e.hasTriggerModifier || t && t.keyCodeIsTriggerKey));
  }
  stop() {
    var e;
    this.computeLinks.cancel(), this.activeLinksList && ((e = this.activeLinksList) === null || e === void 0 || e.dispose(), this.activeLinksList = null), this.computePromise && (this.computePromise.cancel(), this.computePromise = null);
  }
  dispose() {
    super.dispose(), this.stop();
  }
};
bp.ID = "editor.linkDetector";
bp = sN = l_e([
  mw(1, Ys),
  mw(2, xi),
  mw(3, he),
  mw(4, Vo)
], bp);
const SB = {
  general: Fe.register({
    description: "detected-link",
    stickiness: 1,
    collapseOnReplaceEdit: !0,
    inlineClassName: "detected-link"
  }),
  active: Fe.register({
    description: "detected-link-active",
    stickiness: 1,
    collapseOnReplaceEdit: !0,
    inlineClassName: "detected-link-active"
  })
};
class Rf {
  static decoration(e, t) {
    return {
      range: e.range,
      options: Rf._getOptions(e, t, !1)
    };
  }
  static _getOptions(e, t, i) {
    const n = { ...i ? SB.active : SB.general };
    return n.hoverMessage = d_e(e, t), n;
  }
  constructor(e, t) {
    this.link = e, this.decorationId = t;
  }
  activate(e, t) {
    e.changeDecorationOptions(this.decorationId, Rf._getOptions(this.link, t, !0));
  }
  deactivate(e, t) {
    e.changeDecorationOptions(this.decorationId, Rf._getOptions(this.link, t, !1));
  }
}
function d_e(r, e) {
  const t = r.url && /^command:/i.test(r.url.toString()), i = r.tooltip ? r.tooltip : t ? p("links.navigate.executeCmd", "Execute command") : p("links.navigate.follow", "Follow link"), n = e ? Je ? p("links.navigate.kb.meta.mac", "cmd + click") : p("links.navigate.kb.meta", "ctrl + click") : Je ? p("links.navigate.kb.alt.mac", "option + click") : p("links.navigate.kb.alt", "alt + click");
  if (r.url) {
    let s = "";
    if (/^command:/i.test(r.url.toString())) {
      const a = r.url.toString().match(/^command:([^?#]+)/);
      if (a) {
        const l = a[1];
        s = p("tooltip.explanation", "Execute command {0}", l);
      }
    }
    return new Nn("", !0).appendLink(r.url.toString(!0).replace(/ /g, "%20"), i, s).appendMarkdown(` (${n})`);
  } else
    return new Nn().appendText(`${i} (${n})`);
}
class c_e extends ae {
  constructor() {
    super({
      id: "editor.action.openLink",
      label: p("label", "Open Link"),
      alias: "Open Link",
      precondition: void 0
    });
  }
  run(e, t) {
    const i = bp.get(t);
    if (!i || !t.hasModel())
      return;
    const n = t.getSelections();
    for (const s of n) {
      const o = i.getLinkOccurrence(s.getEndPosition());
      o && i.openLinkOccurrence(o, !1);
    }
  }
}
gt(
  bp.ID,
  bp,
  1
  /* EditorContributionInstantiation.AfterFirstRender */
);
Y(c_e);
class oN extends P {
  constructor(e) {
    super(), this._editor = e, this._register(this._editor.onMouseDown((t) => {
      const i = this._editor.getOption(
        117
        /* EditorOption.stopRenderingLineAfter */
      );
      i >= 0 && t.target.type === 6 && t.target.position.column >= i && this._editor.updateOptions({
        stopRenderingLineAfter: -1
      });
    }));
  }
}
oN.ID = "editor.contrib.longLinesHelper";
gt(
  oN.ID,
  oN,
  2
  /* EditorContributionInstantiation.BeforeFirstInteraction */
);
const _w = I("editor.wordHighlightBackground", { dark: "#575757B8", light: "#57575740", hcDark: null, hcLight: null }, p("wordHighlight", "Background color of a symbol during read-access, like reading a variable. The color must not be opaque so as not to hide underlying decorations."), !0);
I("editor.wordHighlightStrongBackground", { dark: "#004972B8", light: "#0e639c40", hcDark: null, hcLight: null }, p("wordHighlightStrong", "Background color of a symbol during write-access, like writing to a variable. The color must not be opaque so as not to hide underlying decorations."), !0);
I("editor.wordHighlightTextBackground", { light: _w, dark: _w, hcDark: _w, hcLight: _w }, p("wordHighlightText", "Background color of a textual occurrence for a symbol. The color must not be opaque so as not to hide underlying decorations."), !0);
const vw = I("editor.wordHighlightBorder", { light: null, dark: null, hcDark: Gt, hcLight: Gt }, p("wordHighlightBorder", "Border color of a symbol during read-access, like reading a variable."));
I("editor.wordHighlightStrongBorder", { light: null, dark: null, hcDark: Gt, hcLight: Gt }, p("wordHighlightStrongBorder", "Border color of a symbol during write-access, like writing to a variable."));
I("editor.wordHighlightTextBorder", { light: vw, dark: vw, hcDark: vw, hcLight: vw }, p("wordHighlightTextBorder", "Border color of a textual occurrence for a symbol."));
const h_e = I("editorOverviewRuler.wordHighlightForeground", { dark: "#A0A0A0CC", light: "#A0A0A0CC", hcDark: "#A0A0A0CC", hcLight: "#A0A0A0CC" }, p("overviewRulerWordHighlightForeground", "Overview ruler marker color for symbol highlights. The color must not be opaque so as not to hide underlying decorations."), !0), u_e = I("editorOverviewRuler.wordHighlightStrongForeground", { dark: "#C0A0C0CC", light: "#C0A0C0CC", hcDark: "#C0A0C0CC", hcLight: "#C0A0C0CC" }, p("overviewRulerWordHighlightStrongForeground", "Overview ruler marker color for write-access symbol highlights. The color must not be opaque so as not to hide underlying decorations."), !0), g_e = I("editorOverviewRuler.wordHighlightTextForeground", { dark: Em, light: Em, hcDark: Em, hcLight: Em }, p("overviewRulerWordHighlightTextForeground", "Overview ruler marker color of a textual occurrence for a symbol. The color must not be opaque so as not to hide underlying decorations."), !0), f_e = Fe.register({
  description: "word-highlight-strong",
  stickiness: 1,
  className: "wordHighlightStrong",
  overviewRuler: {
    color: ai(u_e),
    position: _r.Center
  },
  minimap: {
    color: ai(D0),
    position: 1
    /* MinimapPosition.Inline */
  }
}), p_e = Fe.register({
  description: "word-highlight-text",
  stickiness: 1,
  className: "wordHighlightText",
  overviewRuler: {
    color: ai(g_e),
    position: _r.Center
  },
  minimap: {
    color: ai(D0),
    position: 1
    /* MinimapPosition.Inline */
  }
}), m_e = Fe.register({
  description: "selection-highlight-overview",
  stickiness: 1,
  className: "selectionHighlight",
  overviewRuler: {
    color: ai(Em),
    position: _r.Center
  },
  minimap: {
    color: ai(D0),
    position: 1
    /* MinimapPosition.Inline */
  }
}), __e = Fe.register({
  description: "selection-highlight",
  stickiness: 1,
  className: "selectionHighlight"
}), v_e = Fe.register({
  description: "word-highlight",
  stickiness: 1,
  className: "wordHighlight",
  overviewRuler: {
    color: ai(h_e),
    position: _r.Center
  },
  minimap: {
    color: ai(D0),
    position: 1
    /* MinimapPosition.Inline */
  }
});
function b_e(r) {
  return r === Cx.Write ? f_e : r === Cx.Text ? p_e : v_e;
}
function C_e(r) {
  return r ? __e : m_e;
}
Ho((r, e) => {
  const t = r.getColor(b1);
  t && e.addRule(`.monaco-editor .selectionHighlight { background-color: ${t.transparent(0.5)}; }`);
});
var w_e = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, S_e = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, rN;
function lh(r, e) {
  const t = e.filter((i) => !r.find((n) => n.equals(i)));
  if (t.length >= 1) {
    const i = t.map((s) => `line ${s.viewState.position.lineNumber} column ${s.viewState.position.column}`).join(", "), n = t.length === 1 ? p("cursorAdded", "Cursor added: {0}", i) : p("cursorsAdded", "Cursors added: {0}", i);
    el(n);
  }
}
class y_e extends ae {
  constructor() {
    super({
      id: "editor.action.insertCursorAbove",
      label: p("mutlicursor.insertAbove", "Add Cursor Above"),
      alias: "Add Cursor Above",
      precondition: void 0,
      kbOpts: {
        kbExpr: x.editorTextFocus,
        primary: 2576,
        linux: {
          primary: 1552,
          secondary: [
            3088
            /* KeyCode.UpArrow */
          ]
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: D.MenubarSelectionMenu,
        group: "3_multi",
        title: p({ key: "miInsertCursorAbove", comment: ["&& denotes a mnemonic"] }, "&&Add Cursor Above"),
        order: 2
      }
    });
  }
  run(e, t, i) {
    if (!t.hasModel())
      return;
    let n = !0;
    i && i.logicalLine === !1 && (n = !1);
    const s = t._getViewModel();
    if (s.cursorConfig.readOnly)
      return;
    s.model.pushStackElement();
    const o = s.getCursorStates();
    s.setCursorStates(i.source, 3, cn.addCursorUp(s, o, n)), s.revealTopMostCursor(i.source), lh(o, s.getCursorStates());
  }
}
class L_e extends ae {
  constructor() {
    super({
      id: "editor.action.insertCursorBelow",
      label: p("mutlicursor.insertBelow", "Add Cursor Below"),
      alias: "Add Cursor Below",
      precondition: void 0,
      kbOpts: {
        kbExpr: x.editorTextFocus,
        primary: 2578,
        linux: {
          primary: 1554,
          secondary: [
            3090
            /* KeyCode.DownArrow */
          ]
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: D.MenubarSelectionMenu,
        group: "3_multi",
        title: p({ key: "miInsertCursorBelow", comment: ["&& denotes a mnemonic"] }, "A&&dd Cursor Below"),
        order: 3
      }
    });
  }
  run(e, t, i) {
    if (!t.hasModel())
      return;
    let n = !0;
    i && i.logicalLine === !1 && (n = !1);
    const s = t._getViewModel();
    if (s.cursorConfig.readOnly)
      return;
    s.model.pushStackElement();
    const o = s.getCursorStates();
    s.setCursorStates(i.source, 3, cn.addCursorDown(s, o, n)), s.revealBottomMostCursor(i.source), lh(o, s.getCursorStates());
  }
}
class D_e extends ae {
  constructor() {
    super({
      id: "editor.action.insertCursorAtEndOfEachLineSelected",
      label: p("mutlicursor.insertAtEndOfEachLineSelected", "Add Cursors to Line Ends"),
      alias: "Add Cursors to Line Ends",
      precondition: void 0,
      kbOpts: {
        kbExpr: x.editorTextFocus,
        primary: 1575,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: D.MenubarSelectionMenu,
        group: "3_multi",
        title: p({ key: "miInsertCursorAtEndOfEachLineSelected", comment: ["&& denotes a mnemonic"] }, "Add C&&ursors to Line Ends"),
        order: 4
      }
    });
  }
  getCursorsForSelection(e, t, i) {
    if (!e.isEmpty()) {
      for (let n = e.startLineNumber; n < e.endLineNumber; n++) {
        const s = t.getLineMaxColumn(n);
        i.push(new ge(n, s, n, s));
      }
      e.endColumn > 1 && i.push(new ge(e.endLineNumber, e.endColumn, e.endLineNumber, e.endColumn));
    }
  }
  run(e, t) {
    if (!t.hasModel())
      return;
    const i = t.getModel(), n = t.getSelections(), s = t._getViewModel(), o = s.getCursorStates(), a = [];
    n.forEach((l) => this.getCursorsForSelection(l, i, a)), a.length > 0 && t.setSelections(a), lh(o, s.getCursorStates());
  }
}
class k_e extends ae {
  constructor() {
    super({
      id: "editor.action.addCursorsToBottom",
      label: p("mutlicursor.addCursorsToBottom", "Add Cursors To Bottom"),
      alias: "Add Cursors To Bottom",
      precondition: void 0
    });
  }
  run(e, t) {
    if (!t.hasModel())
      return;
    const i = t.getSelections(), n = t.getModel().getLineCount(), s = [];
    for (let l = i[0].startLineNumber; l <= n; l++)
      s.push(new ge(l, i[0].startColumn, l, i[0].endColumn));
    const o = t._getViewModel(), a = o.getCursorStates();
    s.length > 0 && t.setSelections(s), lh(a, o.getCursorStates());
  }
}
class x_e extends ae {
  constructor() {
    super({
      id: "editor.action.addCursorsToTop",
      label: p("mutlicursor.addCursorsToTop", "Add Cursors To Top"),
      alias: "Add Cursors To Top",
      precondition: void 0
    });
  }
  run(e, t) {
    if (!t.hasModel())
      return;
    const i = t.getSelections(), n = [];
    for (let a = i[0].startLineNumber; a >= 1; a--)
      n.push(new ge(a, i[0].startColumn, a, i[0].endColumn));
    const s = t._getViewModel(), o = s.getCursorStates();
    n.length > 0 && t.setSelections(n), lh(o, s.getCursorStates());
  }
}
class bw {
  constructor(e, t, i) {
    this.selections = e, this.revealRange = t, this.revealScrollType = i;
  }
}
class qv {
  static create(e, t) {
    if (!e.hasModel())
      return null;
    const i = t.getState();
    if (!e.hasTextFocus() && i.isRevealed && i.searchString.length > 0)
      return new qv(e, t, !1, i.searchString, i.wholeWord, i.matchCase, null);
    let n = !1, s, o;
    const a = e.getSelections();
    a.length === 1 && a[0].isEmpty() ? (n = !0, s = !0, o = !0) : (s = i.wholeWord, o = i.matchCase);
    const l = e.getSelection();
    let d, c = null;
    if (l.isEmpty()) {
      const h = e.getConfiguredWordAtPosition(l.getStartPosition());
      if (!h)
        return null;
      d = h.word, c = new ge(l.startLineNumber, h.startColumn, l.startLineNumber, h.endColumn);
    } else
      d = e.getModel().getValueInRange(l).replace(/\r\n/g, `
`);
    return new qv(e, t, n, d, s, o, c);
  }
  constructor(e, t, i, n, s, o, a) {
    this._editor = e, this.findController = t, this.isDisconnectedFromFindController = i, this.searchText = n, this.wholeWord = s, this.matchCase = o, this.currentMatch = a;
  }
  addSelectionToNextFindMatch() {
    if (!this._editor.hasModel())
      return null;
    const e = this._getNextMatch();
    if (!e)
      return null;
    const t = this._editor.getSelections();
    return new bw(
      t.concat(e),
      e,
      0
      /* ScrollType.Smooth */
    );
  }
  moveSelectionToNextFindMatch() {
    if (!this._editor.hasModel())
      return null;
    const e = this._getNextMatch();
    if (!e)
      return null;
    const t = this._editor.getSelections();
    return new bw(
      t.slice(0, t.length - 1).concat(e),
      e,
      0
      /* ScrollType.Smooth */
    );
  }
  _getNextMatch() {
    if (!this._editor.hasModel())
      return null;
    if (this.currentMatch) {
      const n = this.currentMatch;
      return this.currentMatch = null, n;
    }
    this.findController.highlightFindOptions();
    const e = this._editor.getSelections(), t = e[e.length - 1], i = this._editor.getModel().findNextMatch(this.searchText, t.getEndPosition(), !1, this.matchCase, this.wholeWord ? this._editor.getOption(
      131
      /* EditorOption.wordSeparators */
    ) : null, !1);
    return i ? new ge(i.range.startLineNumber, i.range.startColumn, i.range.endLineNumber, i.range.endColumn) : null;
  }
  addSelectionToPreviousFindMatch() {
    if (!this._editor.hasModel())
      return null;
    const e = this._getPreviousMatch();
    if (!e)
      return null;
    const t = this._editor.getSelections();
    return new bw(
      t.concat(e),
      e,
      0
      /* ScrollType.Smooth */
    );
  }
  moveSelectionToPreviousFindMatch() {
    if (!this._editor.hasModel())
      return null;
    const e = this._getPreviousMatch();
    if (!e)
      return null;
    const t = this._editor.getSelections();
    return new bw(
      t.slice(0, t.length - 1).concat(e),
      e,
      0
      /* ScrollType.Smooth */
    );
  }
  _getPreviousMatch() {
    if (!this._editor.hasModel())
      return null;
    if (this.currentMatch) {
      const n = this.currentMatch;
      return this.currentMatch = null, n;
    }
    this.findController.highlightFindOptions();
    const e = this._editor.getSelections(), t = e[e.length - 1], i = this._editor.getModel().findPreviousMatch(this.searchText, t.getStartPosition(), !1, this.matchCase, this.wholeWord ? this._editor.getOption(
      131
      /* EditorOption.wordSeparators */
    ) : null, !1);
    return i ? new ge(i.range.startLineNumber, i.range.startColumn, i.range.endLineNumber, i.range.endColumn) : null;
  }
  selectAll(e) {
    if (!this._editor.hasModel())
      return [];
    this.findController.highlightFindOptions();
    const t = this._editor.getModel();
    return e ? t.findMatches(
      this.searchText,
      e,
      !1,
      this.matchCase,
      this.wholeWord ? this._editor.getOption(
        131
        /* EditorOption.wordSeparators */
      ) : null,
      !1,
      1073741824
      /* Constants.MAX_SAFE_SMALL_INTEGER */
    ) : t.findMatches(
      this.searchText,
      !0,
      !1,
      this.matchCase,
      this.wholeWord ? this._editor.getOption(
        131
        /* EditorOption.wordSeparators */
      ) : null,
      !1,
      1073741824
      /* Constants.MAX_SAFE_SMALL_INTEGER */
    );
  }
}
class Uu extends P {
  static get(e) {
    return e.getContribution(Uu.ID);
  }
  constructor(e) {
    super(), this._sessionDispose = this._register(new q()), this._editor = e, this._ignoreSelectionChange = !1, this._session = null;
  }
  dispose() {
    this._endSession(), super.dispose();
  }
  _beginSessionIfNeeded(e) {
    if (!this._session) {
      const t = qv.create(this._editor, e);
      if (!t)
        return;
      this._session = t;
      const i = { searchString: this._session.searchText };
      this._session.isDisconnectedFromFindController && (i.wholeWordOverride = 1, i.matchCaseOverride = 1, i.isRegexOverride = 2), e.getState().change(i, !1), this._sessionDispose.add(this._editor.onDidChangeCursorSelection((n) => {
        this._ignoreSelectionChange || this._endSession();
      })), this._sessionDispose.add(this._editor.onDidBlurEditorText(() => {
        this._endSession();
      })), this._sessionDispose.add(e.getState().onFindReplaceStateChange((n) => {
        (n.matchCase || n.wholeWord) && this._endSession();
      }));
    }
  }
  _endSession() {
    if (this._sessionDispose.clear(), this._session && this._session.isDisconnectedFromFindController) {
      const e = {
        wholeWordOverride: 0,
        matchCaseOverride: 0,
        isRegexOverride: 0
      };
      this._session.findController.getState().change(e, !1);
    }
    this._session = null;
  }
  _setSelections(e) {
    this._ignoreSelectionChange = !0, this._editor.setSelections(e), this._ignoreSelectionChange = !1;
  }
  _expandEmptyToWord(e, t) {
    if (!t.isEmpty())
      return t;
    const i = this._editor.getConfiguredWordAtPosition(t.getStartPosition());
    return i ? new ge(t.startLineNumber, i.startColumn, t.startLineNumber, i.endColumn) : t;
  }
  _applySessionResult(e) {
    e && (this._setSelections(e.selections), e.revealRange && this._editor.revealRangeInCenterIfOutsideViewport(e.revealRange, e.revealScrollType));
  }
  getSession(e) {
    return this._session;
  }
  addSelectionToNextFindMatch(e) {
    if (this._editor.hasModel()) {
      if (!this._session) {
        const t = this._editor.getSelections();
        if (t.length > 1) {
          const n = e.getState().matchCase;
          if (!m$(this._editor.getModel(), t, n)) {
            const o = this._editor.getModel(), a = [];
            for (let l = 0, d = t.length; l < d; l++)
              a[l] = this._expandEmptyToWord(o, t[l]);
            this._editor.setSelections(a);
            return;
          }
        }
      }
      this._beginSessionIfNeeded(e), this._session && this._applySessionResult(this._session.addSelectionToNextFindMatch());
    }
  }
  addSelectionToPreviousFindMatch(e) {
    this._beginSessionIfNeeded(e), this._session && this._applySessionResult(this._session.addSelectionToPreviousFindMatch());
  }
  moveSelectionToNextFindMatch(e) {
    this._beginSessionIfNeeded(e), this._session && this._applySessionResult(this._session.moveSelectionToNextFindMatch());
  }
  moveSelectionToPreviousFindMatch(e) {
    this._beginSessionIfNeeded(e), this._session && this._applySessionResult(this._session.moveSelectionToPreviousFindMatch());
  }
  selectAll(e) {
    if (!this._editor.hasModel())
      return;
    let t = null;
    const i = e.getState();
    if (i.isRevealed && i.searchString.length > 0 && i.isRegex) {
      const n = this._editor.getModel();
      i.searchScope ? t = n.findMatches(
        i.searchString,
        i.searchScope,
        i.isRegex,
        i.matchCase,
        i.wholeWord ? this._editor.getOption(
          131
          /* EditorOption.wordSeparators */
        ) : null,
        !1,
        1073741824
        /* Constants.MAX_SAFE_SMALL_INTEGER */
      ) : t = n.findMatches(
        i.searchString,
        !0,
        i.isRegex,
        i.matchCase,
        i.wholeWord ? this._editor.getOption(
          131
          /* EditorOption.wordSeparators */
        ) : null,
        !1,
        1073741824
        /* Constants.MAX_SAFE_SMALL_INTEGER */
      );
    } else {
      if (this._beginSessionIfNeeded(e), !this._session)
        return;
      t = this._session.selectAll(i.searchScope);
    }
    if (t.length > 0) {
      const n = this._editor.getSelection();
      for (let s = 0, o = t.length; s < o; s++) {
        const a = t[s];
        if (a.range.intersectRanges(n)) {
          t[s] = t[0], t[0] = a;
          break;
        }
      }
      this._setSelections(t.map((s) => new ge(s.range.startLineNumber, s.range.startColumn, s.range.endLineNumber, s.range.endColumn)));
    }
  }
}
Uu.ID = "editor.contrib.multiCursorController";
class $p extends ae {
  run(e, t) {
    const i = Uu.get(t);
    if (!i)
      return;
    const n = t._getViewModel();
    if (n) {
      const s = n.getCursorStates(), o = ds.get(t);
      if (o)
        this._run(i, o);
      else {
        const a = e.get(be).createInstance(ds, t);
        this._run(i, a), a.dispose();
      }
      lh(s, n.getCursorStates());
    }
  }
}
class I_e extends $p {
  constructor() {
    super({
      id: "editor.action.addSelectionToNextFindMatch",
      label: p("addSelectionToNextFindMatch", "Add Selection To Next Find Match"),
      alias: "Add Selection To Next Find Match",
      precondition: void 0,
      kbOpts: {
        kbExpr: x.focus,
        primary: 2082,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: D.MenubarSelectionMenu,
        group: "3_multi",
        title: p({ key: "miAddSelectionToNextFindMatch", comment: ["&& denotes a mnemonic"] }, "Add &&Next Occurrence"),
        order: 5
      }
    });
  }
  _run(e, t) {
    e.addSelectionToNextFindMatch(t);
  }
}
class E_e extends $p {
  constructor() {
    super({
      id: "editor.action.addSelectionToPreviousFindMatch",
      label: p("addSelectionToPreviousFindMatch", "Add Selection To Previous Find Match"),
      alias: "Add Selection To Previous Find Match",
      precondition: void 0,
      menuOpts: {
        menuId: D.MenubarSelectionMenu,
        group: "3_multi",
        title: p({ key: "miAddSelectionToPreviousFindMatch", comment: ["&& denotes a mnemonic"] }, "Add P&&revious Occurrence"),
        order: 6
      }
    });
  }
  _run(e, t) {
    e.addSelectionToPreviousFindMatch(t);
  }
}
class T_e extends $p {
  constructor() {
    super({
      id: "editor.action.moveSelectionToNextFindMatch",
      label: p("moveSelectionToNextFindMatch", "Move Last Selection To Next Find Match"),
      alias: "Move Last Selection To Next Find Match",
      precondition: void 0,
      kbOpts: {
        kbExpr: x.focus,
        primary: zi(
          2089,
          2082
          /* KeyCode.KeyD */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  _run(e, t) {
    e.moveSelectionToNextFindMatch(t);
  }
}
class N_e extends $p {
  constructor() {
    super({
      id: "editor.action.moveSelectionToPreviousFindMatch",
      label: p("moveSelectionToPreviousFindMatch", "Move Last Selection To Previous Find Match"),
      alias: "Move Last Selection To Previous Find Match",
      precondition: void 0
    });
  }
  _run(e, t) {
    e.moveSelectionToPreviousFindMatch(t);
  }
}
class M_e extends $p {
  constructor() {
    super({
      id: "editor.action.selectHighlights",
      label: p("selectAllOccurrencesOfFindMatch", "Select All Occurrences of Find Match"),
      alias: "Select All Occurrences of Find Match",
      precondition: void 0,
      kbOpts: {
        kbExpr: x.focus,
        primary: 3114,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: D.MenubarSelectionMenu,
        group: "3_multi",
        title: p({ key: "miSelectHighlights", comment: ["&& denotes a mnemonic"] }, "Select All &&Occurrences"),
        order: 7
      }
    });
  }
  _run(e, t) {
    e.selectAll(t);
  }
}
class R_e extends $p {
  constructor() {
    super({
      id: "editor.action.changeAll",
      label: p("changeAll.label", "Change All Occurrences"),
      alias: "Change All Occurrences",
      precondition: U.and(x.writable, x.editorTextFocus),
      kbOpts: {
        kbExpr: x.editorTextFocus,
        primary: 2108,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      contextMenuOpts: {
        group: "1_modification",
        order: 1.2
      }
    });
  }
  _run(e, t) {
    e.selectAll(t);
  }
}
class A_e {
  constructor(e, t, i, n, s) {
    this._model = e, this._searchText = t, this._matchCase = i, this._wordSeparators = n, this._modelVersionId = this._model.getVersionId(), this._cachedFindMatches = null, s && this._model === s._model && this._searchText === s._searchText && this._matchCase === s._matchCase && this._wordSeparators === s._wordSeparators && this._modelVersionId === s._modelVersionId && (this._cachedFindMatches = s._cachedFindMatches);
  }
  findMatches() {
    return this._cachedFindMatches === null && (this._cachedFindMatches = this._model.findMatches(this._searchText, !0, !1, this._matchCase, this._wordSeparators, !1).map((e) => e.range), this._cachedFindMatches.sort(L.compareRangesUsingStarts)), this._cachedFindMatches;
  }
}
let Gv = rN = class extends P {
  constructor(e, t) {
    super(), this._languageFeaturesService = t, this.editor = e, this._isEnabled = e.getOption(
      108
      /* EditorOption.selectionHighlight */
    ), this._decorations = e.createDecorationsCollection(), this.updateSoon = this._register(new xt(() => this._update(), 300)), this.state = null, this._register(e.onDidChangeConfiguration((n) => {
      this._isEnabled = e.getOption(
        108
        /* EditorOption.selectionHighlight */
      );
    })), this._register(e.onDidChangeCursorSelection((n) => {
      this._isEnabled && (n.selection.isEmpty() ? n.reason === 3 ? (this.state && this._setState(null), this.updateSoon.schedule()) : this._setState(null) : this._update());
    })), this._register(e.onDidChangeModel((n) => {
      this._setState(null);
    })), this._register(e.onDidChangeModelContent((n) => {
      this._isEnabled && this.updateSoon.schedule();
    }));
    const i = ds.get(e);
    i && this._register(i.getState().onFindReplaceStateChange((n) => {
      this._update();
    })), this.updateSoon.schedule();
  }
  _update() {
    this._setState(rN._createState(this.state, this._isEnabled, this.editor));
  }
  static _createState(e, t, i) {
    if (!t || !i.hasModel())
      return null;
    const n = i.getSelection();
    if (n.startLineNumber !== n.endLineNumber)
      return null;
    const s = Uu.get(i);
    if (!s)
      return null;
    const o = ds.get(i);
    if (!o)
      return null;
    let a = s.getSession(o);
    if (!a) {
      const c = i.getSelections();
      if (c.length > 1) {
        const u = o.getState().matchCase;
        if (!m$(i.getModel(), c, u))
          return null;
      }
      a = qv.create(i, o);
    }
    if (!a || a.currentMatch || /^[ \t]+$/.test(a.searchText) || a.searchText.length > 200)
      return null;
    const l = o.getState(), d = l.matchCase;
    if (l.isRevealed) {
      let c = l.searchString;
      d || (c = c.toLowerCase());
      let h = a.searchText;
      if (d || (h = h.toLowerCase()), c === h && a.matchCase === l.matchCase && a.wholeWord === l.wholeWord && !l.isRegex)
        return null;
    }
    return new A_e(i.getModel(), a.searchText, a.matchCase, a.wholeWord ? i.getOption(
      131
      /* EditorOption.wordSeparators */
    ) : null, e);
  }
  _setState(e) {
    if (this.state = e, !this.state) {
      this._decorations.clear();
      return;
    }
    if (!this.editor.hasModel())
      return;
    const t = this.editor.getModel();
    if (t.isTooLargeForTokenization())
      return;
    const i = this.state.findMatches(), n = this.editor.getSelections();
    n.sort(L.compareRangesUsingStarts);
    const s = [];
    for (let d = 0, c = 0, h = i.length, u = n.length; d < h; ) {
      const g = i[d];
      if (c >= u)
        s.push(g), d++;
      else {
        const f = L.compareRangesUsingStarts(g, n[c]);
        f < 0 ? ((n[c].isEmpty() || !L.areIntersecting(g, n[c])) && s.push(g), d++) : (f > 0 || d++, c++);
      }
    }
    const o = this.editor.getOption(
      81
      /* EditorOption.occurrencesHighlight */
    ) !== "off", a = this._languageFeaturesService.documentHighlightProvider.has(t) && o, l = s.map((d) => ({
      range: d,
      options: C_e(a)
    }));
    this._decorations.set(l);
  }
  dispose() {
    this._setState(null), super.dispose();
  }
};
Gv.ID = "editor.contrib.selectionHighlighter";
Gv = rN = w_e([
  S_e(1, he)
], Gv);
function m$(r, e, t) {
  const i = yB(r, e[0], !t);
  for (let n = 1, s = e.length; n < s; n++) {
    const o = e[n];
    if (o.isEmpty())
      return !1;
    const a = yB(r, o, !t);
    if (i !== a)
      return !1;
  }
  return !0;
}
function yB(r, e, t) {
  const i = r.getValueInRange(e);
  return t ? i.toLowerCase() : i;
}
class P_e extends ae {
  constructor() {
    super({
      id: "editor.action.focusNextCursor",
      label: p("mutlicursor.focusNextCursor", "Focus Next Cursor"),
      metadata: {
        description: p("mutlicursor.focusNextCursor.description", "Focuses the next cursor"),
        args: []
      },
      alias: "Focus Next Cursor",
      precondition: void 0
    });
  }
  run(e, t, i) {
    if (!t.hasModel())
      return;
    const n = t._getViewModel();
    if (n.cursorConfig.readOnly)
      return;
    n.model.pushStackElement();
    const s = Array.from(n.getCursorStates()), o = s.shift();
    o && (s.push(o), n.setCursorStates(i.source, 3, s), n.revealPrimaryCursor(i.source, !0), lh(s, n.getCursorStates()));
  }
}
class O_e extends ae {
  constructor() {
    super({
      id: "editor.action.focusPreviousCursor",
      label: p("mutlicursor.focusPreviousCursor", "Focus Previous Cursor"),
      metadata: {
        description: p("mutlicursor.focusPreviousCursor.description", "Focuses the previous cursor"),
        args: []
      },
      alias: "Focus Previous Cursor",
      precondition: void 0
    });
  }
  run(e, t, i) {
    if (!t.hasModel())
      return;
    const n = t._getViewModel();
    if (n.cursorConfig.readOnly)
      return;
    n.model.pushStackElement();
    const s = Array.from(n.getCursorStates()), o = s.pop();
    o && (s.unshift(o), n.setCursorStates(i.source, 3, s), n.revealPrimaryCursor(i.source, !0), lh(s, n.getCursorStates()));
  }
}
gt(
  Uu.ID,
  Uu,
  4
  /* EditorContributionInstantiation.Lazy */
);
gt(
  Gv.ID,
  Gv,
  1
  /* EditorContributionInstantiation.AfterFirstRender */
);
Y(y_e);
Y(L_e);
Y(D_e);
Y(I_e);
Y(E_e);
Y(T_e);
Y(N_e);
Y(M_e);
Y(R_e);
Y(k_e);
Y(x_e);
Y(P_e);
Y(O_e);
const F_e = "editor.action.inlineEdit.accept", W_e = "editor.action.inlineEdit.reject", B_e = "editor.action.inlineEdit.jumpTo", H_e = "editor.action.inlineEdit.jumpBack";
var V_e = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, z_e = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
const dx = "inline-edit";
let aN = class extends P {
  constructor(e, t, i) {
    super(), this.editor = e, this.model = t, this.languageService = i, this.isDisposed = rt(this, !1), this.currentTextModel = Lt(this.editor.onDidChangeModel, () => (
      /** @description editor.model */
      this.editor.getModel()
    )), this.uiState = Pe(this, (n) => {
      var s;
      if (this.isDisposed.read(n))
        return;
      const o = this.currentTextModel.read(n);
      if (o !== this.model.targetTextModel.read(n))
        return;
      const a = this.model.ghostText.read(n);
      if (!a)
        return;
      let l = (s = this.model.range) === null || s === void 0 ? void 0 : s.read(n);
      l && l.startLineNumber === l.endLineNumber && l.startColumn === l.endColumn && (l = void 0);
      const d = (l ? l.startLineNumber === l.endLineNumber : !0) && a.parts.length === 1 && a.parts[0].lines.length === 1, c = a.parts.length === 1 && a.parts[0].lines.every((C) => C.length === 0), h = [], u = [];
      function g(C, w) {
        if (u.length > 0) {
          const S = u[u.length - 1];
          w && S.decorations.push(new ts(
            S.content.length + 1,
            S.content.length + 1 + C[0].length,
            w,
            0
            /* InlineDecorationType.Regular */
          )), S.content += C[0], C = C.slice(1);
        }
        for (const S of C)
          u.push({
            content: S,
            decorations: w ? [new ts(
              1,
              S.length + 1,
              w,
              0
              /* InlineDecorationType.Regular */
            )] : []
          });
      }
      const f = o.getLineContent(a.lineNumber);
      let m, _ = 0;
      if (!c) {
        for (const C of a.parts) {
          let w = C.lines;
          l && !d && (g(w, dx), w = []), m === void 0 ? (h.push({
            column: C.column,
            text: w[0],
            preview: C.preview
          }), w = w.slice(1)) : g([f.substring(_, C.column - 1)], void 0), w.length > 0 && (g(w, dx), m === void 0 && C.column <= f.length && (m = C.column)), _ = C.column - 1;
        }
        m !== void 0 && g([f.substring(_)], void 0);
      }
      const v = m !== void 0 ? new Z4(m, f.length + 1) : void 0, b = d || !l ? a.lineNumber : l.endLineNumber - 1;
      return {
        inlineTexts: h,
        additionalLines: u,
        hiddenRange: v,
        lineNumber: b,
        additionalReservedLineCount: this.model.minReservedLineCount.read(n),
        targetTextModel: o,
        range: l,
        isSingleLine: d,
        isPureRemove: c,
        backgroundColoring: this.model.backgroundColoring.read(n)
      };
    }), this.decorations = Pe(this, (n) => {
      const s = this.uiState.read(n);
      if (!s)
        return [];
      const o = [];
      if (s.hiddenRange && o.push({
        range: s.hiddenRange.toRange(s.lineNumber),
        options: { inlineClassName: "inline-edit-hidden", description: "inline-edit-hidden" }
      }), s.range) {
        const a = [];
        if (s.isSingleLine)
          a.push(s.range);
        else if (s.isPureRemove) {
          const d = s.range.endLineNumber - s.range.startLineNumber;
          for (let c = 0; c < d; c++) {
            const h = s.range.startLineNumber + c, u = s.targetTextModel.getLineFirstNonWhitespaceColumn(h), g = s.targetTextModel.getLineLastNonWhitespaceColumn(h), f = new L(h, u, h, g);
            a.push(f);
          }
        } else {
          const d = s.range.endLineNumber - s.range.startLineNumber;
          for (let c = 0; c < d; c++) {
            const h = s.range.startLineNumber + c, u = s.targetTextModel.getLineFirstNonWhitespaceColumn(h), g = s.targetTextModel.getLineLastNonWhitespaceColumn(h), f = new L(h, u, h, g);
            a.push(f);
          }
        }
        const l = s.backgroundColoring ? "inline-edit-remove backgroundColoring" : "inline-edit-remove";
        for (const d of a)
          o.push({
            range: d,
            options: { inlineClassName: l, description: "inline-edit-remove" }
          });
      }
      for (const a of s.inlineTexts)
        o.push({
          range: L.fromPositions(new A(s.lineNumber, a.column)),
          options: {
            description: dx,
            after: { content: a.text, inlineClassName: a.preview ? "inline-edit-decoration-preview" : "inline-edit-decoration", cursorStops: Ba.Left },
            showIfCollapsed: !0
          }
        });
      return o;
    }), this.additionalLinesWidget = this._register(new Q4(this.editor, this.languageService.languageIdCodec, Pe((n) => {
      const s = this.uiState.read(n);
      return s && !s.isPureRemove ? {
        lineNumber: s.lineNumber,
        additionalLines: s.additionalLines,
        minReservedLineCount: s.additionalReservedLineCount,
        targetTextModel: s.targetTextModel
      } : void 0;
    }))), this._register(Se(() => {
      this.isDisposed.set(!0, void 0);
    })), this._register(Y4(this.editor, this.decorations));
  }
  ownsViewZone(e) {
    return this.additionalLinesWidget.viewZoneId === e;
  }
};
aN = V_e([
  z_e(2, Jt)
], aN);
var RR = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Ta = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, iS;
let lN = class extends P {
  constructor(e, t, i) {
    super(), this.editor = e, this.model = t, this.instantiationService = i, this.alwaysShowToolbar = Lt(this.editor.onDidChangeConfiguration, () => this.editor.getOption(
      63
      /* EditorOption.inlineEdit */
    ).showToolbar === "always"), this.sessionPosition = void 0, this.position = Pe(this, (n) => {
      var s, o, a;
      const l = (s = this.model.read(n)) === null || s === void 0 ? void 0 : s.widget.model.ghostText.read(n);
      if (!this.alwaysShowToolbar.read(n) || !l || l.parts.length === 0)
        return this.sessionPosition = void 0, null;
      const d = l.parts[0].column;
      this.sessionPosition && this.sessionPosition.lineNumber !== l.lineNumber && (this.sessionPosition = void 0);
      const c = new A(l.lineNumber, Math.min(d, (a = (o = this.sessionPosition) === null || o === void 0 ? void 0 : o.column) !== null && a !== void 0 ? a : Number.MAX_SAFE_INTEGER));
      return this.sessionPosition = c, c;
    }), this._register(Wo((n, s) => {
      if (!this.model.read(n) || !this.alwaysShowToolbar.read(n))
        return;
      const a = s.add(this.instantiationService.createInstance(Cp, this.editor, !0, this.position));
      e.addContentWidget(a), s.add(Se(() => e.removeContentWidget(a)));
    }));
  }
};
lN = RR([
  Ta(2, be)
], lN);
let Cp = iS = class extends P {
  constructor(e, t, i, n, s, o) {
    super(), this.editor = e, this.withBorder = t, this._position = i, this._contextKeyService = s, this._menuService = o, this.id = `InlineEditHintsContentWidget${iS.id++}`, this.allowEditorOverflow = !0, this.suppressMouseDown = !1, this.nodes = ft("div.inlineEditHints", { className: this.withBorder ? ".withBorder" : "" }, [
      ft("div@toolBar")
    ]), this.inlineCompletionsActionsMenus = this._register(this._menuService.createMenu(D.InlineEditActions, this._contextKeyService)), this.toolBar = this._register(n.createInstance(dN, this.nodes.toolBar, this.editor, D.InlineEditToolbar, {
      menuOptions: { renderShortTitle: !0 },
      toolbarOptions: { primaryGroup: (a) => a.startsWith("primary") },
      actionViewItemProvider: (a, l) => {
        if (a instanceof Hs)
          return n.createInstance(U_e, a, void 0);
      },
      telemetrySource: "InlineEditToolbar"
    })), this._register(this.toolBar.onDidChangeDropdownVisibility((a) => {
      iS._dropDownVisible = a;
    })), this._register(qe((a) => {
      this._position.read(a), this.editor.layoutContentWidget(this);
    })), this._register(qe((a) => {
      const l = [];
      for (const [d, c] of this.inlineCompletionsActionsMenus.getActions())
        for (const h of c)
          h instanceof Hs && l.push(h);
      l.length > 0 && l.unshift(new Oi()), this.toolBar.setAdditionalSecondaryActions(l);
    }));
  }
  getId() {
    return this.id;
  }
  getDomNode() {
    return this.nodes.root;
  }
  getPosition() {
    return {
      position: this._position.get(),
      preference: [
        1,
        2
        /* ContentWidgetPositionPreference.BELOW */
      ],
      positionAffinity: 3
    };
  }
};
Cp._dropDownVisible = !1;
Cp.id = 0;
Cp = iS = RR([
  Ta(3, be),
  Ta(4, De),
  Ta(5, vo)
], Cp);
class U_e extends Hc {
  updateLabel() {
    const e = this._keybindingService.lookupKeybinding(this._action.id, this._contextKeyService);
    if (!e)
      return super.updateLabel();
    if (this.label) {
      const t = ft("div.keybinding").root;
      this._register(new Op(t, Os, { disableTitle: !0, ...c3 })).set(e), this.label.textContent = this._action.label, this.label.appendChild(t), this.label.classList.add("inlineEditStatusBarItemLabel");
    }
  }
  updateTooltip() {
  }
}
let dN = class extends yv {
  constructor(e, t, i, n, s, o, a, l, d, c) {
    super(e, { resetMenu: i, ...n }, s, o, a, l, d, c), this.editor = t, this.menuId = i, this.options2 = n, this.menuService = s, this.contextKeyService = o, this.menu = this._store.add(this.menuService.createMenu(this.menuId, this.contextKeyService, { emitEventsForSubmenuChanges: !0 })), this.additionalActions = [], this.prependedPrimaryActions = [], this._store.add(this.menu.onDidChange(() => this.updateToolbar())), this._store.add(this.editor.onDidChangeCursorPosition(() => this.updateToolbar())), this.updateToolbar();
  }
  updateToolbar() {
    var e, t, i, n, s, o, a;
    const l = [], d = [];
    eL(this.menu, (e = this.options2) === null || e === void 0 ? void 0 : e.menuOptions, { primary: l, secondary: d }, (i = (t = this.options2) === null || t === void 0 ? void 0 : t.toolbarOptions) === null || i === void 0 ? void 0 : i.primaryGroup, (s = (n = this.options2) === null || n === void 0 ? void 0 : n.toolbarOptions) === null || s === void 0 ? void 0 : s.shouldInlineSubmenu, (a = (o = this.options2) === null || o === void 0 ? void 0 : o.toolbarOptions) === null || a === void 0 ? void 0 : a.useSeparatorsInPrimaryActions), d.push(...this.additionalActions), l.unshift(...this.prependedPrimaryActions), this.setActions(l, d);
  }
  setAdditionalSecondaryActions(e) {
    ci(this.additionalActions, e, (t, i) => t === i) || (this.additionalActions = e, this.updateToolbar());
  }
};
dN = RR([
  Ta(4, vo),
  Ta(5, De),
  Ta(6, Zs),
  Ta(7, _t),
  Ta(8, $t),
  Ta(9, kn)
], dN);
var $_e = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, wm = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, iu;
class K_e {
  constructor(e, t) {
    this.widget = e, this.edit = t;
  }
  dispose() {
    this.widget.dispose();
  }
}
let Vi = iu = class extends P {
  static get(e) {
    return e.getContribution(iu.ID);
  }
  constructor(e, t, i, n, s, o) {
    super(), this.editor = e, this.instantiationService = t, this.contextKeyService = i, this.languageFeaturesService = n, this._commandService = s, this._configurationService = o, this._isVisibleContext = iu.inlineEditVisibleContext.bindTo(this.contextKeyService), this._isCursorAtInlineEditContext = iu.cursorAtInlineEditContext.bindTo(this.contextKeyService), this._currentEdit = this._register(cv(this, void 0)), this._isAccepting = rt(this, !1), this._enabled = Lt(this.editor.onDidChangeConfiguration, () => this.editor.getOption(
      63
      /* EditorOption.inlineEdit */
    ).enabled), this._fontFamily = Lt(this.editor.onDidChangeConfiguration, () => this.editor.getOption(
      63
      /* EditorOption.inlineEdit */
    ).fontFamily), this._backgroundColoring = Lt(this.editor.onDidChangeConfiguration, () => this.editor.getOption(
      63
      /* EditorOption.inlineEdit */
    ).backgroundColoring);
    const a = Mn("InlineEditController.modelContentChangedSignal", e.onDidChangeModelContent);
    this._register(qe((u) => {
      this._enabled.read(u) && (a.read(u), !this._isAccepting.read(u) && this.getInlineEdit(e, !0));
    }));
    const l = Lt(e.onDidChangeCursorPosition, () => e.getPosition());
    this._register(qe((u) => {
      if (!this._enabled.read(u))
        return;
      const g = l.read(u);
      g && this.checkCursorPosition(g);
    })), this._register(qe((u) => {
      const g = this._currentEdit.read(u);
      if (this._isCursorAtInlineEditContext.set(!1), !g) {
        this._isVisibleContext.set(!1);
        return;
      }
      this._isVisibleContext.set(!0);
      const f = e.getPosition();
      f && this.checkCursorPosition(f);
    }));
    const d = Mn("InlineEditController.editorBlurSignal", e.onDidBlurEditorWidget);
    this._register(qe(async (u) => {
      var g;
      this._enabled.read(u) && (d.read(u), !(this._configurationService.getValue("editor.experimentalInlineEdit.keepOnBlur") || e.getOption(
        63
        /* EditorOption.inlineEdit */
      ).keepOnBlur) && ((g = this._currentRequestCts) === null || g === void 0 || g.dispose(!0), this._currentRequestCts = void 0, await this.clear(!1)));
    }));
    const c = Mn("InlineEditController.editorFocusSignal", e.onDidFocusEditorText);
    this._register(qe((u) => {
      this._enabled.read(u) && (c.read(u), this.getInlineEdit(e, !0));
    }));
    const h = this._register($H());
    this._register(qe((u) => {
      const g = this._fontFamily.read(u);
      h.setStyle(g === "" || g === "default" ? "" : `
.monaco-editor .inline-edit-decoration,
.monaco-editor .inline-edit-decoration-preview,
.monaco-editor .inline-edit {
	font-family: ${g};
}`);
    })), this._register(new lN(this.editor, this._currentEdit, this.instantiationService));
  }
  checkCursorPosition(e) {
    var t;
    if (!this._currentEdit) {
      this._isCursorAtInlineEditContext.set(!1);
      return;
    }
    const i = (t = this._currentEdit.get()) === null || t === void 0 ? void 0 : t.edit;
    if (!i) {
      this._isCursorAtInlineEditContext.set(!1);
      return;
    }
    this._isCursorAtInlineEditContext.set(L.containsPosition(i.range, e));
  }
  validateInlineEdit(e, t) {
    var i, n;
    if (t.text.includes(`
`) && t.range.startLineNumber !== t.range.endLineNumber && t.range.startColumn !== t.range.endColumn) {
      if (t.range.startColumn !== 1)
        return !1;
      const o = t.range.endLineNumber, a = t.range.endColumn, l = (n = (i = e.getModel()) === null || i === void 0 ? void 0 : i.getLineLength(o)) !== null && n !== void 0 ? n : 0;
      if (a !== l + 1)
        return !1;
    }
    return !0;
  }
  async fetchInlineEdit(e, t) {
    this._currentRequestCts && this._currentRequestCts.dispose(!0);
    const i = e.getModel();
    if (!i)
      return;
    const n = i.getVersionId(), s = this.languageFeaturesService.inlineEditProvider.all(i);
    if (s.length === 0)
      return;
    const o = s[0];
    this._currentRequestCts = new mi();
    const a = this._currentRequestCts.token, l = t ? fA.Automatic : fA.Invoke;
    if (t && await j_e(50, a), a.isCancellationRequested || i.isDisposed() || i.getVersionId() !== n)
      return;
    const c = await o.provideInlineEdit(i, { triggerKind: l }, a);
    if (c && !(a.isCancellationRequested || i.isDisposed() || i.getVersionId() !== n) && this.validateInlineEdit(e, c))
      return c;
  }
  async getInlineEdit(e, t) {
    var i;
    this._isCursorAtInlineEditContext.set(!1), await this.clear();
    const n = await this.fetchInlineEdit(e, t);
    if (!n)
      return;
    const s = n.range.endLineNumber, o = n.range.endColumn, a = n.text.endsWith(`
`) && !(n.range.startLineNumber === n.range.endLineNumber && n.range.startColumn === n.range.endColumn) ? n.text.slice(0, -1) : n.text, l = new Bv(s, [new Vy(o, a, !1)]), d = this.instantiationService.createInstance(aN, this.editor, {
      ghostText: Hr(l),
      minReservedLineCount: Hr(0),
      targetTextModel: Hr((i = this.editor.getModel()) !== null && i !== void 0 ? i : void 0),
      range: Hr(n.range),
      backgroundColoring: this._backgroundColoring
    });
    this._currentEdit.set(new K_e(d, n), void 0);
  }
  async trigger() {
    await this.getInlineEdit(this.editor, !1);
  }
  async jumpBack() {
    this._jumpBackPosition && (this.editor.setPosition(this._jumpBackPosition), this.editor.revealPositionInCenterIfOutsideViewport(this._jumpBackPosition));
  }
  async accept() {
    var e;
    this._isAccepting.set(!0, void 0);
    const t = (e = this._currentEdit.get()) === null || e === void 0 ? void 0 : e.edit;
    if (!t)
      return;
    let i = t.text;
    t.text.startsWith(`
`) && (i = t.text.substring(1)), this.editor.pushUndoStop(), this.editor.executeEdits("acceptCurrent", [ti.replace(L.lift(t.range), i)]), t.accepted && await this._commandService.executeCommand(t.accepted.id, ...t.accepted.arguments || []).then(void 0, _i), this.freeEdit(t), Nt((n) => {
      this._currentEdit.set(void 0, n), this._isAccepting.set(!1, n);
    });
  }
  jumpToCurrent() {
    var e, t;
    this._jumpBackPosition = (e = this.editor.getSelection()) === null || e === void 0 ? void 0 : e.getStartPosition();
    const i = (t = this._currentEdit.get()) === null || t === void 0 ? void 0 : t.edit;
    if (!i)
      return;
    const n = A.lift({ lineNumber: i.range.startLineNumber, column: i.range.startColumn });
    this.editor.setPosition(n), this.editor.revealPositionInCenterIfOutsideViewport(n);
  }
  async clear(e = !0) {
    var t;
    const i = (t = this._currentEdit.get()) === null || t === void 0 ? void 0 : t.edit;
    i && (i != null && i.rejected) && e && await this._commandService.executeCommand(i.rejected.id, ...i.rejected.arguments || []).then(void 0, _i), i && this.freeEdit(i), this._currentEdit.set(void 0, void 0);
  }
  freeEdit(e) {
    const t = this.editor.getModel();
    if (!t)
      return;
    const i = this.languageFeaturesService.inlineEditProvider.all(t);
    i.length !== 0 && i[0].freeInlineEdit(e);
  }
  shouldShowHoverAt(e) {
    const t = this._currentEdit.get();
    if (!t)
      return !1;
    const i = t.edit, n = t.widget.model;
    if (L.containsPosition(i.range, e.getStartPosition()) || L.containsPosition(i.range, e.getEndPosition()))
      return !0;
    const o = n.ghostText.get();
    return o ? o.parts.some((a) => e.containsPosition(new A(o.lineNumber, a.column))) : !1;
  }
  shouldShowHoverAtViewZone(e) {
    var t, i;
    return (i = (t = this._currentEdit.get()) === null || t === void 0 ? void 0 : t.widget.ownsViewZone(e)) !== null && i !== void 0 ? i : !1;
  }
};
Vi.ID = "editor.contrib.inlineEditController";
Vi.inlineEditVisibleKey = "inlineEditVisible";
Vi.inlineEditVisibleContext = new oe(iu.inlineEditVisibleKey, !1);
Vi.cursorAtInlineEditKey = "cursorAtInlineEdit";
Vi.cursorAtInlineEditContext = new oe(iu.cursorAtInlineEditKey, !1);
Vi = iu = $_e([
  wm(1, be),
  wm(2, De),
  wm(3, he),
  wm(4, $t),
  wm(5, Ge)
], Vi);
function j_e(r, e) {
  return new Promise((t) => {
    let i;
    const n = setTimeout(() => {
      i && i.dispose(), t();
    }, r);
    e && (i = e.onCancellationRequested(() => {
      clearTimeout(n), i && i.dispose(), t();
    }));
  });
}
class q_e extends ae {
  constructor() {
    super({
      id: F_e,
      label: "Accept Inline Edit",
      alias: "Accept Inline Edit",
      precondition: U.and(x.writable, Vi.inlineEditVisibleContext),
      kbOpts: [
        {
          weight: 101,
          primary: 2,
          kbExpr: U.and(x.writable, Vi.inlineEditVisibleContext, Vi.cursorAtInlineEditContext)
        }
      ],
      menuOpts: [{
        menuId: D.InlineEditToolbar,
        title: "Accept",
        group: "primary",
        order: 1
      }]
    });
  }
  async run(e, t) {
    const i = Vi.get(t);
    await (i == null ? void 0 : i.accept());
  }
}
class G_e extends ae {
  constructor() {
    const e = U.and(x.writable, U.not(Vi.inlineEditVisibleKey));
    super({
      id: "editor.action.inlineEdit.trigger",
      label: "Trigger Inline Edit",
      alias: "Trigger Inline Edit",
      precondition: e,
      kbOpts: {
        weight: 101,
        primary: 2646,
        kbExpr: e
      }
    });
  }
  async run(e, t) {
    const i = Vi.get(t);
    i == null || i.trigger();
  }
}
class Z_e extends ae {
  constructor() {
    const e = U.and(x.writable, Vi.inlineEditVisibleContext, U.not(Vi.cursorAtInlineEditKey));
    super({
      id: B_e,
      label: "Jump to Inline Edit",
      alias: "Jump to Inline Edit",
      precondition: e,
      kbOpts: {
        weight: 101,
        primary: 2646,
        kbExpr: e
      },
      menuOpts: [{
        menuId: D.InlineEditToolbar,
        title: "Jump To Edit",
        group: "primary",
        order: 3,
        when: e
      }]
    });
  }
  async run(e, t) {
    const i = Vi.get(t);
    i == null || i.jumpToCurrent();
  }
}
class Y_e extends ae {
  constructor() {
    const e = U.and(x.writable, Vi.cursorAtInlineEditContext);
    super({
      id: H_e,
      label: "Jump Back from Inline Edit",
      alias: "Jump Back from Inline Edit",
      precondition: e,
      kbOpts: {
        weight: 110,
        primary: 2646,
        kbExpr: e
      },
      menuOpts: [{
        menuId: D.InlineEditToolbar,
        title: "Jump Back",
        group: "primary",
        order: 3,
        when: e
      }]
    });
  }
  async run(e, t) {
    const i = Vi.get(t);
    i == null || i.jumpBack();
  }
}
class Q_e extends ae {
  constructor() {
    const e = U.and(x.writable, Vi.inlineEditVisibleContext);
    super({
      id: W_e,
      label: "Reject Inline Edit",
      alias: "Reject Inline Edit",
      precondition: e,
      kbOpts: {
        weight: 100,
        primary: 9,
        kbExpr: e
      },
      menuOpts: [{
        menuId: D.InlineEditToolbar,
        title: "Reject",
        group: "secondary",
        order: 2
      }]
    });
  }
  async run(e, t) {
    const i = Vi.get(t);
    await (i == null ? void 0 : i.clear());
  }
}
var X_e = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, LB = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
class J_e {
  constructor(e, t, i) {
    this.owner = e, this.range = t, this.controller = i;
  }
  isValidForHoverAnchor(e) {
    return e.type === 1 && this.range.startColumn <= e.range.startColumn && this.range.endColumn >= e.range.endColumn;
  }
}
let cN = class {
  constructor(e, t, i) {
    this._editor = e, this._instantiationService = t, this._telemetryService = i, this.hoverOrdinal = 5;
  }
  suggestHoverAnchor(e) {
    const t = Vi.get(this._editor);
    if (!t)
      return null;
    const i = e.target;
    if (i.type === 8) {
      const n = i.detail;
      if (t.shouldShowHoverAtViewZone(n.viewZoneId)) {
        const s = i.range;
        return new gu(1e3, this, s, e.event.posx, e.event.posy, !1);
      }
    }
    return i.type === 7 && t.shouldShowHoverAt(i.range) ? new gu(1e3, this, i.range, e.event.posx, e.event.posy, !1) : i.type === 6 && i.detail.mightBeForeignElement && t.shouldShowHoverAt(i.range) ? new gu(1e3, this, i.range, e.event.posx, e.event.posy, !1) : null;
  }
  computeSync(e, t) {
    if (this._editor.getOption(
      63
      /* EditorOption.inlineEdit */
    ).showToolbar !== "onHover")
      return [];
    const i = Vi.get(this._editor);
    return i && i.shouldShowHoverAt(e.range) ? [new J_e(this, e.range, i)] : [];
  }
  renderHoverParts(e, t) {
    const i = new q();
    this._telemetryService.publicLog2("inlineEditHover.shown");
    const n = this._instantiationService.createInstance(Cp, this._editor, !1, Hr(null));
    return e.fragment.appendChild(n.getDomNode()), i.add(n), i;
  }
};
cN = X_e([
  LB(1, be),
  LB(2, kn)
], cN);
Y(q_e);
Y(Q_e);
Y(Z_e);
Y(Y_e);
Y(G_e);
gt(
  Vi.ID,
  Vi,
  3
  /* EditorContributionInstantiation.Eventually */
);
ah.register(cN);
const $u = {
  Visible: new oe("parameterHintsVisible", !1),
  MultipleSignatures: new oe("parameterHintsMultipleSignatures", !1)
};
async function _$(r, e, t, i, n) {
  const s = r.ordered(e);
  for (const o of s)
    try {
      const a = await o.provideSignatureHelp(e, t, n, i);
      if (a)
        return a;
    } catch (a) {
      _i(a);
    }
}
st.registerCommand("_executeSignatureHelpProvider", async (r, ...e) => {
  const [t, i, n] = e;
  ct(Ee.isUri(t)), ct(A.isIPosition(i)), ct(typeof n == "string" || !n);
  const s = r.get(he), o = await r.get(xs).createModelReference(t);
  try {
    const a = await _$(s.signatureHelpProvider, o.object.textEditorModel, A.lift(i), {
      triggerKind: pc.Invoke,
      isRetrigger: !1,
      triggerCharacter: n
    }, at.None);
    return a ? (setTimeout(() => a.dispose(), 0), a.value) : void 0;
  } finally {
    o.dispose();
  }
});
var Ud;
(function(r) {
  r.Default = {
    type: 0
    /* Type.Default */
  };
  class e {
    constructor(n, s) {
      this.request = n, this.previouslyActiveHints = s, this.type = 2;
    }
  }
  r.Pending = e;
  class t {
    constructor(n) {
      this.hints = n, this.type = 1;
    }
  }
  r.Active = t;
})(Ud || (Ud = {}));
class sD extends P {
  constructor(e, t, i = sD.DEFAULT_DELAY) {
    super(), this._onChangedHints = this._register(new R()), this.onChangedHints = this._onChangedHints.event, this.triggerOnType = !1, this._state = Ud.Default, this._pendingTriggers = [], this._lastSignatureHelpResult = this._register(new Yi()), this.triggerChars = new lS(), this.retriggerChars = new lS(), this.triggerId = 0, this.editor = e, this.providers = t, this.throttledDelayer = new pr(i), this._register(this.editor.onDidBlurEditorWidget(() => this.cancel())), this._register(this.editor.onDidChangeConfiguration(() => this.onEditorConfigurationChange())), this._register(this.editor.onDidChangeModel((n) => this.onModelChanged())), this._register(this.editor.onDidChangeModelLanguage((n) => this.onModelChanged())), this._register(this.editor.onDidChangeCursorSelection((n) => this.onCursorChange(n))), this._register(this.editor.onDidChangeModelContent((n) => this.onModelContentChange())), this._register(this.providers.onDidChange(this.onModelChanged, this)), this._register(this.editor.onDidType((n) => this.onDidType(n))), this.onEditorConfigurationChange(), this.onModelChanged();
  }
  get state() {
    return this._state;
  }
  set state(e) {
    this._state.type === 2 && this._state.request.cancel(), this._state = e;
  }
  cancel(e = !1) {
    this.state = Ud.Default, this.throttledDelayer.cancel(), e || this._onChangedHints.fire(void 0);
  }
  trigger(e, t) {
    const i = this.editor.getModel();
    if (!i || !this.providers.has(i))
      return;
    const n = ++this.triggerId;
    this._pendingTriggers.push(e), this.throttledDelayer.trigger(() => this.doTrigger(n), t).catch(He);
  }
  next() {
    if (this.state.type !== 1)
      return;
    const e = this.state.hints.signatures.length, t = this.state.hints.activeSignature, i = t % e === e - 1, n = this.editor.getOption(
      86
      /* EditorOption.parameterHints */
    ).cycle;
    if ((e < 2 || i) && !n) {
      this.cancel();
      return;
    }
    this.updateActiveSignature(i && n ? 0 : t + 1);
  }
  previous() {
    if (this.state.type !== 1)
      return;
    const e = this.state.hints.signatures.length, t = this.state.hints.activeSignature, i = t === 0, n = this.editor.getOption(
      86
      /* EditorOption.parameterHints */
    ).cycle;
    if ((e < 2 || i) && !n) {
      this.cancel();
      return;
    }
    this.updateActiveSignature(i && n ? e - 1 : t - 1);
  }
  updateActiveSignature(e) {
    this.state.type === 1 && (this.state = new Ud.Active({ ...this.state.hints, activeSignature: e }), this._onChangedHints.fire(this.state.hints));
  }
  async doTrigger(e) {
    const t = this.state.type === 1 || this.state.type === 2, i = this.getLastActiveHints();
    if (this.cancel(!0), this._pendingTriggers.length === 0)
      return !1;
    const n = this._pendingTriggers.reduce(eve);
    this._pendingTriggers = [];
    const s = {
      triggerKind: n.triggerKind,
      triggerCharacter: n.triggerCharacter,
      isRetrigger: t,
      activeSignatureHelp: i
    };
    if (!this.editor.hasModel())
      return !1;
    const o = this.editor.getModel(), a = this.editor.getPosition();
    this.state = new Ud.Pending(Zi((l) => _$(this.providers, o, a, s, l)), i);
    try {
      const l = await this.state.request;
      return e !== this.triggerId ? (l == null || l.dispose(), !1) : !l || !l.value.signatures || l.value.signatures.length === 0 ? (l == null || l.dispose(), this._lastSignatureHelpResult.clear(), this.cancel(), !1) : (this.state = new Ud.Active(l.value), this._lastSignatureHelpResult.value = l, this._onChangedHints.fire(this.state.hints), !0);
    } catch (l) {
      return e === this.triggerId && (this.state = Ud.Default), He(l), !1;
    }
  }
  getLastActiveHints() {
    switch (this.state.type) {
      case 1:
        return this.state.hints;
      case 2:
        return this.state.previouslyActiveHints;
      default:
        return;
    }
  }
  get isTriggered() {
    return this.state.type === 1 || this.state.type === 2 || this.throttledDelayer.isTriggered();
  }
  onModelChanged() {
    this.cancel(), this.triggerChars.clear(), this.retriggerChars.clear();
    const e = this.editor.getModel();
    if (e)
      for (const t of this.providers.ordered(e)) {
        for (const i of t.signatureHelpTriggerCharacters || [])
          if (i.length) {
            const n = i.charCodeAt(0);
            this.triggerChars.add(n), this.retriggerChars.add(n);
          }
        for (const i of t.signatureHelpRetriggerCharacters || [])
          i.length && this.retriggerChars.add(i.charCodeAt(0));
      }
  }
  onDidType(e) {
    if (!this.triggerOnType)
      return;
    const t = e.length - 1, i = e.charCodeAt(t);
    (this.triggerChars.has(i) || this.isTriggered && this.retriggerChars.has(i)) && this.trigger({
      triggerKind: pc.TriggerCharacter,
      triggerCharacter: e.charAt(t)
    });
  }
  onCursorChange(e) {
    e.source === "mouse" ? this.cancel() : this.isTriggered && this.trigger({ triggerKind: pc.ContentChange });
  }
  onModelContentChange() {
    this.isTriggered && this.trigger({ triggerKind: pc.ContentChange });
  }
  onEditorConfigurationChange() {
    this.triggerOnType = this.editor.getOption(
      86
      /* EditorOption.parameterHints */
    ).enabled, this.triggerOnType || this.cancel();
  }
  dispose() {
    this.cancel(!0), super.dispose();
  }
}
sD.DEFAULT_DELAY = 120;
function eve(r, e) {
  switch (e.triggerKind) {
    case pc.Invoke:
      return e;
    case pc.ContentChange:
      return r;
    case pc.TriggerCharacter:
    default:
      return e;
  }
}
var tve = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Cw = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, hN;
const Xs = X, ive = hi("parameter-hints-next", me.chevronDown, p("parameterHintsNextIcon", "Icon for show next parameter hint.")), nve = hi("parameter-hints-previous", me.chevronUp, p("parameterHintsPreviousIcon", "Icon for show previous parameter hint."));
let Gy = hN = class extends P {
  constructor(e, t, i, n, s, o) {
    super(), this.editor = e, this.model = t, this.telemetryService = o, this.renderDisposeables = this._register(new q()), this.visible = !1, this.announcedLabel = null, this.allowEditorOverflow = !0, this.markdownRenderer = this._register(new nl({ editor: e }, s, n)), this.keyVisible = $u.Visible.bindTo(i), this.keyMultipleSignatures = $u.MultipleSignatures.bindTo(i);
  }
  createParameterHintDOMNodes() {
    const e = Xs(".editor-widget.parameter-hints-widget"), t = G(e, Xs(".phwrapper"));
    t.tabIndex = -1;
    const i = G(t, Xs(".controls")), n = G(i, Xs(".button" + Le.asCSSSelector(nve))), s = G(i, Xs(".overloads")), o = G(i, Xs(".button" + Le.asCSSSelector(ive)));
    this._register(W(n, "click", (u) => {
      nt.stop(u), this.previous();
    })), this._register(W(o, "click", (u) => {
      nt.stop(u), this.next();
    }));
    const a = Xs(".body"), l = new pb(a, {
      alwaysConsumeMouseWheel: !0
    });
    this._register(l), t.appendChild(l.getDomNode());
    const d = G(a, Xs(".signature")), c = G(a, Xs(".docs"));
    e.style.userSelect = "text", this.domNodes = {
      element: e,
      signature: d,
      overloads: s,
      docs: c,
      scrollbar: l
    }, this.editor.addContentWidget(this), this.hide(), this._register(this.editor.onDidChangeCursorSelection((u) => {
      this.visible && this.editor.layoutContentWidget(this);
    }));
    const h = () => {
      if (!this.domNodes)
        return;
      const u = this.editor.getOption(
        50
        /* EditorOption.fontInfo */
      );
      this.domNodes.element.style.fontSize = `${u.fontSize}px`, this.domNodes.element.style.lineHeight = `${u.lineHeight / u.fontSize}`;
    };
    h(), this._register(ne.chain(this.editor.onDidChangeConfiguration.bind(this.editor), (u) => u.filter((g) => g.hasChanged(
      50
      /* EditorOption.fontInfo */
    )))(h)), this._register(this.editor.onDidLayoutChange((u) => this.updateMaxHeight())), this.updateMaxHeight();
  }
  show() {
    this.visible || (this.domNodes || this.createParameterHintDOMNodes(), this.keyVisible.set(!0), this.visible = !0, setTimeout(() => {
      var e;
      (e = this.domNodes) === null || e === void 0 || e.element.classList.add("visible");
    }, 100), this.editor.layoutContentWidget(this));
  }
  hide() {
    var e;
    this.renderDisposeables.clear(), this.visible && (this.keyVisible.reset(), this.visible = !1, this.announcedLabel = null, (e = this.domNodes) === null || e === void 0 || e.element.classList.remove("visible"), this.editor.layoutContentWidget(this));
  }
  getPosition() {
    return this.visible ? {
      position: this.editor.getPosition(),
      preference: [
        1,
        2
        /* ContentWidgetPositionPreference.BELOW */
      ]
    } : null;
  }
  render(e) {
    var t;
    if (this.renderDisposeables.clear(), !this.domNodes)
      return;
    const i = e.signatures.length > 1;
    this.domNodes.element.classList.toggle("multiple", i), this.keyMultipleSignatures.set(i), this.domNodes.signature.innerText = "", this.domNodes.docs.innerText = "";
    const n = e.signatures[e.activeSignature];
    if (!n)
      return;
    const s = G(this.domNodes.signature, Xs(".code")), o = this.editor.getOption(
      50
      /* EditorOption.fontInfo */
    );
    s.style.fontSize = `${o.fontSize}px`, s.style.fontFamily = o.fontFamily;
    const a = n.parameters.length > 0, l = (t = n.activeParameter) !== null && t !== void 0 ? t : e.activeParameter;
    if (a)
      this.renderParameters(s, n, l);
    else {
      const h = G(s, Xs("span"));
      h.textContent = n.label;
    }
    const d = n.parameters[l];
    if (d != null && d.documentation) {
      const h = Xs("span.documentation");
      if (typeof d.documentation == "string")
        h.textContent = d.documentation;
      else {
        const u = this.renderMarkdownDocs(d.documentation);
        h.appendChild(u.element);
      }
      G(this.domNodes.docs, Xs("p", {}, h));
    }
    if (n.documentation !== void 0) if (typeof n.documentation == "string")
      G(this.domNodes.docs, Xs("p", {}, n.documentation));
    else {
      const h = this.renderMarkdownDocs(n.documentation);
      G(this.domNodes.docs, h.element);
    }
    const c = this.hasDocs(n, d);
    if (this.domNodes.signature.classList.toggle("has-docs", c), this.domNodes.docs.classList.toggle("empty", !c), this.domNodes.overloads.textContent = String(e.activeSignature + 1).padStart(e.signatures.length.toString().length, "0") + "/" + e.signatures.length, d) {
      let h = "";
      const u = n.parameters[l];
      Array.isArray(u.label) ? h = n.label.substring(u.label[0], u.label[1]) : h = u.label, u.documentation && (h += typeof u.documentation == "string" ? `, ${u.documentation}` : `, ${u.documentation.value}`), n.documentation && (h += typeof n.documentation == "string" ? `, ${n.documentation}` : `, ${n.documentation.value}`), this.announcedLabel !== h && (Ls(p("hint", "{0}, hint", h)), this.announcedLabel = h);
    }
    this.editor.layoutContentWidget(this), this.domNodes.scrollbar.scanDomNode();
  }
  renderMarkdownDocs(e) {
    const t = new rs(), i = this.renderDisposeables.add(this.markdownRenderer.render(e, {
      asyncRenderCallback: () => {
        var s;
        (s = this.domNodes) === null || s === void 0 || s.scrollbar.scanDomNode();
      }
    }));
    i.element.classList.add("markdown-docs");
    const n = t.elapsed();
    return n > 300 && this.telemetryService.publicLog2("parameterHints.parseMarkdown", {
      renderDuration: n
    }), i;
  }
  hasDocs(e, t) {
    return !!(t && typeof t.documentation == "string" && Xd(t.documentation).length > 0 || t && typeof t.documentation == "object" && Xd(t.documentation).value.length > 0 || e.documentation && typeof e.documentation == "string" && Xd(e.documentation).length > 0 || e.documentation && typeof e.documentation == "object" && Xd(e.documentation.value).length > 0);
  }
  renderParameters(e, t, i) {
    const [n, s] = this.getParameterLabelOffsets(t, i), o = document.createElement("span");
    o.textContent = t.label.substring(0, n);
    const a = document.createElement("span");
    a.textContent = t.label.substring(n, s), a.className = "parameter active";
    const l = document.createElement("span");
    l.textContent = t.label.substring(s), G(e, o, a, l);
  }
  getParameterLabelOffsets(e, t) {
    const i = e.parameters[t];
    if (i) {
      if (Array.isArray(i.label))
        return i.label;
      if (i.label.length) {
        const n = new RegExp(`(\\W|^)${gr(i.label)}(?=\\W|$)`, "g");
        n.test(e.label);
        const s = n.lastIndex - i.label.length;
        return s >= 0 ? [s, n.lastIndex] : [0, 0];
      } else
        return [0, 0];
    } else return [0, 0];
  }
  next() {
    this.editor.focus(), this.model.next();
  }
  previous() {
    this.editor.focus(), this.model.previous();
  }
  getDomNode() {
    return this.domNodes || this.createParameterHintDOMNodes(), this.domNodes.element;
  }
  getId() {
    return hN.ID;
  }
  updateMaxHeight() {
    if (!this.domNodes)
      return;
    const t = `${Math.max(this.editor.getLayoutInfo().height / 4, 250)}px`;
    this.domNodes.element.style.maxHeight = t;
    const i = this.domNodes.element.getElementsByClassName("phwrapper");
    i.length && (i[0].style.maxHeight = t);
  }
};
Gy.ID = "editor.widget.parameterHintsWidget";
Gy = hN = tve([
  Cw(2, De),
  Cw(3, Ys),
  Cw(4, Jt),
  Cw(5, kn)
], Gy);
I("editorHoverWidget.highlightForeground", { dark: lr, light: lr, hcDark: lr, hcLight: lr }, p("editorHoverWidgetHighlightForeground", "Foreground color of the active item in the parameter hint."));
var sve = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, DB = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, uN;
let Ku = uN = class extends P {
  static get(e) {
    return e.getContribution(uN.ID);
  }
  constructor(e, t, i) {
    super(), this.editor = e, this.model = this._register(new sD(e, i.signatureHelpProvider)), this._register(this.model.onChangedHints((n) => {
      var s;
      n ? (this.widget.value.show(), this.widget.value.render(n)) : (s = this.widget.rawValue) === null || s === void 0 || s.hide();
    })), this.widget = new bd(() => this._register(t.createInstance(Gy, this.editor, this.model)));
  }
  cancel() {
    this.model.cancel();
  }
  previous() {
    var e;
    (e = this.widget.rawValue) === null || e === void 0 || e.previous();
  }
  next() {
    var e;
    (e = this.widget.rawValue) === null || e === void 0 || e.next();
  }
  trigger(e) {
    this.model.trigger(e, 0);
  }
};
Ku.ID = "editor.controller.parameterHints";
Ku = uN = sve([
  DB(1, be),
  DB(2, he)
], Ku);
class ove extends ae {
  constructor() {
    super({
      id: "editor.action.triggerParameterHints",
      label: p("parameterHints.trigger.label", "Trigger Parameter Hints"),
      alias: "Trigger Parameter Hints",
      precondition: x.hasSignatureHelpProvider,
      kbOpts: {
        kbExpr: x.editorTextFocus,
        primary: 3082,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(e, t) {
    const i = Ku.get(t);
    i == null || i.trigger({
      triggerKind: pc.Invoke
    });
  }
}
gt(
  Ku.ID,
  Ku,
  2
  /* EditorContributionInstantiation.BeforeFirstInteraction */
);
Y(ove);
const AR = 175, PR = Ui.bindToContribution(Ku.get);
se(new PR({
  id: "closeParameterHints",
  precondition: $u.Visible,
  handler: (r) => r.cancel(),
  kbOpts: {
    weight: AR,
    kbExpr: x.focus,
    primary: 9,
    secondary: [
      1033
      /* KeyCode.Escape */
    ]
  }
}));
se(new PR({
  id: "showPrevParameterHint",
  precondition: U.and($u.Visible, $u.MultipleSignatures),
  handler: (r) => r.previous(),
  kbOpts: {
    weight: AR,
    kbExpr: x.focus,
    primary: 16,
    secondary: [
      528
      /* KeyCode.UpArrow */
    ],
    mac: { primary: 16, secondary: [
      528,
      302
      /* KeyCode.KeyP */
    ] }
  }
}));
se(new PR({
  id: "showNextParameterHint",
  precondition: U.and($u.Visible, $u.MultipleSignatures),
  handler: (r) => r.next(),
  kbOpts: {
    weight: AR,
    kbExpr: x.focus,
    primary: 18,
    secondary: [
      530
      /* KeyCode.DownArrow */
    ],
    mac: { primary: 18, secondary: [
      530,
      300
      /* KeyCode.KeyN */
    ] }
  }
}));
var rve = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, ww = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
const Kp = new oe("renameInputVisible", !1, p("renameInputVisible", "Whether the rename input widget is visible"));
new oe("renameInputFocused", !1, p("renameInputFocused", "Whether the rename input widget is focused"));
let gN = class {
  constructor(e, t, i, n, s, o) {
    this._editor = e, this._acceptKeybindings = t, this._themeService = i, this._keybindingService = n, this._logService = o, this.allowEditorOverflow = !0, this._disposables = new q(), this._visibleContextKey = Kp.bindTo(s), this._isEditingRenameCandidate = !1, this._nRenameSuggestionsInvocations = 0, this._hadAutomaticRenameSuggestionsInvocation = !1, this._candidates = /* @__PURE__ */ new Set(), this._beforeFirstInputFieldEditSW = new rs(), this._inputWithButton = new ave(), this._disposables.add(this._inputWithButton), this._editor.addContentWidget(this), this._disposables.add(this._editor.onDidChangeConfiguration((a) => {
      a.hasChanged(
        50
        /* EditorOption.fontInfo */
      ) && this._updateFont();
    })), this._disposables.add(i.onDidColorThemeChange(this._updateStyles, this));
  }
  dispose() {
    this._disposables.dispose(), this._editor.removeContentWidget(this);
  }
  getId() {
    return "__renameInputWidget";
  }
  getDomNode() {
    return this._domNode || (this._domNode = document.createElement("div"), this._domNode.className = "monaco-editor rename-box", this._domNode.appendChild(this._inputWithButton.domNode), this._renameCandidateListView = this._disposables.add(new OR(this._domNode, {
      fontInfo: this._editor.getOption(
        50
        /* EditorOption.fontInfo */
      ),
      onFocusChange: (e) => {
        this._inputWithButton.input.value = e, this._isEditingRenameCandidate = !1;
      },
      onSelectionChange: () => {
        this._isEditingRenameCandidate = !1, this.acceptInput(!1);
      }
    })), this._disposables.add(this._inputWithButton.onDidInputChange(() => {
      var e, t, i, n;
      ((e = this._renameCandidateListView) === null || e === void 0 ? void 0 : e.focusedCandidate) !== void 0 && (this._isEditingRenameCandidate = !0), (t = this._timeBeforeFirstInputFieldEdit) !== null && t !== void 0 || (this._timeBeforeFirstInputFieldEdit = this._beforeFirstInputFieldEditSW.elapsed()), ((i = this._renameCandidateProvidersCts) === null || i === void 0 ? void 0 : i.token.isCancellationRequested) === !1 && this._renameCandidateProvidersCts.cancel(), (n = this._renameCandidateListView) === null || n === void 0 || n.clearFocus();
    })), this._label = document.createElement("div"), this._label.className = "rename-label", this._domNode.appendChild(this._label), this._updateFont(), this._updateStyles(this._themeService.getColorTheme())), this._domNode;
  }
  _updateStyles(e) {
    var t, i, n, s, o;
    if (!this._domNode)
      return;
    const a = e.getColor(jl), l = e.getColor(TV);
    this._domNode.style.backgroundColor = String((t = e.getColor(Di)) !== null && t !== void 0 ? t : ""), this._domNode.style.boxShadow = a ? ` 0 0 8px 2px ${a}` : "", this._domNode.style.border = l ? `1px solid ${l}` : "", this._domNode.style.color = String((i = e.getColor(MV)) !== null && i !== void 0 ? i : "");
    const d = e.getColor(RV);
    this._inputWithButton.domNode.style.backgroundColor = String((n = e.getColor(jx)) !== null && n !== void 0 ? n : ""), this._inputWithButton.input.style.backgroundColor = String((s = e.getColor(jx)) !== null && s !== void 0 ? s : ""), this._inputWithButton.domNode.style.borderWidth = d ? "1px" : "0px", this._inputWithButton.domNode.style.borderStyle = d ? "solid" : "none", this._inputWithButton.domNode.style.borderColor = (o = d == null ? void 0 : d.toString()) !== null && o !== void 0 ? o : "none";
  }
  _updateFont() {
    if (this._domNode === void 0)
      return;
    ct(this._label !== void 0, "RenameWidget#_updateFont: _label must not be undefined given _domNode is defined"), this._editor.applyFontInfo(this._inputWithButton.input);
    const e = this._editor.getOption(
      50
      /* EditorOption.fontInfo */
    );
    this._label.style.fontSize = `${this._computeLabelFontSize(e.fontSize)}px`;
  }
  _computeLabelFontSize(e) {
    return e * 0.8;
  }
  getPosition() {
    if (!this._visible || !this._editor.hasModel() || // @ulugbekna: shouldn't happen
    !this._editor.getDomNode())
      return null;
    const e = Rc(this.getDomNode().ownerDocument.body), t = Ei(this._editor.getDomNode()), i = this._getTopForPosition();
    this._nPxAvailableAbove = i + t.top, this._nPxAvailableBelow = e.height - this._nPxAvailableAbove;
    const n = this._editor.getOption(
      67
      /* EditorOption.lineHeight */
    ), { totalHeight: s } = ju.getLayoutInfo({ lineHeight: n }), o = this._nPxAvailableBelow > s * 6 ? [
      2,
      1
      /* ContentWidgetPositionPreference.ABOVE */
    ] : [
      1,
      2
      /* ContentWidgetPositionPreference.BELOW */
    ];
    return {
      position: this._position,
      preference: o
    };
  }
  beforeRender() {
    var e, t;
    const [i, n] = this._acceptKeybindings;
    return this._label.innerText = p({ key: "label", comment: ['placeholders are keybindings, e.g "F2 to Rename, Shift+F2 to Preview"'] }, "{0} to Rename, {1} to Preview", (e = this._keybindingService.lookupKeybinding(i)) === null || e === void 0 ? void 0 : e.getLabel(), (t = this._keybindingService.lookupKeybinding(n)) === null || t === void 0 ? void 0 : t.getLabel()), this._domNode.style.minWidth = "200px", null;
  }
  afterRender(e) {
    if (this._trace("invoking afterRender, position: ", e ? "not null" : "null"), e === null) {
      this.cancelInput(!0, "afterRender (because position is null)");
      return;
    }
    if (!this._editor.hasModel() || // shouldn't happen
    !this._editor.getDomNode())
      return;
    ct(this._renameCandidateListView), ct(this._nPxAvailableAbove !== void 0), ct(this._nPxAvailableBelow !== void 0);
    const t = Bl(this._inputWithButton.domNode), i = Bl(this._label);
    let n;
    e === 2 ? n = this._nPxAvailableBelow : n = this._nPxAvailableAbove, this._renameCandidateListView.layout({
      height: n - i - t,
      width: Ms(this._inputWithButton.domNode)
    });
  }
  acceptInput(e) {
    var t;
    this._trace("invoking acceptInput"), (t = this._currentAcceptInput) === null || t === void 0 || t.call(this, e);
  }
  cancelInput(e, t) {
    var i;
    this._trace(`invoking cancelInput, caller: ${t}, _currentCancelInput: ${this._currentAcceptInput ? "not undefined" : "undefined"}`), (i = this._currentCancelInput) === null || i === void 0 || i.call(this, e);
  }
  focusNextRenameSuggestion() {
    var e;
    !((e = this._renameCandidateListView) === null || e === void 0) && e.focusNext() || (this._inputWithButton.input.value = this._currentName);
  }
  focusPreviousRenameSuggestion() {
    var e;
    !((e = this._renameCandidateListView) === null || e === void 0) && e.focusPrevious() || (this._inputWithButton.input.value = this._currentName);
  }
  /**
   * @param requestRenameCandidates is `undefined` when there are no rename suggestion providers
   */
  getInput(e, t, i, n, s) {
    const { start: o, end: a } = this._getSelection(e, t);
    this._renameCts = s;
    const l = new q();
    this._nRenameSuggestionsInvocations = 0, this._hadAutomaticRenameSuggestionsInvocation = !1, n === void 0 ? this._inputWithButton.button.style.display = "none" : (this._inputWithButton.button.style.display = "flex", this._requestRenameCandidatesOnce = n, this._requestRenameCandidates(t, !1), l.add(W(this._inputWithButton.button, "click", () => this._requestRenameCandidates(t, !0))), l.add(W(this._inputWithButton.button, Q.KEY_DOWN, (c) => {
      const h = new Mt(c);
      (h.equals(
        3
        /* KeyCode.Enter */
      ) || h.equals(
        10
        /* KeyCode.Space */
      )) && (h.stopPropagation(), h.preventDefault(), this._requestRenameCandidates(t, !0));
    }))), this._isEditingRenameCandidate = !1, this._domNode.classList.toggle("preview", i), this._position = new A(e.startLineNumber, e.startColumn), this._currentName = t, this._inputWithButton.input.value = t, this._inputWithButton.input.setAttribute("selectionStart", o.toString()), this._inputWithButton.input.setAttribute("selectionEnd", a.toString()), this._inputWithButton.input.size = Math.max((e.endColumn - e.startColumn) * 1.1, 20), this._beforeFirstInputFieldEditSW.reset(), l.add(Se(() => {
      this._renameCts = void 0, s.dispose(!0);
    })), l.add(Se(() => {
      this._renameCandidateProvidersCts !== void 0 && (this._renameCandidateProvidersCts.dispose(!0), this._renameCandidateProvidersCts = void 0);
    })), l.add(Se(() => this._candidates.clear()));
    const d = new ab();
    return d.p.finally(() => {
      l.dispose(), this._hide();
    }), this._currentCancelInput = (c) => {
      var h;
      return this._trace("invoking _currentCancelInput"), this._currentAcceptInput = void 0, this._currentCancelInput = void 0, (h = this._renameCandidateListView) === null || h === void 0 || h.clearCandidates(), d.complete(c), !0;
    }, this._currentAcceptInput = (c) => {
      this._trace("invoking _currentAcceptInput"), ct(this._renameCandidateListView !== void 0);
      const h = this._renameCandidateListView.nCandidates;
      let u, g;
      const f = this._renameCandidateListView.focusedCandidate;
      if (f !== void 0 ? (this._trace("using new name from renameSuggestion"), u = f, g = { k: "renameSuggestion" }) : (this._trace("using new name from inputField"), u = this._inputWithButton.input.value, g = this._isEditingRenameCandidate ? { k: "userEditedRenameSuggestion" } : { k: "inputField" }), u === t || u.trim().length === 0) {
        this.cancelInput(!0, "_currentAcceptInput (because newName === value || newName.trim().length === 0)");
        return;
      }
      this._currentAcceptInput = void 0, this._currentCancelInput = void 0, this._renameCandidateListView.clearCandidates(), d.complete({
        newName: u,
        wantsPreview: i && c,
        stats: {
          source: g,
          nRenameSuggestions: h,
          timeBeforeFirstInputFieldEdit: this._timeBeforeFirstInputFieldEdit,
          nRenameSuggestionsInvocations: this._nRenameSuggestionsInvocations,
          hadAutomaticRenameSuggestionsInvocation: this._hadAutomaticRenameSuggestionsInvocation
        }
      });
    }, l.add(s.token.onCancellationRequested(() => this.cancelInput(!0, "cts.token.onCancellationRequested"))), l.add(this._editor.onDidBlurEditorWidget(() => {
      var c;
      return this.cancelInput(!(!((c = this._domNode) === null || c === void 0) && c.ownerDocument.hasFocus()), "editor.onDidBlurEditorWidget");
    })), this._show(), d.p;
  }
  _requestRenameCandidates(e, t) {
    if (this._requestRenameCandidatesOnce !== void 0 && (this._renameCandidateProvidersCts !== void 0 && this._renameCandidateProvidersCts.dispose(!0), ct(this._renameCts), this._inputWithButton.buttonState !== "stop")) {
      this._renameCandidateProvidersCts = new mi();
      const i = t ? wx.Invoke : wx.Automatic, n = this._requestRenameCandidatesOnce(i, this._renameCandidateProvidersCts.token);
      if (n.length === 0) {
        this._inputWithButton.setSparkleButton();
        return;
      }
      t || (this._hadAutomaticRenameSuggestionsInvocation = !0), this._nRenameSuggestionsInvocations += 1, this._inputWithButton.setStopButton(), this._updateRenameCandidates(n, e, this._renameCts.token);
    }
  }
  /**
   * This allows selecting only part of the symbol name in the input field based on the selection in the editor
   */
  _getSelection(e, t) {
    ct(this._editor.hasModel());
    const i = this._editor.getSelection();
    let n = 0, s = t.length;
    return !L.isEmpty(i) && !L.spansMultipleLines(i) && L.containsRange(e, i) && (n = Math.max(0, i.startColumn - e.startColumn), s = Math.min(e.endColumn, i.endColumn) - e.startColumn), { start: n, end: s };
  }
  _show() {
    this._trace("invoking _show"), this._editor.revealLineInCenterIfOutsideViewport(
      this._position.lineNumber,
      0
      /* ScrollType.Smooth */
    ), this._visible = !0, this._visibleContextKey.set(!0), this._editor.layoutContentWidget(this), setTimeout(() => {
      this._inputWithButton.input.focus(), this._inputWithButton.input.setSelectionRange(parseInt(this._inputWithButton.input.getAttribute("selectionStart")), parseInt(this._inputWithButton.input.getAttribute("selectionEnd")));
    }, 100);
  }
  async _updateRenameCandidates(e, t, i) {
    const n = (...d) => this._trace("_updateRenameCandidates", ...d);
    n("start");
    const s = await rb(Promise.allSettled(e), i);
    if (this._inputWithButton.setSparkleButton(), s === void 0) {
      n("returning early - received updateRenameCandidates results - undefined");
      return;
    }
    const o = s.flatMap((d) => d.status === "fulfilled" && qa(d.value) ? d.value : []);
    n(`received updateRenameCandidates results - total (unfiltered) ${o.length} candidates.`);
    const a = rd(o, (d) => d.newSymbolName);
    n(`distinct candidates - ${a.length} candidates.`);
    const l = a.filter(({ newSymbolName: d }) => d.trim().length > 0 && d !== this._inputWithButton.input.value && d !== t && !this._candidates.has(d));
    if (n(`valid distinct candidates - ${o.length} candidates.`), l.forEach((d) => this._candidates.add(d.newSymbolName)), l.length < 1) {
      n("returning early - no valid distinct candidates");
      return;
    }
    n("setting candidates"), this._renameCandidateListView.setCandidates(l), n("asking editor to re-layout"), this._editor.layoutContentWidget(this);
  }
  _hide() {
    this._trace("invoked _hide"), this._visible = !1, this._visibleContextKey.reset(), this._editor.layoutContentWidget(this);
  }
  _getTopForPosition() {
    const e = this._editor.getVisibleRanges();
    let t;
    return e.length > 0 ? t = e[0].startLineNumber : (this._logService.warn("RenameWidget#_getTopForPosition: this should not happen - visibleRanges is empty"), t = Math.max(1, this._position.lineNumber - 5)), this._editor.getTopForLineNumber(this._position.lineNumber) - this._editor.getTopForLineNumber(t);
  }
  _trace(...e) {
    this._logService.trace("RenameWidget", ...e);
  }
};
gN = rve([
  ww(2, $i),
  ww(3, _t),
  ww(4, De),
  ww(5, Pn)
], gN);
class OR {
  // FIXME@ulugbekna: rewrite using event emitters
  constructor(e, t) {
    this._disposables = new q(), this._availableHeight = 0, this._minimumWidth = 0, this._lineHeight = t.fontInfo.lineHeight, this._typicalHalfwidthCharacterWidth = t.fontInfo.typicalHalfwidthCharacterWidth, this._listContainer = document.createElement("div"), this._listContainer.className = "rename-box rename-candidate-list-container", e.appendChild(this._listContainer), this._listWidget = OR._createListWidget(this._listContainer, this._candidateViewHeight, t.fontInfo), this._listWidget.onDidChangeFocus((i) => {
      i.elements.length === 1 && t.onFocusChange(i.elements[0].newSymbolName);
    }, this._disposables), this._listWidget.onDidChangeSelection((i) => {
      i.elements.length === 1 && t.onSelectionChange();
    }, this._disposables), this._disposables.add(this._listWidget.onDidBlur((i) => {
      this._listWidget.setFocus([]);
    })), this._listWidget.style(sg({
      listInactiveFocusForeground: ic,
      listInactiveFocusBackground: nc
    }));
  }
  dispose() {
    this._listWidget.dispose(), this._disposables.dispose();
  }
  // height - max height allowed by parent element
  layout({ height: e, width: t }) {
    this._availableHeight = e, this._minimumWidth = t;
  }
  setCandidates(e) {
    this._listWidget.splice(0, 0, e);
    const t = this._pickListHeight(this._listWidget.length), i = this._pickListWidth(e);
    this._listWidget.layout(t, i), this._listContainer.style.height = `${t}px`, this._listContainer.style.width = `${i}px`, el(p("renameSuggestionsReceivedAria", "Received {0} rename suggestions", e.length));
  }
  clearCandidates() {
    this._listContainer.style.height = "0px", this._listContainer.style.width = "0px", this._listWidget.splice(0, this._listWidget.length, []);
  }
  get nCandidates() {
    return this._listWidget.length;
  }
  get focusedCandidate() {
    if (this._listWidget.length === 0)
      return;
    const e = this._listWidget.getSelectedElements()[0];
    if (e !== void 0)
      return e.newSymbolName;
    const t = this._listWidget.getFocusedElements()[0];
    if (t !== void 0)
      return t.newSymbolName;
  }
  focusNext() {
    if (this._listWidget.length === 0)
      return !1;
    const e = this._listWidget.getFocus();
    if (e.length === 0)
      return this._listWidget.focusFirst(), this._listWidget.reveal(0), !0;
    if (e[0] === this._listWidget.length - 1)
      return this._listWidget.setFocus([]), this._listWidget.reveal(0), !1;
    {
      this._listWidget.focusNext();
      const t = this._listWidget.getFocus()[0];
      return this._listWidget.reveal(t), !0;
    }
  }
  /**
   * @returns true if focus is moved to previous element
   */
  focusPrevious() {
    if (this._listWidget.length === 0)
      return !1;
    const e = this._listWidget.getFocus();
    if (e.length === 0) {
      this._listWidget.focusLast();
      const t = this._listWidget.getFocus()[0];
      return this._listWidget.reveal(t), !0;
    } else {
      if (e[0] === 0)
        return this._listWidget.setFocus([]), !1;
      {
        this._listWidget.focusPrevious();
        const t = this._listWidget.getFocus()[0];
        return this._listWidget.reveal(t), !0;
      }
    }
  }
  clearFocus() {
    this._listWidget.setFocus([]);
  }
  get _candidateViewHeight() {
    const { totalHeight: e } = ju.getLayoutInfo({ lineHeight: this._lineHeight });
    return e;
  }
  _pickListHeight(e) {
    const t = this._candidateViewHeight * e;
    return Math.min(t, this._availableHeight, this._candidateViewHeight * 7);
  }
  _pickListWidth(e) {
    const t = Math.ceil(Math.max(...e.map((n) => n.newSymbolName.length)) * this._typicalHalfwidthCharacterWidth);
    return Math.max(
      this._minimumWidth,
      25 + t + 10
      /* (possibly visible) scrollbar width */
      // TODO@ulugbekna: approximate calc - clean this up
    );
  }
  static _createListWidget(e, t, i) {
    const n = new class {
      getTemplateId(o) {
        return "candidate";
      }
      getHeight(o) {
        return t;
      }
    }(), s = new class {
      constructor() {
        this.templateId = "candidate";
      }
      renderTemplate(o) {
        return new ju(o, i);
      }
      renderElement(o, a, l) {
        l.populate(o);
      }
      disposeTemplate(o) {
        o.dispose();
      }
    }();
    return new Co("NewSymbolNameCandidates", e, n, [s], {
      keyboardSupport: !1,
      // @ulugbekna: because we handle keyboard events through proper commands & keybinding service, see `rename.ts`
      mouseSupport: !0,
      multipleSelectionSupport: !1
    });
  }
}
class ave {
  constructor() {
    this._onDidInputChange = new R(), this.onDidInputChange = this._onDidInputChange.event, this._disposables = new q();
  }
  get domNode() {
    return this._domNode || (this._domNode = document.createElement("div"), this._domNode.className = "rename-input-with-button", this._domNode.style.display = "flex", this._domNode.style.flexDirection = "row", this._domNode.style.alignItems = "center", this._inputNode = document.createElement("input"), this._inputNode.className = "rename-input", this._inputNode.type = "text", this._inputNode.style.border = "none", this._inputNode.setAttribute("aria-label", p("renameAriaLabel", "Rename input. Type new name and press Enter to commit.")), this._domNode.appendChild(this._inputNode), this._buttonNode = document.createElement("div"), this._buttonNode.className = "rename-suggestions-button", this._buttonNode.setAttribute("tabindex", "0"), this._buttonGenHoverText = p("generateRenameSuggestionsButton", "Generate new name suggestions"), this._buttonCancelHoverText = p("cancelRenameSuggestionsButton", "Cancel"), this._buttonHover = da().setupUpdatableHover(us("element"), this._buttonNode, this._buttonGenHoverText), this._disposables.add(this._buttonHover), this._domNode.appendChild(this._buttonNode), this._disposables.add(W(this.input, Q.INPUT, () => this._onDidInputChange.fire())), this._disposables.add(W(this.input, Q.KEY_DOWN, (e) => {
      const t = new Mt(e);
      (t.keyCode === 15 || t.keyCode === 17) && this._onDidInputChange.fire();
    })), this._disposables.add(W(this.input, Q.CLICK, () => this._onDidInputChange.fire())), this._disposables.add(W(this.input, Q.FOCUS, () => {
      this.domNode.style.outlineWidth = "1px", this.domNode.style.outlineStyle = "solid", this.domNode.style.outlineOffset = "-1px", this.domNode.style.outlineColor = "var(--vscode-focusBorder)";
    })), this._disposables.add(W(this.input, Q.BLUR, () => {
      this.domNode.style.outline = "none";
    }))), this._domNode;
  }
  get input() {
    return ct(this._inputNode), this._inputNode;
  }
  get button() {
    return ct(this._buttonNode), this._buttonNode;
  }
  get buttonState() {
    return this._buttonState;
  }
  setSparkleButton() {
    var e, t;
    this._buttonState = "sparkle", (e = this._sparkleIcon) !== null && e !== void 0 || (this._sparkleIcon = Lu(me.sparkle)), pn(this.button), this.button.appendChild(this._sparkleIcon), this.button.setAttribute("aria-label", "Generating new name suggestions"), (t = this._buttonHover) === null || t === void 0 || t.update(this._buttonGenHoverText), this.input.focus();
  }
  setStopButton() {
    var e, t;
    this._buttonState = "stop", (e = this._stopIcon) !== null && e !== void 0 || (this._stopIcon = Lu(me.primitiveSquare)), pn(this.button), this.button.appendChild(this._stopIcon), this.button.setAttribute("aria-label", "Cancel generating new name suggestions"), (t = this._buttonHover) === null || t === void 0 || t.update(this._buttonCancelHoverText), this.input.focus();
  }
  dispose() {
    this._disposables.dispose();
  }
}
class ju {
  constructor(e, t) {
    this._domNode = document.createElement("div"), this._domNode.className = "rename-box rename-candidate", this._domNode.style.display = "flex", this._domNode.style.columnGap = "5px", this._domNode.style.alignItems = "center", this._domNode.style.height = `${t.lineHeight}px`, this._domNode.style.padding = `${ju._PADDING}px`;
    const i = document.createElement("div");
    i.style.display = "flex", i.style.alignItems = "center", i.style.width = i.style.height = `${t.lineHeight * 0.8}px`, this._domNode.appendChild(i), this._icon = Lu(me.sparkle), this._icon.style.display = "none", i.appendChild(this._icon), this._label = document.createElement("div"), _n(this._label, t), this._domNode.appendChild(this._label), e.appendChild(this._domNode);
  }
  populate(e) {
    this._updateIcon(e), this._updateLabel(e);
  }
  _updateIcon(e) {
    var t;
    const i = !!(!((t = e.tags) === null || t === void 0) && t.includes(QK.AIGenerated));
    this._icon.style.display = i ? "inherit" : "none";
  }
  _updateLabel(e) {
    this._label.innerText = e.newSymbolName;
  }
  static getLayoutInfo({ lineHeight: e }) {
    return { totalHeight: e + ju._PADDING * 2 };
  }
  dispose() {
  }
}
ju._PADDING = 2;
var lve = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Rd = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, fN;
class FR {
  constructor(e, t, i) {
    this.model = e, this.position = t, this._providerRenameIdx = 0, this._providers = i.ordered(e);
  }
  hasProvider() {
    return this._providers.length > 0;
  }
  async resolveRenameLocation(e) {
    const t = [];
    for (this._providerRenameIdx = 0; this._providerRenameIdx < this._providers.length; this._providerRenameIdx++) {
      const n = this._providers[this._providerRenameIdx];
      if (!n.resolveRenameLocation)
        break;
      const s = await n.resolveRenameLocation(this.model, this.position, e);
      if (s) {
        if (s.rejectReason) {
          t.push(s.rejectReason);
          continue;
        }
        return s;
      }
    }
    this._providerRenameIdx = 0;
    const i = this.model.getWordAtPosition(this.position);
    return i ? {
      range: new L(this.position.lineNumber, i.startColumn, this.position.lineNumber, i.endColumn),
      text: i.word,
      rejectReason: t.length > 0 ? t.join(`
`) : void 0
    } : {
      range: L.fromPositions(this.position),
      text: "",
      rejectReason: t.length > 0 ? t.join(`
`) : void 0
    };
  }
  async provideRenameEdits(e, t) {
    return this._provideRenameEdits(e, this._providerRenameIdx, [], t);
  }
  async _provideRenameEdits(e, t, i, n) {
    const s = this._providers[t];
    if (!s)
      return {
        edits: [],
        rejectReason: i.join(`
`)
      };
    const o = await s.provideRenameEdits(this.model, this.position, e, n);
    if (o) {
      if (o.rejectReason)
        return this._provideRenameEdits(e, t + 1, i.concat(o.rejectReason), n);
    } else return this._provideRenameEdits(e, t + 1, i.concat(p("no result", "No result.")), n);
    return o;
  }
}
async function dve(r, e, t, i) {
  const n = new FR(e, t, r), s = await n.resolveRenameLocation(at.None);
  return s != null && s.rejectReason ? { edits: [], rejectReason: s.rejectReason } : n.provideRenameEdits(i, at.None);
}
let md = fN = class {
  static get(e) {
    return e.getContribution(fN.ID);
  }
  constructor(e, t, i, n, s, o, a, l, d) {
    this.editor = e, this._instaService = t, this._notificationService = i, this._bulkEditService = n, this._progressService = s, this._logService = o, this._configService = a, this._languageFeaturesService = l, this._telemetryService = d, this._disposableStore = new q(), this._cts = new mi(), this._renameWidget = this._disposableStore.add(this._instaService.createInstance(gN, this.editor, ["acceptRenameInput", "acceptRenameInputWithPreview"]));
  }
  dispose() {
    this._disposableStore.dispose(), this._cts.dispose(!0);
  }
  async run() {
    var e, t;
    const i = this._logService.trace.bind(this._logService, "[rename]");
    if (this._cts.dispose(!0), this._cts = new mi(), !this.editor.hasModel()) {
      i("editor has no model");
      return;
    }
    const n = this.editor.getPosition(), s = new FR(this.editor.getModel(), n, this._languageFeaturesService.renameProvider);
    if (!s.hasProvider()) {
      i("skeleton has no provider");
      return;
    }
    const o = new zc(this.editor, 5, void 0, this._cts.token);
    let a;
    try {
      i("resolving rename location");
      const _ = s.resolveRenameLocation(o.token);
      this._progressService.showWhile(_, 250), a = await _, i("resolved rename location");
    } catch (_) {
      _ instanceof Ja ? i("resolve rename location cancelled", JSON.stringify(_, null, "	")) : (i("resolve rename location failed", _ instanceof Error ? _ : JSON.stringify(_, null, "	")), (typeof _ == "string" || Gr(_)) && ((e = ss.get(this.editor)) === null || e === void 0 || e.showMessage(_ || p("resolveRenameLocationFailed", "An unknown error occurred while resolving rename location"), n)));
      return;
    } finally {
      o.dispose();
    }
    if (!a) {
      i("returning early - no loc");
      return;
    }
    if (a.rejectReason) {
      i(`returning early - rejected with reason: ${a.rejectReason}`, a.rejectReason), (t = ss.get(this.editor)) === null || t === void 0 || t.showMessage(a.rejectReason, n);
      return;
    }
    if (o.token.isCancellationRequested) {
      i("returning early - cts1 cancelled");
      return;
    }
    const l = new zc(this.editor, 5, a.range, this._cts.token), d = this.editor.getModel(), c = this._languageFeaturesService.newSymbolNamesProvider.all(d), h = await Promise.all(c.map(async (_) => {
      var v;
      return [_, (v = await _.supportsAutomaticNewSymbolNamesTriggerKind) !== null && v !== void 0 ? v : !1];
    })), u = (_, v) => {
      let b = h.slice();
      return _ === wx.Automatic && (b = b.filter(([C, w]) => w)), b.map(([C]) => C.provideNewSymbolNames(d, a.range, _, v));
    };
    i("creating rename input field and awaiting its result");
    const g = this._bulkEditService.hasPreviewHandler() && this._configService.getValue(this.editor.getModel().uri, "editor.rename.enablePreview"), f = await this._renameWidget.getInput(a.range, a.text, g, c.length > 0 ? u : void 0, l);
    if (i("received response from rename input field"), c.length > 0 && this._reportTelemetry(c.length, d.getLanguageId(), f), typeof f == "boolean") {
      i(`returning early - rename input field response - ${f}`), f && this.editor.focus(), l.dispose();
      return;
    }
    this.editor.focus(), i("requesting rename edits");
    const m = rb(s.provideRenameEdits(f.newName, l.token), l.token).then(async (_) => {
      if (!_) {
        i("returning early - no rename edits result");
        return;
      }
      if (!this.editor.hasModel()) {
        i("returning early - no model after rename edits are provided");
        return;
      }
      if (_.rejectReason) {
        i(`returning early - rejected with reason: ${_.rejectReason}`), this._notificationService.info(_.rejectReason);
        return;
      }
      this.editor.setSelection(L.fromPositions(this.editor.getSelection().getPosition())), i("applying edits"), this._bulkEditService.apply(_, {
        editor: this.editor,
        showPreview: f.wantsPreview,
        label: p("label", "Renaming '{0}' to '{1}'", a == null ? void 0 : a.text, f.newName),
        code: "undoredo.rename",
        quotableLabel: p("quotableLabel", "Renaming {0} to {1}", a == null ? void 0 : a.text, f.newName),
        respectAutoSaveConfig: !0
      }).then((v) => {
        i("edits applied"), v.ariaSummary && Ls(p("aria", "Successfully renamed '{0}' to '{1}'. Summary: {2}", a.text, f.newName, v.ariaSummary));
      }).catch((v) => {
        i(`error when applying edits ${JSON.stringify(v, null, "	")}`), this._notificationService.error(p("rename.failedApply", "Rename failed to apply edits")), this._logService.error(v);
      });
    }, (_) => {
      i("error when providing rename edits", JSON.stringify(_, null, "	")), this._notificationService.error(p("rename.failed", "Rename failed to compute edits")), this._logService.error(_);
    }).finally(() => {
      l.dispose();
    });
    return i("returning rename operation"), this._progressService.showWhile(m, 250), m;
  }
  acceptRenameInput(e) {
    this._renameWidget.acceptInput(e);
  }
  cancelRenameInput() {
    this._renameWidget.cancelInput(!0, "cancelRenameInput command");
  }
  focusNextRenameSuggestion() {
    this._renameWidget.focusNextRenameSuggestion();
  }
  focusPreviousRenameSuggestion() {
    this._renameWidget.focusPreviousRenameSuggestion();
  }
  _reportTelemetry(e, t, i) {
    const n = typeof i == "boolean" ? {
      kind: "cancelled",
      languageId: t,
      nRenameSuggestionProviders: e
    } : {
      kind: "accepted",
      languageId: t,
      nRenameSuggestionProviders: e,
      source: i.stats.source.k,
      nRenameSuggestions: i.stats.nRenameSuggestions,
      timeBeforeFirstInputFieldEdit: i.stats.timeBeforeFirstInputFieldEdit,
      wantsPreview: i.wantsPreview,
      nRenameSuggestionsInvocations: i.stats.nRenameSuggestionsInvocations,
      hadAutomaticRenameSuggestionsInvocation: i.stats.hadAutomaticRenameSuggestionsInvocation
    };
    this._telemetryService.publicLog2("renameInvokedEvent", n);
  }
};
md.ID = "editor.contrib.renameController";
md = fN = lve([
  Rd(1, be),
  Rd(2, xi),
  Rd(3, yb),
  Rd(4, sh),
  Rd(5, Pn),
  Rd(6, h1),
  Rd(7, he),
  Rd(8, kn)
], md);
class cve extends ae {
  constructor() {
    super({
      id: "editor.action.rename",
      label: p("rename.label", "Rename Symbol"),
      alias: "Rename Symbol",
      precondition: U.and(x.writable, x.hasRenameProvider),
      kbOpts: {
        kbExpr: x.editorTextFocus,
        primary: 60,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      contextMenuOpts: {
        group: "1_modification",
        order: 1.1
      }
    });
  }
  runCommand(e, t) {
    const i = e.get(ht), [n, s] = Array.isArray(t) && t || [void 0, void 0];
    return Ee.isUri(n) && A.isIPosition(s) ? i.openCodeEditor({ resource: n }, i.getActiveCodeEditor()).then((o) => {
      o && (o.setPosition(s), o.invokeWithinContext((a) => (this.reportTelemetry(a, o), this.run(a, o))));
    }, He) : super.runCommand(e, t);
  }
  run(e, t) {
    const i = e.get(Pn), n = md.get(t);
    return n ? (i.trace("[RenameAction] got controller, running..."), n.run()) : (i.trace("[RenameAction] returning early - controller missing"), Promise.resolve());
  }
}
gt(
  md.ID,
  md,
  4
  /* EditorContributionInstantiation.Lazy */
);
Y(cve);
const WR = Ui.bindToContribution(md.get);
se(new WR({
  id: "acceptRenameInput",
  precondition: Kp,
  handler: (r) => r.acceptRenameInput(!1),
  kbOpts: {
    weight: 199,
    kbExpr: U.and(x.focus, U.not("isComposing")),
    primary: 3
    /* KeyCode.Enter */
  }
}));
se(new WR({
  id: "acceptRenameInputWithPreview",
  precondition: U.and(Kp, U.has("config.editor.rename.enablePreview")),
  handler: (r) => r.acceptRenameInput(!0),
  kbOpts: {
    weight: 199,
    kbExpr: U.and(x.focus, U.not("isComposing")),
    primary: 2051
    /* KeyCode.Enter */
  }
}));
se(new WR({
  id: "cancelRenameInput",
  precondition: Kp,
  handler: (r) => r.cancelRenameInput(),
  kbOpts: {
    weight: 199,
    kbExpr: x.focus,
    primary: 9,
    secondary: [
      1033
      /* KeyCode.Escape */
    ]
  }
}));
Rt(class extends cs {
  constructor() {
    super({
      id: "focusNextRenameSuggestion",
      title: {
        ...Me("focusNextRenameSuggestion", "Focus Next Rename Suggestion")
      },
      precondition: Kp,
      keybinding: [
        {
          primary: 18,
          weight: 199
        }
      ]
    });
  }
  run(e) {
    const t = e.get(ht).getFocusedCodeEditor();
    if (!t)
      return;
    const i = md.get(t);
    i && i.focusNextRenameSuggestion();
  }
});
Rt(class extends cs {
  constructor() {
    super({
      id: "focusPreviousRenameSuggestion",
      title: {
        ...Me("focusPreviousRenameSuggestion", "Focus Previous Rename Suggestion")
      },
      precondition: Kp,
      keybinding: [
        {
          primary: 16,
          weight: 199
        }
      ]
    });
  }
  run(e) {
    const t = e.get(ht).getFocusedCodeEditor();
    if (!t)
      return;
    const i = md.get(t);
    i && i.focusPreviousRenameSuggestion();
  }
});
ul("_executeDocumentRenameProvider", function(r, e, t, ...i) {
  const [n] = i;
  ct(typeof n == "string");
  const { renameProvider: s } = r.get(he);
  return dve(s, e, t, n);
});
ul("_executePrepareRename", async function(r, e, t) {
  const { renameProvider: i } = r.get(he), s = await new FR(e, t, i).resolveRenameLocation(at.None);
  if (s != null && s.rejectReason)
    throw new Error(s.rejectReason);
  return s;
});
si.as(aa.Configuration).registerConfiguration({
  id: "editor",
  properties: {
    "editor.rename.enablePreview": {
      scope: 5,
      description: p("enablePreview", "Enable/disable the ability to preview changes before renaming"),
      default: !0,
      type: "boolean"
    }
  }
});
var hve = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, kB = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
let Zv = class extends P {
  constructor(e, t, i) {
    super(), this.editor = e, this.languageConfigurationService = t, this.editorWorkerService = i, this.decorations = this.editor.createDecorationsCollection(), this.options = this.createOptions(e.getOption(
      73
      /* EditorOption.minimap */
    )), this.computePromise = null, this.currentOccurrences = {}, this._register(e.onDidChangeModel((n) => {
      this.currentOccurrences = {}, this.options = this.createOptions(e.getOption(
        73
        /* EditorOption.minimap */
      )), this.stop(), this.computeSectionHeaders.schedule(0);
    })), this._register(e.onDidChangeModelLanguage((n) => {
      this.currentOccurrences = {}, this.options = this.createOptions(e.getOption(
        73
        /* EditorOption.minimap */
      )), this.stop(), this.computeSectionHeaders.schedule(0);
    })), this._register(t.onDidChange((n) => {
      var s;
      const o = (s = this.editor.getModel()) === null || s === void 0 ? void 0 : s.getLanguageId();
      o && n.affects(o) && (this.currentOccurrences = {}, this.options = this.createOptions(e.getOption(
        73
        /* EditorOption.minimap */
      )), this.stop(), this.computeSectionHeaders.schedule(0));
    })), this._register(e.onDidChangeConfiguration((n) => {
      this.options && !n.hasChanged(
        73
        /* EditorOption.minimap */
      ) || (this.options = this.createOptions(e.getOption(
        73
        /* EditorOption.minimap */
      )), this.updateDecorations([]), this.stop(), this.computeSectionHeaders.schedule(0));
    })), this._register(this.editor.onDidChangeModelContent((n) => {
      this.computeSectionHeaders.schedule();
    })), this._register(e.onDidChangeModelTokens((n) => {
      this.computeSectionHeaders.isScheduled() || this.computeSectionHeaders.schedule(1e3);
    })), this.computeSectionHeaders = this._register(new xt(() => {
      this.findSectionHeaders();
    }, 250)), this.computeSectionHeaders.schedule(0);
  }
  createOptions(e) {
    if (!e || !this.editor.hasModel())
      return;
    const t = this.editor.getModel().getLanguageId();
    if (!t)
      return;
    const i = this.languageConfigurationService.getLanguageConfiguration(t).comments, n = this.languageConfigurationService.getLanguageConfiguration(t).foldingRules;
    if (!(!i && !(n != null && n.markers)))
      return {
        foldingRules: n,
        findMarkSectionHeaders: e.showMarkSectionHeaders,
        findRegionSectionHeaders: e.showRegionSectionHeaders
      };
  }
  findSectionHeaders() {
    var e, t;
    if (!this.editor.hasModel() || !(!((e = this.options) === null || e === void 0) && e.findMarkSectionHeaders) && !(!((t = this.options) === null || t === void 0) && t.findRegionSectionHeaders))
      return;
    const i = this.editor.getModel();
    if (i.isDisposed() || i.isTooLargeForSyncing())
      return;
    const n = i.getVersionId();
    this.editorWorkerService.findSectionHeaders(i.uri, this.options).then((s) => {
      i.isDisposed() || i.getVersionId() !== n || this.updateDecorations(s);
    });
  }
  updateDecorations(e) {
    const t = this.editor.getModel();
    t && (e = e.filter((s) => {
      if (!s.shouldBeInComments)
        return !0;
      const o = t.validateRange(s.range), a = t.tokenization.getLineTokens(o.startLineNumber), l = a.findTokenIndexAtOffset(o.startColumn - 1), d = a.getStandardTokenType(l);
      return a.getLanguageId(l) === t.getLanguageId() && d === 1;
    }));
    const i = Object.values(this.currentOccurrences).map((s) => s.decorationId), n = e.map((s) => uve(s));
    this.editor.changeDecorations((s) => {
      const o = s.deltaDecorations(i, n);
      this.currentOccurrences = {};
      for (let a = 0, l = o.length; a < l; a++) {
        const d = { sectionHeader: e[a], decorationId: o[a] };
        this.currentOccurrences[d.decorationId] = d;
      }
    });
  }
  stop() {
    this.computeSectionHeaders.cancel(), this.computePromise && (this.computePromise.cancel(), this.computePromise = null);
  }
  dispose() {
    super.dispose(), this.stop(), this.decorations.clear();
  }
};
Zv.ID = "editor.sectionHeaderDetector";
Zv = hve([
  kB(1, Ot),
  kB(2, Uo)
], Zv);
function uve(r) {
  return {
    range: r.range,
    options: Fe.createDynamic({
      description: "section-header",
      stickiness: 3,
      collapseOnReplaceEdit: !0,
      minimap: {
        color: void 0,
        position: 1,
        sectionHeaderStyle: r.hasSeparatorLine ? 2 : 1,
        sectionHeaderText: r.text
      }
    })
  };
}
gt(
  Zv.ID,
  Zv,
  1
  /* EditorContributionInstantiation.AfterFirstRender */
);
function gve(r) {
  for (let e = 0, t = r.length; e < t; e += 4) {
    const i = r[e + 0], n = r[e + 1], s = r[e + 2], o = r[e + 3];
    r[e + 0] = o, r[e + 1] = s, r[e + 2] = n, r[e + 3] = i;
  }
}
function fve(r) {
  const e = new Uint8Array(r.buffer, r.byteOffset, r.length * 4);
  return KB() || gve(e), b0.wrap(e);
}
function v$(r) {
  const e = new Uint32Array(pve(r));
  let t = 0;
  if (e[t++] = r.id, r.type === "full")
    e[t++] = 1, e[t++] = r.data.length, e.set(r.data, t), t += r.data.length;
  else {
    e[t++] = 2, e[t++] = r.deltas.length;
    for (const i of r.deltas)
      e[t++] = i.start, e[t++] = i.deleteCount, i.data ? (e[t++] = i.data.length, e.set(i.data, t), t += i.data.length) : e[t++] = 0;
  }
  return fve(e);
}
function pve(r) {
  let e = 0;
  if (e += 2, r.type === "full")
    e += 1 + r.data.length;
  else {
    e += 1, e += 3 * r.deltas.length;
    for (const t of r.deltas)
      t.data && (e += t.data.length);
  }
  return e;
}
function oD(r) {
  return r && !!r.data;
}
function b$(r) {
  return r && Array.isArray(r.edits);
}
class mve {
  constructor(e, t, i) {
    this.provider = e, this.tokens = t, this.error = i;
  }
}
function C$(r, e) {
  return r.has(e);
}
function _ve(r, e) {
  const t = r.orderedGroups(e);
  return t.length > 0 ? t[0] : [];
}
async function w$(r, e, t, i, n) {
  const s = _ve(r, e), o = await Promise.all(s.map(async (a) => {
    let l, d = null;
    try {
      l = await a.provideDocumentSemanticTokens(e, a === t ? i : null, n);
    } catch (c) {
      d = c, l = null;
    }
    return (!l || !oD(l) && !b$(l)) && (l = null), new mve(a, l, d);
  }));
  for (const a of o) {
    if (a.error)
      throw a.error;
    if (a.tokens)
      return a;
  }
  return o.length > 0 ? o[0] : null;
}
function vve(r, e) {
  const t = r.orderedGroups(e);
  return t.length > 0 ? t[0] : null;
}
class bve {
  constructor(e, t) {
    this.provider = e, this.tokens = t;
  }
}
function Cve(r, e) {
  return r.has(e);
}
function S$(r, e) {
  const t = r.orderedGroups(e);
  return t.length > 0 ? t[0] : [];
}
async function BR(r, e, t, i) {
  const n = S$(r, e), s = await Promise.all(n.map(async (o) => {
    let a;
    try {
      a = await o.provideDocumentRangeSemanticTokens(e, t, i);
    } catch (l) {
      _i(l), a = null;
    }
    return (!a || !oD(a)) && (a = null), new bve(o, a);
  }));
  for (const o of s)
    if (o.tokens)
      return o;
  return s.length > 0 ? s[0] : null;
}
st.registerCommand("_provideDocumentSemanticTokensLegend", async (r, ...e) => {
  const [t] = e;
  ct(t instanceof Ee);
  const i = r.get(ii).getModel(t);
  if (!i)
    return;
  const { documentSemanticTokensProvider: n } = r.get(he), s = vve(n, i);
  return s ? s[0].getLegend() : r.get($t).executeCommand("_provideDocumentRangeSemanticTokensLegend", t);
});
st.registerCommand("_provideDocumentSemanticTokens", async (r, ...e) => {
  const [t] = e;
  ct(t instanceof Ee);
  const i = r.get(ii).getModel(t);
  if (!i)
    return;
  const { documentSemanticTokensProvider: n } = r.get(he);
  if (!C$(n, i))
    return r.get($t).executeCommand("_provideDocumentRangeSemanticTokens", t, i.getFullModelRange());
  const s = await w$(n, i, null, null, at.None);
  if (!s)
    return;
  const { provider: o, tokens: a } = s;
  if (!a || !oD(a))
    return;
  const l = v$({
    id: 0,
    type: "full",
    data: a.data
  });
  return a.resultId && o.releaseDocumentSemanticTokens(a.resultId), l;
});
st.registerCommand("_provideDocumentRangeSemanticTokensLegend", async (r, ...e) => {
  const [t, i] = e;
  ct(t instanceof Ee);
  const n = r.get(ii).getModel(t);
  if (!n)
    return;
  const { documentRangeSemanticTokensProvider: s } = r.get(he), o = S$(s, n);
  if (o.length === 0)
    return;
  if (o.length === 1)
    return o[0].getLegend();
  if (!i || !L.isIRange(i))
    return console.warn("provideDocumentRangeSemanticTokensLegend might be out-of-sync with provideDocumentRangeSemanticTokens unless a range argument is passed in"), o[0].getLegend();
  const a = await BR(s, n, L.lift(i), at.None);
  if (a)
    return a.provider.getLegend();
});
st.registerCommand("_provideDocumentRangeSemanticTokens", async (r, ...e) => {
  const [t, i] = e;
  ct(t instanceof Ee), ct(L.isIRange(i));
  const n = r.get(ii).getModel(t);
  if (!n)
    return;
  const { documentRangeSemanticTokensProvider: s } = r.get(he), o = await BR(s, n, L.lift(i), at.None);
  if (!(!o || !o.tokens))
    return v$({
      id: 0,
      type: "full",
      data: o.tokens.data
    });
});
const HR = "editor.semanticHighlighting";
function nS(r, e, t) {
  var i;
  const n = (i = t.getValue(HR, { overrideIdentifier: r.getLanguageId(), resource: r.uri })) === null || i === void 0 ? void 0 : i.enabled;
  return typeof n == "boolean" ? n : e.getColorTheme().semanticHighlighting;
}
var y$ = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Na = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, Bd;
let pN = class extends P {
  constructor(e, t, i, n, s, o) {
    super(), this._watchers = /* @__PURE__ */ Object.create(null);
    const a = (c) => {
      this._watchers[c.uri.toString()] = new Yv(c, e, i, s, o);
    }, l = (c, h) => {
      h.dispose(), delete this._watchers[c.uri.toString()];
    }, d = () => {
      for (const c of t.getModels()) {
        const h = this._watchers[c.uri.toString()];
        nS(c, i, n) ? h || a(c) : h && l(c, h);
      }
    };
    t.getModels().forEach((c) => {
      nS(c, i, n) && a(c);
    }), this._register(t.onModelAdded((c) => {
      nS(c, i, n) && a(c);
    })), this._register(t.onModelRemoved((c) => {
      const h = this._watchers[c.uri.toString()];
      h && l(c, h);
    })), this._register(n.onDidChangeConfiguration((c) => {
      c.affectsConfiguration(HR) && d();
    })), this._register(i.onDidColorThemeChange(d));
  }
  dispose() {
    for (const e of Object.values(this._watchers))
      e.dispose();
    super.dispose();
  }
};
pN = y$([
  Na(0, W0),
  Na(1, ii),
  Na(2, $i),
  Na(3, Ge),
  Na(4, Vo),
  Na(5, he)
], pN);
let Yv = Bd = class extends P {
  constructor(e, t, i, n, s) {
    super(), this._semanticTokensStylingService = t, this._isDisposed = !1, this._model = e, this._provider = s.documentSemanticTokensProvider, this._debounceInformation = n.for(this._provider, "DocumentSemanticTokens", { min: Bd.REQUEST_MIN_DELAY, max: Bd.REQUEST_MAX_DELAY }), this._fetchDocumentSemanticTokens = this._register(new xt(() => this._fetchDocumentSemanticTokensNow(), Bd.REQUEST_MIN_DELAY)), this._currentDocumentResponse = null, this._currentDocumentRequestCancellationTokenSource = null, this._documentProvidersChangeListeners = [], this._providersChangedDuringRequest = !1, this._register(this._model.onDidChangeContent(() => {
      this._fetchDocumentSemanticTokens.isScheduled() || this._fetchDocumentSemanticTokens.schedule(this._debounceInformation.get(this._model));
    })), this._register(this._model.onDidChangeAttached(() => {
      this._fetchDocumentSemanticTokens.isScheduled() || this._fetchDocumentSemanticTokens.schedule(this._debounceInformation.get(this._model));
    })), this._register(this._model.onDidChangeLanguage(() => {
      this._currentDocumentResponse && (this._currentDocumentResponse.dispose(), this._currentDocumentResponse = null), this._currentDocumentRequestCancellationTokenSource && (this._currentDocumentRequestCancellationTokenSource.cancel(), this._currentDocumentRequestCancellationTokenSource = null), this._setDocumentSemanticTokens(null, null, null, []), this._fetchDocumentSemanticTokens.schedule(0);
    }));
    const o = () => {
      zt(this._documentProvidersChangeListeners), this._documentProvidersChangeListeners = [];
      for (const a of this._provider.all(e))
        typeof a.onDidChange == "function" && this._documentProvidersChangeListeners.push(a.onDidChange(() => {
          if (this._currentDocumentRequestCancellationTokenSource) {
            this._providersChangedDuringRequest = !0;
            return;
          }
          this._fetchDocumentSemanticTokens.schedule(0);
        }));
    };
    o(), this._register(this._provider.onDidChange(() => {
      o(), this._fetchDocumentSemanticTokens.schedule(this._debounceInformation.get(this._model));
    })), this._register(i.onDidColorThemeChange((a) => {
      this._setDocumentSemanticTokens(null, null, null, []), this._fetchDocumentSemanticTokens.schedule(this._debounceInformation.get(this._model));
    })), this._fetchDocumentSemanticTokens.schedule(0);
  }
  dispose() {
    this._currentDocumentResponse && (this._currentDocumentResponse.dispose(), this._currentDocumentResponse = null), this._currentDocumentRequestCancellationTokenSource && (this._currentDocumentRequestCancellationTokenSource.cancel(), this._currentDocumentRequestCancellationTokenSource = null), zt(this._documentProvidersChangeListeners), this._documentProvidersChangeListeners = [], this._setDocumentSemanticTokens(null, null, null, []), this._isDisposed = !0, super.dispose();
  }
  _fetchDocumentSemanticTokensNow() {
    if (this._currentDocumentRequestCancellationTokenSource)
      return;
    if (!C$(this._provider, this._model)) {
      this._currentDocumentResponse && this._model.tokenization.setSemanticTokens(null, !1);
      return;
    }
    if (!this._model.isAttachedToEditor())
      return;
    const e = new mi(), t = this._currentDocumentResponse ? this._currentDocumentResponse.provider : null, i = this._currentDocumentResponse && this._currentDocumentResponse.resultId || null, n = w$(this._provider, this._model, t, i, e.token);
    this._currentDocumentRequestCancellationTokenSource = e, this._providersChangedDuringRequest = !1;
    const s = [], o = this._model.onDidChangeContent((l) => {
      s.push(l);
    }), a = new rs(!1);
    n.then((l) => {
      if (this._debounceInformation.update(this._model, a.elapsed()), this._currentDocumentRequestCancellationTokenSource = null, o.dispose(), !l)
        this._setDocumentSemanticTokens(null, null, null, s);
      else {
        const { provider: d, tokens: c } = l, h = this._semanticTokensStylingService.getStyling(d);
        this._setDocumentSemanticTokens(d, c || null, h, s);
      }
    }, (l) => {
      l && (cl(l) || typeof l.message == "string" && l.message.indexOf("busy") !== -1) || He(l), this._currentDocumentRequestCancellationTokenSource = null, o.dispose(), (s.length > 0 || this._providersChangedDuringRequest) && (this._fetchDocumentSemanticTokens.isScheduled() || this._fetchDocumentSemanticTokens.schedule(this._debounceInformation.get(this._model)));
    });
  }
  static _copy(e, t, i, n, s) {
    s = Math.min(s, i.length - n, e.length - t);
    for (let o = 0; o < s; o++)
      i[n + o] = e[t + o];
  }
  _setDocumentSemanticTokens(e, t, i, n) {
    const s = this._currentDocumentResponse, o = () => {
      (n.length > 0 || this._providersChangedDuringRequest) && !this._fetchDocumentSemanticTokens.isScheduled() && this._fetchDocumentSemanticTokens.schedule(this._debounceInformation.get(this._model));
    };
    if (this._currentDocumentResponse && (this._currentDocumentResponse.dispose(), this._currentDocumentResponse = null), this._isDisposed) {
      e && t && e.releaseDocumentSemanticTokens(t.resultId);
      return;
    }
    if (!e || !i) {
      this._model.tokenization.setSemanticTokens(null, !1);
      return;
    }
    if (!t) {
      this._model.tokenization.setSemanticTokens(null, !0), o();
      return;
    }
    if (b$(t)) {
      if (!s) {
        this._model.tokenization.setSemanticTokens(null, !0);
        return;
      }
      if (t.edits.length === 0)
        t = {
          resultId: t.resultId,
          data: s.data
        };
      else {
        let a = 0;
        for (const u of t.edits)
          a += (u.data ? u.data.length : 0) - u.deleteCount;
        const l = s.data, d = new Uint32Array(l.length + a);
        let c = l.length, h = d.length;
        for (let u = t.edits.length - 1; u >= 0; u--) {
          const g = t.edits[u];
          if (g.start > l.length) {
            i.warnInvalidEditStart(s.resultId, t.resultId, u, g.start, l.length), this._model.tokenization.setSemanticTokens(null, !0);
            return;
          }
          const f = c - (g.start + g.deleteCount);
          f > 0 && (Bd._copy(l, c - f, d, h - f, f), h -= f), g.data && (Bd._copy(g.data, 0, d, h - g.data.length, g.data.length), h -= g.data.length), c = g.start;
        }
        c > 0 && Bd._copy(l, 0, d, 0, c), t = {
          resultId: t.resultId,
          data: d
        };
      }
    }
    if (oD(t)) {
      this._currentDocumentResponse = new wve(e, t.resultId, t.data);
      const a = K2(t, i, this._model.getLanguageId());
      if (n.length > 0)
        for (const l of n)
          for (const d of a)
            for (const c of l.changes)
              d.applyEdit(c.range, c.text);
      this._model.tokenization.setSemanticTokens(a, !0);
    } else
      this._model.tokenization.setSemanticTokens(null, !0);
    o();
  }
};
Yv.REQUEST_MIN_DELAY = 300;
Yv.REQUEST_MAX_DELAY = 2e3;
Yv = Bd = y$([
  Na(1, W0),
  Na(2, $i),
  Na(3, Vo),
  Na(4, he)
], Yv);
class wve {
  constructor(e, t, i) {
    this.provider = e, this.resultId = t, this.data = i;
  }
  dispose() {
    this.provider.releaseDocumentSemanticTokens(this.resultId);
  }
}
Rb(pN);
var Sve = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Sm = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
let Qv = class extends P {
  constructor(e, t, i, n, s, o) {
    super(), this._semanticTokensStylingService = t, this._themeService = i, this._configurationService = n, this._editor = e, this._provider = o.documentRangeSemanticTokensProvider, this._debounceInformation = s.for(this._provider, "DocumentRangeSemanticTokens", { min: 100, max: 500 }), this._tokenizeViewport = this._register(new xt(() => this._tokenizeViewportNow(), 100)), this._outstandingRequests = [];
    const a = () => {
      this._editor.hasModel() && this._tokenizeViewport.schedule(this._debounceInformation.get(this._editor.getModel()));
    };
    this._register(this._editor.onDidScrollChange(() => {
      a();
    })), this._register(this._editor.onDidChangeModel(() => {
      this._cancelAll(), a();
    })), this._register(this._editor.onDidChangeModelContent((l) => {
      this._cancelAll(), a();
    })), this._register(this._provider.onDidChange(() => {
      this._cancelAll(), a();
    })), this._register(this._configurationService.onDidChangeConfiguration((l) => {
      l.affectsConfiguration(HR) && (this._cancelAll(), a());
    })), this._register(this._themeService.onDidColorThemeChange(() => {
      this._cancelAll(), a();
    })), a();
  }
  _cancelAll() {
    for (const e of this._outstandingRequests)
      e.cancel();
    this._outstandingRequests = [];
  }
  _removeOutstandingRequest(e) {
    for (let t = 0, i = this._outstandingRequests.length; t < i; t++)
      if (this._outstandingRequests[t] === e) {
        this._outstandingRequests.splice(t, 1);
        return;
      }
  }
  _tokenizeViewportNow() {
    if (!this._editor.hasModel())
      return;
    const e = this._editor.getModel();
    if (e.tokenization.hasCompleteSemanticTokens())
      return;
    if (!nS(e, this._themeService, this._configurationService)) {
      e.tokenization.hasSomeSemanticTokens() && e.tokenization.setSemanticTokens(null, !1);
      return;
    }
    if (!Cve(this._provider, e)) {
      e.tokenization.hasSomeSemanticTokens() && e.tokenization.setSemanticTokens(null, !1);
      return;
    }
    const t = this._editor.getVisibleRangesPlusViewportAboveBelow();
    this._outstandingRequests = this._outstandingRequests.concat(t.map((i) => this._requestRange(e, i)));
  }
  _requestRange(e, t) {
    const i = e.getVersionId(), n = Zi((o) => Promise.resolve(BR(this._provider, e, t, o))), s = new rs(!1);
    return n.then((o) => {
      if (this._debounceInformation.update(e, s.elapsed()), !o || !o.tokens || e.isDisposed() || e.getVersionId() !== i)
        return;
      const { provider: a, tokens: l } = o, d = this._semanticTokensStylingService.getStyling(a);
      e.tokenization.setPartialSemanticTokens(t, K2(l, d, e.getLanguageId()));
    }).then(() => this._removeOutstandingRequest(n), () => this._removeOutstandingRequest(n)), n;
  }
};
Qv.ID = "editor.contrib.viewportSemanticTokens";
Qv = Sve([
  Sm(1, W0),
  Sm(2, $i),
  Sm(3, Ge),
  Sm(4, Vo),
  Sm(5, he)
], Qv);
gt(
  Qv.ID,
  Qv,
  1
  /* EditorContributionInstantiation.AfterFirstRender */
);
class yve {
  constructor(e = !0) {
    this.selectSubwords = e;
  }
  provideSelectionRanges(e, t) {
    const i = [];
    for (const n of t) {
      const s = [];
      i.push(s), this.selectSubwords && this._addInWordRanges(s, e, n), this._addWordRanges(s, e, n), this._addWhitespaceLine(s, e, n), s.push({ range: e.getFullModelRange() });
    }
    return i;
  }
  _addInWordRanges(e, t, i) {
    const n = t.getWordAtPosition(i);
    if (!n)
      return;
    const { word: s, startColumn: o } = n, a = i.column - o;
    let l = a, d = a, c = 0;
    for (; l >= 0; l--) {
      const h = s.charCodeAt(l);
      if (l !== a && (h === 95 || h === 45))
        break;
      if (Bg(h) && Vd(c))
        break;
      c = h;
    }
    for (l += 1; d < s.length; d++) {
      const h = s.charCodeAt(d);
      if (Vd(h) && Bg(c))
        break;
      if (h === 95 || h === 45)
        break;
      c = h;
    }
    l < d && e.push({ range: new L(i.lineNumber, o + l, i.lineNumber, o + d) });
  }
  _addWordRanges(e, t, i) {
    const n = t.getWordAtPosition(i);
    n && e.push({ range: new L(i.lineNumber, n.startColumn, i.lineNumber, n.endColumn) });
  }
  _addWhitespaceLine(e, t, i) {
    t.getLineLength(i.lineNumber) > 0 && t.getLineFirstNonWhitespaceColumn(i.lineNumber) === 0 && t.getLineLastNonWhitespaceColumn(i.lineNumber) === 0 && e.push({ range: new L(i.lineNumber, 1, i.lineNumber, t.getLineMaxColumn(i.lineNumber)) });
  }
}
var Lve = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Dve = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, mN;
class VR {
  constructor(e, t) {
    this.index = e, this.ranges = t;
  }
  mov(e) {
    const t = this.index + (e ? 1 : -1);
    if (t < 0 || t >= this.ranges.length)
      return this;
    const i = new VR(t, this.ranges);
    return i.ranges[t].equalsRange(this.ranges[this.index]) ? i.mov(e) : i;
  }
}
let wp = mN = class {
  static get(e) {
    return e.getContribution(mN.ID);
  }
  constructor(e, t) {
    this._editor = e, this._languageFeaturesService = t, this._ignoreSelection = !1;
  }
  dispose() {
    var e;
    (e = this._selectionListener) === null || e === void 0 || e.dispose();
  }
  async run(e) {
    if (!this._editor.hasModel())
      return;
    const t = this._editor.getSelections(), i = this._editor.getModel();
    if (this._state || await D$(this._languageFeaturesService.selectionRangeProvider, i, t.map((s) => s.getPosition()), this._editor.getOption(
      113
      /* EditorOption.smartSelect */
    ), at.None).then((s) => {
      var o;
      if (!(!Rn(s) || s.length !== t.length) && !(!this._editor.hasModel() || !ci(this._editor.getSelections(), t, (a, l) => a.equalsSelection(l)))) {
        for (let a = 0; a < s.length; a++)
          s[a] = s[a].filter((l) => l.containsPosition(t[a].getStartPosition()) && l.containsPosition(t[a].getEndPosition())), s[a].unshift(t[a]);
        this._state = s.map((a) => new VR(0, a)), (o = this._selectionListener) === null || o === void 0 || o.dispose(), this._selectionListener = this._editor.onDidChangeCursorPosition(() => {
          var a;
          this._ignoreSelection || ((a = this._selectionListener) === null || a === void 0 || a.dispose(), this._state = void 0);
        });
      }
    }), !this._state)
      return;
    this._state = this._state.map((s) => s.mov(e));
    const n = this._state.map((s) => ge.fromPositions(s.ranges[s.index].getStartPosition(), s.ranges[s.index].getEndPosition()));
    this._ignoreSelection = !0;
    try {
      this._editor.setSelections(n);
    } finally {
      this._ignoreSelection = !1;
    }
  }
};
wp.ID = "editor.contrib.smartSelectController";
wp = mN = Lve([
  Dve(1, he)
], wp);
class L$ extends ae {
  constructor(e, t) {
    super(t), this._forward = e;
  }
  async run(e, t) {
    const i = wp.get(t);
    i && await i.run(this._forward);
  }
}
class kve extends L$ {
  constructor() {
    super(!0, {
      id: "editor.action.smartSelect.expand",
      label: p("smartSelect.expand", "Expand Selection"),
      alias: "Expand Selection",
      precondition: void 0,
      kbOpts: {
        kbExpr: x.editorTextFocus,
        primary: 1553,
        mac: {
          primary: 3345,
          secondary: [
            1297
            /* KeyCode.RightArrow */
          ]
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: D.MenubarSelectionMenu,
        group: "1_basic",
        title: p({ key: "miSmartSelectGrow", comment: ["&& denotes a mnemonic"] }, "&&Expand Selection"),
        order: 2
      }
    });
  }
}
st.registerCommandAlias("editor.action.smartSelect.grow", "editor.action.smartSelect.expand");
class xve extends L$ {
  constructor() {
    super(!1, {
      id: "editor.action.smartSelect.shrink",
      label: p("smartSelect.shrink", "Shrink Selection"),
      alias: "Shrink Selection",
      precondition: void 0,
      kbOpts: {
        kbExpr: x.editorTextFocus,
        primary: 1551,
        mac: {
          primary: 3343,
          secondary: [
            1295
            /* KeyCode.LeftArrow */
          ]
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: D.MenubarSelectionMenu,
        group: "1_basic",
        title: p({ key: "miSmartSelectShrink", comment: ["&& denotes a mnemonic"] }, "&&Shrink Selection"),
        order: 3
      }
    });
  }
}
gt(
  wp.ID,
  wp,
  4
  /* EditorContributionInstantiation.Lazy */
);
Y(kve);
Y(xve);
async function D$(r, e, t, i, n) {
  const s = r.all(e).concat(new yve(i.selectSubwords));
  s.length === 1 && s.unshift(new io());
  const o = [], a = [];
  for (const l of s)
    o.push(Promise.resolve(l.provideSelectionRanges(e, t, n)).then((d) => {
      if (Rn(d) && d.length === t.length)
        for (let c = 0; c < t.length; c++) {
          a[c] || (a[c] = []);
          for (const h of d[c])
            L.isIRange(h.range) && L.containsPosition(h.range, t[c]) && a[c].push(L.lift(h.range));
        }
    }, _i));
  return await Promise.all(o), a.map((l) => {
    if (l.length === 0)
      return [];
    l.sort((u, g) => A.isBefore(u.getStartPosition(), g.getStartPosition()) ? 1 : A.isBefore(g.getStartPosition(), u.getStartPosition()) || A.isBefore(u.getEndPosition(), g.getEndPosition()) ? -1 : A.isBefore(g.getEndPosition(), u.getEndPosition()) ? 1 : 0);
    const d = [];
    let c;
    for (const u of l)
      (!c || L.containsRange(u, c) && !L.equalsRange(u, c)) && (d.push(u), c = u);
    if (!i.selectLeadingAndTrailingWhitespace)
      return d;
    const h = [d[0]];
    for (let u = 1; u < d.length; u++) {
      const g = d[u - 1], f = d[u];
      if (f.startLineNumber !== g.startLineNumber || f.endLineNumber !== g.endLineNumber) {
        const m = new L(g.startLineNumber, e.getLineFirstNonWhitespaceColumn(g.startLineNumber), g.endLineNumber, e.getLineLastNonWhitespaceColumn(g.endLineNumber));
        m.containsRange(g) && !m.equalsRange(g) && f.containsRange(m) && !f.equalsRange(m) && h.push(m);
        const _ = new L(g.startLineNumber, 1, g.endLineNumber, e.getLineMaxColumn(g.endLineNumber));
        _.containsRange(g) && !_.equalsRange(m) && f.containsRange(_) && !f.equalsRange(_) && h.push(_);
      }
      h.push(f);
    }
    return h;
  });
}
st.registerCommand("_executeSelectionRangeProvider", async function(r, ...e) {
  const [t, i] = e;
  ct(Ee.isUri(t));
  const n = r.get(he).selectionRangeProvider, s = await r.get(xs).createModelReference(t);
  try {
    return D$(n, s.object.textEditorModel, i, { selectLeadingAndTrailingWhitespace: !0, selectSubwords: !0 }, at.None);
  } finally {
    s.dispose();
  }
});
const Ive = Object.freeze({
  View: Me("view", "View"),
  Help: Me("help", "Help"),
  Test: Me("test", "Test"),
  File: Me("file", "File"),
  Preferences: Me("preferences", "Preferences"),
  Developer: Me({ key: "developer", comment: ["A developer on Code itself or someone diagnosing issues in Code"] }, "Developer")
});
class xB {
  constructor(e, t, i, n = null) {
    this.startLineNumbers = e, this.endLineNumbers = t, this.lastLineRelativePosition = i, this.showEndForLine = n;
  }
  equals(e) {
    return !!e && this.lastLineRelativePosition === e.lastLineRelativePosition && this.showEndForLine === e.showEndForLine && ci(this.startLineNumbers, e.startLineNumbers) && ci(this.endLineNumbers, e.endLineNumbers);
  }
}
const IB = wd("stickyScrollViewLayer", { createHTML: (r) => r }), cx = "data-sticky-line-index", EB = "data-sticky-is-line", Eve = "data-sticky-is-line-number", TB = "data-sticky-is-folding-icon";
class Tve extends P {
  constructor(e) {
    super(), this._editor = e, this._foldingIconStore = new q(), this._rootDomNode = document.createElement("div"), this._lineNumbersDomNode = document.createElement("div"), this._linesDomNodeScrollable = document.createElement("div"), this._linesDomNode = document.createElement("div"), this._lineHeight = this._editor.getOption(
      67
      /* EditorOption.lineHeight */
    ), this._renderedStickyLines = [], this._lineNumbers = [], this._lastLineRelativePosition = 0, this._minContentWidthInPx = 0, this._isOnGlyphMargin = !1, this._lineNumbersDomNode.className = "sticky-widget-line-numbers", this._lineNumbersDomNode.setAttribute("role", "none"), this._linesDomNode.className = "sticky-widget-lines", this._linesDomNode.setAttribute("role", "list"), this._linesDomNodeScrollable.className = "sticky-widget-lines-scrollable", this._linesDomNodeScrollable.appendChild(this._linesDomNode), this._rootDomNode.className = "sticky-widget", this._rootDomNode.classList.toggle("peek", e instanceof jc), this._rootDomNode.appendChild(this._lineNumbersDomNode), this._rootDomNode.appendChild(this._linesDomNodeScrollable);
    const t = () => {
      this._linesDomNode.style.left = this._editor.getOption(
        115
        /* EditorOption.stickyScroll */
      ).scrollWithEditor ? `-${this._editor.getScrollLeft()}px` : "0px";
    };
    this._register(this._editor.onDidChangeConfiguration((i) => {
      i.hasChanged(
        115
        /* EditorOption.stickyScroll */
      ) && t(), i.hasChanged(
        67
        /* EditorOption.lineHeight */
      ) && (this._lineHeight = this._editor.getOption(
        67
        /* EditorOption.lineHeight */
      ));
    })), this._register(this._editor.onDidScrollChange((i) => {
      i.scrollLeftChanged && t(), i.scrollWidthChanged && this._updateWidgetWidth();
    })), this._register(this._editor.onDidChangeModel(() => {
      t(), this._updateWidgetWidth();
    })), this._register(this._foldingIconStore), t(), this._register(this._editor.onDidLayoutChange((i) => {
      this._updateWidgetWidth();
    })), this._updateWidgetWidth();
  }
  get lineNumbers() {
    return this._lineNumbers;
  }
  get lineNumberCount() {
    return this._lineNumbers.length;
  }
  getRenderedStickyLine(e) {
    return this._renderedStickyLines.find((t) => t.lineNumber === e);
  }
  getCurrentLines() {
    return this._lineNumbers;
  }
  setState(e, t, i) {
    if (i === void 0 && (!this._previousState && !e || this._previousState && this._previousState.equals(e)))
      return;
    const n = this._isWidgetHeightZero(e), s = n ? void 0 : e, o = n ? 0 : this._findLineToRebuildWidgetFrom(e, i);
    this._renderRootNode(s, t, o), this._previousState = e;
  }
  _isWidgetHeightZero(e) {
    if (!e)
      return !0;
    const t = e.startLineNumbers.length * this._lineHeight + e.lastLineRelativePosition;
    if (t > 0) {
      this._lastLineRelativePosition = e.lastLineRelativePosition;
      const i = [...e.startLineNumbers];
      e.showEndForLine !== null && (i[e.showEndForLine] = e.endLineNumbers[e.showEndForLine]), this._lineNumbers = i;
    } else
      this._lastLineRelativePosition = 0, this._lineNumbers = [];
    return t === 0;
  }
  _findLineToRebuildWidgetFrom(e, t) {
    if (!e || !this._previousState)
      return 0;
    if (t !== void 0)
      return t;
    const i = this._previousState, n = e.startLineNumbers.findIndex((s) => !i.startLineNumbers.includes(s));
    return n === -1 ? 0 : n;
  }
  _updateWidgetWidth() {
    const e = this._editor.getLayoutInfo(), t = e.contentLeft;
    this._lineNumbersDomNode.style.width = `${t}px`, this._linesDomNodeScrollable.style.setProperty("--vscode-editorStickyScroll-scrollableWidth", `${this._editor.getScrollWidth() - e.verticalScrollbarWidth}px`), this._rootDomNode.style.width = `${e.width - e.verticalScrollbarWidth}px`;
  }
  _clearStickyLinesFromLine(e) {
    this._foldingIconStore.clear();
    for (let t = e; t < this._renderedStickyLines.length; t++) {
      const i = this._renderedStickyLines[t];
      i.lineNumberDomNode.remove(), i.lineDomNode.remove();
    }
    this._renderedStickyLines = this._renderedStickyLines.slice(0, e), this._rootDomNode.style.display = "none";
  }
  _useFoldingOpacityTransition(e) {
    this._lineNumbersDomNode.style.setProperty("--vscode-editorStickyScroll-foldingOpacityTransition", `opacity ${e ? 0.5 : 0}s`);
  }
  _setFoldingIconsVisibility(e) {
    for (const t of this._renderedStickyLines) {
      const i = t.foldingIcon;
      i && i.setVisible(e ? !0 : i.isCollapsed);
    }
  }
  async _renderRootNode(e, t, i) {
    if (this._clearStickyLinesFromLine(i), !e)
      return;
    for (const a of this._renderedStickyLines)
      this._updateTopAndZIndexOfStickyLine(a);
    const n = this._editor.getLayoutInfo(), s = this._lineNumbers.slice(i);
    for (const [a, l] of s.entries()) {
      const d = this._renderChildNode(a + i, l, t, n);
      d && (this._linesDomNode.appendChild(d.lineDomNode), this._lineNumbersDomNode.appendChild(d.lineNumberDomNode), this._renderedStickyLines.push(d));
    }
    t && (this._setFoldingHoverListeners(), this._useFoldingOpacityTransition(!this._isOnGlyphMargin));
    const o = this._lineNumbers.length * this._lineHeight + this._lastLineRelativePosition;
    this._rootDomNode.style.display = "block", this._lineNumbersDomNode.style.height = `${o}px`, this._linesDomNodeScrollable.style.height = `${o}px`, this._rootDomNode.style.height = `${o}px`, this._rootDomNode.style.marginLeft = "0px", this._minContentWidthInPx = Math.max(...this._renderedStickyLines.map((a) => a.scrollWidth)) + n.verticalScrollbarWidth, this._editor.layoutOverlayWidget(this);
  }
  _setFoldingHoverListeners() {
    this._editor.getOption(
      110
      /* EditorOption.showFoldingControls */
    ) === "mouseover" && (this._foldingIconStore.add(W(this._lineNumbersDomNode, Q.MOUSE_ENTER, () => {
      this._isOnGlyphMargin = !0, this._setFoldingIconsVisibility(!0);
    })), this._foldingIconStore.add(W(this._lineNumbersDomNode, Q.MOUSE_LEAVE, () => {
      this._isOnGlyphMargin = !1, this._useFoldingOpacityTransition(!0), this._setFoldingIconsVisibility(!1);
    })));
  }
  _renderChildNode(e, t, i, n) {
    const s = this._editor._getViewModel();
    if (!s)
      return;
    const o = s.coordinatesConverter.convertModelPositionToViewPosition(new A(t, 1)).lineNumber, a = s.getViewLineRenderingData(o), l = this._editor.getOption(
      68
      /* EditorOption.lineNumbers */
    );
    let d;
    try {
      d = ts.filter(a.inlineDecorations, o, a.minColumn, a.maxColumn);
    } catch {
      d = [];
    }
    const c = new th(!0, !0, a.content, a.continuesWithWrappedLine, a.isBasicASCII, a.containsRTL, 0, a.tokens, d, a.tabSize, a.startVisibleColumn, 1, 1, 1, 500, "none", !0, !0, null), h = new Tp(2e3), u = hb(c, h);
    let g;
    IB ? g = IB.createHTML(h.build()) : g = h.build();
    const f = document.createElement("span");
    f.setAttribute(cx, String(e)), f.setAttribute(EB, ""), f.setAttribute("role", "listitem"), f.tabIndex = 0, f.className = "sticky-line-content", f.classList.add(`stickyLine${t}`), f.style.lineHeight = `${this._lineHeight}px`, f.innerHTML = g;
    const m = document.createElement("span");
    m.setAttribute(cx, String(e)), m.setAttribute(Eve, ""), m.className = "sticky-line-number", m.style.lineHeight = `${this._lineHeight}px`;
    const _ = n.contentLeft;
    m.style.width = `${_}px`;
    const v = document.createElement("span");
    l.renderType === 1 || l.renderType === 3 && t % 10 === 0 ? v.innerText = t.toString() : l.renderType === 2 && (v.innerText = Math.abs(t - this._editor.getPosition().lineNumber).toString()), v.className = "sticky-line-number-inner", v.style.lineHeight = `${this._lineHeight}px`, v.style.width = `${n.lineNumbersWidth}px`, v.style.paddingLeft = `${n.lineNumbersLeft}px`, m.appendChild(v);
    const b = this._renderFoldingIconForLine(i, t);
    b && m.appendChild(b.domNode), this._editor.applyFontInfo(f), this._editor.applyFontInfo(v), m.style.lineHeight = `${this._lineHeight}px`, f.style.lineHeight = `${this._lineHeight}px`, m.style.height = `${this._lineHeight}px`, f.style.height = `${this._lineHeight}px`;
    const C = new Nve(e, t, f, m, b, u.characterMapping, f.scrollWidth);
    return this._updateTopAndZIndexOfStickyLine(C);
  }
  _updateTopAndZIndexOfStickyLine(e) {
    var t;
    const i = e.index, n = e.lineDomNode, s = e.lineNumberDomNode, o = i === this._lineNumbers.length - 1, a = "0", l = "1";
    n.style.zIndex = o ? a : l, s.style.zIndex = o ? a : l;
    const d = `${i * this._lineHeight + this._lastLineRelativePosition + (!((t = e.foldingIcon) === null || t === void 0) && t.isCollapsed ? 1 : 0)}px`, c = `${i * this._lineHeight}px`;
    return n.style.top = o ? d : c, s.style.top = o ? d : c, e;
  }
  _renderFoldingIconForLine(e, t) {
    const i = this._editor.getOption(
      110
      /* EditorOption.showFoldingControls */
    );
    if (!e || i === "never")
      return;
    const n = e.regions, s = n.findRange(t), o = n.getStartLineNumber(s);
    if (!(t === o))
      return;
    const l = n.isCollapsed(s), d = new Mve(l, o, n.getEndLineNumber(s), this._lineHeight);
    return d.setVisible(this._isOnGlyphMargin ? !0 : l || i === "always"), d.domNode.setAttribute(TB, ""), d;
  }
  getId() {
    return "editor.contrib.stickyScrollWidget";
  }
  getDomNode() {
    return this._rootDomNode;
  }
  getPosition() {
    return {
      preference: 2,
      stackOridinal: 10
    };
  }
  getMinContentWidthInPx() {
    return this._minContentWidthInPx;
  }
  focusLineWithIndex(e) {
    0 <= e && e < this._renderedStickyLines.length && this._renderedStickyLines[e].lineDomNode.focus();
  }
  /**
   * Given a leaf dom node, tries to find the editor position.
   */
  getEditorPositionFromNode(e) {
    if (!e || e.children.length > 0)
      return null;
    const t = this._getRenderedStickyLineFromChildDomNode(e);
    if (!t)
      return null;
    const i = D1(t.characterMapping, e, 0);
    return new A(t.lineNumber, i);
  }
  getLineNumberFromChildDomNode(e) {
    var t, i;
    return (i = (t = this._getRenderedStickyLineFromChildDomNode(e)) === null || t === void 0 ? void 0 : t.lineNumber) !== null && i !== void 0 ? i : null;
  }
  _getRenderedStickyLineFromChildDomNode(e) {
    const t = this.getLineIndexFromChildDomNode(e);
    return t === null || t < 0 || t >= this._renderedStickyLines.length ? null : this._renderedStickyLines[t];
  }
  /**
   * Given a child dom node, tries to find the line number attribute that was stored in the node.
   * @returns the attribute value or null if none is found.
   */
  getLineIndexFromChildDomNode(e) {
    const t = this._getAttributeValue(e, cx);
    return t ? parseInt(t, 10) : null;
  }
  /**
   * Given a child dom node, tries to find if it is (contained in) a sticky line.
   * @returns a boolean.
   */
  isInStickyLine(e) {
    return this._getAttributeValue(e, EB) !== void 0;
  }
  /**
   * Given a child dom node, tries to find if this dom node is (contained in) a sticky folding icon.
   * @returns a boolean.
   */
  isInFoldingIconDomNode(e) {
    return this._getAttributeValue(e, TB) !== void 0;
  }
  /**
   * Given the dom node, finds if it or its parent sequence contains the given attribute.
   * @returns the attribute value or undefined.
   */
  _getAttributeValue(e, t) {
    for (; e && e !== this._rootDomNode; ) {
      const i = e.getAttribute(t);
      if (i !== null)
        return i;
      e = e.parentElement;
    }
  }
}
class Nve {
  constructor(e, t, i, n, s, o, a) {
    this.index = e, this.lineNumber = t, this.lineDomNode = i, this.lineNumberDomNode = n, this.foldingIcon = s, this.characterMapping = o, this.scrollWidth = a;
  }
}
class Mve {
  constructor(e, t, i, n) {
    this.isCollapsed = e, this.foldingStartLine = t, this.foldingEndLine = i, this.dimension = n, this.domNode = document.createElement("div"), this.domNode.style.width = `${n}px`, this.domNode.style.height = `${n}px`, this.domNode.className = Le.asClassName(e ? BL : WL);
  }
  setVisible(e) {
    this.domNode.style.cursor = e ? "pointer" : "default", this.domNode.style.opacity = e ? "1" : "0";
  }
}
class x_ {
  constructor(e, t) {
    this.startLineNumber = e, this.endLineNumber = t;
  }
}
class Zy {
  constructor(e, t, i) {
    this.range = e, this.children = t, this.parent = i;
  }
}
class k$ {
  constructor(e, t, i, n) {
    this.uri = e, this.version = t, this.element = i, this.outlineProviderId = n;
  }
}
var rD = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Xv = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, I_;
(function(r) {
  r.OUTLINE_MODEL = "outlineModel", r.FOLDING_PROVIDER_MODEL = "foldingProviderModel", r.INDENTATION_MODEL = "indentationModel";
})(I_ || (I_ = {}));
var gc;
(function(r) {
  r[r.VALID = 0] = "VALID", r[r.INVALID = 1] = "INVALID", r[r.CANCELED = 2] = "CANCELED";
})(gc || (gc = {}));
let _N = class extends P {
  constructor(e, t, i, n) {
    switch (super(), this._editor = e, this._modelProviders = [], this._modelPromise = null, this._updateScheduler = this._register(new pr(300)), this._updateOperation = this._register(new q()), this._editor.getOption(
      115
      /* EditorOption.stickyScroll */
    ).defaultModel) {
      case I_.OUTLINE_MODEL:
        this._modelProviders.push(new vN(this._editor, n));
      case I_.FOLDING_PROVIDER_MODEL:
        this._modelProviders.push(new CN(this._editor, t, n));
      case I_.INDENTATION_MODEL:
        this._modelProviders.push(new bN(this._editor, i));
        break;
    }
  }
  dispose() {
    this._modelProviders.forEach((e) => e.dispose()), this._updateOperation.clear(), this._cancelModelPromise(), super.dispose();
  }
  _cancelModelPromise() {
    this._modelPromise && (this._modelPromise.cancel(), this._modelPromise = null);
  }
  async update(e) {
    return this._updateOperation.clear(), this._updateOperation.add({
      dispose: () => {
        this._cancelModelPromise(), this._updateScheduler.cancel();
      }
    }), this._cancelModelPromise(), await this._updateScheduler.trigger(async () => {
      for (const t of this._modelProviders) {
        const { statusPromise: i, modelPromise: n } = t.computeStickyModel(e);
        this._modelPromise = n;
        const s = await i;
        if (this._modelPromise !== n)
          return null;
        switch (s) {
          case gc.CANCELED:
            return this._updateOperation.clear(), null;
          case gc.VALID:
            return t.stickyModel;
        }
      }
      return null;
    }).catch((t) => (He(t), null));
  }
};
_N = rD([
  Xv(2, be),
  Xv(3, he)
], _N);
class x$ extends P {
  constructor(e) {
    super(), this._editor = e, this._stickyModel = null;
  }
  get stickyModel() {
    return this._stickyModel;
  }
  _invalid() {
    return this._stickyModel = null, gc.INVALID;
  }
  computeStickyModel(e) {
    if (e.isCancellationRequested || !this.isProviderValid())
      return { statusPromise: this._invalid(), modelPromise: null };
    const t = Zi((i) => this.createModelFromProvider(i));
    return {
      statusPromise: t.then((i) => this.isModelValid(i) ? e.isCancellationRequested ? gc.CANCELED : (this._stickyModel = this.createStickyModel(e, i), gc.VALID) : this._invalid()).then(void 0, (i) => (He(i), gc.CANCELED)),
      modelPromise: t
    };
  }
  /**
   * Method which checks whether the model returned by the provider is valid and can be used to compute a sticky model.
   * This method by default returns true.
   * @param model model returned by the provider
   * @returns boolean indicating whether the model is valid
   */
  isModelValid(e) {
    return !0;
  }
  /**
   * Method which checks whether the provider is valid before applying it to find the provider model.
   * This method by default returns true.
   * @returns boolean indicating whether the provider is valid
   */
  isProviderValid() {
    return !0;
  }
}
let vN = class extends x$ {
  constructor(e, t) {
    super(e), this._languageFeaturesService = t;
  }
  createModelFromProvider(e) {
    return Ml.create(this._languageFeaturesService.documentSymbolProvider, this._editor.getModel(), e);
  }
  createStickyModel(e, t) {
    var i;
    const { stickyOutlineElement: n, providerID: s } = this._stickyModelFromOutlineModel(t, (i = this._stickyModel) === null || i === void 0 ? void 0 : i.outlineProviderId), o = this._editor.getModel();
    return new k$(o.uri, o.getVersionId(), n, s);
  }
  isModelValid(e) {
    return e && e.children.size > 0;
  }
  _stickyModelFromOutlineModel(e, t) {
    let i;
    if (ut.first(e.children.values()) instanceof q4) {
      const a = ut.find(e.children.values(), (l) => l.id === t);
      if (a)
        i = a.children;
      else {
        let l = "", d = -1, c;
        for (const [h, u] of e.children.entries()) {
          const g = this._findSumOfRangesOfGroup(u);
          g > d && (c = u, d = g, l = u.id);
        }
        t = l, i = c.children;
      }
    } else
      i = e.children;
    const n = [], s = Array.from(i.values()).sort((a, l) => {
      const d = new x_(a.symbol.range.startLineNumber, a.symbol.range.endLineNumber), c = new x_(l.symbol.range.startLineNumber, l.symbol.range.endLineNumber);
      return this._comparator(d, c);
    });
    for (const a of s)
      n.push(this._stickyModelFromOutlineElement(a, a.symbol.selectionRange.startLineNumber));
    return {
      stickyOutlineElement: new Zy(void 0, n, void 0),
      providerID: t
    };
  }
  _stickyModelFromOutlineElement(e, t) {
    const i = [];
    for (const s of e.children.values())
      if (s.symbol.selectionRange.startLineNumber !== s.symbol.range.endLineNumber)
        if (s.symbol.selectionRange.startLineNumber !== t)
          i.push(this._stickyModelFromOutlineElement(s, s.symbol.selectionRange.startLineNumber));
        else
          for (const o of s.children.values())
            i.push(this._stickyModelFromOutlineElement(o, s.symbol.selectionRange.startLineNumber));
    i.sort((s, o) => this._comparator(s.range, o.range));
    const n = new x_(e.symbol.selectionRange.startLineNumber, e.symbol.range.endLineNumber);
    return new Zy(n, i, void 0);
  }
  _comparator(e, t) {
    return e.startLineNumber !== t.startLineNumber ? e.startLineNumber - t.startLineNumber : t.endLineNumber - e.endLineNumber;
  }
  _findSumOfRangesOfGroup(e) {
    let t = 0;
    for (const i of e.children.values())
      t += this._findSumOfRangesOfGroup(i);
    return e instanceof OT ? t + e.symbol.range.endLineNumber - e.symbol.selectionRange.startLineNumber : t;
  }
};
vN = rD([
  Xv(1, he)
], vN);
class I$ extends x$ {
  constructor(e) {
    super(e), this._foldingLimitReporter = new $4(e);
  }
  createStickyModel(e, t) {
    const i = this._fromFoldingRegions(t), n = this._editor.getModel();
    return new k$(n.uri, n.getVersionId(), i, void 0);
  }
  isModelValid(e) {
    return e !== null;
  }
  _fromFoldingRegions(e) {
    const t = e.length, i = [], n = new Zy(void 0, [], void 0);
    for (let s = 0; s < t; s++) {
      const o = e.getParentIndex(s);
      let a;
      o !== -1 ? a = i[o] : a = n;
      const l = new Zy(new x_(e.getStartLineNumber(s), e.getEndLineNumber(s) + 1), [], a);
      a.children.push(l), i.push(l);
    }
    return n;
  }
}
let bN = class extends I$ {
  constructor(e, t) {
    super(e), this._languageConfigurationService = t, this.provider = this._register(new DR(e.getModel(), this._languageConfigurationService, this._foldingLimitReporter));
  }
  async createModelFromProvider(e) {
    return this.provider.compute(e);
  }
};
bN = rD([
  Xv(1, Ot)
], bN);
let CN = class extends I$ {
  constructor(e, t, i) {
    super(e), this._languageFeaturesService = i;
    const n = pd.getFoldingRangeProviders(this._languageFeaturesService, e.getModel());
    n.length > 0 && (this.provider = this._register(new xR(e.getModel(), n, t, this._foldingLimitReporter, void 0)));
  }
  isProviderValid() {
    return this.provider !== void 0;
  }
  async createModelFromProvider(e) {
    var t, i;
    return (i = (t = this.provider) === null || t === void 0 ? void 0 : t.compute(e)) !== null && i !== void 0 ? i : null;
  }
};
CN = rD([
  Xv(2, he)
], CN);
var Rve = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, NB = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
class Ave {
  constructor(e, t, i) {
    this.startLineNumber = e, this.endLineNumber = t, this.nestingDepth = i;
  }
}
let wN = class extends P {
  constructor(e, t, i) {
    super(), this._languageFeaturesService = t, this._languageConfigurationService = i, this._onDidChangeStickyScroll = this._register(new R()), this.onDidChangeStickyScroll = this._onDidChangeStickyScroll.event, this._model = null, this._cts = null, this._stickyModelProvider = null, this._editor = e, this._sessionStore = this._register(new q()), this._updateSoon = this._register(new xt(() => this.update(), 50)), this._register(this._editor.onDidChangeConfiguration((n) => {
      n.hasChanged(
        115
        /* EditorOption.stickyScroll */
      ) && this.readConfiguration();
    })), this.readConfiguration();
  }
  readConfiguration() {
    this._sessionStore.clear(), this._editor.getOption(
      115
      /* EditorOption.stickyScroll */
    ).enabled && (this._sessionStore.add(this._editor.onDidChangeModel(() => {
      this._model = null, this.updateStickyModelProvider(), this._onDidChangeStickyScroll.fire(), this.update();
    })), this._sessionStore.add(this._editor.onDidChangeHiddenAreas(() => this.update())), this._sessionStore.add(this._editor.onDidChangeModelContent(() => this._updateSoon.schedule())), this._sessionStore.add(this._languageFeaturesService.documentSymbolProvider.onDidChange(() => this.update())), this._sessionStore.add(Se(() => {
      var t;
      (t = this._stickyModelProvider) === null || t === void 0 || t.dispose(), this._stickyModelProvider = null;
    })), this.updateStickyModelProvider(), this.update());
  }
  getVersionId() {
    var e;
    return (e = this._model) === null || e === void 0 ? void 0 : e.version;
  }
  updateStickyModelProvider() {
    var e;
    (e = this._stickyModelProvider) === null || e === void 0 || e.dispose(), this._stickyModelProvider = null;
    const t = this._editor;
    t.hasModel() && (this._stickyModelProvider = new _N(t, () => this._updateSoon.schedule(), this._languageConfigurationService, this._languageFeaturesService));
  }
  async update() {
    var e;
    (e = this._cts) === null || e === void 0 || e.dispose(!0), this._cts = new mi(), await this.updateStickyModel(this._cts.token), this._onDidChangeStickyScroll.fire();
  }
  async updateStickyModel(e) {
    if (!this._editor.hasModel() || !this._stickyModelProvider || this._editor.getModel().isTooLargeForTokenization()) {
      this._model = null;
      return;
    }
    const t = await this._stickyModelProvider.update(e);
    e.isCancellationRequested || (this._model = t);
  }
  updateIndex(e) {
    return e === -1 ? e = 0 : e < 0 && (e = -e - 2), e;
  }
  getCandidateStickyLinesIntersectingFromStickyModel(e, t, i, n, s) {
    if (t.children.length === 0)
      return;
    let o = s;
    const a = [];
    for (let c = 0; c < t.children.length; c++) {
      const h = t.children[c];
      h.range && a.push(h.range.startLineNumber);
    }
    const l = this.updateIndex(R_(a, e.startLineNumber, (c, h) => c - h)), d = this.updateIndex(R_(a, e.startLineNumber + n, (c, h) => c - h));
    for (let c = l; c <= d; c++) {
      const h = t.children[c];
      if (!h)
        return;
      if (h.range) {
        const u = h.range.startLineNumber, g = h.range.endLineNumber;
        e.startLineNumber <= g + 1 && u - 1 <= e.endLineNumber && u !== o && (o = u, i.push(new Ave(u, g - 1, n + 1)), this.getCandidateStickyLinesIntersectingFromStickyModel(e, h, i, n + 1, u));
      } else
        this.getCandidateStickyLinesIntersectingFromStickyModel(e, h, i, n, s);
    }
  }
  getCandidateStickyLinesIntersecting(e) {
    var t, i;
    if (!(!((t = this._model) === null || t === void 0) && t.element))
      return [];
    let n = [];
    this.getCandidateStickyLinesIntersectingFromStickyModel(e, this._model.element, n, 0, -1);
    const s = (i = this._editor._getViewModel()) === null || i === void 0 ? void 0 : i.getHiddenAreas();
    if (s)
      for (const o of s)
        n = n.filter((a) => !(a.startLineNumber >= o.startLineNumber && a.endLineNumber <= o.endLineNumber + 1));
    return n;
  }
};
wN = Rve([
  NB(1, he),
  NB(2, Ot)
], wN);
var Pve = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Ig = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, SN;
let dl = SN = class extends P {
  constructor(e, t, i, n, s, o, a) {
    super(), this._editor = e, this._contextMenuService = t, this._languageFeaturesService = i, this._instaService = n, this._contextKeyService = a, this._sessionStore = new q(), this._foldingModel = null, this._maxStickyLines = Number.MAX_SAFE_INTEGER, this._candidateDefinitionsLength = -1, this._focusedStickyElementIndex = -1, this._enabled = !1, this._focused = !1, this._positionRevealed = !1, this._onMouseDown = !1, this._endLineNumbers = [], this._showEndForLine = null, this._stickyScrollWidget = new Tve(this._editor), this._stickyLineCandidateProvider = new wN(this._editor, i, s), this._register(this._stickyScrollWidget), this._register(this._stickyLineCandidateProvider), this._widgetState = new xB([], [], 0), this._onDidResize(), this._readConfiguration();
    const l = this._stickyScrollWidget.getDomNode();
    this._register(this._editor.onDidChangeConfiguration((c) => {
      this._readConfigurationChange(c);
    })), this._register(W(l, Q.CONTEXT_MENU, async (c) => {
      this._onContextMenu(we(l), c);
    })), this._stickyScrollFocusedContextKey = x.stickyScrollFocused.bindTo(this._contextKeyService), this._stickyScrollVisibleContextKey = x.stickyScrollVisible.bindTo(this._contextKeyService);
    const d = this._register(Xr(l));
    this._register(d.onDidBlur((c) => {
      this._positionRevealed === !1 && l.clientHeight === 0 ? (this._focusedStickyElementIndex = -1, this.focus()) : this._disposeFocusStickyScrollStore();
    })), this._register(d.onDidFocus((c) => {
      this.focus();
    })), this._registerMouseListeners(), this._register(W(l, Q.MOUSE_DOWN, (c) => {
      this._onMouseDown = !0;
    }));
  }
  static get(e) {
    return e.getContribution(SN.ID);
  }
  _disposeFocusStickyScrollStore() {
    var e;
    this._stickyScrollFocusedContextKey.set(!1), (e = this._focusDisposableStore) === null || e === void 0 || e.dispose(), this._focused = !1, this._positionRevealed = !1, this._onMouseDown = !1;
  }
  focus() {
    if (this._onMouseDown) {
      this._onMouseDown = !1, this._editor.focus();
      return;
    }
    this._stickyScrollFocusedContextKey.get() !== !0 && (this._focused = !0, this._focusDisposableStore = new q(), this._stickyScrollFocusedContextKey.set(!0), this._focusedStickyElementIndex = this._stickyScrollWidget.lineNumbers.length - 1, this._stickyScrollWidget.focusLineWithIndex(this._focusedStickyElementIndex));
  }
  focusNext() {
    this._focusedStickyElementIndex < this._stickyScrollWidget.lineNumberCount - 1 && this._focusNav(!0);
  }
  focusPrevious() {
    this._focusedStickyElementIndex > 0 && this._focusNav(!1);
  }
  selectEditor() {
    this._editor.focus();
  }
  // True is next, false is previous
  _focusNav(e) {
    this._focusedStickyElementIndex = e ? this._focusedStickyElementIndex + 1 : this._focusedStickyElementIndex - 1, this._stickyScrollWidget.focusLineWithIndex(this._focusedStickyElementIndex);
  }
  goToFocused() {
    const e = this._stickyScrollWidget.lineNumbers;
    this._disposeFocusStickyScrollStore(), this._revealPosition({ lineNumber: e[this._focusedStickyElementIndex], column: 1 });
  }
  _revealPosition(e) {
    this._reveaInEditor(e, () => this._editor.revealPosition(e));
  }
  _revealLineInCenterIfOutsideViewport(e) {
    this._reveaInEditor(e, () => this._editor.revealLineInCenterIfOutsideViewport(
      e.lineNumber,
      0
      /* ScrollType.Smooth */
    ));
  }
  _reveaInEditor(e, t) {
    this._focused && this._disposeFocusStickyScrollStore(), this._positionRevealed = !0, t(), this._editor.setSelection(L.fromPositions(e)), this._editor.focus();
  }
  _registerMouseListeners() {
    const e = this._register(new q()), t = this._register(new xL(this._editor, {
      extractLineNumberFromMouseEvent: (s) => {
        const o = this._stickyScrollWidget.getEditorPositionFromNode(s.target.element);
        return o ? o.lineNumber : 0;
      }
    })), i = (s) => {
      if (!this._editor.hasModel() || s.target.type !== 12 || s.target.detail !== this._stickyScrollWidget.getId())
        return null;
      const o = s.target.element;
      if (!o || o.innerText !== o.innerHTML)
        return null;
      const a = this._stickyScrollWidget.getEditorPositionFromNode(o);
      return a ? {
        range: new L(a.lineNumber, a.column, a.lineNumber, a.column + o.innerText.length),
        textElement: o
      } : null;
    }, n = this._stickyScrollWidget.getDomNode();
    this._register(pi(n, Q.CLICK, (s) => {
      if (s.ctrlKey || s.altKey || s.metaKey || !s.leftButton)
        return;
      if (s.shiftKey) {
        const d = this._stickyScrollWidget.getLineIndexFromChildDomNode(s.target);
        if (d === null)
          return;
        const c = new A(this._endLineNumbers[d], 1);
        this._revealLineInCenterIfOutsideViewport(c);
        return;
      }
      if (this._stickyScrollWidget.isInFoldingIconDomNode(s.target)) {
        const d = this._stickyScrollWidget.getLineNumberFromChildDomNode(s.target);
        this._toggleFoldingRegionForLine(d);
        return;
      }
      if (!this._stickyScrollWidget.isInStickyLine(s.target))
        return;
      let l = this._stickyScrollWidget.getEditorPositionFromNode(s.target);
      if (!l) {
        const d = this._stickyScrollWidget.getLineNumberFromChildDomNode(s.target);
        if (d === null)
          return;
        l = new A(d, 1);
      }
      this._revealPosition(l);
    })), this._register(pi(n, Q.MOUSE_MOVE, (s) => {
      if (s.shiftKey) {
        const o = this._stickyScrollWidget.getLineIndexFromChildDomNode(s.target);
        if (o === null || this._showEndForLine !== null && this._showEndForLine === o)
          return;
        this._showEndForLine = o, this._renderStickyScroll();
        return;
      }
      this._showEndForLine !== null && (this._showEndForLine = null, this._renderStickyScroll());
    })), this._register(W(n, Q.MOUSE_LEAVE, (s) => {
      this._showEndForLine !== null && (this._showEndForLine = null, this._renderStickyScroll());
    })), this._register(t.onMouseMoveOrRelevantKeyDown(([s, o]) => {
      const a = i(s);
      if (!a || !s.hasTriggerModifier || !this._editor.hasModel()) {
        e.clear();
        return;
      }
      const { range: l, textElement: d } = a;
      if (!l.equalsRange(this._stickyRangeProjectedOnEditor))
        this._stickyRangeProjectedOnEditor = l, e.clear();
      else if (d.style.textDecoration === "underline")
        return;
      const c = new mi();
      e.add(Se(() => c.dispose(!0)));
      let h;
      RL(this._languageFeaturesService.definitionProvider, this._editor.getModel(), new A(l.startLineNumber, l.startColumn + 1), c.token).then((u) => {
        if (!c.token.isCancellationRequested)
          if (u.length !== 0) {
            this._candidateDefinitionsLength = u.length;
            const g = d;
            h !== g ? (e.clear(), h = g, h.style.textDecoration = "underline", e.add(Se(() => {
              h.style.textDecoration = "none";
            }))) : h || (h = g, h.style.textDecoration = "underline", e.add(Se(() => {
              h.style.textDecoration = "none";
            })));
          } else
            e.clear();
      });
    })), this._register(t.onCancel(() => {
      e.clear();
    })), this._register(t.onExecute(async (s) => {
      if (s.target.type !== 12 || s.target.detail !== this._stickyScrollWidget.getId())
        return;
      const o = this._stickyScrollWidget.getEditorPositionFromNode(s.target.element);
      o && (!this._editor.hasModel() || !this._stickyRangeProjectedOnEditor || (this._candidateDefinitionsLength > 1 && (this._focused && this._disposeFocusStickyScrollStore(), this._revealPosition({ lineNumber: o.lineNumber, column: 1 })), this._instaService.invokeFunction(y4, s, this._editor, { uri: this._editor.getModel().uri, range: this._stickyRangeProjectedOnEditor })));
    }));
  }
  _onContextMenu(e, t) {
    const i = new rr(e, t);
    this._contextMenuService.showContextMenu({
      menuId: D.StickyScrollContext,
      getAnchor: () => i
    });
  }
  _toggleFoldingRegionForLine(e) {
    if (!this._foldingModel || e === null)
      return;
    const t = this._stickyScrollWidget.getRenderedStickyLine(e), i = t == null ? void 0 : t.foldingIcon;
    if (!i)
      return;
    B4(this._foldingModel, Number.MAX_VALUE, [e]), i.isCollapsed = !i.isCollapsed;
    const n = (i.isCollapsed ? this._editor.getTopForLineNumber(i.foldingEndLine) : this._editor.getTopForLineNumber(i.foldingStartLine)) - this._editor.getOption(
      67
      /* EditorOption.lineHeight */
    ) * t.index + 1;
    this._editor.setScrollTop(n), this._renderStickyScroll(e);
  }
  _readConfiguration() {
    const e = this._editor.getOption(
      115
      /* EditorOption.stickyScroll */
    );
    if (e.enabled === !1) {
      this._editor.removeOverlayWidget(this._stickyScrollWidget), this._sessionStore.clear(), this._enabled = !1;
      return;
    } else e.enabled && !this._enabled && (this._editor.addOverlayWidget(this._stickyScrollWidget), this._sessionStore.add(this._editor.onDidScrollChange((i) => {
      i.scrollTopChanged && (this._showEndForLine = null, this._renderStickyScroll());
    })), this._sessionStore.add(this._editor.onDidLayoutChange(() => this._onDidResize())), this._sessionStore.add(this._editor.onDidChangeModelTokens((i) => this._onTokensChange(i))), this._sessionStore.add(this._stickyLineCandidateProvider.onDidChangeStickyScroll(() => {
      this._showEndForLine = null, this._renderStickyScroll();
    })), this._enabled = !0);
    this._editor.getOption(
      68
      /* EditorOption.lineNumbers */
    ).renderType === 2 && this._sessionStore.add(this._editor.onDidChangeCursorPosition(() => {
      this._showEndForLine = null, this._renderStickyScroll(0);
    }));
  }
  _readConfigurationChange(e) {
    (e.hasChanged(
      115
      /* EditorOption.stickyScroll */
    ) || e.hasChanged(
      73
      /* EditorOption.minimap */
    ) || e.hasChanged(
      67
      /* EditorOption.lineHeight */
    ) || e.hasChanged(
      110
      /* EditorOption.showFoldingControls */
    ) || e.hasChanged(
      68
      /* EditorOption.lineNumbers */
    )) && this._readConfiguration(), e.hasChanged(
      68
      /* EditorOption.lineNumbers */
    ) && this._renderStickyScroll(0);
  }
  _needsUpdate(e) {
    const t = this._stickyScrollWidget.getCurrentLines();
    for (const i of t)
      for (const n of e.ranges)
        if (i >= n.fromLineNumber && i <= n.toLineNumber)
          return !0;
    return !1;
  }
  _onTokensChange(e) {
    this._needsUpdate(e) && this._renderStickyScroll(0);
  }
  _onDidResize() {
    const t = this._editor.getLayoutInfo().height / this._editor.getOption(
      67
      /* EditorOption.lineHeight */
    );
    this._maxStickyLines = Math.round(t * 0.25);
  }
  async _renderStickyScroll(e) {
    var t, i;
    const n = this._editor.getModel();
    if (!n || n.isTooLargeForTokenization()) {
      this._foldingModel = null, this._stickyScrollWidget.setState(void 0, null);
      return;
    }
    const s = this._stickyLineCandidateProvider.getVersionId();
    if (s === void 0 || s === n.getVersionId())
      if (this._foldingModel = (i = await ((t = pd.get(this._editor)) === null || t === void 0 ? void 0 : t.getFoldingModel())) !== null && i !== void 0 ? i : null, this._widgetState = this.findScrollWidgetState(), this._stickyScrollVisibleContextKey.set(this._widgetState.startLineNumbers.length !== 0), !this._focused)
        this._stickyScrollWidget.setState(this._widgetState, this._foldingModel, e);
      else if (this._focusedStickyElementIndex === -1)
        this._stickyScrollWidget.setState(this._widgetState, this._foldingModel, e), this._focusedStickyElementIndex = this._stickyScrollWidget.lineNumberCount - 1, this._focusedStickyElementIndex !== -1 && this._stickyScrollWidget.focusLineWithIndex(this._focusedStickyElementIndex);
      else {
        const o = this._stickyScrollWidget.lineNumbers[this._focusedStickyElementIndex];
        this._stickyScrollWidget.setState(this._widgetState, this._foldingModel, e), this._stickyScrollWidget.lineNumberCount === 0 ? this._focusedStickyElementIndex = -1 : (this._stickyScrollWidget.lineNumbers.includes(o) || (this._focusedStickyElementIndex = this._stickyScrollWidget.lineNumberCount - 1), this._stickyScrollWidget.focusLineWithIndex(this._focusedStickyElementIndex));
      }
  }
  findScrollWidgetState() {
    const e = this._editor.getOption(
      67
      /* EditorOption.lineHeight */
    ), t = Math.min(this._maxStickyLines, this._editor.getOption(
      115
      /* EditorOption.stickyScroll */
    ).maxLineCount), i = this._editor.getScrollTop();
    let n = 0;
    const s = [], o = [], a = this._editor.getVisibleRanges();
    if (a.length !== 0) {
      const l = new x_(a[0].startLineNumber, a[a.length - 1].endLineNumber), d = this._stickyLineCandidateProvider.getCandidateStickyLinesIntersecting(l);
      for (const c of d) {
        const h = c.startLineNumber, u = c.endLineNumber, g = c.nestingDepth;
        if (u - h > 0) {
          const f = (g - 1) * e, m = g * e, _ = this._editor.getBottomForLineNumber(h) - i, v = this._editor.getTopForLineNumber(u) - i, b = this._editor.getBottomForLineNumber(u) - i;
          if (f > v && f <= b) {
            s.push(h), o.push(u + 1), n = b - m;
            break;
          } else m > _ && m <= b && (s.push(h), o.push(u + 1));
          if (s.length === t)
            break;
        }
      }
    }
    return this._endLineNumbers = o, new xB(s, o, n, this._showEndForLine);
  }
  dispose() {
    super.dispose(), this._sessionStore.dispose();
  }
};
dl.ID = "store.contrib.stickyScrollController";
dl = SN = Pve([
  Ig(1, Zs),
  Ig(2, he),
  Ig(3, be),
  Ig(4, Ot),
  Ig(5, Vo),
  Ig(6, De)
], dl);
class Ove extends cs {
  constructor() {
    super({
      id: "editor.action.toggleStickyScroll",
      title: {
        ...Me("toggleEditorStickyScroll", "Toggle Editor Sticky Scroll"),
        mnemonicTitle: p({ key: "mitoggleStickyScroll", comment: ["&& denotes a mnemonic"] }, "&&Toggle Editor Sticky Scroll")
      },
      metadata: {
        description: Me("toggleEditorStickyScroll.description", "Toggle/enable the editor sticky scroll which shows the nested scopes at the top of the viewport")
      },
      category: Ive.View,
      toggled: {
        condition: U.equals("config.editor.stickyScroll.enabled", !0),
        title: p("stickyScroll", "Sticky Scroll"),
        mnemonicTitle: p({ key: "miStickyScroll", comment: ["&& denotes a mnemonic"] }, "&&Sticky Scroll")
      },
      menu: [
        { id: D.CommandPalette },
        { id: D.MenubarAppearanceMenu, group: "4_editor", order: 3 },
        { id: D.StickyScrollContext }
      ]
    });
  }
  async run(e) {
    const t = e.get(Ge), i = !t.getValue("editor.stickyScroll.enabled");
    return t.updateValue("editor.stickyScroll.enabled", i);
  }
}
const aD = 100;
class Fve extends ra {
  constructor() {
    super({
      id: "editor.action.focusStickyScroll",
      title: {
        ...Me("focusStickyScroll", "Focus on the editor sticky scroll"),
        mnemonicTitle: p({ key: "mifocusStickyScroll", comment: ["&& denotes a mnemonic"] }, "&&Focus Sticky Scroll")
      },
      precondition: U.and(U.has("config.editor.stickyScroll.enabled"), x.stickyScrollVisible),
      menu: [
        { id: D.CommandPalette }
      ]
    });
  }
  runEditorCommand(e, t) {
    var i;
    (i = dl.get(t)) === null || i === void 0 || i.focus();
  }
}
class Wve extends ra {
  constructor() {
    super({
      id: "editor.action.selectNextStickyScrollLine",
      title: Me("selectNextStickyScrollLine.title", "Select the next editor sticky scroll line"),
      precondition: x.stickyScrollFocused.isEqualTo(!0),
      keybinding: {
        weight: aD,
        primary: 18
        /* KeyCode.DownArrow */
      }
    });
  }
  runEditorCommand(e, t) {
    var i;
    (i = dl.get(t)) === null || i === void 0 || i.focusNext();
  }
}
class Bve extends ra {
  constructor() {
    super({
      id: "editor.action.selectPreviousStickyScrollLine",
      title: Me("selectPreviousStickyScrollLine.title", "Select the previous sticky scroll line"),
      precondition: x.stickyScrollFocused.isEqualTo(!0),
      keybinding: {
        weight: aD,
        primary: 16
        /* KeyCode.UpArrow */
      }
    });
  }
  runEditorCommand(e, t) {
    var i;
    (i = dl.get(t)) === null || i === void 0 || i.focusPrevious();
  }
}
class Hve extends ra {
  constructor() {
    super({
      id: "editor.action.goToFocusedStickyScrollLine",
      title: Me("goToFocusedStickyScrollLine.title", "Go to the focused sticky scroll line"),
      precondition: x.stickyScrollFocused.isEqualTo(!0),
      keybinding: {
        weight: aD,
        primary: 3
        /* KeyCode.Enter */
      }
    });
  }
  runEditorCommand(e, t) {
    var i;
    (i = dl.get(t)) === null || i === void 0 || i.goToFocused();
  }
}
class Vve extends ra {
  constructor() {
    super({
      id: "editor.action.selectEditor",
      title: Me("selectEditor.title", "Select Editor"),
      precondition: x.stickyScrollFocused.isEqualTo(!0),
      keybinding: {
        weight: aD,
        primary: 9
        /* KeyCode.Escape */
      }
    });
  }
  runEditorCommand(e, t) {
    var i;
    (i = dl.get(t)) === null || i === void 0 || i.selectEditor();
  }
}
gt(
  dl.ID,
  dl,
  1
  /* EditorContributionInstantiation.AfterFirstRender */
);
Rt(Ove);
Rt(Fve);
Rt(Bve);
Rt(Wve);
Rt(Hve);
Rt(Vve);
var E$ = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, qm = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
class zve {
  constructor(e, t, i, n, s, o) {
    this.range = e, this.insertText = t, this.filterText = i, this.additionalTextEdits = n, this.command = s, this.completion = o;
  }
}
let yN = class extends XK {
  constructor(e, t, i, n, s, o) {
    super(s.disposable), this.model = e, this.line = t, this.word = i, this.completionModel = n, this._suggestMemoryService = o;
  }
  canBeReused(e, t, i) {
    return this.model === e && this.line === t && this.word.word.length > 0 && this.word.startColumn === i.startColumn && this.word.endColumn < i.endColumn && this.completionModel.getIncompleteProvider().size === 0;
  }
  get items() {
    var e;
    const t = [], { items: i } = this.completionModel, n = this._suggestMemoryService.select(this.model, { lineNumber: this.line, column: this.word.endColumn + this.completionModel.lineContext.characterCountDelta }, i), s = ut.slice(i, n), o = ut.slice(i, 0, n);
    let a = 5;
    for (const l of ut.concat(s, o)) {
      if (l.score === qr.Default)
        continue;
      const d = new L(
        l.editStart.lineNumber,
        l.editStart.column,
        l.editInsertEnd.lineNumber,
        l.editInsertEnd.column + this.completionModel.lineContext.characterCountDelta
        // end PLUS character delta
      ), c = l.completion.insertTextRules && l.completion.insertTextRules & 4 ? { snippet: l.completion.insertText } : l.completion.insertText;
      t.push(new zve(d, c, (e = l.filterTextLow) !== null && e !== void 0 ? e : l.labelLow, l.completion.additionalTextEdits, l.completion.command, l)), a-- >= 0 && l.resolve(at.None);
    }
    return t;
  }
};
yN = E$([
  qm(5, UL)
], yN);
let LN = class extends P {
  constructor(e, t, i, n) {
    super(), this._languageFeatureService = e, this._clipboardService = t, this._suggestMemoryService = i, this._editorService = n, this._store.add(e.inlineCompletionsProvider.register("*", this));
  }
  async provideInlineCompletions(e, t, i, n) {
    var s;
    if (i.selectedSuggestionInfo)
      return;
    let o;
    for (const f of this._editorService.listCodeEditors())
      if (f.getModel() === e) {
        o = f;
        break;
      }
    if (!o)
      return;
    const a = o.getOption(
      89
      /* EditorOption.quickSuggestions */
    );
    if (lf.isAllOff(a))
      return;
    e.tokenization.tokenizeIfCheap(t.lineNumber);
    const l = e.tokenization.getLineTokens(t.lineNumber), d = l.getStandardTokenType(l.findTokenIndexAtOffset(Math.max(t.column - 1 - 1, 0)));
    if (lf.valueFor(a, d) !== "inline")
      return;
    let c = e.getWordAtPosition(t), h;
    if (c != null && c.word || (h = this._getTriggerCharacterInfo(e, t)), !(c != null && c.word) && !h || (c || (c = e.getWordUntilPosition(t)), c.endColumn !== t.column))
      return;
    let u;
    const g = e.getValueInRange(new L(t.lineNumber, 1, t.lineNumber, t.column));
    if (!h && (!((s = this._lastResult) === null || s === void 0) && s.canBeReused(e, t.lineNumber, c))) {
      const f = new pB(g, t.column - this._lastResult.word.endColumn);
      this._lastResult.completionModel.lineContext = f, this._lastResult.acquire(), u = this._lastResult;
    } else {
      const f = await IR(this._languageFeatureService.completionProvider, e, t, new Hv(void 0, Ky.createSuggestFilter(o).itemKind, h == null ? void 0 : h.providers), h && { triggerKind: 1, triggerCharacter: h.ch }, n);
      let m;
      f.needsClipboard && (m = await this._clipboardService.readText());
      const _ = new Yd(f.items, t.column, new pB(g, 0), Pr.None, o.getOption(
        118
        /* EditorOption.suggest */
      ), o.getOption(
        112
        /* EditorOption.snippetSuggestions */
      ), { boostFullMatch: !1, firstMatchCanBeWeak: !1 }, m);
      u = new yN(e, t.lineNumber, c, _, f, this._suggestMemoryService);
    }
    return this._lastResult = u, u;
  }
  handleItemDidShow(e, t) {
    t.completion.resolve(at.None);
  }
  freeInlineCompletions(e) {
    e.release();
  }
  _getTriggerCharacterInfo(e, t) {
    var i;
    const n = e.getValueInRange(L.fromPositions({ lineNumber: t.lineNumber, column: t.column - 1 }, t)), s = /* @__PURE__ */ new Set();
    for (const o of this._languageFeatureService.completionProvider.all(e))
      !((i = o.triggerCharacters) === null || i === void 0) && i.includes(n) && s.add(o);
    if (s.size !== 0)
      return { providers: s, ch: n };
  }
};
LN = E$([
  qm(0, he),
  qm(1, Dd),
  qm(2, UL),
  qm(3, ht)
], LN);
Rb(LN);
class Uve extends ae {
  constructor() {
    super({
      id: "editor.action.forceRetokenize",
      label: p("forceRetokenize", "Developer: Force Retokenize"),
      alias: "Developer: Force Retokenize",
      precondition: void 0
    });
  }
  run(e, t) {
    if (!t.hasModel())
      return;
    const i = t.getModel();
    i.tokenization.resetTokenization();
    const n = new rs();
    i.tokenization.forceTokenization(i.getLineCount()), n.stop(), console.log(`tokenization took ${n.elapsed()}`);
  }
}
Y(Uve);
class lD extends cs {
  constructor() {
    super({
      id: lD.ID,
      title: Me({ key: "toggle.tabMovesFocus", comment: ["Turn on/off use of tab key for moving focus around VS Code"] }, "Toggle Tab Key Moves Focus"),
      precondition: void 0,
      keybinding: {
        primary: 2091,
        mac: {
          primary: 1323
          /* KeyCode.KeyM */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      metadata: {
        description: Me("tabMovesFocusDescriptions", "Determines whether the tab key moves focus around the workbench or inserts the tab character in the current editor. This is also called tab trapping, tab navigation, or tab focus mode.")
      },
      f1: !0
    });
  }
  run() {
    const t = !Uf.getTabFocusMode();
    Uf.setTabFocusMode(t), Ls(t ? p("toggle.tabMovesFocus.on", "Pressing Tab will now move focus to the next focusable element") : p("toggle.tabMovesFocus.off", "Pressing Tab will now insert the tab character"));
  }
}
lD.ID = "editor.action.toggleTabFocusMode";
Rt(lD);
var $ve = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, MB = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
let DN = class extends P {
  get enabled() {
    return this._enabled;
  }
  set enabled(e) {
    e ? (this.el.setAttribute("aria-disabled", "false"), this.el.tabIndex = 0, this.el.style.pointerEvents = "auto", this.el.style.opacity = "1", this.el.style.cursor = "pointer", this._enabled = !1) : (this.el.setAttribute("aria-disabled", "true"), this.el.tabIndex = -1, this.el.style.pointerEvents = "none", this.el.style.opacity = "0.4", this.el.style.cursor = "default", this._enabled = !0), this._enabled = e;
  }
  constructor(e, t, i = {}, n, s) {
    var o, a;
    super(), this._link = t, this._hoverService = n, this._enabled = !0, this.el = G(e, X("a.monaco-link", {
      tabIndex: (o = t.tabIndex) !== null && o !== void 0 ? o : 0,
      href: t.href
    }, t.label)), this.hoverDelegate = (a = i.hoverDelegate) !== null && a !== void 0 ? a : us("mouse"), this.setTooltip(t.title), this.el.setAttribute("role", "button");
    const l = this._register(new tt(this.el, "click")), d = this._register(new tt(this.el, "keypress")), c = ne.chain(d.event, (g) => g.map((f) => new Mt(f)).filter(
      (f) => f.keyCode === 3
      /* KeyCode.Enter */
    )), h = this._register(new tt(this.el, Pt.Tap)).event;
    this._register(At.addTarget(this.el));
    const u = ne.any(l.event, c, h);
    this._register(u((g) => {
      this.enabled && (nt.stop(g, !0), i != null && i.opener ? i.opener(this._link.href) : s.open(this._link.href, { allowCommands: !0 }));
    })), this.enabled = !0;
  }
  setTooltip(e) {
    this.hoverDelegate.showNativeHover ? this.el.title = e ?? "" : !this.hover && e ? this.hover = this._register(this._hoverService.setupUpdatableHover(this.hoverDelegate, this.el, e)) : this.hover && this.hover.update(e);
  }
};
DN = $ve([
  MB(3, gl),
  MB(4, Ys)
], DN);
var T$ = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, N$ = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
const Kve = 26;
let kN = class extends P {
  constructor(e, t) {
    super(), this._editor = e, this.instantiationService = t, this.banner = this._register(this.instantiationService.createInstance(xN));
  }
  hide() {
    this._editor.setBanner(null, 0), this.banner.clear();
  }
  show(e) {
    this.banner.show({
      ...e,
      onClose: () => {
        var t;
        this.hide(), (t = e.onClose) === null || t === void 0 || t.call(e);
      }
    }), this._editor.setBanner(this.banner.element, Kve);
  }
};
kN = T$([
  N$(1, be)
], kN);
let xN = class extends P {
  constructor(e) {
    super(), this.instantiationService = e, this.markdownRenderer = this.instantiationService.createInstance(nl, {}), this.element = X("div.editor-banner"), this.element.tabIndex = 0;
  }
  getAriaLabel(e) {
    if (e.ariaLabel)
      return e.ariaLabel;
    if (typeof e.message == "string")
      return e.message;
  }
  getBannerMessage(e) {
    if (typeof e == "string") {
      const t = X("span");
      return t.innerText = e, t;
    }
    return this.markdownRenderer.render(e).element;
  }
  clear() {
    pn(this.element);
  }
  show(e) {
    pn(this.element);
    const t = this.getAriaLabel(e);
    t && this.element.setAttribute("aria-label", t);
    const i = G(this.element, X("div.icon-container"));
    i.setAttribute("aria-hidden", "true"), e.icon && i.appendChild(X(`div${Le.asCSSSelector(e.icon)}`));
    const n = G(this.element, X("div.message-container"));
    if (n.setAttribute("aria-hidden", "true"), n.appendChild(this.getBannerMessage(e.message)), this.messageActionsContainer = G(this.element, X("div.message-actions-container")), e.actions)
      for (const o of e.actions)
        this._register(this.instantiationService.createInstance(DN, this.messageActionsContainer, { ...o, tabIndex: -1 }, {}));
    const s = G(this.element, X("div.action-container"));
    this.actionBar = this._register(new Bo(s)), this.actionBar.push(this._register(new Bs("banner.close", "Close Banner", Le.asClassName(b3), !0, () => {
      typeof e.onClose == "function" && e.onClose();
    })), { icon: !0, label: !1 }), this.actionBar.setFocusable(!1);
  }
};
xN = T$([
  N$(0, be)
], xN);
var zR = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Af = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
const jve = hi("extensions-warning-message", me.warning, p("warningIcon", "Icon shown with a warning message in the extensions editor."));
let Sp = class extends P {
  constructor(e, t, i, n) {
    super(), this._editor = e, this._editorWorkerService = t, this._workspaceTrustService = i, this._highlighter = null, this._bannerClosed = !1, this._updateState = (s) => {
      if (s && s.hasMore) {
        if (this._bannerClosed)
          return;
        const o = Math.max(s.ambiguousCharacterCount, s.nonBasicAsciiCharacterCount, s.invisibleCharacterCount);
        let a;
        if (s.nonBasicAsciiCharacterCount >= o)
          a = {
            message: p("unicodeHighlighting.thisDocumentHasManyNonBasicAsciiUnicodeCharacters", "This document contains many non-basic ASCII unicode characters"),
            command: new qp()
          };
        else if (s.ambiguousCharacterCount >= o)
          a = {
            message: p("unicodeHighlighting.thisDocumentHasManyAmbiguousUnicodeCharacters", "This document contains many ambiguous unicode characters"),
            command: new dh()
          };
        else if (s.invisibleCharacterCount >= o)
          a = {
            message: p("unicodeHighlighting.thisDocumentHasManyInvisibleUnicodeCharacters", "This document contains many invisible unicode characters"),
            command: new jp()
          };
        else
          throw new Error("Unreachable");
        this._bannerController.show({
          id: "unicodeHighlightBanner",
          message: a.message,
          icon: jve,
          actions: [
            {
              label: a.command.shortLabel,
              href: `command:${a.command.id}`
            }
          ],
          onClose: () => {
            this._bannerClosed = !0;
          }
        });
      } else
        this._bannerController.hide();
    }, this._bannerController = this._register(n.createInstance(kN, e)), this._register(this._editor.onDidChangeModel(() => {
      this._bannerClosed = !1, this._updateHighlighter();
    })), this._options = e.getOption(
      125
      /* EditorOption.unicodeHighlighting */
    ), this._register(i.onDidChangeTrust((s) => {
      this._updateHighlighter();
    })), this._register(e.onDidChangeConfiguration((s) => {
      s.hasChanged(
        125
        /* EditorOption.unicodeHighlighting */
      ) && (this._options = e.getOption(
        125
        /* EditorOption.unicodeHighlighting */
      ), this._updateHighlighter());
    })), this._updateHighlighter();
  }
  dispose() {
    this._highlighter && (this._highlighter.dispose(), this._highlighter = null), super.dispose();
  }
  _updateHighlighter() {
    if (this._updateState(null), this._highlighter && (this._highlighter.dispose(), this._highlighter = null), !this._editor.hasModel())
      return;
    const e = qve(this._workspaceTrustService.isWorkspaceTrusted(), this._options);
    if ([
      e.nonBasicASCII,
      e.ambiguousCharacters,
      e.invisibleCharacters
    ].every((i) => i === !1))
      return;
    const t = {
      nonBasicASCII: e.nonBasicASCII,
      ambiguousCharacters: e.ambiguousCharacters,
      invisibleCharacters: e.invisibleCharacters,
      includeComments: e.includeComments,
      includeStrings: e.includeStrings,
      allowedCodePoints: Object.keys(e.allowedCharacters).map((i) => i.codePointAt(0)),
      allowedLocales: Object.keys(e.allowedLocales).map((i) => i === "_os" ? new Intl.NumberFormat().resolvedOptions().locale : i === "_vscode" ? JK : i)
    };
    this._editorWorkerService.canComputeUnicodeHighlights(this._editor.getModel().uri) ? this._highlighter = new IN(this._editor, t, this._updateState, this._editorWorkerService) : this._highlighter = new Gve(this._editor, t, this._updateState);
  }
  getDecorationInfo(e) {
    return this._highlighter ? this._highlighter.getDecorationInfo(e) : null;
  }
};
Sp.ID = "editor.contrib.unicodeHighlighter";
Sp = zR([
  Af(1, Uo),
  Af(2, pz),
  Af(3, be)
], Sp);
function qve(r, e) {
  return {
    nonBasicASCII: e.nonBasicASCII === Js ? !r : e.nonBasicASCII,
    ambiguousCharacters: e.ambiguousCharacters,
    invisibleCharacters: e.invisibleCharacters,
    includeComments: e.includeComments === Js ? !r : e.includeComments,
    includeStrings: e.includeStrings === Js ? !r : e.includeStrings,
    allowedCharacters: e.allowedCharacters,
    allowedLocales: e.allowedLocales
  };
}
let IN = class extends P {
  constructor(e, t, i, n) {
    super(), this._editor = e, this._options = t, this._updateState = i, this._editorWorkerService = n, this._model = this._editor.getModel(), this._decorations = this._editor.createDecorationsCollection(), this._updateSoon = this._register(new xt(() => this._update(), 250)), this._register(this._editor.onDidChangeModelContent(() => {
      this._updateSoon.schedule();
    })), this._updateSoon.schedule();
  }
  dispose() {
    this._decorations.clear(), super.dispose();
  }
  _update() {
    if (this._model.isDisposed())
      return;
    if (!this._model.mightContainNonBasicASCII()) {
      this._decorations.clear();
      return;
    }
    const e = this._model.getVersionId();
    this._editorWorkerService.computedUnicodeHighlights(this._model.uri, this._options).then((t) => {
      if (this._model.isDisposed() || this._model.getVersionId() !== e)
        return;
      this._updateState(t);
      const i = [];
      if (!t.hasMore)
        for (const n of t.ranges)
          i.push({
            range: n,
            options: Yy.instance.getDecorationFromOptions(this._options)
          });
      this._decorations.set(i);
    });
  }
  getDecorationInfo(e) {
    if (!this._decorations.has(e))
      return null;
    const t = this._editor.getModel();
    if (!Z1(t, e))
      return null;
    const i = t.getValueInRange(e.range);
    return {
      reason: R$(i, this._options),
      inComment: Y1(t, e),
      inString: Q1(t, e)
    };
  }
};
IN = zR([
  Af(3, Uo)
], IN);
class Gve extends P {
  constructor(e, t, i) {
    super(), this._editor = e, this._options = t, this._updateState = i, this._model = this._editor.getModel(), this._decorations = this._editor.createDecorationsCollection(), this._updateSoon = this._register(new xt(() => this._update(), 250)), this._register(this._editor.onDidLayoutChange(() => {
      this._updateSoon.schedule();
    })), this._register(this._editor.onDidScrollChange(() => {
      this._updateSoon.schedule();
    })), this._register(this._editor.onDidChangeHiddenAreas(() => {
      this._updateSoon.schedule();
    })), this._register(this._editor.onDidChangeModelContent(() => {
      this._updateSoon.schedule();
    })), this._updateSoon.schedule();
  }
  dispose() {
    this._decorations.clear(), super.dispose();
  }
  _update() {
    if (this._model.isDisposed())
      return;
    if (!this._model.mightContainNonBasicASCII()) {
      this._decorations.clear();
      return;
    }
    const e = this._editor.getVisibleRanges(), t = [], i = {
      ranges: [],
      ambiguousCharacterCount: 0,
      invisibleCharacterCount: 0,
      nonBasicAsciiCharacterCount: 0,
      hasMore: !1
    };
    for (const n of e) {
      const s = bH.computeUnicodeHighlights(this._model, this._options, n);
      for (const o of s.ranges)
        i.ranges.push(o);
      i.ambiguousCharacterCount += i.ambiguousCharacterCount, i.invisibleCharacterCount += i.invisibleCharacterCount, i.nonBasicAsciiCharacterCount += i.nonBasicAsciiCharacterCount, i.hasMore = i.hasMore || s.hasMore;
    }
    if (!i.hasMore)
      for (const n of i.ranges)
        t.push({ range: n, options: Yy.instance.getDecorationFromOptions(this._options) });
    this._updateState(i), this._decorations.set(t);
  }
  getDecorationInfo(e) {
    if (!this._decorations.has(e))
      return null;
    const t = this._editor.getModel(), i = t.getValueInRange(e.range);
    return Z1(t, e) ? {
      reason: R$(i, this._options),
      inComment: Y1(t, e),
      inString: Q1(t, e)
    } : null;
  }
}
const M$ = p("unicodeHighlight.configureUnicodeHighlightOptions", "Configure Unicode Highlight Options");
let EN = class {
  constructor(e, t, i) {
    this._editor = e, this._languageService = t, this._openerService = i, this.hoverOrdinal = 5;
  }
  computeSync(e, t) {
    if (!this._editor.hasModel() || e.type !== 1)
      return [];
    const i = this._editor.getModel(), n = this._editor.getContribution(Sp.ID);
    if (!n)
      return [];
    const s = [], o = /* @__PURE__ */ new Set();
    let a = 300;
    for (const l of t) {
      const d = n.getDecorationInfo(l);
      if (!d)
        continue;
      const h = i.getValueInRange(l.range).codePointAt(0), u = hx(h);
      let g;
      switch (d.reason.kind) {
        case 0: {
          e0(d.reason.confusableWith) ? g = p("unicodeHighlight.characterIsAmbiguousASCII", "The character {0} could be confused with the ASCII character {1}, which is more common in source code.", u, hx(d.reason.confusableWith.codePointAt(0))) : g = p("unicodeHighlight.characterIsAmbiguous", "The character {0} could be confused with the character {1}, which is more common in source code.", u, hx(d.reason.confusableWith.codePointAt(0)));
          break;
        }
        case 1:
          g = p("unicodeHighlight.characterIsInvisible", "The character {0} is invisible.", u);
          break;
        case 2:
          g = p("unicodeHighlight.characterIsNonBasicAscii", "The character {0} is not a basic ASCII character.", u);
          break;
      }
      if (o.has(g))
        continue;
      o.add(g);
      const f = {
        codePoint: h,
        reason: d.reason,
        inComment: d.inComment,
        inString: d.inString
      }, m = p("unicodeHighlight.adjustSettings", "Adjust settings"), _ = `command:${qb.ID}?${encodeURIComponent(JSON.stringify(f))}`, v = new Nn("", !0).appendMarkdown(g).appendText(" ").appendLink(_, m, M$);
      s.push(new Wr(this, l.range, [v], !1, a++));
    }
    return s;
  }
  renderHoverParts(e, t) {
    return jhe(e, t, this._editor, this._languageService, this._openerService);
  }
};
EN = zR([
  Af(1, Jt),
  Af(2, Ys)
], EN);
function TN(r) {
  return `U+${r.toString(16).padStart(4, "0")}`;
}
function hx(r) {
  let e = `\`${TN(r)}\``;
  return CH.isInvisibleCharacter(r) || (e += ` "${`${Zve(r)}`}"`), e;
}
function Zve(r) {
  return r === 96 ? "`` ` ``" : "`" + String.fromCodePoint(r) + "`";
}
function R$(r, e) {
  return bH.computeUnicodeHighlightReason(r, e);
}
class Yy {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  getDecorationFromOptions(e) {
    return this.getDecoration(!e.includeComments, !e.includeStrings);
  }
  getDecoration(e, t) {
    const i = `${e}${t}`;
    let n = this.map.get(i);
    return n || (n = Fe.createDynamic({
      description: "unicode-highlight",
      stickiness: 1,
      className: "unicode-highlight",
      showIfCollapsed: !0,
      overviewRuler: null,
      minimap: null,
      hideInCommentTokens: e,
      hideInStringTokens: t
    }), this.map.set(i, n)), n;
  }
}
Yy.instance = new Yy();
class Yve extends ae {
  constructor() {
    super({
      id: dh.ID,
      label: p("action.unicodeHighlight.disableHighlightingInComments", "Disable highlighting of characters in comments"),
      alias: "Disable highlighting of characters in comments",
      precondition: void 0
    }), this.shortLabel = p("unicodeHighlight.disableHighlightingInComments.shortLabel", "Disable Highlight In Comments");
  }
  async run(e, t, i) {
    const n = e == null ? void 0 : e.get(Ge);
    n && this.runAction(n);
  }
  async runAction(e) {
    await e.updateValue(
      bs.includeComments,
      !1,
      2
      /* ConfigurationTarget.USER */
    );
  }
}
class Qve extends ae {
  constructor() {
    super({
      id: dh.ID,
      label: p("action.unicodeHighlight.disableHighlightingInStrings", "Disable highlighting of characters in strings"),
      alias: "Disable highlighting of characters in strings",
      precondition: void 0
    }), this.shortLabel = p("unicodeHighlight.disableHighlightingInStrings.shortLabel", "Disable Highlight In Strings");
  }
  async run(e, t, i) {
    const n = e == null ? void 0 : e.get(Ge);
    n && this.runAction(n);
  }
  async runAction(e) {
    await e.updateValue(
      bs.includeStrings,
      !1,
      2
      /* ConfigurationTarget.USER */
    );
  }
}
class dh extends ae {
  constructor() {
    super({
      id: dh.ID,
      label: p("action.unicodeHighlight.disableHighlightingOfAmbiguousCharacters", "Disable highlighting of ambiguous characters"),
      alias: "Disable highlighting of ambiguous characters",
      precondition: void 0
    }), this.shortLabel = p("unicodeHighlight.disableHighlightingOfAmbiguousCharacters.shortLabel", "Disable Ambiguous Highlight");
  }
  async run(e, t, i) {
    const n = e == null ? void 0 : e.get(Ge);
    n && this.runAction(n);
  }
  async runAction(e) {
    await e.updateValue(
      bs.ambiguousCharacters,
      !1,
      2
      /* ConfigurationTarget.USER */
    );
  }
}
dh.ID = "editor.action.unicodeHighlight.disableHighlightingOfAmbiguousCharacters";
class jp extends ae {
  constructor() {
    super({
      id: jp.ID,
      label: p("action.unicodeHighlight.disableHighlightingOfInvisibleCharacters", "Disable highlighting of invisible characters"),
      alias: "Disable highlighting of invisible characters",
      precondition: void 0
    }), this.shortLabel = p("unicodeHighlight.disableHighlightingOfInvisibleCharacters.shortLabel", "Disable Invisible Highlight");
  }
  async run(e, t, i) {
    const n = e == null ? void 0 : e.get(Ge);
    n && this.runAction(n);
  }
  async runAction(e) {
    await e.updateValue(
      bs.invisibleCharacters,
      !1,
      2
      /* ConfigurationTarget.USER */
    );
  }
}
jp.ID = "editor.action.unicodeHighlight.disableHighlightingOfInvisibleCharacters";
class qp extends ae {
  constructor() {
    super({
      id: qp.ID,
      label: p("action.unicodeHighlight.disableHighlightingOfNonBasicAsciiCharacters", "Disable highlighting of non basic ASCII characters"),
      alias: "Disable highlighting of non basic ASCII characters",
      precondition: void 0
    }), this.shortLabel = p("unicodeHighlight.disableHighlightingOfNonBasicAsciiCharacters.shortLabel", "Disable Non ASCII Highlight");
  }
  async run(e, t, i) {
    const n = e == null ? void 0 : e.get(Ge);
    n && this.runAction(n);
  }
  async runAction(e) {
    await e.updateValue(
      bs.nonBasicASCII,
      !1,
      2
      /* ConfigurationTarget.USER */
    );
  }
}
qp.ID = "editor.action.unicodeHighlight.disableHighlightingOfNonBasicAsciiCharacters";
class qb extends ae {
  constructor() {
    super({
      id: qb.ID,
      label: p("action.unicodeHighlight.showExcludeOptions", "Show Exclude Options"),
      alias: "Show Exclude Options",
      precondition: void 0
    });
  }
  async run(e, t, i) {
    const { codePoint: n, reason: s, inString: o, inComment: a } = i, l = String.fromCodePoint(n), d = e.get($o), c = e.get(Ge);
    function h(f) {
      return CH.isInvisibleCharacter(f) ? p("unicodeHighlight.excludeInvisibleCharFromBeingHighlighted", "Exclude {0} (invisible character) from being highlighted", TN(f)) : p("unicodeHighlight.excludeCharFromBeingHighlighted", "Exclude {0} from being highlighted", `${TN(f)} "${l}"`);
    }
    const u = [];
    if (s.kind === 0)
      for (const f of s.notAmbiguousInLocales)
        u.push({
          label: p("unicodeHighlight.allowCommonCharactersInLanguage", 'Allow unicode characters that are more common in the language "{0}".', f),
          run: async () => {
            Jve(c, [f]);
          }
        });
    if (u.push({
      label: h(n),
      run: () => Xve(c, [n])
    }), a) {
      const f = new Yve();
      u.push({ label: f.label, run: async () => f.runAction(c) });
    } else if (o) {
      const f = new Qve();
      u.push({ label: f.label, run: async () => f.runAction(c) });
    }
    if (s.kind === 0) {
      const f = new dh();
      u.push({ label: f.label, run: async () => f.runAction(c) });
    } else if (s.kind === 1) {
      const f = new jp();
      u.push({ label: f.label, run: async () => f.runAction(c) });
    } else if (s.kind === 2) {
      const f = new qp();
      u.push({ label: f.label, run: async () => f.runAction(c) });
    } else
      ebe(s);
    const g = await d.pick(u, { title: M$ });
    g && await g.run();
  }
}
qb.ID = "editor.action.unicodeHighlight.showExcludeOptions";
async function Xve(r, e) {
  const t = r.getValue(bs.allowedCharacters);
  let i;
  typeof t == "object" && t ? i = t : i = {};
  for (const n of e)
    i[String.fromCodePoint(n)] = !0;
  await r.updateValue(
    bs.allowedCharacters,
    i,
    2
    /* ConfigurationTarget.USER */
  );
}
async function Jve(r, e) {
  var t;
  const i = (t = r.inspect(bs.allowedLocales).user) === null || t === void 0 ? void 0 : t.value;
  let n;
  typeof i == "object" && i ? n = Object.assign({}, i) : n = {};
  for (const s of e)
    n[s] = !0;
  await r.updateValue(
    bs.allowedLocales,
    n,
    2
    /* ConfigurationTarget.USER */
  );
}
function ebe(r) {
  throw new Error(`Unexpected value: ${r}`);
}
Y(dh);
Y(jp);
Y(qp);
Y(qb);
gt(
  Sp.ID,
  Sp,
  1
  /* EditorContributionInstantiation.AfterFirstRender */
);
ah.register(EN);
var tbe = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, RB = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
const A$ = "ignoreUnusualLineTerminators";
function ibe(r, e, t) {
  r.setModelProperty(e.uri, A$, t);
}
function nbe(r, e) {
  return r.getModelProperty(e.uri, A$);
}
let Jv = class extends P {
  constructor(e, t, i) {
    super(), this._editor = e, this._dialogService = t, this._codeEditorService = i, this._isPresentingDialog = !1, this._config = this._editor.getOption(
      126
      /* EditorOption.unusualLineTerminators */
    ), this._register(this._editor.onDidChangeConfiguration((n) => {
      n.hasChanged(
        126
        /* EditorOption.unusualLineTerminators */
      ) && (this._config = this._editor.getOption(
        126
        /* EditorOption.unusualLineTerminators */
      ), this._checkForUnusualLineTerminators());
    })), this._register(this._editor.onDidChangeModel(() => {
      this._checkForUnusualLineTerminators();
    })), this._register(this._editor.onDidChangeModelContent((n) => {
      n.isUndoing || this._checkForUnusualLineTerminators();
    })), this._checkForUnusualLineTerminators();
  }
  async _checkForUnusualLineTerminators() {
    if (this._config === "off" || !this._editor.hasModel())
      return;
    const e = this._editor.getModel();
    if (!e.mightContainUnusualLineTerminators() || nbe(this._codeEditorService, e) === !0 || this._editor.getOption(
      91
      /* EditorOption.readOnly */
    ))
      return;
    if (this._config === "auto") {
      e.removeUnusualLineTerminators(this._editor.getSelections());
      return;
    }
    if (this._isPresentingDialog)
      return;
    let i;
    try {
      this._isPresentingDialog = !0, i = await this._dialogService.confirm({
        title: p("unusualLineTerminators.title", "Unusual Line Terminators"),
        message: p("unusualLineTerminators.message", "Detected unusual line terminators"),
        detail: p("unusualLineTerminators.detail", "The file '{0}' contains one or more unusual line terminator characters, like Line Separator (LS) or Paragraph Separator (PS).\n\nIt is recommended to remove them from the file. This can be configured via `editor.unusualLineTerminators`.", Fo(e.uri)),
        primaryButton: p({ key: "unusualLineTerminators.fix", comment: ["&& denotes a mnemonic"] }, "&&Remove Unusual Line Terminators"),
        cancelButton: p("unusualLineTerminators.ignore", "Ignore")
      });
    } finally {
      this._isPresentingDialog = !1;
    }
    if (!i.confirmed) {
      ibe(this._codeEditorService, e, !0);
      return;
    }
    e.removeUnusualLineTerminators(this._editor.getSelections());
  }
};
Jv.ID = "editor.contrib.unusualLineTerminatorsDetector";
Jv = tbe([
  RB(1, wb),
  RB(2, ht)
], Jv);
gt(
  Jv.ID,
  Jv,
  1
  /* EditorContributionInstantiation.AfterFirstRender */
);
var P$ = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, sS = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, Bi, NN;
const dD = new oe("hasWordHighlights", !1);
function O$(r, e, t, i) {
  const n = r.ordered(e);
  return e1(n.map((s) => () => Promise.resolve(s.provideDocumentHighlights(e, t, i)).then(void 0, _i)), Rn).then((s) => {
    if (s) {
      const o = new an();
      return o.set(e.uri, s), o;
    }
    return new an();
  });
}
function sbe(r, e, t, i, n, s) {
  const o = r.ordered(e);
  return e1(o.map((a) => () => {
    const l = s.filter((d) => nH(d)).filter((d) => tM(a.selector, d.uri, d.getLanguageId(), !0, void 0, void 0) > 0);
    return Promise.resolve(a.provideMultiDocumentHighlights(e, t, l, n)).then(void 0, _i);
  }), (a) => a instanceof an && a.size > 0);
}
class UR {
  constructor(e, t, i) {
    this._model = e, this._selection = t, this._wordSeparators = i, this._wordRange = this._getCurrentWordRange(e, t), this._result = null;
  }
  get result() {
    return this._result || (this._result = Zi((e) => this._compute(this._model, this._selection, this._wordSeparators, e))), this._result;
  }
  _getCurrentWordRange(e, t) {
    const i = e.getWordAtPosition(t.getPosition());
    return i ? new L(t.startLineNumber, i.startColumn, t.startLineNumber, i.endColumn) : null;
  }
  isValid(e, t, i) {
    const n = t.startLineNumber, s = t.startColumn, o = t.endColumn, a = this._getCurrentWordRange(e, t);
    let l = !!(this._wordRange && this._wordRange.equalsRange(a));
    for (let d = 0, c = i.length; !l && d < c; d++) {
      const h = i.getRange(d);
      h && h.startLineNumber === n && h.startColumn <= s && h.endColumn >= o && (l = !0);
    }
    return l;
  }
  cancel() {
    this.result.cancel();
  }
}
class obe extends UR {
  constructor(e, t, i, n) {
    super(e, t, i), this._providers = n;
  }
  _compute(e, t, i, n) {
    return O$(this._providers, e, t.getPosition(), n).then((s) => s || new an());
  }
}
class rbe extends UR {
  constructor(e, t, i, n, s) {
    super(e, t, i), this._providers = n, this._otherModels = s;
  }
  _compute(e, t, i, n) {
    return sbe(this._providers, e, t.getPosition(), i, n, this._otherModels).then((s) => s || new an());
  }
}
class F$ extends UR {
  constructor(e, t, i, n, s) {
    super(e, t, n), this._otherModels = s, this._selectionIsEmpty = t.isEmpty(), this._word = i;
  }
  _compute(e, t, i, n) {
    return cd(250, n).then(() => {
      const s = new an();
      let o;
      if (this._word ? o = this._word : o = e.getWordAtPosition(t.getPosition()), !o)
        return new an();
      const a = [e, ...this._otherModels];
      for (const l of a) {
        if (l.isDisposed())
          continue;
        const c = l.findMatches(o.word, !0, !1, !0, i, !1).map((h) => ({
          range: h.range,
          kind: Cx.Text
        }));
        c && s.set(l.uri, c);
      }
      return s;
    });
  }
  isValid(e, t, i) {
    const n = t.isEmpty();
    return this._selectionIsEmpty !== n ? !1 : super.isValid(e, t, i);
  }
}
function abe(r, e, t, i, n) {
  return r.has(e) ? new obe(e, t, n, r) : new F$(e, t, i, n, []);
}
function lbe(r, e, t, i, n, s) {
  return r.has(e) ? new rbe(e, t, n, r, s) : new F$(e, t, i, n, s);
}
ul("_executeDocumentHighlights", async (r, e, t) => {
  const i = r.get(he), n = await O$(i.documentHighlightProvider, e, t, at.None);
  return n == null ? void 0 : n.get(e.uri);
});
let eb = Bi = class {
  constructor(e, t, i, n, s) {
    this.toUnhook = new q(), this.workerRequestTokenId = 0, this.workerRequestCompleted = !1, this.workerRequestValue = new an(), this.lastCursorPositionChangeTime = 0, this.renderDecorationsTimer = -1, this.editor = e, this.providers = t, this.multiDocumentProviders = i, this.codeEditorService = s, this._hasWordHighlights = dD.bindTo(n), this._ignorePositionChangeEvent = !1, this.occurrencesHighlight = this.editor.getOption(
      81
      /* EditorOption.occurrencesHighlight */
    ), this.model = this.editor.getModel(), this.toUnhook.add(e.onDidChangeCursorPosition((o) => {
      this._ignorePositionChangeEvent || this.occurrencesHighlight !== "off" && this._onPositionChanged(o);
    })), this.toUnhook.add(e.onDidFocusEditorText((o) => {
      this.occurrencesHighlight !== "off" && (this.workerRequest || this._run());
    })), this.toUnhook.add(e.onDidChangeModelContent((o) => {
      this._stopAll();
    })), this.toUnhook.add(e.onDidChangeModel((o) => {
      !o.newModelUrl && o.oldModelUrl ? this._stopSingular() : Bi.query && this._run();
    })), this.toUnhook.add(e.onDidChangeConfiguration((o) => {
      const a = this.editor.getOption(
        81
        /* EditorOption.occurrencesHighlight */
      );
      this.occurrencesHighlight !== a && (this.occurrencesHighlight = a, this._stopAll());
    })), this.decorations = this.editor.createDecorationsCollection(), this.workerRequestTokenId = 0, this.workerRequest = null, this.workerRequestCompleted = !1, this.lastCursorPositionChangeTime = 0, this.renderDecorationsTimer = -1, Bi.query && this._run();
  }
  hasDecorations() {
    return this.decorations.length > 0;
  }
  restore() {
    this.occurrencesHighlight !== "off" && this._run();
  }
  _getSortedHighlights() {
    return this.decorations.getRanges().sort(L.compareRangesUsingStarts);
  }
  moveNext() {
    const e = this._getSortedHighlights(), i = (e.findIndex((s) => s.containsPosition(this.editor.getPosition())) + 1) % e.length, n = e[i];
    try {
      this._ignorePositionChangeEvent = !0, this.editor.setPosition(n.getStartPosition()), this.editor.revealRangeInCenterIfOutsideViewport(n);
      const s = this._getWord();
      if (s) {
        const o = this.editor.getModel().getLineContent(n.startLineNumber);
        Ls(`${o}, ${i + 1} of ${e.length} for '${s.word}'`);
      }
    } finally {
      this._ignorePositionChangeEvent = !1;
    }
  }
  moveBack() {
    const e = this._getSortedHighlights(), i = (e.findIndex((s) => s.containsPosition(this.editor.getPosition())) - 1 + e.length) % e.length, n = e[i];
    try {
      this._ignorePositionChangeEvent = !0, this.editor.setPosition(n.getStartPosition()), this.editor.revealRangeInCenterIfOutsideViewport(n);
      const s = this._getWord();
      if (s) {
        const o = this.editor.getModel().getLineContent(n.startLineNumber);
        Ls(`${o}, ${i + 1} of ${e.length} for '${s.word}'`);
      }
    } finally {
      this._ignorePositionChangeEvent = !1;
    }
  }
  _removeSingleDecorations() {
    if (!this.editor.hasModel())
      return;
    const e = Bi.storedDecorations.get(this.editor.getModel().uri);
    e && (this.editor.removeDecorations(e), Bi.storedDecorations.delete(this.editor.getModel().uri), this.decorations.length > 0 && (this.decorations.clear(), this._hasWordHighlights.set(!1)));
  }
  _removeAllDecorations() {
    const e = this.codeEditorService.listCodeEditors(), t = [];
    for (const i of e) {
      if (!i.hasModel())
        continue;
      const n = Bi.storedDecorations.get(i.getModel().uri);
      if (!n)
        continue;
      i.removeDecorations(n), t.push(i.getModel().uri);
      const s = _d.get(i);
      s != null && s.wordHighlighter && s.wordHighlighter.decorations.length > 0 && (s.wordHighlighter.decorations.clear(), s.wordHighlighter.workerRequest = null, s.wordHighlighter._hasWordHighlights.set(!1));
    }
    for (const i of t)
      Bi.storedDecorations.delete(i);
  }
  _stopSingular() {
    var e, t, i, n;
    this._removeSingleDecorations(), this.editor.hasTextFocus() && (((e = this.editor.getModel()) === null || e === void 0 ? void 0 : e.uri.scheme) !== Ne.vscodeNotebookCell && ((i = (t = Bi.query) === null || t === void 0 ? void 0 : t.modelInfo) === null || i === void 0 ? void 0 : i.model.uri.scheme) !== Ne.vscodeNotebookCell ? (Bi.query = null, this._run()) : !((n = Bi.query) === null || n === void 0) && n.modelInfo && (Bi.query.modelInfo = null)), this.renderDecorationsTimer !== -1 && (clearTimeout(this.renderDecorationsTimer), this.renderDecorationsTimer = -1), this.workerRequest !== null && (this.workerRequest.cancel(), this.workerRequest = null), this.workerRequestCompleted || (this.workerRequestTokenId++, this.workerRequestCompleted = !0);
  }
  _stopAll() {
    this._removeAllDecorations(), this.renderDecorationsTimer !== -1 && (clearTimeout(this.renderDecorationsTimer), this.renderDecorationsTimer = -1), this.workerRequest !== null && (this.workerRequest.cancel(), this.workerRequest = null), this.workerRequestCompleted || (this.workerRequestTokenId++, this.workerRequestCompleted = !0);
  }
  _onPositionChanged(e) {
    var t;
    if (this.occurrencesHighlight === "off") {
      this._stopAll();
      return;
    }
    if (e.reason !== 3 && ((t = this.editor.getModel()) === null || t === void 0 ? void 0 : t.uri.scheme) !== Ne.vscodeNotebookCell) {
      this._stopAll();
      return;
    }
    this._run();
  }
  _getWord() {
    const e = this.editor.getSelection(), t = e.startLineNumber, i = e.startColumn;
    return this.model.isDisposed() ? null : this.model.getWordAtPosition({
      lineNumber: t,
      column: i
    });
  }
  getOtherModelsToHighlight(e) {
    if (!e)
      return [];
    if (e.uri.scheme === Ne.vscodeNotebookCell) {
      const s = [], o = this.codeEditorService.listCodeEditors();
      for (const a of o) {
        const l = a.getModel();
        l && l !== e && l.uri.scheme === Ne.vscodeNotebookCell && s.push(l);
      }
      return s;
    }
    const i = [], n = this.codeEditorService.listCodeEditors();
    for (const s of n) {
      if (!YM(s))
        continue;
      const o = s.getModel();
      o && e === o.modified && i.push(o.modified);
    }
    if (i.length)
      return i;
    if (this.occurrencesHighlight === "singleFile")
      return [];
    for (const s of n) {
      const o = s.getModel();
      o && o !== e && i.push(o);
    }
    return i;
  }
  _run() {
    var e;
    let t;
    if (this.editor.hasTextFocus()) {
      const n = this.editor.getSelection();
      if (!n || n.startLineNumber !== n.endLineNumber) {
        Bi.query = null, this._stopAll();
        return;
      }
      const s = n.startColumn, o = n.endColumn, a = this._getWord();
      if (!a || a.startColumn > s || a.endColumn < o) {
        Bi.query = null, this._stopAll();
        return;
      }
      t = this.workerRequest && this.workerRequest.isValid(this.model, n, this.decorations), Bi.query = {
        modelInfo: {
          model: this.model,
          selection: n
        },
        word: a
      };
    } else if (!Bi.query)
      return;
    if (this.lastCursorPositionChangeTime = (/* @__PURE__ */ new Date()).getTime(), t)
      this.workerRequestCompleted && this.renderDecorationsTimer !== -1 && (clearTimeout(this.renderDecorationsTimer), this.renderDecorationsTimer = -1, this._beginRenderDecorations());
    else {
      this._stopAll();
      const n = ++this.workerRequestTokenId;
      this.workerRequestCompleted = !1;
      const s = this.getOtherModelsToHighlight(this.editor.getModel());
      if (!Bi.query.modelInfo || Bi.query.modelInfo.model.isDisposed())
        return;
      this.workerRequest = this.computeWithModel(Bi.query.modelInfo.model, Bi.query.modelInfo.selection, Bi.query.word, s), (e = this.workerRequest) === null || e === void 0 || e.result.then((o) => {
        n === this.workerRequestTokenId && (this.workerRequestCompleted = !0, this.workerRequestValue = o || [], this._beginRenderDecorations());
      }, He);
    }
  }
  computeWithModel(e, t, i, n) {
    return n.length ? lbe(this.multiDocumentProviders, e, t, i, this.editor.getOption(
      131
      /* EditorOption.wordSeparators */
    ), n) : abe(this.providers, e, t, i, this.editor.getOption(
      131
      /* EditorOption.wordSeparators */
    ));
  }
  _beginRenderDecorations() {
    const e = (/* @__PURE__ */ new Date()).getTime(), t = this.lastCursorPositionChangeTime + 250;
    e >= t ? (this.renderDecorationsTimer = -1, this.renderDecorations()) : this.renderDecorationsTimer = setTimeout(() => {
      this.renderDecorations();
    }, t - e);
  }
  renderDecorations() {
    var e, t, i;
    this.renderDecorationsTimer = -1;
    const n = this.codeEditorService.listCodeEditors();
    for (const s of n) {
      const o = _d.get(s);
      if (!o)
        continue;
      const a = [], l = (e = s.getModel()) === null || e === void 0 ? void 0 : e.uri;
      if (l && this.workerRequestValue.has(l)) {
        const d = Bi.storedDecorations.get(l), c = this.workerRequestValue.get(l);
        if (c)
          for (const u of c)
            u.range && a.push({
              range: u.range,
              options: b_e(u.kind)
            });
        let h = [];
        s.changeDecorations((u) => {
          h = u.deltaDecorations(d ?? [], a);
        }), Bi.storedDecorations = Bi.storedDecorations.set(l, h), a.length > 0 && ((t = o.wordHighlighter) === null || t === void 0 || t.decorations.set(a), (i = o.wordHighlighter) === null || i === void 0 || i._hasWordHighlights.set(!0));
      }
    }
  }
  dispose() {
    this._stopSingular(), this.toUnhook.dispose();
  }
};
eb.storedDecorations = new an();
eb.query = null;
eb = Bi = P$([
  sS(4, ht)
], eb);
let _d = NN = class extends P {
  static get(e) {
    return e.getContribution(NN.ID);
  }
  constructor(e, t, i, n) {
    super(), this._wordHighlighter = null;
    const s = () => {
      e.hasModel() && !e.getModel().isTooLargeForTokenization() && (this._wordHighlighter = new eb(e, i.documentHighlightProvider, i.multiDocumentHighlightProvider, t, n));
    };
    this._register(e.onDidChangeModel((o) => {
      this._wordHighlighter && (this._wordHighlighter.dispose(), this._wordHighlighter = null), s();
    })), s();
  }
  get wordHighlighter() {
    return this._wordHighlighter;
  }
  saveViewState() {
    return !!(this._wordHighlighter && this._wordHighlighter.hasDecorations());
  }
  moveNext() {
    var e;
    (e = this._wordHighlighter) === null || e === void 0 || e.moveNext();
  }
  moveBack() {
    var e;
    (e = this._wordHighlighter) === null || e === void 0 || e.moveBack();
  }
  restoreViewState(e) {
    this._wordHighlighter && e && this._wordHighlighter.restore();
  }
  dispose() {
    this._wordHighlighter && (this._wordHighlighter.dispose(), this._wordHighlighter = null), super.dispose();
  }
};
_d.ID = "editor.contrib.wordHighlighter";
_d = NN = P$([
  sS(1, De),
  sS(2, he),
  sS(3, ht)
], _d);
class W$ extends ae {
  constructor(e, t) {
    super(t), this._isNext = e;
  }
  run(e, t) {
    const i = _d.get(t);
    i && (this._isNext ? i.moveNext() : i.moveBack());
  }
}
class dbe extends W$ {
  constructor() {
    super(!0, {
      id: "editor.action.wordHighlight.next",
      label: p("wordHighlight.next.label", "Go to Next Symbol Highlight"),
      alias: "Go to Next Symbol Highlight",
      precondition: dD,
      kbOpts: {
        kbExpr: x.editorTextFocus,
        primary: 65,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
}
class cbe extends W$ {
  constructor() {
    super(!1, {
      id: "editor.action.wordHighlight.prev",
      label: p("wordHighlight.previous.label", "Go to Previous Symbol Highlight"),
      alias: "Go to Previous Symbol Highlight",
      precondition: dD,
      kbOpts: {
        kbExpr: x.editorTextFocus,
        primary: 1089,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
}
class hbe extends ae {
  constructor() {
    super({
      id: "editor.action.wordHighlight.trigger",
      label: p("wordHighlight.trigger.label", "Trigger Symbol Highlight"),
      alias: "Trigger Symbol Highlight",
      precondition: dD.toNegated(),
      kbOpts: {
        kbExpr: x.editorTextFocus,
        primary: 0,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(e, t, i) {
    const n = _d.get(t);
    n && n.restoreViewState(!0);
  }
}
gt(
  _d.ID,
  _d,
  0
  /* EditorContributionInstantiation.Eager */
);
Y(dbe);
Y(cbe);
Y(hbe);
class cD extends Ui {
  constructor(e) {
    super(e), this._inSelectionMode = e.inSelectionMode, this._wordNavigationType = e.wordNavigationType;
  }
  runEditorCommand(e, t, i) {
    if (!t.hasModel())
      return;
    const n = fr(t.getOption(
      131
      /* EditorOption.wordSeparators */
    ), t.getOption(
      130
      /* EditorOption.wordSegmenterLocales */
    )), s = t.getModel(), a = t.getSelections().map((l) => {
      const d = new A(l.positionLineNumber, l.positionColumn), c = this._move(n, s, d, this._wordNavigationType);
      return this._moveTo(l, c, this._inSelectionMode);
    });
    if (s.pushStackElement(), t._getViewModel().setCursorStates("moveWordCommand", 3, a.map((l) => dt.fromModelSelection(l))), a.length === 1) {
      const l = new A(a[0].positionLineNumber, a[0].positionColumn);
      t.revealPosition(
        l,
        0
        /* ScrollType.Smooth */
      );
    }
  }
  _moveTo(e, t, i) {
    return i ? new ge(e.selectionStartLineNumber, e.selectionStartColumn, t.lineNumber, t.column) : new ge(t.lineNumber, t.column, t.lineNumber, t.column);
  }
}
class ch extends cD {
  _move(e, t, i, n) {
    return vt.moveWordLeft(e, t, i, n);
  }
}
class hh extends cD {
  _move(e, t, i, n) {
    return vt.moveWordRight(e, t, i, n);
  }
}
class ube extends ch {
  constructor() {
    super({
      inSelectionMode: !1,
      wordNavigationType: 0,
      id: "cursorWordStartLeft",
      precondition: void 0
    });
  }
}
class gbe extends ch {
  constructor() {
    super({
      inSelectionMode: !1,
      wordNavigationType: 2,
      id: "cursorWordEndLeft",
      precondition: void 0
    });
  }
}
class fbe extends ch {
  constructor() {
    var e;
    super({
      inSelectionMode: !1,
      wordNavigationType: 1,
      id: "cursorWordLeft",
      precondition: void 0,
      kbOpts: {
        kbExpr: U.and(x.textInputFocus, (e = U.and(ub, sL)) === null || e === void 0 ? void 0 : e.negate()),
        primary: 2063,
        mac: {
          primary: 527
          /* KeyCode.LeftArrow */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
}
class pbe extends ch {
  constructor() {
    super({
      inSelectionMode: !0,
      wordNavigationType: 0,
      id: "cursorWordStartLeftSelect",
      precondition: void 0
    });
  }
}
class mbe extends ch {
  constructor() {
    super({
      inSelectionMode: !0,
      wordNavigationType: 2,
      id: "cursorWordEndLeftSelect",
      precondition: void 0
    });
  }
}
class _be extends ch {
  constructor() {
    var e;
    super({
      inSelectionMode: !0,
      wordNavigationType: 1,
      id: "cursorWordLeftSelect",
      precondition: void 0,
      kbOpts: {
        kbExpr: U.and(x.textInputFocus, (e = U.and(ub, sL)) === null || e === void 0 ? void 0 : e.negate()),
        primary: 3087,
        mac: {
          primary: 1551
          /* KeyCode.LeftArrow */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
}
class vbe extends ch {
  constructor() {
    super({
      inSelectionMode: !1,
      wordNavigationType: 3,
      id: "cursorWordAccessibilityLeft",
      precondition: void 0
    });
  }
  _move(e, t, i, n) {
    return super._move(fr(oa.wordSeparators.defaultValue, e.intlSegmenterLocales), t, i, n);
  }
}
class bbe extends ch {
  constructor() {
    super({
      inSelectionMode: !0,
      wordNavigationType: 3,
      id: "cursorWordAccessibilityLeftSelect",
      precondition: void 0
    });
  }
  _move(e, t, i, n) {
    return super._move(fr(oa.wordSeparators.defaultValue, e.intlSegmenterLocales), t, i, n);
  }
}
class Cbe extends hh {
  constructor() {
    super({
      inSelectionMode: !1,
      wordNavigationType: 0,
      id: "cursorWordStartRight",
      precondition: void 0
    });
  }
}
class wbe extends hh {
  constructor() {
    var e;
    super({
      inSelectionMode: !1,
      wordNavigationType: 2,
      id: "cursorWordEndRight",
      precondition: void 0,
      kbOpts: {
        kbExpr: U.and(x.textInputFocus, (e = U.and(ub, sL)) === null || e === void 0 ? void 0 : e.negate()),
        primary: 2065,
        mac: {
          primary: 529
          /* KeyCode.RightArrow */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
}
class Sbe extends hh {
  constructor() {
    super({
      inSelectionMode: !1,
      wordNavigationType: 2,
      id: "cursorWordRight",
      precondition: void 0
    });
  }
}
class ybe extends hh {
  constructor() {
    super({
      inSelectionMode: !0,
      wordNavigationType: 0,
      id: "cursorWordStartRightSelect",
      precondition: void 0
    });
  }
}
class Lbe extends hh {
  constructor() {
    var e;
    super({
      inSelectionMode: !0,
      wordNavigationType: 2,
      id: "cursorWordEndRightSelect",
      precondition: void 0,
      kbOpts: {
        kbExpr: U.and(x.textInputFocus, (e = U.and(ub, sL)) === null || e === void 0 ? void 0 : e.negate()),
        primary: 3089,
        mac: {
          primary: 1553
          /* KeyCode.RightArrow */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
}
class Dbe extends hh {
  constructor() {
    super({
      inSelectionMode: !0,
      wordNavigationType: 2,
      id: "cursorWordRightSelect",
      precondition: void 0
    });
  }
}
class kbe extends hh {
  constructor() {
    super({
      inSelectionMode: !1,
      wordNavigationType: 3,
      id: "cursorWordAccessibilityRight",
      precondition: void 0
    });
  }
  _move(e, t, i, n) {
    return super._move(fr(oa.wordSeparators.defaultValue, e.intlSegmenterLocales), t, i, n);
  }
}
class xbe extends hh {
  constructor() {
    super({
      inSelectionMode: !0,
      wordNavigationType: 3,
      id: "cursorWordAccessibilityRightSelect",
      precondition: void 0
    });
  }
  _move(e, t, i, n) {
    return super._move(fr(oa.wordSeparators.defaultValue, e.intlSegmenterLocales), t, i, n);
  }
}
class hD extends Ui {
  constructor(e) {
    super(e), this._whitespaceHeuristics = e.whitespaceHeuristics, this._wordNavigationType = e.wordNavigationType;
  }
  runEditorCommand(e, t, i) {
    const n = e.get(Ot);
    if (!t.hasModel())
      return;
    const s = fr(t.getOption(
      131
      /* EditorOption.wordSeparators */
    ), t.getOption(
      130
      /* EditorOption.wordSegmenterLocales */
    )), o = t.getModel(), a = t.getSelections(), l = t.getOption(
      6
      /* EditorOption.autoClosingBrackets */
    ), d = t.getOption(
      11
      /* EditorOption.autoClosingQuotes */
    ), c = n.getLanguageConfiguration(o.getLanguageId()).getAutoClosingPairs(), h = t._getViewModel(), u = a.map((g) => {
      const f = this._delete({
        wordSeparators: s,
        model: o,
        selection: g,
        whitespaceHeuristics: this._whitespaceHeuristics,
        autoClosingDelete: t.getOption(
          9
          /* EditorOption.autoClosingDelete */
        ),
        autoClosingBrackets: l,
        autoClosingQuotes: d,
        autoClosingPairs: c,
        autoClosedCharacters: h.getCursorAutoClosedCharacters()
      }, this._wordNavigationType);
      return new Cn(f, "");
    });
    t.pushUndoStop(), t.executeCommands(this.id, u), t.pushUndoStop();
  }
}
class $R extends hD {
  _delete(e, t) {
    const i = vt.deleteWordLeft(e, t);
    return i || new L(1, 1, 1, 1);
  }
}
class KR extends hD {
  _delete(e, t) {
    const i = vt.deleteWordRight(e, t);
    if (i)
      return i;
    const n = e.model.getLineCount(), s = e.model.getLineMaxColumn(n);
    return new L(n, s, n, s);
  }
}
class Ibe extends $R {
  constructor() {
    super({
      whitespaceHeuristics: !1,
      wordNavigationType: 0,
      id: "deleteWordStartLeft",
      precondition: x.writable
    });
  }
}
class Ebe extends $R {
  constructor() {
    super({
      whitespaceHeuristics: !1,
      wordNavigationType: 2,
      id: "deleteWordEndLeft",
      precondition: x.writable
    });
  }
}
class Tbe extends $R {
  constructor() {
    super({
      whitespaceHeuristics: !0,
      wordNavigationType: 0,
      id: "deleteWordLeft",
      precondition: x.writable,
      kbOpts: {
        kbExpr: x.textInputFocus,
        primary: 2049,
        mac: {
          primary: 513
          /* KeyCode.Backspace */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
}
class Nbe extends KR {
  constructor() {
    super({
      whitespaceHeuristics: !1,
      wordNavigationType: 0,
      id: "deleteWordStartRight",
      precondition: x.writable
    });
  }
}
class Mbe extends KR {
  constructor() {
    super({
      whitespaceHeuristics: !1,
      wordNavigationType: 2,
      id: "deleteWordEndRight",
      precondition: x.writable
    });
  }
}
class Rbe extends KR {
  constructor() {
    super({
      whitespaceHeuristics: !0,
      wordNavigationType: 2,
      id: "deleteWordRight",
      precondition: x.writable,
      kbOpts: {
        kbExpr: x.textInputFocus,
        primary: 2068,
        mac: {
          primary: 532
          /* KeyCode.Delete */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
}
class Abe extends ae {
  constructor() {
    super({
      id: "deleteInsideWord",
      precondition: x.writable,
      label: p("deleteInsideWord", "Delete Word"),
      alias: "Delete Word"
    });
  }
  run(e, t, i) {
    if (!t.hasModel())
      return;
    const n = fr(t.getOption(
      131
      /* EditorOption.wordSeparators */
    ), t.getOption(
      130
      /* EditorOption.wordSegmenterLocales */
    )), s = t.getModel(), a = t.getSelections().map((l) => {
      const d = vt.deleteInsideWord(n, s, l);
      return new Cn(d, "");
    });
    t.pushUndoStop(), t.executeCommands(this.id, a), t.pushUndoStop();
  }
}
se(new ube());
se(new gbe());
se(new fbe());
se(new pbe());
se(new mbe());
se(new _be());
se(new Cbe());
se(new wbe());
se(new Sbe());
se(new ybe());
se(new Lbe());
se(new Dbe());
se(new vbe());
se(new bbe());
se(new kbe());
se(new xbe());
se(new Ibe());
se(new Ebe());
se(new Tbe());
se(new Nbe());
se(new Mbe());
se(new Rbe());
Y(Abe);
class Pbe extends hD {
  constructor() {
    super({
      whitespaceHeuristics: !0,
      wordNavigationType: 0,
      id: "deleteWordPartLeft",
      precondition: x.writable,
      kbOpts: {
        kbExpr: x.textInputFocus,
        primary: 0,
        mac: {
          primary: 769
          /* KeyCode.Backspace */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  _delete(e, t) {
    const i = T0.deleteWordPartLeft(e);
    return i || new L(1, 1, 1, 1);
  }
}
class Obe extends hD {
  constructor() {
    super({
      whitespaceHeuristics: !0,
      wordNavigationType: 2,
      id: "deleteWordPartRight",
      precondition: x.writable,
      kbOpts: {
        kbExpr: x.textInputFocus,
        primary: 0,
        mac: {
          primary: 788
          /* KeyCode.Delete */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  _delete(e, t) {
    const i = T0.deleteWordPartRight(e);
    if (i)
      return i;
    const n = e.model.getLineCount(), s = e.model.getLineMaxColumn(n);
    return new L(n, s, n, s);
  }
}
class B$ extends cD {
  _move(e, t, i, n) {
    return T0.moveWordPartLeft(e, t, i);
  }
}
class Fbe extends B$ {
  constructor() {
    super({
      inSelectionMode: !1,
      wordNavigationType: 0,
      id: "cursorWordPartLeft",
      precondition: void 0,
      kbOpts: {
        kbExpr: x.textInputFocus,
        primary: 0,
        mac: {
          primary: 783
          /* KeyCode.LeftArrow */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
}
st.registerCommandAlias("cursorWordPartStartLeft", "cursorWordPartLeft");
class Wbe extends B$ {
  constructor() {
    super({
      inSelectionMode: !0,
      wordNavigationType: 0,
      id: "cursorWordPartLeftSelect",
      precondition: void 0,
      kbOpts: {
        kbExpr: x.textInputFocus,
        primary: 0,
        mac: {
          primary: 1807
          /* KeyCode.LeftArrow */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
}
st.registerCommandAlias("cursorWordPartStartLeftSelect", "cursorWordPartLeftSelect");
class H$ extends cD {
  _move(e, t, i, n) {
    return T0.moveWordPartRight(e, t, i);
  }
}
class Bbe extends H$ {
  constructor() {
    super({
      inSelectionMode: !1,
      wordNavigationType: 2,
      id: "cursorWordPartRight",
      precondition: void 0,
      kbOpts: {
        kbExpr: x.textInputFocus,
        primary: 0,
        mac: {
          primary: 785
          /* KeyCode.RightArrow */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
}
class Hbe extends H$ {
  constructor() {
    super({
      inSelectionMode: !0,
      wordNavigationType: 2,
      id: "cursorWordPartRightSelect",
      precondition: void 0,
      kbOpts: {
        kbExpr: x.textInputFocus,
        primary: 0,
        mac: {
          primary: 1809
          /* KeyCode.RightArrow */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
}
se(new Pbe());
se(new Obe());
se(new Fbe());
se(new Wbe());
se(new Bbe());
se(new Hbe());
class MN extends P {
  constructor(e) {
    super(), this.editor = e, this._register(this.editor.onDidAttemptReadOnlyEdit(() => this._onDidAttemptReadOnlyEdit()));
  }
  _onDidAttemptReadOnlyEdit() {
    const e = ss.get(this.editor);
    if (e && this.editor.hasModel()) {
      let t = this.editor.getOptions().get(
        92
        /* EditorOption.readOnlyMessage */
      );
      t || (this.editor.isSimpleWidget ? t = new Nn(p("editor.simple.readonly", "Cannot edit in read-only input")) : t = new Nn(p("editor.readonly", "Cannot edit in read-only editor"))), e.showMessage(t, this.editor.getPosition());
    }
  }
}
MN.ID = "editor.contrib.readOnlyMessageController";
gt(
  MN.ID,
  MN,
  2
  /* EditorContributionInstantiation.BeforeFirstInteraction */
);
var Vbe = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, AB = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
let RN = class extends P {
  constructor(e, t, i) {
    super(), this._textModel = e, this._languageFeaturesService = t, this._outlineModelService = i, this._currentModel = rt(this, void 0);
    const n = Mn("documentSymbolProvider.onDidChange", this._languageFeaturesService.documentSymbolProvider.onDidChange), s = Mn("_textModel.onDidChangeContent", ne.debounce((o) => this._textModel.onDidChangeContent(o), () => {
    }, 100));
    this._register(Wo(async (o, a) => {
      n.read(o), s.read(o);
      const l = a.add(new ire()), d = await this._outlineModelService.getOrCreate(this._textModel, l.token);
      a.isDisposed || this._currentModel.set(d, void 0);
    }));
  }
  getBreadcrumbItems(e, t) {
    const i = this._currentModel.read(t);
    if (!i)
      return [];
    const n = i.asListOfDocumentSymbols().filter((s) => e.contains(s.range.startLineNumber) && !e.contains(s.range.endLineNumber));
    return n.sort(ej(cr((s) => s.range.endLineNumber - s.range.startLineNumber, Zu))), n.map((s) => ({ name: s.name, kind: s.kind, startLineNumber: s.range.startLineNumber }));
  }
};
RN = Vbe([
  AB(1, he),
  AB(2, Kb)
], RN);
Lv.setBreadcrumbsSourceFactory((r, e) => e.createInstance(RN, r));
class AN extends P {
  constructor(e) {
    super(), this.editor = e, this.widget = null, Zr && (this._register(e.onDidChangeConfiguration(() => this.update())), this.update());
  }
  update() {
    const e = !this.editor.getOption(
      91
      /* EditorOption.readOnly */
    );
    !this.widget && e ? this.widget = new uD(this.editor) : this.widget && !e && (this.widget.dispose(), this.widget = null);
  }
  dispose() {
    super.dispose(), this.widget && (this.widget.dispose(), this.widget = null);
  }
}
AN.ID = "editor.contrib.iPadShowKeyboard";
class uD extends P {
  constructor(e) {
    super(), this.editor = e, this._domNode = document.createElement("textarea"), this._domNode.className = "iPadShowKeyboard", this._register(W(this._domNode, "touchstart", (t) => {
      this.editor.focus();
    })), this._register(W(this._domNode, "focus", (t) => {
      this.editor.focus();
    })), this.editor.addOverlayWidget(this);
  }
  dispose() {
    this.editor.removeOverlayWidget(this), super.dispose();
  }
  // ----- IOverlayWidget API
  getId() {
    return uD.ID;
  }
  getDomNode() {
    return this._domNode;
  }
  getPosition() {
    return {
      preference: 1
      /* OverlayWidgetPositionPreference.BOTTOM_RIGHT_CORNER */
    };
  }
}
uD.ID = "editor.contrib.ShowKeyboardWidget";
gt(
  AN.ID,
  AN,
  3
  /* EditorContributionInstantiation.Eventually */
);
var zbe = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, PB = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, PN;
let yp = PN = class extends P {
  static get(e) {
    return e.getContribution(PN.ID);
  }
  constructor(e, t, i) {
    super(), this._editor = e, this._languageService = i, this._widget = null, this._register(this._editor.onDidChangeModel((n) => this.stop())), this._register(this._editor.onDidChangeModelLanguage((n) => this.stop())), this._register(ri.onDidChange((n) => this.stop())), this._register(this._editor.onKeyUp((n) => n.keyCode === 9 && this.stop()));
  }
  dispose() {
    this.stop(), super.dispose();
  }
  launch() {
    this._widget || this._editor.hasModel() && (this._widget = new gD(this._editor, this._languageService));
  }
  stop() {
    this._widget && (this._widget.dispose(), this._widget = null);
  }
};
yp.ID = "editor.contrib.inspectTokens";
yp = PN = zbe([
  PB(1, wo),
  PB(2, Jt)
], yp);
class Ube extends ae {
  constructor() {
    super({
      id: "editor.action.inspectTokens",
      label: BI.inspectTokensAction,
      alias: "Developer: Inspect Tokens",
      precondition: void 0
    });
  }
  run(e, t) {
    const i = yp.get(t);
    i == null || i.launch();
  }
}
function $be(r) {
  let e = "";
  for (let t = 0, i = r.length; t < i; t++) {
    const n = r.charCodeAt(t);
    switch (n) {
      case 9:
        e += "";
        break;
      case 32:
        e += "";
        break;
      default:
        e += String.fromCharCode(n);
    }
  }
  return e;
}
function Kbe(r, e) {
  const t = ri.get(e);
  if (t)
    return t;
  const i = r.encodeLanguageId(e);
  return {
    getInitialState: () => zf,
    tokenize: (n, s, o) => g1(e, o),
    tokenizeEncoded: (n, s, o) => S0(i, o)
  };
}
class gD extends P {
  constructor(e, t) {
    super(), this.allowEditorOverflow = !0, this._editor = e, this._languageService = t, this._model = this._editor.getModel(), this._domNode = document.createElement("div"), this._domNode.className = "tokens-inspect-widget", this._tokenizationSupport = Kbe(this._languageService.languageIdCodec, this._model.getLanguageId()), this._compute(this._editor.getPosition()), this._register(this._editor.onDidChangeCursorPosition((i) => this._compute(this._editor.getPosition()))), this._editor.addContentWidget(this);
  }
  dispose() {
    this._editor.removeContentWidget(this), super.dispose();
  }
  getId() {
    return gD._ID;
  }
  _compute(e) {
    const t = this._getTokensAtLine(e.lineNumber);
    let i = 0;
    for (let l = t.tokens1.length - 1; l >= 0; l--) {
      const d = t.tokens1[l];
      if (e.column - 1 >= d.offset) {
        i = l;
        break;
      }
    }
    let n = 0;
    for (let l = t.tokens2.length >>> 1; l >= 0; l--)
      if (e.column - 1 >= t.tokens2[l << 1]) {
        n = l;
        break;
      }
    const s = this._model.getLineContent(e.lineNumber);
    let o = "";
    if (i < t.tokens1.length) {
      const l = t.tokens1[i].offset, d = i + 1 < t.tokens1.length ? t.tokens1[i + 1].offset : s.length;
      o = s.substring(l, d);
    }
    mn(this._domNode, X("h2.tm-token", void 0, $be(o), X("span.tm-token-length", void 0, `${o.length} ${o.length === 1 ? "char" : "chars"}`))), G(this._domNode, X("hr.tokens-inspect-separator", { style: "clear:both" }));
    const a = (n << 1) + 1 < t.tokens2.length ? this._decodeMetadata(t.tokens2[(n << 1) + 1]) : null;
    G(this._domNode, X("table.tm-metadata-table", void 0, X("tbody", void 0, X("tr", void 0, X("td.tm-metadata-key", void 0, "language"), X("td.tm-metadata-value", void 0, `${a ? a.languageId : "-?-"}`)), X("tr", void 0, X("td.tm-metadata-key", void 0, "token type"), X("td.tm-metadata-value", void 0, `${a ? this._tokenTypeToString(a.tokenType) : "-?-"}`)), X("tr", void 0, X("td.tm-metadata-key", void 0, "font style"), X("td.tm-metadata-value", void 0, `${a ? this._fontStyleToString(a.fontStyle) : "-?-"}`)), X("tr", void 0, X("td.tm-metadata-key", void 0, "foreground"), X("td.tm-metadata-value", void 0, `${a ? z.Format.CSS.formatHex(a.foreground) : "-?-"}`)), X("tr", void 0, X("td.tm-metadata-key", void 0, "background"), X("td.tm-metadata-value", void 0, `${a ? z.Format.CSS.formatHex(a.background) : "-?-"}`))))), G(this._domNode, X("hr.tokens-inspect-separator")), i < t.tokens1.length && G(this._domNode, X("span.tm-token-type", void 0, t.tokens1[i].type)), this._editor.layoutContentWidget(this);
  }
  _decodeMetadata(e) {
    const t = ri.getColorMap(), i = yn.getLanguageId(e), n = yn.getTokenType(e), s = yn.getFontStyle(e), o = yn.getForeground(e), a = yn.getBackground(e);
    return {
      languageId: this._languageService.languageIdCodec.decodeLanguageId(i),
      tokenType: n,
      fontStyle: s,
      foreground: t[o],
      background: t[a]
    };
  }
  _tokenTypeToString(e) {
    switch (e) {
      case 0:
        return "Other";
      case 1:
        return "Comment";
      case 2:
        return "String";
      case 3:
        return "RegEx";
      default:
        return "??";
    }
  }
  _fontStyleToString(e) {
    let t = "";
    return e & 1 && (t += "italic "), e & 2 && (t += "bold "), e & 4 && (t += "underline "), e & 8 && (t += "strikethrough "), t.length === 0 && (t = "---"), t;
  }
  _getTokensAtLine(e) {
    const t = this._getStateBeforeLine(e), i = this._tokenizationSupport.tokenize(this._model.getLineContent(e), !0, t), n = this._tokenizationSupport.tokenizeEncoded(this._model.getLineContent(e), !0, t);
    return {
      startState: t,
      tokens1: i.tokens,
      tokens2: n.tokens,
      endState: i.endState
    };
  }
  _getStateBeforeLine(e) {
    let t = this._tokenizationSupport.getInitialState();
    for (let i = 1; i < e; i++)
      t = this._tokenizationSupport.tokenize(this._model.getLineContent(i), !0, t).endState;
    return t;
  }
  getDomNode() {
    return this._domNode;
  }
  getPosition() {
    return {
      position: this._editor.getPosition(),
      preference: [
        2,
        1
        /* ContentWidgetPositionPreference.ABOVE */
      ]
    };
  }
}
gD._ID = "editor.contrib.inspectTokensWidget";
gt(
  yp.ID,
  yp,
  4
  /* EditorContributionInstantiation.Lazy */
);
Y(Ube);
var jbe = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, OB = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, Gm;
let Qy = Gm = class {
  constructor(e, t) {
    this.quickInputService = e, this.keybindingService = t, this.registry = si.as(og.Quickaccess);
  }
  provide(e) {
    const t = new q();
    return t.add(e.onDidAccept(() => {
      const [i] = e.selectedItems;
      i && this.quickInputService.quickAccess.show(i.prefix, { preserveValue: !0 });
    })), t.add(e.onDidChangeValue((i) => {
      const n = this.registry.getQuickAccessProvider(i.substr(Gm.PREFIX.length));
      n && n.prefix && n.prefix !== Gm.PREFIX && this.quickInputService.quickAccess.show(n.prefix, { preserveValue: !0 });
    })), e.items = this.getQuickAccessProviders().filter((i) => i.prefix !== Gm.PREFIX), t;
  }
  getQuickAccessProviders() {
    return this.registry.getQuickAccessProviders().sort((t, i) => t.prefix.localeCompare(i.prefix)).flatMap((t) => this.createPicks(t));
  }
  createPicks(e) {
    return e.helpEntries.map((t) => {
      const i = t.prefix || e.prefix, n = i || "";
      return {
        prefix: i,
        label: n,
        keybinding: t.commandId ? this.keybindingService.lookupKeybinding(t.commandId) : void 0,
        ariaLabel: p("helpPickAriaLabel", "{0}, {1}", n, t.description),
        description: t.description
      };
    });
  }
};
Qy.PREFIX = "?";
Qy = Gm = jbe([
  OB(0, $o),
  OB(1, _t)
], Qy);
si.as(og.Quickaccess).registerQuickAccessProvider({
  ctor: Qy,
  prefix: "",
  helpEntries: [{ description: HI.helpQuickAccessActionLabel }]
});
class V$ {
  constructor(e) {
    this.options = e, this.rangeHighlightDecorationId = void 0;
  }
  //#region Provider methods
  provide(e, t, i) {
    var n;
    const s = new q();
    e.canAcceptInBackground = !!(!((n = this.options) === null || n === void 0) && n.canAcceptInBackground), e.matchOnLabel = e.matchOnDescription = e.matchOnDetail = e.sortByLabel = !1;
    const o = s.add(new Yi());
    return o.value = this.doProvide(e, t, i), s.add(this.onDidActiveTextEditorControlChange(() => {
      o.value = void 0, o.value = this.doProvide(e, t);
    })), s;
  }
  doProvide(e, t, i) {
    var n;
    const s = new q(), o = this.activeTextEditorControl;
    if (o && this.canProvideWithTextEditor(o)) {
      const a = { editor: o }, l = $3(o);
      if (l) {
        let d = (n = o.saveViewState()) !== null && n !== void 0 ? n : void 0;
        s.add(l.onDidChangeCursorPosition(() => {
          var c;
          d = (c = o.saveViewState()) !== null && c !== void 0 ? c : void 0;
        })), a.restoreViewState = () => {
          d && o === this.activeTextEditorControl && o.restoreViewState(d);
        }, s.add(Ff(t.onCancellationRequested)(() => {
          var c;
          return (c = a.restoreViewState) === null || c === void 0 ? void 0 : c.call(a);
        }));
      }
      s.add(Se(() => this.clearDecorations(o))), s.add(this.provideWithTextEditor(a, e, t, i));
    } else
      s.add(this.provideWithoutTextEditor(e, t));
    return s;
  }
  /**
   * Subclasses to implement if they can operate on the text editor.
   */
  canProvideWithTextEditor(e) {
    return !0;
  }
  gotoLocation({ editor: e }, t) {
    e.setSelection(
      t.range,
      "code.jump"
      /* TextEditorSelectionSource.JUMP */
    ), e.revealRangeInCenter(
      t.range,
      0
      /* ScrollType.Smooth */
    ), t.preserveFocus || e.focus();
    const i = e.getModel();
    i && "getLineContent" in i && el(`${i.getLineContent(t.range.startLineNumber)}`);
  }
  getModel(e) {
    var t;
    return YM(e) ? (t = e.getModel()) === null || t === void 0 ? void 0 : t.modified : e.getModel();
  }
  addDecorations(e, t) {
    e.changeDecorations((i) => {
      const n = [];
      this.rangeHighlightDecorationId && (n.push(this.rangeHighlightDecorationId.overviewRulerDecorationId), n.push(this.rangeHighlightDecorationId.rangeHighlightId), this.rangeHighlightDecorationId = void 0);
      const s = [
        // highlight the entire line on the range
        {
          range: t,
          options: {
            description: "quick-access-range-highlight",
            className: "rangeHighlight",
            isWholeLine: !0
          }
        },
        // also add overview ruler highlight
        {
          range: t,
          options: {
            description: "quick-access-range-highlight-overview",
            overviewRuler: {
              color: ai(GV),
              position: _r.Full
            }
          }
        }
      ], [o, a] = i.deltaDecorations(n, s);
      this.rangeHighlightDecorationId = { rangeHighlightId: o, overviewRulerDecorationId: a };
    });
  }
  clearDecorations(e) {
    const t = this.rangeHighlightDecorationId;
    t && (e.changeDecorations((i) => {
      i.deltaDecorations([
        t.overviewRulerDecorationId,
        t.rangeHighlightId
      ], []);
    }), this.rangeHighlightDecorationId = void 0);
  }
}
class fD extends V$ {
  constructor() {
    super({ canAcceptInBackground: !0 });
  }
  provideWithoutTextEditor(e) {
    const t = p("cannotRunGotoLine", "Open a text editor first to go to a line.");
    return e.items = [{ label: t }], e.ariaLabel = t, P.None;
  }
  provideWithTextEditor(e, t, i) {
    const n = e.editor, s = new q();
    s.add(t.onDidAccept((l) => {
      const [d] = t.selectedItems;
      if (d) {
        if (!this.isValidLineNumber(n, d.lineNumber))
          return;
        this.gotoLocation(e, { range: this.toRange(d.lineNumber, d.column), keyMods: t.keyMods, preserveFocus: l.inBackground }), l.inBackground || t.hide();
      }
    }));
    const o = () => {
      const l = this.parsePosition(n, t.value.trim().substr(fD.PREFIX.length)), d = this.getPickLabel(n, l.lineNumber, l.column);
      if (t.items = [{
        lineNumber: l.lineNumber,
        column: l.column,
        label: d
      }], t.ariaLabel = d, !this.isValidLineNumber(n, l.lineNumber)) {
        this.clearDecorations(n);
        return;
      }
      const c = this.toRange(l.lineNumber, l.column);
      n.revealRangeInCenter(
        c,
        0
        /* ScrollType.Smooth */
      ), this.addDecorations(n, c);
    };
    o(), s.add(t.onDidChangeValue(() => o()));
    const a = $3(n);
    return a && a.getOptions().get(
      68
      /* EditorOption.lineNumbers */
    ).renderType === 2 && (a.updateOptions({ lineNumbers: "on" }), s.add(Se(() => a.updateOptions({ lineNumbers: "relative" })))), s;
  }
  toRange(e = 1, t = 1) {
    return {
      startLineNumber: e,
      startColumn: t,
      endLineNumber: e,
      endColumn: t
    };
  }
  parsePosition(e, t) {
    const i = t.split(/,|:|#/).map((s) => parseInt(s, 10)).filter((s) => !isNaN(s)), n = this.lineCount(e) + 1;
    return {
      lineNumber: i[0] > 0 ? i[0] : n + i[0],
      column: i[1]
    };
  }
  getPickLabel(e, t, i) {
    if (this.isValidLineNumber(e, t))
      return this.isValidColumn(e, t, i) ? p("gotoLineColumnLabel", "Go to line {0} and character {1}.", t, i) : p("gotoLineLabel", "Go to line {0}.", t);
    const n = e.getPosition() || { lineNumber: 1, column: 1 }, s = this.lineCount(e);
    return s > 1 ? p("gotoLineLabelEmptyWithLimit", "Current Line: {0}, Character: {1}. Type a line number between 1 and {2} to navigate to.", n.lineNumber, n.column, s) : p("gotoLineLabelEmpty", "Current Line: {0}, Character: {1}. Type a line number to navigate to.", n.lineNumber, n.column);
  }
  isValidLineNumber(e, t) {
    return !t || typeof t != "number" ? !1 : t > 0 && t <= this.lineCount(e);
  }
  isValidColumn(e, t, i) {
    if (!i || typeof i != "number")
      return !1;
    const n = this.getModel(e);
    if (!n)
      return !1;
    const s = { lineNumber: t, column: i };
    return n.validatePosition(s).equals(s);
  }
  lineCount(e) {
    var t, i;
    return (i = (t = this.getModel(e)) === null || t === void 0 ? void 0 : t.getLineCount()) !== null && i !== void 0 ? i : 0;
  }
}
fD.PREFIX = ":";
var qbe = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Gbe = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
let tb = class extends fD {
  constructor(e) {
    super(), this.editorService = e, this.onDidActiveTextEditorControlChange = ne.None;
  }
  get activeTextEditorControl() {
    var e;
    return (e = this.editorService.getFocusedCodeEditor()) !== null && e !== void 0 ? e : void 0;
  }
};
tb = qbe([
  Gbe(0, ht)
], tb);
let jR = class z$ extends ae {
  constructor() {
    super({
      id: z$.ID,
      label: US.gotoLineActionLabel,
      alias: "Go to Line/Column...",
      precondition: void 0,
      kbOpts: {
        kbExpr: x.focus,
        primary: 2085,
        mac: {
          primary: 293
          /* KeyCode.KeyG */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(e) {
    e.get($o).quickAccess.show(tb.PREFIX);
  }
};
jR.ID = "editor.action.gotoLine";
Y(jR);
si.as(og.Quickaccess).registerQuickAccessProvider({
  ctor: tb,
  prefix: tb.PREFIX,
  helpEntries: [{ description: US.gotoLineActionLabel, commandId: jR.ID }]
});
const U$ = [void 0, []];
function ux(r, e, t = 0, i = 0) {
  const n = e;
  return n.values && n.values.length > 1 ? Zbe(r, n.values, t, i) : $$(r, e, t, i);
}
function Zbe(r, e, t, i) {
  let n = 0;
  const s = [];
  for (const o of e) {
    const [a, l] = $$(r, o, t, i);
    if (typeof a != "number")
      return U$;
    n += a, s.push(...l);
  }
  return [n, Ybe(s)];
}
function $$(r, e, t, i) {
  const n = Du(e.original, e.originalLowercase, t, r, r.toLowerCase(), i, { firstMatchCanBeWeak: !0, boostFullMatch: !0 });
  return n ? [n[0], Sb(n)] : U$;
}
function Ybe(r) {
  const e = r.sort((n, s) => n.start - s.start), t = [];
  let i;
  for (const n of e)
    !i || !Qbe(i, n) ? (i = n, t.push(n)) : (i.start = Math.min(i.start, n.start), i.end = Math.max(i.end, n.end));
  return t;
}
function Qbe(r, e) {
  return !(r.end < e.start || e.end < r.start);
}
function FB(r) {
  return r.startsWith('"') && r.endsWith('"');
}
const K$ = " ";
function ON(r) {
  typeof r != "string" && (r = "");
  const e = r.toLowerCase(), { pathNormalized: t, normalized: i, normalizedLowercase: n } = WB(r), s = t.indexOf($r) >= 0, o = FB(r);
  let a;
  const l = r.split(K$);
  if (l.length > 1)
    for (const d of l) {
      const c = FB(d), { pathNormalized: h, normalized: u, normalizedLowercase: g } = WB(d);
      u && (a || (a = []), a.push({
        original: d,
        originalLowercase: d.toLowerCase(),
        pathNormalized: h,
        normalized: u,
        normalizedLowercase: g,
        expectContiguousMatch: c
      }));
    }
  return { original: r, originalLowercase: e, pathNormalized: t, normalized: i, normalizedLowercase: n, values: a, containsPathSeparator: s, expectContiguousMatch: o };
}
function WB(r) {
  let e;
  Ks ? e = r.replace(/\//g, $r) : e = r.replace(/\\/g, $r);
  const t = tj(e).replace(/\s|"/g, "");
  return {
    pathNormalized: e,
    normalized: t,
    normalizedLowercase: t.toLowerCase()
  };
}
function BB(r) {
  return Array.isArray(r) ? ON(r.map((e) => e.original).join(K$)) : ON(r.original);
}
var Xbe = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, HB = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, Pf;
let Qa = Pf = class extends V$ {
  constructor(e, t, i = /* @__PURE__ */ Object.create(null)) {
    super(i), this._languageFeaturesService = e, this._outlineModelService = t, this.options = i, this.options.canAcceptInBackground = !0;
  }
  provideWithoutTextEditor(e) {
    return this.provideLabelPick(e, p("cannotRunGotoSymbolWithoutEditor", "To go to a symbol, first open a text editor with symbol information.")), P.None;
  }
  provideWithTextEditor(e, t, i, n) {
    const s = e.editor, o = this.getModel(s);
    return o ? this._languageFeaturesService.documentSymbolProvider.has(o) ? this.doProvideWithEditorSymbols(e, o, t, i, n) : this.doProvideWithoutEditorSymbols(e, o, t, i) : P.None;
  }
  doProvideWithoutEditorSymbols(e, t, i, n) {
    const s = new q();
    return this.provideLabelPick(i, p("cannotRunGotoSymbolWithoutSymbolProvider", "The active text editor does not provide symbol information.")), (async () => !await this.waitForLanguageSymbolRegistry(t, s) || n.isCancellationRequested || s.add(this.doProvideWithEditorSymbols(e, t, i, n)))(), s;
  }
  provideLabelPick(e, t) {
    e.items = [{
      label: t,
      index: 0,
      kind: 14
      /* SymbolKind.String */
    }], e.ariaLabel = t;
  }
  async waitForLanguageSymbolRegistry(e, t) {
    if (this._languageFeaturesService.documentSymbolProvider.has(e))
      return !0;
    const i = new ab(), n = t.add(this._languageFeaturesService.documentSymbolProvider.onDidChange(() => {
      this._languageFeaturesService.documentSymbolProvider.has(e) && (n.dispose(), i.complete(!0));
    }));
    return t.add(Se(() => i.complete(!1))), i.p;
  }
  doProvideWithEditorSymbols(e, t, i, n, s) {
    var o;
    const a = e.editor, l = new q();
    l.add(i.onDidAccept((u) => {
      var g;
      const [f] = i.selectedItems;
      f && f.range && (this.gotoLocation(e, { range: f.range.selection, keyMods: i.keyMods, preserveFocus: u.inBackground }), (g = s == null ? void 0 : s.handleAccept) === null || g === void 0 || g.call(s, f), u.inBackground || i.hide());
    })), l.add(i.onDidTriggerItemButton(({ item: u }) => {
      u && u.range && (this.gotoLocation(e, { range: u.range.selection, keyMods: i.keyMods, forceSideBySide: !0 }), i.hide());
    }));
    const d = this.getDocumentSymbols(t, n);
    let c;
    const h = async (u) => {
      c == null || c.dispose(!0), i.busy = !1, c = new mi(n), i.busy = !0;
      try {
        const g = ON(i.value.substr(Pf.PREFIX.length).trim()), f = await this.doGetSymbolPicks(d, g, void 0, c.token, t);
        if (n.isCancellationRequested)
          return;
        if (f.length > 0) {
          if (i.items = f, u && g.original.length === 0) {
            const m = N_(f, (_) => !!(_.type !== "separator" && _.range && L.containsPosition(_.range.decoration, u)));
            m && (i.activeItems = [m]);
          }
        } else
          g.original.length > 0 ? this.provideLabelPick(i, p("noMatchingSymbolResults", "No matching editor symbols")) : this.provideLabelPick(i, p("noSymbolResults", "No editor symbols"));
      } finally {
        n.isCancellationRequested || (i.busy = !1);
      }
    };
    return l.add(i.onDidChangeValue(() => h(void 0))), h((o = a.getSelection()) === null || o === void 0 ? void 0 : o.getPosition()), l.add(i.onDidChangeActive(() => {
      const [u] = i.activeItems;
      u && u.range && (a.revealRangeInCenter(
        u.range.selection,
        0
        /* ScrollType.Smooth */
      ), this.addDecorations(a, u.range.decoration));
    })), l;
  }
  async doGetSymbolPicks(e, t, i, n, s) {
    var o, a;
    const l = await e;
    if (n.isCancellationRequested)
      return [];
    const d = t.original.indexOf(Pf.SCOPE_PREFIX) === 0, c = d ? 1 : 0;
    let h, u;
    t.values && t.values.length > 1 ? (h = BB(t.values[0]), u = BB(t.values.slice(1))) : h = t;
    let g;
    const f = (a = (o = this.options) === null || o === void 0 ? void 0 : o.openSideBySideDirection) === null || a === void 0 ? void 0 : a.call(o);
    f && (g = [{
      iconClass: f === "right" ? Le.asClassName(me.splitHorizontal) : Le.asClassName(me.splitVertical),
      tooltip: f === "right" ? p("openToSide", "Open to the Side") : p("openToBottom", "Open to the Bottom")
    }]);
    const m = [];
    for (let b = 0; b < l.length; b++) {
      const C = l[b], w = ij(C.name), S = `$(${fH.toIcon(C.kind).id}) ${w}`, y = S.length - w.length;
      let k = C.containerName;
      i != null && i.extraContainerLabel && (k ? k = `${i.extraContainerLabel}  ${k}` : k = i.extraContainerLabel);
      let E, N, F, V;
      if (t.original.length > c) {
        let H = !1;
        if (h !== t && ([E, N] = ux(S, {
          ...t,
          values: void 0
          /* disable multi-query support */
        }, c, y), typeof E == "number" && (H = !0)), typeof E != "number" && ([E, N] = ux(S, h, c, y), typeof E != "number"))
          continue;
        if (!H && u) {
          if (k && u.original.length > 0 && ([F, V] = ux(k, u)), typeof F != "number")
            continue;
          typeof E == "number" && (E += F);
        }
      }
      const Z = C.tags && C.tags.indexOf(
        1
        /* SymbolTag.Deprecated */
      ) >= 0;
      m.push({
        index: b,
        kind: C.kind,
        score: E,
        label: S,
        ariaLabel: nj(C.name, C.kind),
        description: k,
        highlights: Z ? void 0 : {
          label: N,
          description: V
        },
        range: {
          selection: L.collapseToStart(C.selectionRange),
          decoration: C.range
        },
        uri: s.uri,
        symbolName: w,
        strikethrough: Z,
        buttons: g
      });
    }
    const _ = m.sort((b, C) => d ? this.compareByKindAndScore(b, C) : this.compareByScore(b, C));
    let v = [];
    if (d) {
      let S = function() {
        C && typeof b == "number" && w > 0 && (C.label = vu(fx[b] || gx, w));
      }, b, C, w = 0;
      for (const y of _)
        b !== y.kind ? (S(), b = y.kind, w = 1, C = { type: "separator" }, v.push(C)) : w++, v.push(y);
      S();
    } else _.length > 0 && (v = [
      { label: p("symbols", "symbols ({0})", m.length), type: "separator" },
      ..._
    ]);
    return v;
  }
  compareByScore(e, t) {
    if (typeof e.score != "number" && typeof t.score == "number")
      return 1;
    if (typeof e.score == "number" && typeof t.score != "number")
      return -1;
    if (typeof e.score == "number" && typeof t.score == "number") {
      if (e.score > t.score)
        return -1;
      if (e.score < t.score)
        return 1;
    }
    return e.index < t.index ? -1 : e.index > t.index ? 1 : 0;
  }
  compareByKindAndScore(e, t) {
    const i = fx[e.kind] || gx, n = fx[t.kind] || gx, s = i.localeCompare(n);
    return s === 0 ? this.compareByScore(e, t) : s;
  }
  async getDocumentSymbols(e, t) {
    const i = await this._outlineModelService.getOrCreate(e, t);
    return t.isCancellationRequested ? [] : i.asListOfDocumentSymbols();
  }
};
Qa.PREFIX = "@";
Qa.SCOPE_PREFIX = ":";
Qa.PREFIX_BY_CATEGORY = `${Pf.PREFIX}${Pf.SCOPE_PREFIX}`;
Qa = Pf = Xbe([
  HB(0, he),
  HB(1, Kb)
], Qa);
const gx = p("property", "properties ({0})"), fx = {
  5: p("method", "methods ({0})"),
  11: p("function", "functions ({0})"),
  8: p("_constructor", "constructors ({0})"),
  12: p("variable", "variables ({0})"),
  4: p("class", "classes ({0})"),
  22: p("struct", "structs ({0})"),
  23: p("event", "events ({0})"),
  24: p("operator", "operators ({0})"),
  10: p("interface", "interfaces ({0})"),
  2: p("namespace", "namespaces ({0})"),
  3: p("package", "packages ({0})"),
  25: p("typeParameter", "type parameters ({0})"),
  1: p("modules", "modules ({0})"),
  6: p("property", "properties ({0})"),
  9: p("enum", "enumerations ({0})"),
  21: p("enumMember", "enumeration members ({0})"),
  14: p("string", "strings ({0})"),
  0: p("file", "files ({0})"),
  17: p("array", "arrays ({0})"),
  15: p("number", "numbers ({0})"),
  16: p("boolean", "booleans ({0})"),
  18: p("object", "objects ({0})"),
  19: p("key", "keys ({0})"),
  7: p("field", "fields ({0})"),
  13: p("constant", "constants ({0})")
};
var Jbe = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, px = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
let FN = class extends Qa {
  constructor(e, t, i) {
    super(t, i), this.editorService = e, this.onDidActiveTextEditorControlChange = ne.None;
  }
  get activeTextEditorControl() {
    var e;
    return (e = this.editorService.getFocusedCodeEditor()) !== null && e !== void 0 ? e : void 0;
  }
};
FN = Jbe([
  px(0, ht),
  px(1, he),
  px(2, Kb)
], FN);
class Gb extends ae {
  constructor() {
    super({
      id: Gb.ID,
      label: ov.quickOutlineActionLabel,
      alias: "Go to Symbol...",
      precondition: x.hasDocumentSymbolProvider,
      kbOpts: {
        kbExpr: x.focus,
        primary: 3117,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      contextMenuOpts: {
        group: "navigation",
        order: 3
      }
    });
  }
  run(e) {
    e.get($o).quickAccess.show(Qa.PREFIX, { itemActivation: Tr.NONE });
  }
}
Gb.ID = "editor.action.quickOutline";
Y(Gb);
si.as(og.Quickaccess).registerQuickAccessProvider({
  ctor: FN,
  prefix: Qa.PREFIX,
  helpEntries: [
    { description: ov.quickOutlineActionLabel, prefix: Qa.PREFIX, commandId: Gb.ID },
    { description: ov.quickOutlineByCategoryActionLabel, prefix: Qa.PREFIX_BY_CATEGORY }
  ]
});
function eCe(r) {
  var e;
  const t = /* @__PURE__ */ new Map();
  for (const i of r)
    t.set(i, ((e = t.get(i)) !== null && e !== void 0 ? e : 0) + 1);
  return t;
}
class E_ {
  constructor() {
    this.chunkCount = 0, this.chunkOccurrences = /* @__PURE__ */ new Map(), this.documents = /* @__PURE__ */ new Map();
  }
  calculateScores(e, t) {
    const i = this.computeEmbedding(e), n = /* @__PURE__ */ new Map(), s = [];
    for (const [o, a] of this.documents) {
      if (t.isCancellationRequested)
        return [];
      for (const l of a.chunks) {
        const d = this.computeSimilarityScore(l, i, n);
        d > 0 && s.push({ key: o, score: d });
      }
    }
    return s;
  }
  /**
   * Count how many times each term (word) appears in a string.
   */
  static termFrequencies(e) {
    return eCe(E_.splitTerms(e));
  }
  /**
   * Break a string into terms (words).
   */
  static *splitTerms(e) {
    const t = (i) => i.toLowerCase();
    for (const [i] of e.matchAll(new RegExp("\\b\\p{Letter}[\\p{Letter}\\d]{2,}\\b", "gu"))) {
      yield t(i);
      const n = i.replace(/([a-z])([A-Z])/g, "$1 $2").split(/\s+/g);
      if (n.length > 1)
        for (const s of n)
          s.length > 2 && new RegExp("\\p{Letter}{3,}", "gu").test(s) && (yield t(s));
    }
  }
  updateDocuments(e) {
    var t;
    for (const { key: i } of e)
      this.deleteDocument(i);
    for (const i of e) {
      const n = [];
      for (const s of i.textChunks) {
        const o = E_.termFrequencies(s);
        for (const a of o.keys())
          this.chunkOccurrences.set(a, ((t = this.chunkOccurrences.get(a)) !== null && t !== void 0 ? t : 0) + 1);
        n.push({ text: s, tf: o });
      }
      this.chunkCount += n.length, this.documents.set(i.key, { chunks: n });
    }
    return this;
  }
  deleteDocument(e) {
    const t = this.documents.get(e);
    if (t) {
      this.documents.delete(e), this.chunkCount -= t.chunks.length;
      for (const i of t.chunks)
        for (const n of i.tf.keys()) {
          const s = this.chunkOccurrences.get(n);
          if (typeof s == "number") {
            const o = s - 1;
            o <= 0 ? this.chunkOccurrences.delete(n) : this.chunkOccurrences.set(n, o);
          }
        }
    }
  }
  computeSimilarityScore(e, t, i) {
    let n = 0;
    for (const [s, o] of Object.entries(t)) {
      const a = e.tf.get(s);
      if (!a)
        continue;
      let l = i.get(s);
      typeof l != "number" && (l = this.computeIdf(s), i.set(s, l));
      const d = a * l;
      n += d * o;
    }
    return n;
  }
  computeEmbedding(e) {
    const t = E_.termFrequencies(e);
    return this.computeTfidf(t);
  }
  computeIdf(e) {
    var t;
    const i = (t = this.chunkOccurrences.get(e)) !== null && t !== void 0 ? t : 0;
    return i > 0 ? Math.log((this.chunkCount + 1) / i) : 0;
  }
  computeTfidf(e) {
    const t = /* @__PURE__ */ Object.create(null);
    for (const [i, n] of e) {
      const s = this.computeIdf(i);
      s > 0 && (t[i] = n * s);
    }
    return t;
  }
}
function tCe(r) {
  var e, t;
  const i = r.slice(0);
  i.sort((s, o) => o.score - s.score);
  const n = (t = (e = i[0]) === null || e === void 0 ? void 0 : e.score) !== null && t !== void 0 ? t : 0;
  if (n > 0)
    for (const s of i)
      s.score /= n;
  return i;
}
var df;
(function(r) {
  r[r.NO_ACTION = 0] = "NO_ACTION", r[r.CLOSE_PICKER = 1] = "CLOSE_PICKER", r[r.REFRESH_PICKER = 2] = "REFRESH_PICKER", r[r.REMOVE_ITEM = 3] = "REMOVE_ITEM";
})(df || (df = {}));
function mx(r) {
  const e = r;
  return Array.isArray(e.items);
}
function VB(r) {
  const e = r;
  return !!e.picks && e.additionalPicks instanceof Promise;
}
class iCe extends P {
  constructor(e, t) {
    super(), this.prefix = e, this.options = t;
  }
  provide(e, t, i) {
    var n;
    const s = new q();
    e.canAcceptInBackground = !!(!((n = this.options) === null || n === void 0) && n.canAcceptInBackground), e.matchOnLabel = e.matchOnDescription = e.matchOnDetail = e.sortByLabel = !1;
    let o;
    const a = s.add(new Yi()), l = async () => {
      var c;
      const h = a.value = new q();
      o == null || o.dispose(!0), e.busy = !1, o = new mi(t);
      const u = o.token;
      let g = e.value.substring(this.prefix.length);
      !((c = this.options) === null || c === void 0) && c.shouldSkipTrimPickFilter || (g = g.trim());
      const f = this._getPicks(g, h, u, i), m = (v, b) => {
        var C;
        let w, S;
        if (mx(v) ? (w = v.items, S = v.active) : w = v, w.length === 0) {
          if (b)
            return !1;
          (g.length > 0 || e.hideInput) && (!((C = this.options) === null || C === void 0) && C.noResultsPick) && (aS(this.options.noResultsPick) ? w = [this.options.noResultsPick(g)] : w = [this.options.noResultsPick]);
        }
        return e.items = w, S && (e.activeItems = [S]), !0;
      }, _ = async (v) => {
        let b = !1, C = !1;
        await Promise.all([
          // Fast Picks: if `mergeDelay` is configured, in order to reduce
          // amount of flicker, we race against the slow picks over some delay
          // and then set the fast picks.
          // If the slow picks are faster, we reduce the flicker by only
          // setting the items once.
          (async () => {
            typeof v.mergeDelay == "number" && (await cd(v.mergeDelay), u.isCancellationRequested) || C || (b = m(
              v.picks,
              !0
              /* skip over empty to reduce flicker */
            ));
          })(),
          // Slow Picks: we await the slow picks and then set them at
          // once together with the fast picks, but only if we actually
          // have additional results.
          (async () => {
            e.busy = !0;
            try {
              const w = await v.additionalPicks;
              if (u.isCancellationRequested)
                return;
              let S, y;
              mx(v.picks) ? (S = v.picks.items, y = v.picks.active) : S = v.picks;
              let k, E;
              if (mx(w) ? (k = w.items, E = w.active) : k = w, k.length > 0 || !b) {
                let N;
                if (!y && !E) {
                  const F = e.activeItems[0];
                  F && S.indexOf(F) !== -1 && (N = F);
                }
                m({
                  items: [...S, ...k],
                  active: y || E || N
                });
              }
            } finally {
              u.isCancellationRequested || (e.busy = !1), C = !0;
            }
          })()
        ]);
      };
      if (f !== null) if (VB(f))
        await _(f);
      else if (!(f instanceof Promise))
        m(f);
      else {
        e.busy = !0;
        try {
          const v = await f;
          if (u.isCancellationRequested)
            return;
          VB(v) ? await _(v) : m(v);
        } finally {
          u.isCancellationRequested || (e.busy = !1);
        }
      }
    };
    s.add(e.onDidChangeValue(() => l())), l(), s.add(e.onDidAccept((c) => {
      var h;
      if (i != null && i.handleAccept) {
        c.inBackground || e.hide(), (h = i.handleAccept) === null || h === void 0 || h.call(i, e.activeItems[0]);
        return;
      }
      const [u] = e.selectedItems;
      typeof (u == null ? void 0 : u.accept) == "function" && (c.inBackground || e.hide(), u.accept(e.keyMods, c));
    }));
    const d = async (c, h) => {
      var u, g;
      if (typeof h.trigger != "function")
        return;
      const f = (g = (u = h.buttons) === null || u === void 0 ? void 0 : u.indexOf(c)) !== null && g !== void 0 ? g : -1;
      if (f >= 0) {
        const m = h.trigger(f, e.keyMods), _ = typeof m == "number" ? m : await m;
        if (t.isCancellationRequested)
          return;
        switch (_) {
          case df.NO_ACTION:
            break;
          case df.CLOSE_PICKER:
            e.hide();
            break;
          case df.REFRESH_PICKER:
            l();
            break;
          case df.REMOVE_ITEM: {
            const v = e.items.indexOf(h);
            if (v !== -1) {
              const b = e.items.slice(), C = b.splice(v, 1), w = e.activeItems.filter((y) => y !== C[0]), S = e.keepScrollPosition;
              e.keepScrollPosition = !0, e.items = b, w && (e.activeItems = w), e.keepScrollPosition = S;
            }
            break;
          }
        }
      }
    };
    return s.add(e.onDidTriggerItemButton(({ button: c, item: h }) => d(c, h))), s.add(e.onDidTriggerSeparatorButton(({ button: c, separator: h }) => d(c, h))), s;
  }
}
var j$ = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Qd = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
}, Ah, Ai;
let qu = Ah = class extends iCe {
  constructor(e, t, i, n, s, o) {
    super(Ah.PREFIX, e), this.instantiationService = t, this.keybindingService = i, this.commandService = n, this.telemetryService = s, this.dialogService = o, this.commandsHistory = this._register(this.instantiationService.createInstance(eh)), this.options = e;
  }
  async _getPicks(e, t, i, n) {
    var s, o, a, l;
    const d = await this.getCommandPicks(i);
    if (i.isCancellationRequested)
      return [];
    const c = Ff(() => {
      const v = new E_();
      v.updateDocuments(d.map((C) => ({
        key: C.commandId,
        textChunks: [this.getTfIdfChunk(C)]
      })));
      const b = v.calculateScores(e, i);
      return tCe(b).filter((C) => C.score > Ah.TFIDF_THRESHOLD).slice(0, Ah.TFIDF_MAX_RESULTS);
    }), h = [];
    for (const v of d) {
      const b = (s = Ah.WORD_FILTER(e, v.label)) !== null && s !== void 0 ? s : void 0, C = v.commandAlias && (o = Ah.WORD_FILTER(e, v.commandAlias)) !== null && o !== void 0 ? o : void 0;
      if (b || C)
        v.highlights = {
          label: b,
          detail: this.options.showAlias ? C : void 0
        }, h.push(v);
      else if (e === v.commandId)
        h.push(v);
      else if (e.length >= 3) {
        const w = c();
        if (i.isCancellationRequested)
          return [];
        const S = w.find((y) => y.key === v.commandId);
        S && (v.tfIdfScore = S.score, h.push(v));
      }
    }
    const u = /* @__PURE__ */ new Map();
    for (const v of h) {
      const b = u.get(v.label);
      b ? (v.description = v.commandId, b.description = b.commandId) : u.set(v.label, v);
    }
    h.sort((v, b) => {
      if (v.tfIdfScore && b.tfIdfScore)
        return v.tfIdfScore === b.tfIdfScore ? v.label.localeCompare(b.label) : b.tfIdfScore - v.tfIdfScore;
      if (v.tfIdfScore)
        return 1;
      if (b.tfIdfScore)
        return -1;
      const C = this.commandsHistory.peek(v.commandId), w = this.commandsHistory.peek(b.commandId);
      if (C && w)
        return C > w ? -1 : 1;
      if (C)
        return -1;
      if (w)
        return 1;
      if (this.options.suggestedCommandIds) {
        const S = this.options.suggestedCommandIds.has(v.commandId), y = this.options.suggestedCommandIds.has(b.commandId);
        if (S && y)
          return 0;
        if (S)
          return -1;
        if (y)
          return 1;
      }
      return v.label.localeCompare(b.label);
    });
    const g = [];
    let f = !1, m = !0, _ = !!this.options.suggestedCommandIds;
    for (let v = 0; v < h.length; v++) {
      const b = h[v];
      v === 0 && this.commandsHistory.peek(b.commandId) && (g.push({ type: "separator", label: p("recentlyUsed", "recently used") }), f = !0), m && b.tfIdfScore !== void 0 && (g.push({ type: "separator", label: p("suggested", "similar commands") }), m = !1), _ && b.tfIdfScore === void 0 && !this.commandsHistory.peek(b.commandId) && (!((a = this.options.suggestedCommandIds) === null || a === void 0) && a.has(b.commandId)) && (g.push({ type: "separator", label: p("commonlyUsed", "commonly used") }), f = !0, _ = !1), f && b.tfIdfScore === void 0 && !this.commandsHistory.peek(b.commandId) && !(!((l = this.options.suggestedCommandIds) === null || l === void 0) && l.has(b.commandId)) && (g.push({ type: "separator", label: p("morecCommands", "other commands") }), f = !1), g.push(this.toCommandPick(b, n));
    }
    return this.hasAdditionalCommandPicks(e, i) ? {
      picks: g,
      additionalPicks: (async () => {
        var v;
        const b = await this.getAdditionalCommandPicks(d, h, e, i);
        if (i.isCancellationRequested)
          return [];
        const C = b.map((w) => this.toCommandPick(w, n));
        return m && ((v = C[0]) === null || v === void 0 ? void 0 : v.type) !== "separator" && C.unshift({ type: "separator", label: p("suggested", "similar commands") }), C;
      })()
    } : g;
  }
  toCommandPick(e, t) {
    if (e.type === "separator")
      return e;
    const i = this.keybindingService.lookupKeybinding(e.commandId), n = i ? p("commandPickAriaLabelWithKeybinding", "{0}, {1}", e.label, i.getAriaLabel()) : e.label;
    return {
      ...e,
      ariaLabel: n,
      detail: this.options.showAlias && e.commandAlias !== e.label ? e.commandAlias : void 0,
      keybinding: i,
      accept: async () => {
        var s, o;
        this.commandsHistory.push(e.commandId), this.telemetryService.publicLog2("workbenchActionExecuted", {
          id: e.commandId,
          from: (s = t == null ? void 0 : t.from) !== null && s !== void 0 ? s : "quick open"
        });
        try {
          !((o = e.args) === null || o === void 0) && o.length ? await this.commandService.executeCommand(e.commandId, ...e.args) : await this.commandService.executeCommand(e.commandId);
        } catch (a) {
          cl(a) || this.dialogService.error(p("canNotRun", "Command '{0}' resulted in an error", e.label), Ey(a));
        }
      }
    };
  }
  // TF-IDF string to be indexed
  getTfIdfChunk({ label: e, commandAlias: t, commandDescription: i }) {
    let n = e;
    return t && t !== e && (n += ` - ${t}`), i && i.value !== e && (n += ` - ${i.value === i.original ? i.value : `${i.value} (${i.original})`}`), n;
  }
};
qu.PREFIX = ">";
qu.TFIDF_THRESHOLD = 0.5;
qu.TFIDF_MAX_RESULTS = 5;
qu.WORD_FILTER = sM(iv, nee, tz);
qu = Ah = j$([
  Qd(1, be),
  Qd(2, _t),
  Qd(3, $t),
  Qd(4, kn),
  Qd(5, wb)
], qu);
let eh = Ai = class extends P {
  constructor(e, t, i) {
    super(), this.storageService = e, this.configurationService = t, this.logService = i, this.configuredCommandsHistoryLength = 0, this.updateConfiguration(), this.load(), this.registerListeners();
  }
  registerListeners() {
    this._register(this.configurationService.onDidChangeConfiguration((e) => this.updateConfiguration(e))), this._register(this.storageService.onWillSaveState((e) => {
      e.reason === uv.SHUTDOWN && this.saveState();
    }));
  }
  updateConfiguration(e) {
    e && !e.affectsConfiguration("workbench.commandPalette.history") || (this.configuredCommandsHistoryLength = Ai.getConfiguredCommandHistoryLength(this.configurationService), Ai.cache && Ai.cache.limit !== this.configuredCommandsHistoryLength && (Ai.cache.limit = this.configuredCommandsHistoryLength, Ai.hasChanges = !0));
  }
  load() {
    const e = this.storageService.get(
      Ai.PREF_KEY_CACHE,
      0
      /* StorageScope.PROFILE */
    );
    let t;
    if (e)
      try {
        t = JSON.parse(e);
      } catch (n) {
        this.logService.error(`[CommandsHistory] invalid data: ${n}`);
      }
    const i = Ai.cache = new Cd(this.configuredCommandsHistoryLength, 1);
    if (t) {
      let n;
      t.usesLRU ? n = t.entries : n = t.entries.sort((s, o) => s.value - o.value), n.forEach((s) => i.set(s.key, s.value));
    }
    Ai.counter = this.storageService.getNumber(Ai.PREF_KEY_COUNTER, 0, Ai.counter);
  }
  push(e) {
    Ai.cache && (Ai.cache.set(e, Ai.counter++), Ai.hasChanges = !0);
  }
  peek(e) {
    var t;
    return (t = Ai.cache) === null || t === void 0 ? void 0 : t.peek(e);
  }
  saveState() {
    if (!Ai.cache || !Ai.hasChanges)
      return;
    const e = { usesLRU: !0, entries: [] };
    Ai.cache.forEach((t, i) => e.entries.push({ key: i, value: t })), this.storageService.store(
      Ai.PREF_KEY_CACHE,
      JSON.stringify(e),
      0,
      0
      /* StorageTarget.USER */
    ), this.storageService.store(
      Ai.PREF_KEY_COUNTER,
      Ai.counter,
      0,
      0
      /* StorageTarget.USER */
    ), Ai.hasChanges = !1;
  }
  static getConfiguredCommandHistoryLength(e) {
    var t, i;
    const s = (i = (t = e.getValue().workbench) === null || t === void 0 ? void 0 : t.commandPalette) === null || i === void 0 ? void 0 : i.history;
    return typeof s == "number" ? s : Ai.DEFAULT_COMMANDS_HISTORY_LENGTH;
  }
};
eh.DEFAULT_COMMANDS_HISTORY_LENGTH = 50;
eh.PREF_KEY_CACHE = "commandPalette.mru.cache";
eh.PREF_KEY_COUNTER = "commandPalette.mru.counter";
eh.counter = 1;
eh.hasChanges = !1;
eh = Ai = j$([
  Qd(0, br),
  Qd(1, Ge),
  Qd(2, Pn)
], eh);
class nCe extends qu {
  constructor(e, t, i, n, s, o) {
    super(e, t, i, n, s, o);
  }
  getCodeEditorCommandPicks() {
    var e;
    const t = this.activeTextEditorControl;
    if (!t)
      return [];
    const i = [];
    for (const n of t.getSupportedActions()) {
      let s;
      !((e = n.metadata) === null || e === void 0) && e.description && (Uie(n.metadata.description) ? s = n.metadata.description : s = { original: n.metadata.description, value: n.metadata.description }), i.push({
        commandId: n.id,
        commandAlias: n.alias,
        commandDescription: s,
        label: cM(n.label) || n.id
      });
    }
    return i;
  }
}
var sCe = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Eg = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
let ib = class extends nCe {
  get activeTextEditorControl() {
    var e;
    return (e = this.codeEditorService.getFocusedCodeEditor()) !== null && e !== void 0 ? e : void 0;
  }
  constructor(e, t, i, n, s, o) {
    super({ showAlias: !1 }, e, i, n, s, o), this.codeEditorService = t;
  }
  async getCommandPicks() {
    return this.getCodeEditorCommandPicks();
  }
  hasAdditionalCommandPicks() {
    return !1;
  }
  async getAdditionalCommandPicks() {
    return [];
  }
};
ib = sCe([
  Eg(0, be),
  Eg(1, ht),
  Eg(2, _t),
  Eg(3, $t),
  Eg(4, kn),
  Eg(5, wb)
], ib);
class Zb extends ae {
  constructor() {
    super({
      id: Zb.ID,
      label: $S.quickCommandActionLabel,
      alias: "Command Palette",
      precondition: void 0,
      kbOpts: {
        kbExpr: x.focus,
        primary: 59,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      contextMenuOpts: {
        group: "z_commands",
        order: 1
      }
    });
  }
  run(e) {
    e.get($o).quickAccess.show(ib.PREFIX);
  }
}
Zb.ID = "editor.action.quickCommand";
Y(Zb);
si.as(og.Quickaccess).registerQuickAccessProvider({
  ctor: ib,
  prefix: ib.PREFIX,
  helpEntries: [{ description: $S.quickCommandHelp, commandId: Zb.ID }]
});
var oCe = function(r, e, t, i) {
  var n = arguments.length, s = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(r, e, t, i);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (s = (n < 3 ? o(s) : n > 3 ? o(e, t, s) : o(e, t)) || s);
  return n > 3 && s && Object.defineProperty(e, t, s), s;
}, Tg = function(r, e) {
  return function(t, i) {
    e(t, i, r);
  };
};
let WN = class extends Gc {
  constructor(e, t, i, n, s, o, a) {
    super(!0, e, t, i, n, s, o, a);
  }
};
WN = oCe([
  Tg(1, De),
  Tg(2, ht),
  Tg(3, xi),
  Tg(4, be),
  Tg(5, br),
  Tg(6, Ge)
], WN);
gt(
  Gc.ID,
  WN,
  4
  /* EditorContributionInstantiation.Lazy */
);
class rCe extends ae {
  constructor() {
    super({
      id: "editor.action.toggleHighContrast",
      label: VI.toggleHighContrast,
      alias: "Toggle High Contrast Theme",
      precondition: void 0
    }), this._originalThemeName = null;
  }
  run(e, t) {
    const i = e.get(wo), n = i.getColorTheme();
    jr(n.type) ? (i.setTheme(this._originalThemeName || (jf(n.type) ? Nf : Wl)), this._originalThemeName = null) : (i.setTheme(jf(n.type) ? hu : uu), this._originalThemeName = n.themeName);
  }
}
Y(rCe);
function aCe(r) {
  return new Worker(
    "/assets/editor.worker-CRD3n8oc.js",
    {
      name: r == null ? void 0 : r.name
    }
  );
}
function lCe(r) {
  return new Worker(
    "/assets/ts.worker-D-ENfniO.js",
    {
      name: r == null ? void 0 : r.name
    }
  );
}
function dCe(r) {
  return new Worker(
    "/assets/json.worker-CaZqtpQK.js",
    {
      name: r == null ? void 0 : r.name
    }
  );
}
function cCe(r) {
  return new Worker(
    "/assets/css.worker-rxb0bYN-.js",
    {
      name: r == null ? void 0 : r.name
    }
  );
}
function hCe(r) {
  return new Worker(
    "/assets/html.worker-BV97uPRq.js",
    {
      name: r == null ? void 0 : r.name
    }
  );
}
window.MonacoEnvironment = {
  getWorker(r, e) {
    return e === "typescript" || e === "javascript" ? new lCe() : e === "json" ? new dCe() : e === "css" ? new cCe() : e === "html" ? new hCe() : new aCe();
  }
};
const q$ = G3.create(document.getElementById("code-editor"), {
  value: `
<shopify-collection handle="freestyle">
  <template name="loading"><div>Loading...</div></template>
  <template name="empty"><div>Collection doesn't exist</div></template>
  <template name="error"
    ><div>Error loading collection: {{message}}</div></template
  >
  <template>
    <div>
      <h1>{{ collection.title }}</h1>
      <p>{{ collection.description }}</p>
      <shopify-repeat type="collection.products" first="2">
        <template>
          <div>
            <h3>{{ product.title }}</h3>
            <p>{{ product.description }}</p>
            <shopify-repeat
              type="product.variants"
              first="2"
              style="display: flex"
            >
              <template>
                <div>
                  <h4>{{ variant.title }}</h4>
                  <div>
                    <img src="{{ variant.image.url }}" height="300" />
                  </div>
                  <div><button>Add to cart</button></div>
                </div>
              </template>
            </shopify-repeat>
          </div>
        </template>
      </shopify-repeat>
    </div>
  </template>
</shopify-collection>
    `.trim(),
  language: "html"
});
let zB;
q$.getModel().onDidChangeContent(G$);
G$();
function G$() {
  clearTimeout(zB), zB = setTimeout(() => {
    const e = `
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <script type="module" src="./dist/shopify-components.es.js"><\/script>
  </head>
  <body style="position: relative">
    ${q$.getModel().getValue()}
    <div
      style="
        right: 0;
        bottom: 0;
        position: fixed;
        width: 50%;
        height: 80px;
        overflow: auto;
        background-color: black;
        color: #ddd;
        padding: 12px;
        font-size: 12px;
        font-family: monospace;
      "
    >
      <div style="margin-bottom: 4px"><strong>GraphQL Query: </strong></div>
      <div id="query"></div>
    </div>
  </body>
</html>

    `, t = document.createElement("iframe");
    t.style.width = "100%", t.style.height = "100%", t.setAttribute("frameborder", "0"), document.getElementById("preview").replaceChild(t, document.getElementById("preview").firstChild), t.contentWindow.document.open(), t.contentWindow.document.write(e), t.contentWindow.document.close();
  }, 500);
}
export {
  Ab as m,
  uU as t
};
